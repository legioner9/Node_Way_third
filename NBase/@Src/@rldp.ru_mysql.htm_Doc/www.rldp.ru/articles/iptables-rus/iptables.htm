<html>
<head>
<meta name="generator" content= "HTML Tidy for Linux/x86 (vers 1st July 2002),
           see www.w3.org">
<title>Iptables Tutorial 1.1.19</title>
<meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
<meta name="GENERATOR" content="Modular DocBook HTML Stylesheet Version 1.64">
</head>

<body class="BOOK" bgcolor="#FFFFFF" text="#000000" link="#0000FF"
      vlink="#840084" alink="#0000FF">

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>


<a name="IPTABLES-TUTORIAL"></a>
<h1 class="TITLE"><a name="AEN2">Iptables Tutorial 1.1.19</a></h1>
<h3 class="AUTHOR"><a name="AEN4">Автор: Oskar Andreasson</a></h3>
<p class="ADDRESS">blueflux@koffein.net<br>
Copyright (C) 2001-2003 Oskar Andreasson<br></p>

<a name="AEN12"></a>
<a name="AEN18"></a><p>Последнюю англоязычную версию документа можно получить
по адресу: <a href="../../../iptables-tutorial.frozentux.net/default.htm" target="_top">
http://iptables-tutorial.frozentux.net</a>.</p>

<p>Данный документ подготовлен Алексеем Паутовым в рамках некоммерческого
проекта RussianLDP (<a href="../../default.htm" target="_top">
http://www.rldp.ru/</a>). Именно на этом сайте и надлежит искать новые
версии на русском языке.</p>

<p>Допускается копирование и/или модификация данного
документа или его части, в соответствии с соглашениями,
принятыми в GNU Free Documentation License, версии 1.1.
Неизменяемыми разделами являются раздел &quot;Введение&quot;
и все подразделы этого раздела, а также разделы,
начинающиеся словами &quot;Original Author: Oskar Andreasson&quot;,
Копия GNU Free Documentation License включена в данный документ и находится в
секции &quot;GNU Free Documentation License&quot;.</p>

<p>Все скрипты в данном руководстве подпадают под действие
GNU General Public License. Они являются свободно
распространяемыми и могут копироваться и/или модифицироваться
в соответствии с условиями GNU General Public License версии 2.</p>

<p>Скрипты распространяются в надежде на то, что они будут полезны Вам,
но БЕЗ КАКИХ-ЛИБО ГАРАНТИЙ. За дополнительной информацией
обращайтесь к тексту GNU General Public License.</p>

<p>С данным документом должна распространяться копия GNU
General Public License, в секции &quot;GNU General Public License&quot;,
в случае ее отсутствия Вы можете написать по
адресу Free Software Foundation, Inc., 59 Temple Place, Suite 330,
Boston, MA 02111-1307 USA</p>

<dl><dt><strong>Содержание</strong></dt>
<dt><a href="#AEN25">Посвящения</a></dt>
<dt><a href="#AEN29">Об авторе</a></dt>
<dt><a href="#HOWTOREAD">Как читать этот документ</a></dt>
<dt><a href="#PREREQUISITES">Предварительные условия</a></dt>
<dt><a href="#CONVENTIONSUSED">Типографские соглашения</a></dt>

<dt>1. <a href="#INTRODUCTION">Введение</a></dt>
<dd><dl><dt>1.1. <a href="#WHYTHISDOCUMENT">Почему было написано данное
руководство</a></dt>
<dt>1.2. <a href="#HOWITWAS">Как он был написан</a></dt>
<dt>1.3. <a href="#TERMSUSED">Термины, используемые в данном документе</a>
</dt></dl></dd>

<dt>2. <a href="#PREPARATIONS">Подготовка</a></dt>
<dd><dl><dt>2.1. <a href="#WHERETOGET">Где взять iptables</a></dt>
<dt>2.2. <a href="#KERNELSETUP">Настройка ядра</a></dt>
<dt>2.3. <a href="#USERLANDSETUP">Установка пакета</a></dt>
<dd><dl><dt>2.3.1. <a href="#COMPILINGUSERAPPS">Сборка пакета</a></dt>
<dt>2.3.2. <a href="#INSTALLRH71">Установка в Red Hat 7.1</a></dt>
</dl></dd></dl></dd>

<dt>3. <a href="#TRAVERSINGOFTABLES">Порядок прохождения таблиц и цепочек</a>
</dt>
<dd><dl><dt>3.1. <a href="#TRAVERSINGGENERAL">Общие положения</a></dt>
<dt>3.2. <a href="#MANGLETABLE">Таблица Mangle</a></dt>
<dt>3.3. <a href="#NATTABLE">Таблица Nat</a></dt>
<dt>3.4. <a href="#FILTERTABLE">Таблица Filter</a></dt></dl></dd>

<dt>4. <a href="#STATEMACHINE">Механизм определения состояний</a></dt>
<dd><dl><dt>4.1. <a href="#STATEMACHINEINTRODUCTION">Введение</a></dt>
<dt>4.2. <a href="#THECONNTRACKENTRIES">Таблица трассировщика</a></dt>
<dt>4.3. <a href="#USERLANDSTATES">Состояния в пространстве пользователя
</a></dt>
<dt>4.4. <a href="#TCPCONNECTIONS">TCP соединения</a></dt>
<dt>4.5. <a href="#UDPCONNECTIONS">UDP соединения</a></dt>
<dt>4.6. <a href="#ICMPCONNECTIONS">ICMP соединения</a></dt>
<dt>4.7. <a href="#DEFAULTCONNECTIONS">Поведение по умолчанию</a></dt>
<dt>4.8. <a href="#COMPLEXPROTOCOLS">Трассировка комплексных протоколов
</a></dt></dl></dd>

<dt>5. <a href="#SAVEANDRESTORE">Сохранение и восстановление больших
наборов правил</a></dt>
<dd><dl><dt>5.1. <a href="#SPEEDCONSIDERATIONS">Плюсы</a></dt>
<dt>5.2. <a href="#DRAWBACKSWITHRESTORE">И минусы</a></dt>
<dt>5.3. <a href="#IPTABLES-SAVE">iptables-save</a></dt>
<dt>5.4. <a href="#IPTABLES-RESTORE">iptables-restore</a></dt></dl></dd>

<dt>6. <a href="#HOWARULEISBUILT">Как строить правила</a></dt>
<dd><dl><dt>6.1. <a href="#BASICS">Основы</a></dt>
<dt>6.2. <a href="#TABLES">Таблицы</a></dt>
<dt>6.3. <a href="#COMMANDS">Команды</a></dt>
<dt>6.4. <a href="#MATCHES">Критерии</a></dt>
<dd><dl><dt>6.4.1. <a href="#GENERICMATCHES">Общие критерии</a></dt>
<dt>6.4.2. <a href="#IMPLICITMATCHES">Неявные критерии</a></dt>
<dt>6.4.3. <a href="#EXPLICITMATCHES">Явные критерии</a></dt>
<dt>6.4.4. <a href="#UNCLEANMATCH">Критерий &quot;мусора&quot;
(Unclean match)</a></dt></dl></dd>
<dt>6.5. <a href="#TARGETS">Действия и переходы</a></dt>
<dd><dl><dt>6.5.1. <a href="#ACCEPTTARGET">Действие ACCEPT</a></dt>
<dt>6.5.2. <a href="#DNATTARGET">Действие DNAT</a></dt>
<dt>6.5.3. <a href="#DROPTARGET">Действие DROP</a></dt>
<dt>6.5.4. <a href="#LOGTARGET">Действие LOG</a></dt>
<dt>6.5.5. <a href="#MARKTARGET">Действие MARK</a></dt>
<dt>6.5.6. <a href="#MASQUERADETARGET">Действие MASQUERADE</a></dt>
<dt>6.5.7. <a href="#MIRRORTARGET">Действие MIRROR</a></dt>
<dt>6.5.8. <a href="#QUEUETARGET">Действие QUEUE</a></dt>
<dt>6.5.9. <a href="#REDIRECTTARGET">Действие REDIRECT</a></dt>
<dt>6.5.10. <a href="#REJECTTARGET">Действие REJECT</a></dt>
<dt>6.5.11. <a href="#RETURNTARGET">Действие RETURN</a></dt>
<dt>6.5.12. <a href="#SNATTARGET">Действие SNAT</a></dt>
<dt>6.5.13. <a href="#TOSTARGET">Действие TOS</a></dt>
<dt>6.5.14. <a href="#TTLTARGET">Действие TTL</a></dt>
<dt>6.5.15. <a href="#ULOGTARGET">Действие ULOG</a></dt></dl></dd></dl></dd>

<dt>7. <a href="#RCFIREWALLFILE">Файл rc.firewall</a></dt>
<dd><dl><dt>7.1. <a href="#EXAMPLERCFIREWALL">Пример rc.firewall</a></dt>
<dt>7.2. <a href="#EXPLANATIONOFRCFIREWALL">Описание скрипта
rc.firewall</a></dt>
<dd><dl><dt>7.2.1. <a href="#CONFIGOPTIONS">Конфигурация</a></dt>
<dt>7.2.2. <a href="#INITIALLOADING">Загрузка дополнительных модулей</a></dt>
<dt>7.2.3. <a href="#PROCSETUP">Настройка /proc</a></dt>
<dt>7.2.4. <a href="#DISPLACEMENT">Размещение правил по разным цепочкам</a>
</dt>
<dt>7.2.5. <a href="#DEFAULTPOLICIES">Установка политик по умолчанию</a></dt>
<dt>7.2.6. <a href="#SETTINGUPUSER">
Создание пользовательских цепочек в таблице filter</a></dt>
<dt>7.2.7. <a href="#INPUTCHAIN">Цепочка INPUT</a></dt>
<dt>7.2.8. <a href="#FORWARDCHAIN">Цепочка FORWARD</a></dt>
<dt>7.2.9. <a href="#OUTPUTCHAIN">Цепочка OUTPUT</a></dt>
<dt>7.2.10. <a href="#PREROUTINGCHAIN">Цепочка PREROUTING таблицы nat</a></dt>
<dt>7.2.11. <a href="#STARTINGSNAT">Запуск SNAT и цепочка POSTROUTING</a>
</dt></dl></dd></dl></dd>

<dt>8. <a href="glava08.htm#EXAMPLESCRIPTS">Примеры скриптов</a></dt>
<dd><dl><dt>8.1. <a href="glava08.htm#FIREWALLTXTSCRIPTSTRUCTURE">
Структура файла rc.firewall.txt</a></dt>
<dd><dl><dt>8.1.1. <a href="glava08.htm#THESTRUCTURE">Структура</a></dt></dl>
</dd>
<dt>8.2. <a href="glava08.htm#RCFIREWALLTXT">rc.firewall.txt</a></dt>
<dt>8.3. <a href="glava08.htm#RCDMZFIREWALLTXT">rc.DMZ.firewall.txt</a></dt>
<dt>8.4. <a href="glava08.htm#RCDHCPFIREWALLTXT">rc.DHCP.firewall.txt</a></dt>
<dt>8.5. <a href="glava08.htm#RCUTINFIREWALLTXT">rc.UTIN.firewall.txt</a></dt>
<dt>8.6. <a href="glava08.htm#RCTEST-IPTABLESTXT">rc.test-iptables.txt</a></dt>
<dt>8.7. <a href="glava08.htm#RCFLUSH-IPTABLESTXT">rc.flush-iptables.txt</a>
</dt>
<dt>8.8. <a href="glava08.htm#LIMIT-MATCHTXT">Limit-match.txt</a></dt>
<dt>8.9. <a href="glava08.htm#PID-OWNERTXT">Pid-owner.txt</a></dt>
<dt>8.10. <a href="glava08.htm#SID-OWNERTXT">Sid-owner.txt</a></dt>
<dt>8.11. <a href="glava08.htm#TTL-INCTXT">Ttl-inc.txt</a></dt>
<dt>8.12. <a href="glava08.htm#IPTSAVE-RULESET">Iptables-save ruleset</a>
</dt></dl></dd>

<dt>A. <a href="commands.htm#DETAILEDEXPLANATIONS">
Детальное описание специальных команд</a></dt>
<dd><dl><dt>A.1. <a href="commands.htm#LISTINGRULESET">Вывод списка правил
</a></dt>
<dt>A.2. <a href="commands.htm#UPDATINGTABLES">
Изменение и очистка Ваших таблиц</a></dt></dl></dd>

<dt>B. <a href="problems.htm#COMMONPROBLEMS">Общие проблемы и вопросы</a></dt>
<dd><dl><dt>B.1. <a href="problems.htm#MODULEPROBLEMS">
Проблемы загрузки модулей</a></dt>
<dt>B.2. <a href="problems.htm#NEWNOTSYN">Пакеты со статусом NEW и со
сброшенным битом SYN</a></dt>
<dt>B.3. <a href="problems.htm#SYNACKANDNEW">SYN/ACK-пакеты и пакеты
со статусом NEW</a></dt>
<dt>B.4. <a href="problems.htm#ISPWHOUSEASSIGNEDIP">
Поставщики услуг Internet, использующие зарезервированные IP-адреса</a></dt>
<dt>B.5. <a href="problems.htm#LETTINGDHCPREQUESTS">Как разрешить прохождение
DHCP-запросов через iptables</a></dt>
<dt>B.6. <a href="problems.htm#MIRCDCC">Проблемы mIRC DCC</a></dt></dl></dd>

<dt>C. <a href="typeicmp.htm#ICMPTYPES">Типы ICMP</a></dt>
<dt>D. <a href="links.htm#OTHERRESOURCES">Ссылки на другие ресурсы</a></dt>
<dt>E. <a href="thanktoy.htm#ACKNOWLEDGEMENTS">Благодарности</a></dt>
<dt>F. <a href="hrono.htm#HISTORY">Хронология</a></dt>

<dt>G. <a href="gfdl.htm#GFDL">GNU Free Documentation License</a></dt>
<dd><dl><dt>0. <a href="gfdl.htm#AEN4169">PREAMBLE</a></dt>
<dt>1. <a href="gfdl.htm#APPLICABILITY">APPLICABILITY AND DEFINITIONS</a></dt>
<dt>2. <a href="gfdl.htm#VERBATIM">VERBATIM COPYING</a></dt>
<dt>3. <a href="gfdl.htm#COPYING">COPYING IN QUANTITY</a></dt>
<dt>4. <a href="gfdl.htm#MODIFICATIONS">MODIFICATIONS</a></dt>
<dt>5. <a href="gfdl.htm#COMBININGDOCS">COMBINING DOCUMENTS</a></dt>
<dt>6. <a href="gfdl.htm#COLLECTIONSOFDOCS">COLLECTIONS OF DOCUMENTS</a></dt>
<dt>7. <a href="gfdl.htm#AGGREGATION">AGGREGATION WITH INDEPENDENT WORKS</a></dt>
<dt>8. <a href="gfdl.htm#TRANSLATION">TRANSLATION</a></dt>
<dt>9. <a href="gfdl.htm#TERMINATION">TERMINATION</a></dt>
<dt>10. <a href="gfdl.htm#FUTUREREVISIONS">FUTURE REVISIONS OF THIS LICENSE
</a></dt>
<dt><a href="gfdl.htm#HOWTOUSETHISLICENSE">How to use this License
for your documents</a></dt></dl></dd>

<dt>H. <a href="gpl.htm#GPL">GNU General Public License</a></dt>
<dd><dl><dt>0. <a href="gpl.htm#AEN4266">Preamble</a></dt>
<dt>1. <a href="gpl.htm#GPLTERMSANDCONDITIONS">
TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</a></dt>
<dt>2. <a href="gpl.htm#GPLHOWTOAPPLY">How to Apply These Terms to
Your New Programs</a></dt></dl></dd>

<dt>I. <a href="#EXAMPLECODE">Примеры скриптов</a></dt>
<dd><dl><dt>I.1. <a href="exam1.htm#INCLUDE.RCFIREWALL">Пример rc.firewall
</a></dt>
<dt>I.2. <a href="exam2.htm#INCLUDE.RCDMZFIREWALL">Пример rc.DMZ.firewall</a>
</dt>
<dt>I.3. <a href="exam3.htm#INCLUDE.RCUTINFIREWALL">Пример rc.UTIN.firewall
</a></dt>
<dt>I.4. <a href="exam4.htm#INCLUDE.RCDHCPFIREWALL">Пример rc.DHCP.firewall
</a></dt>
<dt>I.5. <a href="exam5.htm#INCLUDE.FLUSHIPTABLES">Пример rc.flush-iptables
</a></dt>
<dt>I.6. <a href="exam6.htm#INCLUDE.TESTTABLES">Пример rc.test-iptables</a>
</dt></dl></dd></dl>

<dl class="LOT"><dt><strong>Перечень таблиц</strong></dt>
<dt>3-1. <a href="#TABLE.FORWARDEDPACKETS">Порядок движения транзитных
пакетов</a></dt>
<dt>3-2. <a href="#TABLE.DESTINATIONLOCALHOST">Для локального приложения</a>
</dt>
<dt>3-3. <a href="#TABLE.SOURCELOCALHOST">От локальных процессов</a></dt>
<dt>4-1. <a href="#TABLE.USERLANDSTATES">Перечень состояний в
пространстве пользователя</a></dt>
<dt>4-2. <a href="#TABLE.INTERNALSTATES">Internal states</a></dt>
<dt>6-1. <a href="#TABLE.TABLES">Таблицы</a></dt>
<dt>6-2. <a href="#TABLE.COMMANDS">Команды</a></dt>
<dt>6-3. <a href="#TABLE.OPTIONS">Дополнительные ключи</a></dt>
<dt>6-4. <a href="#TABLE.GENERICMATCHES">Общие критерии</a></dt>
<dt>6-5. <a href="#TABLE.TCPMATCHES">TCP критерии</a></dt>
<dt>6-6. <a href="#TABLE.UDPMATCHES">UDP критерии</a></dt>
<dt>6-7. <a href="#TABLE.ICMPMATCHES">ICMP критерии</a></dt>
<dt>6-8. <a href="#TABLE.LIMITMATCH">Ключи критерия limit</a></dt>
<dt>6-9. <a href="#TABLE.MACMATCH">Ключи критерия MAC</a></dt>
<dt>6-10. <a href="#TABLE.MARKMATCH">Ключи критерия Mark</a></dt>
<dt>6-11. <a href="#TABLE.MULTIPORTMATCH">Ключи критерия Multiport</a></dt>
<dt>6-12. <a href="#TABLE.OWNERMATCH">Ключи критерия Owner</a></dt>
<dt>6-13. <a href="#TABLE.STATEMATCHES">Ключи критерия State</a></dt>
<dt>6-14. <a href="#TABLE.TOSMATCHES">Ключи критерия TOS</a></dt>
<dt>6-15. <a href="#TABLE.TTLMATCHES">Ключи критерия TTL</a></dt>
<dt>6-16. <a href="#TABLE.DNATTARGET">Действие DNAT</a></dt>
<dt>6-17. <a href="#TABLE.LOGTARGET">Ключи действия LOG</a></dt>
<dt>6-18. <a href="#TABLE.MARKTARGET">Ключи действия MARK</a></dt>
<dt>6-19. <a href="#TABLE.MASQUERADETARGET">Действие MASQUERADE</a></dt>
<dt>6-20. <a href="#TABLE.REDIRECTTARGET">Действие REDIRECT</a></dt>
<dt>6-21. <a href="#TABLE.REJECTTARGET">Действие REJECT</a></dt>
<dt>6-22. <a href="#TABLE.SNATTARGET">Действие SNAT</a></dt>
<dt>6-23. <a href="#TABLE.TOSTARGET">Действие TOS</a></dt>
<dt>6-24. <a href="#TABLE.TTLTARGET">Действие TTL</a></dt>
<dt>6-25. <a href="#TABLE.ULOGTARGET">Действие ULOG</a></dt>
<dt>C-1. <a href="typeicmp.htm#TABLE.ICMPTYPES">Типы ICMP</a></dt></dl><hr>

<h1><a name="AEN25">Посвящения</a></h1>
<p>Прежде всего, я хотел бы посвятить данный документ моей
замечательной подруге Нинель (Ninel). Она поддерживает меня
больше, чем я когда-либо смогу поддержать ее.</p>
<p>Во-вторых, всем разработчикам Linux, сделавшим эту
замечательную операционную систему, за их невероятно напряженный труд.</p>

<hr><h1><a name="AEN29">Об авторе</a></h1>
<p>Я человек, который имеет на своем попечении достаточно много
стареньких компьютеров, объединенных мною в локальную сеть с
выходом в Интернет, и обеспечивающую их безопасность.
И в этом отношении переход от ipchains к iptables является оправданным.
Ранее для повышения безопасности своей сети, Вы могли отсекать
все пакеты, закрывая определенные порты, однако это порождало
проблемы с пассивным <em class="EMPHASIS">FTP</em> (passive FTP) или
исходящим <em class="EMPHASIS">DCC</em> в <em class="EMPHASIS">IRC</em>
(outgoing DCC in IRC), для которых порты на сервере назначаются динамически и
потом сообщаются клиенту для выполнения соединения.
В самом начале я столкнулся с некоторыми &#39;болезнями&#39;,
перекочевавшими из ipchains, и считал код iptables не совсем
готовым к окончательному выпуску. Сегодня же я мог бы порекомендовать всем,
кто использует в своей работе ipchains и ipfwadm
&#39;пересесть&#39; на iptables!</p>

<hr><h1><a name="HOWTOREAD">Как читать этот документ</a></h1>
<p>Этот документ написан так, чтобы облегчить читателям
понимание замечательного мира iptables. Здесь Вы не найдете
информации об ошибках в iptables или в netfilter. Если Вы столкнетесь с ними,
то можете связяться с командой разработчиков, а они в ответ могут сообщить
Вам, действительно ли существует такая ошибка. На сегодняшний день iptables
и netfilter практически не содержат ошибок, хотя изредка одна-две
&quot;проскакивают&quot;. Информация о таких ошибках обязательно появляется
на <a href="../../../www.netfilter.org/default.htm" target="_top">
главной странице проекта Netfilter</a>.</p>

<p>Вышесказанное также означает, что при написании наборов
правил, прилагаемых к данному руководству, не учитывалось
возможное наличие каких-либо ошибок внутри netfilter.
Основная цель примеров: показать порядок написания набора правил и
проблемы, с которыми Вы можете столкнуться. Например, в этом документе не
поясняется, как закрыть уязвимость Apache 1.2.12 на HTTP-порте
(в примерах Вы найдете, как закрыть этот порт, но по другой причине).</p>

<p>Этот документ был написан с целью дать начинающим хороший,
простой и в то же время достаточно полный учебник по iptables.
Он не содержит информации по действиям и критериям из
patch-o-matic по той простой причине, что потребовалось бы
слишком много усилий, чтобы запомнить весь список изменений.
Если у Вас возникнет необходимость в получении информации по
модификациям patch-o-matic, то Вам следует обращаться к
документации, которая сопровождает конкретный patch-o-matic,
она доступна на <a href="../../../www.netfilter.org/default.htm" target="_top">
главной странице проекта Netfilter</a>.</p>

<hr><h1><a name="PREREQUISITES">Предварительные условия</a></h1>
<p>Данное руководство предполагает наличие у читателя начальных
сведений о Linux/Unix, языке скриптов командной оболочки.
Кроме того, Вы должны знать как пересобрать ядро операционной
системы и иметь некоторое представление о его внутреннем устройстве.</p>

<p>Я постарался, насколько это возможно, сделать документ
доступным для понимания как можно более широкому кругу
читателей, однако я не всесилен, и поэтому от Вас все-таки
потребуется наличие некоторых познаний.</p>

<hr><h1><a name="CONVENTIONSUSED">Типографские соглашения</a></h1>
<p>В данном документе приняты следующие соглашения по выделению
информации различного рода:</p>
<ul><li style="list-style-type: disc">
<p>Команды, вводимые пользователем, и вывод, получаемый в
результате работы команд, отображаются моноширинным шрифтом, кроме того,
ввод пользователя отображается жирным шрифтом:</p>
<pre class="SCREEN">
[blueflux@work1 neigh]$ <strong class="COMMAND">ls</strong>
defaulteth0lo
[blueflux@work1 neigh]$
</pre></li>

<li style="list-style-type: disc">
<p>Все команды и имена программ отображаются
<strong class="COMMAND">жирным шрифтом</strong>.</p></li>

<li style="list-style-type: disc">
<p>Все упоминания об аппаратном обеспечении, а также о внутренних механизмах
ядра или абстрактных понятиях системы (например, кольцевой (loopback)
интерфейс), отображаются <em class="EMPHASIS">курсивом</em>.</p></li>

<li style="list-style-type: disc">
<p>Имена файлов и пути к файлам отображаются таким образом:
<tt class="FILENAME">/usr/local/bin/iptables</tt>.</p></li></ul>

<hr><h1><a name="INTRODUCTION">Глава 1. Введение</a></h1>
<h1 class="SECTION"><a name="WHYTHISDOCUMENT">
1.1. Почему было написано данное руководство</a></h1>
<p>Скажем так, я посчитал, что существует досадный пробел в
HOWTO по части информации об iptables и функциях сетевого
фильтра (netfilter), реализованных в новой серии ядер 2.4.x Linux.
Кроме всего прочего, я попытался ответить на некоторые
вопросы по поводу новых возможностей, например, проверки
состояния пакетов (state matching). Большинство из них
проиллюстрированы в файле скрипта
<a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt</em></a>, который
Вы можете вставить в <tt class="FILENAME">/etc/rc.d/</tt>.
Для тех, кому интересно, готов сообщить, что этот файл первоначально был
основан на masquerading HOWTO.</p>

<p>Там же Вы найдете небольшой скрипт
<a href="glava08.htm#RCFLUSH-IPTABLESTXT"><em>rc.flush-iptables.txt</em></a>,
написанный мною, который Вы можете использовать для своих нужд,
при необходимости расширяя под свою конфигурацию.</p>

<hr><h1 class="SECTION"><a name="HOWITWAS">1.2. Как он был написан</a></h1>
<p>Я консультировался с Марком Бучером (Marc Boucher) и
другими членами команды разработчиков netfilter. Пользуясь
случаем, выражаю огромную признательность за их помощь в
создании данного руководства, которое изначально было
написано для boingworld.com, а теперь доступно на моем
персональном сайте frozentux.net. С помощью этого документа
Вы пройдете процесс настройки шаг за шагом и, надеюсь, что к
концу изучения его Вы будете знать о пакете iptables значительно больше.
Большая часть материала базируется на
файле rc.firewall.txt, так как я считаю, что рассмотрение
примера лучший способ изучения iptables. Я пройду по основным цепочкам правил
в порядке их следования. Это несколько усложняет изучение,
зато изложение становится логичнее. И всякий раз, когда у Вас возникнут
затруднения, можете обращаться к этому руководству.</p>

<hr><h1 class="SECTION"><a name="TERMSUSED">
1.3. Термины, используемые в данном документе</a></h1>
<p>Этот документ содержит несколько терминов, которые следует
пояснить прежде, чем Вы столкнетесь с ними.</p>

<p>DNAT от англ. Destination Network Address Translation:
Изменение Сетевого Адреса Получателя. DNAT это изменение адреса
назначения в заголовке пакета. Зачастую используется в паре с SNAT.
Основное применение: использование единственного реального IP-адреса
несколькими компьютерами для выхода в Интернет и предоставления
дополнительных сетевых услуг внешним клиентам.</p>

<p>&quot;Поток&quot; (Stream): под этим термином
подразумевается соединение, через которое передаются и принимаются пакеты.
Я использовал этот термин для обозначения соединений, через которые
передается по меньшей мере 2 пакета в обоих направлениях. В случае TCP это
может означать соединение, через которое передается SYN-пакет и затем
принимается SYN/ACK-пакет. Но это также может подразумевать
передачу SYN-пакета и прием сообщения ICMP Host unreachable.
Другими словами, я использую этот термин в
достаточно широком диапазоне применений.</p>

<p>SNAT от англ. Source Network Address Translation:
Изменение Сетевого Адреса Отправителя. SNAT это изменение
исходного адреса в заголовке пакета. Основное применение: использование
единственного реального IP-адреса несколькими компьютерами
для выхода в Интернет. В настоящее время диапазон
реальных IP-адресов по стандарту IPv4 недостаточно широк, и
его не хватает на всех (переход на IPv6 разрешит эту проблему).</p>

<p>&quot;Состояние&quot; (State): под этим термином
подразумевается состояние, в котором находится пакет,
согласно RFC 793 <a href="links.htm#RFC793"><em>Transmission Control Protocol
</em></a>, а также трактовкам, используемым в netfilter/iptables.
Хочу обратить Ваше внимание на тот факт, что определения состояний пакетов,
как для внутренних, так и для внешних состояний, используемые Netfilter,
не полностью соответствуют указанному выше RFC 793.</p>

<p>&quot;Пространство пользователя&quot; (User space): под этим термином я
подразумеваю все, что расположено за пределами ядра, например,
команда <strong class="COMMAND">iptables -h</strong> выполняется за
пределами ядра в то время, как команда <strong class="COMMAND">iptables -A
FORWARD -p tcp -j ACCEPT</strong> выполняется (частично) в пространстве ядра,
поскольку она добавляет новое правило к имеющемуся набору.</p>

<p>&quot;Пространство ядра&quot; (Kernel space): в большей или меньшей
степени является утверждением, обратным термину
&quot;Пространство пользователя&quot;.
Подразумевает место исполнения в пределах ядра.</p>
<p>&quot;Userland&quot; см. &quot;Пространство пользователя&quot;.</p>

<hr><h1><a name="PREPARATIONS">Глава 2. Подготовка</a></h1>
<p>Целью данной главы является оказание помощи в понимании той
роли, которую netfilter и <strong class="COMMAND">iptables</strong>
играют в Linux сегодня. Также она должна помочь установить и настроить
межсетевой экран (firewall).</p>

<hr><h1 class="SECTION"><a name="WHERETOGET">2.1. Где взять iptables</a></h1>
<p>Пакеты <strong class="COMMAND">iptables</strong> могут быть загружены с
домашней страницы <a href="../../../netfilter.samba.org/default.htm"
target="_top">проекта Netfilter</a>. Кроме того, для работы iptables
соответствующим образом должно быть сконфигурировано
ядро Вашей Linux-системы. Настройка ядра будет обсуждаться ниже.</p>

<hr><h1 class="SECTION"><a name="KERNELSETUP">2.2. Настройка ядра</a></h1>
<p>Для обеспечения базовых возможностей <strong class="COMMAND">iptables
</strong>, с помощью утилиты <strong class="COMMAND">make config</strong>
или ей подобных (<strong class="COMMAND">make menuconfig</strong> или
<strong class="COMMAND">make xconfig</strong>), в ядро должны быть
включены следующие опции:</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_PACKET</tt>: Эта опция необходима для
приложений, работающих непосредственно с
сетевыми устройствами, например, tcpdump или snort.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Строго говоря, опция CONFIG_PACKET
не требуется для работы iptables, но, поскольку она используется
довольно часто, я включил ее в список. Если Вам эта опция не нужна,
то можете ее не включать.</p></td></tr></table>

<p><tt class="COMPUTEROUTPUT">CONFIG_NETFILTER</tt>: Эта опция необходима,
если Вы собираетесь использовать компьютер в качестве сетевого экрана
(firewall) или шлюза (gateway) в Интернет. Другими словами, Вам она
определенно понадобится, иначе зачем тогда читать это руководство!</p>

<p>И конечно нужно добавить драйверы для Ваших устройств,
то есть для карты Ethernet, <em class="EMPHASIS">PPP</em> и
<em class="EMPHASIS">SLIP</em>. Эти опции необходимы для
обеспечения базовых возможностей <strong class="COMMAND">iptables</strong>,
для получения дополнительных возможностей придется включить в ядро
некоторые дополнительные опции. Ниже приводится список опций
для ядра 2.4.9 и их краткое описание:</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_CONNTRACK</tt>:
Трассировка соединений. Трассировка соединений, среди всего прочего,
используется при трансляции сетевых адресов и маскарадинге
(<em class="EMPHASIS">NAT</em> и <em class="EMPHASIS">Masquerading</em>).
Если Вы собираетесь строить сетевой экран (firewall) для локальной сети,
то Вам определенно потребуется эта опция. К примеру, этот модуль необходим
для работы <a href="glava08.htmRCFIREWALLTXT#RCFIREWALLTXT"><em>
rc.firewall.txt</em></a>.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_FTP</tt>:
Трассировка FTP-соединений. Обмен по FTP идет слишком интенсивно, чтобы
использовать обычные методы трассировки. Если не добавить этот модуль,
то Вы столкнетесь с трудностями при передаче
протокола FTP через сетевой экран (firewall).</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_IPTABLES</tt>:
Эта опция необходима для выполнения операций фильтрации,
преобразования сетевых адресов (NAT) и маскарадинга (masquerading).
Без нее Вы вообще ничего не сможете делать с iptables.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_LIMIT</tt>:
Этот модуль необязателен, однако он используется в примерах
<a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt</em></a>.
Он предоставляет возможность ограничения количества проверок
для некоторого правила. Например, <strong class="COMMAND">-m limit --limit
3/minute</strong> указывает, что заданное правило может пропустить
не более 3 пакетов в минуту. Таким образом, данный модуль может
использоваться для защиты от нападений типа &quot;Отказ в обслуживании&quot;.
</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_MAC</tt>:
Этот модуль позволит строить правила, основанные на
<em class="EMPHASIS">MAC</em>-адресации. Как известно, каждая
сетевая карта имеет свой собственный уникальный
Ethernet-адрес, таким образом, существует возможность
блокировать пакеты, поступающие с определенных
<em class="EMPHASIS">MAC</em>-адресов (с определенных сетевых карт).
Следует, однако, отметить что данный модуль не используется в
<a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt</em></a> или где-либо
еще в данном руководстве.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_MARK</tt>:
Функция маркировки пакетов <strong class="COMMAND">MARK</strong>.
Например, при использовании функции <strong class="COMMAND">MARK</strong> мы
получаем возможность пометить требуемые пакеты, а затем, в других таблицах,
в зависимости от значения метки, принимать решение о
маршрутизации помеченного пакета. Более подробное описание
функции <strong class="COMMAND">MARK</strong> приводится
ниже в данном документе.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_MULTIPORT</tt>:
Этот модуль позволит строить правила с проверкой на
принадлежность пакета к диапазону номеров портов источника/приемника.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_TOS</tt>:
Этот модуль позволит строить правила, отталкиваясь от состояния поля
<em class="EMPHASIS">TOS</em> в пакете. Поле <em  class="EMPHASIS">TOS</em>
устанавливается для Type Of Service. Также становится возможным устанавливать
и сбрасывать биты этого поля в собственных правилах в таблице
<em class="EMPHASIS">mangle</em> или командами ip/tc.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_TCPMSS</tt>:
Эта опция добавляет возможность проверки поля <em class="EMPHASIS">MSS</em> в
<em class="EMPHASIS">TCP</em>-пакетах.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_STATE</tt>:
Это одно из самых серьезных усовершенствований по сравнению с
<strong class="COMMAND">ipchains</strong>. Этот модуль предоставляет
возможность управления <em class="EMPHASIS">TCP</em>-пакетами, основываясь на
их состоянии (state). К примеру, допустим, что мы имеем
установленное TCP-соединение, с трафиком в оба конца, тогда пакет полученный
по такому соединению будет считаться
<strong class="COMMAND">ESTABLISHED</strong> (установленное соединение).
Эта возможность широко используется в примере
<a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt</em></a>.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_UNCLEAN</tt>:
Этот модуль реализует возможность дополнительной проверки
<em class="EMPHASIS">IP</em>, <em class="EMPHASIS">TCP</em>,
<em class="EMPHASIS">UDP</em> и <em class="EMPHASIS">ICMP</em>-пакетов
на предмет наличия в них несоответствий, &quot;странностей&quot;, ошибок.
Установив его мы, к примеру, получим возможность &quot;отсекать&quot;
подобного рода пакеты. Однако хочется отметить, что данный
модуль пока находится на экспериментальной стадии и не во всех случаях
будет работать одинаково, поэтому никогда нельзя будет быть уверенным,
что мы не &quot;сбросили&quot; вполне правильные пакеты.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_MATCH_OWNER</tt>:
Проверка &quot;владельца&quot; соединения (socket). Для примера, мы можем
позволить только пользователю root выходить в Internet.
Этот модуль был написан как пример работы с <strong class="COMMAND">iptables
</strong>. Следует заметить, что данный модуль имеет статус
экспериментального и может не всегда выполнять свои функции.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_FILTER</tt>:
Реализация таблицы <em class="EMPHASIS">filter</em>, в которой в
основном и осуществляется фильтрация. В данной таблице находятся цепочки
<em class="EMPHASIS">INPUT</em>, <em class="EMPHASIS">FORWARD</em> и
<em class="EMPHASIS">OUTPUT</em>. Этот модуль обязателен, если
Вы планируете осуществлять фильтрацию пакетов.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_TARGET_REJECT</tt>:
Добавляется действие <em class="EMPHASIS">REJECT</em>, которое производит
передачу <em class="EMPHASIS">ICMP</em>-сообщения об ошибке в ответ на
входящий пакет, который отвергается заданным правилом.
Запомните, что <em class="EMPHASIS">TCP</em>-соединения, в отличие от
<em class="EMPHASIS">UDP</em> и <em class="EMPHASIS">ICMP</em>,
всегда завершаются или отвергаются пакетом <em class="EMPHASIS">TCP RST</em>.
</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_TARGET_MIRROR</tt>:
Возможность отправки полученного пакета обратно (отражение).
Например, если назначить действие <em class="EMPHASIS">MIRROR</em>
для пакетов, идущих в порт <em class="EMPHASIS">HTTP</em> через нашу цепочку
<em class="EMPHASIS">INPUT</em> (на наш WEB-сервер),
то пакет будет отправлен обратно (отражен), в результате отправитель увидит
свою собственную домашнюю страничку. Суть сводится к тому, что с точки зрения
отправителя все выглядит так, как будто бы пакет он отправил на свою
собственную машину, а проще говоря, действие <em class="EMPHASIS">MIRROR</em>
меняет местами адреса отправителя и получателя, после чего выдает
измененный пекет в сеть.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_NAT</tt>:
Трансляция сетевых адресов в различных ее видах. С помощью этой опции Вы
сможете дать выход в Интернет всем компьютерам Вашей
локальной сети, имея лишь один уникальный IP-адрес. Эта опция необходима
для работы примера <a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt</em></a>.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_TARGET_MASQUERADE</tt>:
Маскарадинг. В отличие от NAT, маскарадинг используется в тех
случаях, когда заранее неизвестен наш IP-адрес в Интернете,
то есть для случаев <em class="EMPHASIS">DHCP</em>,
<em class="EMPHASIS">PPP</em>, <em class="EMPHASIS">SLIP</em> или какого-либо
другого способа подключения, подразумевающего динамическое
получение IP-адреса. Маскарадинг дает несколько более высокую нагрузку
на компьютер, по сравнению с NAT, однако он работает в ситуациях,
когда невозможно заранее указать собственный внешний IP-адрес.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_TARGET_REDIRECT</tt>:
Перенаправление. Обычно это действие используется совместно с
<em class="EMPHASIS">проксированием</em>. Вместо того, чтобы
просто пропустить пакет дальше, это действие перенаправляет
пакет на другой порт сетевого экрана (прокси-серверу).
Другими словами, таким способом мы можем выполнять
<em class="EMPHASIS">&quot;прозрачное проксирование&quot;</em>.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_TARGET_LOG</tt>:
Добавляет действие <strong class="COMMAND">LOG</strong> в
<strong class="COMMAND">iptables</strong>. Мы можем использовать
этот модуль для фиксации отдельных пакетов в системном журнале (syslog).
Эта возможность может оказаться весьма полезной при отладке скриптов.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_TARGET_TCPMSS</tt>:
Эта опция может использоваться для преодоления ограничений,
накладываемых некоторыми провайдерами, которые блокируют
<em class="EMPHASIS">ICMP Fragmentation Needed</em>-пакеты.
В результате таких ограничений серверы провайдеров могут не
передавать web-страницы, ssh может работать в то время, как scp обрывается
после установления соединения и пр. Для преодоления подобного рода
ограничений мы можем использовать действие <em class="EMPHASIS">TCPMSS</em>
ограничивая значение <em class="EMPHASIS">MSS</em> (Maximum Segment Size)
(обычно MSS ограничивается размером MTU исходящего интерфейса минус 40 байт).
Таким образом мы получаем возможность преодолеть то, что авторы netfilter
называют &quot;преступной безмозглостью провайдеров или серверов&quot;
(&quot;criminally braindead ISPs or servers&quot;) в справке
по конфигурации ядра.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_COMPAT_IPCHAINS</tt>:
Добавляет совместимость с более старой технологией <strong class="COMMAND">
ipchains</strong>. Вполне возможно, что
подобного рода совместимость будет сохранена и в ядрах серии 2.6.x.</p>

<p><tt class="COMPUTEROUTPUT">CONFIG_IP_NF_COMPAT_IPFWADM</tt>:
Добавляет совместимость с <strong class="COMMAND">ipfwadm</strong>,
несмотря на то, что это очень старое средство построения брандмауэров.</p>

<p>Как вы можете видеть, я дал краткую характеристику каждому модулю.
Данные опции доступны в ядре версии 2.4.9. Если потребуются дополнительные
возможности, советую обратить внимание на расширения
<em class="EMPHASIS">patch-o-matic</em>, которые добавляют достаточно большое
количество дополнительных функций к
<em class="EMPHASIS">Netfilter</em>. <em class="EMPHASIS">Patch-o-matic</em>
это набор дополнений, которые, как предполагается,
в будущем будут включены в состав ядра.</p>

<p>Для работы сценария <a href="glava08.htm#RCFIREWALLTXT"><em>
rc.firewall.txt</em></a>
Вам необходимо будет добавить в ядро следующие опции или собрать
соответствующие подгружаемые модули. За информацией по опциям,
необходимым для работы других скриптов, обращайтесь
к приложению с примерами этих скриптов.</p>

<ul><li style="list-style-type: opencircle"><p>CONFIG_PACKET</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_NETFILTER</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_CONNTRACK</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_FTP</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_IRC</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_IPTABLES</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_FILTER</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_NAT</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_MATCH_STATE</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_TARGET_LOG</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_MATCH_LIMIT</p></li>
<li style="list-style-type: opencircle"><p>CONFIG_IP_NF_TARGET_MASQUERADE</p>
</li></ul>

<p>Выше приведен список минимально необходимых опций ядра для скрипта
<a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt</em></a>.
Перечень опций, необходимых для других примеров, Вы сможете найти в
соответствующих разделах ниже. Сейчас же мы
остановимся на главном скрипте и начнем его изучение.</p>

<hr><h1 class="SECTION"><a name="USERLANDSETUP">2.3. Установка пакета</a></h1>
<p>В первую очередь посмотрим, как собрать (скомпилировать) пакет
<strong class="COMMAND">iptables</strong>. Сборка пакета в значительной
степени зависит от конфигурации ядра, и Вы должны это понимать.
Некоторые дистрибутивы предполагают предустановку пакета
<strong class="COMMAND">iptables</strong>, один из них Red Hat.
Однако, в RedHat этот пакет по умолчанию выключен, поэтому
ниже мы рассмотрим, как его включить в данном и в других дистрибутивах.</p>

<hr><h2 class="SECTION"><a name="COMPILINGUSERAPPS">2.3.1. Сборка пакета</a>
</h2>
<p>Для начала пакет с исходными текстами <strong class="COMMAND">iptables
</strong> нужно распаковать. Мы будем рассматривать пакет
<em class="EMPHASIS">iptables 1.2.6a</em> и ядро серии 2.4.
Распакуем как обычно, командой <strong class="COMMAND">
bzip2 -cd iptables-1.2.6a.tar.bz2 | tar -xvf -</strong>
(распаковку можно выполнить также командой
<strong class="COMMAND">tar -xjvf iptables-1.2.6a.tar.bz2</strong>).
Если распаковка прошла удачно, то пакет будет размещен в каталоге
<tt class="COMPUTEROUTPUT">iptables-1.2.6a</tt>.
За дополнительной информацией Вы можете обратиться к файлу
<tt class="FILENAME">iptables-1.2.6a/INSTALL</tt>,
который содержит подробную информацию по сборке и установке пакета.</p>

<p>Далее необходимо проверить включение в ядро
дополнительных модулей и опций. Шаги, описываемые здесь,
будут касаться только наложения &quot;заплат&quot;
(patches) на ядро. На этом шаге мы установим обновления,
которые, как ожидается, будут включены в ядро в будущем.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Некоторые из них находятся пока на
экспериментальной стадии и наложение этих заплат
может оказаться не всегда оправданной, однако среди
них есть чрезвычайно интересные функции и действия.</p>
<p>Выполним этот шаг, набрав команду (естественно,
обладая правами пользователя root)</p></td></tr></table>
<p><strong class="COMMAND">make pending-patches KERNEL_DIR=/usr/src/linux/
</strong></p>

<p>Переменная <tt class="VARNAME">KERNEL_DIR</tt> должна содержать путь к
исходным текстам ядра. Обычно это <tt class="FILENAME">/usr/src/linux/</tt>.
Если исходные тексты у Вас расположены в другом месте, то,
соответственно, Вы должны указать свой путь.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Здесь предполагается выполнить несколько
обновлений и дополнений, которые определенно войдут
в состав ядра, но несколько позднее, сейчас же мы
возьмем их отсюда выполнив команду:</p></td></tr></table>
<p><strong class="COMMAND">make most-of-pom KERNEL_DIR=/usr/src/linux/
</strong></p>

<p>В процессе выполнения вышеприведенной команды у Вас
будет запрашиваться подтверждение на обновление каждого
раздела из того, что в мире netfilter называется
<strong class="COMMAND">patch-o-matic</strong>.
Чтобы установить <em class="EMPHASIS">все</em> &quot;заплатки&quot; из
<em class="EMPHASIS">patch-o-matic</em>, нужно выполнить следующую команду:
</p>
<p><strong class="COMMAND">make patch-o-matic KERNEL_DIR=/usr/src/linux/
</strong></p>

<p>Не забудьте внимательно и до конца прочитать справку по
каждой &quot;заплатке&quot; до того, как будете
устанавливать что-либо, поскольку одни &quot;заплатки&quot;
могут оказаться несовместимы с другими, а некоторые при совместном
наложении даже разрушить ядро.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Вы можете вообще пропустить обновление ядра,
другими словами особой нужды в таком обновлении нет,
однако <em class="EMPHASIS">patch-o-matic</em> содержит
действительно интересные обновления, и у Вас вполне может возникнуть
желание посмотреть на них. Ничего страшного не случится,
если Вы запустите эти команды и посмотрите, какие обновления имеются.</p>
</td></tr></table>

<p>После завершения обновления, необходимо будет пересобрать ядро,
добавив в него только что установленные обновления. Не забудьте сначала
выполнить конфигурирование ядра, поскольку установленные обновления скорее
всего окажутся выключенными. В принципе, можно подождать с компиляцией ядра
до тех пор, пока Вы не закончите установку
<strong class="COMMAND">iptables</strong>.</p>

<p>Продолжая сборку <strong class="COMMAND">iptables</strong>,
запустите команду:</p>
<p><strong class="COMMAND">make KERNEL_DIR=/usr/src/linux/</strong></p>

<p>Если в процессе сборки возникли какие-либо проблемы, то можете попытаться
разрешить их самостоятельно, либо обратиться на
<a href="#NETFILTERLIST">Netfilter mailing list</a>, где Вам смогут помочь.
Там Вы найдете пояснения, что могло быть сделано неправильно при установке,
так что сразу не паникуйте. Если это не помогло, постарайтесь поразмыслить
логически, возможно это поможет.
Или обратитесь к знакомому &quot;гуру&quot;.</p>

<p>Если все прошло гладко, то, следовательно, Вы готовы к установке
исполняемых модулей (binaries), для чего запустите следующую команду:</p>
<p><strong class="COMMAND">make install KERNEL_DIR=/usr/src/linux/</strong>
</p>

<p>Надеюсь, что здесь-то проблем не возникло! Теперь для использования пакета
<strong class="COMMAND">iptables</strong> Вам определенно
потребуется пересобрать и переустановить ядро, если Вы до
сих пор этого не сделали. Дополнительную информацию по
установке пакета Вы найдете в файле <tt class="FILENAME">INSTALL</tt>.</p>

<hr><h2 class="SECTION"><a name="INSTALLRH71">2.3.2. Установка в Red Hat 7.1
</a></h2>
<p>RedHAt 7.1 с установленным ядром 2.4.x уже включает
предустановленные <em class="EMPHASIS">netfilter</em> и
<strong class="COMMAND">iptables</strong>. Однако, для сохранения
обратной совместимости с предыдущими дистрибутивами, по умолчанию работает
пакет <strong class="COMMAND">ipchains</strong>. Сейчас мы коротко разберем,
как удалить ipchains и запустить вместо него
<strong class="COMMAND">iptables</strong>.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top">
<p>Версия <strong class="COMMAND">iptables</strong> в Red Hat 7.1
сильно устарела и неплохим решением будет
установить более новую версию.</p></td></tr></table>

<p>Для начала нужно отключить <strong class="COMMAND">ipchains</strong>,
чтобы предотвратить загрузку соответствующих модулей в будущем.
Чтобы добиться этого, нам потребуется изменить имена некоторых файлов в
дереве каталогов <tt class="FILENAME">/etc/rc.d/</tt>. Следующая команда,
выполнит требуемые действия:</p>

<p><strong class="COMMAND">chkconfig --level 0123456 ipchains off</strong></p>
<p>В результате выполнения этой команды, в некоторых именах ссылок,
указывающих на файлы в каталоге <tt class="FILENAME">
/etc/rc.d/init.d/ipchains</tt>, символ S
(который сообщает, что данный Скрипт отрабатывает на
запуске системы) будет заменен символом K (от слова Kill,
который указывает на то, что Скрипт отрабатывает, при
завершении работы системы. Таким образом мы предотвратим
запуск ненужного сервиса в будущем.</p>

<p>Однако <strong class="COMMAND">ipchains</strong> по-прежнему остаются в
работе. Теперь надо выполнить команду, которая остановит этот сервис:</p>
<p><strong class="COMMAND">service ipchains stop</strong></p>

<p>И в заключение необходимо запустить сервис <strong class="COMMAND">
iptables</strong>. Для этого, во-первых,
надо определиться с уровнями запуска операционной системы,
на которых нужно стартовать этот сервис. Обычно это уровни
2, 3 и 5. Об этих уровнях мы знаем:</p>

<ul><li style="list-style-type: opencircle">
<p>2. Многопользовательский режим без поддержки NFS или
то же самое, что и 3, но без сетевой поддержки.</p></li>

<li style="list-style-type: opencircle">
<p>3. Полнофункциональный многопользовательский режим.</p></li>
<li style="list-style-type: opencircle">
<p>5. X11. Данный уровень используется для
автоматической загрузки X window.</p></li></ul>

<p>Чтобы запустить <strong class="COMMAND">iptables</strong> на этих уровнях
нужно выполнить команду:</p>
<p><strong class="COMMAND">chkconfig --level 235 iptables on</strong></p>

<p>Хочется упомянуть об уровнях, на которых не
требуется запуск <strong class="COMMAND">iptables</strong>:
Уровень 1 однопользовательский режим работы, как правило,
используется в экстренных случаях, когда мы &quot;поднимаем&quot;
&quot;упавшую&quot; систему. Уровень 4 вообще не должен использоваться.
Уровень выполнения 6 это уровень остановки системы при выключении
или перезагрузке компьютера.</p>

<p>Для активации сервиса <strong class="COMMAND">iptables</strong>
дадим команду:</p>
<p><strong class="COMMAND">service iptables start</strong></p>

<p>Итак, мы запустили <strong class="COMMAND">iptables</strong>,
но у нас пока еще нет ни одного правила. Чтобы добавить новые правила в
Red Hat 7.1 можно пойти двумя путями, во-первых: подправить файл
<tt class="FILENAME">/etc/rc.d/init.d/iptables</tt>, но этот
способ имеет одно негативное свойство: при обновлении
iptables из RPM-пакетов все правила будут утеряны, а во-вторых:
занести правила и сохранить их командой <strong class="COMMAND">
iptables-save</strong>, сохраненные таким образом
правила будут автоматически восстанавливаться при загрузке системы.</p>

<p>В случае, если Вы избрали первый вариант установки
правил в <strong class="COMMAND">iptables</strong>, то Вам необходимо
занести их в секцию start скрипта /etc/rc.d/init.d/iptables
(для установки правил при загрузке системы) или в функцию start().
Для выполнения действий при остановке системы внесите соответствующие
изменения в секцию stop или в функцию stop(). Также не забудьте про
секции restart и condrestart. Хочется еще раз напомнить, что в случае
обновления <strong  class="COMMAND">iptables</strong> из RPM-пакетов или
через автоматическое обновление по сети, Вы можете утерять все изменения,
внесенные в файл <tt class="FILENAME">/etc/rc.d/init.d/iptables</tt>.</p>

<p>Второй способ загрузки правил предпочтительнее.
Он предполагает следующие шаги. Для начала запишите правила
в файл или непосредственно, через команду
<strong class="COMMAND">iptables</strong>, смотря что для Вас
предпочтительнее. Затем исполните команду
<strong class="COMMAND">iptables-save</strong>. Эта команда эквивалентна
<strong class="COMMAND">iptables-save &gt; /etc/sysconfig/iptables</strong>.
В результате, весь набор правил будет сохранен в файле
<tt class="FILENAME">/etc/sysconfig/iptables</tt>,
который автоматически подгружается при запуске сервиса iptables.
Другим способом сохранить набор правил будет подача команды
<strong class="COMMAND">service iptables save</strong>, которая
полностью идентична вышеприведенной команде. Впоследствии, при перезагрузке
компьютера, скрипт iptables из rc.d будет выполнять команду
<strong class="COMMAND">iptables-restore</strong> для загрузки набора
правил из файла <tt class="FILENAME">/etc/sysconfig/iptables</tt>.</p>

<p>И наконец, в завершение установки, неплохо было бы удалить старые версии
<strong class="COMMAND">ipchains</strong> и
<strong class="COMMAND">iptables</strong>. Это необходимо сделать
для того, чтобы система не &quot;перепутала&quot; старый пакет
<strong class="COMMAND">iptables</strong> с вновь установленным.
Удаление старого пакета <strong class="COMMAND">iptables</strong>
необходимо произвести только в том случае, если Вы производили установку
из исходных текстов. Дело в том, что RPM-пакеты
устанавливаются в несколько иное место, нежели пакеты, собранные из исходных
текстов, а поэтому новый пакет не &quot;затирает&quot; старый.
Чтобы выполнить деинсталляцию предыдущей версии
<strong class="COMMAND">iptables</strong> выполните следующую команду:</p>
<p><strong class="COMMAND">rpm -e iptables</strong></p>

<p>Аналогичным образом удалим и <strong class="COMMAND">ipchains</strong>,
поскольку оставлять этот пакет в системе более нет никакого смысла:</p>
<p><strong class="COMMAND">rpm -e ipchains</strong></p>

<hr><h1><a name="TRAVERSINGOFTABLES">Глава 3. Порядок прохождения таблиц
и цепочек</a></h1>
<p>В этой главе мы рассмотрим порядок прохождения таблиц и
цепочек в каждой таблице. Эта информация будет очень важна для
Вас позднее, когда Вы начнете строить свои наборы правил,
особенно когда в наборы правил будут включаться такие действия
как <strong class="COMMAND">DNAT</strong>,
<strong class="COMMAND">SNAT</strong> и конечно же
<strong class="COMMAND">TOS</strong>.</p>

<hr><h1 class="SECTION"><a name="TRAVERSINGGENERAL">3.1. Общие положения</a>
</h1>
<p>Когда пакет приходит на наш брандмауэр, то он сперва
попадает на сетевое устройство, перехватывается соответствующим драйвером и
далее передается в ядро. Далее пакет проходит ряд таблиц и затем передается
либо локальному приложению, либо переправляется на другую машину.
Порядок следования пакета приводится ниже:</p>

<a name="TABLE.FORWARDEDPACKETS"></a>
<p><strong>Таблица 3-1. Порядок движения транзитных
пакетов</strong></p>
<table border="1" class="CALSTABLE">
<thead><tr><th width="12%" align="left" valign="top">Шаг</th>
<th width="12%" align="left" valign="top">Таблица</th>
<th width="25%" align="left" valign="top">Цепочка</th>
<th width="50%" align="left" valign="top">Примечание</th></tr></thead>
<tbody><tr><td width="12%" align="left" valign="top">1</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Кабель (т.е. Интернет)</td></tr>
<tr><td width="12%" align="left" valign="top">2</td>
<td width="12%" align="left" valign="top"></td>
<td width="25%" align="left" valign="top"></td>
<td width="50%" align="left" valign="top">Сетевой интерфейс (например, eth0)
</td></tr>
<tr><td width="12%" align="left" valign="top">3</td>
<td width="12%" align="left" valign="top">mangle</td>
<td width="25%" align="left" valign="top">PREROUTING</td>
<td width="50%" align="left" valign="top">Обычно эта цепочка используется для
внесения изменений в заголовок пакета, например для
изменения битов <em class="EMPHASIS">TOS</em> и пр.</td></tr>

<tr><td width="12%" align="left" valign="top">4</td>
<td width="12%" align="left" valign="top">nat</td>
<td width="25%" align="left" valign="top">PREROUTING</td>
<td width="50%" align="left" valign="top">Эта цепочка используется для
трансляции сетевых адресов (<em class="EMPHASIS">Destination Network Address
Translation</em>). <em class="EMPHASIS">Source Network Address Translation
</em> выполняется позднее в другой цепочке. Любого рода фильтрация в этой
цепочке может производиться только в исключительных случаях</td></tr>

<tr><td width="12%" align="left" valign="top">5</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Принятие решения о дальнейшей
маршрутизации, то есть в этой точке решается, куда пойдет пакет:
локальному приложению или на другой узел сети.</td></tr>

<tr><td width="12%" align="left" valign="top">6</td>
<td width="12%" align="left" valign="top">mangle</td>
<td width="25%" align="left" valign="top">FORWARD</td>
<td width="50%" align="left" valign="top">Далее пакет попадает в цепочку
<em class="EMPHASIS">FORWARD</em> таблицы mangle,
которая должна использоваться только в исключительных случаях,
когда необходимо внести некоторые изменения в заголовок пакета между
двумя точками принятия решения о маршрутизации.</td></tr>

<tr><td width="12%" align="left" valign="top">7</td>
<td width="12%" align="left" valign="top">Filter</td>
<td width="25%" align="left" valign="top">FORWARD</td>
<td width="50%" align="left" valign="top">В цепочку <em class="EMPHASIS">
FORWARD</em> попадают только те пакеты, которые идут на другой хост.
Вся фильтрация транзитного трафика должна выполняться здесь.
Не забывайте, что через эту цепочку проходит трафик в обоих направлениях,
обязательно учитывайте это обстоятельство при написании правил фильтрации.
</td></tr>

<tr><td width="12%" align="left" valign="top">8</td>
<td width="12%" align="left" valign="top">mangle</td>
<td width="25%" align="left" valign="top">POSTROUTING</td>
<td width="50%" align="left" valign="top">Эта цепочка предназначена для
внесения изменений в заголовок пакета уже после того,
как принято последнее решение о маршрутизации.</td></tr>

<tr><td width="12%" align="left" valign="top">9</td>
<td width="12%" align="left" valign="top">nat</td>
<td width="25%" align="left" valign="top">POSTROUTING</td>
<td width="50%" align="left" valign="top">Эта цепочка предназначена в первую
очередь для <em class="EMPHASIS">Source Network Address Translation</em>.
Не используйте ее для фильтрации без особой на то необходимости.
Здесь же выполняется и маскарадинг (Masquerading).</td></tr>

<tr><td width="12%" align="left" valign="top">10</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Выходной сетевой интерфейс
(например, eth1).</td></tr>

<tr><td width="12%" align="left" valign="top">11</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Кабель (пусть будет LAN).</td>
</tr></tbody></table>

<p>Как Вы можете видеть, пакет проходит несколько этапов,
прежде чем он будет передан далее. На каждом из них пакет
может быть остановлен, будь то цепочка
<strong class="COMMAND">iptables</strong> или что-либо еще, но нас главным
образом интересует <strong class="COMMAND">iptables</strong>.
Заметьте, что нет каких-либо цепочек, специфичных для отдельных интерфейсов
или чего-либо подобного. Цепочку <em class="EMPHASIS">FORWARD</em> проходят
ВСЕ пакеты, которые движутся через наш брандмауэр/роутер.
Не используйте цепочку INPUT для фильтрации транзитных пакетов,
они туда просто не попадают! Через эту цепочку движутся только те пакеты,
которые предназначены данному хосту!</p>

<p>А теперь рассмотрим порядок движения пакета,
предназначенного локальному процессу/приложению:</p>
<a name="TABLE.DESTINATIONLOCALHOST"></a>
<p><strong>Таблица 3-2. Для локального приложения</strong></p>
<table border="1" class="CALSTABLE">
<thead><tr><th width="12%" align="left" valign="top">Шаг</th>
<th width="12%" align="left" valign="top">Таблица</th>
<th width="25%" align="left" valign="top">Цепочка</th>
<th width="50%" align="left" valign="top">Примечание</th></tr></thead>
<tbody><tr><td width="12%" align="left" valign="top">1</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Кабель (Интернет)</td></tr>
<tr><td width="12%" align="left" valign="top">2</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Входной сетевой интерфейс (например,
eth0)</td></tr>
<tr><td width="12%" align="left" valign="top">3</td>
<td width="12%" align="left" valign="top">mangle</td>
<td width="25%" align="left" valign="top">PREROUTING</td>
<td width="50%" align="left" valign="top">Обычно используется для внесения
изменений в заголовок пакета, например, для установки битов
<em class="EMPHASIS">TOS</em> и пр.</td></tr>

<tr><td width="12%" align="left" valign="top">4</td>
<td width="12%" align="left" valign="top">nat</td>
<td width="25%" align="left" valign="top">PREROUTING</td>
<td width="50%" align="left" valign="top">Преобразование адресов
(<em class="EMPHASIS">Destination Network Address Translation</em>).
Фильтрация пакетов здесь допускается только в исключительных случаях.</td>
</tr>
<tr><td width="12%" align="left" valign="top">5</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Принятие решения о маршрутизации.
</td></tr>
<tr><td width="12%" align="left" valign="top">6</td>
<td width="12%" align="left" valign="top">mangle</td>
<td width="25%" align="left" valign="top">INPUT</td>
<td width="50%" align="left" valign="top">Пакет попадает в цепочку
<em class="EMPHASIS">INPUT</em> таблицы mangle. Здесь внесятся изменения в
заголовок пакета перед тем, как он будет передан локальному приложению.</td>
</tr>

<tr><td width="12%" align="left" valign="top">7</td>
<td width="12%" align="left" valign="top">filter</td>
<td width="25%" align="left" valign="top">INPUT</td>
<td width="50%" align="left" valign="top">Здесь производится фильтрация
входящего трафика. Помните, что все входящие пакеты,
адресованные нам, проходят через эту цепочку, независимо от того,
с какого интерфейса они поступили.</td></tr>

<tr><td width="12%" align="left" valign="top">8</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Локальный процесс/приложение
(программа-сервер или программа-клиент).</td></tr></tbody></table>

<p>Важно помнить, что на этот раз пакеты идут через цепочку
<em class="EMPHASIS">INPUT</em>, а не через
<em class="EMPHASIS">FORWARD</em>.</p>

<p>И в заключение мы рассмотрим порядок движения пакетов,
созданных локальными процессами.</p>
<a name="TABLE.SOURCELOCALHOST"></a>
<p><strong>Таблица 3-3. От локальных процессов</strong></p>
<table border="1" class="CALSTABLE"><thead><tr>
<th width="12%" align="left" valign="top">Шаг</th>
<th width="12%" align="left" valign="top">Таблица</th>
<th width="25%" align="left" valign="top">Цепочка</th>
<th width="50%" align="left" valign="top">Примечание</th></tr></thead>

<tbody><tr><td width="12%" align="left" valign="top">1</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Локальный процесс (программа-сервер
или программа-клиент).</td></tr>

<tr><td width="12%" align="left" valign="top">2</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Принятие решения о маршрутизации.
Здесь решается куда пойдет пакет дальше: на какой адрес,
через какой сетевой интерфейс и пр.</td></tr>

<tr><td width="12%" align="left" valign="top">3</td>
<td width="12%" align="left" valign="top">mangle</td>
<td width="25%" align="left" valign="top">OUTPUT</td>
<td width="50%" align="left" valign="top">Здесь производится внесение
изменений в заголовок пакета. Выполнение фильтрации в этой
цепочке может иметь негативные последствия.</td></tr>

<tr><td width="12%" align="left" valign="top">4</td>
<td width="12%" align="left" valign="top">nat</td>
<td width="25%" align="left" valign="top">OUTPUT</td>
<td width="50%" align="left" valign="top">Эта цепочка используется
для трансляции сетевых адресов (NAT) в пакетах, исходящих от
локальных процессов брандмауэра.</td></tr>

<tr><td width="12%" align="left" valign="top">5</td>
<td width="12%" align="left" valign="top">Filter</td>
<td width="25%" align="left" valign="top">OUTPUT</td>
<td width="50%" align="left" valign="top">
Здесь фильтруется исходящий трафик.</td></tr>

<tr><td width="12%" align="left" valign="top">6</td>
<td width="12%" align="left" valign="top">mangle</td>
<td width="25%" align="left" valign="top">POSTROUTING</td>
<td width="50%" align="left" valign="top">Цепочка <em class="EMPHASIS">
POSTROUTING</em> таблицы mangle в основном используется для правил,
которые должны вносить изменения в заголовок пакета перед тем, как
он покинет брандмауэр, но уже после принятия решения о маршрутизации.
В эту цепочку попадают все пакеты, как транзитные, так и созданные
локальными процессами брандмауэра.</td></tr>

<tr><td width="12%" align="left" valign="top">7</td>
<td width="12%" align="left" valign="top">nat</td>
<td width="25%" align="left" valign="top">POSTROUTING</td>
<td width="50%" align="left" valign="top">Здесь выполняется
<em class="EMPHASIS">Source Network Address Translation</em>.
Не следует в этой цепочке производить фильтрацию пакетов во избежание
нежелательных побочных эффектов. Однако и здесь можно останавливать пакеты,
применяя политику по умолчанию
<strong class="COMMAND">DROP</strong>.</td></tr>

<tr><td width="12%" align="left" valign="top">8</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Сетевой интерфейс (например, eth0).
</td></tr>
<tr><td width="12%" align="left" valign="top">9</td>
<td width="12%" align="left" valign="top"> </td>
<td width="25%" align="left" valign="top"> </td>
<td width="50%" align="left" valign="top">Кабель (Internet).</td>
</tr></tbody></table>

<p>Теперь мы знаем, что есть три различных варианта прохождения пакетов.
Рисунок ниже более наглядно демонстрирует это:</p>
<p><img src="images/tables_traverse.jpg"></p>

<p>Этот рисунок дает довольно ясное представление о порядке
прохождения пакетов через различные цепочки. В первой точке принятия решения
о маршрутизации (routing decision) все пакеты, предназначенные данному хосту,
направляются в цепочку <em class="EMPHASIS">INPUT</em>,
остальные в цепочку <em class="EMPHASIS">FORWARD</em>.</p>

<p>Обратите внимание также на тот факт, что пакеты, с адресом назначения на
брандмауэр, могут претерпеть изменение сетевого адреса назначения (DNAT) в
цепочке <em class="EMPHASIS">PREROUTING</em> таблицы nat и соответственно
дальнейшая маршрутизация в первой точке будет выполняться в зависимости от
произведенных изменений. Запомните: <em class="EMPHASIS">все</em> пакеты
проходят через таблицы и цепочки по тому или иному маршруту.
Даже если выполняется <em class="EMPHASIS">DNAT</em> в ту же сеть,
откуда пакет пришел, то он все равно продолжит движение по цепочкам.</p>

<table class="TIP" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/tip.gif" hspace="5" alt="Tip"></td>
<td align="left" valign="top"><p>
В скрипте <a href="glava08.htm#RCTEST-IPTABLESTXT">
<em>rc.test-iptables.txt</em></a> Вы сможете найти дополнительную информацию
о порядке прохождения пакетов.</p></td></tr></table>

<hr><h1 class="SECTION"><a name="MANGLETABLE">3.2. Таблица Mangle</a></h1>
<p>Как уже упоминалось выше, эта таблица предназначена,
главным образом для внесения изменений в заголовки пакетов. То есть в этой
таблице Вы можете устанавливать биты <em class="EMPHASIS">TOS</em>
(Type Of Service) и т.д.</p>

<table class="CAUTION" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/caution.gif" hspace="5"
alt="Caution"></td>

<td align="left" valign="top"><p>Еще раз напоминаю, что в этой таблице не
следует производить любого рода фильтрацию, маскировку или преобразование
адресов <strong class="COMMAND">(DNAT, SNAT, MASQUERADE)</strong>.
</p></td></tr></table>

<p>В этой таблице допускается выполнять только нижеперечисленные действия:</p>
<ul><li style="list-style-type: opencircle"><p>TOS</p></li>
<li style="list-style-type: opencircle"><p>TTL</p></li>
<li style="list-style-type: opencircle"><p>MARK</p></li></ul>

<p>Действие <strong class="COMMAND">TOS</strong> выполняет
установку битов поля <em class="EMPHASIS">Type of Service</em> в пакете.
Это поле используется для назначения сетевой политики обслуживания пакета,
то есть задает желаемый вариант маршрутизации. Однако, следует заметить,
что данное свойство в действительности используется на незначительном
количестве маршрутизаторов в Интернете. Другими словами, не следует изменять
состояние этого поля для пакетов, уходящих в Интернет, потому что на роутерах,
которые обслуживают это поле, может быть принято неправильное решение
при выборе маршрута.</p>

<p>Действие <strong class="COMMAND">TTL</strong> используется для установки
значения поля <em class="EMPHASIS">TTL</em> (Time To Live) пакета.
Есть одно неплохое применение этому действию. Мы можем присваивать
определенное значение этому полю, чтобы скрыть наш брандмауэр
от чересчур любопытных провайдеров. Дело в том, что отдельные провайдеры
очень не любят, когда одно подключение разделяется несколькими компьютерами,
и тогда они начинают проверять значение <em class="EMPHASIS">TTL</em>
приходящих пакетов и используют его как один из критериев определения того,
один компьютер &quot;сидит&quot; на подключении или несколько.</p>

<p>Действие <strong class="COMMAND">MARK</strong> устанавливает специальную
метку на пакет, которая затем может быть проверена другими
правилами в iptables или другими программами, например,
<strong class="COMMAND">iproute2</strong>. С помощью &quot;меток&quot; можно
управлять маршрутизацией пакетов, ограничивать трафик и т.п.</p>

<hr><h1 class="SECTION"><a name="NATTABLE">3.3. Таблица Nat</a></h1>
<p>Эта таблица используется для выполнения преобразований сетевых адресов
<em class="EMPHASIS">NAT</em> (Network Address Translation).
Как уже упоминалось ранее, только первый пакет из потока проходит
через цепочки этой таблицы, трансляция адресов или маскировка
применяются ко всем последующим пакетам в потоке автоматически.
Для этой таблицы характерны действия:</p>

<ul><li style="list-style-type: opencircle"><p>DNAT</p></li>
<li style="list-style-type: opencircle"><p>SNAT</p></li>
<li style="list-style-type: opencircle"><p>MASQUERADE</p></li></ul>

<p>Действие <strong class="COMMAND">DNAT</strong> (Destination Network
Address Translation) производит преобразование адресов назначения в
заголовках пакетов. Другими словами, этим действием
производится перенаправление пакетов на другие адреса,
отличные от указанных в заголовках пакетов.</p>

<p><strong class="COMMAND">SNAT</strong> (Source Network Address
Translation) используется для изменения исходных адресов пакетов.
С помощью этого действия можно скрыть структуру локальной сети,
а заодно и разделить единственный внешний IP-адрес между компьютерами
локальной сети для выхода в Интернет.
В этом случае брандмауэр, с помощью <strong class="COMMAND">SNAT</strong>,
автоматически производит прямое и обратное преобразование адресов,
тем самым давая возможность выполнять подключение к серверам в Интернете с
компьютеров в локальной сети.</p>

<p>Маскировка (<strong class="COMMAND">MASQUERADE</strong>) применяется в тех же
целях, что и <strong class="COMMAND">SNAT</strong>, но в отличие от последней,
<strong class="COMMAND">MASQUERADE</strong> дает более сильную
нагрузку на систему. Происходит это потому, что каждый раз,
когда требуется выполнение этого действия, производится
запрос IP-адреса для указанного в действии сетевого интерфейса,
в то время как для <strong class="COMMAND">SNAT</strong> IP-адрес указывается
непосредственно. Однако, благодаря такому отличию,
<strong class="COMMAND">MASQUERADE</strong> может работать в случаях
с динамическим IP-адресом, то есть когда Вы подключаетесь к Интернет,
скажем, через <em class="EMPHASIS">PPP</em>,
<em class="EMPHASIS">SLIP</em> или <em class="EMPHASIS">DHCP</em>.</p>

<hr><h1 class="SECTION"><a name="FILTERTABLE">3.4. Таблица Filter</a></h1>
<p>Как следует из названия, в этой таблице должны содержаться
наборы правил для выполнения фильтрации пакетов. Пакеты могут пропускаться
далее, либо отвергаться (действия <strong class="COMMAND">ACCEPT</strong> и
<strong class="COMMAND">DROP</strong>, соответственно), в зависимости
от их содержимого. Конечно же, мы можем отфильтровывать
пакеты и в других таблицах, но эта таблица существует именно
для нужд фильтрации. В этой таблице допускается использование
большинства из существующих действий, однако ряд действий,
которые мы рассмотрели выше в этой главе, должны выполняться только в
присущих им таблицах.</p>

<hr><h1><a name="STATEMACHINE">Глава 4. Механизм определения состояний</a>
</h1>
<p>В данной главе все внимание будет уделено механизму
определения состояний пакетов (state machine). По прочтении ее
у Вас должно сложиться достаточно четкое представление о работе
механизма, а способствовать этому должен значительный
объем поясняющих примеров.</p>

<hr><h1 class="SECTION"><a name="STATEMACHINEINTRODUCTION">4.1. Введение</a>
</h1>
<p>Механизм определения состояния (state machine) является
отдельной частью iptables и в действительности не должен бы так называться,
поскольку фактически является механизмом трассировки соединений.
Однако, значительному количеству людей
он известен именно как &quot;механизм определения состояния&quot;
(state machine). В данной главе эти названия
будут использоваться как синонимы. Трассировщик соединений создан для того,
чтобы netfilter мог постоянно иметь
информацию о состоянии каждого конкретного соединения.
Наличие трассировщика позволяет создавать более надежные
наборы правил по сравнению с брандмауэрами, которые не имеют
поддержки такого механизма.</p>

<p>В пределах iptables соединение может иметь одно из 4 базовых состояний:
<strong class="COMMAND">NEW</strong>, <strong class="COMMAND">ESTABLISHED
</strong>, <strong class="COMMAND">RELATED</strong> и
<strong class="COMMAND">INVALID</strong>. Позднее мы остановимся на
каждом из них более подробно. Для управления прохождением пакетов,
основываясь на их состоянии, используется критерий
<strong class="COMMAND">--state</strong>.</p>

<p>Трассировка соединений производится специальным кодом в
пространстве ядра, трассировщиком (conntrack). Код трассировщика может быть
скомпилирован как подгружаемый модуль ядра, так и статически связан с ядром.
В большинстве случаев нам потребна более специфичная информация о соединении,
чем та, которую поставляет трассировщик по умолчанию.
Поэтому трассировщик включает в себя обработчики различных протоколов,
например, <em class="EMPHASIS">TCP</em>,
<em class="EMPHASIS">UDP</em> или <em class="EMPHASIS">ICMP</em>.
Собранная ими информация затем
используется для идентификации и определения текущего состояния соединения.
Например, соединение по протоколу <em class="EMPHASIS">UDP</em> однозначно
идентифицируется по IP-адресам и портам источника и приемника.</p>

<p>В предыдущих версиях ядра имелась возможность включения/выключения
поддержки дефрагментации пакетов. Однако, после того как трассировка
соединений была включена в состав iptables/netfilter,
надобность в этом отпала. Причина в том, что трассировщик не в состоянии
выполнять возложенные на него функции без поддержки дефрагментации и поэтому
она включена постоянно. Ее нельзя отключить иначе как
отключив трассировку соединений. Дефрагментация выполняется всегда,
если трассировщик включен.</p>

<p>Трассировка соединений производится в цепочке
<em class="EMPHASIS">PREROUTING</em>, исключая случаи,
когда пакеты создаются локальными процессами на брандмауэре,
в этом случае трассировка производится в цепочке
<em class="EMPHASIS">OUTPUT</em>. Это означает, что iptables
производит все вычисления, связанные с определением состояния,
в пределах этих цепочек. Когда локальный процесс на брандмауэре отправляет
первый пакет из потока, то в цепочке <em class="EMPHASIS">OUTPUT</em> ему
присваивается состояние <strong class="COMMAND">NEW</strong>,
а когда возвращается пакет ответа, то состояние соединения в цепочке
<em class="EMPHASIS">PREROUTING</em> изменяется на
<strong class="COMMAND">ESTABLISHED</strong> и так далее. Если же соединение
устанавливается извне, то состояние <strong class="COMMAND">NEW</strong>
присваивается первому пакету из потока в цепочке
<em class="EMPHASIS">PREROUTING</em>. Таким образом, определение
состояния пакетов производится в пределах цепочек
<em class="EMPHASIS">PREROUTING</em> и
<em class="EMPHASIS">OUTPUT</em> таблицы nat.</p>

<hr><h1 class="SECTION"><a name="THECONNTRACKENTRIES">4.2. Таблица
трассировщика</a></h1>
<p>Кратко рассмотрим таблицу трассировщика, которую можно найти в файле
<tt class="FILENAME">/proc/net/ip_conntrack</tt>. Здесь содержится список
всех активных соединений. Если модуль <em class="EMPHASIS">ip_conntrack</em>
загружен, то команда <strong class="COMMAND">cat /proc/net/ip_conntrak
</strong> должна вывести нечто, подобное:</p>
<pre class="SCREEN">
tcp6 117 SYN_SENT src=192.168.1.6 dst=192.168.1.9 sport=32775 \
     dport=22 [UNREPLIED] src=192.168.1.9 dst=192.168.1.6 sport=22 \
     dport=32775 use=2
</pre>

<p>В этом примере содержится вся информация, которая известна трассировщику,
по конкретному соединению. Первое, что можно увидеть, это название протокола,
в данном случае, tcp. Далее следует некоторое число в
обычном десятичном представлении. После него следует число, определяющее
&quot;время жизни&quot; записи в таблице (количество секунд, через которое
информация о соединении будет удалена из таблицы). Для нашего случая,
запись в таблице будет храниться еще 117 секунд, если конечно через это
соединение более не проследует ни одного пакета. При прохождении каждого
последующего пакета через данное соединение, это значение будет
устанавливаться в значение по умолчанию для заданного состояния.
Это число уменьшается на 1 каждую секунду. Далее следует фактическое
состояние соединения. Для нашего примера состояние имеет значение
<tt class="COMPUTEROUTPUT">SYN_SENT</tt>. Внутреннее представление состояния
несколько отличается от внешнего. Значение <tt class="COMPUTEROUTPUT">
SYN_SENT</tt> говорит о том, что через данное соединение проследовал
единственный пакет <em class="EMPHASIS">TCP SYN</em>.
Далее расположены адреса отправителя и получателя, порт отправителя и
получателя. Здесь же видно ключевое слово <tt class="COMPUTEROUTPUT">
[UNREPLIED]</tt>, которое сообщает о том, что ответного трафика через это
соединение еще не было. И наконец приводится дополнительная информация по
ожидаемому пакету, это IP-адреса отправителя/получателя (те же самые,
только поменявшиеся местами, поскольку ожидается ответный пакет),
то же касается и портов.</p>

<p>Записи в таблице могут принимать ряд значений, все они
определены в заголовочных файлах
<tt class="FILENAME">linux/include/netfilter-ipv4/ip_conntrack*.h</tt>.
Значения по умолчанию зависят от типа протокола. Каждый из IP-протоколов
<em class="EMPHASIS">TCP</em>, <em class="EMPHASIS">UDP</em> или
<em class="EMPHASIS">ICMP</em> имеют собственные значения по умолчанию,
которые определены в заголовочном файле
<tt class="FILENAME">linux/include/netfilter-ipv4/ip_conntrack.h</tt>.
Более подробно мы остановимся на этих значениях, когда будем рассматривать
каждый из протоколов в отдельности.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>В patch-o-matic появилась
заплата tcp-window-tracking, которая предоставляет возможность
передачи значений всех таймаутов через специальные переменные,
то есть позволяет изменять их &quot;на лету&quot;. Таким образом, появляется
возможность изменения таймаутов без необходимости пересборки ядра.</p>

<p>Изменения вносятся с помощью определенных системных вызовов,
через каталог <tt class="FILENAME">/proc/sys/net/ipv4/netfilter</tt>.
Особое внимание обратите на ряд переменных
<tt class="FILENAME">/proc/sys/net/ipv4/netfilter/ip_ct_*</tt>.</p>
</td></tr></table>

<p>После получения пакета ответа трассировщик снимет флаг
<tt class="COMPUTEROUTPUT">[UNREPLIED]</tt> и заменит его флагом
<tt class="COMPUTEROUTPUT">[ASSURED]</tt>. Этот флаг сообщает о том,
что соединение установлено уверенно, и эта запись не будет стерта по
достижении максимально возможного количества трассируемых соединений.
Максимальное количество записей, которое может содержаться в таблице,
зависит от значения по умолчанию, которое может быть установлено вызовом
функции ipsysctl в последних версиях ядра. Для объема ОЗУ 128 Мб это
значение соответствует 8192 записям, для 256 Мб 16376. Вы можете посмотреть и
изменить это значение установкой переменной
<tt class="FILENAME">/proc/sys/net/ipv4/ip_conntrack_max</tt>.</p>

<hr><h1 class="SECTION"><a name="USERLANDSTATES">
4.3. Состояния в пространстве пользователя</a></h1>
<p>Как Вы уже наверняка заметили, в пространстве ядра,
в зависимости от типа протокола, пакеты могут иметь
несколько различных состояний. Однако, вне ядра пакеты могут
иметь только 4 состояния. В основном состояние пакета используется
критерием <strong class="COMMAND">--state</strong>. Допустимыми являются
состояния <strong class="COMMAND">NEW</strong>,
<strong class="COMMAND">ESTABLISHED</strong>,
<strong class="COMMAND">RELATED</strong> и
<strong class="COMMAND">INVALID</strong>. В таблице, приводимой ниже,
рассмтриваются каждое из возможных состояний.</p>

<a name="TABLE.USERLANDSTATES"></a>
<p><strong>Таблица 4-1. Перечень состояний в пространстве пользователя
</strong></p>
<table border="1" class="CALSTABLE">
<thead><tr><th width="17%" align="left" valign="top">Состояние</th>
<th width="83%" align="left" valign="top">Описание</th></tr></thead>
<tbody><tr><td width="17%" align="left" valign="top">NEW</td>

<td width="83%" align="left" valign="top">Признак <strong class="COMMAND">NEW
</strong> сообщает о том, что пакет является первым для данного соединения.
Это означает, что это первый пакет в данном соединении,
который увидел модуль трассировщика. Например, если получен
<em class="EMPHASIS">SYN</em>-пакет, являющийся первым пакетом
для данного соединения, то он получит статус
<strong class="COMMAND">NEW</strong>. Однако, пакет может и не быть
<em class="EMPHASIS">SYN</em>-пакетом и тем не менее получить статус
<strong class="COMMAND">NEW</strong>. Это может породить
определенные проблемы в отдельных случаях, но может
оказаться и весьма полезным, например, когда
желательно &quot;подхватить&quot; соединения,
&quot;потерянные&quot; другими брандмауэрами или в случаях,
когда таймаут соединения уже истек, но само соединение не было закрыто.
</td></tr>

<tr><td width="17%" align="left" valign="top">RELATED</td>
<td width="83%" align="left" valign="top">
Состояние <strong class="COMMAND">RELATED</strong> одно из самых хитрых.
Соединение получает статус
<strong class="COMMAND">RELATED</strong>, если оно связано с
другим соединением, имеющим признак
<strong class="COMMAND">ESTABLISHED</strong>. Это означает, что соединение
получает признак <strong class="COMMAND">RELATED</strong> тогда,
когда оно инициировано из уже установленного соединения, имеющего признак
<strong class="COMMAND">ESTABLISHED</strong>. Хорошим примером соединения,
которое может рассматриваться как <strong class="COMMAND">RELATED</strong>,
является соединение <em class="EMPHASIS">FTP-data</em>, которое является
связанным с портом <em class="EMPHASIS">FTP control</em>, а также
<em class="EMPHASIS">DCC</em>-соединение, запущенное из
<em class="EMPHASIS">IRC</em>. Обратите внимание на то,
что большинство протоколов <em class="EMPHASIS">TCP</em> и некоторые из
протоколов <em class="EMPHASIS">UDP</em> весьма сложны и передают
информацию о соединении через область данных <em class="EMPHASIS">TCP</em>
или <em class="EMPHASIS">UDP</em>-пакетов и поэтому требуют наличия
специальных вспомогательных модулей для корректной работы.</td></tr>

<tr><td width="17%" align="left" valign="top">ESTABLISHED</td>
<td width="83%" align="left" valign="top">
Состояние <strong class="COMMAND">ESTABLISHED</strong> говорит о том,
что это не первый пакет в соединении. Схема установки состояния
<strong class="COMMAND">ESTABLISHED</strong> достаточна проста для понимания.
Единственное требование, предъявляемое к соединению, заключается в том, что
для перехода в состояние <strong class="COMMAND">ESTABLISHED</strong>
необходимо, чтобы узел сети передал пакет и получил на него ответ
от другого узла (хоста). После получения ответа состояние соединения
<strong class="COMMAND">NEW</strong> или
<strong class="COMMAND">RELATED</strong>будет изменено на
<strong class="COMMAND">ESTABLISHED</strong>.</td></tr>

<tr><td width="17%" align="left" valign="top">INVALID</td>
<td width="83%" align="left" valign="top">Признак <strong class="COMMAND">
INVALID</strong> говорит о том, что пакет не может быть идентифицирован и
поэтому не может иметь определенного статуса. Это может происходить по разным
причинам, например, при нехватке памяти или при получении
<em class="EMPHASIS">ICMP</em>-сообщения об ошибке, которое не соответствует
какому-либо известному соединению. Наверное, наилучшим вариантом было бы
применение действия <strong class="COMMAND">DROP</strong> к таким пакетам.
</td></tr></tbody></table>

<p>Эти четыре состояния могут использоваться в критерии
<strong class="COMMAND">--state</strong>. Механизм определения состояния
позволяет строить чрезвычайно мощную и эффективную защиту.
Раньше приходилось открывать все порты выше 1024, чтобы пропустить обратный
трафик в локальную сеть, теперь же, при наличии механизма определения
состояния, необходимость в этом отпала, поскольку появилась возможность
&quot;открывать&quot; доступ только для обратного (ответного) трафика,
пресекая попытки установления соединений извне.</p>

<hr><h1 class="SECTION"><a name="TCPCONNECTIONS">4.4. TCP-соединения</a></h1>
<p>В этом и в последующих разделах мы поближе рассмотрим
признаки состояний и порядок их обработки каждым из трех
базовых протоколов <em class="EMPHASIS">TCP</em>,
<em class="EMPHASIS">UDP</em> и <em class="EMPHASIS">ICMP</em>,
а также коснемся случая, когда протокол соединения не может быть
классифицирован на принадлежность к трем вышеуказанным протоколам.
Начнем рассмотрение с протокола TCP, поскольку он имеет множество
интереснейших особенностей в отношении механизма
определения состояния в iptables.</p>

<p><em class="EMPHASIS">TCP</em>-соединение всегда устанавливается
передачей трех пакетов, которые инициализируют и устанавливают соединение,
через которое в дальнейшем будут передаваться данные.
Сессия начинается с передачи <em class="EMPHASIS">SYN</em>-пакета,
в ответ на который передается <em class="EMPHASIS">SYN/ACK</em>-пакет и
подтверждает установление соединения пакет <em class="EMPHASIS">ACK</em>.
После этого соединение считается установленным и готовым к передаче данных.
Может возникнуть вопрос: &quot;А как же трассируется соединение?&quot;.
В действительности все довольно просто.</p>

<p>Для всех типов соединений, трассировка проходит практически одинаково.
Взгляните на рисунок ниже, где показаны все стадии установления соединения.
Как видите, трассировщик, с точки зрения пользователя, фактически не
следит за ходом установления соединения. Просто, как только трассировщик
&quot;увидел&quot; первый (<em class="EMPHASIS">SYN</em>) пакет,
то присваивает ему статус <strong class="COMMAND">NEW</strong>.
Как только через трассировщик проходит второй пакет
(<em class="EMPHASIS">SYN/ACK</em>), то соединению присваивается статус
<strong class="COMMAND">ESTABLISHED</strong>. Почему именно второй пакет?
Сейчас разберемся. Строя свой набор правил, Вы можете позволить покидать
локальную сеть пакетам со статусом <strong class="COMMAND">NEW</strong> и
<strong class="COMMAND">ESTABLISHED</strong>, а во входящем трафике
пропускать пакеты только со статусом <strong class="COMMAND">ESTABLISHED
</strong>, и все будет работать прекрасно. И наоборот, если бы трассировщик
продолжал считать соединение как <strong class="COMMAND">NEW</strong>,
то фактически Вам никогда не удалось бы установить соединение с
внешним миром, либо пришлось бы позволить прохождение
<strong class="COMMAND">NEW</strong>-пакетов в локальную сеть.
С точки зрения ядра все выглядит более сложным, поскольку в
пространстве ядра <em class="EMPHASIS">TCP</em>-соединения имеют ряд
промежуточных состояний, недоступных в пространстве пользователя.
В общих чертах они соответствуют спецификации <a href="links.htm#RFC793"><em>
RFC 793. Transmission Control Protocol</em></a> на странице 21-23.
Более подробно эта тема будет рассматриваться чуть ниже.</p>
<p><img src="images/state-tcp-connecting.jpg"></p>

<p>С точки зрения пользователя все выглядит достаточно просто,
однако если посмотреть с точки зрения ядра, то все выглядит несколько сложнее.
Рассмотрим порядок изменения состояния соединения в таблице
<tt class="FILENAME">/proc/net/ip_conntrack</tt>. После передачи первого
пакета <strong class="COMMAND">SYN</strong>.</p>
<pre class="SCREEN">
tcp6 117 SYN_SENT src=192.168.1.5 dst=192.168.1.35 sport=1031 \
     dport=23 [UNREPLIED] src=192.168.1.35 dst=192.168.1.5 sport=23 \
     dport=1031 use=1
</pre>

<p>Как видите, запись в таблице отражает точное состояние соединения:
был отмечен факт передачи пакета SYN (флаг <tt class="COMPUTEROUTPUT">
SYN_SENT</tt>), на который ответа пока не было (флаг
<tt class="COMPUTEROUTPUT">[UNREPLIED]</tt>). После получения пакета-ответа,
соединение переводится в следующее внутреннее состояние:</p>
<pre class="SCREEN">
tcp6 57 SYN_RECV src=192.168.1.5 dst=192.168.1.35 sport=1031 \
     dport=23 src=192.168.1.35 dst=192.168.1.5 sport=23 dport=1031 use=1
</pre>

<p>Теперь запись сообщает о том, что обратно прошел пакет
<em class="EMPHASIS">SYN/ACK</em>. На этот раз соединение переводится в
состояние <tt class="COMPUTEROUTPUT">SYN_RECV</tt>. Это состояние говорит
о том, что пакет <em class="EMPHASIS">SYN</em> был благополучно доставлен
получателю и в ответ на него пришел пакет-подтверждение
(<em class="EMPHASIS">SYN/ACK</em>). Кроме того, механизм определения
состояния &quot;увидев&quot; пакеты, следующие в обеих направлениях,
снимает флаг <tt class="COMPUTEROUTPUT">[UNREPLIED]</tt>. И наконец после
передачи заключительного <em class="EMPHASIS">ACK</em>-пакета
в процедуре установления соединения</p>
<pre class="SCREEN">
tcp6 431999 ESTABLISHED src=192.168.1.5 dst=192.168.1.35 \
     sport=1031 dport=23 src=192.168.1.35 dst=192.168.1.5 \
     sport=23 dport=1031 use=1
</pre>

<p>Соединение переходит в состояние
<strong class="COMMAND">ESTABLISHED</strong> (установленное).
После приема нескольких пакетов через это соединение,
к нему добавится флаг <tt class="COMPUTEROUTPUT">[ASSURED]</tt> (уверенное).
</p>

<p>При закрытии <em class="EMPHASIS">TCP</em>-соединение проходит
через следующие состояния.</p>
<p><img src="images/state-tcp-closing.jpg"></p>

<p>Как видно из рисунка, соединение не закрывается до тех пор,
пока не будет передан последний пакет <em class="EMPHASIS">ACK</em>.
Обратите внимание: эта картинка описывает нормальный
процесс закрытия соединения. Кроме того, если соединение отвергается,
оно может быть закрыто передачей пакета <em class="EMPHASIS">RST</em> (сброс).
В этом случае соединение будет закрыто по истечение предопределенного времени.
</p>

<p>При закрытии соединение переводится в состояние
<tt class="COMPUTEROUTPUT">TIME_WAIT</tt>, продолжительность
которого по умолчанию соответствует 2 минутам, в течение которого еще
возможно прохождение пакетов через брандмауэр. Это является своего рода
&quot;буферным временем&quot;, которое дает возможность пройти пакетам,
&quot;увязшим&quot; на том или ином маршрутизаторе (роутере).</p>

<p>Если соединение закрывается по получении пакета
<em class="EMPHASIS">RST</em>, то оно переводится в состояние
<tt class="COMPUTEROUTPUT">CLOSE</tt>. Время ожидания до фактического
закрытия соединения по умолчанию устанавливается равным 10 секунд.
Подтверждение на пакеты <em class="EMPHASIS">RST</em> не передается,
и соединение закрывается сразу же.
Кроме того, имеется ряд других внутренних состояний.
В таблице ниже приводится список возможных внутренних состояний соединения и
соответствующие им размеры таймаутов.</p>

<a name="TABLE.INTERNALSTATES"></a>
<p><strong>Таблица 4-2. Internal states</strong></p>
<table border="1" class="CALSTABLE">
<thead><tr><th width="17%" align="left" valign="top">Состояние</th>
<th width="83%" align="left" valign="top">Время ожидания</th></tr></thead>
<tbody><tr><td width="17%" align="left" valign="top">NONE</td>
<td width="83%" align="left" valign="top">30 минут</td></tr>
<tr><td width="17%" align="left" valign="top">ESTABLISHED</td>
<td width="83%" align="left" valign="top">5 дней</td></tr>
<tr><td width="17%" align="left" valign="top">SYN_SENT</td>
<td width="83%" align="left" valign="top">2 минуты</td></tr>
<tr><td width="17%" align="left" valign="top">SYN_RECV</td>
<td width="83%" align="left" valign="top">60 секунд</td></tr>
<tr><td width="17%" align="left" valign="top">FIN_WAIT</td>
<td width="83%" align="left" valign="top">2 минуты</td></tr>
<tr><td width="17%" align="left" valign="top">TIME_WAIT</td>
<td width="83%" align="left" valign="top">2 минуты</td></tr>
<tr><td width="17%" align="left" valign="top">CLOSE</td>
<td width="83%" align="left" valign="top">10 секунд</td></tr>
<tr><td width="17%" align="left" valign="top">CLOSE_WAIT</td>
<td width="83%" align="left" valign="top">12 часов</td></tr>
<tr><td width="17%" align="left" valign="top">LAST_ACK</td>
<td width="83%" align="left" valign="top">30 секунд</td></tr>
<tr><td width="17%" align="left" valign="top">LISTEN&gt;</td>
<td width="83%" align="left" valign="top">2 минуты</td></tr></tbody></table>

<p>Эти значения могут несколько изменяться от версии к версии ядра,
кроме того, они могут быть изменены через интерфейс файловой системы
<tt class="FILENAME">/proc</tt> (переменные <tt class="FILENAME">
proc/sys/net/ipv4/netfilter/ip_ct_tcp_*</tt>).
Значения устанавливаются в сотых долях секунды,
так что число 3000 означает 30 секунд.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Обратите внимание на то,
что со стороны пользователя, механизм определения состояния никак не
отображает состояние флагов <em class="EMPHASIS">TCP</em>-пакетов.
Как правило, это не всегда хорошо, поскольку состояние
<strong class="COMMAND">NEW</strong> присваивается, не только пакетам
<em class="EMPHASIS">SYN</em>.</p>

<p>Это качество трассировщика может быть использовано
для избыточного файрволлинга (firewalling), но для случая
домашней локальной сети, в которой используется только один брандмауэр,
это очень плохо. Эта проблема более подробно обсуждается в разделе
<a href="problems.htm#NEWNOTSYN"><em>Пакеты со статусом NEW и
со сброшенным битом SYN</em></a> приложения
<a href="problems.htm#COMMONPROBLEMS"><em>Общие проблемы и вопросы</em></a>.
Альтернативным вариантом решения этой проблемы может служить установка
заплаты <strong class="COMMAND">tcp-window-tracking</strong> из
<strong class="COMMAND">patch-o-matic</strong>,
которая сделает возможным принятие решений в зависимости от значения
<em class="EMPHASIS">TCP window</em>.</p></td></tr></table>

<hr><h1 class="SECTION"><a name="UDPCONNECTIONS">4.5. UDP-соединения</a></h1>
<p>По сути своей <em class="EMPHASIS">UDP</em>-соединения
не имеют признака состояния. Этому имеется несколько причин, основная из них
состоит в том, что этот протокол не предусматривает
установления и закрытия соединения, но самый большой
недостаток отсутствие информации об очередности поступления пакетов.
Приняв две датаграммы <em class="EMPHASIS">UDP</em>, невозможно сказать точно,
в каком порядке они были отправлены. Однако, даже в этой ситуации все
еще возможно определить состояние соединения. Ниже приводится рисунок того,
как выглядит установление соединения с точки зрения трассировщика.</p>
<p><img src="images/state-udp-connection.jpg"></p>

<p>Из рисунка видно, что состояние <em class="EMPHASIS">UDP</em>-соединения
определяется почти так же, как и состояние
<em class="EMPHASIS">TCP</em>-соединения, с точки зрения из
пользовательского пространства. Изнутри же это выглядит несколько иначе,
хотя во многом похоже. Для начала посмотрим на запись,
появившуюся после передачи первого пакета <em class="EMPHASIS">UDP</em>.</p>

<pre class="SCREEN">
udp17 20 src=192.168.1.2 dst=192.168.1.5 sport=137 dport=1025 \
      [UNREPLIED] src=192.168.1.5 dst=192.168.1.2 sport=1025 dport=137 use=1
</pre>

<p>Первое, что мы видим, это название протокола (udp) и его
номер (см. /etc/protocols). Третье значение,
оставшееся &quot;время жизни&quot; записи в секундах.
Далее следуют характеристики пакета, прошедшего через брандмауэр,
это адреса и порты отправителя и получателя. Здесь же видно,
что это первый пакет в сессии (флаг
<tt class="COMPUTEROUTPUT">[UNREPLIED]</tt>). И завершают запись
адреса и порты отправителя и получателя ожидаемого пакета.
Таймаут такой записи по умолчанию составляет 30 секунд.</p>
<pre class="SCREEN">
udp17 170 src=192.168.1.2 dst=192.168.1.5 sport=137 \
      dport=1025 src=192.168.1.5 dst=192.168.1.2 sport=1025 dport=137 use=1
</pre>

<p>После того как сервер &quot;увидел&quot; ответ на первый пакет,
соединение считается <strong class="COMMAND">ESTABLISHED</strong>
(установленным), единственное отличие от предыдущей записи состоит в
отсутствии флага <tt class="COMPUTEROUTPUT">[UNRREPLIED]</tt> и, кроме того,
таймаут для записи стал равным 180 секундам. После этого может только
добавиться флаг <tt class="COMPUTEROUTPUT">[ASSURED]</tt>
(уверенное соединение), который был описан выше.
Флаг <tt class="COMPUTEROUTPUT">[ASSURED]</tt> устанавливается только
после прохождения некоторого количества пакетов через соединение.</p>
<pre class="SCREEN">
udp17 175 src=192.168.1.5 dst=195.22.79.2 sport=1025 \
      dport=53 src=195.22.79.2 dst=192.168.1.5 sport=53 \
      dport=1025 [ASSURED] use=1
</pre>

<p>Теперь соединение стало &quot;уверенным&quot;. Запись в таблице выглядит
практически так же, как и в предыдущем примере, за исключением флага
<tt class="COMPUTEROUTPUT">[ASSURED]</tt>. Если в течение 180 секунд через
соединение не пройдет хотя бы один пакет, то запись будет удалена из таблицы.
Это достаточно маленький промежуток времени, но его вполне достаточно
для большинства применений. &quot;Время жизни&quot; отсчитывается от момента
прохождения последнего пакета, при появлении нового время
переустанавливается в свое начальное значение, это справедливо и для всех
остальных типов внутренних состояний.</p>

<hr><h1 class="SECTION"><a name="ICMPCONNECTIONS">4.6. ICMP-соединения</a>
</h1>
<p><em class="EMPHASIS">ICMP</em>-пакеты используются только для
передачи управляющих сообщений и не организуют постоянного соединения.
Однако, существует 4 типа <em class="EMPHASIS">ICMP</em>-пакетов, которые
вызывают передачу ответа, поэтому они могут иметь два состояния:
<strong class="COMMAND">NEW</strong> и <strong class="COMMAND">ESTABLISHED
</strong>. К этим пакетам относятся <em class="EMPHASIS">ICMP Echo
Request/Echo Reply</em>, <em class="EMPHASIS">ICMP Timestamp
Request/Timestamp Reply</em>, <em class="EMPHASIS">ICMP Information
Request/Information Reply</em> и <em class="EMPHASIS">ICMP Address Mask
Request/Address Mask Reply</em>.
Из них <em class="EMPHASIS">ICMP Timestamp Request/Timestamp Reply</em>
и <em class="EMPHASIS">ICMP Information Request/Information Reply</em>
считаются устаревшими и поэтому, в большинстве случаев, могут быть
безболезненно сброшены (<strong class="COMMAND">DROP</strong>).
Взгляните на рисунок ниже.</p>
<p><img src="images/state-icmp-ping.jpg"></p>

<p>Как видно из этого рисунка, сервер выполняет <em class="EMPHASIS">Echo Request</em> (эхо-запрос) к клиенту,
который (запрос) распознается брандмауэром как <strong class="COMMAND">NEW</strong>. На этот запрос клиент отвечает
пакетом <em class="EMPHASIS">Echo Reply</em>, и теперь пакет
распознается как имеющий состояние <strong class="COMMAND">ESTABLISHED</strong>. После прохождения
первого пакета (<em class="EMPHASIS">Echo Request</em>) в
<tt class="FILENAME">ip_conntrack</tt> появляется запись:</p>
<pre class="SCREEN">
icmp 1 25 src=192.168.1.6 dst=192.168.1.10 type=8 code=0 \
     id=33029 [UNREPLIED] src=192.168.1.10 dst=192.168.1.6 \
     type=0 code=0 id=33029 use=1
</pre>

<p>Эта запись несколько отличается от записей, свойственных
протоколам <em class="EMPHASIS">TCP</em> и <em class="EMPHASIS">UDP</em>,
хотя точно так же присутствуют
название протокола, время таймаута и адреса передатчика и
приемника, но далее появляются три новых поля:
<tt class="COMPUTEROUTPUT">type</tt>, <tt class="COMPUTEROUTPUT">code</tt> и
<tt class="COMPUTEROUTPUT">id</tt>. Поле <tt class="COMPUTEROUTPUT">type</tt>
содержит тип <em class="EMPHASIS">ICMP</em>, поле
<tt class="COMPUTEROUTPUT">code</tt>,
код <em class="EMPHASIS">ICMP</em>. Значения типов и кодов
<em class="EMPHASIS">ICMP</em> приводятся в приложении
<a href="typeicmp.htm#ICMPTYPES"><em>Типы ICMP</em></a>. И последнее поле
<tt class="COMPUTEROUTPUT">id</tt> содержит идентификатор пакета. Каждый
<em class="EMPHASIS">ICMP</em>-пакет имеет свой идентификатор.
Когда приемник, в ответ на <em class="EMPHASIS">ICMP</em>-запрос посылает
ответ, он подставляет в пакет ответа этот идентификатор, благодаря
чему, передатчик может корректно распознать в ответ на какой
запрос пришел ответ.</p>

<p>Следующее поле флаг <tt class="COMPUTEROUTPUT">[UNREPLIED]</tt>,
который встречался нам ранее. Он означает, что прибыл
первый пакет в соединении. Завершается запись характеристиками
ожидаемого пакета ответа. Сюда включаются адреса отправителя и получателя.
Что касается типа и кода <em class="EMPHASIS">ICMP</em>-пакета,
то они соответствуют правильным значениям ожидаемого пакета
<em class="EMPHASIS">ICMP Echo Reply</em>. Идентификатор пакета-ответа
тот же, что и в пакете запроса.</p>

<p>Пакет ответа распознается уже как
<strong class="COMMAND">ESTABLISHED</strong>. Однако, мы знаем, что
после передачи пакета ответа, через это соединение уже ничего
не ожидается, поэтому после прохождения ответа через netfilter,
запись в таблице трассировщика уничтожается.</p>

<p>В любом случае запрос рассматривается как
<strong class="COMMAND">NEW</strong>, а ответ как
<strong class="COMMAND">ESTABLISHED</strong>.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>

<td align="left" valign="top"><p>Заметьте при этом, что пакет ответа должен
совпадать по своим характеристикам (адреса отправителя и получателя,
тип, код и идентификатор) с указанными в записи в таблице трассировщика,
это справедливо и для всех остальных типов трафика.</p></td></tr></table>

<p>ICMP-запросы имеют таймаут, по умолчанию, 30 секунд.
Этого времени в большинстве случаев вполне достаточно.
Время таймаута можно изменить в
<tt class="FILENAME">/proc/sys/net/ipv4/netfilter/ip_ct_icmp_timeout</tt>.
Напоминаю, что переменные типа
<tt class="FILENAME">/proc/sys/net/ipv4/netfilter/ip_ct_*</tt>
становятся доступны только после установки
&quot;заплаты&quot; tcp-window-tracking из patch-o-matic.</p>

<p>Значительная часть <em class="EMPHASIS">ICMP</em> используется для
передачи сообщений о том, что происходит с тем или иным
<em class="EMPHASIS">UDP</em> или <em class="EMPHASIS">TCP</em>-соединением.
В связи с этим, они очень часто распознаются как связанные
(<strong class="COMMAND">RELATED</strong>) с существующим соединением.
Простым примером могут служить сообщения <em class="EMPHASIS">ICMP Host
Unreachable</em> или <em class="EMPHASIS">ICMP Network Unreachable</em>.
Они всегда порождаются при попытке соединиться с узлом сети, когда этот узел
или сеть недоступны, в этом случае последний маршрутизатор вернет
соответствующий <em class="EMPHASIS">ICMP</em>-пакет, который будет распознан
как <strong class="COMMAND">RELATED</strong>. На рисунке ниже показано
как это происходит.</p>
<p><img src="images/state-tcp-icmp-reply.jpg"></p>

<p>В этом примере некоторому узлу передается запрос на соединение
(<em class="EMPHASIS">SYN</em>-пакет). Он приобретает статус
strong class="COMMAND">NEW</strong> на брандмауэре. Однако, в этот момент
времени сеть оказывается недоступной, поэтому роутер возвращает пакет
<em class="EMPHASIS">ICMP Network Unreachable</em>.
Трассировщик соединений распознает этот пакет как
<strong class="COMMAND">RELATED</strong>, благодаря уже имеющейся
записи в таблице, так что пакет благополучно будет передан клиенту,
который затем оборвет неудачное соединение. Тем временем,
брандмауэр уничтожит запись в таблице, поскольку для данного соединения было
получено сообщение об ошибке.</p>

<p>Тоже самое происходит и с <em class="EMPHASIS">UDP</em>-соединениями:
если обнаруживаются подобные проблемы. Все сообщения
<em class="EMPHASIS">ICMP</em>, передаваемые в ответ на
<em class="EMPHASIS">UDP</em>-соединение, рассматриваются как
<strong class="COMMAND">RELATED</strong>. Взгляните на следующий рисунок.</p>
<p><img src="images/state-udp-icmp-reply.jpg"></p>

<p>Датаграмма <em class="EMPHASIS">UDP</em> передается на сервер. Соединению
присваивается статус <strong class="COMMAND">NEW</strong>.
Однако доступ к сети запрещен (брандмауэром или роутером),
поэтому обратно возвращается сообщение <em class="EMPHASIS">ICMP Network
Prohibited</em>. Брандмауэр распознает это сообщение,
как связанное с открытым <em class="EMPHASIS">UDP</em>-соединением,
присваивает ему статус <strong class="COMMAND">RELATED</strong> и
передает клиенту. После чего запись в таблице трассировщика уничтожается,
а клиент благополучно обрывает соединение.</p>

<hr><h1 class="SECTION"><a name="DEFAULTCONNECTIONS">
4.7. Поведение по умолчанию</a></h1>
<p>В некоторых случаях механизм определения состояния не
может распознать протокол обмена и, соответственно, не может
выбрать стратегию обработки этого соединения. В этом случае он переходит к
заданному по умолчанию поведению. Поведение по умолчанию используется,
например, при обслуживании протоколов <em class="EMPHASIS">NETBLT</em>,
<em class="EMPHASIS">MUX</em> и <em class="EMPHASIS">EGP</em>.
Поведение по-молчанию во многом схоже с трассировкой
<em class="EMPHASIS">UDP</em>-соединений. Первому пакету присваивается статус
<strong class="COMMAND">NEW</strong>, а всем последующим статус
<strong class="COMMAND">ESTABLISHED</strong>.</p>

<p>При использовании поведения по умолчанию, для всех пакетов
используется одно и то же значение таймаута, которое можно изменить в
<tt class="FILENAME">/proc/sys/net/ipv4/netfilter/ip_ct_generic_timeout</tt>.
по умолчанию это значение равно 600 секундам или 10 минутам
В зависимости от типа трафика, это время может меняться,
особенно когда соединение устанавливается по спутниковому каналу.</p>

<hr><h1 class="SECTION"><a name="COMPLEXPROTOCOLS">
4.8. Трассировка комплексных протоколов</a></h1>
<p>Имеется ряд комплексных протоколов, корректная трассировка
которых более сложна. Прмером могут служить протоколы
<em class="EMPHASIS">ICQ</em>, <em class="EMPHASIS">IRC</em> и
<em class="EMPHASIS">FTP</em>. Каждый из этих протоколов несет
дополнительную информацию о соединении в области данных пакета.
Соответственно корректная трассировка таких соединений требует подключения
дополнительных вспомогательных модулей.</p>

<p>В качестве первого примера рассмотрим протокол
<em class="EMPHASIS">FTP</em>. Протокол <em class="EMPHASIS">FTP</em> сначала
открывает одиночное соединение, которое называется &quot;сеансом управления
FTP&quot; (<em class="EMPHASIS">FTP control session</em>).
При выполнении команд в пределах этого сеанса, для передачи сопутствующих
данных открываются дополнительные порты. Эти соединения могут
быть активными или пассивными. При создании активного соединения клент
передает <em class="EMPHASIS">FTP</em>-серверу номер порта и
<em class="EMPHASIS">IP</em>-адрес для соединения.
Затем клиент открывает порт, сервер подключает к заданному порту клиента
свой порт с номером 20 (известный как <em class="EMPHASIS">FTP-Data</em>)
и передает данные через установленное соединение.</p>

<p>Проблема состоит в том, что брандмауэр ничего не знает об
этих дополнительных подключениях, поскольку вся информация о
них передается через область данных пакета. Из-за этого брандмауэр не
позволит серверу соединиться с указанным портом клиента.</p>

<p>Решение проблемы состоит в добавлении специального
вспомогательного модуля трассировки, который отслеживает,
специфичную для данного протокола, информацию в области данных пакетов,
передаваемых в рамках сеанса управления. При создании такого соединения,
вспомогательный модуль корректно воспримет передаваемую информацию и создаст
соответствующую запись в таблице трассировщика со статусом
<strong class="COMMAND">RELATED</strong>, благодаря чему
соединение будет установлено. Рисунок ниже поясняет порядок
выполнения подобного соединения.</p>
<p><img src="images/state-tcp-server-subconn.jpg"></p>

<p>Пассивный <em class="EMPHASIS">FTP</em> действует противоположным образом.
Клиент посылает запрос серверу на получение данных,
а сервер возвращает клиенту <em class="EMPHASIS">IP</em>-адрес и номер
порта для подключения. Клиент подключает свой 20-й порт
(<em class="EMPHASIS">FTP-data</em>) к указанному порту сервера и
получает запрошенные данные. Если Ваш FTP-сервер находится за брандмауэром,
то Вам потребуется этот вспомогательный модуль для того, чтобы сервер смог
обслуживать клиентов из Интернет. Тоже самое касается случая, когда Вы хотите
ограничить своих пользователей только возможностью подключения к
<em class="EMPHASIS">HTTP</em> и <em class="EMPHASIS">FTP</em>-серверам в
Интернет и закрыть все остальные порты. Рисунок ниже показывает,
как выполняется пассивное соединение <em class="EMPHASIS">FTP</em>.</p>
<p><img src="images/state-tcp-client-subconn.jpg"></p>

<p>Некоторые вспомогательные модули уже включены в состав ядра.
Если быть более точным, то в состав ядра включены вспомогательные
модули для протоколов <em class="EMPHASIS">FTP</em> и
<em class="EMPHASIS">IRC</em>. Если в Вашем распоряжении нет
необходимого вспомогательного модуля, то Вам следует
обратиться к <em class="EMPHASIS">patch-o-matic</em>, который содержит
большое количество вспомогательных модулей для трассировки таких протоколов,
как <em class="EMPHASIS">ntalk</em> или <em class="EMPHASIS">H.323</em>.
Если и здесь Вы не нашли то, что нужно, то есть еще варианты: Вы можете
обратиться к CVS iptables, если искомый вспомогательный
модуль еще не был включен в <em class="EMPHASIS">patch-o-matic</em>,
либо можете войти в контакт с разработчиками netfilter и узнать у них,
имеется ли подобный модуль и планируется ли он к выпуску. Если и тут Вы
потерпели неудачу, то наверное Вам следует прочитать
<a href="#NETFILTERHACKINGHOWTO">Rusty Russell&#39;s Unreliable
Netfilter Hacking HOW-TO</a>.</p>

<p>Вспомогательные модули могут быть скомпилированы как в
виде подгружаемых модулей ядра, так и статически связаны с ядром.
Если они скомпилированы как модули, то Вы можете загрузить их командой:</p>
<pre class="SCREEN">
<strong class="COMMAND">modprobe ip_conntrack_*</strong>
</pre>

<p>Обратите внимание на то, что механизм определения
состояния не имеет никакого отношения к трансляции сетевых адресов
(<em class="EMPHASIS">NAT</em>), поэтому Вам может потребоваться большее
количество дополнительных модулей, если Вы выполняете такую трансляцию.
Допустим, что Вы выполняете трансляцию адресов и трассировку
<em class="EMPHASIS">FTP</em>-соединений, тогда необходим также и
соответствующий вспомогательный модуль <em class="EMPHASIS">NAT</em>.
Имена вспомогательных модулей <em class="EMPHASIS">NAT</em> начинаются с
ip_nat_, в соответствии с соглашением об именах. В данном случае модуль
называется <em class="EMPHASIS">ip_nat_ftp</em>. Для протокола
<em class="EMPHASIS">IRC</em> такой модуль будет называться
<em class="EMPHASIS">ip_nat_irc</em>. Тому же самому соглашению
следуют и названия вспомогательных модулей трассировщика, например:
<em class="EMPHASIS">ip_conntrack_ftp</em> и
<em class="EMPHASIS">ip_conntrack_irc</em>.</p>

<hr><h1><a name="SAVEANDRESTORE">Глава 5. Сохранение и восстановление
больших наборов правил</a></h1>
<p>В состав пакета <strong class="COMMAND">iptables</strong> входят две очень
удобные утилиты, особенно если Вам приходится иметь дело с
большими наборами правил. Называются они <strong class="COMMAND">
iptables-save</strong> и <strong class="COMMAND">iptables-restore</strong>.
Первая из них сохраняет, а вторая восстанавливает наборы правил в/из файла.
По своему формату файл с набором правил похож на обычные файлы скриптов
командной оболочки (shell), в чем Вы сможете убедиться чуть ниже.</p>

<hr><h1 class="SECTION"><a name="SPEEDCONSIDERATIONS">5.1. Плюсы</a></h1>
<p>Один из плюсов использования утилит <strong class="COMMAND">iptables-save
</strong> и <strong class="COMMAND">iptables-restore</strong> состоит в
высокой скорости загрузки и сохранения больших наборов правил.
Главный недостаток, связанный с установкой наборов правил из
скриптов командной оболочки состоит в том, что команда
<strong class="COMMAND">iptables</strong> копирует набор правил из
пространства ядра в пространство пользователя, вставляет,
добавляет или изменяет правило и, наконец, весь набор правил
копируется обратно в пространство ядра. Эта последовательность действий
выполняется для каждого правила, которое вставляется или
изменяется в наборе правил.</p>

<p>Эта проблема легко решается с помощью
<strong class="COMMAND">iptables-save</strong> и
<strong class="COMMAND">iptables-restore</strong>.
Утилита <strong class="COMMAND">iptables-save</strong> записывает набор
правил в обычный текстовый файл в особом формате.
Утилита <strong class="COMMAND">iptables-restore</strong> загружает набор
правил из файла. Главное преимущество этих утилит состоит в том,
что они производят сохранение/восстановление всего набора правил
за одно обращение. <strong class="COMMAND">iptables-save</strong>
&quot;в один присест&quot; получает из пространства ядра и записывает в
файл весь набор правил, а <strong class="COMMAND">iptables-restore</strong>
загружает из файла и переписывает за одно обращение в пространство ядра набор
правил для каждой таблицы. Или другими словами: вместо того, чтобы обращаться
огромное число раз к ядру для того, чтобы получить набор правил,
а затем опять записать его в пространство ядра не меньшее число раз,
можно просто сохранить набор правил в файл, а затем загружать его из файла,
при этом число перемещений наборов в ядро будет
зависеть только от числа используемых таблиц.</p>

<p>Вы уже наверняка поняли, что эти утилиты могут представлять для Вас
интерес, особенно если Вам приходится
загружать огромные наборы правил. Однако использование этих
утилит имеет и свои отрицательные стороны, которые мы
рассмотрим в следующем разделе.</p>

<hr><h1 class="SECTION"><a name="DRAWBACKSWITHRESTORE">5.2. И минусы</a></h1>
<p>У Вас может сложиться впечатление, что
<strong class="COMMAND">iptables-restore</strong> может обрабатывать
своего рода скрипты. Пока не может и, вероятнее всего, никогда не сможет.
В этом и состоит главный недостаток
<strong class="COMMAND">iptables-restore</strong>. Чтобы было более
понятно: представьте себе случай, когда брандмауэр получает
динамический IP-адрес, и Вы хотите вставить его значение в
свои правила во время загрузки системы. Решить эту проблему с помощью
<strong class="COMMAND">iptables-restore</strong> практически невозможно.</p>

<p>Как одно из решений можно предложить написать небольшой скрипт,
который определяет значение IP-адреса и затем
вставляет его в набор правил (например, с помощью
<strong class="COMMAND">sed</strong>) на место некоторого ключевого слова.
Здесь Вам потребуется создать временный файл, в котором производятся
изменения и который затем загружается с помощью
<strong class="COMMAND">iptables-restore</strong>. Однако такой вариант
решения порождает свои проблемы: Вам придется отказаться от утилиты
<strong class="COMMAND">iptables-save</strong> поскольку она может
затереть созданную вручную заготовку файла с правилами для
<strong class="COMMAND">iptables-restore</strong>.
В общем, довольно неуклюжее решение.</p>

<p>Еще один вариант: хранить в файле для
<strong class="COMMAND">iptables-restore</strong> только статические
правила, а затем с помощью небольшого скрипта добавлять
правила с динамическими параметрами. Конечно же Вы уже
поняли, что это решение такое же неуклюжее, как и первое.
Вам придется смириться с тем, что
<strong class="COMMAND">iptables-restore</strong> не очень хорошо
подходит для случая с динамически назначаемым IP-адресом и
вообще для случаев, когда Вам потребуется динамически
изменять набор правил в зависимости от конфигурации системы и т.п.</p>

<p>Еще один недостаток <strong class="COMMAND">iptables-restore</strong> и
<strong class="COMMAND">iptables-save</strong> в том, что их
функциональность не всегда соответствует описанной. Проблема состоит в том,
что не многие пользуются этими утилитами, еще меньше людей вовлечено в
процесс поиска ошибок в этих программах. Поэтому, при использовании
некоторых, вновь появившихся, критериев или действий Вы можете столкнуться с
неожиданным поведением своих правил. Несмотря на возможное
существование некоторых проблем, я все же настоятельно
рекомендую к использованию эти два инструмента, которые прекрасно работают в
большинстве случаев, исключение могут составлять лишь некоторые
новые критерии и действия.</p>

<hr><h1 class="SECTION"><a name="IPTABLES-SAVE">5.3. iptables-save</a></h1>
<p>Утилита <strong class="COMMAND">iptables-save</strong>, как я уже
упоминал, предназначена для сохранения текущего набора правил в файл,
который затем может быть использован утилитой
<strong class="COMMAND">iptables-restore</strong>. Эта команда очень
проста в использовании и имеет всего два аргумента.</p>

<p><strong class="COMMAND">iptables-save</strong> [-c] [-t
<tt class="REPLACEABLE"><em>table</em></tt>]</p>

<p>Первый аргумент <strong class="COMMAND">-c</strong> (допустимо
использовать более длинный вариант
<strong class="COMMAND">--counters</strong>) заставляет
<strong class="COMMAND">iptables-save</strong> сохранить знчения
счетчиков байт и пакетов. Это делает возможным рестарт
брандмауэра без потери счетчиков, которые могут использоваться
для подсчета статистики. По умолчанию, при запуске без ключа
<strong class="COMMAND">-с</strong>, сохранение счетчиков не производится.</p>

<p>С помощью ключа <strong class="COMMAND">-t</strong> (более длинный вариант
<strong class="COMMAND">--table</strong>) можно указать имя
таблицы для сохранения. Если ключ <strong class="COMMAND">-t</strong>
не задан, то сохраняются все таблицы. Ниже приведен пример работы команды
<strong class="COMMAND">iptables-save</strong> в случае, когда набор не
содержит ни одного правила.</p>

<pre class="SCREEN">
# Generated by iptables-save v1.2.6a on Wed Apr 24 10:19:17 2002
*filter
:INPUT ACCEPT [404:19766]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [530:43376]
COMMIT
# Completed on Wed Apr 24 10:19:17 2002
# Generated by iptables-save v1.2.6a on Wed Apr 24 10:19:17 2002
*mangle
:PREROUTING ACCEPT [451:22060]
:INPUT ACCEPT [451:22060]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [594:47151]
:POSTROUTING ACCEPT [594:47151]
COMMIT
# Completed on Wed Apr 24 10:19:17 2002
# Generated by iptables-save v1.2.6a on Wed Apr 24 10:19:17 2002
*nat
:PREROUTING ACCEPT [0:0]
:POSTROUTING ACCEPT [3:450]
:OUTPUT ACCEPT [3:450]
COMMIT
# Completed on Wed Apr 24 10:19:17 2002
</pre>

<p>Строки, начинающиеся с символа #, являются комментариями.
Имена таблиц начинаются с символа * (звездочка), например:
<tt class="COMPUTEROUTPUT">*mangle</tt>. После каждого имени
таблицы следуют описания цепочек и правил. Описания цепочек записываются в
формате :&lt;chain-name&gt; &lt;chain-policy&gt;
[&lt;packet-counter&gt;:&lt;byte-counter&gt;], где
&lt;chain-name&gt; это название цепочки (например,
<span class="SYSTEMITEM">PREROUTING</span>), &lt;chain-policy&gt;
политика по умолчанию (например, <span class="SYSTEMITEM">ACCEPT</span>).
Завершают описание цепочки значения счетчиков пакетов и байт,
те самые счетчики, которые Вы получите в результате выполнения команды
<strong class="COMMAND">iptables -L -v</strong>. Описание каждой таблицы
завершает ключевое слово <tt class="COMPUTEROUTPUT">COMMIT</tt>,
которое означает, что в этой точке набор правил для данной таблицы будет
передан в пространство ядра.</p>

<p>Пример выше показал как выглядит содержимое пустого набора
правил, сохраненного утилитой <strong class="COMMAND">iptables-save</strong>.
Ниже показан результат сохранения небольшого набора правил
(<a href="glava08.htm#IPTSAVE-RULESET"><em>Iptables-save ruleset</em></a>):
</p>
<pre class="SCREEN">
# Generated by iptables-save v1.2.6a on Wed Apr 24 10:19:55 2002
*filter
:INPUT DROP [1:229]
:FORWARD DROP [0:0]
:OUTPUT DROP [0:0]
[0:0] -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
[0:0] -A FORWARD -i eth0 -m state --state RELATED,ESTABLISHED -j ACCEPT
[0:0] -A FORWARD -i eth1 -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
[0:0] -A OUTPUT -m state --state NEW,RELATED,ESTABLISHED -j ACCEPT
COMMIT
# Completed on Wed Apr 24 10:19:55 2002
# Generated by iptables-save v1.2.6a on Wed Apr 24 10:19:55 2002
*mangle
:PREROUTING ACCEPT [658:32445]
:INPUT ACCEPT [658:32445]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [891:68234]
:POSTROUTING ACCEPT [891:68234]
COMMIT
# Completed on Wed Apr 24 10:19:55 2002
# Generated by iptables-save v1.2.6a on Wed Apr 24 10:19:55 2002
*nat
:PREROUTING ACCEPT [1:229]
:POSTROUTING ACCEPT [3:450]
:OUTPUT ACCEPT [3:450]
[0:0] -A POSTROUTING -o eth0 -j SNAT --to-source 195.233.192.1
COMMIT
# Completed on Wed Apr 24 10:19:55 2002
</pre>

<p>Из примера виден результат действия аргумента
<strong class="COMMAND">-c</strong>: перед каждым правилом и в
строке описания каждой цепочки имеются числа,
отображающие содержимое счетчиков пакетов и байт. Сразу замечу, что набор
правил утилита <strong class="COMMAND">iptables-save</strong> выдает на
стандартный вывод, поэтому при сохранении набора в файл команда должна
выглядеть примерно так:</p>
<p><strong class="COMMAND">iptables-save -c &gt; /etc/iptables-save</strong>
</p>
<p>Эта команда запишет весь набор правил, вместе с содержимым счетчиков,
в файл с именем <tt class="FILENAME">/etc/iptables-save</tt>.</p>

<hr><h1 class="SECTION"><a name="IPTABLES-RESTORE">5.4. iptables-restore</a>
</h1>
<p>Утилита <strong class="COMMAND">iptables-restore</strong> используется для
восстановления (загрузки) набора правил, который ранее был сохранен утилитой
<strong class="COMMAND">iptables-save</strong>. Набор правил утилита
получает со стандартного ввода и не может загружать его из файла напрямую.
Команда имеет следующий синтаксис:</p>
<p><strong class="COMMAND">iptables-restore</strong> [-c] [-n]</p>

<p>Ключ <strong class="COMMAND">-c</strong> (более длинный вариант
<strong class="COMMAND">--counters</strong>) заставляет
восстанавливать значения счетчиков.</p>

<p>Указание ключа <strong class="COMMAND">-n</strong> (более длинный вариант
<strong class="COMMAND">--noflush</strong>) сообщает
<strong class="COMMAND">iptables-restore</strong> о том, что правила
должны быть добавлены к имеющимся. По умолчанию утилита
<strong class="COMMAND">iptables-restore</strong> (без ключа
<strong class="COMMAND">-n</strong>) очистит содержимое таблиц и
цепочек перед загрузкой нового набора правил.</p>

<p>Для загрузки набора правил утилитой
<strong class="COMMAND">iptables-restore</strong> из файла можно
предложить несколько вариантов, но наиболее употребимый:</p>
<p><strong class="COMMAND">cat /etc/iptables-save | iptables-restore -c
</strong></p>

<p>В результате выполнения этой команды содержимое файла
<tt class="FILENAME">/etc/iptables-save</tt> будет прочитано утилитой
<strong class="COMMAND">cat</strong> и перенаправленно на стандартный ввод
утилиты <strong class="COMMAND">iptables-restore</strong>. Можно было бы
привести еще целый ряд команд, с помощью которых можно
организовать загрузку набора правил из файла, но это выходит
за рамки темы, поэтому оставлю читателю возможность самому
найти более удобный для него вариант.</p>

<p>После исполнения этой команды набор правил должен загрузиться,
и все должно работать. Если это не так, то скорее всего Вы
допустили ошибку при наборе команды.</p>

<hr><h1><a name="HOWARULEISBUILT">Глава 6. Как строить правила</a></h1>
<p>В данной главе будет обсуждаться порядок построения
собственных правил для iptables. Каждая строка, которую Вы вставляете в ту
или иную цепочку, должна содержать отдельное правило. Мы также обсудим
основные критерии и действия (targets) и порядок создания своих собственных
действий (то есть подцепочек правил).</p>

<hr><h1 class="SECTION"><a name="BASICS">6.1. Основы</a></h1>
<p>Как уже говорилось выше, каждое правило это строка,
содержащая в себе критерии определяющие, подпадает ли пакет
под заданное правило, и действие, которое необходимо выполнить в
случае выполнения критерия. В общем виде правила записываются примерно так:
</p>
<p><strong class="COMMAND">iptables</strong> [-t <tt class="REPLACEABLE">
<em>table</em></tt>] command [match] [target/jump]</p>

<p>Нигде не утверждается, что описание действия (target/jump)
должно стоять последним в строке, однако, такая нотация более удобочитаема.
Как бы то ни было, но чаще всего Вам будет
встречаться именно такой способ записи правил.</p>

<p>Если в правило не включается спецификатор [-t table],
то по умолчанию предполагается использование таблицы
<em class="EMPHASIS">filter</em>, если же предполагается
использование другой таблицы, то это требуется указать явно.
Спецификатор таблицы также можно указывать в любом месте строки правила,
однако более или менее стандартом считается
указание таблицы в начале правила.</p>

<p>Далее, непосредственно за именем таблицы, должна стоять команда.
Если спецификатора таблицы нет, то команда всегда должна стоять первой.
Команда определяет действие iptables, например: вставить правило,
добавить правило в конец цепочки или удалить правило и т. п.</p>

<p>Раздел match задает критерии проверки, по которым определяется,
подпадает ли пакет под действие этого правила или нет. Здесь мы можем указать
самые разные критерии: IP-адрес источника пакета или сети, IP-адрес места
назначения, порт, протокол, сетевой интерфейс и т. д.
Существует множество разнообразных критериев, но об этом несколько позже.</p>

<p>И наконец target указывает, какое действие должно быть
выполнено при условии выполнения критериев в правиле. Здесь можно заставить
ядро передать пакет в другую цепочку правил,
&quot;сбросить&quot; пакет и забыть про него, выдать на источник
сообщение об ошибке и т. п.</p>

<hr><h1 class="SECTION"><a name="TABLES">6.2. Таблицы</a></h1>
<p>Опция <strong class="COMMAND">-t</strong> указывает
на используемую таблицу. По умолчанию используется таблица
<em class="EMPHASIS">filter</em>. С ключом
<strong class="COMMAND">-t</strong> применяются следующие опции.</p>

<a name="TABLE.TABLES"></a>
<p><strong>Таблица 6-1. Таблицы</strong></p>
<table border="1" class="CALSTABLE">
<thead><tr><th width="17%" align="left" valign="top">Таблица</th>
<th width="83%" align="left" valign="top">Описание</th></tr></thead>
<tbody><tr><td width="17%" align="left" valign="top">nat</td>
<td width="83%" align="left" valign="top">
Таблица <em class="EMPHASIS">nat</em> используется главным
образом для преобразования сетевых адресов
(<em class="EMPHASIS">Network Address Translation</em>).
Через эту таблицу проходит только первый пакет из потока.
Преобразования адресов автоматически
применяется ко всем последующим пакетам. Это один из
факторов, исходя из которых мы не должны осуществлять
какую-либо фильтрацию в этой таблице.
Цепочка <em class="EMPHASIS">PREROUTING</em> используется для
внесения изменений в пакеты на входе в брандмауэр.
Цепочка <em class="EMPHASIS">OUTPUT</em> используется для
преобразования адресов в пакетах, созданных приложениями внутри брандмауэра,
перед принятием решения о маршрутизации. И последняя цепочка в этой таблице
<em class="EMPHASIS">POSTROUTING</em>, которая используется для
преобразования пакетов перед выдачей их в сеть.</td></tr>

<tr><td width="17%" align="left" valign="top">mangle</td>
<td width="83%" align="left" valign="top">Эта таблица используется для
внесения изменений в заголовки пакетов. Примером может служить изменение поля
<strong class="COMMAND">TTL</strong>, <strong class="COMMAND">TOS</strong>
или <strong class="COMMAND">MARK</strong>. Важно: в действительности поле
<strong class="COMMAND">MARK</strong> не изменяется, но в памяти ядра
заводится структура, которая сопровождает данный пакет все время его
прохождения через брандмауэр, так что другие правила и приложения на
данном брандмауэре (и только на данном брандмауэре) могут использовать это
поле в своих целях. Таблица имеет пять цепочек
<em class="EMPHASIS">PREROUTING</em>, <em class="EMPHASIS">POSTROUTING</em>,
<em class="EMPHASIS">INPUT</em>, <em class="EMPHASIS">OUTPUT</em> и
<em class="EMPHASIS">FORWARD</em>. <em class="EMPHASIS">PREROUTING</em>
используется для внесения изменений на входе в брандмауэр,
перед принятием решения о маршрутизации.
<em class="EMPHASIS">POSTROUTING</em> используется для внесения изменений на
выходе из брандмауэра, после принятия решения о маршрутизации.
<em class="EMPHASIS">INPUT</em> для внесения
изменений в пакеты перед тем, как они будут переданы
локальному приложению внутри брандмауэра.
<em class="EMPHASIS">OUTPUT</em> для внесения изменений в пакеты,
поступающие от приложений внутри брандмауэра.
<em class="EMPHASIS">FORWARD</em> для внесения
изменений в транзитные пакеты после первого принятия решения о маршрутизации,
но перед последним принятием решения о маршрутизации. Замечу, что таблица
<em class="EMPHASIS">mangle</em> ни в коем случае не должна использоваться
для преобразования сетевых адресов или маскарадинга
(<em class="EMPHASIS">Network Address Translation, Masquerading</em>),
поскольку для этих целей имеется таблица nat.</td></tr>

<tr><td width="17%" align="left" valign="top">filter</td>
<td width="83%" align="left" valign="top">
Таблица <em class="EMPHASIS">filter</em> используется главным
образом для фильтрации пакетов. Для примера, здесь мы можем выполнить
<strong class="COMMAND">DROP</strong>, <strong class="COMMAND">LOG</strong>,
<strong class="COMMAND">ACCEPT</strong> или
<strong class="COMMAND">REJECT</strong> без каких-либо ограничений,
которые имеются в других таблицах. Имеется три встроенных цепочки.
Первая <em class="EMPHASIS">FORWARD</em>, используемая для фильтрации
пакетов, идущих транзитом через брандмауэр.
Цепочку <em class="EMPHASIS">INPUT</em> проходят пакеты,
которые предназначены локальным приложениям (брандмауэру).
И цепочка <em class="EMPHASIS">OUTPUT</em> используется для
фильтрации исходящих пакетов, сгенерированных
приложениями на самом брандмауэре.</td></tr></tbody></table>

<p>Выше мы рассмотрели основные отличия трех имеющихся таблиц.
Каждая из них должна использоваться только в своих целях,
и Вы должны это понимать. Нецелевое использование таблиц может привести к
ослаблению защиты брандмауэра и сети, находящейся за ним.
Позднее, в главе <a href="#TRAVERSINGOFTABLES"><em>Порядок прохождения таблиц
и цепочек</em></a>, мы подробнее остановимся на этом.</p>

<hr><h1 class="SECTION"><a name="COMMANDS">6.3. Команды</a></h1>
<p>Ниже приводится список команд и правила их использования.
Посредством команд мы сообщаем <strong class="COMMAND">iptables</strong>,
что мы предполагаем сделать. Обычно предполагается одно из двух действий:
добавление нового правила в цепочку или удаление
существующего правила из той или иной таблицы. Далее приведены команды,
которые используются в <strong class="COMMAND">iptables</strong>.</p>

<a name="TABLE.COMMANDS"></a>
<p><strong>Таблица 6-2. Команды</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top">
<strong class="COMMAND">-A</strong>,
<strong class="COMMAND">--append</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT ...</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Добавляет новое правило в
конец заданной цепочки.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-D
</strong>, <strong class="COMMAND">--delete</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -D INPUT --dport 80 -j DROP</strong>,
<strong class="COMMAND">iptables -D INPUT 1</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Удаление правила из цепочки.
Команда имеет два формата записи, первый когда задается
критерий сравнения с опцией -D (см. первый пример),
второй порядковый номер правила. Если задается критерий сравнения,
то удаляется правило, которое имеет в себе этот критерий,
если задается номер правила, то будет удалено правило с заданным номером.
Счет правил в цепочках начинается с 1.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-R
</strong>, <strong class="COMMAND">--replace</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -R INPUT 1 -s 192.168.0.1 -j DROP</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Эта команда заменяет
одно правило другим. В основном она используется во время
отладки новых правил.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-I
</strong>, <strong class="COMMAND">--insert</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -I INPUT 1 --dport 80 -j ACCEPT</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Вставляет новое правило в цепочку.
Число, следующее за именем цепочки, указывает номер правила,
перед которым нужно вставить новое правило, другими словами,
число задает номер для вставляемого правила. В примере выше указывается,
что данное правило должно быть 1-м в цепочке <em class="EMPHASIS">INPUT</em>.
</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-L
</strong>, <strong class="COMMAND">--list</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -L INPUT</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Вывод списка правил в
заданной цепочке, в данном примере предполагается вывод правил из
цепочки <em class="EMPHASIS">INPUT</em>. Если имя цепочки не указывается,
то выводится список правил для всех цепочек. Формат вывода зависит от наличия
дополнительных ключей в команде, например,
<strong class="COMMAND">-n</strong>,
<strong class="COMMAND">-v</strong> и пр.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-F
</strong>, <strong class="COMMAND">--flush</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -F INPUT</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Сброс (удаление) всех правил из
заданной цепочки (таблицы). Если имя цепочки и
таблицы не указывается, то удаляются все правила во всех цепочках.
Если не указана таблица ключом <strong class="COMMAND">-t (--table)</strong>,
то очистка цепочек производится только в таблице filter.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-Z</strong>,
<strong class="COMMAND">--zero</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -Z INPUT</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Обнуление всех счетчиков в заданной цепочке. Если имя цепочки не указывается,
то подразумеваются все цепочки. При использовании ключа
<strong class="COMMAND">-v</strong> совместно с командой
<strong class="COMMAND">-L</strong>, на вывод будут поданы и
состояния счетчиков пакетов, попавших под действие каждого правила.
Допускается совместное использование команд
<strong class="COMMAND">-L</strong> и <strong class="COMMAND">-Z</strong>.
В этом случае будет выдан сначала список правил со счетчиками,
а затем произойдет обнуление счетчиков.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-N
</strong>, <strong class="COMMAND">--new-chain</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -N allowed</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Создается новая цепочка с заданным
именем в заданной таблице. В вышеприведенном примере
создается новая цепочка с именем <strong class="COMMAND">allowed</strong>.
Имя цепочки должно быть уникальным и не должно совпадать с
зарезервированными именами цепочек и действий (такими, как
<strong class="COMMAND">DROP</strong>, <strong class="COMMAND">REJECT
</strong> и т. п.).</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-X
</strong>, <strong class="COMMAND">--delete-chain</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -X allowed</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Удаление заданной цепочки
из заданной таблицы. Удаляемая цепочка не должна иметь правил и
не должно быть ссылок из других цепочек на удаляемую цепочку.
Если имя цепочки не указано, то будут удалены все
цепочки заданной таблицы, кроме встроенных.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-P
</strong>, <strong class="COMMAND">--policy</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -P INPUT DROP</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Задает политику по умолчанию
для заданной цепочки. Политика по умолчанию определяет действие,
применяемое к пакетам, не попавшим под действие ни одного из правил в цепочке.
В качестве политики по умолчанию допускается использовать
<strong class="COMMAND">DROP</strong> и
<strong class="COMMAND">ACCEPT</strong>.</td></tr>
<tr><td width="14%" align="left" valign="top">Команда</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-E
</strong>, <strong class="COMMAND">--rename-chain</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -E allowed disallowed</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Команда <strong class="COMMAND">-E</strong> выполняет переименование
пользовательской цепочки. В примере цепочка <tt class="VARNAME">allowed</tt>
будет переименована в цепочку <tt class="VARNAME">disallowed</tt>.
Эти переименования не изменяют порядок работы,
а носят только косметический характер.</td></tr></tbody></table>

<p>Команда должна быть указана всегда. Список доступных команд можно
просмотреть с помощью команды <strong class="COMMAND">iptables -h</strong>
или, что то же самое, <strong class="COMMAND">iptables --help</strong>.
Некоторые команды могут использоваться совместно с дополнительными ключами.
Ниже приводится список дополнительных ключей и описывается
результат их действия. При этом заметьте, что здесь не
приводится дополнительных ключей, которые используются при
построении критериев (matches) или действий (targets). Эти опции мы
будем обсуждать далее.</p>

<a name="TABLE.OPTIONS"></a>
<p><strong>Таблица 6-3. Дополнительные ключи</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-v
</strong>, <strong class="COMMAND">--verbose</strong></td></tr>

<tr><td width="14%" align="left" valign="top">
Команды, с которыми используется</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--list
</strong>, <strong class="COMMAND">--append</strong>,
<strong class="COMMAND">--insert</strong>,
<strong class="COMMAND">--delete</strong>,
<strong class="COMMAND">--replace</strong></td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Используется для повышения
информативности вывода и, как правило, используется совместно с командой
<strong class="COMMAND">--list</strong>. В случае использования с командой
<strong class="COMMAND">--list</strong>, в вывод этой команды включаются
также имя интерфейса, счетчики пакетов и байт для каждого правила.
Формат вывода счетчиков предполагает вывод кроме цифр числа еще и
символьные множители K (x1000), M (x1000000) и G (x1000000000).
Для того, чтобы заставить команду <strong class="COMMAND">--list</strong>
выводить полное число (без употребления множителей) требуется
применять ключ <strong class="COMMAND">-x</strong>, который описан ниже.
Если ключ <strong class="COMMAND">-v</strong>,
<strong class="COMMAND">--verbose</strong> используется с командами
<strong class="COMMAND">--append</strong>,
<strong class="COMMAND">--insert</strong>,
<strong class="COMMAND">--delete</strong> или
<strong class="COMMAND">--replace</strong>, то будет выведен
подробный отчет о произведенной операции.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-x</strong>,
<strong class="COMMAND">--exact</strong></td></tr>
<tr><td width="14%" align="left" valign="top">
Команды, с которыми используется</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--list
</strong></td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Для всех чисел в выходных данных
выводятся их точные значения без округления и без использования множителей
K, M, G. Этот ключ используется только с командой
<strong class="COMMAND">--list</strong> и неприменим с другими командами.
</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-n</strong>,
<strong class="COMMAND">--numeric</strong></td></tr>

<tr><td width="14%" align="left" valign="top">
Команды, с которыми используется</td>
<td width="86%" align="left" valign="top">
<strong class="COMMAND">--list</strong></td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Заставляет iptables выводить
IP-адреса и номера портов в числовом виде предотвращая попытки
преобразовать их в символические имена. Данный ключ используется только с
командой <strong class="COMMAND">--list</strong>.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--line-numbers</strong></td></tr>

<tr><td width="14%" align="left" valign="top">
Команды, с которыми используется</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--list
</strong></td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--line-numbers</strong> включает режим вывода номеров строк при отображении
списка правил командой <strong class="COMMAND">--list</strong>.
Номер строки соответствует позиции правила в цепочке. Этот ключ используется
только с командой <strong class="COMMAND">--list</strong>.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-c
</strong>, <strong class="COMMAND">--set-counters</strong></td></tr>

<tr><td width="14%" align="left" valign="top">
Команды, с которыми используется</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--insert
</strong>, <strong class="COMMAND">--append</strong>,
<strong class="COMMAND">--replace</strong></td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Этот ключ используется для
установки начального значения счетчиков пакетов и байт в заданное значение
при создании нового правила. Например, ключ --set-counters 20 4000 установит
счетчик пакетов = 20, а счетчик байт = 4000.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--modprobe
</strong></td></tr>

<tr><td width="14%" align="left" valign="top">
Команды, с которыми используется</td>
<td width="86%" align="left" valign="top">Все</td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--modprobe</strong> определяет команду загрузки модуля ядра.
Данный ключ может использоваться в случае, когда модули ядра находится вне
пути поиска (search path). Этот ключ может использоваться с любой командой.
</td></tr></tbody></table>

<hr><h1 class="SECTION"><a name="MATCHES">6.4. Критерии</a></h1>
<p>Здесь мы подробнее остановимся на критериях выделения пакетов.
Я разбил все критерии на пять групп. Первая <em class="EMPHASIS">общие
критерии</em>, которые могут использоваться в любых правилах.
Вторая <em class="EMPHASIS">TCP-критерии</em>, которые применяются только к
<em class="EMPHASIS">TCP</em>-пакетам.
Третья <em class="EMPHASIS">UDP-критерии</em>, которые применяются только к
<em class="EMPHASIS">UDP</em>-пакетам.
Четвертая <em class="EMPHASIS">ICMP-критерии</em> для работы с
<em class="EMPHASIS">ICMP</em>-пакетами. И наконец пятая задает
специальные критерии такие, как state, owner, limit и пр.</p>

<hr><h2 class="SECTION"><a name="GENERICMATCHES">6.4.1. Общие критерии</a>
</h2>
<p>Здесь мы рассмотрим <em class="EMPHASIS">общие критерии</em>.
Общие критерии допустимо употреблять в любых правилах, они не зависят от
типа протокола и не требуют подгрузки модулей расширения.
К этой группе я умышленно отнес критерий <strong class="COMMAND">--protocol
</strong> несмотря на то, что он используется в некоторых специфичных
от протокола расширениях. Например, мы решили использовать
<em class="EMPHASIS">TCP-критерий</em>, тогда нам необходимо
будет использовать и критерий <strong class="COMMAND">--protocol</strong>,
которому в качестве дополнительного ключа передается название протокола TCP.
Однако, критерий <strong class="COMMAND">--protocol</strong> сам по
себе является критерием, который используется для указания типа протокола.</p>

<a name="TABLE.GENERICMATCHES"></a>
<p><strong>Таблица 6-4. Общие критерии</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-p</strong>,
<strong class="COMMAND">--protocol</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Этот критерий используется для
указания типа протокола. Примерами протоколов могут быть
<em class="EMPHASIS">TCP</em>, <em class="EMPHASIS">UDP</em> и
<em class="EMPHASIS">ICMP</em>. Список протоколов можно посмотреть в файле
<a href="other/protocols.txt" target="_top">
<tt class="FILENAME">/etc/protocols</tt></a>. Прежде всего, в качестве имени
протокола в данный критерий можно передавать один из
трех вышеупомянутых протоколов, а также ключевое слово ALL.
В качестве протокола допускается передавать число, номер протокола,
так, например, протоколу ICMP соответствует число 1, TCP 6 и UDP 17.
Соответствия между номерами протоколов и их именами
Вы можете посмотреть в файле <tt class="FILENAME">/etc/protocols</tt>,
который уже упоминался. Критерию может передаваться и список протоколов,
разделенных запятыми, например: <strong class="COMMAND">udp,tcp</strong>.
Если данному критерию передается числовое значение 0, то это эквивалентно
использованию спецификатора ALL, который подразумевается по умолчанию,
когда критерий <strong class="COMMAND">--protocol</strong> не используется.
Для логической инверсии критерия, перед именем протокола (списком протоколов)
используется символ <strong class="COMMAND">!</strong>, например,
<strong class="COMMAND">--protocol ! tcp</strong> подразумевает пакеты
протоколов <em class="EMPHASIS">UDP</em> и <em class="EMPHASIS">ICMP</em>.
</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-s</strong>,
<strong class="COMMAND">--src</strong>, <strong class="COMMAND">--source
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -s 192.168.1.1</strong></td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">IP-адрес(а) источника пакета.
Адрес источника может указываться так, как показано в примере,
тогда подразумевается единственный IP-адрес. А можно указать адрес в виде
address/mask, например, как <em class="EMPHASIS">192.168.0.0/255.255.255.0
</em> или более современным способом <em class="EMPHASIS">192.168.0.0/24
</em>, то есть фактически определяя диапазон адресов. Как и ранее, символ !,
установленный перед адресом, означает логическое отрицание, то есть
<strong class="COMMAND">--source ! 192.168.0.0/24</strong>
означает любой адрес, кроме адресов <em class="EMPHASIS">192.168.0.x</em>.
</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-d
</strong>, <strong class="COMMAND">--dst</strong>,
<strong class="COMMAND">--destination</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -d 192.168.1.1</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">IP-адрес(а) получателя.
Имеет синтаксис, схожий с критерием <strong class="COMMAND">--source</strong>,
за исключением того, что подразумевает адрес места назначения.
Точно так же может определять как единственный IP-адрес,
так и диапазон адресов. Символ ! используется для
логической инверсии критерия.</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-i
</strong>, <strong class="COMMAND">--in-interface</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -i eth0</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Интерфейс, с которого был получен пакет. Использование этого критерия
допускается только в цепочках <em class="EMPHASIS">INPUT</em>,
<em class="EMPHASIS">FORWARD</em> и <em class="EMPHASIS">PREROUTING</em>,
в любых других случаях он будет вызывать сообщение об ошибке.
При отсутствии этого критерия предполагается любой интерфейс,
что равносильно использованию критерия <strong class="COMMAND">-i +</strong>.
Как и прежде, символ ! инвертирует результат совпадения. Если имя интерфейса
завершается символом <strong class="COMMAND">+</strong>, то критерий задает
все интерфейсы, начинающиеся с заданной строки, например,
<strong class="COMMAND">-i PPP+</strong> обозначает любой PPP-интерфейс,
а запись <strong class="COMMAND">-i ! eth+</strong> любой интерфейс,
кроме любого eth.</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-o</strong>,
<strong class="COMMAND">--out-interface</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A FORWARD -o eth0</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Задает имя выходного интерфейса.
Этот критерий допускается использовать только в цепочках
<em class="EMPHASIS">OUTPUT</em>, <em class="EMPHASIS">FORWARD</em> и
<em class="EMPHASIS">POSTROUTING</em>, в противном случае будет
генерироваться сообщение об ошибке. При отсутствии этого критерия
предполагается любой интерфейс, что равносильно использованию критерия
<strong class="COMMAND">-o +</strong>. Как и прежде, символ ! инвертирует
результат совпадения. Если имя интерфейса завершается символом
<strong class="COMMAND">+</strong>, то критерий задает все интерфейсы,
начинающиеся с заданной строки, например,
<strong class="COMMAND">-o eth+</strong> обозначает любой
eth-интерфейс, а запись <strong class="COMMAND">-o ! eth+</strong> любой
интерфейс, кроме любого eth.</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">-f
</strong>, <strong class="COMMAND">--fragment</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -f</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Правило распространяется на все
фрагменты фрагментированного пакета, кроме первого, сделано это потому,
что нет возможности определить исходящий/входящий порт для фрагмента пакета,
а для ICMP-пакетов определить их тип. С помощью фрагментированных пакетов
могут производиться атаки на Ваш брандмауэр, так как фрагменты пакетов могут
не отлавливаться другими правилами. Как и раньше, допускается использование
символа ! для инверсии результата сравнения. Только в данном случае символ
! должен предшествовать критерию <strong class="COMMAND">-f</strong>,
например, <strong class="COMMAND">! -f</strong>. Инверсия критерия трактуется
как &quot;все первые фрагменты фрагментированных пакетов и/или
нефрагментированные пакеты, но не вторые и последующие
фрагменты фрагментированных пакетов&quot;.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="IMPLICITMATCHES">6.4.2. Неявные критерии</a>
</h2>
<p>В этом разделе мы рассмотрим <em class="EMPHASIS">неявные критерии</em>,
точнее, те критерии, которые подгружаются неявно и становятся доступны,
например при указании критерия <strong class="COMMAND">--protocol tcp
</strong>. На сегодняшний день существует три автоматически подгружаемых
расширения, это <em class="EMPHASIS">TCP-критерии</em>,
<em class="EMPHASIS">UDP-критерии</em> и
<em class="EMPHASIS">ICMP-критерии</em>. При построении своих правил я
столкнулся с необходимостью явного указания ключа <strong class="COMMAND">
-m tcp</strong>, о неявности здесь говорить не приходится,
поэтому будьте внимательнее при построении своих правил, если что-то не идет,
пробуйте явно указывать необходимое расширение. Загрузка этих расширений
может производиться и явным образом с помощью
ключа -m, -match, например, -m tcp.</p>

<hr><h3 class="SECTION"><a name="TCPMATCHES">6.4.2.1. TCP-критерии</a></h3>
<p>Этот набор критериев зависит от типа протокола и
работает только с <em class="EMPHASIS">TCP</em>-пакетами.
Чтобы использовать их, потребуется в правилах указывать тип протокола
<strong class="COMMAND">--protocol tcp</strong>. Важно: критерий
<strong class="COMMAND">--protocol tcp</strong> обязательно
должен стоять перед специфичным критерием. Эти расширения загружаются
автоматически как для <em class="EMPHASIS">tcp</em>-протокола, так и для
<em class="EMPHASIS">udp</em> и <em class="EMPHASIS">icmp</em>-протоколов.
</p>

<a name="TABLE.TCPMATCHES"></a>
<p><strong>Таблица 6-5. TCP-критерии</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--sport
</strong>, <strong class="COMMAND">--source-port</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp --sport 22</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Исходный порт, с которого был отправлен пакет. В качестве параметра может
указываться номер порта или название сетевой службы.
Соответствие имен сервисов и номеров портов Вы сможете найти в файле
/etc/services. При указании номеров портов правила
отрабатывают несколько быстрее. Однако, это менее удобно при
разборе листингов скриптов. Если же Вы собираетесь создавать значительные
по объему наборы правил, скажем, порядка нескольких сотен и более,
то тут предпочтительнее использовать номера портов. Номера портов могут
задаваться в виде интервала из минимального и максимального номеров,
например, <strong class="COMMAND">--source-port 22:80</strong>.
Если опускается минимальный порт, то есть когда критерий записывается как
<strong class="COMMAND">--source-port :80</strong>, то в качестве начала
диапазона принимается число 0. Если опускается максимальный порт, то есть
когда критерий записывается как <strong class="COMMAND">--source-port 22:
</strong>, то в качестве конца диапазона принимается число 65535.
Допускается такая запись <strong  class="COMMAND">--source-port 80:22
</strong>, в этом случае <strong class="COMMAND">iptables</strong>
поменяет числа 22 и 80 местами, то есть подобного рода запись будет
преобразована в <strong class="COMMAND">--source-port 22:80</strong>.
Как и раньше, символ <strong class="COMMAND">!</strong>
используется для инверсии. Так критерий <strong class="COMMAND">
--source-port ! 22</strong> подразумевает любой порт, кроме 22.
Инверсия может применяться и к диапазону портов, например,
<strong class="COMMAND">--source-port ! 22:80</strong>.
За дополнительной информацией обращайтесь к описанию критерия multiport.
</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--dport
</strong>, <strong class="COMMAND">--destination-port</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp --dport 22</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Порт или диапазон портов, на
который адресован пакет. Аргументы задаются в том же формате, что и для
<strong class="COMMAND">--source-port</strong>.</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--tcp-flags
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -p tcp --tcp-flags SYN,FIN,ACK SYN</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Определяет маску и флаги tcp-пакета.
Пакет считается удовлетворяющим критерию, если из перечисленных флагов в
первом списке в единичное состояние установлены флаги из второго списка.
Так для вышеуказанного примера под критерий подпадают пакеты,
у которых флаг <em class="EMPHASIS">SYN</em> установлен, а флаги
<em class="EMPHASIS">FIN</em> и <em class="EMPHASIS">ACK</em> сброшены.
В качестве аргументов критерия могут выступать флаги
<em class="EMPHASIS">SYN, ACK, FIN, RST, URG, PSH</em>,
а также зарезервированные идентификаторы <em class="EMPHASIS">ALL</em> и
<em class="EMPHASIS">NONE</em>. <em class="EMPHASIS">ALL</em> значит
<em class="EMPHASIS">ВСЕ</em> флаги и <em class="EMPHASIS">NONE</em>
НИ ОДИН флаг. Так, критерий <strong class="COMMAND">--tcp-flags ALL NONE
</strong> означает <em class="EMPHASIS">&quot;все флаги в пакете должны
быть сброшены&quot;</em>. Как и ранее, символ
<strong class="COMMAND">!</strong> означает инверсию критерия.
Важно: имена флагов в каждом списке должны разделяться запятыми,
пробелы служат для разделения списков.</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--syn
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -p tcp --syn</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Критерий <strong class="COMMAND">--syn</strong> является по сути реликтом,
перекочевавшим из ipchains. Критерию соответствуют пакеты с установленным
флагом <em class="EMPHASIS">SYN</em> и сброшенными флагами
<em class="EMPHASIS">ACK</em> и <em class="EMPHASIS">FIN</em>.
Этот критерий аналогичен критерию <strong class="COMMAND">--tcp-flags
SYN,ACK,FIN SYN</strong>. Такие пакеты используются для открытия соединения
<em class="EMPHASIS">TCP</em>. Заблокировав такие пакеты,
Вы надежно заблокируете все входящие запросы на соединение,
однако этот критерий неспособен заблокировать исходящие
запросы на соединение. Как и ранее, допускается
инвертирование критерия символом <strong class="COMMAND">!</strong>.
Так критерий <strong class="COMMAND">! --syn</strong> означает
<em class="EMPHASIS">&quot;все пакеты, не являющиеся
запросом на соединение&quot;</em>, то есть все
пакеты с установленными флагами <em class="EMPHASIS">FIN</em> или
<em class="EMPHASIS">ACK</em>.</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--tcp-option</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -p tcp --tcp-option 16</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Удовлетворяющим условию данного
критерия будет будет считаться пакет, <em class="EMPHASIS">TCP</em>-параметр
которого равен заданному числу. <em class="EMPHASIS">TCP Option</em> это
часть заголовка пакета. Она состоит из 3 различных полей. Первое 8-ми битовое
поле содержит информацию об опциях, используемых в данном соединении.
Второе 8-ми битовое поле содержит длину поля опций. Если следовать стандартам
до конца, то следовало бы реализовать обработку всех
возможных вариантов, однако, вместо этого мы
можем проверить первое поле и в случае, если там указана
не поддерживаемая нашим брандмауэром опция, то просто перешагнуть через
третье поле (длина которого содержится во втором поле).
Пакет, который не будет иметь полного
<em class="EMPHASIS">TCP</em>-заголовка, будет сброшен автоматически при
попытке изучения его <em class="EMPHASIS">TCP</em>-параметра.
Как и ранее, допускается использование флага инверсии
условия <strong class="COMMAND">!</strong>.
Дополнительную информацию по <em class="EMPHASIS">TCP Options</em> Вы сможете
найти на <a href="../../../www.ietf.org/default.htm" target="_top">
Internet Engineering Task Force</a></td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="UDPMATCHES">6.4.2.2. UDP-критерии</a></h3>
<p>В данном разделе будут рассматриваться критерии,
специфичные только для протокола <em class="EMPHASIS">UDP</em>.
Эти расширения подгружаются автоматически при указании типа протокола
<strong class="COMMAND">--protocol udp</strong>. Важно отметить,
что пакеты <em class="EMPHASIS">UDP</em> не ориентированы на
установленное соединение и поэтому не имеют различных флагов,
которые дают возможность судить о предназначении датаграмм.
Получение <em class="EMPHASIS">UDP</em>-пакетов не требует какого-либо
подтверждения со стороны получателя. Если они потеряны,
то они просто потеряны (не вызывая передачу
<em class="EMPHASIS">ICMP</em>-сообщения об ошибке). Это предполагает наличие
значительно меньшего числа дополнительных критериев, в отличие от
<em class="EMPHASIS">TCP</em>-пакетов. Важно: хороший брандмауэр должен
работать с пакетами любого типа, <em class="EMPHASIS">UDP</em> или
<em class="EMPHASIS">ICMP</em>, которые считаются не
ориентированными на соединение, также хорошо, как и с
<em class="EMPHASIS">TCP</em>-пакетами. Об этом мы поговорим
позднее, в следующих главах.</p>

<a name="TABLE.UDPMATCHES"></a>
<p><strong>Таблица 6-6. UDP-критерии</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--sport
</strong>, <strong class="COMMAND">--source-port</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p udp --sport 53</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Исходный порт, с которого был отправлен пакет. В качестве параметра может
указываться номер порта или название сетевой службы.
Соответствие имен сервисов и номеров портов Вы сможете найти в файле
<a href="other/services.txt" target="_top">
other/services.txt</a>. При указании номеров портов правила отрабатывают
несколько быстрее. однако это менее удобно при разборе листингов скриптов.
Если же Вы собираетесь создавать значительные по объему наборы правил,
скажем, порядка нескольких сотен и более, то тут предпочтительнее
использовать номера портов. Номера портов могут задаваться в
виде интервала из минимального и максимального номеров,
например, <strong class="COMMAND">-source-port 22:80</strong>.
Если опускается минимальный порт, то есть когда
критерий записывается как <strong class="COMMAND">--source-port :80</strong>,
то в качестве начала диапазона принимается число 0.
Если опускается максимальный порт, то есть когда
критерий записывается как <strong class="COMMAND">--source-port 22:</strong>,
то в качестве конца диапазона принимается число 65535.
Допускается такая запись <strong class="COMMAND">--source-port 80:22</strong>,
в этом случае iptables поменяет числа 22 и 80 местами, то есть подобного рода
запись будет преобразована в <strong class="COMMAND">--source-port 22:80
</strong>. Как и раньше, символ <strong class="COMMAND">!</strong>
используется для инверсии. Так критерий <strong class="COMMAND">
--source-port ! 22</strong> подразумевает любой порт, кроме 22.
Инверсия может применяться и к диапазону портов, например,
<strong class="COMMAND">--source-port ! 22:80</strong>.</td></tr>

<tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--dport
</strong>, <strong class="COMMAND">--destination-port</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p udp --dport 53</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Порт, на который адресован пакет.
Формат аргументов полностью аналогичен принятому в критерии
<strong class="COMMAND">--source-port</strong>.</td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="ICMPMATCHES">6.4.2.3. ICMP-критерии</a></h3>
<p>Этот протокол используется, как правило, для передачи
сообщений об ошибках и для управления соединением. Он не является подчиненным
<em class="EMPHASIS">IP</em>-протоколу, но тесно с ним взаимодействует,
поскольку помогает обрабатывать ошибочные ситуации.
Заголовки <em class="EMPHASIS">ICMP</em>-пакетов
очень похожи на <em class="EMPHASIS">IP</em>-заголовки, но имеют и отличия.
Главное свойство этого протокола заключается в типе
заголовка, который содержит информацию о том, что это за пакет.
Например, когда мы пытаемся соединиться с недоступным хостом,
то мы получим в ответ сообщение
<em class="EMPHASIS">ICMP host unreachable</em>. Полный список типов
<em class="EMPHASIS">ICMP</em>-сообщений Вы можете
посмотреть в приложении <a href="#ICMPTYPES"><em>Типы ICMP</em></a>.
Существует только один специфичный критерий для
<em class="EMPHASIS">ICMP</em>-пакетов. Это расширение загружается
автоматически, когда мы указываем критерий
<strong class="COMMAND">--protocol icmp</strong>. Заметьте, что для проверки
<em class="EMPHASIS">ICMP</em>-пакетов могут употребляться и
общие критерии, поскольку известны и адрес источника и
адрес назначения и пр.</p>

<a name="TABLE.ICMPMATCHES"></a>
<p><strong>Таблица 6-7. ICMP-критерии</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Критерий</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--icmp-type</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p icmp --icmp-type 8</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Тип сообщения <em class="EMPHASIS">ICMP</em> определяется
номером или именем. Числовые значения определяются в RFC 792.
Чтобы получить список имен <em class="EMPHASIS">ICMP</em>-значений выполните
команду <strong class="COMMAND">iptables --protocol icmp --help</strong>,
или посмотрите приложение <a href="typeicmp.htm#ICMPTYPES"><em>Типы ICMP</em></a>.
Как и ранее, символ <strong class="COMMAND">!</strong> инвертирует критерий,
например, <strong class="COMMAND">--icmp-type ! 8</strong>.
</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="EXPLICITMATCHES">6.4.3. Явные критерии</a>
</h2>
<p>Перед использованием этих расширений, они должны быть загружены явно,
с помощью ключа <strong class="COMMAND">-m</strong> или
<strong class="COMMAND">--match</strong>. Так, например, если мы
собираемся использовать критерии state, то мы должны явно
указать это в строке правила: <strong class="COMMAND">-m state</strong>
левее используемого критерия. Некоторые из этих критериев пока еще находятся
в стадии разработки, а посему могут работать не всегда, однако,
в большинстве случаев они работают вполне устойчиво. Все отличие между явными
и неявными критериями заключается только в том,
что первые нужно подгружать явно, а вторые подгружаются автоматически.</p>

<hr><h3 class="SECTION"><a name="LIMITMATCH">6.4.3.1. Критерий Limit</a></h3>
<p>Должен подгружаться явно ключом <strong class="COMMAND">-m limit</strong>. Прекрасно подходит
для правил, производящих запись в системный журнал (logging) и т. п.
Добавляя этот критерий, мы тем самым
устанавливаем предельное число пакетов в единицу времени,
которое способно пропустить правило. Можно использовать символ
<strong class="COMMAND">!</strong> для инверсии, например,
<strong class="COMMAND">-m limit ! --limit 5/s</strong>.
В этом случае подразумевается, что пакеты будут проходить
правило только после превышения ограничения.</p>

<p>Более наглядно этот критерий можно представить себе
как некоторую емкость с выпускным отверстием, через
которое проходит определенное число пакетов за единицу
времени (то есть скорость &quot;вытекания&quot;).
Скорость &quot;вытекания&quot; как раз и определяет величина
<strong class="COMMAND">--limit</strong>.
Величина <strong class="COMMAND">--limit-burst</strong> задает общий
&quot;объем емкости&quot;. А теперь представим себе правило
<strong class="COMMAND">--limit 3/minute --limit-burst 5</strong>,
тогда после поступления 5 пакетов (за очень короткий промежуток времени),
емкость &quot;наполнится&quot;, и каждый последующий пакет будет
вызывать &quot;переполнение&quot; емкости, то есть
&quot;срабатывание&quot; критерия. Через 20 секунд &quot;уровень&quot; в
емкости будет понижен (в соответствии с величиной --limit), таким образом она
готова будет принять еще один пакет, не вызывая
&quot;переполнения&quot; емкости, то есть срабатывания критерия.</p>

<p>Рассмотрим еще подробнее.</p>
<ol type="1"><li><p>Предположим наличие правила, содержащего критерий
-m limit --limit 5/second --limit-burst 10. Ключ limit-burst установил
объем &quot;емкости&quot; равный 10. Каждый пакет, который подпадает под
указанное правило, направляется в эту емкость.</p></li>

<li><p>Допустим, в течение 1/1000 секунды мы получили 10 пакетов,
тогда с получением каждого пакета &quot;уровень&quot; в
&quot;емкости&quot; будет возрастать: 1-2-3-4-5-6-7-8-9-10.</p></li>

<li><p>Емкость наполнилась. Теперь пакеты, подпадающие под наше
ограничительное правило, больше не смогут попасть в эту &quot;емкость&quot;
(там просто нет места), поэтому они (пакеты) пойдут дальше по набору правил,
пока не будут явно восприняты одним из них,
либо подвергнутся политике по умолчанию.</p></li>

<li><p>Каждые 1/5 секунды &quot;уровень&quot; в
воображаемой емкости снижается на 1, и так до тех пор,
пока &quot;емкость&quot; не будет опустошена.
Через секунду, после приема 10 пакетов
&quot;емкость&quot; готова будет принять еще 5 пакетов.</p></li>
<li><p>Само собой разумеется, что &quot;уровень&quot; в
&quot;емкости&quot; возрастает на 1 с каждым вновь пришедшим пакетом.
</p></li></ol>

<a name="TABLE.LIMITMATCH"></a>
<p><strong>Таблица 6-8. Ключи критерия limit</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--limit
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -m limit --limit 3/hour</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>

<td width="86%" align="left" valign="top">Устанавливается средняя скорость
&quot;освобождения емкости&quot; за единицу времени.
В качестве аргумента указывается число пакетов и время.
Допустимыми считаются следующие единицы измерения времени:
<strong class="COMMAND">/second</strong>
<strong class="COMMAND">/minute</strong>
<strong class="COMMAND">/hour</strong> <strong class="COMMAND">/day</strong>.
По умолчанию принято значение 3 пакета в час или
<strong class="COMMAND">3/hour</strong>. Использование флага инверсии
условия <strong class="COMMAND">!</strong> в данном критерии недопустимо.
</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--limit-burst</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -m limit --limit-burst 5</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Устанавливает максимальное значение
числа <em class="EMPHASIS">burst limit</em> для критерия
<strong class="COMMAND">limit</strong>. Это число увеличивается на единицу,
если получен пакет, подпадающий под действие данного правила,
и при этом средняя скорость (задаваемая ключом <strong class="COMMAND">
--limit</strong>) поступления пакетов уже достигнута. Так происходит до тех
пор, пока число <em class="EMPHASIS">burst limit</em> не достигнет
максимального значения, устанавливаемого ключом
<strong class="COMMAND">--limit-burst</strong>. После этого правило
начинает пропускать пакеты со скоростью, задаваемой ключом
<strong class="COMMAND">--limit</strong>.
Значение по умолчанию принимается равным 5. Для демонстрации принципов
работы данного критерия, я написал скрипт
<a href="glava08.htm#LIMIT-MATCHTXT"><em>Limit-match.txt</em></a>.
С помощью этого скрипта Вы увидите, как работает критерий
<strong class="COMMAND">limit</strong>, просто посылая ping-пакеты
с различными временными интервалами.</td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="MACMATCH">6.4.3.2. Критерий MAC</a></h3>
<p><em class="EMPHASIS">MAC</em> (<em class="EMPHASIS">Ethernet Media Access
Control</em>) критерий используется для проверки исходного MAC-адреса пакета.
Расширение <strong class="COMMAND">-m mac</strong> на сегодняшний день
предоставляет единственный критерий, но возможно в будущем он будет
расширен и станет более полезен.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Модуль расширения должен подгружаться явно
ключом <strong class="COMMAND">-m mac</strong>. Упоминаю я об этом потому,
что многие, забыв указать этот ключ, удивляются, почему не работает критерий.
</p></td></tr></table>

<a name="TABLE.MACMATCH"></a>
<p><strong>Таблица 6-9. Ключи критерия MAC</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--mac-source</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -m mac --mac-source 00:00:00:00:00:01</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top"><em class="EMPHASIS">MAC</em>-адрес
сетевого узла, передавшего пакет. <em class="EMPHASIS">MAC</em>-адрес должен
указываться в форме XX:XX:XX:XX:XX:XX. Как и ранее, символ
<strong class="COMMAND">!</strong> используется для инверсии критерия,
например, <strong class="COMMAND">--mac-source ! 00:00:00:00:00:01</strong>,
что означает &quot;пакет с любого узла, кроме узла, который
имеет MAC-адрес 00:00:00:00:00:01&quot;. Этот критерий имеет смысл только в
цепочках <em class="EMPHASIS">PREROUTING</em>,
<em class="EMPHASIS">FORWARD</em>, <em class="EMPHASIS">INPUT</em>,
но нигде более.</td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="MARKMATCH">6.4.3.3. Критерий Mark</a></h3>
<p>Критерий <strong class="COMMAND">mark</strong> предоставляет возможность
&quot;пометить&quot; пакеты специальным образом. <strong class="COMMAND">Mark
</strong> специальное поле, которое существует только в области памяти ядра и
связано с конкретным пакетом. Может использоваться в самых разнообразных
целях, например, ограничение трафика и фильтрация. На сегодняшний день
существует единственная возможность установки метки на пакет в Linux:
это использование действия <strong class="COMMAND">MARK</strong>.
Поле <strong class="COMMAND">mark</strong> представляет собой беззнаковое
целое число в диапазоне от 0 до 4294967296 для 32-битных систем.</p>

<a name="TABLE.MARKMATCH"></a>
<p><strong>Таблица 6-10. Ключи критерия Mark</strong></p>
<table border="1" class="CALSTABLE"><tbody>
<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--mark
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t mangle -A INPUT -m mark --mark 1</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Критерий производит проверку пакетов, которые были предварительно
&quot;помечены&quot;. Метки устанавливаются действием
<strong class="COMMAND">MARK</strong>, которое мы будем рассматривать ниже.
Все пакеты, проходящие через netfilter, имеют специальное поле
<strong class="COMMAND">mark</strong>. Запомните, что нет никакой возможности
передать состояние этого поля вместе с пакетом в сеть.
Поле <strong class="COMMAND">mark</strong> является целым беззнаковым,
таким образом можно создать не более 4294967296 различных меток.
Допускается использовать маску с метками. В данном случае критерий будет
выглядеть подобным образом: <strong class="COMMAND">--mark 1/1</strong>.
Если указывается маска, то выполняется логическое AND метки и маски.
</td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="MULTIPORTMATCH">6.4.3.4. Критерий Multiport
</a></h3>
<p>Расширение <strong class="COMMAND">multiport</strong> позволяет указывать
в тексте правила несколько портов и диапазонов портов.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Вы не сможете использовать стандартную
проверку портов и расширение <strong class="COMMAND">-m multiport</strong>
(например, <strong class="COMMAND">--sport 1024:63353 -m multiport
--dport 21,23,80</strong>) одновременно. Подобные правила будут
просто отвергаться iptables.</p></td></tr></table>

<a name="TABLE.MULTIPORTMATCH"></a>
<p><strong>Таблица 6-11. Ключи критерия Multiport</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--source-port</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp -m multiport --source-port 22,53,80,110</strong>
</td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Служит для указания
списка исходящих портов. С помощью данного критерия
можно указать до 15 различных портов. Названия портов в списке должны
отделяться друг от друга запятыми, пробелы в списке не допустимы.
Данное расширение может использоваться только совместно с критериями
<strong class="COMMAND">-p tcp</strong> или <strong class="COMMAND">-p udp
</strong>. Главным образом используется как расширенная версия обычного
критерия <strong class="COMMAND">--source-port</strong>.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--destination-port</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp -m multiport --destination-port 22,53,80,110
</strong></td></tr>

<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Служит для указания списка входных портов. Формат задания аргументов
полностью аналогичен <strong class="COMMAND">-m multiport --source-port
</strong>.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--port
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp -m multiport --port 22,53,80,110</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Данный критерий проверяет
как исходящий, так и входящий порт пакета. Формат аргументов аналогичен
критерию <strong class="COMMAND">--source-port</strong> и
<strong class="COMMAND">--destination-port</strong>.
Обратите внимание на то, что данный критерий
проверяет порты обеих направлений, то есть, если Вы пишете
<strong class="COMMAND">-m multiport --port 80</strong>,
то под данный критерий подпадают пакеты, идущие с порта 80 на порт 80.</td>
</tr></tbody></table>

<hr><h3 class="SECTION"><a name="OWNERMATCH">6.4.3.5. Критерий Owner</a></h3>
<p>Расширение <strong class="COMMAND">owner</strong> предназначено для
проверки &quot;владельца&quot; пакета. Изначально данное
расширение было написано как пример демонстрации возможностей iptables.
Допускается использовать этот критерий только в цепочке
<em class="EMPHASIS">OUTPUT</em>. Такое ограничение наложено потому,
что на сегодняшний день нет реального механизма
передачи информации о &quot;владельце&quot; по сети.
Справедливости ради следует отметить, что для некоторых
пакетов невозможно определить &quot;владельца&quot; в этой цепочке.
К такого рода пакетам относятся различные
<em class="EMPHASIS">ICMP responses</em>. Поэтому не следует
применять этот критерий к <em class="EMPHASIS">ICMP responses</em> пакетам.
</p>

<a name="TABLE.OWNERMATCH"></a>
<p><strong>Таблица 6-12. Ключи критерия Owner</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--uid-owner
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A OUTPUT -m owner --uid-owner 500</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Производится проверка &quot;владельца&quot; по <tt class="COMPUTEROUTPUT">
User ID</tt> (UID). Подобного рода проверка может использоваться,
к примеру, для блокировки выхода в Интернет отдельных пользователей.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--gid-owner
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A OUTPUT -m owner --gid-owner 0</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Производится проверка &quot;владельца&quot; пакета по
<tt class="COMPUTEROUTPUT">Group ID</tt> (GID).</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--pid-owner
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A OUTPUT -m owner --pid-owner 78</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Производится проверка &quot;владельца&quot; пакета по
<em class="EMPHASIS">Process ID</em> (PID). Этот критерий достаточно сложен в
использовании, например, если мы хотим позволить передачу пакетов на
<em class="EMPHASIS">HTTP</em>-порт только от заданного демона,
то нам потребуется написать небольшой скрипт, который получает
<em class="EMPHASIS">PID</em> процесса (хотя бы через ps) и затем подставляет
найденный <em class="EMPHASIS">PID</em> в правила.
Пример использования критерия можно найти в
<a href="glava08.htm#PID-OWNERTXT"><em>Pid-owner.txt</em></a>.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--sid-owner
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A OUTPUT -m owner --sid-owner 100</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Производится проверка
<em class="EMPHASIS">Session ID</em> пакета. Значение
<em class="EMPHASIS">SID</em> наследуются дочерними процессами от
&quot;родителя&quot;, так, например, все процессы
<em class="EMPHASIS">HTTPD</em> имеют один и тот же
<em class="EMPHASIS">SID</em> (примером таких
процессов могут служить <em class="EMPHASIS">HTTPD</em> Apache и Roxen).
Пример использования этого критерия можно найти в
<a href="glava08.htm#SID-OWNERTXT"><em>Sid-owner.txt</em></a>.
Этот скрипт можно запускать по времени для проверки наличия процесса
<em class="EMPHASIS">HTTPD</em>, и в случае отсутствия перезапустить
&quot;упавший&quot; процесс, после чего сбросить содержимое цепочки
<em class="EMPHASIS">OUTPUT</em> и ввести ее снова.</td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="STATEMATCH">6.4.3.6. Критерий State</a></h3>
<p>Критерий <strong class="COMMAND">state</strong> используется совместно с
кодом трассировки соединений и позволяет нам получать
информацию о признаке состояния соединения, что позволяет
судить о состоянии соединения, причем даже для таких протоколов,
как <em class="EMPHASIS">ICMP</em> и <em class="EMPHASIS">UDP</em>.
Данное расширение необходимо загружать явно, с помощью ключа
<strong class="COMMAND">-m state</strong>. Более подробно механизм
определения состояния соединения обсуждается в разделе
<a href="#STATEMACHINE"><em>Механизм определения состояний</em></a>.</p>

<a name="TABLE.STATEMATCHES"></a>
<p><strong>Таблица 6-13. Ключи критерия State</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--state
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -m state --state RELATED,ESTABLISHED</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Проверяется признак состояния
соединения (state). На сегодняшний день можно указывать 4 состояния:
<strong class="COMMAND">INVALID</strong>, <strong class="COMMAND">ESTABLISHED
</strong>, <strong class="COMMAND">NEW</strong> и
<strong class="COMMAND">RELATED</strong>.
<strong class="COMMAND">INVALID</strong> подразумевает, что пакет связан с
неизвестным потоком или соединением и, возможно, содержит ошибку в
данных или в заголовке. Состояние <strong class="COMMAND">ESTABLISHED
</strong> указывает на то, что пакет принадлежит уже установленному
соединению через которое пакеты идут в обеих направлениях.
Признак <strong class="COMMAND">NEW</strong> подразумевает,
что пакет открывает новое соединение или принадлежит однонаправленному потоку.
И наконец, признак <strong class="COMMAND">RELATED</strong> указывает на то,
что пакет принадлежит уже существующему соединению, но при этом он
открывает новое соединение. Примером тому может служить передача
данных по <em class="EMPHASIS">FTP</em> или выдача сообщения
<em class="EMPHASIS">ICMP</em> об ошибке, которое связано с существующим
<em class="EMPHASIS">TCP</em> или <em class="EMPHASIS">UDP</em>-соединением.
Замечу, что признак <strong class="COMMAND">NEW</strong> это не то же самое,
что установленный бит <em class="EMPHASIS">SYN</em> в пакетах
<em class="EMPHASIS">TCP</em>, посредством которых открывается новое
соединение, и подобного рода пакеты могут быть потенциально опасны в случае,
когда для защиты сети Вы используете один сетевой экран. Более подробно эта
проблема рассматривается ниже в главе <a href="#STATEMACHINE"><em>
Механизм определения состояний</em></a>.</td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="TOSMATCH">6.4.3.7. Критерий TOS</a></h3>
<p>Критерий <strong class="COMMAND">TOS</strong> предназначен для проведения
проверки битов поля <em class="EMPHASIS">TOS</em>. <em class="EMPHASIS">TOS
(Type Of Service)</em> представляет собой 8-ми битовое поле в
заголовке IP-пакета. Модуль должен загружаться явно, ключом
<strong class="COMMAND">-m tos</strong>.</p>

<p>Данное поле служит для нужд маршрутизации пакета. Установка любого бита
может привести к тому, что пакет будет обработан маршрутизатором не так,
как пакет со сброшенными битами <em class="EMPHASIS">TOS</em>.
Каждый бит поля <em class="EMPHASIS">TOS</em> имеет свое значение.
В пакете может быть установлен только один из битов этого поля,
поэтому комбинации недопустимы. Каждый бит определяет тип сетевой службы:</p>

<p><strong class="COMMAND">Минимальная задержка</strong>:
Используется в ситуациях, когда время передачи пакета
должно быть минимальным, то есть, если есть возможность,
то маршрутизатор для такого пакета будет выбирать более скоростной канал.
Например, если есть выбор между оптоволоконной линией и спутниковым каналом,
то предпочтение будет отдано более скоростному оптоволокну.</p>

<p><strong class="COMMAND">Максимальная пропускная способность</strong>:
Указывает, что пакет должен быть переправлен через канал с
максимальной пропускной способностью. Например, спутниковые каналы, обладая
большей задержкой имеют высокую пропускную способность.</p>

<p><strong class="COMMAND">Максимальная надежность</strong>:
Выбирается максимально надежный маршрут во избежание
необходимости повторной передачи пакета. Примером могут служить PPP и
SLIP-соединения, которые по своей надежности уступают, к примеру, сетям X.25,
поэтому, сетевой провайдер может предусмотреть специальный
маршрут с повышенной надежностью.</p>

<p><strong class="COMMAND">Минимальные затраты</strong>:
Применяется в случаях, когда важно минимизировать затраты (в смысле деньги)
на передачу данных. Например, при передаче через океан (на другой континент)
аренда спутникового канала может оказаться дешевле,
чем аренда оптоволоконного кабеля. Установка данного бита вполне может
привести к тому, что пакет пойдет по более &quot;дешевому&quot; маршруту.</p>

<p><strong class="COMMAND">Обычный сервис</strong>:
В данной ситуации все биты поля TOS сброшены. Маршрутизация такого пакета
полностью отдается на усмотрение провайдера.</p>

<a name="TABLE.TOSMATCHES"></a>
<p><strong>Таблица 6-14. Ключи критерия TOS</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--tos
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp -m tos --tos 0x16</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Данный критерий предназначен для
проверки установленных битов <em class="EMPHASIS">TOS</em>,
которые описывались выше. Как правило, поле используется для нужд
маршрутизации, но вполне может быть использовано с целью
&quot;маркировки&quot; пакетов для использования с iproute2 и дополнительной
маршрутизации в linux. В качестве аргумента критерию может быть передано
десятичное или шестнадцатиричное число, либо мнемоническое описание бита,
мнемоники и их числовое значение Вы можете получить, выполнив команду
<strong class="COMMAND">iptables -m tos -h</strong>.
Ниже приводятся мнемоники и их значения.
<tt class="COMPUTEROUTPUT">Minimize-Delay 16 (0x10)</tt>
(Минимальная задержка), <tt class="COMPUTEROUTPUT">Maximize-Throughput 8
(0x08)</tt> (Максимальная пропускная способность),
<tt class="COMPUTEROUTPUT">Maximize-Reliability 4 (0x04)</tt>
(Максимальная надежность), <tt class="COMPUTEROUTPUT">Minimize-Cost 2 (0x02)
</tt> (Минимальные затраты), <tt class="COMPUTEROUTPUT">Normal-Service 0
(0x00)</tt> (Обычный сервис).</td></tr></tbody></table>

<hr><h3 class="SECTION"><a name="TTLMATCH">6.4.3.8. Критерий TTL</a></h3>
<p><strong class="COMMAND">TTL</strong> (Time To Live) является
числовым полем в IP-заголовке. При прохождении очередного маршрутизатора,
это число уменьшается на 1. Если число становится равным нулю,
то отправителю пакета будет передано <em class="EMPHASIS">ICMP</em>-сообщение
типа 11 с кодом 0 <em class="EMPHASIS">(TTL equals 0 during transit)</em> или
с кодом 1 <em class="EMPHASIS">(TTL equals 0 during reassembly)</em>.
Для использования этого критерия необходимо явно
загружать модуль ключом <strong class="COMMAND">-m ttl</strong>.</p>

<a name="TABLE.TTLMATCHES"></a>
<p><strong>Таблица 6-15. Ключи критерия TTL</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--ttl
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A OUTPUT -m ttl --ttl 60</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Производит проверку поля
<em class="EMPHASIS">TTL</em> на равенство заданному значению.
Данный критерий может быть использован
при наладке локальной сети, например, для случаев, когда какая-либо машина
локальной сети не может подключиться к серверу в Интернете
или для поиска &quot;троянов&quot; и пр. В общем, области применения этого
поля ограничиваются только Вашей фантазией. Еще один пример:
использование этого критерия может быть направлено на поиск машин с
некачественной реализацией стека <em class="EMPHASIS">TCP/IP</em>
или с ошибками в конфигурации ОС.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="UNCLEANMATCH">6.4.4.
Критерий &quot;мусора&quot; (Unclean match)</a></h2>
<p>Критерий <strong class="COMMAND">unclean</strong> не имеет дополнительных
ключей и для его использования достаточно явно загрузить модуль.
Будьте осторожны, данный модуль находится еще на стадии разработки и поэтому
в некоторых ситуациях может работать некорректно.
Данная проверка производится для вычленения пакетов,
которые имеют расхождения с принятыми стандартами, это могут быть пакеты с
поврежденным заголовком или с неверной контрольной суммой и пр., однако
использование этой проверки может привести к разрыву и
вполне корректного соединения.</p>

<hr><h1 class="SECTION"><a name="TARGETS">6.5. Действия и переходы</a></h1>
<p>Действия и переходы сообщают правилу, что необходимо выполнить,
если пакет соответствует заданному критерию. Чаще всего употребляются
действия <strong class="COMMAND">ACCEPT</strong> и <strong class="COMMAND">
DROP</strong>. Однако, давайте кратко рассмотрим понятие переходов.</p>

<p>Описание переходов в правилах выглядит точно так же,
как и описание действий, то есть ставится ключ
<strong class="COMMAND">-j</strong> и указывается название цепочки правил,
на которую выполняется переход. На переходы накладывается ряд ограничений,
первое: цепочка, на которую выполняется переход, должна находиться в той же
таблице, что и цепочка, из которой этот переход выполняется,
второе: цепочка, являющаяся целью перехода, должна быть создана до того,
как на нее будут выполняться переходы. Например, создадим цепочку
<strong class="COMMAND">tcp_packets</strong> в таблице
filter с помощью команды</p>
<pre class="SCREEN">
<strong class="COMMAND">iptables -N tcp_packets</strong>
</pre>

<p>Теперь мы можем выполнять переходы на эту цепочку подобно:</p>
<pre class="SCREEN">
<strong class="COMMAND">iptables -A INPUT -p tcp -j tcp_packets</strong>
</pre>

<p>То есть встретив пакет протокола tcp, iptables произведет
переход на цепочку <strong class="COMMAND">tcp_packets</strong>
и продолжит движение пакета по этой цепочке. Если пакет достиг конца цепочки,
то он будет возвращен в вызывающую цепочку (в нашем случае это цепочка
<strong class="COMMAND">INPUT</strong>),
и движение пакета продолжится с правила, следующего за правилом,
вызвавшем переход. Если к пакету во вложенной цепочке будет применено
действие <strong class="COMMAND">ACCEPT</strong>, то автоматически пакет
будет считаться принятым и в вызывающей цепочке и уже не будет продолжать
движение по вызывающим цепочкам. Однако, пакет пойдет по другим
цепочкам в других таблицах. Дополнительную информацию о порядке
прохождения цепочек и таблиц Вы сможете получить в главе
<a href="#TRAVERSINGOFTABLES"><em>Порядок прохождения таблиц и цепочек
</em></a>.</p>

<p>Действие это предопределенная команда, описывающая действие,
которое необходимо выполнить, если пакет совпал с заданным критерием.
Например, можно применить действие <strong class="COMMAND">DROP</strong> или
<strong class="COMMAND">ACCEPT</strong> к пакету, в зависимости от наших нужд.
Существует и ряд других действий, которые описываются ниже в этом разделе.
В результате выполнения одних действий, пакет прекращает свое прохождение по
цепочке, например, <strong class="COMMAND">DROP</strong> и
<strong class="COMMAND">ACCEPT</strong>, в результате других, после
выполнения неких операций, продолжает проверку, например,
<strong class="COMMAND">LOG</strong>, в результате работы третьих
даже видоизменяется, например, <strong class="COMMAND">DNAT</strong> и
<strong class="COMMAND">SNAT</strong>, <strong class="COMMAND">TTL</strong>
и <strong class="COMMAND">TOS</strong>, но также продолжает
продвижение по цепочке.</p>

<hr><h2 class="SECTION"><a name="ACCEPTTARGET">6.5.1. Действие ACCEPT</a>
</h2>
<p>Данная операция не имеет дополнительных ключей. Если над пакетом
выполняется действие <strong class="COMMAND">ACCEPT</strong>,
то пакет прекращает движение по цепочке (и всем вызвавшим цепочкам,
если текущая цепочка была вложенной) и считается ПРИНЯТЫМ
(то есть пропускается), тем не менее, пакет продолжит движение по цепочкам в
других таблицах и может быть отвергнут там. Действие задается с помощью ключа
<strong class="COMMAND">-j ACCEPT</strong>.</p>

<hr><h2 class="SECTION"><a name="DNATTARGET">6.5.2. Действие DNAT</a></h2>
<p><strong class="COMMAND">DNAT</strong> (Destination Network Address
Translation) используется для преобразования адреса места
назначения в IP-заголовке пакета. Если пакет подпадает под
критерий правила, выполняющего <strong class="COMMAND">DNAT</strong>,
то этот пакет и все последующие пакеты из этого же потока, будут подвергнуты
преобразованию адреса назначения и переданы на требуемое
устройство, хост или сеть. Данное действие может, к примеру,
успешно использоваться для предоставления доступа
к Вашему web-серверу, находящемуся в локальной сети, и не
имеющему реального IP-адреса. Для этого Вы строите правило,
которое перехватывает пакеты, идущие на <em class="EMPHASIS">HTTP</em>-порт
брандмауэра и выполняя <strong class="COMMAND">DNAT</strong> передаете их на
локальный адрес web-сервера. Для этого действия также можно указать
диапазон адресов, тогда выбор адреса назначения для каждого
нового потока будет производиться случайнам образом.</p>

<p>Действие <strong class="COMMAND">DNAT</strong> может выполняться только в
цепочках <strong class="COMMAND">PREROUTING</strong> и
<strong class="COMMAND">OUTPUT</strong> таблицы nat
и во вложенных подцепочках. Важно запомнить, что вложенные подцепочки,
реализующие <strong class="COMMAND">DNAT</strong> не должны вызываться из
других цепочек, кроме <strong class="COMMAND">PREROUTING</strong> и
<strong class="COMMAND">OUTPUT</strong>.</p>

<a name="TABLE.DNATTARGET"></a>
<p><strong>Таблица 6-16. Действие DNAT</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--to-destination</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t nat -A PREROUTING -p tcp -d 15.45.23.67 --dport 80 -j DNAT
--to-destination 192.168.1.1-192.168.1.10</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--to-destination</strong> указывает, какой IP-адрес должен быть подставлен в
качестве адреса места назначения. В вышеприведенном примере во всех пакетах,
пришедших на адрес 15.45.23.67, адрес назначения будет изменен
на один из диапазона от 192.168.1.1 до 192.168.1.10. Как уже указывалось выше,
все пакеты из одного потока будут направляться на один и тот же адрес,
а для каждого нового потока будет
выбираться один из адресов в указанном диапазоне случайным образом.
Можно также определить единственный IP-адрес. Можно дополнительно указать
порт или диапазон портов, на который (которые)
будет перенаправлен трафик. Для этого после ip-адреса через
двоеточие укажите порт, например, <strong class="COMMAND">--to-destination
192.168.1.1:80</strong>, а указание диапазона портов выглядит так:
<strong class="COMMAND">--to-destination 192.168.1.1:80-100</strong>.
Как Вы можете видеть, синтаксис действий
<strong class="COMMAND">DNAT</strong> и <strong class="COMMAND">SNAT</strong>
во многом схож. Не забывайте, что указание портов допускается только
при работе с протоколом TCP или UDP, при наличии опции
<strong class="COMMAND">--protocol</strong> в критерии.
</td></tr></tbody></table>

<p>Действие <strong class="COMMAND">DNAT</strong> достаточно сложно в
использовании и требует дополнительного пояснения.
Рассмотрим простой пример. У нас есть WEB-сервер, и мы хотим
разрешить доступ к нему из Интернет. Мы имеем только один
реальный IP-адрес, а WEB-сервер расположен в локальной сети.
Реальный IP-адрес <strong class="COMMAND">$INET_IP</strong> назначен
брандмауэру, HTTP-сервер имеет локальный адрес <strong class="COMMAND">
$HTTP_IP</strong>, и наконец брандмауэр имеет локальный алрес
<strong class="COMMAND">$LAN_IP</strong>. Для начала добавим простое правило
в цепочку <strong class="COMMAND">PREROUTING</strong> таблицы nat:</p>
<pre class="SCREEN">
<strong class="COMMAND">
iptables -t nat -A PREROUTING --dst $INET_IP -p tcp --dport 80 -j DNAT \
         --to-destination $HTTP_IP</strong>
</pre>

<p>В соответствии с этим правилом, все пакеты, поступающие
на 80-й порт адреса $INET_IP перенаправляются на наш
внутренний WEB-сервер. Если теперь обратиться к WEB-серверу из Интернет,
то все будет работать прекрасно. Но что же произойдет,
если попробовать соединиться с ним из локальной сети?
Соединение просто не установится. Давайте посмотрим как
маршрутизируются пакеты, идущие из Интернет на WEB-сервер.
Для простоты изложения примем адрес клиента в
Интернет равным <strong class="COMMAND">$EXT_BOX</strong>.</p>

<ol type="1"><li><p>Пакет покидает клиентский узел с адресом
<strong class="COMMAND">$EXT_BOX</strong> и направляется на
<strong class="COMMAND">$INET_IP</strong></p>.</li>
<li><p>Пакет приходит на наш брандмауэр.</p></li>
<li><p>Брандмауэр, в соответствии с вышеприведенным правилом,
подменяет адрес назначения и передает его дальше, в другие цепочки.</p></li>
<li><p>Пакет передается на <strong class="COMMAND">$HTTP_IP</strong>.</p></li>
<li><p>Пакет поступает на <em class="EMPHASIS">HTTP</em>-сервер и сервер
передает ответ через брандмауэр, если в таблице маршрутизации он обозначен
как шлюз для <strong class="COMMAND">$EXT_BOX</strong>. Как правило, он
назначается шлюзом по умолчанию для <em class="EMPHASIS">HTTP</em>-сервера.
</p></li>

<li><p>Брандмауэр производит обратную подстановку адреса в пакете,
теперь все выглядит так, как будто бы пакет был
сформирован на брандмауэре.</p></li>
<li><p>Пакет передается клиенту <strong class="COMMAND">$EXT_BOX</strong>.
</p></li></ol>

<p>А теперь посмотрим, что произойдет, если запрос посылается с узла,
расположенного в той же локальной сети.
Для простоты изложения примем адрес клиента в локальной
сети равным <strong class="COMMAND">$LAN_BOX</strong>.</p>

<ol type="1"><li><p>Пакет покидает <strong class="COMMAND">$LAN_BOX</strong>.
</p></li>
<li><p>Поступает на брандмауэр.</p></li>
<li><p>Производится подстановка адреса назначения, однако
адрес отправителя не подменяется, то есть исходный адрес
остается в пакете без изменения.</p></li>
<li><p>Пакет покидает брандмауэр и отправляется на HTTP-сервер.</p></li>
<li><p><em class="EMPHASIS">HTTP</em>-сервер, готовясь к отправке ответа,
обнаруживает, что клиент находится в локальной сети (поскольку пакет запроса
содержал оригинальный IP-адрес, который теперь превратился в адрес
назначения) и поэтому отправляет пакет непосредственно на
<strong class="COMMAND">$LAN_BOX</strong>.</p></li>
<li><p>Пакет поступает на <strong class="COMMAND">$LAN_BOX</strong>.
Клиент &quot;путается&quot;, поскольку ответ пришел не с того узла,
на который отправлялся запрос. Поэтому клиент &quot;сбрасывает&quot;
пакет ответа и продолжает ждать &quot;настоящий&quot; ответ.</p></li></ol>

<p>Проблема решается довольно просто с помощью <strong class="COMMAND">SNAT
</strong>. Ниже приводится правило, которое выполняет эту функцию.
Это правило вынуждает HTTP-сервер передавать ответы на наш брандмауэр,
которые затем будут переданы клиенту.</p>
<pre class="SCREEN">
<strong class="COMMAND">
iptables -t nat -A POSTROUTING -p tcp --dst $HTTP_IP --dport 80 -j SNAT \
         --to-source $LAN_IP
</strong>
</pre>

<p>Запомните, цепочка <em class="EMPHASIS">POSTROUTING</em> обрабатывается
самой последней, к этому моменту пакет уже прошел процедуру
преобразования <strong class="COMMAND">DNAT</strong>,
поэтому критерий строится на базе адреса назначения
<strong class="COMMAND">$HTTP_IP</strong>.</p>

<p>Если Вы думаете, что на этом можно остановиться, то ошибаетесь!
Представим себе ситуацию, когда в качестве клиента выступает сам брандмауэр.
Тогда, к сожалению, пакеты будут передаваться на локальный порт с номером 80
самого брандмауэра, а не на <strong class="COMMAND">$HTTP_IP</strong>.
Чтобы разрешить и эту проблему, добавим правило:</p>
<pre class="SCREEN">
<strong class="COMMAND">
iptables -t nat -A OUTPUT --dst $INET_IP -p tcp --dport 80 -j DNAT \
         --to-destination $HTTP_IP</strong>
</pre>
<p>Теперь никаких проблем, с доступом к нашему WEB-серверу,
уже не должно возникать.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Каждый должен понять, что эти правила
предназначены только лишь для корректной обработки адресации пакетов.
В дополнение к этим правилам может потребоваться написать дополнительные
правила для цепочки <em class="EMPHASIS">FORWARD</em> таблицы filter.
Не забудьте при этом, что пакеты уже прошли цепочку
<em class="EMPHASIS">PREROUTING</em> и поэтому их адреса назначения уже
изменены действием <em class="EMPHASIS">DNAT</em>.</p></td></tr></table>

<hr><h2 class="SECTION"><a name="DROPTARGET">6.5.3. Действие DROP</a></h2>
<p>Данное действие просто &quot;сбрасывает&quot; пакет и
iptables забывает; о его существовании.
&quot;Сброшенные&quot; пакеты прекращают свое движение полностью,
то есть они не передаются в другие таблицы, как это происходит в случае с
действием <strong class="COMMAND">ACCEPT</strong>. Следует помнить, что
данное действие может иметь негативные последствия,
поскольку может оставлять незакрытые &quot;мертвые&quot;
сокеты как на стороне сервера, так и на стороне клиента,
наилучшим способом защиты будет использование действия
<strong class="COMMAND">REJECT</strong>, особенно при защите
от сканирования портов.</p>

<hr><h2 class="SECTION"><a name="LOGTARGET">6.5.4. Действие LOG</a></h2>
<p><strong class="COMMAND">LOG</strong> действие, которое служит
для журналирования отдельных пакетов и событий. В журнал могут заноситься
заголовки IP-пакетов и другая интересующая Вас информация.
Информация из журнала может быть затем прочитана с помощью dmesg или syslogd,
либо с помощью других программ. Превосходное средство для отладки правил.
Неплохо было бы на период отладки правил вместо действия
<strong class="COMMAND">DROP</strong> использовать действие
<strong class="COMMAND">LOG</strong>, чтобы до конца убедиться,
что Ваш брандмауэр работает безупречно. Обратите внимание также на действие
<strong class="COMMAND">ULOG</strong>,
которое наверняка заинтересует Вас своими возможностями, поскольку позволяет
выполнять запись журналируемой информации не в системный журнал,
а в базу данных MySQL и т. п.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top">
<p>Обратите внимание: если у Вас имеются проблемы
с записью в системный журнал, то это проблемы не
iptables или netfilter, а syslogd. За информацией по конфигурированию
syslogd обращайтесь к <strong class="COMMAND">man syslog.conf</strong>.</p>
</td></tr></table>
<p>Действие <strong class="COMMAND">LOG</strong> имеет пять ключей,
которые перечислены ниже.</p>

<a name="TABLE.LOGTARGET"></a>
<p><strong>Таблица 6-17. Ключи действия LOG</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--log-level
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A FORWARD -p tcp -j LOG --log-level debug</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Используется для задания уровня
журналирования (log level). Полный список уровней Вы найдете в руководстве
(man) по syslog.conf. Обычно можно задать следующие уровни:
<em class="EMPHASIS">debug</em>, <em class="EMPHASIS">info</em>,
<em class="EMPHASIS">notice</em>, <em class="EMPHASIS">warning</em>,
<em class="EMPHASIS">warn</em>, <em class="EMPHASIS">err</em>,
<em class="EMPHASIS">error</em>, <em class="EMPHASIS">crit</em>,
<em class="EMPHASIS">alert</em>, <em class="EMPHASIS">emerg</em> и
<em class="EMPHASIS">panic</em>. Ключевое слово
<em class="EMPHASIS">error</em> означает то же самое,
что и <em class="EMPHASIS">err</em>,
<em class="EMPHASIS">warn</em> - <em class="EMPHASIS">warning</em> и
<em class="EMPHASIS">panic</em> - <em class="EMPHASIS">emerg</em>.
Важно: в последних трех парах слов не следует использовать
<em class="EMPHASIS">error</em>, <em class="EMPHASIS">warn</em> и
<em class="EMPHASIS">panic</em>. Приоритет определяет различия в том,
как будут заноситься сообщения в журнал. Все сообщения заносятся в
журнал средствами ядра. Если Вы установите строку
<strong class="COMMAND">kern.=info /var/log/iptables</strong>
в файле syslog.conf, то все Ваши сообщения из
<strong class="COMMAND">iptables</strong>, использующие
уровень <em class="EMPHASIS">info</em>, будут заноситься в файл
/var/log/iptables. Однако, в этот файл попадут и другие сообщения,
поступающие из других подсистем, которые используют уровень
<em class="EMPHASIS">info</em>.
За дополнительной информацией по syslog и syslog.conf я рекомендую
обращаться к manpages и HOWTO.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--log-prefix</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp -j LOG --log-prefix &quot;INPUT packets&quot;
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ задает текст (префикс),
которым будут предваряться все сообщения <strong class="COMMAND">iptables
</strong>. Сообщения со специфичным префиксом затем легко можно найти, к
примеру, с помощью <strong class="COMMAND">grep</strong>.
Префикс может содержать до 29 символов, включая и пробелы.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--log-tcp-sequence</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p tcp -j LOG --log-tcp-sequence</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Этот ключ позволяет заносить в
журнал номер <em class="EMPHASIS">TCP Sequence</em> пакета.
Номер <em class="EMPHASIS">TCP Sequence</em> идентифицирует
каждый пакет в потоке и определяет порядок &quot;сборки&quot; потока.
Этот ключ потенциально опасен для безопасности системы, если системный журнал
разрешает доступ &quot;НА ЧТЕНИЕ&quot; всем пользователям. Как и любой другой
журнал, содержащий сообщения от iptables.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--log-tcp-options</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A FORWARD -p tcp -j LOG --log-tcp-options</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Этот ключ позволяет заносить в
системный журнал различные сведения из заголовка TCP-пакета.
Такая возможность может быть полезна при отладке. Этот ключ не имеет
дополнительных параметров, как и большинство ключей действия
<strong class="COMMAND">LOG</strong>.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--log-ip-options</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A FORWARD -p tcp -j LOG --log-ip-options</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Этот ключ позволяет заносить в
системный журнал различные сведения из заголовка IP-пакета. Во многом схож с
ключом <strong class="COMMAND">--log-tcp-options</strong>, но
работает только с IP-заголовком.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="MARKTARGET">6.5.5. Действие MARK</a></h2>
<p>Используется для установки меток для определенных пакетов.
Это действие может выполняться только в пределах таблицы
<em class="EMPHASIS">mangle</em>. Установка меток обычно
используется для нужд маршрутизации пакетов по различным маршрутам,
для ограничения трафика и т. п. За дополнительной информацией можете
обратиться к <a href="#LARTC"><em>Linux Advanced Routing and Traffic
Control HOW-TO</em></a>. Не забывайте, что &quot;метка&quot; пакета
существует только в период времени, пока пакет не покинул брандмауэр, то есть
метка не передается по сети. Если необходимо как-то пометить пакеты, чтобы
использовать маркировку на другой машине, то можете попробовать
манипулировать битами поля <strong class="COMMAND">TOS</strong>.</p>

<a name="TABLE.MARKTARGET"></a>
<p><strong>Таблица 6-18. Ключи действия MARK</strong></p>
<table border="1" class="CALSTABLE"><tbody>
<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--set-mark
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t mangle -A PREROUTING -p tcp --dport 22 -j MARK --set-mark 2
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--set-mark</strong> устанавливает метку на пакет. После ключа
<strong class="COMMAND">--set-mark</strong> должно
следовать целое беззнаковое число.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="MASQUERADETARGET">6.5.6. Действие
MASQUERADE</a></h2>
<p>Маскарадинг (<strong class="COMMAND">MASQUERADE</strong>) в основе своей
представляет то же самое, что и <strong class="COMMAND">SNAT</strong>,
только не имеет ключа <strong class="COMMAND">--to-source</strong>.
Причиной тому то, что маскарадинг может работать, например, с
dialup-подключением или DHCP, то есть в тех случаях, когда IP-адрес
присваивается устройству динамически. Если у Вас имеется
динамическое подключение, то нужно использовать маскарадинг, если же у Вас
статическое IP-подключение, то бесспорно лучшим выходом
будет использование действия <strong class="COMMAND">SNAT</strong>.</p>

<p>Маскарадинг подразумевает получение IP-адреса от
заданного сетевого интерфейса, вместо прямого его указания,
как это делается с помощью ключа <strong class="COMMAND">--to-source</strong>
в действии <strong class="COMMAND">SNAT</strong>. Действие
<strong class="COMMAND">MASQUERADE</strong> имеет хорошее свойство:
&quot;забывать&quot; соединения при остановке сетевого интерфейса.
В случае же <strong class="COMMAND">SNAT</strong> в этой ситуации в таблице
трассировщика остаются данные о потерянных соединениях,
и эти данные могут сохраняться до суток, поглощая ценную память.
Эффект &quot;забывчивости&quot; связан с тем, что при остановке сетевого
интерфейса с динамическим IP-адресом, есть вероятность на следующем запуске
получить другой IP-адрес, но в этом случае любые соединения все
равно будут потеряны, и было бы глупо хранить трассировочную информацию.</p>

<p>Как Вы уже поняли, действие <strong class="COMMAND">MASQUERADE</strong>
может быть использовано вместо <strong class="COMMAND">SNAT</strong>,
даже если Вы имеете постоянный IP-адрес, однако, невзирая на положительные
черты, маскарадинг не следует считать предпочтительным в этом случае,
поскольку он дает большую нагрузку на систему.</p>

<p>Действие <strong class="COMMAND">MASQUERADE</strong> допускается указывать
только в цепочке <em class="EMPHASIS">POSTROUTING</em> таблицы nat, также как
и действие <strong class="COMMAND">SNAT</strong>.
<strong class="COMMAND">MASQUERADE</strong> имеет ключ,
описываемый ниже, использование которого необязательно.</p>

<a name="TABLE.MASQUERADETARGET"></a>
<p><strong>Таблица 6-19. Действие MASQUERADE</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--to-ports
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE --to-ports 1024-31000
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--to-ports</strong> используется для указания порта источника или диапазона
портов исходящего пакета. Можно указать один порт, например:
<strong class="COMMAND">--to-ports 1025</strong> или диапазон портов:
<strong class="COMMAND">--to-ports 1024-3000</strong>.
Этот ключ можно использовать только в правилах, где критерий содержит явное
указание на протокол TCP или UDP с помощью ключа
<strong class="COMMAND">--protocol</strong>.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="MIRRORTARGET">6.5.7. Действие MIRROR</a></h2>
<p>Действие <strong class="COMMAND">MIRROR</strong> может использоваться Вами
только для экспериментов и в демонстрационных целях,
поскольку это действие может привести к &quot;зацикливанию&quot; пакета и в
результате к &quot;Отказу от обслуживания&quot;. В результате действия
<strong class="COMMAND">MIRROR</strong> в пакете, поля source и
destination меняются местами (invert the source and destination fields)
и пакет отправляется в сеть.
Использование этой команды может иметь весьма забавный результат, наверное,
со стороны довольно потешно наблюдать, как какой-нибудь хакер пытается
&quot;взломать&quot; свой собственный компьютер!</p>

<p>Данное действие допускается использовать только в цепочках
<em class="EMPHASIS">INPUT</em>, <em class="EMPHASIS">FORWARD</em> и
<em class="EMPHASIS">PREROUTING</em> и в цепочках, вызываемых из этих трех.
Пакеты, отправляемые в сеть действием <strong class="COMMAND">MIRROR</strong>
больше не подвергаются фильтрации, трассировке или
<strong class="COMMAND">NAT</strong>, избегая тем самым
&quot;зацикливания&quot; и других неприятностей. Однако, это не означает,
что проблем с этим действием нет. Давайте, к примеру, представим,
что на хосте, использующем действие
<strong class="COMMAND">MIRROR</strong> фабрикуется пакет, с
<strong class="COMMAND">TTL</strong> равным 255, на этот же самый
хост и пакет подпадает под критерий &quot;зеркалирующего&quot; правила.
Пакет &quot;отражается&quot; на этот же хост, а поскольку между
&quot;приемником&quot; и &quot;передатчиком&quot; только 1 хоп (hop),
то пакет будет прыгать туда и обратно 255 раз. Неплохо для хакера, ведь,
при величине пакета 1500 байт, мы потеряем до 380 Кбайт трафика!</p>

<hr><h2 class="SECTION"><a name="QUEUETARGET">6.5.8. Действие QUEUE</a></h2>
<p>ействие <strong class="COMMAND">QUEUE</strong> ставит пакет в очередь на
обработку пользовательскому процессу. Оно может быть
использовано для нужд учета, проксирования или
дополнительной фильтрации пакетов.</p>

<hr><h2 class="SECTION"><a name="REDIRECTTARGET">6.5.9. Действие REDIRECT</a>
</h2>
<p>Выполняет перенаправление пакетов и потоков на другой порт той
же самой машины. К примеру, можно пакеты, поступающие на HTTP-порт,
перенаправить на порт HTTP proxy. Действие <strong class="COMMAND">REDIRECT
</strong> очень удобно для выполнения &quot;прозрачного&quot; проксирования
(transparent proxying), когда машины в локальной сети даже
не подозревают о существовании прокси.</p>

<p><strong class="COMMAND">REDIRECT</strong> может использоваться
только в цепочках <em class="EMPHASIS">PREROUTING</em> и
<em class="EMPHASIS">OUTPUT</em> таблицы nat. И конечно же это
действие можно выполнять в подцепочках, вызываемых и вышеуказанных.
Для действия <strong class="COMMAND">REDIRECT</strong> предусмотрен
только один ключ.</p>

<a name="TABLE.REDIRECTTARGET"></a>
<p><strong>Таблица 6-20. Действие REDIRECT</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--to-ports
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--to-ports</strong> определяет порт или диапазон портов назначения.
Без указания ключа <strong class="COMMAND">--to-ports</strong>,
перенаправления не происходит, то есть пакет идет на тот порт,
куда и был назначен. В примере, приведенном выше,
<strong class="COMMAND">--to-ports 8080</strong> указан один порт назначения.
Если нужно указать диапазон портов, то мы должны написать нечто подобное
<strong class="COMMAND">--to-ports 8080-8090</strong>.
Этот ключ можно использовать только в правилах, где критерий содержит явное
указание на протокол TCP или UDP с помощью ключа <strong class="COMMAND">
--protocol</strong>.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="REJECTTARGET">6.5.10. Действие REJECT</a>
</h2>
<p><strong class="COMMAND">REJECT</strong> используется, как правило,
в тех же самых ситуациях, что и <strong class="COMMAND">DROP</strong>,
но в отличие от <strong class="COMMAND">DROP</strong>, команда
<strong class="COMMAND">REJECT</strong> выдает сообщение об ошибке
на хост, передавший пакет. Действие <strong class="COMMAND">REJECT</strong>
на сегодняшний день может использоваться только в цепочках
<em class="EMPHASIS">INPUT</em>, <em class="EMPHASIS">FORWARD</em> и
<em class="EMPHASIS">OUTPUT</em> (и во вложенных в них цепочках).
Пока существует только единственный ключ,
управляющий поведением команды <strong class="COMMAND">REJECT</strong>.</p>

<a name="TABLE.REJECTTARGET"></a>
<p><strong>Таблица 6-21. Действие REJECT</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--reject-with</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A FORWARD -p TCP --dport 22 -j REJECT --reject-with tcp-reset
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Указывает, какое сообщение необходимо передать в ответ,
если пакет совпал с заданным критерием. При применении действия
<strong class="COMMAND">REJECT</strong> к пакету, сначала на хост-отправитель
будет отослан указанный ответ, а затем пакет будет &quot;сброшен&quot;.
Допускается использовать следующие типы ответов:
<tt class="COMPUTEROUTPUT">icmp-net-unreachable</tt>,
<tt class="COMPUTEROUTPUT">icmp-host-unreachable</tt>,
<tt class="COMPUTEROUTPUT">icmp-port-unreachable</tt>,
<tt class="COMPUTEROUTPUT">icmp-proto-unreachable</tt>,
<tt class="COMPUTEROUTPUT">icmp-net-prohibited</tt> и
<tt class="COMPUTEROUTPUT">icmp-host-prohibited</tt>.
по умолчанию передается сообщение
<tt class="COMPUTEROUTPUT">port-unreachable</tt>. Все вышеуказанные типы
ответов являются <em class="EMPHASIS">ICMP error messages</em>.
Дополнительную информацию по типам ICMP-сообщений Вы можете получить в
приложении <a href="typeicmp.htm#ICMPTYPES"><em>Типы ICMP</em></a>.
В заключение укажем еще один тип ответа:
<strong class="COMMAND">tcp-reset</strong>, который используется только
для протокола TCP. Если указано значение
<strong class="COMMAND">tcp-reset</strong>, то действие
<strong class="COMMAND">REJECT</strong> передаст в ответ пакет
<strong class="COMMAND">TCP RST</strong>, пакеты
<strong class="COMMAND">TCP RST</strong> используются для
закрытия TCP-соединений. За дополнительной информацией обращайтесь к
<a href="links.htm#RFC793"><em>RFC 793. Transmission Control Protocol</em></a>.
Список типов ICMP ответов и их алиасов Вы сможете
получить, введя команду <strong class="COMMAND">iptables -j REJECT -h
</strong>.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="RETURNTARGET">6.5.11. Действие RETURN</a>
</h2>
<p>Действие <strong class="COMMAND">RETURN</strong> прекращает движение
пакета по текущей цепочке правил и производит возврат в вызывающую цепочку,
если текущая цепочка была вложенной, или, если текущая цепочка лежит на самом
верхнем уровне (например, <em class="EMPHASIS">INPUT</em>), то к пакету будет
применена политика по умолчанию. Обычно в качестве политики по умолчанию
назначают действия <strong class="COMMAND">ACCEPT</strong> или
<strong class="COMMAND">DROP</strong>.</p>

<p>Для примера, допустим, что пакет идет по цепочке
<em class="EMPHASIS">INPUT</em> и встречает правило,
которое производит переход во вложенную цепочку:
<strong class="COMMAND">--jump EXAMPLE_CHAIN</strong>.
Далее, в цепочке EXAMPLE_CHAIN пакет встречает правило,
которое выполняет действие <strong class="COMMAND">--jump RETURN</strong>.
Тогда произойдет возврат пакета в цепочку <em class="EMPHASIS">INPUT</em>.
Другой пример, пусть пакет встречает правило, которое выполняет действие
<strong class="COMMAND">--jump RETURN</strong> в цепочке
<em class="EMPHASIS">INPUT</em>. Тогда к пакету будет применена политика
по умолчанию цепочки <em class="EMPHASIS">INPUT</em>.</p>

<hr><h2 class="SECTION"><a name="SNATTARGET">6.5.12. Действие SNAT</a></h2>
<p><strong class="COMMAND">SNAT</strong> используется для преобразования
сетевых адресов (Source Network Address Translation), то есть изменение
исходящего IP-адреса в IP-заголовке пакета. Например, это действие можно
использовать для предоставления выхода в Интернет другим компьютерам из
локальной сети, имея лишь один уникальный IP-адрес. Для этого необходимо
включить пересылку пакетов (forwarding) в ядре и затем создать правила,
которые будут транслировать исходящие IP-адреса нашей локальной сети в
реальный внешний адрес. В результате, внешний мир ничего не будет знать о
нашей локальной сети, он будет считать, что запросы пришли с брандмауэра.</p>

<p><strong class="COMMAND">SNAT</strong> допускается выполнять только
в таблице nat, в цепочке <em class="EMPHASIS">POSTROUTING</em>.
Другими словами, только здесь допускается преобразование исходящих адресов.
Если первый пакет в соединении подвергся преобразованию
исходящего адреса, то все последующие пакеты из этого же
соединения будут преобразованы автоматически и не пойдут
через эту цепочку правил.</p>

<a name="TABLE.SNATTARGET"></a>
<p><strong>Таблица 6-22. Действие SNAT</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--to-source
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t nat -A POSTROUTING -p tcp -o eth0 -j SNAT --to-source
194.236.50.155-194.236.50.160:1024-32000</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--to-source</strong> используется для указания адреса, присваемового пакету.
Все просто: Вы указываете IP-адрес, который будет подставлен в заголовок
пакета в качестве исходящего. Если Вы собираетесь перераспределять
нагрузку между несколькими брандмауэрами, то можно указать диапазон адресов,
где начальный и конечный адреса диапазона разделяются дефисом, например:
194.236.50.155-194.236.50.160. Тогда, конкретный IP-адрес будет выбираться из
диапазона случайным образом для каждого нового потока.
Дополнительно можно указать диапазон портов, которые будут использоваться
только для нужд <strong class="COMMAND">SNAT</strong>. Все исходящие порты
будут после этого перекартироваться в заданный диапазон.
iptables старается по возможности избегать перекартирования портов,
однако не всегда это возможно, и тогда производится перекартирование.
Если диапазон портов не задан, то исходные порты ниже 512 перекартируются в
диапазоне 0-511, порты в диапазоне 512-1023 перекартируются в диапазоне
512-1023 и наконец порты из диапазона 1024-65535 перекартируются в диапазон
1024-65535. Что касается портов назначения,
то они не подвергаются перекартированию.</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="TOSTARGET">6.5.13. Действие TOS</a></h2>
<p>Команда <strong class="COMMAND">TOS</strong> используется для установки
битов в поле <em class="EMPHASIS">Type of Service</em> IP-заголовка.
Поле TOS содержит 8 бит, которые используются для маршрутизации пакетов.
Это один из нескольких полей, используемых
<strong class="COMMAND">iproute2</strong>. Также важно помнить,
что данное поле может обрабатываться различными
маршрутизаторами с целью выбора маршрута движения пакета.
Как уже указывалось выше, это поле, в отличие от <strong class="COMMAND">
MARK</strong>, сохраняет свое значение при движении по сети,
а поэтому может использоваться для маршрутизации пакета. На сегодняшний день,
большинство маршрутизаторов в Интернете никак не обрабатывают это поле,
однако есть и такие, которые смотрят на него. Если Вы используете это поле в
своих нуждах, то подобные маршрутизаторы могут принять неверное решение при
выборе маршрута, поэтому, лучше всего использовать это поле для
своих нужд только в пределах Вашей <strong class="COMMAND">WAN</strong>
или <strong class="COMMAND">LAN</strong>.</p>

<table class="CAUTION" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/caution.gif" hspace="5"
alt="Caution"></td>

<td align="left" valign="top">
<p>Действие <strong class="COMMAND">TOS</strong> воспринимает только
предопределенные числовые значения и мнемоники,
которые вы можете найти в <tt class="FILENAME">linux/ip.h</tt>.
Если Вам действительно необходимо устанавливать произвольные
значения в поле TOS, то можно воспользоваться
&quot;заплатой&quot; FTOS с сайта <a href="#PAKSECURED"><em>Paksecured Linux
Kernel patches</em></a>, поддерживаемого Matthew G. Marsh.
Однако, будьте крайне осторожны с этой &quot;заплатой&quot;.
Не следует использовать нестандартные значения TOS иначе,
как в особенных ситуациях.</p></td></tr></table>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Данное действие допускается выполнять только
в пределах таблицы mangle.</p></td></tr></table>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top">
<p>В некоторых старых версиях iptables (1.2.2 и ниже) это действие
реализовано с ошибкой (не исправляется контрольная сумма пакета),
а это ведет к нарушению протокола обмена,
в результате такие соединения обрываются.</p></td></tr></table>
<p>Команда <strong class="COMMAND">TOS</strong> имеет только один ключ,
который описан ниже.</p>

<a name="TABLE.TOSTARGET"></a>
<p><strong>Таблица 6-23. Действие TOS</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--set-tos
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t mangle -A PREROUTING -p TCP --dport 22 -j TOS --set-tos 0x10
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--set-tos</strong> определяет числовое значение в десятичном
или шестнадцатиричном виде. Поскольку поле TOS является 8-битным,
то Вы можете указать число в диапазоне от 0 до 255 (0x00-0xFF).
Однако, большинство значений этого поля никак не используются.
Вполне возможно, что в будущих реализациях TCP/IP числовые
значения могут быть изменены, поэтому во избежание ошибок лучше использовать
мнемонические обозначения: <tt class="COMPUTEROUTPUT">Minimize-Delay</tt>
(16 или 0x10), <tt class="COMPUTEROUTPUT">Maximize-Throughput</tt> (8 или
0x08), <tt class="COMPUTEROUTPUT">Maximize-Reliability</tt>
(4 или 0x04), <tt class="COMPUTEROUTPUT">Minimize-Cost</tt> (2 или
0x02) или <tt class="COMPUTEROUTPUT">Normal-Service</tt> (0 или 0x00).
По умолчанию большинство пакетов имеют признак
<tt class="COMPUTEROUTPUT">Normal-Service</tt> или 0.
Список мнемоник Вы сможете получить, выполнив команду
<strong class="COMMAND">iptables -j TOS -h</strong>.
</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="TTLTARGET">6.5.14. Действие TTL</a></h2>
<p>Действие <strong class="COMMAND">TTL</strong> используется для изменения
содержимого поля Time To Live в IP-заголовке. Один из вариантов применения
этого действия: это устанавливать значение поля Time To Live ВО ВСЕХ
исходящих пакетах в одно и то же значение. Для чего это?!
Есть некоторые провайдеры, которые очень не любят, когда одним подключением
пользуется несколько компьютеров, если мы начинаем устанавливать на
все пакеты одно и то же значение TTL, то тем самым мы
лишаем провайдера одного из критериев определения того,
что подключение к Интернету разделяется несколькими компьютерами.
Для примера можно привести число TTL=64,
которое является стандартным для ядра Linux.</p>

<p>За дополнительной информацией по установке значения
по умолчанию обращайтесь к <a href="#IP-SYSCTLTXT"><em>ip-sysctl.txt</em></a>,
который Вы найдете в приложении <a href="links.htm#OTHERRESOURCES"><em>
Ссылки на другие ресурсы</em></a>.</p>

<p>Действие <strong class="COMMAND">TTL</strong> можно указывать только в
таблице mangle и нигде больше. Для данного действия
предусмотрено 3 ключа, описываемых ниже.</p>

<a name="TABLE.TTLTARGET"></a>
<p><strong>Таблица 6-24. Действие TTL</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--ttl-set
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-set 64
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Устанавливает поле TTL в заданное значение.
Оптимальным считается значение около 64.
Это не слишком много, но и не слишком мало.
Не задавайте слишком большое значение, это может иметь неприятные
последствия для Вашей сети. Представьте себе, что пакет
&quot;зацикливается&quot; между двумя неправильно сконфигурированными
роутерами, тогда при больших значениях TTL есть риск
потерять значительную долю пропускной способности канала.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--ttl-dec
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-dec 1</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Уменьшает значение поля TTL
на заданное число. Например, пусть входящий пакет
имеет значение TTL равное 53, и мы выполняем команду
<strong class="COMMAND">--ttl-dec 3</strong>, тогда пакет покинет наш хост с
полем TTL равным 49. Не забывайте, что сетевой код автоматически уменьшит
значение TTL на 1, поэтому, фактически мы получаем 53-3-1=49.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">--ttl-inc
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -t mangle -A PREROUTING -i eth0 -j TTL --ttl-inc 1</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Увеличивает значение поля TTL
на заданное число. Возьмем предыдущий пример, пусть к
нам поступает пакет с TTL=53, тогда после выполнения команды
<strong class="COMMAND">--ttl-inc 4</strong> на выходе с нашего хоста
пакет будет иметь TTL=56, не забывайте об автоматическом уменьшении поля TTL
сетевым кодом ядра, то есть фактически мы получаем выражение 53+4-1=56.
Увеличение поля TTL может использоваться для того, чтобы сделать наш
брандмауэр менее &quot;заметным&quot; для трассировщиков (traceroutes).
Программы трассировки любят за ценную информацию при поиске проблемных
участков сети и ненавидят за это же, поскольку эта информация может
использоваться хакерами в неблаговидных целях. Пример использования Вы можете
найти в скрипте <a href="glava08.htm#TTL-INCTXT"><em>Ttl-inc.txt</em></a>.
</td></tr></tbody></table>

<hr><h2 class="SECTION"><a name="ULOGTARGET">6.5.15. Действие ULOG</a></h2>
<p>Действие <strong class="COMMAND">ULOG</strong> предоставляет возможность
журналирования пакетов в пользовательское пространство. Оно
заменяет традиционное действие <strong class="COMMAND">LOG</strong>,
базирующееся на системном журнале. При использовании этого действия, пакет
через сокеты netlink передается специальному демону,
который может выполнять очень детальное журналирование в различных
форматах (обычный текстовый файл, база данных MySQL и пр.)
и к тому же поддерживает возможность добавления надстроек
(плагинов) для формирования различных выходных форматов и
обработки сетевых протоколов. Пользовательскую часть ULOGD
Вы можете получить на домашней странице <a href="#ULOGDSITE"><em>
ULOGD project page</em></a>.</p>

<a name="TABLE.ULOGTARGET"></a>
<p><strong>Таблица 6-25. Действие ULOG</strong></p>
<table border="1" class="CALSTABLE">
<tbody><tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--ulog-nlgroup</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-nlgroup 2</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">
Ключ <strong class="COMMAND">--ulog-nlgroup</strong> сообщает
<strong class="COMMAND">ULOG</strong>, в какую группу netlink должен
быть передан пакет. Всего существует 32 группы (от 1 до 32). Если Вы желаете
передать пакет в 5-ю группу, то можно просто указать
<strong class="COMMAND">--ulog-nlgroup 5</strong>.
По умолчанию используется 1-я группа.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--ulog-prefix</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-prefix
&quot;SSH connection attempt: &quot;</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--ulog-prefix</strong> имеет тот же смысл, что и аналогичная опция в действии
<strong class="COMMAND">LOG</strong>. Длина строки префикса
не должна превышать 32 символа.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--ulog-cprange</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-cprange 100
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--ulog-cprange</strong> определяет, какую долю пакета, в байтах,
надо передавать демону <strong class="COMMAND">ULOG</strong>.
Если указать число 100, как показано в примере, то демону будет
передано только 100 байт из пакета, это означает,
что демону будет передан заголовок пакета и некоторая часть области данных
пакета. Если указать 0, будет передан весь пакет, независимо от его размера.
Значение по умолчанию равно 0.</td></tr>

<tr><td width="14%" align="left" valign="top">Ключ</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
--ulog-qthreshold</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Пример</td>
<td width="86%" align="left" valign="top"><strong class="COMMAND">
iptables -A INPUT -p TCP --dport 22 -j ULOG --ulog-qthreshold 10
</strong></td></tr>
<tr><td width="14%" align="left" valign="top">Описание</td>
<td width="86%" align="left" valign="top">Ключ <strong class="COMMAND">
--ulog-qthreshold</strong> устанавливает величину буфера в области ядра.
Например, если задать величину буфера равной 10, как в примере, то ядро будет
накапливать журналируемые пакеты во внутреннем буфере и
передавать в пользовательское пространство группами по 10 пакетов.
По умолчанию размер буфера равен 1 из-за сохранения обратной совместимости с
ранними версиями ulogd, которые не могли принимать группы пакетов.
</td></tr></tbody></table>

<hr><h1><a name="RCFIREWALLFILE">Глава 7. Файл rc.firewall</a></h1>
<p>В этой главе мы рассмотрим настройку брандмауэра на примере
скрипта rc.firewall.txt. Мы будем брать каждую базовую
настройку и рассматривать, как она работает и что делает.
Это может натолкнуть Вас на решение Ваших собственных задач.
Для запуска этого скрипта Вам потребуется внести в него изменения
таким образом, чтобы он мог работать с Вашей конфигурацией сети,
в большинстве случаев достаточно изменить только переменные.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Примечательно, что есть более эффективные
способы задания наборов правил, однако я исходил из мысли о
большей удобочитаемости скрипта, так, чтобы каждый смог понять его
без глубоких познаний оболочки BASH.</p></td></tr></table>

<hr><h1 class="SECTION"><a name="EXAMPLERCFIREWALL">7.1. Пример rc.firewall
</a></h1>
<p>Итак, все готово для разбора файла примера
<a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt</em></a>
(скрипт включен в состав данного документа в приложении
<a href="#EXAMPLECODE"><em>Примеры сценариев</em></a>). Он достаточно велик,
но только из-за большого количества комментариев. Сейчас я предлагаю Вам
просмотреть этот файл, чтобы получить представление о его содержимом и затем
вернуться сюда за более подробными пояснениями.</p>

<hr><h1 class="SECTION"><a name="EXPLANATIONOFRCFIREWALL">
7.2. Описание сценария rc.firewall</a></h1>
<h2 class="SECTION"><a name="CONFIGOPTIONS">7.2.1. Конфигурация</a></h2>
<p>Первая часть файла <a href="glava08.htm#RCFIREWALLTXT"><em>rc.firewall.txt
</em></a> является конфигурационным разделом. Здесь задаются основные
настройки брандмауэра, которые зависят от Вашей конфигурации сети.
Например, IP-адреса наверняка должны быть изменены на Ваши собственные.
Переменная <strong class="COMMAND">$INET_IP</strong> должна содержать
реальный IP-адрес, если Вы подключаетесь к Интернет через DHCP,
то Вам следует обратить внимание на скрипт
<a href="glava08.htm#RCDHCPFIREWALLTXT"><em>rc.DHCP.firewall.txt</em></a>,
Аналогично <strong class="COMMAND">$INET_IFACE</strong> должна указывать Ваше
устройство, через которое осуществляется подключение к Интернет.
Это может быть, к примеру, eth0, eth1, ppp0, tr0 и пр.</p>

<p>Этот скрипт не содержит каких-либо настроек,
специфичных для DHCP, PPPoE, поэтому эти разделы не заполнены.
Тоже самое касается и других &quot;пустых&quot; разделов.
Это сделано преднамеренно, чтобы Вы могли более
наглядно видеть разницу между скриптами. Если Вам потребуется
заполнить эти разделы, можете взять их из других скриптов или
написать свой собственный.</p>

<p>Раздел <em class="EMPHASIS">Local Area Network</em> должен содержать
настройки, соответствующие конфигурации локальной сети. Вы должны указать
локальный IP-адрес брандмауэра, интерфейс, подключенный к локальной сети,
маску подсети и широковещательный адрес.</p>

<p>Далее следует секция Localhost Configuration, которую изменять Вам
едва ли придется. В этой секции указывается локальный интерфейс lo и
локальный IP-адрес 127.0.0.1. За разделом Localhost Configuration следует
секция Iptables Configuration. Здесь создается переменная
<strong class="COMMAND">$IPTABLES</strong>, содержащая путь к
файлу iptables (обычно <tt class="FILENAME">/usr/local/sbin/iptables</tt>).
Если Вы устанавливали iptables из исходных модулей, то путь к iptables может
несколько отличаться от приведенного (например,
<tt class="FILENAME">/usr/sbin/iptables</tt>),
однако в большинстве дистрибутивов iptables расположен именно здесь.</p>

<hr><h2 class="SECTION"><a name="INITIALLOADING">
7.2.2. Загрузка дополнительных модулей</a></h2>
<p>В первую очередь командой <strong class="COMMAND">/sbin/depmod -a</strong>
выполняется проверка зависимостей модулей, после чего производится
подгрузка модулей, необходимых для работы скрипта.
Старайтесь в Ваших скриптах загружать только необходимые модули.
Например, по каким-то причинам мы собрали поддержку действий
<strong class="COMMAND">LOG</strong>, <strong class="COMMAND">REJECT</strong>
и <strong class="COMMAND">MASQUERADE</strong> в виде подгружаемых модулей и
теперь собираемся строить правила, использующие эти действия,
тогда соответствующие модули необходимо загрузить командами:</p>
<pre class="SCREEN"><strong class="COMMAND">
/sbin/insmod ipt_LOG
/sbin/insmod ipt_REJECT
/sbin/insmod ipt_MASQUERADE
</strong></pre>

<table class="CAUTION" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/caution.gif" hspace="5"
alt="Caution"></td>
<td align="left" valign="top">
<p>В своих скриптах я принудительно загружаю все необходимые модули,
во избежание отказов. Если происходит ошибка во время загрузки модуля,
то причин может быть множество, но основной причиной является то,
что подгружаемые модули скомпилированы с ядром статически.
За дополнительной информацией обращайтесь к разделу
<a href="problems.htm#MODULEPROBLEMS"><em>Проблемы загрузки модулей</em></a>.
</p></td></tr></table>

<p>В следующей секции приводится ряд модулей, которые не
используются в данном скрипте, но перечислены для примера.
Так модуль <tt class="COMPUTEROUTPUT">ipt_owner</tt>, который может
использоваться для предоставления доступа к сети с Вашей
машины только определенному кругу пользователей,
повышая тем самым уровень безопасности. Информацию по критериям
<tt class="COMPUTEROUTPUT">ipt_owner</tt>, смотрите в разделе
<a href="#OWNERMATCH"><em>Критерий Owner</em></a> главы
<a href="#HOWARULEISBUILT"><em>Как строить правила</em></a>.</p>

<p>Мы можем загрузить дополнительные модули для проверки
состояния пакетов (state matching). Все модули, расширяющие возможности
проверки состояния пакетов, именуются как <em class="EMPHASIS">ip_conntrack_*
</em> и <em class="EMPHASIS">ip_nat_*</em>. С помощью этих модулей
осуществляется трассировка соединений по специфичным протоколам.
Например: протокол FTP является комплексным
протоколом по определению, он передает информацию о
соединении в области данных пакета. Так, если наш локальный
хост передает через брандмауэр, производящий трансляцию
адресов, запрос на соединение с FTP-сервером в Интернет, то
внутри пакета передается локальный IP-адрес хоста.
А поскольку, IP-адреса, зарезервированные для локальных сетей,
считаются ошибочными в Интернет, то сервер не будет знать,
что делать с этим запросом, в результате соединение не будет установлено.
Вспомогательный модуль FTP NAT выполняет все необходимые действия
по преобразованию адресов, поэтому FTP-сервер фактически получит запрос на
соединение от имени нашего внешнего IP-адреса и сможет установить соединение.
Тоже самое происходит при использовании DCC для передачи файлов и чатов.
Установка соединений этого типа требует передачи IP-адреса и порта по
протоколу IRC, который также проходит через трансляцию
сетевых адресов на брандмауэре. Без специального модуля
расширения работоспособность протоколов FTP и IRC
становится весьма сомнительной. Например, Вы можете
принимать файлы через DCC, но не можете отправлять. Это обусловливается тем,
как DCC &quot;запускает&quot; соединение. Вы сообщаете принимающему узлу о
своем желании передать файл, и куда он должен подключиться.
Без вспомогательного модуля DCC соединение выглядит так,
как если бы мы потребовали установление соединения внешнего
приемника с узлом в нашей локальной сети, проще говоря,
такое соединение будет обрушено.
При использовании же вспомогательного модуля все работает прекрасно,
поскольку приемнику передается корректный IP-адрес
для установления соединения.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Если у Вас наблюдаются проблемы с
прохождением mIRC DCC через брандмауэр, но при этом другие
IRC-клиенты работают вполне корректно, прочитайте раздел
<a href="problems.htm#MIRCDCC"><em>Проблемы mIRC DCC</em></a> в приложении
<a href="problems.htm#COMMONPROBLEMS"><em>Общие проблемы и вопросы</em></a>.
</p></td></tr></table>

<p>Дополнительную информацию по модулям conntrack и nat читайте в приложении
<a href="problems.htm#COMMONPROBLEMS"><em>Общие проблемы и вопросы</em></a>.
Также не забывайте о документации, включаемой в пакет iptables.
Чтобы иметь эти дополнительные возможности, Вам потребуется установить
patch-o-matic и пересобрать ядро. Как это сделать, объясняется выше в главе
<a href="#PREPARATIONS"><em>Подготовка</em></a>.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Заметьте, что загружать модули ip_nat_irc и
ip_nat_ftp Вам потребуется только в том случае,
если Вы хотите, чтобы преобразование сетевых
адресов (Network Adress Translation) производилось
корректно с протоколами FTP и IRC. Также Вам потребуется
подгрузить модули ip_conntrack_irc и ip_conntrack_ftp до
загрузки модулей NAT.</p></td></tr></table>

<hr><h2 class="SECTION"><a name="PROCSETUP">7.2.3. Настройка /proc</a></h2>
<p>Здесь мы запускаем пересылку пакетов (IP forwarding), записав единицу в
файл <tt class="FILENAME">/proc/sys/net/ipv4/ip_forward</tt> таким способом:
</p>
<p><strong class="COMMAND">echo &quot;1&quot; &gt;
/proc/sys/net/ipv4/ip_forward</strong></p>

<table class="WARNING" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/warning.gif" hspace="5"
alt="Warning"></td>
<td align="left" valign="top">
<p>Наверное, стоит задуматься над тем, где и когда
включать пересылку (IP forwarding). В этом и в других скриптах
в данном руководстве мы включаем пересылку до того,
как создадим какие-либо правила iptables. От начала работы пересылки
(IP forwarding) до момента, когда будут созданы необходимые правила,
при нашем варианте, может пройти от нескольких миллисекунд до минут,
все зависит от объема работы, выполняемой скриптом и
быстродействия конкретного компьютера.
Понятно, что это дает некоторый промежуток времени, когда злоумышленник может
проникнуть через брандмауэр. Поэтому, в реальной ситуации запускать пересылку
(IP forwarding) следует после создания всего набора правил.
Здесь же я поместил включение пересылки в
начале исключительно в целях удобочитаемости.</p></td></tr></table>

<p>Если Вам необходима поддержка динамического IP
(при использовании <em class="EMPHASIS">SLIP</em>,
<em class="EMPHASIS">PPP</em> или <em class="EMPHASIS">DHCP</em>),
Вы можете раскомментировать строку:</p>
<p><strong class="COMMAND">echo &quot;1&quot; &gt;
/proc/sys/net/ipv4/ip_dynaddr</strong></p>

<p>Если Вам требуется включить любые другие опции, Вы должны обращаться к
соответствующей документации по этим опциям. Хороший и лаконичный документ по
файловой системе /proc поставляется вместе с ядром. Ссылки на другие
документы Вы найдете в приложении <a href="links.htm#OTHERRESOURCES"><em>
Ссылки на другие ресурсы</em></a>.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Скрипт <tt class="FILENAME">rc.firewall.txt
</tt> и все остальные скрипты в данном руководстве содержат небольшую по
размерам секцию не требуемых (non-required) настроек /proc.
Как бы привлекательно не выглядели эти опции, не включайте их,
пока не убедитесь, что достаточно четко представляете себе функции,
которые они выполняют.</p></td></tr></table>

<hr><h2 class="SECTION"><a name="DISPLACEMENT">
7.2.4. Размещение правил по разным цепочкам</a></h2>
<p>Здесь мы поговорим о пользовательских цепочках,
в частности о пользовательских цепочках, определяемых в скрипте
<tt class="FILENAME">rc.firewall.txt</tt>. Мой вариант разделения
правил по дополнительным цепочкам может
оказаться неприемлемым в том или ином конкретном случае.
Я надеюсь, что смогу показать Вам возможные &quot;подводные камни&quot;.
Данный раздел тесно перекликается с главой
<a href="#TRAVERSINGOFTABLES"><em>Порядок прохождения таблиц и цепочек</em>
</a> и совершенно не лишним будет еще раз, хотя бы бегло, просмотреть ее.</p>

<p>Распределив набор правил по пользовательским цепочкам,
я добился экономии процессорного времени без потери уровня
безопасности системы и читабельности скриптов. Вместо того, чтобы пропускать
<em class="EMPHASIS">TCP</em>-пакеты через весь набор правил
(для <em class="EMPHASIS">ICMP</em> и для <em class="EMPHASIS">UDP</em>),
я просто отбираю <em class="EMPHASIS">TCP</em>-пакеты и пропускаю их через
пользовательскую цепочку, предназначенную именно для
<em class="EMPHASIS">TCP</em>-пакетов, что приводит к
уменьшению нагрузки на систему. На следующей картинке
схематично приводится порядок прохождения пакетов через netfilter.
В действительности, эта картинка выглядит несколько ограниченно по
сравнению со схемой, приведенной в главе
<a href="#TRAVERSINGOFTABLES"><em>Порядок прохождения таблиц и цепочек
</em></a>.</p>
<p><img src="images/packet_traverse.jpg"></p>

<p>Основное назначение рисунка: освежить нашу память.
В целом, данный пример основан на предположении, что мы имеем одну локальную
сеть, один брандмауэр (firewall) и единственное подключение к Интернет
с постоянным IP-адресом (в противоположность <em class="EMPHASIS">PPP</em>,
<em class="EMPHASIS">SLIP</em>, <em class="EMPHASIS">DHCP</em> и прочим).
Также предполагается, что доступ к сервисам Интернет идет через
брандмауэр, что мы полностью доверяем нашей локальной сети
и поэтому не собираемся блокировать трафик, исходящий из локальной сети,
однако, Интернет не может считаться доверительной сетью и поэтому необходимо
ограничить возможность доступа в нашу локальную сеть извне.
Мы собираемся исходить из принципа &quot;Все что не разрешено, запрещено&quot;.
Для выполнения последнего ограничения мы устанавливаем
политику по умолчанию <strong class="COMMAND">DROP</strong>.
Тем самым мы отсекаем соединения, которые явно не разрешены.</p>
<p>А теперь давайте рассмотрим как и что нам нужно сделать.</p>

<p><img src="images/packet_traverse_FORWARD.jpg"></p>
<p>Для начала позволим соединения из локальной сети с Интернет. Для этого нам
потребуется выполнить преобразование сетевых адресов
(<em class="EMPHASIS">NAT</em>). Делается это в цепочке
<em class="EMPHASIS">POSTROUTING</em>, которая заполняется последней.
Подразумевается также выполнение некоторой фильтрации в цепочке
<em class="EMPHASIS">FORWARD</em>. Если мы полностью доверяем
нашей локальной сети, пропуская весь трафик в Интернет, то
это еще не означает доверия к Интернет и, следовательно,
необходимо вводить ограничения на доступ к нашим компьютерам извне.
В нашем случае мы допускаем прохождение пакетов в нашу сеть только в
случае уже установленного соединения, либо в случае открытия нового
соединения, но в рамках уже существующего (ESTABLISHED и RELATED).</p>
<p><img src="images/packet_traverse_INPUT.jpg"></p>

<p>Что касается машины-брандмауэра, необходимо до минимума свести сервисы,
работающие с Интернет. Следовательно, мы допускаем только
<em class="EMPHASIS">HTTP</em>, <em class="EMPHASIS">FTP</em>,
<em class="EMPHASIS">SSH</em> и <em class="EMPHASIS">IDENTD</em>-доступ к
брандмауэру. Все эти протоколы мы будем считать допустимыми в цепочке
<em class="EMPHASIS">INPUT</em>, соответственно, нам необходимо
разрешить &quot;ответный&quot; трафик в цепочке
<em class="EMPHASIS">OUTPUT</em>. Поскольку мы предполагаем
доверительные взаимоотношения с локальной сетью, то мы добавляем правила для
диапазона адресов локальной сети, а заодно и для локального сетевого
интерфейса и локального IP-адреса (127.0.0.1). Как уже упоминалось выше,
существует ряд диапазонов адресов, выделенных специально для локальных сетей,
эти адреса считаются в Интернет ошибочными и как правило не обслуживаются.
Поэтому и мы запретим любой трафик из Интернет с исходящим адресом,
принадлежащим диапазонам локальных сетей. И в заключение прочитайте главу
<a href="problems.htm#COMMONPROBLEMS"><em>Общие проблемы и вопросы</em></a>.
</p>

<p>Так как у нас работает <em class="EMPHASIS">FTP</em>-сервер, то правила,
обслуживающие соединения с этим сервером, желательно было бы поместить в
начало цепочки <em class="EMPHASIS">INPUT</em>, добиваясь тем самым
уменьшения нагрузки на систему. В целом же надо понимать,
что чем меньше правил проходит пакет, тем больше экономия
процессорного времени, тем ниже нагрузка на систему.
С этой целью я разбил набор правил на дополнительные цепочки.</p>

<p>В нашем примере я разбил пакеты на группы по их
принадлежности к тому или иному протоколу. Для каждого типа
протокола создана своя цепочка правил, например,
<em class="EMPHASIS">tcp_packets</em>, которая содержит правила для проверки
всех допустимых <em class="EMPHASIS">TCP</em>-портов и протоколов.
Для проведения дополнительной проверки пакетов, прошедших через
одну цепочку, может быть создана другая. В нашем случае таковой является
цепочка <em class="EMPHASIS">allowed</em>. В этой цепочке производится
дополнительная проверка отдельных характеристик
<em class="EMPHASIS">TCP</em>-пакетов перед тем, как принять
окончательное решение о пропуске.
<em class="EMPHASIS">ICMP</em>-пакеты следуют через цепочку
<em class="EMPHASIS">icmp_packets</em>. Здесь мы просто
пропускаем все <em class="EMPHASIS">ICMP</em>-пакеты с
указанным кодом сообщения. И наконец <em class="EMPHASIS">UDP</em>-пакеты.
Они проходят через цепочку <em class="EMPHASIS">udp_packets</em>,
которая обрабатывает входящие <em class="EMPHASIS">UDP</em>-пакеты.
Если они принадлежат допустимым сервисам, то они пропускаются без
проведения дополнительной проверки.</p>

<p>Поскольку мы рассматриваем сравнительно небольшую сеть,
то наш брандмауэр используется еще и в качестве рабочей станции,
поэтому мы делаем возможным соединение с Интернет
и с самого брандмауэра.</p>

<p><img src="images/packet_traverse_OUTPUT.jpg"></p>
<p>И в завершение о цепочке <em class="EMPHASIS">OUTPUT</em>. Мы не выполняем
каких-либо специфичных блокировок для пользователей, однако мы не хотим,
чтобы кто-либо, используя наш брандмауэр выдавал в сеть
&quot;поддельные&quot; пакеты, поэтому мы устанавливаем правила,
позволяющие прохождение пакетов только с нашим адресом в локальной сети,
с нашим локальным адресом (127.0.0.1) и с нашим адресом в Интернет.
С этих адресов пакеты пропускаются цепочкой <em class="EMPHASIS">OUTPUT</em>,
все остальные (скорее всего, сфальсифицированные) отсекаются политикой
по умолчанию <em class="EMPHASIS">DROP</em>.</p>

<hr><h2 class="SECTION"><a name="DEFAULTPOLICIES">
7.2.5. Установка политик по умолчанию</a></h2>
<p>Прежде чем приступить к созданию набора правил,
необходимо определиться с политиками цепочек по умолчанию.
Политика по умолчанию устанавливается командой, подобной приводимой ниже</p>
<p><strong class="COMMAND">iptables</strong> [-P {chain} {policy}]</p>

<p>Политика по умолчанию представляет собой действие,
которое применяется к пакету, не попавшему под действие ни
одного из правил в цепочке.</p>

<table class="CAUTION" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/caution.gif" hspace="5"
alt="Caution"></td>
<td align="left" valign="top"><p>Будьте предельно осторожны с установкой
политик по умолчанию для цепочек из таблиц, не предназначенных для
фильтрации, так как это может приводить к довольно странным результатам.</p>
</td></tr></table>

<hr><h2 class="SECTION"><a name="SETTINGUPUSER">
7.2.6. Создание пользовательских цепочек в таблице filter</a></h2>
<p>Итак, у Вас перед глазами наверняка уже стоит картинка
движения пакетов через различные цепочки и то, как эти цепочки
взаимодействуют между собой! Вы уже должны ясно
представлять себе цели и назначение данного скрипта.
Давайте начнем создавать цепочки и наборы правил для них.</p>

<p>Прежде всего необходимо создать дополнительные цепочки с
помощью команды <strong class="COMMAND">-N</strong>. Сразу после создания
цепочки еще не имеют ни одного правила. В нашем примере создаются цепочки
<em class="EMPHASIS">icmp_packets</em>,
<em class="EMPHASIS">tcp_packets</em>, <em class="EMPHASIS">udp_packets</em>
и цепочка <em class="EMPHASIS">allowed</em>, которая вызывается из
цепочки <em class="EMPHASIS">tcp_packets</em>. Входящие пакеты с интерфейса
<strong class="COMMAND">$INET_IFACE</strong> (из Интернет)
по протоколу <em class="EMPHASIS">ICMP</em> перенаправляются в цепочку
<em class="EMPHASIS">icmp_packets</em>, пакеты протокола TCP
перенаправляются в цепочку <em class="EMPHASIS">tcp_packets</em>
и входящие пакеты <em class="EMPHASIS">UDP</em> с интерфейса eth0 идут в
цепочку <em class="EMPHASIS">udp_packets</em>. Более подробное описание Вы
найдете в разделе <a href="#INPUTCHAIN"><em>Цепочка INPUT</em></a>.
Синтаксис команды для создания своей цепочки очень прост:</p>
<p><strong class="COMMAND">iptables</strong> [-N <tt class="REPLACEABLE"><em>chain</em></tt>]</p>

<hr><h3 class="SECTION"><a name="BADTCPPACKETS">
7.2.6.1. Цепочка bad_tcp_packets</a></h3>
<p>Эта цепочка предназначена для отфильтровывания пакетов
с &quot;неправильными&quot; заголовками и решения ряда других проблем.
Здесь отфильтровываются все пакеты, которые распознаются как
<strong class="COMMAND">NEW</strong>, но не являются
<strong class="COMMAND">SYN</strong>-пакетами, а также обрабатываются
<span class="SYSTEMITEM">SYN</span>/<span class="SYSTEMITEM">
ACK</span>-пакеты, имеющие статус <span class="SYSTEMITEM">NEW</span>.
Эта цепочка может быть использована для защиты от
вторжения и сканирования портов. Сюда также добавлено правило для отсеивания
пакетов со статусом <strong class="COMMAND">INVALID</strong>.</p>

<p>Если Вы пожелаете почитать более подробно об этой проблеме,
то смотрите раздел <a href="problems.htm#NEWNOTSYN"><em>Пакеты со статусом
NEW и со сброшенным битом SYN</em></a> в приложении
<a href="problems.htm#COMMONPROBLEMS"><em>
Общие проблемы и вопросы</em></a>. Разумеется, не всегда справедливо будет
просто сбрасывать пакеты с признаком <strong class="COMMAND">NEW</strong> и
сброшенным битом <strong class="COMMAND">SYN</strong>,
но в 99% случаев это оправданный шаг. Поэтому мой скрипт заносит информацию
о таких пакетах в системный журнал, а затем сбрасывает их.</p>

<p>Причина, по которой для SYN/ACK-пакетов со статусом
NEW применяется действие <span class="SYSTEMITEM">REJECT</span>,
достаточно проста. Она описывается в разделе
<a href="problems.htm#SYNACKANDNEW"><em>SYN/ACK-пакеты и пакеты
со статусом NEW</em></a> приложения <a href="problems.htm#COMMONPROBLEMS">
<em>Общие проблемы и вопросы</em></a>.
Общепринятой считается необходимость отправления пакета RST в подобных
случаях (RST в ответ на незапрошенный SYN/ACK). Тем самым мы предотвращаем
возможность атаки &quot;Предсказание номера TCP-последовательности&quot;
(Sequence Number Prediction) на другие узлы сети.</p>

<hr><h3 class="SECTION"><a name="ALLOWEDCHAIN">7.2.6.2. Цепочка allowed</a>
</h3>
<p>TCP-пакет, следуя с интерфейса <strong class="COMMAND">$INET_IFACE
</strong>, попадает в цепочку <em class="EMPHASIS">tcp_packets</em>,
если пакет следует на разрешенный порт, то после этого проводится
дополнительная проверка в цепочке <em class="EMPHASIS">allowed</em>.</p>

<p>Первое правило проверяет, является ли пакет
<em class="EMPHASIS">SYN</em>-пакетом, то есть запросом на соединение.
Такой пакет мы считаем допустимым и пропускаем. Следующее правило пропускает
все пакеты с признаком <em class="EMPHASIS">ESTABLISHED</em> или
<em class="EMPHASIS">RELATED</em>. Когда соединение устанавливается
<em class="EMPHASIS">SYN</em>-пакетом, и на этот запрос был
отправлен положительный ответ, то оно получает статус
<em class="EMPHASIS">ESTABLISHED</em>. Последним правилом в этой цепочке
сбрасываются все остальные TCP-пакеты. Под это правило попадают пакеты из
несуществующего соединения, пакеты со сброшенным битом
<em class="EMPHASIS">SYN</em>, которые пытаются запустить соединение.
Не <em class="EMPHASIS">SYN</em>-пакеты практически не используются для
запуска соединения, за исключением случаев сканирования портов.
Насколько я знаю, на сегодняшний день нет реализации TCP/IP, которая
поддерживала бы открытие соединения иначе, чем передача
<em class="EMPHASIS">SYN</em>-пакета, поэтому на 99% можно
быть уверенным, что сброшены пакеты, посланные сканером портов.</p>

<hr><h3 class="SECTION"><a name="TCPCHAIN">7.2.6.3. Цепочка для TCP</a></h3>
<p>Итак, мы подошли к TCP-соединениям. Здесь мы указываем, какие порты могут
быть доступны из Internet. Несмотря на то, что даже если пакет прошел
проверку здесь, мы все равно все пакеты передаем в цепочку
<em class="EMPHASIS">allowed</em> для дополнительной проверки.</p>

<p>Я открыл TCP порт с номером 21, который является портом управления
FTP-соединениями, и далее я разрешаю все
<strong class="COMMAND">RELATED</strong>-соединения, разрешая,
тем самым, PASSIVE FTP, при условии, что был загружен модуль
<strong class="COMMAND">ip_conntrack_ftp</strong>. Если Вам потребуется
запретить FTP-соединения, то потребуется выгрузить модуль
<strong class="COMMAND">ip_conntrack_ftp</strong> и удалить строку
<strong class="COMMAND">$IPTABLES -A tcp_packets -p TCP -s 0/0
--dport 21 -j allowed</strong> из <tt class="FILENAME">rc.firewall.txt</tt>.
</p>

<p>Порт 22 это SSH, который намного более безопасен, чем telnet на 23 порту.
Если Вам вздумается предоставить доступ к командной оболочке (shell) кому бы
то ни было из Интернет, то лучше, конечно, пользоваться SSH. Однако,
хочу заметить, что вообще-то считается дурным тоном
предоставлять доступ к брандмауэру любому, кроме Вас самих.
Ваш сетевой экран должен иметь только те сервисы,
которые действительно необходимы и не более того.</p>

<p>Порт 80 это порт HTTP, другими словами, web-сервер,
уберите это правило, если у Вас нет web-сервера.</p>
<p>И наконец порт 113, ответственный за службу IDENTD и
использующийся некоторыми протоколами типа IRC и пр.
Замечу, что Вам следует использовать пакет
<strong class="COMMAND">oidentd</strong>, если Вы делаете
трансляцию сетевых адресов для некоторых узлов (хостов) в локальной сети.
<strong class="COMMAND">oidentd</strong> поддерживает передачу
<em class="EMPHASIS">IDENTD</em>-запросов в локальной сети.</p>

<p>Если у Вас имеется необходимость открыть дополнительные порты,
то просто скопируйте одно из правил в цепочке
<em class="EMPHASIS">tcp_packets</em> и подправьте номера
портов в соответствии с Вашими требованиями.</p>

<hr><h3 class="SECTION"><a name="UDPPACKETSCHAIN">7.2.6.4. Цепочка для UDP
</a></h3>
<p>Пакеты <em class="EMPHASIS">UDP</em> из цепочки
<em class="EMPHASIS">INPUT</em> следуют в цепочку
<em class="EMPHASIS">udp_packets</em> Как и в случае с
<em class="EMPHASIS">TCP</em>-пакетами, здесь они проверяются на допустимость
по номеру порта назначения. Обратите вниманиея: мы не проверяем исходящий
порт пакета, поскольку об этом заботится механизм определения состояния.
Открываются только те порты, которые обслуживаются серверами или демонами
на нашем брандмауэре. Пакеты, которые поступают на брандмауэр по
уже установленным соединениям (установленным из локальной сети),
пропускаются брандмауэром автоматически, поскольку имеют состояние
<em class="EMPHASIS">ESTABLISHED</em> или <em class="EMPHASIS">RELATED</em>.
</p>

<p>Как видно из текста скрипта, порт 53, на котором сидит DNS,
для UDP-пакетов закрыт, то есть правило, открывающее 53-й порт,
присутствует, но закомментировано. Если Вы пожелаете запустить
DNS на брандмауэре, то это правило следует раскомментировать.</p>

<p>Я лично разрешаю порт 123, на котором работает NTP
(network time protocol). Этой службой обычно пользуются
для приема точного времени с серверов времени в Интернет.
Однако, вероятнее всего, что Вы не используете этот протокол,
поэтому соответствующее правило также закомментировано.</p>

<p>Порт 2074 используется некоторыми мультимедийными приложениями,
подобно <em class="EMPHASIS">speak freely</em>, которые используются для
передачи голоса в режиме реального времени.</p>

<p>И наконец ICQ на порту 4000. Это широко известный протокол,
используемый ICQ-приложениями. Я полагаю, не следует объяснять
Вам, что это такое.</p>

<p>Кроме того, приведены еще два правила, которые по умолчанию
закомментированы. Ими можно воспользоваться, если брандмауэр чрезмерно
нагружен. Первое блокирует широковещательные пакеты, поступающие на порты со
135 по 139. Эти порты используются протоколами <em class="EMPHASIS">SMB</em>
и <em class="EMPHASIS">NetBIOS</em> от Microsoft. Таким образом, данное
правило предотвращает переполнение таблицы трассировщика в сетях Microsoft
Network. Второе правило блокирует <em class="EMPHASIS">DHCP</em>-запросы
извне. Это правило определенно имеет смысл, если внешняя сеть содержит
некоммутируемые сегменты, где IP-адреса выделяются клиентам динамически.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5"
 alt="Note"></td>
<td align="left" valign="top"><p>Последние два правила не являются
обязательными (в тексте скрипта они закомментированы). Все пакеты, которые не
были отвергнуты или приняты явно, логируются в журнал последним правилом в
цепочке <em class="EMPHASIS">INPUT</em>, поэтому, если Вас беспокоит проблема
&quot;раздувания&quot; системного журнала,
можете раскомментировать эти правила.</p></td></tr></table>

<hr><h3 class="SECTION"><a name="ICMPCHAIN">7.2.6.5. Цепочка для ICMP</a>
</h3>
<p>Здесь принимается решение о пропуске
<em class="EMPHASIS">ICMP</em>-пакетов. Если пакет приходит
с eth0 в цепочку <em class="EMPHASIS">INPUT</em>, то далее он
перенаправляется в цепочку <em class="EMPHASIS">icmp_packets</em>.
В этой цепочке проверяется тип <em class="EMPHASIS">ICMP</em>-сообщения.
Пропускаются только <em class="EMPHASIS">ICMP Echo Request</em>,
<em class="EMPHASIS">TTL equals 0 during transit</em> и
<em class="EMPHASIS">TTL equals 0 during reassembly</em>.
Все остальные типы <em class="EMPHASIS">ICMP</em>-сообщений должны проходить
брандмауэр беспрепятственно, поскольку будут иметь состояние
<em class="EMPHASIS">RELATED</em>.</p>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Если <em class="EMPHASIS">ICMP</em>-пакет
приходит в ответ на наш запрос, то он приобретает статус
<em class="EMPHASIS">RELATED</em> (связанный с имеющимся соединением).
Более подробно состояние пакетов рассматривается в главе
<a href="#STATEMACHINE"><em>Механизм определения состояний</em></a>.</p>
</td></tr></table>

<p>При принятии решения я исхожу из следующих соображений:
<em class="EMPHASIS">ICMP Echo Request</em> пакеты посылаются,
главным образом, для проверки доступности хоста. Если удалить это правило,
то наш брандмауэр не будет &quot;откликаться&quot; в ответ на
<em class="EMPHASIS">ICMP Echo Request</em>, что сделает использование
утилиты ping и подобных ей, по отношению к брандмауэру, бесполезными.</p>

<p><em class="EMPHASIS">Time Exceeded</em> (то есть,
<em class="EMPHASIS">TTL equals 0 during transit</em> и
<em class="EMPHASIS">TTL equals 0 during reassembly</em>).
Во время движения пакета по сети, на каждом маршрутизаторе поле
<em class="EMPHASIS">TTL</em> в заголовке пакета уменьшается на 1.
Как только поле <em class="EMPHASIS">TTL</em> станет равным нулю, то
маршрутизатором будет послано сообщение
<em class="EMPHASIS">Time Exceeded</em>. Например, когда Вы выполняете
трассировку (<em class="EMPHASIS">traceroute</em>) какого-либо узла,
то поле <em class="EMPHASIS">TTL</em> устанавливается равным 1,
на первом же маршрутизаторе оно становится равным нулю,
и к Вам приходит сообщение <em class="EMPHASIS">Time Exceeded</em>, далее,
устанавливаем TTL=2, и второй маршрутизатор передает
<em class="EMPHASIS">Time Exceeded</em> и так далее,
пока не получим ответ с самого узла.</p>

<p>Список типов <em class="EMPHASIS">ICMP</em>-сообщений смотрите в
приложении <a href="typeicmp.htm#ICMPTYPES"><em>Типы ICMP</em></a>.
Дополнительную информацию по <em class="EMPHASIS">ICMP</em> Вы можете
получить в следующих документах:</p>

<ul><li><p><a href="links.htm#THEICMP"><em>
The Internet Control Message Protocol</em></a></p></li>
<li><p><a href="links.htm#RFC792"><em>
RFC 792: Internet Control Message Protocol</em></a>.</p></li></ul>

<table class="NOTE" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/note.gif" hspace="5" alt="Note"></td>
<td align="left" valign="top"><p>Будьте внимательны при блокировании
<em class="EMPHASIS">ICMP</em>-пакетов, возможно, я не прав,
блокируя какие-то из них, может оказаться так, что для Вас это неприемлемо.
</p></td></tr></table>

<hr><h2 class="SECTION"><a name="INPUTCHAIN">7.2.7. Цепочка INPUT</a></h2>
<p>Цепочка <em class="EMPHASIS">INPUT</em>, как я уже писал,
для выполнения основной работы использует другие цепочки,
за счет чего снижая нагрузку на сетевой фильтр. Эффект применения такого
варианта организации правил лучше заметен на медленных машинах,
которые в другом случае начинают терять пакеты при высокой нагрузке.
Достигается это разбиением набора правил по некоторому признаку и
выделение их в отдельные цепочки. Тем самым уменьшается количество правил,
которое проходит каждый пакет.</p>

<p>Первым же правилом мы пытаемся отбросить &quot;плохие&quot; пакеты.
За дополнительной информацией обращайтесь к приложению
<a href="#BADTCPPACKETS"><em>Цепочка bad_tcp_packets</em></a>.
В некоторых особенных ситуациях такие пакеты могут считаться допустимыми,
но в 99% случаев лучше их &quot;остановить&quot;. Поэтому такие пакеты
заносятся в системный журнал (логируются) и &quot;сбрасываются&quot;.</p>

<p>Далее следует целая группа правил, которая пропускает весь трафик,
идущий из доверительной сети, которая включает в себя сетевой адаптер,
связанный с локальной сетью и локальный сетевой интерфейс (lo)
и имеющий исходные адреса нашей локальной сети (включая реальный IP-адрес).
Эта группа правил стоит первой по той простой причине, что
локальная сеть генерирует значительно больший трафик, чем трафик из Internet.
Поэтому, при построении своих наборов правил,
всегда старайтесь учитывать объем трафика, указывая первыми те правила,
которые будут обслуживать больший трафик.</p>

<p>Первым в группе, анализирующей трафик, идущий с $INET_IFACE,
стоит правило, пропускающее все пакеты со статусом
<span class="SYSTEMITEM">ESTABLISHED</span> или
<span class="SYSTEMITEM">RELATED</span> (эти пакеты являются
частью уже УСТАНОВЛЕННОГО или СВЯЗАННОГО соединения).
Это правило эквивалентно правилу, стоящему в цепочке allowed.
И в некоторой степени является избыточным, поскольку затем цепочка allowed
вызывается опосредованно через цепочку tcp_packets, однако оно несколько
разгружает сетевой фильтр, поскольку значительная доля трафика пропускается
этим правилом и не проходит всю последовательность до цепочки allowed.</p>

<p>После этого производится анализ трафика, идущего из Internet.
Все пакеты, приходящие в цепочку <em class="EMPHASIS">INPUT</em> с интерфейса
<strong class="COMMAND">$INET_IFACE</strong> распределяются по вложенным
цепочкам, в зависимости от типа протокола. TCP-пакеты передаются в цепочку
<em class="EMPHASIS">tcp_packets</em>, UDP-пакеты отправляются в цепочку
<em class="EMPHASIS">udp_packets</em> и ICMP перенаправляются в цепочку
<em class="EMPHASIS">icmp_packets</em>. Как правило, большую часть трафика
&quot;съедают&quot; TCP-пакеты, потом UDP и меньший объем приходится на долю
ICMP, однако в Вашем конкретном случае это предположение
может оказаться неверным. Очень важно учитывать объем трафика,
проходящего через набор правил. Учет объема трафика абсолютная необходимость.
В случае неоптимального распределения правил, даже машину класса Pentium III
и выше, с сетевой картой 100 Мбит и большим объемом передаваемых
данных по сети, довольно легко можно &quot;поставить на колени&quot;
сравнительно небольшим объемом правил.</p>

<p>Далее следует весьма специфическое правило (по умолчанию закомментировано).
Дело в том, что клиенты Microsoft Network имеют дурную привычку выдавать
огромное количество Multicast (групповых) пакетов в диапазоне адресов
224.0.0.0/8. Поэтому можно использовать данное правило для предотвращения
засорения логов в случае, если с внешней стороны имеется какая-либо
сеть Microsoft Network. Подобную же проблему решают два последних правила
(по умолчанию закомментированы) в цепочке
<em class="EMPHASIS">udp_packets</em>, описанные в
<a href="#UDPPACKETSCHAIN"><em>Цепочка для UDP</em></a>.</p>

<p>Последним правилом, перед тем как ко всем не принятым
явно пакетам в цепочке <em class="EMPHASIS">INPUT</em> будет применена
политика по умолчанию, трафик журналируется на случай необходимости поиска
причин возникающих проблем. При этом мы устанавливаем правилу ограничение
на количество логируемых пакетов: не более 3-х в минуту,
чтобы предотвратить чрезмерное раздувание журнала и кроме того
подобные записи в журнал сопровождаются собственным комментарием (префиксом),
чтобы знать, откуда появились эти записи.</p>

<p>Все что не было явно пропущено в цепочке INPUT, будет подвергнуто действию
<strong class="COMMAND">DROP</strong>, поскольку именно это
действие назначено в качестве политики по умолчанию.
Политики по умолчанию были описаны чуть выше в разделе
<a href="#DEFAULTPOLICIES"><em>Установка политик по умолчанию</em></a>.</p>

<hr><h2 class="SECTION"><a name="FORWARDCHAIN">7.2.8. Цепочка FORWARD</a>
</h2>
<p>Цепочка <em class="EMPHASIS">FORWARD</em> содержит очень
небольшое количество правил. Первое правило напрвляет все TCP-пакеты
на проверку в цепочку <em class="EMPHASIS">bad_tcp_packets</em>,
которая используется также и в цепочке <em class="EMPHASIS">INPUT</em>.
Цепочка <em class="EMPHASIS">bad_tcp_packets</em> сконструирована
таким образом, что может вызываться из других цепочек, невзирая на то,
куда направляется пакет. После проверки TCP-пакетов, как обычно,
мы разрешаем движение пакетов из локальной сети без ограничений.</p>

<p>Далее, пропускается весь трафик из локальной сети без ограничений.
Естественно, нужно пропустить ответные пакеты в локальную сеть,
поэтому следующим правилом мы пропускаем все, что имеет признак ESTABLISHED
или RELATED, то есть мы пропускаем пакеты по соединению,
установленному ИЗ локальной сети.</p>

<p>И в заключение заносим в системный журнал информацию о сброшенных пакетах,
предваряя их префиксом <strong class="COMMAND">&quot;IPT FORWARD packet died:
&quot;</strong>, чтобы потом, в случае поиска ошибок, не перепутать их с
пакетами, сброшенными в цепочке <em class="EMPHASIS">INPUT</em>.</p>

<hr><h2 class="SECTION"><a name="OUTPUTCHAIN">7.2.9. Цепочка OUTPUT</a></h2>
<p>Как я уже упоминал ранее, в моем случае компьютер
используется как брандмауэр и одновременно как рабочая станция.
Поэтому я позволяю покидать мой хост всему, что имеет исходный адрес
<strong class="COMMAND">$LOCALHOST_IP</strong>,
<strong class="COMMAND">$LAN_IP</strong> или
<strong class="COMMAND">$STATIC_IP</strong>. Сделано это для
защиты от трафика, который можно сфальсицировать с моего компьютера,
несмотря на то, что я совершенно уверен во всех, кто имеет к нему доступ.
И в довершение ко всему, я журналирую &quot;сброшенные&quot; пакеты на случай
поиска ошибок или в целях выявления сфальсифицированных пакетов.
Ко всем пакетам, не прошедшим ни одно из правил,
применяется политика по умолчанию <strong class="COMMAND">DROP</strong>.</p>

<hr><h2 class="SECTION"><a name="PREROUTINGCHAIN">
7.2.10. Цепочка PREROUTING таблицы nat</a></h2>
<p>В данном сценарии эта цепочка не имеет ни одного правила
и единственно, почему я привожу ее описание здесь, это еще раз напомнить,
что в данной цепочке выполняется преобразование сетевых адресов (DNAT)
перед тем, как пакеты попадут в цепочку <em class="EMPHASIS">INPUT</em>
или <em class="EMPHASIS">FORWARD</em>.</p>

<table class="CAUTION" width="100%" border="0">
<tr><td width="25" align="center" valign="top">
<img src="images/caution.gif" hspace="5"
alt="Caution"></td>
<td align="left" valign="top"><p>Еще раз хочу напомнить, что эта цепочка не
предназначена ни для какого вида фильтрации, а только для преобразования
адресов, поскольку в эту цепочку попадает только первый пакет из потока.</p>
</td></tr></table>

<hr><h2 class="SECTION"><a name="STARTINGSNAT">
7.2.11. Запуск SNAT и цепочка POSTROUTING</a></h2>
<p>И заключительный раздел настройка <em class="EMPHASIS">SNAT</em>.
По крайней мере для меня. Прежде всего мы добавляем правило в таблицу nat,
в цепочку <em class="EMPHASIS">POSTROUTING</em>, которое производит
преобразование исходных адресов всех пакетов, исходящих с интерфейса,
подключенного к Internet. В скрипте определен ряд переменных,
которые можно использовать для автоматической настройки скрипта.
Кроме того, использование переменных повышает удобочитаемость скриптов.
Ключом <strong class="COMMAND">-t</strong> задается имя таблицы,
в данном случае nat. Команда <strong class="COMMAND">-A</strong>
добавляет (Add) новое правило в цепочку POSTROUTING, критерий
<strong class="COMMAND">-o $INET_IFACE</strong> задает исходящий интерфейс,
и в конце правила задаем действие над пакетом
<strong class="COMMAND">SNAT</strong>. Таким образом, все пакеты,
подошедшие под заданный критерий будут &quot;замаскированы&quot;,
то есть будут выглядеть так, как будто они отправлены с нашего узла.
Не забудьте указать ключ <strong class="COMMAND">--to-source</strong>
с соответствующим IP-адресом для исходящих пакетов</p>

<p>В этом скрипте я использую <strong class="COMMAND">SNAT</strong> вместо
<strong class="COMMAND">MASQUERADE</strong> по ряду причин.
Первая: предполагается, что этот скрипт должен работать на сетевом узле,
который имеет постоянный IP-адрес. Следующая состоит в том, что
<strong class="COMMAND">SNAT</strong> работает быстрее и более эффективно.
Конечно, если Вы не имеете постоянного IP-адреса, то должны использовать
действие <strong class="COMMAND">MASQUERADE</strong>, которое предоставляет
более простой способ трансляции адресов, поскольку оно автоматически
определяет IP-адрес, присвоенный заданному интерфейсу.
Однако, по сравнению с <strong class="COMMAND">SNAT</strong>,
это действие требует несколько больших вычислительных ресурсов,
хотя и не значительно. Пример работы с
<strong class="COMMAND">MASQUERADE</strong> Вы найдете в скрипте
<a href="glava08.htm#RCDHCPFIREWALLTXT"><em>rc.DHCP.firewall.txt</em></a>.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</body>
</html>
