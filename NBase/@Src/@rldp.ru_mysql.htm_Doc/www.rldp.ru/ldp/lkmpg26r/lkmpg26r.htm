<html>
<head>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
   <META NAME="Author" CONTENT="Alexey V. Pautov">
   <title>Руководство по разработке модулей для ядра Linux 2.6.</title>
   <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
</head>

<BODY>
<h1><a name="AEN2"></a>Руководство по разработке модулей для ядра Linux 2.6
(The Linux Kernel Module Programming Guide 2.6)</h1>

<h3"AUTHOR"><a name="AEN4"></a>Авторы: Peter Jay Salzman,
Michael Burian, Ori Pomerantz</h3>

<a name="AEN6"></a><p>Copyright 2001, Peter Jay Salzman.</p>
<p>2004-05-16 ver 2.6.0</p>
<p>Перевод: Алексей Паутов в рамках проекта
<a href="../../default.htm">Russian LDP</a>.

<a name="AEN10"></a><p>Оригинальная версия была опубликована на сайте проекта
<a href="../../../www.tldp.org/default.htm">The Linux Documentation Project</a>, откуда и
была мной скачана.</p>

<p>Данная книга распространяется на условиях Open Software License, version
1.1. Полный текст лицензии Вы можете найти по адресу:
<a href="../../../opensource.org/licenses/osl.php">
http://opensource.org/licenses/osl.php</a>.</p>

<p>Эта книга распространяется в надежде на то, что она будет Вам полезна, но
без каких-либо гарантий, в том числе и без подразумеваемых гарантий высокого
спроса или пригодности для любых специфических целей.</p>

<p>Авторы приветствуют широкое распространение этой книги как для
персонального, так и для коммерческого пользования, при условии соблюдения
вышеупомянутого примечания относительно авторских прав, а так же при условии,
что распространитель твердо придерживается условий Open Software License. Вы
можете копировать и распространять эту книгу как бесплатно, так и с целью
получения прибыли. От авторов не требуется никакого явного разрешения для
воспроизводства этой книги на любом носителе, будь то твердая
или электронная копия.</p>

<p>Производные работы и переводы этого документа должны размещаться на
условиях Open Software License, а первоначальное примечание об авторских
правах должно оставаться нетронутым. Если Вы добавили новый материал в книгу,
то следует сделать его общедоступным. Пожалуйста, извещайте руководителя
проекта (Peter Jay Salzman, <a href="mailto:p@dirac.org">p@dirac.org</a>) о
внесенных изменениях и дополнениях. Он объединит модификации и обеспечит
непротиворечивость изменений документа.</p>

<p>Если Вы планируете издавать и распространять эту книгу на коммерческой
основе, пожертвования, лицензионные отчисления и/или печатные копии будут
высоко оценены автором и <a href="../../../www.tldp.org/default.htm">The Linux
Documentation Project</a>. Таким образом Вы окажете поддержку свободному
программному обеспечению и LDP. Если у Вас появятся вопросы или предложения,
пожалуйста, напишите руководителю проекта по адресу, указанному выше.</p>

<dl><dt><strong>Содержание</strong></dt>
<dt><a href="#PREFACE">Предисловие</a></dt>
<dd><dl><dt>1. <a href="#AEN24">Об авторах</a></dt>
<dt>2. <a href="#AEN27">Нумерация версий и дополнительные примечания</a></dt>
<dt>3. <a href="#AEN32">Благодарности</a></dt></dl></dd>
<dt>1. <a href="#CHAPTER1">Введение.</a></dt>
<dd><dl><dt>1.1. <a href="#WHATISAKERNELMODULE">Что такое модуль ядра?</a>
</dt>
<dt>1.2. <a href="#HOWDOMODULESGETINTOTHEKERNEL">Как модули попадают в ядро?
</a></dt>
<dd><dl><dt>1.2.1. <a href="#BEFOREWEBEGIN">Прежде, чем продолжить</a></dt>
</dl></dd></dl></dd>
<dt>2. <a href="#CHAPTER2">Hello World</a></dt>
<dd><dl><dt>2.1. <a href="#HELLOWORLDPART1THESIMPLESTMODULE">"Hello,
World" (часть 1): Простейший модуль ядра.</a></dt>
<dd><dl><dt>2.1.1. <a href="#INTRODUCINGPRINTK">Знакомство с функцией
<tt>printk()</tt></a></dt></dl></dd>
<dt>2.2. <a href="#COMPILINGKERNELMODULES">Сборка модулей ядра</a></dt>
<dt>2.3. <a href="#HELLOWORLDPART2">Hello World (часть 2)</a></dt>
<dt>2.4. <a href="#HELLOWORLDPART3THE__INITAND__EXITMACROS">Hello World
(часть 3): Макроопределения __init и __exit</a></dt>
<dt>2.5. <a href="#HELLOWORLDPART4LICENSINGANDMODULEDOCUMENTATI">Hello World
(часть 4): Вопросы лицензирования и документирования модулей</a></dt>
<dt>2.6. <a href="#PASSINGCOMMANDLINEARGUMENTSTOAMODULE">Передача модулю
параметров командной строки</a></dt>
<dt>2.7. <a href="#MODULESSPANNINGMULTIPLEFILES">Модули состоящие
из нескольких файлов</a></dt>
<dt>2.8. <a href="#BUILDINGMODULESFORAPRECOMPILEDKERNEL">Сборка модулей под
существующее ядро</a></dt></dl></dd>
<dt>3. <a href="#CHAPTER3">Дополнительные сведения</a></dt>
<dd><dl><dt>3.1. <a href="#MODULESVSPROGRAMS">
Модули ядра и прикладные программы</a></dt>
<dt>3.2. <a href="#FUNCTIONSAVAILABLETOMODULES">Функции, которые доступны
из модулей ядра</a></dt>
<dt>3.3. <a href="#USERSPACEVSKERNELSPACE">Пространство пользователя и
пространство ядра</a></dt>
<dt>3.4. <a href="#NAMESPACE">Пространство имен</a></dt>
<dt>3.5. <a href="#CODESPACE">Адресное пространство</a></dt>
<dt>3.6. <a href="#DEVICEDRIVERS">Драйверы устройств</a></dt>
<dd><dl><dt>3.6.1. <a href="#MAJORANDMINORNUMBERS">Старший и младший номера
устройства</a></dt></dl></dd></dl></dd>
<dt>4. <a href="#CHAPTER4">Файлы символьных устройств</a></dt>
<dd><dl><dt>4.1. <a href="#THEFILE_OPERATIONSSTRUCTURE">Структура
<tt>file_operations</tt></a></dt>
<dt>4.2. <a href="#THEFILESTRUCTURE">Структура <tt>file</tt></a></dt>
<dt>4.3. <a href="#REGISTERINGADEVICE">Регистрация устройства</a></dt>
<dt>4.4. <a href="#UNREGISTERINGADEVICE">Отключение устройства</a></dt>
<dt>4.5. <a href="#CHARDEV">chardev.c</a></dt>
<dt>4.6. <a href="#WRITINGMODULESFORMULTIPLEKERNELVERSIONS">Создание модулей
для работы с разными версиями ядра</a></dt></dl></dd>
<dt>5. <a href="#CHAPTER5">Файловая система <tt>/proc</tt></a></dt>
<dd><dl><dt>5.1. <a href="#THEPROCFILESYSTEMFORREAD">Файловая система
<tt>/proc</tt>: создание файлов, доступных для чтения</a></dt>
<dt>5.2. <a href="#USINGPROCFORINPUT">Файловая система <tt>/proc</tt>:
создание файлов, доступных для записи</a></dt></dl></dd>
<dt>6. <a href="#CHAPTER6">Работа с файлами устройств</a></dt>
<dt>7. <a href="#CHAPTER7">Системные вызовы</a></dt>
<dt>8. <a href="#CHAPTER8">Блокировка процессов</a></dt>
<dt>9. <a href="#CHAPTER9">Замена <tt>printk</tt></a></dt>
<dd><dl><dt>9.1. <a href="#REPLACINGPRINTKS">Замена <tt>printk</tt></a></dt>
<dt>9.2. <a href="#FLASHINGKEYBOARDLEDS">Управление индикаторами на клавиатуре
</a></dt></dl></dd>
<dt>10. <a href="#CHAPTER10">Планирование задач</a></dt>
<dt>11. <a href="#CHAPTER11">Обработка прерываний</a></dt>
<dd><dl><dt>11.1. <a href="#INTERRUPTHANDLERS">Обработка прерываний</a></dt>
<dt>11.2. <a href="#KEYBOARDSONTHEINTELARCHITECTURE">Клавиатура на
архитектуре Intel</a></dt></dl></dd>
<dt>12. <a href="#CHAPTER12">Симметричная многопроцессорность</a></dt>
<dt>13. <a href="#CHAPTER13">Заключение</a></dt></dl>

<dl><dt><strong>Перечень примеров</strong></dt>
<dt>2-1. <a href="#HELLO1">hello-1.c</a></dt>
<dt>2-2. <a href="#MAKEFILEFORABASICKERNELMODULE">Makefile для модуля ядра
</a></dt>
<dt>2-3. <a href="#HELLO2">hello-2.c</a></dt>
<dt>2-4. <a href="#MAKEFILEFORBOTHOURMODULES">Makefile для сборки
обоих модулей</a></dt>
<dt>2-5. <a href="#HELLO3">hello-3.c</a></dt>
<dt>2-6. <a href="#HELLO4">hello-4.c</a></dt>
<dt>2-7. <a href="#HELLO5">hello-5.c</a></dt>
<dt>2-8. <a href="#START">start.c</a></dt>
<dt>2-9. <a href="#STOP">stop.c</a></dt>
<dt>2-10. <a href="#MAKEFILEFORALLOURMODULES">Makefile для сборки
всех модулей</a></dt>
<dt>4-1. <a href="#CHARDEVC">chardev.c</a></dt>
<dt>4-2. <a href="#MAKEFILEFORCHARDEVC">Makefile</a></dt>
<dt>5-1. <a href="#PROCFSC">procfs.c</a></dt>
<dt>5-2. <a href="#MAKEFILEFORPROCFSC">Makefile</a></dt>
<dt>5-3. <a href="#PROCFSC2">procfs.c</a></dt>
<dt>6-1. <a href="#AEN668">chardev.c</a></dt>
<dt>6-2. <a href="#AEN671">chardev.h</a></dt>
<dt>6-3. <a href="#AEN674">ioctl.c</a></dt>
<dt>6-4. <a href="#AEN677">Makefile</a></dt>
<dt>6-5. <a href="#AEN681">build.sh</a></dt>
<dt>7-1. <a href="#AEN741">syscall.c</a></dt>
<dt>7-2. <a href="#AEN744">Патч к ядру
(export_sys_call_table_patch_for_linux_2.6.x)</a></dt>
<dt>7-3. <a href="#AEN747">Makefile</a></dt>
<dt>7-4. <a href="#AEN750">README.txt</a></dt>
<dt>8-1. <a href="#AEN781">sleep.c</a></dt>
<dt>9-1. <a href="#AEN800">print_string.c</a></dt>
<dt>9-2. <a href="#AEN807">kbleds.c</a></dt>
<dt>10-1. <a href="#AEN831">sched.c</a></dt>
<dt>11-1. <a href="#AEN867">intrpt.c</a></dt></dl>

<hr><h1><a name="PREFACE"></a>Предисловие</h1>
<h1><a name="AEN24"></a>1. Об авторах</h1>
<p>Эта книга изначально была написана Ори Померанцем (Ori Pomerantz) для ядра
Linux версии 2.2. К сожалению, у Ори не хватает времени на продолжение работы
над этой книгой. Ядро Linux продолжает быстро развиваться. Питер Зальцман
(Peter Jay Salzman) взял на себя труд по адаптации документа для ядра версии
2.4. К сожалению, и Питер не нашел достаточно свободного времени, чтобы
продолжить работу над книгой и дополнить ее материалами, касающимися ядра
версии 2.6. Таким образом, Майкл Бариан (Michael Burian) взялся за адаптацию
материала книги для ядра 2.6.</p>

<hr><h1><a name="AEN27"></a>2. Нумерация версий и дополнительные примечания
</h1>
<p>Ядро Linux динамически развивающийся проект. Перед авторами книги всегда
остро стоял вопрос: удалять ли устаревшие сведения из книги или сохранять их
как историческую ценность. Майкл и Питер Зальцман решили создавать отдельную
ветвь документа для каждой стабильной серии ядер. Таким образом, LKMPG (Linux
Kernel Module Programming Guide), имеющяя версию 2.4.x относится к ядру
2.4.x, а LKMPG 2.6.x к ядру версии 2.6.x. Решено не сохранять устаревшие
сведения в новых версиях документа. Желающие получить эту информацию должны
обращаться к соответствующим версиям документа.</p>

<p>Исходный код и подаваемый материал не относятся к какой-либо конкретной
аппаратной архитектуре, но ничего нельзя гарантировать. Одно важное
исключение: <a href="#INTERRUPTHANDLERS">Обработка прерываний (Глава 12)</a>,
где весь материал относится к архитектуре x86.</p>

<hr><h1><a name="AEN32"></a>3. Благодарности</h1>
<p>Ори Померанц выражает свою благодарность Yoav Weiss, за многочисленные
предложения, обсуждение материала и внесение исправлений. Он также хотел бы
поблагодарить Фродо Лоойаарда из Нидердандов, Стефана Джадда из Новой
Зеландии, Магнуса Альторпа из Швеции и Эммануэль Папиракис
из Квебека, Канада.</p>

<p>Питер выражает свою благодарность Ори за то, что тот позволил ему принять
участие в проекте LKMPG. А также благодарит Джеффа Ньюмиллера, Ронду Франчес
Бэйли (ныне Ронда Франчес Зальцман) и Марка Кима за науку и долготерпение. Он
также хотел бы поблагодарить Дэвида Портера, который оказал неоценимую помощь
в переводе документа из формата LaTeX в формат docbook. Это была тяжелая и
нудная работа, но ее необходимо было сделать.</p>

<p>Отдельное спасибо всем участникам проекта <a href="www.kernelnewbies.org">
www.kernelnewbies.org</a>, и особенно Марку Маклолину и Джону Левону, которые,
я уверен, могли бы найти много более интересное занятие, нежели висеть на
kernelnewbies.org и обучать новичков. Если это руководство научит Вас
чему-либо, знайте: в этом есть доля и их работы!</p>

<p>Ори и Питер Зальцман хотели бы сказать слова благодарности в адрес Ричарда
М. Столлмана и Линуса Торвальдса не только за эту превосходную операционную
систему, но и за то, что позволили исследовать ее исходный код, чтобы
разобраться в том, как она работает.</p>

<p>Хочется выразить благодарность тем, кто внес свои исправления в документ
или внес свои предложения по улучшению. Это Игнасио Мартин, Дэвид Портер,
Дэниэл Паоло Скарпацца и Димо Велев.</p>

<hr><h1><a name="CHAPTER1"></a>Глава 1. Введение.</h1>
<h1><a name="WHATISAKERNELMODULE"></a>1.1. Что такое модуль ядра?</h1>
<p>Итак, Вы хотите писать модули ядра. Вы знакомы с языком C, у Вас есть
опыт создания обычных программ, а теперь Вы хотите забраться туда, где
свершается великое таинство. Туда, где один ошибочный указатель может снести
файловую систему или подвесить компьютер.</p>

<p>Так что же такое модуль ядра? Модуль представляет собой некий код, который
может быть загружен или выгружен ядром по мере необходимости. Модули
расширяют функциональные возможности ядра без перезагрузки системы. Например,
одна из разновидностей модулей ядра, драйверы устройств, позволяют ядру
взаимодействовать с аппаратурой компьютера. При отсутствии поддержки модулей
пришлось бы писать монолитные ядра и добавлять новые возможности прямо в
ядро. При этом после добавления в ядро новых возможностей пришлось
бы перезагружать систему.</p>

<hr><h1><a name="HOWDOMODULESGETINTOTHEKERNEL"></a>1.2.
Как модули попадают в ядро?</h1>
<p>Вы можете просмотреть список загруженных модулей командой
<strong>lsmod</strong>, которая в свою очередь обращается за необходимыми
сведениями к файлу <tt>/proc/modules</tt>.</p>

<p>Как же модули загружаются ядром? Когда ядро обнаруживает необходимость в
тех или иных функциональных возможностях, еще не загруженных в память, то
демон <strong>kmod</strong> (в ранних версиях ядра он назывался
<strong>kerneld</strong>) вызывает утилиту <strong>modprobe</strong>,
передавая ей строку в виде:
<ul><li>Название модуля, например, <tt>softdog</tt> или <tt>ppp</tt>.</li>
<li>Универсальный идентификатор, например, <tt>char-major-10-30</tt>.</li>
</ul></p>

<p>Если утилите <strong>modprobe</strong> передается <span><em>универсальный
идентификатор</em></span>, то она сначала пытается отыскать имя
соответствующего модуля в файле <tt>/etc/modules.conf</tt>, где каждому
универсальному идентификатору поставлено в соответствие имя модуля, например:
<pre>
alias char-major-10-30 softdog
</pre></p>

<p>Это соответствует утверждению, что данному универсальному
идентификатору соответствует файл модуля <tt>softdog.ko</tt>.</p>
<p>Затем <strong>modprobe</strong> отыскивает файл
<tt>/lib/modules/version/modules.dep</tt>, чтобы проверить не нужно ли
загружать еще какие-либо модули, от которых может зависеть заданный модуль.
Этот файл создается командой <strong>depmod -a</strong> и описывает
зависимости модулей. Например, модуль <tt>msdos.ko</tt> требует, чтобы
предварительно был загружен модуль <tt>fat.ko</tt>. Если модуль
<strong>Б</strong> экспортирует ряд имен (имена функций, переменных и т.п.),
которые используются модулем <strong>А</strong>, то говорят, что модуль
<strong>А</strong> зависит от модуля <strong>Б</strong>.</p>

<p>Наконец <strong>modprobe</strong> вызывает <strong>insmod</strong>, чтобы
сначала загрузить необходимые для удовлетворения зависимостей модули, а затем
запрошенный модуль. Вызывая <strong>insmod</strong>, утилита
<strong>modprobe</strong> указывает ей каталог
<tt>/lib/modules/version</tt> (стандартный путь к модулям ядра). Если Вы
предполагаете проводить эксперименты с ядром, то чтобы избежать перезаписи
существующих файлов модулей Вы можете изменить значение переменной
<tt>EXTRAVERSION</tt> в файле <tt>Makefile</tt> ядра. В результате все модули
ядра будут записываться в отдельный каталог. Утилита <strong>insmod</strong>
ничего не знает о размещении модулей ядра, зато это знает утилита
<strong>modprobe</strong>. Таким образом, если необходимо загрузить модуль
<tt>msdos</tt>, необходимо дать следующие команды:
<pre>
insmod /lib/modules/2.6.0/kernel/fs/fat/fat.ko
insmod /lib/modules/2.6.0/kernel/fs/msdos/msdos.ko
</pre></p>

<p>Или еще проще:
<pre>
modprobe -a msdos
</pre></p>

<p>В большинстве дистрибутивов Linux утилиты <strong>modprobe</strong>,
<strong>insmod</strong> и <strong>depmod</strong> входят в состав пакета
<strong>modutils</strong> или <strong>mod-utils</strong>.</p>

<p>Прежде чем закончить эту главу, я предлагаю вкратце
ознакомиться с содержимым файла <tt>/etc/modules.conf</tt>:
<pre>
### This file is automatically generated by modules-update
#
# Please do not edit this file directly. If you want to change or add
# anything please take a look at the files in /etc/modules.d and read
# the manpage for modules-update.
#
### modules-update: start processing /etc/modules.d/aliases
# Aliases to tell insmod/modprobe which modules to use
path[misc]=/lib/modules/2.6.?/local
keep
path[net]=~p/mymodules
options mydriver irq=10
alias eth0 eepro
</pre></p>

<p>Строки, начинающиеся с символа #, являются комментариями. Пустые строки
игнорируются. Строка <tt>path[misc]</tt> сообщает <strong>modprobe</strong> о
том, что модули ядра из категории <tt>misc</tt> следует искать в каталоге
<tt>/lib/modules/2.6.?/local</tt>. Как видите, здесь вполне
допустимы шаблонные символы.</p>

<p>Строка <tt>path[net]</tt> задает каталог размещения модулей категории
<tt>net</tt>, однако, директива <strong>keep</strong>, стоящая выше,
сообщает, что каталог <tt>~p/mymodules</tt> не замещает стандартный путь
поиска модулей (как это происходит в случае с <tt>path[misc]</tt>), а всего
лишь добавляется к нему.</p>

<p>Строка <tt>alias</tt> говорит о том, что если запрошена загрузка модуля по
универсальному идентификатору <tt>eth0</tt>, то следует загружать
модуль <tt>eepro.ko</tt></p>

<p>Вы едва ли встретите в этом файле строки, подобные:
<pre>
alias block-major-2 floppy
</pre>
поскольку <strong>modprobe</strong> уже знает о существовании стандартных
драйверов устройств, которые используются в большинстве систем.</p>

<hr><h2><a name="BEFOREWEBEGIN"></a>1.2.1. Прежде, чем продолжить</h2>
<p>Прежде, чем мы приступим к программированию, необходимо обсудить еще ряд
моментов. Любая система имеет свои отличительные черты, и каждый из нас имеет
разный багаж знаний. Написать, скомпилировать и запустить свою первую
программу "Hello World!" для многих может оказаться довольно сложной задачей.
Однако, после преодоления этого начального препятствия, работа, как правило,
продвигается без особых проблем.</p>

<hr><h3><a name="MODVERSIONING"></a>1.2.1.1. Механизм контроля версий</h3>
<p>Модули, скомпилированные с одним ядром, могут не загружаться другим ядром,
если в ядре включен механизм проверки версий модулей. В большинстве
дистрибутивов ядро собирается с такой поддержкой. Я не собираюсь обсуждать
проблему контроля версий в этой книге, поэтому нам остается порекомендовать в
случае возникновения проблем пересобрать ядро без механизма контроля версий.
</p>

<hr><h3><a name="USINGX"></a>1.2.1.2. Работа в X Window</h3>
<p>Я настоятельно рекомендую скачать и опробовать все примеры, обсуждаемые в
книге. Кроме того, я настаиваю на том, чтобы всю работу, связанную с
редактированием исходных текстов, компиляцией и запуском модулей, Вы
выполняли из текстовой консоли. Поверьте моему опыту, X Window не подходит
для выполнения подобных задач.</p>

<p>Модули не могут использовать функцию <tt>printf()</tt> для вывода на
экран, но они могут регистрировать сообщения об ошибках, которые в конечном
итоге попадают на экран, но только в текстовой консоли. Если же модуль
загружается из окна терминала, например, в <tt>xterm</tt>, то эти сообщения
будут попадать только в системный журнал и не будут выводиться на экран.
Чтобы видеть выводимые сообщения на экране, работайте в текстовой консоли.
Если же сообщения так и не появляются, ищите их в системном журнале, в моем
случае это файл <tt>/var/log/kern.log</tt></em></span>.</p>

<hr><h3><a name="COMPILINGISSUESANDKERNELVERSION"></a>1.2.1.3. Проблемы
компиляции</h3>
<p>Зачастую авторы дистрибутив распространяют исходные тексты ядра, на
которые уже наложены нестандартные патчи. Это может породить определенные
проблемы. Не менее частый случай: неполный набор заголовочных файлов ядра.
Для сборки своих модулей потребуются многие заголовочные файлы ядра Linux. А
закон Мэрфи гласит, что отсутствовать будут как раз те файлы, в которых Вы
больше всего нуждаетесь.</p>

<p>Чтобы избежать этих двух проблем, рекомендуется собрать и установить
наиболее свежее ядро. Скачать исходные тексты ядра Вы можете на любом из
зеркал, распространяющих ядро Linux. За более подробной информацией
обращайтесь к "Kernel HOWTO".</p>

<p>Как это ни покажется странным, но проблемы могут крыться и в компиляторе.
По умолчанию <tt>gcc</tt> может искать заголовочные файлы ядра совсем не там,
куда Вы их установили (как правило, это каталог <tt>/usr/src</tt>). Эта
проблема легко преодолевается заданием ключа компиляции <strong>-I</strong>.
</p>

<hr><h1><a name="CHAPTER2"></a>Глава 2. Hello World</h1>
<h1><a name="HELLOWORLDPART1THESIMPLESTMODULE"></a>2.1. "Hello,
World" (часть 1): Простейший модуль ядра</h1>
<p>Мы начнем с серии программ "Hello world", на которых разберем различные
базовые аспекты создания модулей ядра.</p>

<p>Ниже приводится исходный текст самого простого модуля ядра, какой только
вообще возможен в принципе. Пока только ознакомьтесь с его содержимым, а
компиляцию и запуск модуля обсудим в следующем разделе.</p>

<a name="HELLO1"></a><p><strong>Пример 2-1. hello-1.c</strong></p>
<pre>
/*
 *  hello-1.c - Простейший модуль ядра.
 */
#include &lt;linux/module.h>       /* Необходим для любого модуля ядра */
#include &lt;linux/kernel.h>       /* Здесь находится определение KERN_ALERT */

int init_module(void)
{
  printk("&lt;1>Hello world 1.\n");
  /*
   * Если вернуть ненулевое значение, то это будет воспринято как
   * признак ошибки, возникшей в процессе работы init_module, в
   * результате модуль не будет загружен.
   */
  return 0;
}

void cleanup_module(void)
{
  printk(KERN_ALERT "Goodbye world 1.\n");
}
</pre>

<p>Любой модуль ядра должен иметь по меньшей мере две функции: функцию
инициализации модуля (<tt>init_module()</tt>), которую вызывает
<strong>insmod</strong> во время загрузки модуля, и функцию завершения работы
модуля (<tt>cleanup_module()</tt>), которую вызывает <strong>rmmod</strong>.
Начиная с ядра версии 2.3.13, требования к именованию начальной и конечной
функций были сняты. Теперь Вы можете давать им свои имена. Как это сделать
будет описано в разделе <a href="#HELLOWORLDPART2">Hello World (часть 2)</a>.
Новый метод именования является более предпочтительным, однако многие
по-прежнему продолжают использовать имена <tt>init_module()</tt> и
<tt>cleanup_module()</tt>, что вроде никому не мешает.</p>

<p>Обычно функция <tt>init_module()</tt> выполняет регистрацию обработчика
какого-либо события или замещает какую-либо функцию в ядре своим кодом
(который, как правило, выполнив некие специфические действия, вызывает
оригинальную версию функции в ядре). Функция <tt>cleanup_module()</tt>
является полной противоположностью: она производит отмену изменений,
сделанных функцией <tt>init_module()</tt>, что делает
выгрузку модуля безопасной.</p>

<p>Наконец, любой модуль ядра должен подключать заголовочный файл
<tt>linux/module.h</tt>. В нашем примере мы подключали еще один файл
<tt>linux/kernel.h</tt>, но лишь для того, чтобы получить доступ к
определению <tt>KERN_ALERT</tt>, которое более подробно будет обсуждаться в
<a href="#INTRODUCINGPRINTK">следующем разделе</a>.</p>

<hr><h2><a name="INTRODUCINGPRINTK"></a>2.1.1. Знакомство с <tt>printk()</tt>
</h2>
<p>Несмотря на столь красноречивое название, функция <tt>printk()</tt> вовсе
не предназначена для вывода информации на экран, даже несмотря на то, что мы
использовали ее в своем примере именно для этой цели! Основное назначение
этой функции: дать ядру механизм регистрации событий и предупреждений.
Поэтому, каждый вызов <tt>printk()</tt> сопровождается указанием приоритета,
в нашем примере это <tt>&lt;1></tt> и <tt>KERN_ALERT</tt>. Всего в ядре
определено 8 различных уровней приоритета для функции <tt>printk()</tt>, и
каждый из них имеет свое макроопределение, таким образом нет необходимости
писать числа, лишенные смысла (имена уровней приоритета и их числовые
значения Вы найдете в файле <tt>linux/kernel.h</tt>, для этого-то он и был
подключен в примере). Если уровень приоритета не указывается, то по умолчанию
он принимается равным <tt>DEFAULT_MESSAGE_LOGLEVEL</tt>.</p>

<p>Найдите время и просмотрите содержимое этого файла. Здесь Вы найдете
краткое описание значения каждого из уровней. На практике считается дурным
тоном указание уровней приоритета числовым значением, например,
<tt>&lt;4></tt>. Для этих целей лучше пользоваться именами
макроопределений, например, <tt>KERN_WARNING</tt>.</p>

<p>Если задан уровень ниже, чем <tt>int console_loglevel</tt>, то сообщение
выводится на экран. Если запущены <strong>syslog</strong> и
<strong>klogd</strong>, то сообщение попадет также и в системный журнал
<tt>/var/log/messages</tt>, при этом оно может быть выведено на экран, а
может и не выводиться. Мы использовали достаточно высокий уровень приоритета
<tt>KERN_ALERT</tt> для того, чтобы гарантировать вывод сообщения на экран
функцией <tt>printk()</tt>. Когда Вы вплотную займетесь созданием модулей
ядра, Вы будете использовать уровни приоритета наиболее подходящие
под конкретную ситуацию.</p>

<hr><h1><a name="COMPILINGKERNELMODULES"></a>2.2. Сборка модулей ядра</h1>
<p>Чтобы модуль был работоспособен, при компиляции необходимо передать
<strong>gcc</strong> ряд опций. Кроме того, необходимо, чтобы модули
компилировались с предварительно определенными символами. Ранние версии ядра
полностью полагались в этом вопросе на программиста, и ему приходилось явно
указывать требуемые определения в <tt>Makefile</tt>. Несмотря на
иерархическую организацию, в <tt>Makefile</tt> на вложенных уровнях
накапливалось такое огромное количество параметров настройки, что управление
и сопровождение этих настроек стало довольно трудоемким делом. К счастью,
появился <strong>kbuild</strong>, в результате процесс сборки внешних
загружаемых модулей теперь полностью интегрирован в механизм сборки ядра.
Дополнительные сведения по сборке модулей, которые не являются частью
официального ядра (как в нашем случае), Вы найдете в файле
<tt>linux/Documentation/kbuild/modules.txt</tt>.</p>

<p>А теперь попробуем собрать наш с Вами модуль hello-1.c. Соответствующий
<tt>Makefile</tt> содержит всего одну строку:</p>

<a name="MAKEFILEFORABASICKERNELMODULE"></a><p><strong>Пример 2-2. Makefile
для модуля ядра</strong></p>
<pre>
obj-m += hello-1.o
</pre>

<p>Для того, чтобы запустить процесс сборки модуля, дайте команду
<strong>make -C /usr/src/linux-`uname -r` SUBDIRS=$PWD modules</strong>. На
экран будет выведено нечто вроде:
<pre>
[root@pcsenonsrv test_module]# make -C /usr/src/linux-`uname -r` \
                                    SUBDIRS=$PWD modules
make: Entering directory `/usr/src/linux-2.6.x
  CC [M]  /root/test_module/hello-1.o
  Building modules, stage 2.
  MODPOST
  CC      /root/test_module/hello-1.mod.o
  LD [M]  /root/test_module/hello-1.ko
make: Leaving directory `/usr/src/linux-2.6.x
</pre></p>

<p>Обратите внимание: в ядрах версии 2.6 введено новое соглашение по
именованию объектных файлов модулей. Теперь они имеют расширение <tt>.ko</tt>
(взамен прежнего <tt>.o</tt>), что отличает их от обычных объектных файлов.
Дополнительную информацию по оформлению <tt>Makefile</tt> для модулей Вы
найдете в файле <tt>linux/Documentation/kbuild/makefiles.txt</tt>.
Обязательно прочтите этот документ прежде, чем начнете
углубляться в изучение <tt>Makefile</tt>.</p>

<p>Итак, настал торжественный момент: теперь можно загрузить свежесобранный
модуль! Дайте команду <strong>insmod ./hello-1.ko</strong> (появляющиеся
сообщения о загрязнении ядра Вы сейчас можете просто игнорировать, вскоре мы
обсудим и эту проблему).</p>

<p>Любой загруженный модуль ядра заносится в список <tt>/proc/modules</tt>,
так что идем туда и смотрим содержимое этого файла. Как Вы можете убедиться,
наш модуль стал частью ядра. Вдоволь насладившись ощущением новизны,
выгрузите модуль командой <strong>rmmod hello-1</strong> и загляните в файл
<tt>/var/log/messages</tt>, здесь Вы увидите сообщения, которые
сгенерировал Ваш модуль.</p>

<p>А теперь небольшое упражнение: измените содержимое файла
<tt>hello-1.c</tt> так, чтобы функция <tt>init_module()</tt> возвращала бы
какое-либо ненулевое значение и проверьте: что получится?</p>

<hr><h1><a name="HELLOWORLDPART2"></a>2.3. Hello World (часть 2)</h1>
<p>Как я уже упоминал, начиная с ядра версии 2.3.13, требования к именованию
начальной и конечной функций модуля были сняты. Достигается это с помощью
макроопределений <tt>module_init()</tt> и <tt>module_exit()</tt>. Они
определены в файле <tt>linux/init.h</tt>. Единственное замечание: начальная и
конечная функции должны быть определены выше строк, в которых вызываются эти
макросы, в противном случае Вы получите ошибку времени компиляции. Ниже
приводится пример использования этих макроопределений:</p>

<a name="HELLO2"></a><p><strong>Пример 2-3. hello-2.c</strong></p>
<pre>
/*
 *  hello-2.c - Демонстрация использования макроопределений module_init() и module_exit().
 */
#include &lt;linux/module.h>   /* Необходим для любого модуля ядра */
#include &lt;linux/kernel.h>   /* Здесь находится определение KERN_ALERT */
#include &lt;linux/init.h>     /* Здесь находятся определения макросов */

static int __init hello_2_init(void)
{
  printk(KERN_ALERT "Hello, world 2\n");
  return 0;
}

static void __exit hello_2_exit(void)
{
  printk(KERN_ALERT "Goodbye, world 2\n");
}

module_init(hello_2_init);
module_exit(hello_2_exit);
</pre>

<p>Теперь мы имеем в своем багаже два настоящих модуля ядра. Добавить сборку
второго модуля очень просто:</p>

<a name="MAKEFILEFORBOTHOURMODULES"></a><p><strong>Пример 2-4. Makefile для
сборки обоих модулей</strong></p>
<pre>
obj-m += hello-1.o
obj-m += hello-2.o
</pre>

<p>Теперь загляните в файл <tt>linux/drivers/char/Makefile</tt>. Он может
рассматриваться как пример полноценного <tt>Makefile</tt> модуля ядра. Здесь
видно, что ряд модулей жестко зашиты в ядро (obj-y), но нигде нет строки
obj-m. Почему? Знакомые с языком скриптов командной оболочки легко найдут
ответ. Все записи вида obj-$(CONFIG_FOO) будут заменены на obj-y или obj-m, в
зависимости от значения переменных CONFIG_FOO. Эти переменные Вы можете найти
в файле <tt>.config</tt>, который был создан во время конфигурирования ядра с
помощью <strong>make menuconfig</strong> или чего-то вроде этого.</p>

<hr><h1><a name="HELLOWORLDPART3THE__INITAND__EXITMACROS"></a>2.4. Hello
World (часть 3): макроопределения __init и __exit</h1>
<p>Это демонстрация особенностей ядра, появивишихся начиная с версии 2.2.
Обратите внимание на то, как изменились определения функций инициализации и
завершения работы модуля. Макроопределение <tt>__init</tt> вынуждает ядро
после выполнения инициализации модуля освободить память, занимаемую функцией,
правда относится это только к встроенным модулям и не имеет никакого эффекта
для загружаемых модулей. Если Вы мысленно представите себе весь процесс
инициализации встроенного модуля, то все встанет на свои места.</p>

<p>То же относится к макросу <tt>__initdata</tt>, но только для переменных.
</p>

<p>Макроопределение <tt>__exit</tt> вынуждает ядро освободить память,
занимаемую функцией, но только для встроенных модулей, на загружаемые модули
это макроопределение не оказывает эффекта. Опять же, если Вы представите себе
когда вызывается функция завершения работы модуля, то станет понятно, что для
встроенных модулей она не нужна, в то время как для загружаемых
модулей просто необходима.</p>

<p>Оба этих макроса определены в файле <tt>linux/init.h</tt> и отвечают за
освобождение неиспользуемой памяти в ядре. Вам наверняка приходилось видеть
на экране во время загрузки сообщение примерно такого содержания: <tt>Freeing
unused kernel memory: 236k freed</tt>. Это как раз и есть результат
работы данных макроопределений.</p>

<a name="HELLO3"></a><p><strong>Пример 2-5. hello-3.c</strong></p>
<pre>
/*
 *  hello-3.c - Использование макроопределений __init, __initdata и __exit.
 */
#include &lt;linux/module.h>   /* Необходим для любого модуля ядра */
#include &lt;linux/kernel.h>   /* Здесь находится определение KERN_ALERT */
#include &lt;linux/init.h>     /* Здесь находятся определения макросов */

static int hello3_data __initdata = 3;

static int __init hello_3_init(void)
{
  printk(KERN_ALERT "Hello, world %d\n", hello3_data);
  return 0;
}

static void __exit hello_3_exit(void)
{
  printk(KERN_ALERT "Goodbye, world 3\n");
}

module_init(hello_3_init);
module_exit(hello_3_exit);
</pre>

<hr><h1><a name="HELLOWORLDPART4LICENSINGANDMODULEDOCUMENTATI"></a>2.5. Hello
World (часть 4): вопросы лицензирования и документирования модулей</h1>
<p>Если у Вас установлено ядро 2.4 или более позднее, то наверняка во время
запуска примеров модулей Вам пришлось столкнуться с сообщениями вида:
<pre>
# insmod hello-3.o
Warning: loading hello-3.o will taint the kernel: no license
  See http://www.tux.org/lkml/#export-tainted for information
  about tainted modules
Hello, world 3
Module hello-3 loaded, with warnings
</pre></p>

<p>В ядра версии 2.4 и выше был добавлен механизм контроля лицензий, чтобы
иметь возможность предупреждать пользователя об использовании проприетарного
(не свободного) кода. Задать условия лицензирования модуля можно с помощью
макроопределения <tt>MODULE_LICENSE()</tt>. Ниже приводится выдержка из
файла <tt>linux/module.h</tt>:
<pre>
/*
 * В настоящее время для обозначения свободных лицензий
 * приняты следующие идентификаторы:
 * "GPL"                       [GNU Public License v2 или выше]
 * "GPL v2"                    [GNU Public License v2]
 * "GPL and additional rights" [GNU Public License v2 с дополнительными правами]
 * "Dual BSD/GPL"              [GNU Public License v2 или BSD license]
 * "Dual MPL/GPL"              [GNU Public License v2 или Mozilla license]
 *
 * Кроме того, дополнительно имеются следующие идентификаторы:
 * "Proprietary"               [проприетарный, не свободный продукт]
 *
 * Здесь присутствуют компоненты, подразумевающие двойное лицензирование,
 * однако, по отношению к Linux они приобретают значение GPL, как наиболее
 * уместное, так что это не является проблемой.
 * Подобно тому, как LGPL связана с GPL.
 *
 * На это есть несколько причин:
 * 1. modinfo может показать сведения о лицензировании для тех пользователей,
 *    которые желают, чтобы их набор программных компонентов был свободным.
 * 2. Сообщество может игнорировать отчеты об ошибках (bug reports),
 *    относящиеся к проприетарным модулям.
 * 3. Поставщики программных продуктов могут поступать аналогичным образом,
 *    основываясь на своих собственных правилах.
 */
</pre></p>

<p>Точно так же, для описания модуля может использоваться макрос
<tt>MODULE_DESCRIPTION()</tt>, для установления авторства
<tt>MODULE_AUTHOR()</tt>, а для описания типов устройств, поддерживаемых
модулем <tt>MODULE_SUPPORTED_DEVICE()</tt>.</p>

<p>Все эти макроопределения описаны в файле <tt>linux/module.h</tt>. Они не
используются ядром и служат лишь для описания модуля, которое может быть
просмотрено с помощью <strong>objdump</strong>. Попробуйте с помощью утилиты
<strong>grep</strong> посмотреть, как авторы модулей используют эти макросы
(в каталоге <tt>linux/drivers</tt>).</p>

<a name="HELLO4"></a><p><strong>Пример 2-6. hello-4.c</strong></p>
<pre>
/*
 *  hello-4.c - Демонстрация описания модуля.
 */
#include &lt;linux/module.h>
#include &lt;linux/kernel.h>
#include &lt;linux/init.h>
#define DRIVER_AUTHOR "Peter Jay Salzman &lt;p@dirac.org>"
#define DRIVER_DESC   "A sample driver"

static int __init init_hello_4(void)
{
  printk(KERN_ALERT "Hello, world 4\n");
  return 0;
}

static void __exit cleanup_hello_4(void)
{
  printk(KERN_ALERT "Goodbye, world 4\n");
}

module_init(init_hello_4);
module_exit(cleanup_hello_4);

/*
 *  Вы можете передавать в макросы строки, как это показано ниже:
 *  Запретить вывод предупреждения о "загрязнении" ядра, объявив код под GPL.
 */
MODULE_LICENSE("GPL");

/*
 * или определения:
 */
MODULE_AUTHOR(DRIVER_AUTHOR);    /* Автор модуля */
MODULE_DESCRIPTION(DRIVER_DESC); /* Назначение модуля */

/*
 *  Этот модуль использует устройство /dev/testdevice. В будущих версиях ядра
 *  макрос MODULE_SUPPORTED_DEVICE может быть использован
 *  для автоматической настройки модуля, но пока
 *  он служит исключительно в описательных целях.
 */
MODULE_SUPPORTED_DEVICE("testdevice");
</pre>

<hr><h1><a name="PASSINGCOMMANDLINEARGUMENTSTOAMODULE"></a>2.6.
Передача модулю параметров командной строки</h1>
<p>Имеется возможность передачи модулю дополнительных параметров командной
строки, но делается это не с помощью <tt>argc/argv</tt>.</p>

<p>Для начала нужно объявить глобальные переменные, в которые будут записаны
входные параметры, а затем вставить макрос <tt>MODULE_PARAM()</tt> для
запуска механизма приема внешних аргументов. Значения параметров могут быть
переданы модулю с помощью команд <tt>insmod</tt> или <tt>modprobe</tt>.
Например: <strong>insmod mymodule.ko myvariable=5</strong>. Для большей
ясности, объявления переменных и вызовы макроопределений следует размещать в
начале модуля. Пример кода прояснит мое, по общему признанию,
довольно неудачное объяснение.</p>

<p>Макрос <tt>MODULE_PARAM()</tt> принимает 2 аргумента: имя переменной и ее
тип. Поддерживаются следующие типы переменных:
<ul><li>"b": byte (байт),</li>
<li>"h": short int (короткое целое),</li>
<li>"i": integer (целое, как со знаком, так и без знака),</li>
<li>"l": long int (длинное целое, как со знаком, так и без знака),</li>
<li>"s": string (строка, должна объявляться как char*).</li></ul></p>

<p>Для переменных типа <tt>char *</tt> <strong>insmod</strong> будет сам
выделять необходимую память. Вы всегда должны инициализировать переменные
значениями по умолчанию, не забывайте: это код ядра, здесь лучше лишний
раз перестраховаться. Например:
<pre>
int myint = 3;
char *mystr;

MODULE_PARAM(myint, "i");
MODULE_PARAM(mystr, "s");
</pre></p>

<p>Параметры-массивы также допустимы. Целое число, предшествующее символу
типа аргумента, обозначает максимальный размер массива. Два числа,
разделенные дефисом, минимальное и максимальное количество значений.
Например, массив целых, который должен иметь не менее 2 и не более 4
значений, может быть объявлен так:
<pre>
int myintArray[4];
MODULE_PARAM(myintArray, "2-4i");
</pre></p>

<p>Желательно, чтобы все входные параметры модуля имели значения по
умолчанию, например, адреса портов ввода-вывода. Модуль может выполнять
проверку переменных на значения по умолчанию, и если такая проверка дает
положительный результат, то переходить к автоматическому конфигурированию
(вопрос автонастройки будет обсуждаться ниже).</p>

<p>Наконец еще одно макроопределение <tt>MODULE_PARAM_DESC()</tt>. Оно
используется для описания входных аргументов модуля. Принимает два параметра:
имя переменной и строку ее описания в свободной форме.</p>

<a name="HELLO5"></a><p><strong>Пример 2-7. hello-5.c</strong></p>
<pre>
/*
 *  hello-5.c - Пример передачи модулю аргументов командной строки.
 */
#include &lt;linux/module.h>
#include &lt;linux/moduleparam.h>
#include &lt;linux/kernel.h>
#include &lt;linux/init.h>
#include &lt;linux/stat.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Peter Jay Salzman");

static short int myshort = 1;
static int myint = 420;
static long int mylong = 9999;
static char *mystring = "blah";
/*
 * module_param(foo, int, 0000)
 * Первый параметр: имя переменной,
 * Второй: тип,
 * Последний: биты прав доступа для того, чтобы выставить в sysfs
 * (если ненулевое значение) на более поздней стадии.
 */
module_param(myshort, short, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);
MODULE_PARM_DESC(myshort, "A short integer");
module_param(myint, int, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
MODULE_PARM_DESC(myint, "An integer");
module_param(mylong, long, S_IRUSR);
MODULE_PARM_DESC(mylong, "A long integer");
module_param(mystring, charp, 0000);
MODULE_PARM_DESC(mystring, "A character string");

static int __init hello_5_init(void)
{
  printk(KERN_ALERT "Hello, world 5\n=============\n");
  printk(KERN_ALERT "myshort is a short integer: %hd\n", myshort);
  printk(KERN_ALERT "myint is an integer: %d\n", myint);
  printk(KERN_ALERT "mylong is a long integer: %ld\n", mylong);
  printk(KERN_ALERT "mystring is a string: %s\n", mystring);
  return 0;
}

static void __exit hello_5_exit(void)
{
  printk(KERN_ALERT "Goodbye, world 5\n");
}

module_init(hello_5_init);
module_exit(hello_5_exit);
</pre>

<p>Давайте немножко поэкспериментируем с этим модулем:
<pre>
tester# insmod hello-5.o mystring="bebop" myshort=255
myshort is a short integer: 255
myint is an integer: 420
mylong is a long integer: 9999
mystring is a string: bebop

tester# rmmod hello-5
Goodbye, world 5

tester# insmod hello-5.o mystring="supercalifragilisticexpialidocious" \
               myint=100
myshort is a short integer: 1
myint is an integer: 100
mylong is a long integer: 9999
mystring is a string: supercalifragilisticexpialidocious

tester# rmmod hello-5
Goodbye, world 5

tester# insmod hello-5.o mylong=hello
hello-5.o: `hello&#39; invalid for parameter mylong
</pre></p>

<hr><h1><a name="MODULESSPANNINGMULTIPLEFILES"></a>2.7.
Модули, состоящие из нескольких файлов</h1>
<p>Иногда возникает необходимость разместить исходные тексты модуля в
нескольких файлах. В этом случае <strong>kbuild</strong> опять возьмет на
себя всю грязную работу, <tt>Makefile</tt> поможет сохранить Ваши руки
чистыми, а голову светлой! Ниже приводится пример модуля, состоящего
из двух файлов:</p>

<a name="START"></a><p><strong>Пример 2-8. start.c</strong></p>
<pre>
/*
 *  start.c - Пример модуля, исходный текст которого
 *            размещен в нескольких файлах
 */

#include &lt;linux/kernel.h>       /* Все-таки мы пишем код ядра! */
#include &lt;linux/module.h>       /* Необходим для любого модуля ядра */

int init_module(void)
{
  printk("Hello, world - this is the kernel speaking\n");
  return 0;
}
</pre>

<a name="STOP"></a><p><strong>Пример 2-9. stop.c</strong></p>
<pre>
/*
 *  stop.c - Пример модуля, исходный текст которого
 *           размещен в нескольких файлах
 */

#include &lt;linux/kernel.h>       /* Все-таки мы пишем код ядра! */
#include &lt;linux/module.h>       /* Необходим для любого модуля ядра */

void cleanup_module()
{
  printk("&lt;1>Short is the life of a kernel module\n");
}
</pre>

<a name="MAKEFILEFORALLOURMODULES"></a><p><strong>Пример 2-10. Makefile для
сборки всех модулей</strong></p>
<pre>
obj-m += hello-1.o
obj-m += hello-2.o
obj-m += hello-3.o
obj-m += hello-4.o
obj-m += hello-5.o
obj-m += startstop.o
startstop-objs := start.o stop.o
</pre>

<hr><h1><a name="BUILDINGMODULESFORAPRECOMPILEDKERNEL"></a>2.8.
Сборка модулей под существующее ядро</h1>
<p>Я уже рекомендовал Вам пересобрать свое ядро, включив некоторые полезные
для отладки опции, например, такие, как (MODULE_FORCE_UNLOAD): когда эта
опция включена, Вы имеете возможность принудительной выгрузки модуля
(посредством команды <strong>rmmod -f module_name</strong>), даже если ядро
считает Ваши действия небезопасными. Эта опция поможет сэкономить время на
перезагрузках системы в процессе отладки модуля.</p>

<p>Как бы то ни было, но ситуация может сложиться так, что Вам потребуется
загрузить модуль в ранее откомпилированное ядро, например, на другой системе
или в случае, когда Вы не можете пересобрать ядро по каким-либо соображениям.
Если Вы не предполагаете возникновение таких ситуаций, то можете просто
пропустить эту часть главы.</p>

<p>Если Вы лишь установили дерево с исходными текстами ядра и использовали их
для сборки своего модуля, то в большинстве случаев при попытке загрузить его
в работающее ядро Вы получите следующее сообщение об ошибке:
<pre>
insmod: error inserting &#39;your_module_name.ko&#39;: -1
        Invalid module format
</pre></p>

<p>Более подробная информация будет помещена в файл
<tt>/var/log/messages</tt>:
<pre>
Jun  4 22:07:54 localhost kernel: your_module_name: version magic
                &#39;2.6.5-1.358custom 686
REGPARM 4KSTACKS gcc-3.3&#39; should be &#39;2.6.5-1.358 686
REGPARM 4KSTACKS gcc-3.3&#39;
</pre></p>

<p>Другими словами, Ваше ядро отказывается принимать Ваш модуль из-за
несоответствия версий (точнее из-за несоответствия сигнатур версий).
Сигнатура версии сохраняется в объектном файле в виде статической строки,
начинающейся со слова <tt>vermagic:</tt>. Эта строка вставляется во время
компоновки модуля с файлом <tt>init/vermagic.o</tt>. Просмотреть сигнатуру
версии (также как и некоторые дополнительные сведения) можно посредством
команды <strong>modinfo module.ko</strong>:
<pre>
[root@pcsenonsrv 02-HelloWorld]# modinfo hello-4.ko
license:        GPL
author:         Peter Jay Salzman &lt;p@dirac.org>
description:    A sample driver
vermagic:       2.6.5-1.358 686 REGPARM 4KSTACKS gcc-3.3
depends:
</pre></p>

<p>Для преодоления этого препятствия можно воспользоваться ключом
<strong>--force-vermagic</strong> (команды <strong>modprobe</strong>, но это
решение потенциально опасно и совершенно не применимо при распространении
готовых модулей. Следовательно, придется пересобрать модуль в окружении
идентичном тому, в котором было собрано целевое ядро. Как это сделать и
является темой для дальнейшего обсуждения в данной главе.</p>

<p>Прежде всего необходимо установить дерево с исходными текстами ядра той же
версии, что и целевое ядро. Найдите файл конфигурации целевого ядра, как
правило он располагается в каталоге <tt>/boot</tt> под именем вроде
<tt>config-2.6.x</tt>. Просто скопируйте его в каталог с исходными текстами
ядра на своей машине.</p>

<p>Вернемся к сообщению об ошибке, которое было приведено выше, и еще раз
внимательно прочитаем его. Как видите, версия ядра практически та же самая,
но даже небольшого отличия хватило, чтобы ядро отказалось загружать модуль.
Все различие заключается лишь в наличии слова <tt>custom</tt> в сигнатуре
версии модуля. Теперь откройте <tt>Makefile</tt> ядра и удостоверьтесь, что
информация о версии в точности соответствует целевому ядру. Например, в
данном конкретном случае <tt>Makefile</tt> должен содержать строки:
<pre>
VERSION = 2
PATCHLEVEL = 6
SUBLEVEL = 5
EXTRAVERSION = -1.358custom
...
</pre></p>

<p>Теперь запустите <strong>make</strong>, чтобы обновить информацию о версии:
<pre>
[root@pcsenonsrv linux-2.6.x]# make
CHK     include/linux/version.h
UPD     include/linux/version.h
SYMLINK include/asm -> include/asm-i386
SPLIT   include/linux/autoconf.h -> include/config/*
HOSTCC  scripts/basic/fixdep
HOSTCC  scripts/basic/split-include
HOSTCC  scripts/basic/docproc
HOSTCC  scripts/conmakehash
HOSTCC  scripts/kallsyms
CC      scripts/empty.o
...
</pre></p>

<p>Если Вы не желаете полностью пересобирать ядро, то можете прервать процесс
сборки (CTRL_C) сразу же после появления строки, начинающейся со слова
<tt>SPLIT</tt>, поскольку в этот момент все необходимые файлы уже будут
готовы. Перейдем в каталог с исходными текстами модуля и скомпилируем его.
Теперь сигнатура версии модуля будет в точности соответствовать версии
целевого ядра, и модуль будет загружен им без каких-либо проблем.</p>

<hr><h1><a name="CHAPTER3"></a>Глава 3. Дополнительные сведения</h1>
<h1><a name="MODULESVSPROGRAMS"></a>3.1. Модули ядра и прикладные программы
</h1>
<p>Работа программы обычно начинается с исполнения функции
<tt>main()</tt>. После выполнения всей последовательность команд программа
завершает свою работу. Модули исполняются иначе. Они всегда начинают работу с
исполнения функции <tt>init_module</tt> или с функции, которую Вы определили
через вызов <tt>module_init</tt>. Это функция запуска модуля, которая
подготавливает его для последующих вызовов. После завершения исполнения
функции <tt>init_module</tt> модуль больше ничего не делает, он просто сидит
и ждет, когда ядро обратится к нему для выполнения специфических действий.
</p>

<p>Вторая точка входа в модуль: cleanup_module вызывается непосредственно
перед его выгрузкой. Она производит отмену изменений, выполненных
функцией <tt>init_module()</tt>.</p>

<p>Любой модуль обязательно должен иметь функцию инициализации и функцию
завершения. Так как существует более, чем один способ определить функции
инициализации и завершения, я буду стараться использовать термины "начальная"
и "конечная" функции, если я собьюсь и укажу названия <tt>init_module</tt> и
<tt>cleanup_module</tt>, то думаю, что Вы поймете меня правильно.</p>

<hr><h1><a name="FUNCTIONSAVAILABLETOMODULES"></a>3.2. Функции, которые
доступны из модулей</h1>
<p>Как программист Вы знаете, что приложение может вызывать функции, которые
не определены в самой программе. На стадии компоновки разрешаются все внешние
ссылки, уходящие во внешние библиотеки. Функция printf одна из таких функций,
которая определена в библиотеке libc.</p>

<p>Модули ядра в этом плане сильно отличаются от прикладных программ. В
примере "Hello World" мы использовали функцию <tt>printk()</tt>, но не
подключали стандартную библиотеку ввода-вывода. Модули так же проходят стадию
компоновки, но только с ядром и могут вызывать только те функции, которые
экспортируются ядром. Разрешение ссылок на внешние символы производится
утилитой <strong>insmod</strong>. Если у Вас есть желание взглянуть на список
имен, экспортируемых ядром, загляните в файл <tt>/proc/kallsyms</tt>.</p>

<p>Здесь я хочу заострить Ваше внимание на различиях между библиотечными
функциями и системными вызовами. Библиотечные функции это верхний уровень,
который работает в пространстве пользователя и обеспечивает более удобный
интерфейс к функциям, которые выполняют основную работу, системным вызовам.
Системные вызовы работают в привилегированном режиме от имени пользователя и
предоставляются самим ядром. Библиотечная функция <tt>printf()</tt> на первый
взгляд выглядит как основная функция вывода, но все, что она фактически
делает, это формирует строку в соответствии с заданным форматом и передает ее
низкоуровневому системному вызову <tt>write()</tt>, который и выводит строку
на устройство стандартного вывода.</p>

<p>Как в этом можно убедиться? Да очень просто! Скомпилируйте с помощью
команды <strong>gcc -Wall -o hello hello.c</strong> следующую программу:
<pre>
#include &lt;stdio.h>
int main(void)
{
  printf("hello");
  return 0;
}
</pre>
Запустите ее командой <strong>strace hello</strong>. Впечатляет? Каждая
строка, выводимая на экран, соответствует системному вызову. Помните, что
команда <strong>strace</strong> представляет собой незаменимый инструмент для
того, чтобы выяснить, куда программа пытается обратиться, включая такие
сведения, как имена системных вызовов, передаваемые им аргументы и
возвращаемые значения. Здесь Вы должны увидеть строку, которая выглядит
примерно так: <tt>write(1, "hello", 5hello)</tt>. Это и есть то, что мы ищем.
То есть, скрытая от нас сторона вызова функции <tt>printf()</tt>. Возможно,
Вы не знакомы с вызовом <tt>write()</tt>, поскольку большинство программистов
предпочитают пользоваться стандартными библиотечными функциями (такими, как
<tt>fopen(), fputs(), fclose()</tt>). Если это так, тогда загляните в
<strong>man 2 write</strong>. Второй раздел справочного руководства содержит
описания системных вызовов (таких, как <tt>kill(), read()</tt> и т.п.). В
третьем разделе описываются библиотечные вызовы (такие, как
<tt>cosh(), random()</tt> и прочие).</p>

<p>Вы можете даже написать модули, которые подменяют системные вызовы ядра,
вскоре мы продемонстрируем это. Хакеры довольно часто используют эту
возможность для создания "черного хода" в систему или троянов, но Вы можете
использовать ее в менее вредоносных целях, например, заставить ядро выводить
строку "Tee hee, that tickles!" ("Хи-хи, щекотно!") каждый раз, когда
кто-нибудь пробует удалить файл.</p>

<hr><h1><a name="USERSPACEVSKERNELSPACE"></a>3.3.
Пространство пользователя и пространство ядра</h1>
<p>За доступ к ресурсам системы отвечает ядро, будь то видеокарта, жесткий
диск или даже память. Программы часто конкурируют между собой за доступ к тем
или иным ресурсам. Например, при подготовке этого документа, я сохраняю файл
с текстом на жесткий диск, тут же стартует <strong>updatedb</strong>, чтобы
обновить локальную базу данных. В результате мой <strong>vim</strong> и
<strong>updatedb</strong> начинают конкурировать за обладание жестким диском.
Ядро должно обслужить конкурирующие запросы и выстроить их в порядке
очередности. К тому же, сам центральный процессор может работать в различных
режимах. Каждый из режимов имеет свою степень свободы действий. Процессор
Intel 80386 имеет четыре таких режима, которые часто называют кольцами. Unix
использует только два из них: наивысший (нулевое кольцо, известное также под
названием <span><em>привилегированный режим</em></span>) и низший
(<span><em>пользовательский режим</em></span>).</p>

<p>Вернемся к обсуждению библиотечных функций и системных вызовов. Как
правило, программа обращается к библиотечным функциям, находясь в
<span><em>пользовательском режиме</em></span>. Затем библиотечные функции
обращаются к системным вызовам. Системные вызовы выступают от имени
библиотечных функций, но работают в <span><em>привилегированном режиме</em>
</span>, так как они являются непосредственной частью ядра. Как только
системный вызов завершает свою работу, он возвращает управление библиотечной
функции и происходит обратный переход в <span><em>пользовательский режим</em>
</span>.</p>

<p>Обычно о режимах исполнения мы говорим как о <span><em>пространстве
ядра</em></span> и <span><em>пространстве пользователя</em></span>. Эти два
понятия охватывают не только два режима исполнения, но также и то, что каждый
из режимов имеет свое собственное отображение памяти, свое
собственное адресное пространство.</p>

<p>Unix производит переключение из <span><em>пространства пользователя</em>
</span> в <span><em>пространство ядра</em></span> всякий раз, когда
приложение делает системный вызов или приостанавливается аппаратным
прерыванием. Код ядра, исполняющий системный вызов, работает в контексте
процесса: от имени вызвавшего процесса и имеет доступ к данным в адресном
пространстве процесса. Код, который обрабатывает прерывание, наоборот,
являясь асинхронным по своей природе, не относится ни к одному из процессов.
</p>

<p>Основное назначение модулей: расширение функциональности ядра. Код модуля
исполняется в <span><em>пространстве ядра</em></span>. Обычно модуль
реализует обе рассмотренные выше задачи: одни функции выполняются как часть
системных вызовов, другие же производят обработку прерываний.</p>

<hr><h1><a name="NAMESPACE"></a>3.4. Пространство имен</h1>
<p>Когда Вы пишете небольшую программу на C, Вы именуете свои функции и
переменные так, как Вам это удобно. С другой стороны, когда Вы разрабатываете
некую программную единицу, входящую в состав большого программного пакета,
любые глобальные переменные, которые Вы вводите, становятся частью всего
набора глобальных переменных пакета. В этой ситуации могут возникнуть
конфликты имен. Внедрение большого количества имен функций и переменных с
глобальной областью видимости, значение которых не интутивно и
трудноразличимо, приводит к загрязнению пространства имен. Программист,
который работает с такими приложениями, тратит огромное количество умственных
сил на то, чтобы запомнить зарезервированные имена и придумать
свои уникальные названия.</p>

<p>Модули ядра компонуются с огромным программным пакетом, ядром, поэтому
проблема загрязнения пространства имен становится достаточно острой. Коллизии
имен могут породить трудноуловимые ошибки, начиная с того, что модуль просто
отказывается загружаться, и заканчивая весьма причудливыми сообщениями.
Лучший способ избежать загрязнения пространства имен: объявлять все имена как
<tt>static</tt> и использовать префиксы для придания уникальности именам с
глобальной областью видимости. По соглашению об именовании желательно в
качестве префиксов использовать символы нижнего регистра. Если Вы не можете
какие-то имена объявить как <tt>static</tt>, то разрешить проблему можно
посредством создания <tt>symbol table</tt> и регистрации ее в ядре. Эту тему
мы обсудим ниже.</p>

<p>Файл <tt>/proc/kallsyms</tt> содержит все имена в ядре с глобальной
областью видимости, которые доступны для Ваших модулей.</p>

<hr><h1><a name="CODESPACE"></a>3.5. Адресное пространство</h1>
<p>Управление памятью очень сложная тема, она достаточно полно освещается в
книге "Understanding The Linux Kernel", выпущенной издательством
O&#39;Reilly. Я не собираюсь делать из Вас экспертов в области управления
памятью, но Вам действительно необходимо знать некоторые факты.</p>

<p>Если Вы никогда не задумывалесь над тем, что означает слово segfault, то
для Вас скорее всего окажется сюрпризом тот факт, что указатели фактически не
указывают на какой-то реальный участок физической памяти. В любом случе эти
адреса не являются реальными. Когда запускается процесс, ядро выделяет под
него кусок физической памяти и передает его процессу. Эта память используется
для размещения исполняемого кода, стека, переменных, динамической "кучи" и
других вещей, о чем наверняка знают компьютерные гении. Эта память начинается
с логического адреса #0 и простирается до того адреса, который необходим.
Поскольку области памяти, выделенные для разных процессов, не пересекаются,
то каждый из процессов, обратившись к ячейке памяти с адресом, скажем,
<tt>0xbffff978</tt>, получит данные из различных областей физической памяти!
В даннм случае число <tt>0xbffff978</tt> можно рассматривать как смещение
относительно начала области памяти, выделенной процессу. Как правило
программы, подобные нашей "Hello World", не могут обратиться к памяти,
занимаемой другим процессом, хотя существуют обходные пути, позволяющие
добиться этого, но оставим пока эту тему для более позднего обсуждения.</p>

<p>Ядро тоже имеет свое собственное адресное пространство. Поскольку модуль
по сути является частью ядра, то он также работает в адресном пространстве
ядра. Если ошибка <tt>segmentation fault</tt>, возникающая в приложении,
может быть отслежена и устранена без особых проблем, то в модуле подобная
ошибка может стать фатальной для всей системы. Из-за незначительной ошибки в
модуле Вы рискуете свалить все ядро. Результат может быть самым плачевным.
Поэтому будьте предельно внимательны!</p>

<p>Хотелось бы заметить, что это справедливо для любой операционной системы,
которая построена на монолитном ядре. Есть операционные системы, в основе
которых лежит микроядро. В таких ОС каждый модуль получает свое адресное
пространство. Примерами могут служить GNU Hurd и QNX Neutrino.</p>

<hr><h1><a name="DEVICEDRIVERS"></a>3.6. Драйверы устройств</h1>
<p>Драйверы устройств являются одной из разновидностей модулей ядра. Они
играют особую роль. Это настоящие "черные ящики", которые полностью скрывают
детали, касающиеся работы устройства, и предоставляют четкий программный
интерфейс для работы с аппаратурой. В Unix каждое аппаратное устройство
представлено псевдофайлом (файлом устройства) в каталоге <tt>/dev</tt>. Этот
файл обеспечивает средства для взаимодействия с аппаратурой. Так, например,
драйвер звуковой карты <tt>es1370.ko</tt> связывает файл устройства
<tt>/dev/sound</tt> со звуковой картой Ensoniq IS1370. Пользовательское
приложение, например, <strong>mp3blaster</strong> может использовать для
своей работы файл <tt>/dev/sound</tt>, ничего не подозревая о типе
установленной звуковой карты.</p>

<hr><h2><a name="MAJORANDMINORNUMBERS"></a>3.6.1.
Старший и младший номер устройства</h2>
<p>Давайте взглянем на некоторые файлы устройств. Ниже перечислены те из них,
которые представляют первые три раздела на первичном жестком диске:
<pre>
# ls -l /dev/hda[1-3]
brw-rw----  1 root  disk  3, 1 Jul  5  2000 /dev/hda1
brw-rw----  1 root  disk  3, 2 Jul  5  2000 /dev/hda2
brw-rw----  1 root  disk  3, 3 Jul  5  2000 /dev/hda3
</pre></p>

<p>Обратили внимание на столбец с числами, разделенными запятой? Первое число
называют старшим номером устройства. Второе младшим номером. Старший номер
говорит о том, какой драйвер используется для обслуживания аппаратного
обеспечения. Каждый драйвер имеет свой уникальный старший номер. Все файлы
устройств с одинаковым старшим номером управляются одним и тем же драйвером.
Все из вышеперечисленных файлов устройств имеют старший номер равный 3
потому, что все они управляются одним и тем же драйвером.</p>

<p>Младший номер используется драйвером, для различия аппаратных средств,
которыми он управляет. Возвращаясь к примеру выше, заметим, что хотя все три
устройства обслуживаются одним и тем же драйвером, тем не менее каждое из них
имеет уникальный младший номер, поэтому драйвер видит их как
различные аппаратные устройства.</p>

<p>Устройства подразделяются на две большие группы:
<span><em>блочные</em></span> и <span><em>символьные</em></span>. Основное
различие блочных и символьных устройств состоит в том, что обмен данными с
блочным устройством производится порциями байт, блоками. Они имеют внутренний
буфер, благодаря чему повышается скорость обмена. В большинстве Unix-систем
размер одного блока равен 1 килобайту или другому числу, являющемуся степенью
числа 2. Символьные же устройства это лишь каналы передачи информации, по
которым данные следуют последовательно, байт за байтом. Большинство устройств
относятся к классу символьных, поскольку они не ограничены размером блока и
не нуждаются в буферизации. Если первый символ в списке, полученном командой
<strong>ls -l /dev</strong>, &#39;b&#39;, то это блочное устройство, если же
&#39;c&#39;, то символьное. Устройства, которые были приведены в примере
выше, блочные. Ниже приводится список некоторых символьных
устройств (последовательные порты):
<pre>
crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3
</pre></p>

<p>Если Вам интересно узнать, как назначаются старшие номера устройств,
загляните в файл <tt>/usr/src/linux/documentation/devices.txt</tt>.</p>

<p>Все файлы устройств создаются в процессе установки системы с помощью
утилиты <strong>mknod</strong>. Чтобы создать новое устройство, например, с
именем coffee со старшим номером 12 и младшим номером 2, нужно выполнить
команду <strong>mknod /dev/coffee c 12 2</strong>. Вас никто не обязывает
размещать файлы устройств именно в каталоге <tt>/dev</tt>, тем не менее,
делается это в соответствии с принятыми соглашениями. Однако, при разработке
драйвера устройства на период отладки размещать файл устройства в своем
домашнем каталоге, наверное, не такая уж и плохая идея. Главное, не забудьте
исправить место для размещения файла устройства после того, как
отладка будет закончена.</p>

<p>Еще несколько замечаний, которые явно не касаются обсуждаемой темы, но
которые мне хотелось бы сделать. Когда происходит обращение к файлу
устройства, ядро использует старший номер файла для определения драйвера,
который должен обработать это обращение. Это означает, что ядро в
действительности не использует и даже ничего не знает о младшем номере.
Единственный, кто обеспокоен этим, это сам драйвер. Он использует младший
номер, чтобы отличить разные устройства.</p>

<p>Между прочим, когда я говорю "устройства", я подразумеваю нечто более
абстрактное чем, скажем, PCI-плата, которую Вы можете подержать в руке.
Взгляните на эти два файла:
<pre>
% ls -l /dev/fd0 /dev/fd0u1680
brwxrwxrwx   1 root  floppy   2,  0 Jul  5  2000 /dev/fd0
brw-rw----   1 root  floppy   2, 44 Jul  5  2000 /dev/fd0u1680
</pre></p>

<p>К настоящему моменту Вы можете сказать об этих файлах устройств, что оба
они блочные устройства, что обслуживаются одним и тем же драйвером (старший
номер 2). Вы можете даже заявить, что они оба представляют Ваш дисковод для
гибких дисков, несмотря на то, что у Вас стоит только один дисковод. Но
почему два файла? А дело вот в чем: один из них представляет дисковод для
дискет, емкостью 1.44 Мб. Другой тот же самый дисковод, но для дискет
емкостью 1.68 Мб и соответствует тому, что некоторые люди называют
"суперотформатированным" диском ("superformatted" disk). Такие дискеты могут
хранить больший объем данных, чем стандартно отформатированная дискета. Вот
тот случай, когда два файла устройства с различным младшими номерами
фактически представляют одно и то же физическое устройство. Так что слово
"устройство" в нашем обсуждении может означать нечто более абстрактное.</p>

<hr><h1><a name="CHAPTER4"></a>Глава 4. Файлы символьных устройств</h1>
<h1><a name="THEFILE_OPERATIONSSTRUCTURE"></a>4.1. Структура
<tt>file_operations</tt></h1>
<p>Структура file_operations определена в файле <tt>linux/fs.h</tt> и
содержит указатели на функции драйвера, которые отвечают за выполнение
различных операций с устройством. Например, практически любой драйвер
символьного устройства реализует функцию чтения данных из устройства. Адрес
этой функции, среди всего прочего, хранится в структуре file_operations. Ниже
приводится определение структуры, взятое из исходных текстов ядра 2.6.5:
<pre>
struct file_operations
{
  struct module *owner;
    loff_t(*llseek) (struct file *, loff_t, int);
    ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);
    ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);
    ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t,
                         loff_t);
   int (*readdir) (struct file *, void *, filldir_t);
   unsigned int (*poll) (struct file *, struct poll_table_struct *);
   int (*ioctl) (struct inode *, struct file *, unsigned int,
                 unsigned long);
   int (*mmap) (struct file *, struct vm_area_struct *);
   int (*open) (struct inode *, struct file *);
   int (*flush) (struct file *);
   int (*release) (struct inode *, struct file *);
   int (*fsync) (struct file *, struct dentry *, int datasync);
   int (*aio_fsync) (struct kiocb *, int datasync);
   int (*fasync) (int, struct file *, int);
   int (*lock) (struct file *, int, struct file_lock *);
   ssize_t(*readv) (struct file *, const struct iovec *, unsigned long,
                    loff_t *);
   ssize_t(*writev) (struct file *, const struct iovec *, unsigned long,
                     loff_t *);
   ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t,
                       void __user *);
   ssize_t(*sendpage) (struct file *, struct page *, int, size_t,
                       loff_t *, int);
  unsigned long (*get_unmapped_area) (struct file *, unsigned long,
                                      unsigned long, unsigned long,
                                      unsigned long);
};
</pre></p>

<p>Драйвер зачастую реализует далеко не все функции, предусмотренные данной
структурой. Например, драйвер, который обслуживает видеокарту, не обязан
выполнять операцию чтения каталога (<tt>readdir</tt>). Поля структуры,
соответствующие нереализованным функциям, заполняются
пустыми указателями, NULL.</p>

<p>Компилятор <strong>gcc</strong> предоставляет программисту довольно
удобный способ заполнения полей структуры в исходном тексте. Поэтому, если Вы
встретите подобный прием в современных драйверах, пусть это Вас не удивляет.
Ниже приводится пример подобного заполнения:
<pre>
struct file_operations fops =
{
  read: device_read,
  write: device_write,
  open: device_open,
  release: device_release
};
</pre></p>

<p>Однако, существует еще один способ заполнения структур, который
описывается стандартом C99. Причем этот способ более предпочтителен. Gcc
2.95, который я использую, поддерживает синтаксис C99. Вам также следует
придерживаться этого синтаксиса, если Вы желаете обеспечить
переносимость своему драйверу:
<pre>
struct file_operations fops =
{
  .read = device_read,
  .write = device_write,
  .open = device_open,
  .release = device_release
};
</pre></p>

<p>На мой взгляд все выглядит достаточно понятным. Вы должны знать, что в
любое поле структуры, которое Вы явно не инициализируете, компилятор
<strong>gcc</strong> запишет пустой указатель, NULL. Указатель на <tt>struct
file_operations</tt> обычно именуют как <tt>fops</tt>.</p>

<hr><h1><a name="THEFILESTRUCTURE"></a>4.2. Структура <tt>file</tt></h1>
<p>Каждое устройство представлено в ядре структурой <tt>file</tt>, которая
определена в файле <tt>linux/fs.h</tt>. Эта структура используется
исключительно ядром и никогда не используется прикладными программами,
работающими в пространстве пользователя. Это совершенно не то же самое, что и
<tt>FILE</tt>, определяемый библиотекой <tt>glibc</tt>, который в свою
очередь в ядре нигде не используется. Имя структуры может ввести в
заблуждение, поскольку она представляет абстракцию открытого файла, а не
файла на диске, который представляет структура <tt>inode</tt>.</p>

<p>Как правило указатель на структуру <tt>file</tt> называют <tt>filp</tt>.
</p>

<p>Загляните в заголовочный файл и посмотрите определение структуры
<tt>file</tt>. Большинство имеющихся полей структуры, например, <tt>struct
dentry *f_dentry</tt>, не используются драйверами устройств, и Вы можете
игнорировать их. Драйверы не заполняют структуру <tt>file</tt>
непосредственно, они только используют структуры, содержащиеся в ней.</p>

<hr><h1><a name="REGISTERINGADEVICE"></a>4.3. Регистрация устройства</h1>
<p>Как уже говорилось ранее, доступ к символьным устройствам осуществляется
посредством файлов устройств, которые, как правило, располагаются в каталоге
<tt>/dev</tt>. Старший номер устройства говорит о том, какой драйвер с каким
файлом устройства связан. Младший номер используется самим драйвером для
идентификации устройства, если он обслуживает несколько таких устройств.</p>

<p>Добавление драйвера в систему подразумевает его регистрацию в ядре. Это
означает получение старшего номера в момент инициализации модуля. Получить
его можно вызовом функции <tt>register_chrdev()</tt>, определенной в
файле <tt>linux/fs.h</tt>:
<pre>
int register_chrdev(unsigned int major, const char *name,
                    struct file_operations *fops);
</pre></p>
Здесь <tt>unsigned int major</tt> определяет запрашиваемый старший номер
устройства, <tt>const char *name</tt> название устройства, которое будет
отображаться в <tt>/proc/devices</tt>, а <tt>struct file_operations
*fops</tt> задает указатель на таблицу <tt>file_operations</tt> драйвера. В
случае ошибки функция <tt>register_chrdev()</tt> возвращает отрицательное
число. Обратите внимание: функции регистрации драйвера не передается младший
номер устройства. Это потому, что ядро не обслуживает его: это задача
уже самого драйвера.</p>

<p>А теперь вопрос: как получить старший номер для своего устройства, чтобы
случайно не занять уже существующий? Самый простой способ: заглянуть в файл
<tt>Documentation/devices.txt</tt> и выбрать один из неиспользуемых. Но это
не самый лучший выход, потому что Вы никогда не будете уверены в том, что
выбранный номер не будет позднее официально связан с каким-либо другим
устройством. Правильный ответ: попросить ядро выделить
динамический номер устройства.</p>

<p>Если Вы передадите функции <tt>register_chrdev()</tt> в качестве старшего
номера число 0, то возвращаемое положительное значение будет представлять
собой динамически выделенный ядром старший номер устройства. Один из
неприятных моментов здесь состоит в том, что заранее Вы не сможете создать
файл устройства, поскольку старший номер устройства заранее не известен. Тем
не менее, можно предложить ряд способов решения этой проблемы:
<ol type="1"><li>Драйвер может выводить сообщение в системный журнал (как
это делает модуль "Hello World"), а Вы затем вручную
создадите файл устройства.</li>
<li>Для вновь зарегистрированного устройства в файле <tt>/proc/devices</tt>
появится запись. Вы можете найти эту запись и вручную создать файл устройства
или можно написать скрипт, который выполнит эту работу за Вас.</li>
<li>Можно заставить сам драйвер создавать файл устройства с помощью
системного вызова <tt>mknod</tt> после успешной регистрации. А внутри
<tt>cleanup_module()</tt> предусмотреть возможность удаления файла
устройства с помощью <tt>rm</tt>.</li></ol></p>

<hr><h1><a name="UNREGISTERINGADEVICE"></a>4.4. Отключение устройства</h1>
<p>Мы не можем позволить выгружать модуль по прихоти суперпользователя. Если
файл устройства удалить после того, как он будет открыт процессом, то может
возникнуть ситуация, когда процесс попытается обратиться к выгруженному
драйверу (в конце концов процесс даже не подозревает, что такое могло
произойти). В результате произойдет попытка обращения к тому участку памяти,
где ранее находилась функция обработки запроса. Если повезет, то этот участок
памяти окажется не затертым ядром, и Вы получите сообщение об ошибке. Если не
повезет, произойдет переход в середину чужой функции. Результат такого вызова
трудно предугадать заранее</p>

<p>Обычно если какая-то операция должна быть отвергнута, функция возвращает
код ошибки (отрицательное число). В случае с функцией
<tt>cleanup_module()</tt> это невозможно, поскольку она не имеет
возвращаемого значения. Однако, для каждого модуля в системе имеется счетчик
обращений, который хранит число процессов, использующих модуль. Вы можете
увидеть это число в третьем поле в файле <tt>/proc/devices</tt>. Если это
поле не равно нулю, то <strong>rmmod</strong> не сможет выгрузить модуль.
Обратите внимание: нет нужды следить за состоянием счетчика в
<tt>cleanup_module()</tt>, это делает система внутри системного вызова
<tt>sys_delete_module</tt> (определение функции Вы найдете в файле
<tt>linux/module.c</tt>). Вы не должны изменять значение счетчика напрямую,
тем не менее ядро предоставляет в Ваше распоряжение функции, которые
увеличивают и уменьшают значение счетчика обращений:
<ul><li><tt>try_module_get(THIS_MODULE)</tt>:
увеличивает счетчик обращений на 1.</li>
<li><tt>try_module_put(THIS_MODULE)</tt>: уменьшает счетчик обращений на 1.
</li></ul></p>

<p>Очень важно сохранять точное значение счетчика! Если Вы каким-либо образом
потеряете действительное значение, то никогда не сможете выгрузить модуль.
Тут поможет только перезагрузка. Это рано или поздно обязательно случиться
при разработке какого-либо модуля.

<hr><h1><a name="CHARDEV"></a>4.5. chardev.c</h1>
<p>Следующий пример создает устройство с именем <tt>chardev</tt>. Вы можете
читать содержимое файла устройства с помощью команды <strong>cat</strong> или
открывать его на чтение из программы (функцией <tt>open()</tt>). Посредством
этого файла драйвер будет извещать о количестве попыток обращения к нему.
Модуль не поддерживает операцию записи (типа <strong>echo "hi" >
/dev/chardev</strong>), но определяет такую попытку и сообщает
пользователю о том, что операция записи не поддерживается.</p>

<a name="CHARDEVC"></a><p><strong>Пример 4-1. chardev.c</strong></p>
<pre>
/*
 *  chardev.c: Создает символьное устройство, доступное только для чтения
 *  возвращает сообщение, с указанием количества произведенных попыток чтения
 *  из файла устройства.
 */
#include &lt;linux/kernel.h>
#include &lt;linux/module.h>
#include &lt;linux/fs.h>
#include &lt;asm/uaccess.h>        /* определение функции put_user */

/*
 *  Прототипы функций, обычно их выносят в заголовочный файл (.h).
 */
int init_module(void);
void cleanup_module(void);
static int device_open(struct inode *, struct file *);
static int device_release(struct inode *, struct file *);
static ssize_t device_read(struct file *, char *, size_t, loff_t *);
static ssize_t device_write(struct file *, const char *, size_t, loff_t *);

#define SUCCESS 0
#define DEVICE_NAME "chardev"   /* Имя устройства, будет отображаться в /proc/devices   */
#define BUF_LEN 80                      /* Максимальная длина сообщения */

/*
 * Глобальные переменные, объявлены как static, во избежание конфликтов имен.
 */
static int Major;             /* Старший номер устройства нашего драйвера */
static int Device_Open = 0;   /* Устройство открыто? Используется для
                               * предотвращения одновременного обращения
                               * из нескольких процессов */
static char msg[BUF_LEN];     /* Здесь будет собираться текст сообщения */
static char *msg_Ptr;

static struct file_operations fops =
{
  .read = device_read,
  .write = device_write,
  .open = device_open,
  .release = device_release
};

/*
 * Функции
 */
int init_module(void)
{
  Major = register_chrdev(0, DEVICE_NAME, &fops);

  if (Major &lt; 0)
  {
     printk("Registering the character device failed with %d\n", Major);
     return Major;
  }
  printk("&lt;1>I was assigned major number %d.  To talk to\n", Major);
  printk("&lt;1>the driver, create a dev file with\n");
  printk("&#39;mknod /dev/chardev c %d 0&#39;.\n", Major);
  printk("&lt;1>Try various minor numbers.  Try to cat and echo to\n");
  printk("the device file.\n");
  printk("&lt;1>Remove the device file and module when done.\n");
  return 0;
}

void cleanup_module(void)
{
  /*
   * Отключение устройства
   */
  int ret = unregister_chrdev(Major, DEVICE_NAME);
  if (ret &lt; 0) printk("Error in unregister_chrdev: %d\n", ret);
}

/*
 * Обработчики.
 * Вызывается, когда процесс пытается открыть файл устройства, например,
 * командой "cat /dev/chardev".
 */
static int device_open(struct inode *inode, struct file *file)
{
  static int counter = 0;

  if (Device_Open) return -EBUSY;
  Device_Open++;
  sprintf(msg, "I already told you %d times Hello world!\n", counter++);
  msg_Ptr = msg;
  try_module_get(THIS_MODULE);
  return SUCCESS;
}

/*
 * Вызывается, когда процесс закрывает файл устройства.
 */
static int device_release(struct inode *inode, struct file *file)
{
  Device_Open--;   /* Теперь мы готовы обслужить другой процесс */
  /*
   * Уменьшить счетчик обращений, иначе после первой же удачной
   * попытки открыть файл устройства, Вы никогда не сможете выгрузить модуль.
   */
  module_put(THIS_MODULE);
  return 0;
}

/*
 * Вызывается, когда процесс пытается прочитать уже открытый файл устройства.
 */
static ssize_t device_read(struct file *filp, /* см. include/linux/fs.h   */
                           char *buffer,   /* буфер, куда надо положить данные */
                           size_t length,  /* размер буфера */
                           loff_t * offset)
{
  /*
   * Количество байт, фактически записанных в буфер
   */
  int bytes_read = 0;

  /*
   * Если достигли конца сообщения, вернуть 0, как признак конца файла.
   */
  if (*msg_Ptr == 0) return 0;
  /*
   * Перемещение данных в буфер.
   */
  while (length && *msg_Ptr)
  {
    /*
     * Буфер находится в пространстве пользователя (в сегменте данных),
     * а не в пространстве ядра, поэтому простое присваивание здесь
     * недопустимо. Для того, чтобы скопировать данные, мы используем
     * функцию put_user, которая перенесет данные из пространства
     * ядра в пространство пользователя.
     */
    put_user(*(msg_Ptr++), buffer++);
    length--;
    bytes_read++;
  }
  /*
   * В большинстве своем, функции чтения возвращают количество
   * байт, записанных в буфер.
   */
  return bytes_read;
}

/*
 * Вызывается, когда процесс пытается записать в устройство,
 * например, так: echo "hi" > /dev/chardev.
 */
static ssize_t device_write(struct file *filp, const char *buff,
                            size_t len, loff_t * off)
{
  printk("&lt;1>Sorry, this operation isn&#39;t supported.\n");
  return -EINVAL;
}
</pre>

<a name="MAKEFILEFORCHARDEVC"></a><p><strong>Пример 4-2. Makefile</strong></p>
<pre>
obj-m += chardev.o
</pre>

<hr><h1><a name="WRITINGMODULESFORMULTIPLEKERNELVERSIONS"></a>4.6. Создание
модулей для работы с разными версиями ядра</h1>
<p>Системные вызовы, которые представляют собой основной интерфейс с ядром,
как правило, не меняют свой синтаксис вызова от версии к версии. В ядро могут
быть добавлены новые системные вызовы, но старые практически всегда сохраняют
свое поведение, независимо от версии ядра. Делается это с целью сохранения
обратной совместимости, чтобы не нарушить корректную работу ранее выпущенных
приложений. В большинстве случаев файлы устройств также останутся теми же
самыми. С другой стороны, внутренние интерфейсы ядра могут изменяться
от версии к версии.</p>

<p>Версии ядра подразделяются на стабильные (n.&lt;четное_число>.m) и
нестабильные (n.&lt;нечетное_число>.m). Нестабильные версии несут в себе
самые новые наработки, включая те, которые будут считаться ошибкой и те,
которые претерпят существенные изменения в следующей версии. В результате Вы
не можете доверять тому или иному интерфейсу, поскольку он может еще
измениться (по этой причине я не посчитал нужным описывать их в этой книге:
слишком много работы, к тому же, изменения происходят слишком быстро). От
стабильных версий можно ожидать, что интерфейсы останутся неизменными,
независимо от версии релиза (последнее число в номере версии: m).</p>

<p>Итак, Вы уже поняли, что между разными версиями ядра могут существовать
весьма существенные отличия. Если появится необходимость в создании модуля,
который мог бы работать с разными версиями ядра, то можете воспользоваться
директивами условной компиляции, основываясь на сравнении макроопределений
<tt>LINUX_VERSION_CODE</tt> и <tt>KERNEL_VERSION</tt>. Для версии a.b.c
макрос <tt>KERNEL_VERSION</tt> вернет код версии, вычисленный в соответствии
с выражением 2^{16}a+2^{8}b+c. Макрос <tt>LINUX_VERSION_CODE</tt> возвращает
текущую версию ядра.</p>

<p>В предыдущих версиях данного руководства довольно подробно описывалось,
как писать обратно совместимый код с использованием директив условной
компиляции. Но, начиная с этой версии, я решил порвать с устоявшейся
традицией. Теперь, если Вы желаете писать модули под определенные версии
ядра, обращайтесь к соответствующей версии руководства (LKMPG). Я решил
выпускать этот документ под версиями (номер версии и номер подверсии),
совпадающими с версиями обсуждаемого ядра. Таким образом, разработчики,
работающие под ядром 2.4.x, должны обращаться к LKMPG версии 2.4.x, а
работающие под ядром 2.6.x к LKMPG версии 2.6.x и т.д.</p>

<hr><h1><a name="CHAPTER5"></a>Глава 5. Файловая система <tt>/proc</tt></h1>
<h1><a name="THEPROCFILESYSTEMFORREAD"></a>5.1. Файловая система <tt>/proc</tt>:
создание файлов, доступных для чтения</h1>
<p>Linux предоставляет ядру и модулям ядра дополнительный механизм передачи
информации заинтересованным в ней процессам: файловую систему <tt>/proc</tt>.
Первоначально она создавалась с целью получения сведений о процессах (отсюда
и такое название). Теперь она интенсивно используется и самим ядром, которому
есть что сообщить! Например, <tt>/proc/modules</tt> список загруженных
модулей, <tt>/proc/meminfo</tt> статистика использования памяти.</p>

<p>Методика работы с файловой системой <tt>/proc</tt> очень похожа на работу
драйверов с файлами устройств: Вы создаете структуру со всей необходимой
информацией, включая указатели на функции-обработчики (в нашем случае имеется
только один обработчик, который обслуживает чтение файла в <tt>/proc</tt>).
Функция <tt>init_module</tt> регистрирует структуру, а
<tt>cleanup_module</tt> отменяет регистрацию.</p>

<p>Основная причина, по которой используется <tt>proc_register_dynamic</tt>,
состоит в том, что номер inode для нашего файла заранее неизвестен, поэтому
мы даем возможность ядру определить его самостоятельно, чтобы предотвратить
возможные конфликты. В обычных файловых системах, размещенных на диске, а не
в памяти, как <tt>/proc</tt>, inode указывает на то место в дисковом
пространстве, где размещена индексная запись (index node, сокращенно inode) о
файле. Inode содержит все необходимые сведения о файле, например, права
доступа, указатель на первый блок с содержимым файла.</p>

<p>Поскольку мы не предусматриваем обработку операций открытия/закрытия файла
в файловой системе <tt>/proc</tt>, то некуда вставлять вызовы функций
<tt>try_module_get</tt> и <tt>try_module_put</tt>. Если вдруг случится так,
что модуль был выгружен в то время, как соответствующий файл в
<tt>/proc</tt> оставался открытым, к сожалению, у Вас не будет возможности
избежать возможных последствий. В следующем разделе я расскажу о довольно
сложном, но достаточно гибком способе защиты от подобных ситуаций.</p>

<a name="PROCFSC"></a><p><strong>Пример 5-1. procfs.c</strong></p>
<pre>
/*
 *  procfs.c - Пример создания файла в /proc.
 */

#include &lt;linux/module.h> /* Необходимо для любого модуля */
#include &lt;linux/kernel.h> /* Все-таки мы работаем с ядром! */
#include &lt;linux/proc_fs.h>/* Необходимо для работы с файловой системой /proc */

struct proc_dir_entry *Our_Proc_File;
/* Обработчик чтения из файла в /proc.
 *
 * Аргументы
 * =========
 * 1. Буфер с данными. Как его заполнить решайте сами.
 * 2. Указатель на указатель на строку символов. Если Вы не желаете
 *    использовать буфер, размещенный ядром.
 * 3. Текущая позиция в файле.
 * 4. Размер буфера.
 * 5. Признак конца файла, "1" == EOF.
 * 6. Указатель на данные (необходим в случае единственного
 *    обработчика на несколько файлов в /proc).
 *
 * Порядок использования и возвращаемое значение
 * =============================================
 * Нулевое значение == "буфер пуст", то есть "конец файла".
 * Отрицательное значение == код ошибки.
 *
 * Дополнительные сведения
 * =======================
 * Основные принципы реализации этой функции я почерпнул не из документации,
 * а из исходных текстов модулей, выполняющих подобные действия.
 * Меня интересовало использование поля get_info в
 * структуре proc_dir_entry. Если Вам это интересно. то для поиска
 * я пользовался утилитами find и grep). Интересующий меня пример
 * я нашел в &lt;kernel source directory>/fs/proc/array.c.
 *
 * Когда что-то непонятно, то лучше всего
 * поискать примеры в исходных текстах ядра. В этом состоит
 * огромное преимущество Linux перед другими ОС, так как
 * доступны все исходные тексты, так что пользуйтесь этим преимуществом!
 */
ssize_t procfile_read(char *buffer, char **buffer_location,
                      off_t offset, int buffer_length, int *eof, void *data)
{
  printk(KERN_INFO "inside /proc/test : procfile_read\n");

  int len = 0;          /* Фактическое число байт */
  static int count = 1;

  /*
   * Вы всегда должны выдавать имеющуюся информацию,
   * если пользователь спрашивает, Вы должны ответить.
   *
   * Это очень важно, поскольку библиотечная функция read
   * будет продолжать обращаться к системному вызову read до тех
   * пор, пока ядро не ответит, что сведений больше нет, или пока буфер
   * не будет заполнен.
   */
  if (offset > 0)
  {
     printk(KERN_INFO "offset %d : /proc/test : procfile_read, \
            wrote %d Bytes\n", (int)(offset), len);
     *eof = 1;
     return len;
  }
  /*
   * Заполнить буфер и получить его размер
   */
  len = sprintf(buffer, "For the %d%s time, go away!\n", count,
                (count % 100 > 10 && count % 100 &lt; 14) ?
                "th" : (count % 10 == 1) ? "st" :
                (count % 10 == 2) ? "nd" :
                (count % 10 == 3) ? "rd" : "th");
  count++;
  /*
   * Вернуть размер буфера
   */
  printk(KERN_INFO "leaving /proc/test : procfile_read,
         wrote %d Bytes\n", len);
  return len;
}

int init_module()
{
  int rv = 0;

  Our_Proc_File = create_proc_entry("test", 0644, NULL);
  Our_Proc_File->read_proc = procfile_read;
  Our_Proc_File->owner = THIS_MODULE;
  Our_Proc_File->mode = S_IFREG | S_IRUGO;
  Our_Proc_File->uid = 0;
  Our_Proc_File->gid = 0;
  Our_Proc_File->size = 37;
  printk(KERN_INFO "Trying to create /proc/test:\n");
  if (Our_Proc_File == NULL)
  {
     rv = -ENOMEM;
     remove_proc_entry("test", &proc_root);
     printk(KERN_INFO "Error: Could not initialize /proc/test\n");
  }
  else
  {
    printk(KERN_INFO "Success!\n");
  }
  return rv;
}

void cleanup_module()
{
  remove_proc_entry("test", &proc_root);
  printk(KERN_INFO "/proc/test removed\n");
}
</pre>

<a name="MAKEFILEFORPROCFSC"></a><p><strong>Пример 5-2. Makefile</strong></p>
<pre>
obj-m += procfs.o
</pre>

<hr><h1><a name="USINGPROCFORINPUT"></a>5.2. Файловая система <tt>/proc</tt>:
создание файлов, доступных для записи</h1>
<p>Пока мы знаем о двух способах получения информации от драйвера устройства:
можно зарегистрировать драйвер и создать файл устройства, и создать файл в
файловой системе <tt>/proc</tt>. Единственная проблема: Вы пока ничего не
можете передать модулю ядра. Для начала попробуем организовать передачу
данных модулю ядра посредством файловой системы <tt>/proc</tt>.</p>

<p>Поскольку файловая система <tt>/proc</tt> была написана, главным образом,
для того, чтобы получать данные от ядра, она не предусматривает специальных
средств для записи данных в файлы. Структура proc_dir_entry не содержит
указатель на функцию-обработчик записи. Поэтому, вместо того, чтобы писать в
<tt>/proc</tt> напрямую, мы вынуждены будем использовать стандартный для
файловой системы механизм.</p>

<p>Linux предусматривает возможность регистрации файловой системы. Так как
каждая файловая система должна иметь собственные функции для обработки inode
и выполнять файловые операции, то имеется специальная структура, которая
хранит указатели на все необходимые функции-обработчики, <tt>struct
inode_operations</tt>, которая включает указатель на <tt>struct
file_operations</tt>. Файловая система <tt>/proc</tt> всякий раз, когда мы
регистрируем новый файл, позволяет указать какая <tt>struct
inode_operations</tt> будет использоваться для доступа к нему. В свою очередь
в этой структуре имеется указатель <tt>struct file_operations</tt>, а в ней
уже находятся указатели на наши функции-обработчики.</p>

<p>Обратите внимание: стандартные понятия "чтение" и "запись" в ядре имеют
противоположный смысл. Функции чтения используются для записи в файл в то
время, как функции записи используются для чтения из файла. Причина в том,
что понятия "чтение" и "запись" рассматриваются здесь с точки зрения
пользователя: если процесс читает что-то из ядра, значит ядро должно записать
эти данные, если процесс пишет, ядро должно прочитать то, что записано.</p>

<p>Еще один интересный момент: функция <tt>module_permission</tt>. Она
вызывается всякий раз, когда процесс пытается обратиться к файлу в файловой
системе <tt>/proc</tt>, и принимает решение: разрешить доступ к файлу или
нет. На сегодняшний день решение принимается только на основе выполняемой
операции и UID процесса, но в принципе возможна и иная организация принятия
решения, например, разрешать ли одновременный доступ к одному файлу
нескольким процессам и прочее.</p>

<p>Причина, по которой для копирования данных используются функции
<tt>put_user</tt> и <tt>get_user</tt>, состоит в том, что процессы в Linux
(по крайней мере в архитектуре Intel) исполняются в изолированных адресных
пространствах, не пересекающихся с адресным пространством ядра. Это означает,
что указатель не содержит уникальный адрес физической памяти: он хранит
логический адрес в адресном пространстве процесса.</p>

<p>Единственное адресное пространство, доступное процессу, это его
собственное адресное пространство. Практически любой модуль ядра должен иметь
возможность обмена информацией с пользовательскими процессами. Однако, когда
модуль ядра получает указатель на некий буфер, то адрес этого буфера
находится в адресном пространстве процесса. Макрокоманды <tt>put_user</tt> и
<tt>get_user</tt> позволяют обращаться к памяти процесса по
указанному им адресу.</p>

<a name="PROCFSC2"></a><p><strong>Пример 5-3. procfs.c</strong></p>
<pre>
/*
 *  procfs.c - Пример создания файла в /proc, который доступен как на чтение,
 *  так и на запись.
 */
#include &lt;linux/module.h>  /* Необходимо для любого модуля */
#include &lt;linux/kernel.h>  /* Все-таки мы работаем с ядром! */
#include &lt;linux/proc_fs.h> /* Необходимо для работы с файловой системой /proc */
#include &lt;asm/uaccess.h>   /* определения функций get_user и put_user */

/*
 * Место хранения последнего принятого сообщения,
 * которое будет выводиться в файл, чтобы показать, что
 * модуль действительно может получать ввод от пользователя
 */
#define MESSAGE_LENGTH 80
static char Message[MESSAGE_LENGTH];
static struct proc_dir_entry *Our_Proc_File;

#define PROC_ENTRY_FILENAME "rw_test"

static ssize_t module_output(struct file *filp, /* см. include/linux/fs.h   */
                             char *buffer,      /* буфер с данными */
                             size_t length,     /* размер буфера   */
                             loff_t * offset)
{
  static int finished = 0;
  int i;
  char message[MESSAGE_LENGTH + 30];

  /*
   * Для индикации признака конца файла возвращается 0.
   * Если этого не сделать, процесс будет продолжать
   * пытаться читать из файла, угодив в бесконечный цикл.
   */
  if (finished)
  {
     finished = 0;
     return 0;
  }
  /*
   * Для передачи данных из пространства ядра в пространство пользователя
   * следует использовать put_user.
   * В обратном направлении get_user.
   */
  sprintf(message, "Last input:%s", Message);
  for (i = 0; i &lt; length && message[i]; i++)
    put_user(message[i], buffer + i);
  /*
   * Обратите внимание: в данной ситуации мы исходим из предположения,
   * что размер сообщения меньше, чем len, в противном случае сообщение будет
   * обрезано. В реальной ситуации, если длина сообщения больше, чем
   * len, то возвращается len, а остаток сообщения возвращается
   * на последующих вызовах.
   */
  finished = 1;
  return i;             /* Вернуть количество "прочитанных" байт */
}

static ssize_t module_input(struct file *filp, const char *buff, size_t len,
                            loff_t * off)
{
  int i;

  /*
   * Переместить данные, полученные от пользователя в буфер,
   * который позднее будет выведен функцией module_output.
   */
  for (i = 0; i &lt; MESSAGE_LENGTH - 1 && i &lt; len; i++)
    get_user(Message[i], buff + i);
  Message[i] = &#39;\0&#39;;
  /* Обычная строка, завершающаяся символом \0 */
  return i;
}

/*
 * Эта функция принимает решение о праве на выполнение операций с файлом
 * 0: разрешено, ненулеое значение: запрещено.
 *
 * Операции с файлом могут быть:
 * 0 - Исполнение (не имеет смысла в нашей ситуации),
 * 2 - Запись (передача от пользователя к модулю ядра),
 * 4 - Чтение (передача от модуля ядра к пользователю).
 *
 * Эта функция проверяет права доступа к файлу
 * Права, выводимые командой ls -l,
 * могут быть проигнорированы здесь.
 */

static int module_permission(struct inode *inode, int op,
                             struct nameidata *foo)
{
  /*
   * Позволим любому читать файл, но писать только root (uid 0).
   */
  if (op == 4 || (op == 2 && current->euid == 0)) return 0;
  /*
   * Если что-то иное, то запретить доступ.
   */
  return -EACCES;
}

/*
 * Файл открыт, пока нет нужды беспокоиться о чем-то,
 * единственное, что нужно сделать, это нарастить
 * счетчик обращений к модулю.
 */
int module_open(struct inode *inode, struct file *file)
{
  try_module_get(THIS_MODULE);
  return 0;
}

/*
 * Файл закрыт, значит надо уменьшить счетчик обращений.
 */
int module_close(struct inode *inode, struct file *file)
{
  module_put(THIS_MODULE);
  return 0;             /* все нормально! */
}

static struct file_operations File_Ops_4_Our_Proc_File =
{
  .read = module_output,
  .write = module_input,
  .open = module_open,
  .release = module_close,
};

/*
 * Операции над индексной записью Вашего файла. Необходима для того, чтобы
 * указать местоположение структуры
 * file_operations нашего файла, а также, чтобы задать адрес
 * функции определения прав доступа к файлу. Здесь можно указать адреса
 * других функций-обработчиков, но нас они не интересуют.
 */
static struct inode_operations Inode_Ops_4_Our_Proc_File =
{
  .permission = module_permission,      /* проверка прав доступа */
};

/*
 * Начальная и конечная функции модуля
 */
int init_module()
{
  int rv = 0;

  Our_Proc_File = create_proc_entry(PROC_ENTRY_FILENAME, 0644, NULL);
  Our_Proc_File->owner = THIS_MODULE;
  Our_Proc_File->proc_iops = &Inode_Ops_4_Our_Proc_File;
  Our_Proc_File->proc_fops = &File_Ops_4_Our_Proc_File;
  Our_Proc_File->mode = S_IFREG | S_IRUGO | S_IWUSR;
  Our_Proc_File->uid = 0;
  Our_Proc_File->gid = 0;
  Our_Proc_File->size = 80;
  if (Our_Proc_File == NULL)
  {
     rv = -ENOMEM;
     remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root);
     printk(KERN_INFO "Error: Could not initialize /proc/test\n");
  }
  return rv;
}

void cleanup_module()
{
  remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root);
}
</pre>

<p>Хотите еще примеры работы с файловой системой <tt>/proc</tt>? Хорошо, но
имейте в виду, ходят слухи, что <tt>/proc</tt> уходит в небытие и вместо нее
следует использовать sysfs. Дополнительные сведения о файловой системе
<tt>/proc</tt> Вы найдете в <tt>linux/Documentation/DocBook</tt>. Дайте
команду <strong>make help</strong>, она выведет инструкции по созданию
документации в различных форматах, например: <strong>make htmldocs</strong>.
</p>

<hr><h1><a name="CHAPTER6"></a>Глава 6. Работа с файлами устройств</h1>
<p>Файлы устройств представляют физические устройства. В большинстве своем
физические устройства используются как для вывода, так и для ввода, таким
образом необходимо иметь некий механизм для передачи данных от процесса
(через модуль ядра) к устройству. Один из вариантов: открыть файл устройства
и записать в него данные, точно так же, как в обычный файл. В следующем
примере операция записи реализуется функцией <tt>device_write</tt>.</p>

<p>Однако, этого не всегда бывает достаточно. Допустим, что у Вас есть модем,
подключенный через последовательный порт (это может быть и внутренний модем,
с точки зрения CPU он выглядит как модем, связанный с последовательным
портом). Естественное решение: использовать файл устройства для передачи
данных модему (это могут быть команды модема или данные, которые будут
посланы в линию) и для чтения данных из модема (ответы модема на команды или
данные, полученные из линии). Однако, это оставляет открытым вопрос о том,
как взаимодействовать непосредственно с последовательным портом,
например, как настроить скорость обмена.</p>

<p>Ответ: в Unix следует использовать специальную функцию с именем
<tt>ioctl</tt> (сокращение от Input Output ConTroL). Любое устройство может
иметь свои команды <tt>ioctl</tt>, которые могут читать (для передачи данных
от процесса ядру), писать (для передачи данных от ядра к процессу), писать и
читать или ни то, ни другое. Функция <tt>ioctl</tt> вызывается с тремя
параметрами: дескриптор файла устройства, номер <tt>ioctl</tt> и третий
параметр, который имеет тип long, используется для
передачи дополнительных аргументов.

<p>Номер ioctl содержит комбинацию бит, составляющих старший номер
устройства, тип команды и тип дополнительного параметра. Обычно номер ioctl
создается макроопределением (_IO, _IOR, _IOW или _IOWR, в зависимости от
типа) в файле заголовка. Этот заголовочный файл должен подключаться
директивой #include к исходным файлам программы, которая использует ioctl для
обмена данными с модулем. В примере, приводимом ниже, представлены файл
заголовка chardev.h и программа, которая взаимодействует с модулем ioctl.c.
</p>

<p>Если Вы предполагаете использовать ioctl в Ваших собственных модулях, то
Вам надлежит обратиться к файлу <tt>Documentation/ioctl-number.txt</tt> с
тем, чтобы не занять зарегистрированные номера ioctl.</p>

<a name="AEN668"></a><p><strong>Пример 6-1. chardev.c</strong></p>
<pre>
/*
 *  chardev.c - Пример создания символьного устройства
 *              доступного на запись и чтение.
 */
#include &lt;linux/module.h> /* Необходимо для любого модуля */
#include &lt;linux/kernel.h> /* Все-таки мы работаем с ядром! */
#include &lt;linux/fs.h>
#include &lt;asm/uaccess.h>  /* определения функций get_user и put_user */
#include "chardev.h"

#define SUCCESS 0
#define DEVICE_NAME "char_dev"
#define BUF_LEN 80

/*
 * Устройство уже открыто? Используется для
 * предотвращения конкурирующих запросов к устройству
 */
static int Device_Open = 0;

/*
 * Ответ устройства на запрос
 */
static char Message[BUF_LEN];

/*
 * Позиция в буфере. Используется в том случае, если сообщение оказывается
 * длиннее, чем размер буфера.
 */
static char *Message_Ptr;

/*
 * Вызывается, когда процесс пытается открыть файл устройства.
 */
static int device_open(struct inode *inode, struct file *file)
{
#ifdef DEBUG
  printk("device_open(%p)\n", file);
#endif
  /*
   * В каждый конкретный момент времени только один процесс может
   * открыть файл устройства.
   */
  if (Device_Open) return -EBUSY;
  Device_Open++;
  /*
   * Инициализация сообщения.
   */
  Message_Ptr = Message;
  try_module_get(THIS_MODULE);
  return SUCCESS;
}

static int device_release(struct inode *inode, struct file *file)
{
#ifdef DEBUG
  printk("device_release(%p,%p)\n", inode, file);
#endif
  /*
   * Теперь мы готовы принять запрос от другого процесса.
   */
  Device_Open--;
  module_put(THIS_MODULE);
  return SUCCESS;
}

/*
 * Вызывается когда процесс, открывший файл устройства,
 * пытается считывать из него данные.
 */
static ssize_t device_read(struct file *file, /* см. include/linux/fs.h   */
                           char __user * buffer,  /* буфер для сообщения */
                           size_t length,         /* размер буфера       */
                           loff_t * offset)
{
  /*
   * Количество байт, фактически записанных в буфер
   */
  int bytes_read = 0;

#ifdef DEBUG
  printk("device_read(%p,%p,%d)\n", file, buffer, length);
#endif
  /*
   * Если достигнут конец сообщения, вернуть 0 (признак конца файла).
   */
  if (*Message_Ptr == 0) return 0;
  /*
   * Собственно запись данных в буфер.
   */
  while (length && *Message_Ptr)
  {
    /*
     * Поскольку буфер располагается в пространстве пользователя,
     * обычное присвоение не сработает. Поэтому для записи данных
     * используется функция put_user, которая копирует данные из пространства
     * ядра в пространство пользователя.
     */
    put_user(*(Message_Ptr++), buffer++);
    length--;
    bytes_read++;
  }
#ifdef DEBUG
  printk("Read %d bytes, %d left\n", bytes_read, length);
#endif
  /*
   * Вернуть количество байт, помещенных в буфер.
   */
  return bytes_read;
}

/*
 * Вызывается при попытке записи в файл устройства
 */
static ssize_t device_write(struct file *file, const char __user * buffer,
                            size_t length, loff_t * offset)
{
  int i;

#ifdef DEBUG
  printk("device_write(%p,%s,%d)", file, buffer, length);
#endif
  for (i = 0; i &lt; length && i &lt; BUF_LEN; i++)
    get_user(Message[i], buffer + i);
  Message_Ptr = Message;
  /*
   * Вернуть количество принятых байт
   */
  return i;
}

/*
 * Вызывается, когда процесс пытается выполнить операцию ioctl над файлом
 * устройства. Кроме inode и структуры file функция получает
 * два дополнительных параметра: номер ioctl и дополнительные аргументы.
 */
int device_ioctl(struct inode *inode, /* см. include/linux/fs.h */
                 struct file *file,        /* то же самое */
                 unsigned int ioctl_num,   /* номер и аргументы ioctl */
                 unsigned long ioctl_param)
{
  int i;
  char *temp;
  char ch;

  /*
   * Реакция на различные команды ioctl.
   */
  switch (ioctl_num)
  {
    case IOCTL_SET_MSG:
    /*
     * Принять указатель на сообщение (в пространстве пользователя)
     * и переписать в буфер, адрес которого задан в дополнительно аргументе.
     */
      temp = (char *)ioctl_param;
      /*
       * Найти длину сообщения.
       */
      get_user(ch, temp);
      for (i=0; ch && i &lt; BUF_LEN; i++,temp++) get_user(ch,temp);
      device_write(file, (char *)ioctl_param, i, 0);
      break;
    case IOCTL_GET_MSG:
      /*
       * Передать текущее сообщение вызывающему процессу:
       * записать по указанному адресу.
       */
      i = device_read(file, (char *)ioctl_param, 99, 0);
      /*
       * Вставить в буфер завершающий символ \0.
       */
      put_user(&#39;\0&#39;, (char *)ioctl_param + i);
      break;
    case IOCTL_GET_NTH_BYTE:
      /*
       * Этот вызов является вводом (ioctl_param) и
       * выводом (возвращаемое значение функции) одновременно.
       */
      return Message[ioctl_param];
      break;
    }
  return SUCCESS;
}

/* Объявлнеия */
/*
 * В этой структуре хранятся адреса функций-обработчиков операций,
 * производимых процессом над устройством.
 * Поскольку указатель на эту структуру хранится в таблице устройств,
 * она не может быть локальной для init_module.
 * Отсутствующие указатели в структуре забиваются значением NULL.
 */
struct file_operations Fops =
{
  .read = device_read,
  .write = device_write,
  .ioctl = device_ioctl,
  .open = device_open,
  .release = device_release,    /* оно же close */
};

/*
 * Инициализация модуля: регистрация символьного устройства
 */
int init_module()
{
  int ret_val;
  /*
   * Регистрация символьного устройства (по крайней мере попытка регистрации)
   */

  ret_val = register_chrdev(MAJOR_NUM, DEVICE_NAME, &Fops);
  /*
   * Отрицательное значение означает ошибку
   */
  if (ret_val &lt; 0)
  {
     printk("%s failed with %d\n",
            "Sorry, registering the character device ", ret_val);
     return ret_val;
  }
  printk("%s The major device number is %d.\n",
         "Registeration is a success", MAJOR_NUM);
  printk("If you want to talk to the device driver,\n");
  printk("you&#39;ll have to create a device file. \n");
  printk("We suggest you use:\n");
  printk("mknod %s c %d 0\n", DEVICE_FILE_NAME, MAJOR_NUM);
  printk("The device file name is important, because\n");
  printk("the ioctl program assumes that&#39;s the\n");
  printk("file you&#39;ll use.\n");
  return 0;
}

/*
 * Завершение работы модуля - дерегистрация файла в /proc
 */
void cleanup_module()
{
  int ret;

  /*
   * Отмена регистрации устройства.
   */
  ret = unregister_chrdev(MAJOR_NUM, DEVICE_NAME);

  /*
   * Если обнаружена ошибка, вывести сообщение.
   */
  if (ret &lt; 0) printk("Error in module_unregister_chrdev: %d\n", ret);
}
</pre>

<a name="AEN671"></a><p><strong>Пример 6-2. chardev.h</strong></p>
<pre>
/*
 *  chardev.h - определения ioctl.
 *
 *  Определения, которые здесь находятся, должны помещаться в заголовочный
 *  файл потому, что они потребуются как модулю ядра (chardev.c), так и
 *  вызывающему процессу (ioctl.c)
 */
#ifndef CHARDEV_H
#define CHARDEV_H
#include &lt;linux/ioctl.h>

/*
 * Старший номер устройства. В случае использования ioctl, мы уже
 * лишены возможности воспользоваться динамическим номером, поскольку он
 * должен быть известен заранее.
 */
#define MAJOR_NUM 100

/*
 * Операция передачи сообщения драйверу устройства.
 */
#define IOCTL_SET_MSG _IOR(MAJOR_NUM, 0, char *)
/*
 * _IOR означает, что команда передает данные
 * от пользовательского процесса к модулю ядра.
 *
 * Первый аргумент: MAJOR_NUM, старший номер устройства.
 * Второй аргумент: код команды (можно указать иное значение).
 * Третий аргумент задает тип данных, передаваемых в ядро.
 */

/*
 * Операция получения сообщения от драйвера устройства
 */
#define IOCTL_GET_MSG _IOR(MAJOR_NUM, 1, char *)
/*
 * Эта команда IOCTL используется для вывода данных.
 * Нам по-прежнему нужен буфер, размещенный в адресном пространстве
 * вызывающего процесса, куда это сообщение должно быть переписано.
 */

/*
 * Команда получения n-ного байта сообщения.
 */
#define IOCTL_GET_NTH_BYTE _IOWR(MAJOR_NUM, 2, int)
/*
 * Здесь команда IOCTL работает как на ввод, так и на вывод.
 * Она принимает от пользователя номер байта (n),
 * и возвращает n-ный байт сообщения (Message[n]).
 */

/*
 * Имя файла устройства
 */
#define DEVICE_FILE_NAME "char_dev"
#endif
</pre>

<a name="AEN674"></a><p><strong>Пример 6-3. ioctl.c</strong></p>
<pre>
/*
 * ioctl.c - Пример программы, использующей ioctl для
 *           управления модулем ядра.
 * До сих пор мы пользовались командой cat, для передачи данных в/из модуля.
 * Теперь же мы должны написать свою программу, которая использовала бы ioctl.
 */

/*
 * Определения старшего номера устройства и коды операций ioctl.
 */
#include "chardev.h"
#include &lt;fcntl.h>      /* open */
#include &lt;unistd.h>     /* exit */
#include &lt;sys/ioctl.h>  /* ioctl */

/*
 * Функции работы с драйвером через ioctl.
 */
ioctl_set_msg(int file_desc, char *message)
{
  int ret_val;

  ret_val = ioctl(file_desc, IOCTL_SET_MSG, message);
  if (ret_val &lt; 0)
  {
     printf("Ошибка при вызове ioctl_set_msg: %d\n", ret_val);
     exit(-1);
  }
}

ioctl_get_msg(int file_desc)
{
  int ret_val;
  char message[100];

  /*
   * Внимание! Ядро понятия не имеет какой длины буфер мы используем,
   * поэтому возможна ошибка, связанная с переполнением буфера.
   * В реальных проектах необходимо предусмотреть передачу в ioctl
   * двух дополнительных параметров: собственно буфера сообщения и его длины.
   */
  ret_val = ioctl(file_desc, IOCTL_GET_MSG, message);
  if (ret_val &lt; 0)
  {
     printf("Ошибка при вызове ioctl_get_msg: %d\n", ret_val);
     exit(-1);
  }
  printf("Получено сообщение (get_msg): %s\n", message);
}

ioctl_get_nth_byte(int file_desc)
{
  int i;
  char c;

  printf("N-ный байт в сообщении (get_nth_byte): ");
  i = 0;
  while (c != 0)
  {
    c = ioctl(file_desc, IOCTL_GET_NTH_BYTE, i++);
    if (c &lt; 0)
    {
      printf("Ошибка при вызове ioctl_get_nth_byte на %d-м байте.\n", i);
      exit(-1);
    }
    putchar(c);
  }
  putchar(&#39;\n&#39;);
}

/*
 * Main - Проверка работоспособности функции ioctl.
 */
main()
{
  int file_desc, ret_val;
  char *msg = "Это сообщение передается через ioctl\n";

  file_desc = open(DEVICE_FILE_NAME, 0);
  if (file_desc &lt; 0)
  {
     printf("Невозможно открыть файл устройства: %s\n", DEVICE_FILE_NAME);
     exit(-1);
  }
  ioctl_get_nth_byte(file_desc);
  ioctl_get_msg(file_desc);
  ioctl_set_msg(file_desc, msg);
  close(file_desc);
}
</pre>

<a name="AEN677"></a><p><strong>Пример 6-4. Makefile</strong></p>
<pre>
obj-m += chardev.o
</pre>

<p>Для облегчения сборки примера, предлагается скрипт, который
выполнит эту работу за Вас:</p>

<a name="AEN681"></a><p><strong>Пример 6-5. build.sh</strong></p>
<pre>
#/bin/sh
# сборка пользовательского приложения
gcc -o ioctl ioctl.c

# создание файла устройства
mknod char_dev c 100 0
</pre>

<hr><h1><a name="CHAPTER7"></a>Глава 7. Системные вызовы</h1>
<p>До сих пор все, что Вы делали, это использовали ранее определенные
механизмы ядра для регистрации файлов в файловой системе <tt>/proc</tt> и
файлов устройств. Это все замечательно, но это годится только для создания
драйверов устройств. А что если Вы хотите сделать действительно что-то
необычное, например изменить реакцию системы на какое-либо событие?</p>

<p>Мы как раз вступаем в ту область, где программирование действительно
становится опасным. При разработке примера, приведенного ниже, я уничтожил
системный вызов <tt>open</tt>. В результате система потеряла возможность
открывать любые файлы, что равносильно отказу системы выполнять любые
программы. Я не мог даже остановить систему командой
<strong>shutdown</strong>. Из-за этого пришлось прибегнуть к помощи кнопки
выключения питания. К счастью, ни один файл не был уничтожен. Чтобы
обезопасить себя от потери данных в аналогичных ситуациях перед загрузкой
подобных модулей выполняйте резервное копирование.</p>

<p>Забудьте про <tt>/proc</tt>, забудьте и про файлы устройств.
<span><em>Реальный</em></span> механизм взаимодействия процессов с ядром:
системные вызовы. Когда процесс запрашивает какую-либо услугу ядра (например,
открытие файла, запуск нового процесса или выделение дополнительной памяти),
используется механизм системных вызовов. Если Вы хотите изменить поведение
ядра, то системные вызовы это как раз то место, куда можно приложить свои
знания и умения. Между прочим, если Вы захотите увидеть какие системные
вызовы используются той или иной программой, запустите <strong>strace
&lt;command> &lt;arguments></strong>.</p>

<p>Строго говоря, процесс не имеет доступа в пространство ядра. Он не может
обращаться к памяти ядра и не может вызывать функции в ядре. Процессор
ограничивает такого рода доступ на аппаратном уровне (поэтому режим
выполнения ядра называется <span><em>защищенным</em></span>
или <span><em>привилегированным</em></span>).</p>

<p>Системные вызовы являются исключением из этого правила. Чтобы выполнить
системный вызов, процесс заполняет регистры соответствующими значениями и
выполняет специальную инструкцию, которая производит переход в
предопределенное место в пространстве ядра (разумеется, точка перехода
доступна пользовательским процессам на чтение). Для платформы Intel это
инструкция прерывания с вектором 0x80. Процессор воспринимает это как переход
из ограниченного пользовательского режима в защищенный режим ядра, где
позволено делать все, что заблагорассудится.</p>

<p>Точка перехода в ядре называется <tt>system_call</tt>. Процедура, которая
там находится, проверяет номер системного вызова, который сообщает ядру какую
именно услугу запрашивает процесс. Затем, она просматривает таблицу системных
вызовов (<tt>sys_call_table</tt>), отыскивает адрес функции ядра, которую
следует вызвать, после чего вызывается нужная функция. По окончании работы
системного вызова, выполняется ряд дополнительных проверок, и лишь после
этого управление возвращается вызвавшему процессу (или другому процессу, если
вызвавший процесс исчерпал свой квант времени). Код, выполняющий все
вышеперечисленные действия, Вы найдете в файле
<tt>arch/&lt;architecture>/kernel/entry.S</tt>, после строки
<tt>ENTRY(system_call)</tt>.</p>

<p>Итак, если нужно изменить поведение некоторого системного вызова, то
первое, что необходимо сделать, это написать собственную функцию, которая
выполняла бы требуемые действия (обычно после выполнения своих действий в
подобных случаях вызывается первоначальная функция, реализующая системный
вызов), затем изменить указатель в <tt>sys_call_table</tt> так, чтобы он
указывал на Вашу функцию. Поскольку Ваш модуль впоследствии может быть
выгружен, следует предусмотреть восстановление системы в ее первоначальное
состояние, чтобы не оставлять ее в нестабильном состоянии. Это делается в
пределах функции <tt>cleanup_module</tt>.</p>

<p>Ниже приводится исходный текст такого модуля. Он наблюдает за выбранным
пользователем и посылает через <tt>printk</tt> сообщение всякий раз, когда
данный пользователь открывает какой-либо файл. Для этого системный вызов
<tt>open()</tt> подменяется функцией с именем <tt>our_sys_open</tt>. Она
проверяет <tt>UID (User ID)</tt> текущего процесса, и если он равен
заданному, то вызывает <tt>printk</tt>, чтобы сообщить имя открываемого
файла, а в заключение вызывает оригинальную функцию <tt>open()</tt> с теми же
параметрами, которая открывает требуемый файл.</p>

<p>Функция <tt>init_module</tt> изменяет соответствующий указатель в
<tt>sys_call_table</tt> и сохраняет его первоначальное значение в переменной.
Функция <tt>cleanup_module</tt> восстанавливает указатель в
<tt>sys_call_table</tt>, используя эту переменную. В данном подходе кроются
свои подводные камни из-за возможности существования нескольких модулей,
перекрывающих один и тот же системный вызов. Представьте себе: имеются два
модуля А и B. Пусть модуль A перекрывает системный вызов <tt>open</tt> своей
функцией <tt>A_open</tt>, а модуль B функцией <tt>B_open</tt>. Первым
загружается модуль A, он заменяет системный вызов <tt>open</tt> на
<tt>A_open</tt>. Затем загружается модуль B, который меняет системный вызов
<tt>A_open</tt> на <tt>B_open</tt>. Модуль B полагает, что он подменил
оригинальный системный вызов, хотя на самом деле был
подменен вызов <tt>A_open</tt>.</p>

<p>Теперь, если модуль B выгрузить первым, то ничего страшного не произойдет:
он просто восстановит запись в таблице <tt>sys_call_table</tt> в значение
<tt>A_open</tt>, который в свою очередь вызывает оригинальную функцию
<tt>sys_open</tt>. Однако, если первым будет выгружен модуль А, а затем B, то
система рухнет. Модуль А восстановит адрес в <tt>sys_call_table</tt>,
указывающий на оригинальную функцию <tt>sys_open</tt>, отсекая таким образом
модуль B от обработки действий по открытию файлов. Затем, когда будет
выгружен модуль B, он восстановит адрес в <tt>sys_call_table</tt> на тот,
который запомнил сам потому, что он считает его оригинальным. То есть, вызовы
будут направлены в функцию <tt>A_open</tt>, которой уже нет в памяти! На
первый взгляд, проблему можно решить проверкой совпадает ли адрес в
<tt>sys_call_table</tt> с адресом нашей функции <tt>open</tt>, и если не
совпадает, то не восстанавливать значение этого вызова (таким образом B не
будет восстанавливать системный вызов), но это порождает другую проблему.
Когда выгружается модуль А, он видит, что системный вызов был изменен на
<tt>B_open</tt> и отказывается от восстановления указателя на
<tt>sys_open</tt>. Теперь функция <tt>B_open</tt> будет по-прежнему пытаться
вызывать <tt>A_open</tt>, которой больше не существует в памяти, так что
система рухнет еще раньше, до удаления модуля B.</p>

<p>Обратите внимание: подобные проблемы делают такую подмену системных
вызовов неприменимой для широкого распространения. С целью предотвращения
потенциальной опасности, связанной с подменой адресов системных вызовов, ядро
более не экспортирует <tt>sys_call_table</tt>. Поэтому, если Вы желаете
сделать нечто большее, чем просто пробежать глазами по тексту данного
примера, надлежит наложить патч на ядро. В каталоге с примерами Вы найдете
файл <tt>README</tt> и патч. Как Вы наверняка понимаете, подобные модификации
сопряжены с определенными трудностями, поэтому я не рекомендую производить их
на системах, владельцем которых Вы не являетесь или не в состоянии быстро все
восстановить. Если Вас одолевают сомнения, то лучшим выбором будет отказ от
тестирования этого примера.</p>

<a name="AEN741"></a><p><strong>Пример 7-1. syscall.c</strong></p>
<pre>
/*
 * syscall.c - Пример "перехвата" системного вызова.
 * Copyright (C) 2001 by Peter Jay Salzman
 */
/*
 * Необходимые заголовочные файлы
 */
#include &lt;linux/kernel.h>      /* Все-таки мы работаем с ядром! */
#include &lt;linux/module.h>      /* Необходимо для любого модуля */
#include &lt;linux/moduleparam.h> /* для передачи параметров модулю */
#include &lt;linux/unistd.h>      /* Список системных вызовов */
/*
 * Необходимо, чтобы уметь определять user id вызвавшего процесса.
 */
#include &lt;linux/sched.h>
#include &lt;asm/uaccess.h>
/*
 * Таблица системных вызовов (таблица адресов функций).
 * Просто определим ее как ссылку на внешнюю таблицу.
 *
 * sys_call_table больше не экспортируется ядрами 2.6.x.
 * Если Вы намереваетесь опробовать этот ОПАСНЫЙ модуль,
 * следует наложить патч на ядро и перекомпилировать его.
 */
extern void *sys_call_table[];
/*
 * UID пользователя, за которым наблюдаем, принимается из командной строки.
 */
static int uid;
module_param(uid, int, 0644);
/*
 * Указатель на оригинальную функцию, выполняющую системный вызов.
 * Мы сохраняем ее вместо того, чтобы напрямую вызывать оригинальную
 * функцию для того, чтобы имелась возможность вызова
 * обработчиков, вставленных до нас.
 * Это не гарантирует 100% безопасность, поскольку другой модуль,
 * замещающий sys_open может быть выгружен раньше нашего модуля.
 *
 * Другая причина: мы не можем получить адрес оригинальной функции sys_open.
 * Этот адрес не экспортируется ядром.
 */
asmlinkage int (*original_call) (const char *, int, int);
/*
 * Функция, замещающая sys_open (вызывается всякий раз, когда делается
 * обращение к системному вызову open). Прототип функции, количество
 * аргументов и их типы Вы найдете в fs/open.c.
 *
 * Теоретически мы привязаны к данной конкретной версии ядра. Практически же
 * системные вызовы очень редко подвергаются кардинальному изменению,
 * поскольку это сделало бы огромное количество программного обеспечения
 * несовместимым с ядром и потребовало бы их переделки.
 */
asmlinkage int our_sys_open(const char *filename, int flags, int mode)
{
  int i = 0;
  char ch;

  /*
   * Проверить -- это искомый пользователь?
   */
  if (uid == current->uid)
  {
     /*
     * Зафиксировать
     */
     printk("Opened file by %d: ", uid);
     do
     {
       get_user(ch, filename + i);
       i++;
       printk("%c", ch);
     } while (ch != 0);
     printk("\n");
  }
  /*
   * Вызвать оригинальную версию системного вызова sys_open, иначе
   * система потеряет возможность открывать файлы.
   */
  return original_call(filename, flags, mode);
}

/*
 * Инициализация модуля: подмена системного вызова
 */
int init_module()
{
  /*
   * Внимание: предупреждение запоздало, но может быть в следующий раз...
   */
  printk("I&#39;m dangerous. I hope you did a ");
  printk("sync before you insmod&#39;ed me.\n");
  printk("My counterpart, cleanup_module(), is even");
  printk("more dangerous. If\n");
  printk("you value your file system, it will ");
  printk("be \"sync; rmmod\" \n");
  printk("when you remove this module.\n");
  /*
   * Сохранить указатель на оригинальную функцию
   * в переменной original_call, а затем заменить указатель
   * в таблице системных вызовов.
   */
  original_call = sys_call_table[__NR_open];
  sys_call_table[__NR_open] = our_sys_open;
  /*
   * Чтобы получить адрес любого системного вызова
   * с именем foo, обращайтесь к записи sys_call_table[__NR_foo].
   */
  printk("Spying on UID:%d\n", uid);
  return 0;
}

/*
 * Завершение работы модуля: восстановление указателя на
 * оригинальный системный вызов.
 */
void cleanup_module()
{
  /*
   * Восстановить адрес системного вызова
   */
  if (sys_call_table[__NR_open] != our_sys_open)
  {
     printk("Somebody else also played with the ");
     printk("open system call\n");
     printk("The system may be left in ");
     printk("an unstable state.\n");
  }
  sys_call_table[__NR_open] = original_call;
}
</pre>

<a name="AEN744"></a><p><strong>Пример 7-2. Патч для ядра
(export_sys_call_table_patch_for_linux_2.6.x)</strong></p>
<pre>
--- kernel/kallsyms.c.orig     2003-12-30 07:07:17.000000000 +0000
+++ kernel/kallsyms.c   2003-12-30 07:43:43.000000000 +0000
@@ -184,7 +184,7 @@
                iter->pos = pos;
                return get_ksymbol_mod(iter);
        }
-
+
  /* If we&#39;re past the desired position, reset to start. */
  if (pos &lt; iter->pos) reset_iter(iter);
@@ -291,3 +291,11 @@
  EXPORT_SYMBOL(kallsyms_lookup);
  EXPORT_SYMBOL(__print_symbol);
+/* START OF DIRTY HACK:
+ * Purpose: enable interception of syscalls as shown in the
+ * Linux Kernel Module Programming Guide. */
+extern void *sys_call_table;
+EXPORT_SYMBOL(sys_call_table);
+ /* see http://marc.free.net.ph/message/20030505.081945.fa640369.html
+  * for discussion why this is a BAD THING(tm) and no longer supported by 2.6.0
+  * END OF DIRTY HACK: USE AT YOUR OWN RISK */
</pre>

<a name="AEN747"></a><p><strong>Пример 7-3. Makefile</strong></p>
<pre>
obj-m += syscall.o
</pre>

<a name="AEN750"></a><p><strong>Пример 7-4. README.txt</strong></p>
<pre>
Основная проблема, связанная с данным примером, состоит в невозможности
определить адрес sys_call_table, поскольку он больше
не экспортируется ядрами 2.6.x.

Возможность перекрытия системных вызовов через sys_call_table потенциально
опасна поэтому, начиная с версии 2.5.41, она больше не поддерживается.

Обсуждение проблемы Вы найдете на:
  http://www.ussg.iu.edu/hypermail/linux/kernel/0305.0/0711.html
  http://marc.free.net.ph/message/20030505.081945.fa640369.html
  http://marc.theaimsgroup.com/?l=linux-kernel&m=105212296015799&w=2

Чтобы иметь возможность опробовать данный пример на ядрах версий 2.5.41
или выше необходимо наложить патч на ядро.

ВНИМАНИЕ:
  НЕ ИСПОЛЬЗУЙТЕ ЭТОТ ПАТЧ НА ПРОМЫШЛЕННЫХ ИЛИ ИНЫХ СИСТЕМАХ,
  КОТОРЫЕ СОДЕРЖАТ ЦЕННУЮ ИНФОРМАЦИЮ.

Если бы я писал встроенную справку к этому патчу в Configure.help, то я бы
пометил ее как &lt;dangerous> и дал бы следующее описание:

#######################################################################
Эта опция экспортирует sys_call_table, что делает возможным перекрытие
(подмену) системных вызовов. Подмена системных вызовов потенциально опасна
и может стать причиной потери данных.

Скажите Y, если желаете опробовать прилагаемый пример, и Вас не беспокоит
возможная потеря данных.

Практически любой должен здесть сказать N.
#######################################################################

Если Ваш PC используется только как игрушка, можете наложить этот
патч и опробовать пример.

Предполагается, что исходные тексты ядра 2.6.x находятся в каталоге
/usr/src/linux
(http://www.linuxmafia.com/faq/Kernel/usr-src-linux-symlink.html)

Ниже приводится текст скрипта, выполняющего наложение патча.

Этот патч протестирован с ядрами 2.6.[0123] и может накладываться или
не накладываться на другие версии.

#!/bin/sh
cp export_sys_call_table_patch_for_linux_2.6.x /usr/src/linux/
cd /usr/src/linux/
patch -p0 &lt; export_sys_call_table_patch_for_linux_2.6.x
</pre>

<hr><h1><a name="CHAPTER8"></a>Глава 8. Блокировка процессов</h1>
<p>Что Вы делаете, когда кто-то просит Вас о чем-то, а Вы не можете сделать
это немедленно? Пожалуй единственное, что Вы можете ответить: "Пожалуйста, не
сейчас, я пока занят.". А что должен делать модуль ядра? У него есть другая
возможность. Он может приостановить работу процесса до тех пор, пока не
сможет обслужить его. В конечном итоге, ядро постоянно то приостанавливает,
то вновь возобновляет работу процессов. Именно так обеспечивается возможность
одновременного исполнения нескольких процессов на единственном процессоре.
</p>

<p>Пример ниже демонстрирует такую возможность. Модуль создает файл
<tt>/proc/sleep</tt>, который может быть открыт только одним процессом, в
каждый конкретный момент времени. Если файл уже был открыт кем-нибудь, то
модуль вызывает <tt>wait_event_interruptible</tt>.
<a name="AEN759" href="#FTN.AEN759"><span>[10]</span></a> Эта функция
изменяет состояние задачи (здесь под термином "задача" понимается структура
данных в ядре, которая хранит информацию о процессе), присваивая ему значение
<tt>TASK_INTERRUPTIBLE</tt>, это означает, что задача не будет выполняться до
тех пор, пока не будет разбужена каким-либо образом, и добавляет процесс в
очередь ожидания <tt>WaitQ</tt>, куда помещаются все процессы, желающие
открыть файл <tt>/proc/sleep</tt>. Затем функция передает управление
планировщику, который в свою очередь предоставляет возможность
поработать другому процессу.</p>

<p>Когда процесс закрывает файл, это приводит к вызову функции
<tt>module_close</tt>. Она запускает все процессы, которые сидят в очереди
<tt>WaitQ</tt> (к сожалению, нет механизма, который позволил бы разбудить
только один процесс). Затем управление возвращается процессу, который только
что закрыл файл, и он продолжает свою работу. После того, как данный процесс
исчерпает свой квант времени, планировщик передаст управление другому
процессу. Таким образом, один из процессов, ожидавших своей очереди доступа к
файлу, в конечном итоге получит управление и продолжит исполнение с точки,
следующей за вызовом <tt>wait_event_interruptible</tt>. <a name="AEN769"
href="#FTN.AEN769"><span>[11]</span></a> Он установит глобальную переменную,
извещающую остальные процессы о том, что файл открыт, и займется обработкой
открытого файла. Когда другие процессы получат свой квант времени, они
обнаружат, что файл все еще открыт и опять приостановят свою работу.</p>

<p>Чтобы как-то оживить повествование замечу, что <tt>module_close</tt> не
обладает монопольным правом на возобновление работы ожидающих процессов.
Сигнал Ctrl-C (SIGINT) также может разбудить процесс. <a name="AEN773"
href="#FTN.AEN773"><span>[12]</span></a> В этом случае процессу немедленно
возвращается <tt>-EINTR</tt>. Таким образом пользователи могут, например,
прервать процесс прежде, чем он получит доступ к файлу.</p>

<p>Тут есть еще один момент, о котором хотелось бы упомянуть. Некоторые
процессы не желают быть заблокированными, такие процессы должны либо получить
в свое распоряжение открытый файл немедленно, либо извещение о том, что их
запрос не может быть удовлетворен в настоящий момент. Такие процессы
используют флаг <tt>O_NONBLOCK</tt> при открытии файла. Если ядро не в
состоянии немедленно удовлетворить запрос, оно отвечает
кодом ошибки <tt>-EAGAIN</tt>.</p>

<a name="AEN781"></a><p><strong>Пример 8-1. sleep.c</strong></p>
<pre>
/*
 * sleep.c. - Создает файл в /proc, доступ к которому может получить
 * только один процесс, все остальные будут приостановлены.
*/
#include &lt;linux/kernel.h> /* Все-таки мы работаем с ядром! */
#include &lt;linux/module.h> /* Необходимо для любого модуля */
#include &lt;linux/proc_fs.h>  /* Необходимо для работы с /proc */
#include &lt;linux/sched.h>  /* Взаимодействие с планировщиком */
#include &lt;asm/uaccess.h>  /* определение функций get_user и put_user */
/*
 * Место хранения последнего принятого сообщения,
 * которое будет выводиться в файл, чтобы показать, что
 * модуль действительно может получать ввод от пользователя.
 */
#define MESSAGE_LENGTH 80
static char Message[MESSAGE_LENGTH];
static struct proc_dir_entry *Our_Proc_File;
#define PROC_ENTRY_FILENAME "sleep"

static ssize_t module_output(struct file *file,
                             /* см. include/linux/fs.h   */
                             char *buf,
                             /* буфер с данными (в пространстве пользователя) */
                             size_t len,   /* размер буфера */
                             loff_t * offset)
{
  static int finished = 0;
  int i;
  char message[MESSAGE_LENGTH + 30];

  /*
   * Для индикации признака конца файла возвращается 0.
   * В противном случае процесс будет продолжать читать из файла
   * попав в бесконечный цикл.
  */
  if (finished)
  {
     finished = 0;
     return 0;
  }
  /*
   * Для передачи данных из пространства ядра в пространство пользователя
   * следует использовать put_user.
   * В обратном направлении get_user.
  */
  sprintf(message, "Last input:%s\n", Message);
  for (i = 0; i &lt; len && message[i]; i++)
    put_user(message[i], buf + i);
  finished = 1;
  return i;    /* Вернуть количество прочитанных байт */
}

/*
 * Эта функция принимает введенное пользователем сообщение
*/
static ssize_t module_input(struct file *file,  /* Собственно файл */
                            const char *buf,    /* Буфер с сообщением */
                            size_t length,      /* размер буфера */
                            loff_t * offset)
                            /* смещение в файле игнорируется */
{
  int i;

  /*
   * Переместить данные, полученные от пользователя в буфер,
   * который позднее будет выведен функцией module_output.
  */
  for (i = 0; i &lt; MESSAGE_LENGTH - 1 && i &lt; length; i++)
    get_user(Message[i], buf + i);
  /* Обычная строка, завершающаяся символом \0 */
  Message[i] = &#39;\0&#39;;
  /*
   * Вернуть число принятых байт.
  */
  return i;
}

/*
 * 1 если файл открыт.
 */
int Already_Open = 0;

/*
 * Очередь для ожидания.
 */
DECLARE_WAIT_QUEUE_HEAD(WaitQ);
/*
 * Вызывается при открытии файла в /proc.
 */
static int module_open(struct inode *inode, struct file *file)
{
  /*
   * Если установлен флаг O_NONBLOCK, то процесс не должен останавливаться.
   * В этом случае, если файл уже открыт, необходимо вернуть код ошибки
   * -EAGAIN, что означает "попробуйте в другой раз".
  */
  if ((file->f_flags & O_NONBLOCK) && Already_Open)
     return -EAGAIN;
  /*
   * Нарастить счетчик обращений, чтобы невозможно было выгрузить модуль.
  */
  try_module_get(THIS_MODULE);
  /*
   * Если файл открыт, приостановить процесс.
  */
  while (Already_Open)
  {
    int i, is_sig = 0;
    /*
     * Эта функция приостановит процесс и поместит его в очередь ожидания.
     * Исполнение процесса будет продолжено с точки, следующей за вызовом
     * этой функции, когда кто-нибудь сделает вызов wake_up(&WaitQ) (это
     * возможно только внутри module_close, когда файл будет закрыт) или
     * когда процессу поступит сигнал Ctrl-C.
    */
    wait_event_interruptible(WaitQ, !Already_Open);
    for (i = 0; i &lt; _NSIG_WORDS && !is_sig; i++)
    is_sig = current->pending.signal.sig[i] & ~current->
             blocked.sig[i];
    if (is_sig)
    {
       /*
       * Не забыть вызвать здесь module_put(THIS_MODULE),
       * поскольку процесс был прерван и никогда не вызовет функцию close.
       * Если не уменьшить счетчик обращений, то он навсегда останется
       * большим нуля, в результате модуль можно будет
       * уничтожить только при перезагрузке системы.
       */
       module_put(THIS_MODULE);
       return -EINTR;
    }
  }
  /*
   * В этой точке переменная Already_Open должна быть равна нулю.
   * Надо открыть файл.
  */
  Already_Open = 1;
  return 0;
}

/*
 * Вызывается при закрытии файла.
 */
int module_close(struct inode *inode, struct file *file)
{
  /*
   * Записать ноль в Already_Open, тогда один из процессов из WaitQ
   * сможет записать туда единицу и открыть файл. Все остальные
   * процессы, ожидающие доступа к файлу, опять будут приостановлены.
  */
  Already_Open = 0;
  /*
   * Возобновить работу процессов из WaitQ.
  */
  wake_up(&WaitQ);
  module_put(THIS_MODULE);
  return 0;
}

/*
 * Эта функция принимает решение о праве на выполнение операций с файлом:
 * 0: разрешено, ненулеое значение: запрещено.
 *
 * Операции с файлом могут быть:
 * 0 - Исполнениe (не имеет смысла в нашей ситуации)
 * 2 - Запись (передача от пользователя модулю ядра)
 * 4 - Чтение (передача от модуля ядра пользователю)
 *
 * Эта функция проверяет права доступа к файлу.
 * Права, выводимые командой ls -l,
 * могут быть проигнорированы здесь.
 */
static int module_permission(struct inode *inode, int op,
                             struct nameidata *nd)
{
  /*
   * Позволим любому читать файл, но записывать только root (uid 0).
  */
  if (op == 4 || (op == 2 && current->euid == 0)) return 0;
  /*
   * Если иное, запретить доступ.
  */
  return -EACCES;
}

/*
 * Указатели на функции-обработчики для нашего файла.
*/
static struct file_operations File_Ops_4_Our_Proc_File =
{
  .read = module_output,    /* чтение из файла */
  .write = module_input,    /* запись в файл */
  .open = module_open,      /* открытие файла */
  .release = module_close,  /* закрытие файла */
};

/*
 * Операции над индексной записью нашего файла. Необходимы
 * для того, чтобы указать местоположение структуры
 * file_operations нашего файла, а так же чтобы задать функцию
 * определения прав доступа к файлу. Здесь можно указать адреса
 * других функций-обработчиков, но нас они не интересуют.
 */
static struct inode_operations Inode_Ops_4_Our_Proc_File =
{
  .permission = module_permission,      /* check for permissions */
};
/*
 * Начальная и конечная функции модуля.
 * Инициализация модуля: регистрация файла в /proc.
 */
int init_module()
{
  int rv = 0;

  Our_Proc_File = create_proc_entry(PROC_ENTRY_FILENAME, 0644, NULL);
  Our_Proc_File->owner = THIS_MODULE;
  Our_Proc_File->proc_iops = &Inode_Ops_4_Our_Proc_File;
  Our_Proc_File->proc_fops = &File_Ops_4_Our_Proc_File;
  Our_Proc_File->mode = S_IFREG | S_IRUGO | S_IWUSR;
  Our_Proc_File->uid = 0;
  Our_Proc_File->gid = 0;
  Our_Proc_File->size = 80;
  if (Our_Proc_File == NULL)
  {
     rv = -ENOMEM;
     remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root);
     printk(KERN_INFO "Error: Could not initialize /proc/test\n");
  }
  return rv;
}

/*
 * Завершение работы модуля: удаление файла из /proc. Чревато проблемами,
 * если в WaitQ остаются процессы, ожидающие своей очереди, поскольку точка
 * их исполнения практически находится в функции open, которая будет
 * выгружена при удалении модуля. Позднее, в 9 главе, я опишу, как
 * воспрепятствовать удалению модуля в таких случаях
 */
void cleanup_module()
{
  remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root);
}
</pre>

<hr><h1><a name="CHAPTER9"></a>Глава 9. Замена <tt>printk</tt></h1>
<h1><a name="REPLACINGPRINTKS"></a>9.1. Замена <tt>printk</tt></h1>
<p>Ранее я уже говорил о том, что X Window и разработка модулей ядра
являются несовместимыми вещами. Это все так, но иногда возникает
необходимость выдачи сообщений от модуля на любой tty. <a name="AEN795"
href="#FTN.AEN795"><span>[13]</span></a></p>

<p>В качестве одного из вариантов можно предложить следующее: используя
указатель на текущий исполняемый процесс, <tt>current</tt>, получить
структуру <tt>tty</tt>. Затем извлечь из этой структуры указатель на функцию
вывода строки и использовать ее для выдачи сообщений.</p>

<a name="AEN800"></a><p><strong>Пример 9-1. print_string.c</strong></p>
<pre>
/*
 *  print_string.c отправляет вывод на tty терминала, независимо от того
 *  X11 это, telnet или что-то еще. Делается это путем вывода строки на tty,
 *  ассоциированный с текущим процессом.
 */
#include &lt;linux/kernel.h>
#include &lt;linux/module.h>
#include &lt;linux/init.h>
#include &lt;linux/sched.h>   /* определение current */
#include &lt;linux/tty.h>     /* определение tty */
#include &lt;linux/version.h> /* макрос LINUX_VERSION_CODE */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Peter Jay Salzman");

static void print_string(char *str)
{
  struct tty_struct *my_tty;
  /*
   * Начиная с версии 2.6.6, структура tty перенесена в структуру signal
   */
#if (LINUX_VERSION_CODE &lt;= KERNEL_VERSION(2,6,5))
  /*
   * tty текущего процесса
   */
  my_tty = current->tty;
#else
  /*
   * tty текущего процесса для ядер версий 2.6.6 и выше
   */
  my_tty = current->signal->tty;
#endif
  /*
   * Если my_tty == NULL, то текущий процесс не имеет tty, на который можно
   * было бы что-нибудь вывести (например, это демон). В этом случае
   * нам ничего не нужно делать.
  */
  if (my_tty != NULL)
  {
     /*
      * my_tty->driver: структура, которая хранит указатели на
      * функции-обработчики, одна из которых (write) используется для
      * вывода строк на tty.
      * Первый параметр функции: tty, на который осуществляется вывод,
      * поскольку эта функция обычно используется для вывода на все
      * tty одного и того же типа.
      * Второй параметр: флаг расположения строки,
      * если строка находится в пространстве ядра, флаг равен false (0), а
      * если в пространстве пользователя, то true (не ноль).
      * Третий параметр: указатель на строку.
      * Четвертый параметр: длина строки.
      */
     ((my_tty->driver)->write) (my_tty,  /* Собственно tty  */
             0,                         /* Строка в пространстве ядра */
             str,                       /* Сама строка */
             strlen(str));              /* Длина строки */

     /*
      * tty изначально был аппаратным устройством, который (обычно)
      * ограничивался стандартом ASCII, в котором перевод строки
      * включал в себя два символа "возврат каретки" и "перевод строки".
      * В Unix символ ASCII "перевод строки" заменил оба этих символа,
      * поэтому нам придется использовать для перевода строки оба символа.
      *
      * Это одна из причин различий между текстовыми файлами Unix и
      * MS Windows. CP/M и ее наследницы, например, MS-DOS и
      * MS Windows, строго придерживались стандарта ASCII.
      */
     ((my_tty->driver)->write) (my_tty, 0, "\015\012", 2);
  }
}

static int __init print_string_init(void)
{
  print_string("The module has been inserted. Hello world!");
  return 0;
}

static void __exit print_string_exit(void)
{
  print_string("The module has been removed. Farewell world!");
}
module_init(print_string_init);
module_exit(print_string_exit);
</pre>

<hr><h1><a name="FLASHINGKEYBOARDLEDS"></a>9.2.
Управление индикаторами на клавиатуре</h1>
<p>При определенных условиях может возникнуть необходимость дать модулю более
простой и прямолинейный способ взаимодействия с внешним миром. Изменение
состояния светодиодных индикаторов клавиатуры может быть одним из вариантов
привлечения внимания пользователя или отображения некоторого состояния.
Светодиодные индикаторы присутствуют на любой клавиатуре, они всегда
находятся в поле зрения, они не нуждаются в установке и их переключение
достаточно ненавязчиво, по сравнению с выводом на tty или в файл.</p>

<p>Следующий исходный код иллюстрирует модуль ядра, который после загрузки
начинает мигать индикаторами клавиатуры.</p>

<a name="AEN807"></a><p><strong>Пример 9-2. kbleds.c</strong></p>
<pre>
/*
 *  kbleds.c - Мигание индикаторами на клавиатуре.
*/
#include &lt;linux/module.h>
#include &lt;linux/config.h>
#include &lt;linux/init.h>
#include &lt;linux/tty.h>   /* определение fg_console, MAX_NR_CONSOLES */
#include &lt;linux/kd.h>    /* определение KDSETLED */
#include &lt;linux/console_struct.h> /* определение  vc_cons */

MODULE_DESCRIPTION("Пример module illustrating the use of Keyboard LEDs.");
MODULE_AUTHOR("Daniele Paolo Scarpazza");
MODULE_LICENSE("GPL");

struct timer_list my_timer;
struct tty_driver *my_driver;
char kbledstatus = 0;

#define BLINK_DELAY   HZ/5
#define ALL_LEDS_ON   0x07
#define RESTORE_LEDS  0xFF
/*
 * Функция my_timer_func мигает индикаторами на клавиатуре периодически
 * вызывая ioctl() драйвера клавиатуры с командой KDSETLED. Дополнительную
 * информацию по командам ioctl виртуального терминала Вы найдете в файле
 * /usr/src/linux/drivers/char/vt_ioctl.c, функция vt_ioctl().
 *
 * Дополнительный аргумент команды KDSETLED: значение 7 (перевод в режим
 * LED_SHOW_IOCTL, управление индикаторами через ioctl), значение 0xFF:
 * (любое значение больше 7 переводит в режим LED_SHOW_FLAGS: отображение
 * фактического состояния клавиатуры). Дополнительная информация: файл
 * /usr/src/linux/drivers/char/keyboard.c, функция setledstate().
 */
static void my_timer_func(unsigned long ptr)
{
  int *pstatus = (int *)ptr;

  if (*pstatus == ALL_LEDS_ON) *pstatus = RESTORE_LEDS;
  else *pstatus = ALL_LEDS_ON;
  (my_driver->ioctl) (vc_cons[fg_console].d->vc_tty, NULL, KDSETLED,
          *pstatus);
  my_timer.expires = jiffies + BLINK_DELAY;
  add_timer(&my_timer);
}

static int __init kbleds_init(void)
{
  int i;

  printk(KERN_INFO "kbleds: loading\n");
  printk(KERN_INFO "kbleds: fgconsole is %x\n", fg_console);
  for (i = 0; i &lt; MAX_NR_CONSOLES; i++)
  {
    if (!vc_cons[i].d) break;
    printk(KERN_INFO "poet_atkm: console[%i/%i] #%i, tty %lx\n", i,
           MAX_NR_CONSOLES, vc_cons[i].d->vc_num,
           (unsigned long)vc_cons[i].d->vc_tty);
  }
  printk(KERN_INFO "kbleds: finished scanning consoles\n");
  my_driver = vc_cons[fg_console].d->vc_tty->driver;
  printk(KERN_INFO "kbleds: tty driver magic %x\n", my_driver->magic);
  /*
   * Инициировать таймер
  */
  init_timer(&my_timer);
  my_timer.function = my_timer_func;
  my_timer.data = (unsigned long)&kbledstatus;
  my_timer.expires = jiffies + BLINK_DELAY;
  add_timer(&my_timer);
  return 0;
}

static void __exit kbleds_cleanup(void)
{
  printk(KERN_INFO "kbleds: unloading...\n");
  del_timer(&my_timer);
  (my_driver->ioctl) (vc_cons[fg_console].d->vc_tty, NULL, KDSETLED,
          RESTORE_LEDS);
}
module_init(kbleds_init);
module_exit(kbleds_cleanup);
</pre>

<p>Если ни один из примеров данной главы Вас не устраивает, можно попробовать
другие хитрости, скрытые в ядре. Может быть подойдет опция CONFIG_LL_DEBUG в
<strong>make menuconfig</strong>? Включив ее, Вы получите низкоуровневый
доступ к последовательному порту. Как бы страшно это ни прозвучало, но можете
попробовать изменить реализацию <tt>kernel/printk.c</tt> или какого-нибудь
другого системного вызова для вывода ascii-строк, чтобы иметь возможность
отслеживать действия модуля через последовательную линию связи.</p>

<p>Несмотря на то, что Вы уже встретили в этой книге намало наглядных приемов
отладки, существует еще ряд моментов, которые необходимо знать. Отладка это
всегда очень утомительный процесс и практически всегда он сопровождается
внедрением значительного количества отладочного кода. Может сложиться так,
что отладочный код не дает проявляться некоторым ошибкам. Поэтому при выпуске
Вашего модуля старайтесь свести отладочный код к минимуму и прогнать модуль
еще раз, пытаясь обнаружить какие-либо ошибки.</p>

<hr><h1><a name="CHAPTER10"></a>Глава 10. Планирование задач</h1>
<p>Очень часто возникает необходимость запуска вспомогательных задач по
расписанию. Если запускаемая задача обычный процесс, то помещаем ее в файл
crontab. Если же задача является модулем ядра, то у нас есть две возможности.
Первая состоит в том, чтобы поместить некую задачу в файл crontab, которая
будет будить модуль системным вызовом в заданный момент времени, например,
открывая файл. Это очень неэффективно, так как при запуске нового процесса из
crontab приходится загружать программу в память и все это только для того,
чтобы разбудить модуль ядра, который уже находится в памяти.</p>

<p>Вместо этого мы попробуем создать функцию, которая будет вызываться по
прерываниям от таймера. Для этого создадим задачу
<tt>struct work_struct</tt>. Эта структура будет хранить указатель на
функцию, срабатывающую по таймеру. Затем с помощью
<tt>queue_delayed_work</tt> поместим задачу в очередь <tt>tq_timer</tt>, где
должны располагаться задачи, срабатывающие по таймеру. А так как
предполагается срабатывание функции каждый раз, по истечении заданного
интервала времени, мы должны всякий раз опять вставлять ее в
очередь <tt>tq_timer</tt>.</p>

<p>Еще один немаловажный момент. Когда модуль выгружается командой
<strong>rmmod</strong>, сначала проверяется счетчик обращений к модулю. Если
он равен нулю, то вызывается <tt>module_cleanup</tt>. После чего модуль
удаляется из памяти со всеми его функциями. Никто не проверяет содержит ли
очередь задач таймера указатель на одну из удаляемых функций. По прошествии
некоторого времени (с точки зрения человека практически мгновенно), ядро
получит прерывание от таймера и попробует вызывать удаленную из очереди
задачу. Но функции-то больше нет! В большинстве случаев страница памяти, где
она была, будет рассматриваться как неиспользуемая, и Вы получите сообщение
об ошибке. Но может случиться так, что на этом месте окажется некоторый
другой код, тогда Ваше дело табак. К сожалению, у нас нет достаточно
простого способа удаления задачи из очереди таймера.</p>

<p>Так как <tt>cleanup_module</tt> не может вернуть код ошибки (она не имеет
возвращаемого значения), то напрашивается решение: приостановить процедуру
завершения работы модуля. Вместо того, чтобы немедленно завершить работу
функции <tt>cleanup_module</tt>, мы можем приостановить работу команды
<strong>rmmod</strong>. Затем, установив глобальную переменную, сообщить
функции, вызываемой по прерыванию таймера, чтобы она убрала себя из очереди
(точнее, чтобы она опять не вставляла себя в очередь). На ближайшем
прерывании таймера, процесс <strong>rmmod</strong> будет разбужен, когда
функция удалит себя из очереди таймера и удаление модуля станет безопасным.
</p>

<a name="AEN831"></a><p><strong>Пример 10-1. sched.c</strong></p>
<pre>
/*
 *  sched.c - реализация срабатывания по таймеру.
 *  Copyright (C) 2001 by Peter Jay Salzman
 */
/*
 * Необходимые заголовочные файлы.
 * Обычные для модулей ядра.
 */
#include &lt;linux/kernel.h>    /* Все-таки мы работаем с ядром! */
#include &lt;linux/module.h>    /* Необходимо для любого модуля */
#include &lt;linux/proc_fs.h>   /* Необходимо для работы с /proc */
#include &lt;linux/workqueue.h> /* очереди задач */
#include &lt;linux/sched.h>     /* Взаимодействие с планировщиком */
#include &lt;linux/init.h>      /* макросы  __init и  __exit */
#include &lt;linux/interrupt.h> /* определение irqreturn_t */

struct proc_dir_entry *Our_Proc_File;
#define PROC_ENTRY_FILENAME "sched"
#define MY_WORK_QUEUE_NAME "WQsched.c"
/*
 * Счетчик срабатываний по таймеру
 */
static int TimerIntrpt = 0;
static void intrpt_routine(void *);
static int die = 0;  /* 1 -- завершить работу */
/*
 * Очередь задач, создается для того, чтобы поместить в
 * очередь таймера (workqueue.h)
 */
static struct workqueue_struct *my_workqueue;
static struct work_struct Task;
static DECLARE_WORK(Task, intrpt_routine, NULL);

/*
 * Функция-обработчик прерывания от таймера. Обратите внимание на аргумент
 * типа void*: функция может получать дополнительные аргументы
 * посредством этого указателя.
 */
static void intrpt_routine(void *irrelevant)
{
  /*
   * Нарастить счетчик.
   */
  TimerIntrpt++;
  /*
   * Если признак завершения сброшен, то опять вставить
   * себя в очередь таймера.
   */
  if (die == 0) queue_delayed_work(my_workqueue, &Task, 100);
}

/*
 * Запись данных в файл /proc.
 */
ssize_t procfile_read(char *buffer, char **buffer_location, off_t offset,
                      int buffer_length, int *eof, void *data)
{
  int len;              /* Фактическое число записанных байт */

  /*
   * Переменные объявлены как static, поэтому они располагаются не в стеке
   * функции, а в памяти модуля.
   */
  static char my_buffer[80];
  static int count = 1;
  /*
   * Все сведения выдаются за один раз поэтому, если смещение != 0, значит
   * нам нечего больше сказать, поэтому возвращается 0 в качестве
   * признака конца файла.
   */
  if (offset > 0) return 0;
  /*
   * Заполнить буфер и получить его длину.
   */
  len = sprintf(my_buffer, "Timer called %d times so far\n", TimerIntrpt);
  count++;
  /*
   * Указать адрес буфера.
   */
  *buffer_location = my_buffer;
  /*
   * Вернуть длину буфера.
   */
  return len;
}

/*
 * Функция инициализации - зарегистрировать файл в /proc
 */
int __init init_module()
{
  int rv = 0;

  /*
   * Создать очередь задач с нашей задачей и поместить ее в очередь таймера
   */
  my_workqueue = create_workqueue(MY_WORK_QUEUE_NAME);
  queue_delayed_work(my_workqueue, &Task, 100);
  Our_Proc_File = create_proc_entry(PROC_ENTRY_FILENAME, 0644, NULL);
  Our_Proc_File->read_proc = procfile_read;
  Our_Proc_File->owner = THIS_MODULE;
  Our_Proc_File->mode = S_IFREG | S_IRUGO;
  Our_Proc_File->uid = 0;
  Our_Proc_File->gid = 0;
  Our_Proc_File->size = 80;
  if (Our_Proc_File == NULL)
  {
     rv = -ENOMEM;
     remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root);
     printk(KERN_INFO "Error: Could not initialize /proc/%s\n",
            PROC_ENTRY_FILENAME);
  }
  return rv;
}

/*
 * Завершение работы
 */
void __exit cleanup_module()
{
  /*
   * Удалить файл из /proc.
   */
  remove_proc_entry(PROC_ENTRY_FILENAME, &proc_root);
  printk(KERN_INFO "/proc/%s removed\n", PROC_ENTRY_FILENAME);
  die = 1;   /* Известить функцию обработки прерываний о завершении работы */
  cancel_delayed_work(&Task);
  flush_workqueue(my_workqueue); /* ждать пока отработает таймер */
  destroy_workqueue(my_workqueue);
  /*
   * Приостановить работу, пока intrpt_routine не отработает в последний раз.
   * Это необходимо, поскольку мы освобождаем память,
   * занимаемую этой функцией.
   */
}

/*
 * Некоторые функции, относящиеся к work_queue, доступны только,
 * если модуль лицензирован под GPL.
 */
MODULE_LICENSE("GPL");
</pre>

<hr><h1><a name="CHAPTER11"></a>Глава 11. Обработка прерываний</h1>
<h1><a name="INTERRUPTHANDLERS"></a>11.1. Обработка прерываний</h1>
<p>Везде, кроме предыдущей главы, все наши действия в ядре сводилось к
ответам на разные запросы от процессов, к работе со специальными файлом,
посылке команд ioctl или запуску системных вызовов. Однако работа ядра не
может сводится только к обработке запросов. Еще одна немаловажная задача это
работа с аппаратурой компьютера.</p>

<p>Существует два типа взаимодействий между CPU и остальной аппаратной частью
компьютера. Первый передача команд аппаратным средствам, второй прием ответов
от аппаратуры. Второй тип взаимодействия, прерывания, является наиболее
тяжелым в обработке потому, что прерывания возникают тогда, когда это удобно
устройству, а не CPU. Аппаратные устройства обычно имеют весьма ограниченный
объем памяти, и если не прочитать поставляемую ими информацию немедленно, то
она может потеряться.</p>

<p>В Linux аппаратные прерывания называются <strong>IRQ</strong> (сокращение
от Interrupt ReQuests: запрос на прерывание). Имеется два типа IRQ: короткие
и длинные. Короткие IRQ занимают очень короткий период времени, в течение
которого работа операционной системы будет заблокирована, а также будет
невозможна обработка других прерываний. Длинные IRQ могут занять довольно
продолжительное время, в течение которого могут обрабатываться и другие
прерывания (но не прерывания из того же самого устройства). Поэтому иногда
бывает благоразумным разбить выполнение работы на исполняемую внутри
обработчика прерываний (то есть, подтверждение прерывания, изменение
состояния и прочее) и работу, которая может быть отложена на некоторое время
(например, обработка данных, активизация процессов, ожидающих эти данные, и
т.п.). Если это возможно, лучше объявлять обработчики прерывания длинными.
</p>

<p>Когда CPU получает прерывание, он останавливает любые процессы (если это
не более приоритетное прерывание, тогда обработка пришедшего прерывания
произойдет только тогда, когда более приоритетное будет завершено), сохраняет
некоторые параметры в стеке и вызывает обработчик прерывания. Это означает,
что не все действия допустимы внутри обработчика прерывания потому, что
система находится в неизвестном состоянии. Решение проблемы: обработчик
прерывания определяет, что должно быть сделано немедленно (обычно надо что-то
прочитать из устройства или что-то послать ему), а затем планирует обработку
поступившей информации на более позднее время (это называется "bottom halves"
или "нижние половины") и возвращает управление. Ядро гарантирует вызов
нижней половины так быстро, насколько это возможно. Когда это произойдет, то
наш обработчик (нижняя половина) уже не будет стеснен какими-то рамками и ему
будет доступно все то, что доступно обычным модулям ядра.</p>

<p>Устанавливается обработчик прерывания вызовом <tt>request_irq</tt>. Ему
передаются номер IRQ, имя функции-обработчика, флаги, имя для
<tt>/proc/interrupts</tt> и дополнительный параметр для обработчика
прерываний. Флаги могут включать <tt>SA_SHIRQ</tt>, чтобы указать, что
прерывание может обслуживаться несколькими обработчиками (обычно по той
простой причине, что на одном IRQ может работать несколько устройств) и
<tt>SA_INTERRUPT</tt>, чтобы указать, что это короткое прерывание. Эта
функция установит обработчик только в том случае, если на заданном IRQ еще
нет обработчика прерывания, или если существующий обработчик зарегистрировал
совместную обработку прерывания флагом <tt>SA_SHIRQ</tt>.</p>

<p>Во время обработки прерывания из функции-обработчика прерывания мы можем
получить данные от устройства и затем, с помощью <tt>queue_task_irq</tt>,
<tt>tq_immediate</tt> и <tt>mark_bh(BH_IMMEDIATE)</tt>, запланировать нижнюю
половину. В ранних версиях Linux имелся массив только из 32 нижних половин,
теперь же одна из них (а именно BH_IMMEDIATE) используется для обслуживания
целого списка нижних половин драйверов. Вызов <tt>mark_bh(BH_IMMEDIATE)</tt>
как раз и вставляет нижнюю половину драйвера в этот список, планируя таким
образом ее исполнение.</p>

<hr><h1><a name="KEYBOARDSONTHEINTELARCHITECTURE"></a>11.2. Клавиатура на
архитектуре Intel</h1>
<p>Материал, рассматриваемый в оставшейся части этой главы, может быть
применен исключительно к архитектуре Intel. На других платформах код примера
работать не будет.</p>

<p>Было очень трудно выбрать тип драйвера, который можно было бы использовать
в качестве примера в этой главе. С одной стороны, пример должен быть
достаточно полезным, он должен работать на любом компьютере и быть достаточно
выразительным. С другой стороны, в ядро уже включено огромное количество
драйверов практически для всех общеизвестных и широко распространенных
устройств. Эти драйверы не смогли бы совместно работать с тем, что я
собирался написать. Наконец я принял решение представить в качестве примера
обработчик прерываний от клавиатуры, но для демонстрации работоспособности
кода сначала придется отключить стандартный обработчик прерываний от
клавиатуры, а так как этот символ объявлен как <tt>static</tt> (в файле
<tt>drivers/char/keyboard.c</tt>), то нет никакого способа восстановить
обработчик. Поэтому прежде, чем Вы дадите команду <strong>insmod</strong>,
перейдите в другую консоль и дайте команду
<strong>sleep 120; reboot</strong>, если Ваша файловая система представляет
для Вас какую-нибудь ценность.</p>

<p>Этот пример перехватывает обработку IRQ 1, прерывания от клавиатуры на
архитектуре Intel. При получении прерывания обработчик читает состояние
клавиатуры (inb(0x64)) и скан-код нажатой клавиши. Затем, как только ядро
сочтет возможным, оно вызывает <tt>got_char</tt> (она играет роль нижней
половины), которая выводит через <tt>printk</tt> код клавиши (младшие семь
бит скан-кода) и признак "нажата/отпущена" (8-й бит
скан-кода: 0 или 1 соответственно).</p>

<a name="AEN867"></a><p><strong>Пример 11-1. intrpt.c</strong></p>
<pre>
/*
 *  intrpt.c - Обработчик прерываний.
 *  Copyright (C) 2001 by Peter Jay Salzman
 */

/*
 * Standard in kernel modules
 */
#include &lt;linux/kernel.h>    /* Все-таки мы работаем с ядром! */
#include &lt;linux/module.h>    /* Необходимо для любого модуля */
#include &lt;linux/workqueue.h> /* очереди задач */
#include &lt;linux/sched.h>     /* Взаимодействие с планировщиком */
#include &lt;linux/interrupt.h> /* определение irqreturn_t */
#include &lt;asm/io.h>

#define MY_WORK_QUEUE_NAME "WQsched.c"

static struct workqueue_struct *my_workqueue;
/*
 * Эта функция вызывается ядром, поэтому в ней будут безопасны все действия
 * которые допустимы в модулях ядра.
 */
static void got_char(void *scancode)
{
  printk("Scan Code %x %s.\n", (int)*((char *)scancode) & 0x7F,
         *((char *)scancode) & 0x80 ? "Released" : "Pressed");
}

/*
 * Обработчик прерываний от клавиатуры. Он считывает информацию с клавиатуры
 * и передает ее менее критичной по времени исполнения части,
 * которая будет запущена сразу же, как только ядро сочтет это возможным.
 */
irqreturn_t irq_handler(int irq, void *dev_id, struct pt_regs *regs)
{
  /*
   * Эти переменные объявлены статическими, чтобы имелась возможность
   * доступа к ним (посредством указателей) из нижней половины.
   */
  static int initialised = 0;
  static unsigned char scancode;
  static struct work_struct task;
  unsigned char status;

  /*
   * Прочитать состояние клавиатуры
   */
  status = inb(0x64);
  scancode = inb(0x60);
  if (initialised == 0)
  {
     INIT_WORK(&task, got_char, &scancode);
     initialised = 1;
  }
  else
  {
    PREPARE_WORK(&task, got_char, &scancode);
  }
  queue_work(my_workqueue, &task);
  return IRQ_HANDLED;
}

/*
 * Инициализация модуля: регистрация обработчика прерывания.
 */
int init_module()
{
  my_workqueue = create_workqueue(MY_WORK_QUEUE_NAME);
  /*
   * Поскольку стандартный обработчик прерываний от клавиатуры не может
   * сосуществовать с таким, как наш, то придется запретить его
   * (освободить IRQ) прежде, чем что-либо сделать.
   * Но поскольку мы не знаем, где он находится в ядре, то мы лишены
   * возможности переустановить его. Поэтому компьютер придется
   * перезагрузить после опробования этого примера.
   */
  free_irq(1, NULL);
  /*
   * Подставить свой обработчик (irq_handler) на IRQ 1.
   * SA_SHIRQ означает, что мы допускаем возможность совместного
   * обслуживания этого IRQ другими обработчиками.
   */
  return request_irq(1,    /* Номер IRQ */
         irq_handler,      /* Наш обработчик */
         SA_SHIRQ, "test_keyboard_irq_handler", (void *)(irq_handler));
}

/*
 * Завершение работы.
 */
void cleanup_module()
{
  /*
   * Эта функция добавлена лишь для полноты изложения.
   * Она вообще бессмысленна, поскольку я не вижу способа
   * восстановить стандартный обработчик прерываний от клавиатуры
   * поэтому необходимо выполнить перезагрузку системы.
   */
  free_irq(1, NULL);
}

/*
 * Некоторые функции, относящиеся к work_queue, доступны только,
 * если модуль лицензирован под GPL.
 */
MODULE_LICENSE("GPL");
</pre>

<hr><h1><a name="CHAPTER12"></a>Глава 12. Симметричная многопроцессорность
</h1>
<p>Один из самых простых и самых дешевых способов увеличения
производительности это разместить на материнской плате несколько процессоров.
Каждый из процессоров может играть свою собственную роль (асимметричная
многопроцессорная обработка, ASMP), или же они все работают параллельно,
организуя вычисления таким образом, при котором операционная система и
приложения могут использовать любой доступный процессор (симметричная
многопроцессорная обработка, SMP). Примером асимметричной многопроцессорной
ОС может служить NetWare SFT III, использующая зеркальное отображение
серверов: в двухпроцессорном сервере первый процессор занимается
предоставлением услуг, а второй операциями ввода/вывода. Асимметричная
многопроцессорноя обработка более эффективна, но она требует точного
распределения ролей между процессорами, что практически невозможно на
универсальных ОС, подобных Linux. С другой стороны, симметричная
многопроцессорная обработка менее эффективна, но относительно проста в
реализации (здесь под словами "относительно проста", вовсе не
подразумевается, что это <span><em>действительно</em></span> просто).</p>

<p>В симметричной многопроцессорной среде процессоры совместно используют
одну и ту же память, в результате код, работающий на одном CPU может изменять
содержимое памяти, используемой другим CPU (за исключением многопоточных
процессов. В этом случае разные потоки одного процесса могут исполняться
одновременно на разных процессорах). Здесь уже нет уверенности, что
переменная, которой Вы присвоили некоторое значение в предыдущей строке
программы, все еще имеет то же самое значение: код, исполняемый на другом
CPU, может его поменять.</p>

<p>На самом деле в случае обычных процессов такой проблемы не существует. Как
правило, в каждый конкретный момент времени процесс может исполняться только
на одном CPU. Но ядро может выполнять одновременно разные процессы
на разных CPU.</p>

<p>В ядрах версии 2.0.x это не было большой проблемой, поскольку ядро
работало под защитой одной большой спин-блокировки (spinlock). Это означает,
что когда один процессор работает в привилегированном режиме, а другой
собирается войти в этот режим (например, в случае системного вызова), то он
вынужден ждать, пока первый процессор не выйдет в пользовательский режим. Это
делает SMP в Linux безопасным, но малоэффективным.</p>

<p>Начиная с ядра версии 2.2.x, стал возможным одновременный выход нескольких
процессоров в привилегированный режим. Это обстоятельство Вы
должны знать и помнить.</p>

<hr><h1><a name="CHAPTER13"></a>Глава 13. Заключение</h1>
<p>В заключение я хотел бы предупредить Вас о некоторых общих ошибках,
допускаемых программистами модулей ядра. Если я что-то упустил из виду, и
из-за этого у Вас произошло нечто ужасное, напишите мне, и я верну Вам ту
долю авторского гонорара, которую я получил за Ваш экземпляр книги.</p>

<p><strong>Стандартные библиотеки</strong>. Вы не должны использовать функции
из стандартных библиотек языка C. Используйте только те функции, которые
предоставляются ядром (большинство из них Вы найдете в
<tt>/proc/kallsyms</tt>).</p>

<p><strong>Запрет прерываний</strong>. Если Вы запретите прерывания на
короткий срок, то ничего страшного не произойдет. Но если Вы забудете их
потом разрешить, то система зависнет и перезагрузить ее можно будет только
кнопкой выключения питания.</p>

<p><strong>Не тяните за хвост, если неизвестно точно, что находится на
другом конце</strong>! Вероятно, это предупреждение излишне, но
тем не менее...</p>

</BODY>
</html>
