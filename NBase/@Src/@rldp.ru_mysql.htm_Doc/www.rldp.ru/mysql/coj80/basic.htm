<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <meta http-equiv="Content-Type" content="text/html; charset=">
  <title>Глава 7. Концепции JDBC</title>
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="connector-j-usagenotes-basic"></a>Глава 7. Концепции JDBC</h1>
<a class="indexterm" name="idm45064739183136"></a>
<p>Эта секция обеспечивает некоторые общие концепции JDBC.
</p>

<h2><a name="connector-j-usagenotes-connect-drivermanager"></a>
7.1. Соединение с MySQL, используя интерфейс JDBC
<code class="literal">DriverManager</code></h2>
<p>Когда вы используете JDBC за пределами сервера приложений, класс
<code class="literal">DriverManager</code> управляет связями.</p>

<p>Определите для <code class="literal">DriverManager</code>, с какими
драйверами JDBC попытаться установить связи. Самый легкий способ сделать это:
использовать <code class="literal">Class.forName()</code> в классе, который
осуществляет интерфейс <code class="literal">java.sql.Driver</code>.
С MySQL Connector/J название этого класса
<code class="literal">com.mysql.cj.jdbc.Driver</code>.
С этим методом вы могли использовать внешний конфигурационный файл, чтобы
поставлять имя класса драйвера и параметры, чтобы использовать,
соединяясь с базой данных.</p>

<p>Следующий раздел показывает код Java, как вы могли бы зарегистрировать
MySQL Connector/J из метода <code class="function">main()</code> вашего
приложения. Проверяя этот код, сначала прочитайте инсталляционную секцию в
<a href="install.htm">главе 4</a>, чтобы удостовериться, что установили
соединитель правильно и настроили <code class="literal">CLASSPATH</code>.
Кроме того, гарантируйте, что MySQL формируется, чтобы принять внешние
связи TCP/IP.</p>

<pre class="programlisting">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

// Notice, do not import com.mysql.cj.jdbc.*
// or you will have problems!
public class LoadDriver {
  public static void main(String[] args)
  {
    try {
      // The newInstance() call is a work around for some
      // broken Java implementations
      Class.forName("com.mysql.cj.jdbc.Driver").newInstance();
    } catch (Exception ex) {
      // handle the error
    }
  }
}
</pre>

<p>После того, как драйвер был зарегистрирован в
<code class="literal">DriverManager</code>, можно получить экземпляр
<code class="literal">Connection</code>, который связан с конкретной базой
данных, вызывая <code class="literal">DriverManager.getConnection()</code>:
</p>

<a name="connector-j-examples-connection-drivermanager"></a>
<p><b>Пример 7.1. Connector/J: Получение связи от
<code class="literal">DriverManager</code></b></p>
<p>Если вы еще не сделали этого, пожалуйста, просмотрите
<a href="#connector-j-usagenotes-connect-drivermanager">
раздел 7.1</a> выше прежде, чем работать с примером ниже.</p>

<p>Этот пример показывает, как можно получить экзепляр
<code class="literal">Connection</code> из
<code class="literal">DriverManager</code>.
Есть несколько различных сигнатур для метода
<code class="function">getConnection()</code>.
Консультируйтесь с документацией API, которая идет с вашим JDK для более
определенной информации о том, как использовать их.</p>

<pre class="programlisting">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;

Connection conn = null;
...
try {
  conn = DriverManager.getConnection("jdbc:mysql://localhost/test?" +
                                     "user=minty&amp;password=greatsqldb");
  // Do something with the Connection
   ...
} catch (SQLException ex) {
  // handle any errors
  System.out.println("SQLException: " + ex.getMessage());
  System.out.println("SQLState: " + ex.getSQLState());
  System.out.println("VendorError: " + ex.getErrorCode());
}
</pre>

<p>После установки <code class="classname">Connection</code> это может
использоваться, чтобы создать объекты
<code class="classname">Statement</code> и
<code class="classname">PreparedStatement</code>, а также получить
метаданные о базе данных. Это объяснено в следующих разделах.</p>

<h2><a name="connector-j-usagenotes-statements"></a>
7.2. Использование объектов JDBC <code class="literal">Statement</code>,
чтобы выполнить SQL</h2>
<p>Объекты <code class="classname">Statement</code> позволяют вам выполнять
основные SQL-запросы и получать результаты через класс
<code class="literal">ResultSet</code>, который описан позже.</p>

<p>Чтобы создать экземпляр <code class="classname">Statement</code>,
вызовите метод <code class="function">createStatement()</code> на объекте
<code class="literal">Connection</code>, который вы получили с использованием
одного из методов <code class="literal">DriverManager.getConnection()</code>
или <code class="literal">DataSource.getConnection()</code>, описанных ранее.
</p>

<p>Имея экземпляр <code class="classname">Statement</code>, можно
выполнить запрос <a href="../../../https@dev.mysql.com/doc/refman/8.0/en/select.html"
target="_top"><code class="literal">SELECT</code></a> вызовом метода
<code class="function">executeQuery(String)</code>
с SQL, который вы хотите использовать.</p>

<p>Чтобы обновить данные в базе данных, используйте метод
<code class="function">executeUpdate(String SQL)</code>.
Этот метод возвращает количество строк, соответствовавших запросу
обновления, а не количество строк, которые были изменены.</p>

<p>Если вы не знаете заранее, будет ли SQL-оператор
be a <a href="../../../https@dev.mysql.com/doc/refman/8.0/en/select.html"
target="_top"><code class="literal">SELECT</code></a> или
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/update.html"
target="_top"><code class="literal">UPDATE</code></a>/
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/insert.html" target="_top">
<code class="literal">INSERT</code></a>, тогда можно использовать метод.
Он вернет true, если SQL-запрос был
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/select.html" target="_top">
<code class="literal">SELECT</code></a>, или false, если SQL-запрос был
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/update.html" target="_top">
<code class="literal">UPDATE</code></a>,
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/insert.html" target="_top">
<code class="literal">INSERT</code></a> или
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/delete.html" target="_top">
<code class="literal">DELETE</code></a>. Если это был
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/select.html" target="_top">
<code class="literal">SELECT</code></a>, можно получить результаты, вызвав
метод <code class="function">getResultSet()</code>. Если это был
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/update.html"
target="_top"><code class="literal">UPDATE</code></a>,
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/insert.html" target="_top">
<code class="literal">INSERT</code></a> или
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/delete.html" target="_top">
<code class="literal">DELETE</code></a>, можно узнать затронутое количество
строк вызовом <code class="function">getUpdateCount()</code> в экземпляре
<code class="classname">Statement</code>.</p>

<a name="connector-j-examples-execute-select"></a>
<p><b>Пример 7.2. Connector/J: применение java.sql.Statement для выполнения
<code class="literal">SELECT</code></b></p>
<pre class="programlisting">
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.ResultSet;

// assume that conn is an already created JDBC connection (see previous examples)
Statement stmt = null;
ResultSet rs = null;
try {
  stmt = conn.createStatement();
  rs = stmt.executeQuery("SELECT foo FROM bar");
  // or alternatively, if you don't know ahead of time that
  // the query will be a SELECT...
  if (stmt.execute("SELECT foo FROM bar")) {
     rs = stmt.getResultSet();
  }
  // Now do something with the ResultSet ....
}
catch (SQLException ex) {
  // handle any errors
  System.out.println("SQLException: " + ex.getMessage());
  System.out.println("SQLState: " + ex.getSQLState());
  System.out.println("VendorError: " + ex.getErrorCode());
}
finally {
  // it is a good idea to release resources in a finally{} block
  // in reverse-order of their creation
  // if they are no-longer needed
  if (rs != null) {
     try {
       rs.close();
     } catch (SQLException sqlEx) { }   // ignore
     rs = null;
  }
  if (stmt != null) {
     try {
       stmt.close();
     } catch (SQLException sqlEx) { }   // ignore
     stmt = null;
  }
}
</pre><br class="example-break">

<h2><a name="connector-j-usagenotes-statements-callable"></a>
7.3. Применение JDBC <code class="literal">CallableStatements</code>
для выполнения сохраненных процедур</h2>
<p>Connector/J полностью понимает интерфейс
<code class="classname">java.sql.CallableStatement</code>.</p>

<p>Для получения дополнительной информации о хранимых процедурах
MySQL, пожалуйста, обратитесь к
<a href="../../../https@dev.mysql.com/doc/refman/8.0/en/stored-routines.html"
target="_top">Using Stored Routines</a>.</p>

<p>Connector/J выставляет функциональность хранимой процедуры через интерфейс
JDBC <code class="classname">CallableStatement</code>.</p>
<p>Следующий пример показывает хранимую процедуру, которая возвращает
значение <code class="varname">inOutParam</code> +1 и последовательность,
переданную с использованием <code class="varname">inputParam</code>, как
<code class="classname">ResultSet</code>:</p>

<a name="connector-j-examples-stored-procedure"></a>
<p><b>Пример 7.3. Connector/J: Запрос хранимых процедур</b></p>
<pre class="programlisting">
CREATE PROCEDURE demoSp(IN inputParam VARCHAR(255), INOUT inOutParam INT)
BEGIN
  DECLARE z INT;
  SET z = inOutParam + 1;
  SET inOutParam = z;
  SELECT inputParam;
  SELECT CONCAT('zyxw', inputParam);
END
</pre>

<p>Чтобы использовать процедуру <code class="literal">demoSp</code> с
Connector/J, выполните эти шаги:</p>
<ol type="1"><li><p>Подготовьте запрос при помощи
<code class="literal">Connection.prepareCall()</code>.</p>
<p>Заметьте, что необходимо использовать синтаксис JDBC escape
и что круглые скобки, окружающие заполнители параметра, не опциональны:</p>

<a name="connector-j-examples-preparecall"></a>
<p><b>Пример 7.4. Connector/J: Применение
<code class="literal">Connection.prepareCall()</code></b></p>

<pre class="programlisting">
import java.sql.CallableStatement;
...
// Prepare a call to the stored procedure 'demoSp'
// with two parameters
//
// Notice the use of JDBC-escape syntax ({call ...})
CallableStatement cStmt = conn.prepareCall("{call demoSp(?, ?)}");
cStmt.setString(1, "abcdefg");
</pre><br class="example-break">

<p><code class="literal">Connection.prepareCall()</code> дорогой метод из-за
поиска метаданных, который драйвер выполняет, чтобы поддержать параметры
вывода. По исполнительным причинам минимизируйте ненужные запросы
<code class="literal">Connection.prepareCall()</code> снова используя
экземпляр <code class="classname">CallableStatement</code>.</p></li>

<li><p>Зарегистрируйте параметры вывода (если есть).</p>
<p>Чтобы получить значения параметров вывода (параметры, определенные как
<code class="literal">OUT</code> или <code class="literal">INOUT</code>,
когда вы создали хранимую процедуру), JDBC требует, чтобы они были определены
перед выполнением запроса, используя различные методы
<code class="function">registerOutputParameter()</code> в интерфейсе
the <code class="classname">CallableStatement</code>:</p>

<a name="connector-j-examples-output-param"></a>
<p><b>Пример 7.5. Connector/J: Регистрация параметров вывода</b></p>
<pre class="programlisting">
import java.sql.Types;
...
// Connector/J supports both named and indexed
// output parameters. You can register output
// parameters using either method, as well
// as retrieve output parameters using either
// method, regardless of what method was used to register them.
//
// The following examples show how to use
// the various methods of registering
// output parameters (you should of course
// use only one registration per parameter).

// Registers the second parameter as output, and
// uses the type 'INTEGER' for values returned
// from getObject()
//
cStmt.registerOutParameter(2, Types.INTEGER);

// Registers the named parameter 'inOutParam', and
// uses the type 'INTEGER' for values returned
// from getObject()
cStmt.registerOutParameter("inOutParam", Types.INTEGER);
...
</pre></li>

<li><p>Установите входные параметры (если есть).</p>
<p>Параметры ввода и in/out заданы как для объектов
<code class="classname">PreparedStatement</code>, но
<code class="classname">CallableStatement</code> также понимают
параметры по имени:</p>

<a name="connector-j-examples-callablestatement"></a>
<p><b>Пример 7.6. Connector/J: Установка входных параметров
<code class="literal">CallableStatement</code></b></p>

<pre class="programlisting">
...
// Set a parameter by index
cStmt.setString(1, "abcdefg");

// Alternatively, set a parameter using the parameter name
cStmt.setString("inputParam", "abcdefg");
// Set the 'in/out' parameter using an index
cStmt.setInt(2, 1);

// Alternatively, set the 'in/out' parameter by name
cStmt.setInt("inOutParam", 1);
...
</pre></li>

<li><p>Выполните <code class="classname">CallableStatement</code>
и получите любые наборы результатов или выходные параметры.</p>
<p>Хотя <code class="classname">CallableStatement</code> допускает вызов
любого из методов выполнения <code class="classname">Statement</code>
(<code class="function">executeUpdate()</code>,
<code class="function">executeQuery()</code> или
<code class="function">execute()</code>), самый гибкий метод, это вызвать
<code class="function">execute()</code>, поскольку вы не должны знать
заранее, что хранимая процедура возвращает наборы результатов:</p>

<a name="connector-j-examples-retrieving-results-params"></a>
<p><b>Пример 7.7. Connector/J: Получение результатов и
значений выходных параметров</b></p>
<pre class="programlisting">
...
boolean hadResults = cStmt.execute();
//
// Process all returned result sets
//
while (hadResults) {
  ResultSet rs = cStmt.getResultSet();
  // process result set
  ...
  hadResults = cStmt.getMoreResults();
}

// Retrieve output parameters
//
// Connector/J supports both index-based and
// name-based retrieval
int outputValue = cStmt.getInt(2);          // index-based
outputValue = cStmt.getInt("inOutParam");   // name-based
...
</pre></li></ol>

<h2><a name="connector-j-usagenotes-last-insert-id"></a>
7.4. Получение силами JDBC значений столбцов
<code class="literal">AUTO_INCREMENT</code></h2>
<p><code class="function">getGeneratedKeys()</code>
это предпочтительный метод, если необходимо получить
<code class="literal">AUTO_INCREMENT</code> через JDBC, это иллюстрировано в
первом примере ниже. Второй пример показывает, как можно получить то же самое
значение, используя стандартный запрос
<code class="literal">SELECT LAST_INSERT_ID()</code>.
Заключительный пример показывает, как обновляемые наборы результатов могут
получить значение <code class="literal">AUTO_INCREMENT</code>, используя
метод <code class="function">insertRow()</code>.</p>

<a name="connector-j-examples-autoincrement-getgeneratedkeys"></a>
<p><b>Пример 7.8. Connector/J: Получение значений столбца
<code class="literal">AUTO_INCREMENT</code> через
<code class="literal">Statement.getGeneratedKeys()</code></b></p>

<pre class="programlisting">
Statement stmt = null;
ResultSet rs = null;
try {
  // Create a Statement instance that we can use for
  // 'normal' result sets assuming you have a
  // Connection 'conn' to a MySQL database already available
  stmt = conn.createStatement();

  // Issue the DDL queries for the table for this example
  stmt.executeUpdate("DROP TABLE IF EXISTS autoIncTutorial");
  stmt.executeUpdate("CREATE TABLE autoIncTutorial ("
                     + "priKey INT NOT NULL AUTO_INCREMENT, "
                     + "dataField VARCHAR(64), PRIMARY KEY (priKey))");

  // Insert one row that will generate an AUTO INCREMENT
  // key in the 'priKey' field
  stmt.executeUpdate("INSERT INTO autoIncTutorial (dataField) "
                     + "values ('Can I Get the Auto Increment Field?')",
                     Statement.RETURN_GENERATED_KEYS);

  // Example of using Statement.getGeneratedKeys()
  // to retrieve the value of an auto-increment value
  int autoIncKeyFromApi = -1;
  rs = stmt.getGeneratedKeys();
  if (rs.next()) {
     autoIncKeyFromApi = rs.getInt(1);
  } else {
    // throw an exception from here
  }
  System.out.println("Key returned from getGeneratedKeys():"
                     + autoIncKeyFromApi);
} finally {
  if (rs != null) {
     try {
       rs.close();
     } catch (SQLException ex) {
       // ignore
     }
  }
  if (stmt != null) {
     try {
       stmt.close();
     } catch (SQLException ex) {
       // ignore
     }
  }
}
</pre><br class="example-break">

<a name="connector-j-examples-autoincrement-select"></a>
<p><b>Пример 7.9. Connector/J: Получение значений столбца
<code class="literal">AUTO_INCREMENT</code> через
<code class="literal">SELECT LAST_INSERT_ID()</code></b></p>

<pre class="programlisting">
Statement stmt = null;
ResultSet rs = null;
try {
  // Create a Statement instance that we can use for
  // 'normal' result sets.
  stmt = conn.createStatement();

  // Issue the DDL queries for the table for this example
  stmt.executeUpdate("DROP TABLE IF EXISTS autoIncTutorial");
  stmt.executeUpdate("CREATE TABLE autoIncTutorial ("
                     + "priKey INT NOT NULL AUTO_INCREMENT, "
                     + "dataField VARCHAR(64), PRIMARY KEY (priKey))");

  // Insert one row that will generate an AUTO INCREMENT
  // key in the 'priKey' field
  stmt.executeUpdate("INSERT INTO autoIncTutorial (dataField) "
                     + "values ('Can I Get the Auto Increment Field?')");

  // Use the MySQL LAST_INSERT_ID()
  // function to do the same thing as getGeneratedKeys()
  int autoIncKeyFromFunc = -1;
  rs = stmt.executeQuery("SELECT LAST_INSERT_ID()");
  if (rs.next()) {
     autoIncKeyFromFunc = rs.getInt(1);
  } else {
    // throw an exception from here
  }
  System.out.println("Key returned from " + "'SELECT LAST_INSERT_ID()': " +
                     autoIncKeyFromFunc);
} finally {
  if (rs != null) {
     try {
       rs.close();
     } catch (SQLException ex) {
       // ignore
     }
  }
  if (stmt != null) {
     try {
       stmt.close();
     } catch (SQLException ex) {
       // ignore
     }
  }
}
</pre><br class="example-break">

<a name="connector-j-examples-autoincrement-updateable-resultsets"></a>
<p><b>Пример 7.10. Connector/J: Получение значений столбца
<code class="literal">AUTO_INCREMENT</code> в
<code class="literal">Updatable ResultSets</code></b></p>

<pre class="programlisting">
Statement stmt = null;
ResultSet rs = null;
try {
  // Create a Statement instance that we can use for
  // 'normal' result sets as well as an 'updatable'
  // one, assuming you have a Connection 'conn' to
  // a MySQL database already available
  stmt = conn.createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY,
  java.sql.ResultSet.CONCUR_UPDATABLE);

  // Issue the DDL queries for the table for this example
  stmt.executeUpdate("DROP TABLE IF EXISTS autoIncTutorial");
  stmt.executeUpdate("CREATE TABLE autoIncTutorial ("
                     + "priKey INT NOT NULL AUTO_INCREMENT, "
                     + "dataField VARCHAR(64), PRIMARY KEY (priKey))");

  // Example of retrieving an AUTO INCREMENT key
  // from an updatable result set
  rs = stmt.executeQuery("SELECT priKey, dataField "+"FROM autoIncTutorial");
  rs.moveToInsertRow();
  rs.updateString("dataField", "AUTO INCREMENT here?");
  rs.insertRow();

  // the driver adds rows at the end
  rs.last();
  // We should now be on the row we just inserted
  int autoIncKeyFromRS = rs.getInt("priKey");
  System.out.println("Key returned for inserted row: " + autoIncKeyFromRS);
} finally {
  if (rs != null) {
     try {
       rs.close();
     } catch (SQLException ex) {
       // ignore
     }
  }
  if (stmt != null) {
     try {
       stmt.close();
     } catch (SQLException ex) {
       // ignore
     }
  }
}
</pre>

<p>Управление предыдущим примером кода должно произвести следующий вывод:</p>
<pre class="programlisting">
Key returned from getGeneratedKeys(): 1
Key returned from SELECT LAST_INSERT_ID(): 1
Key returned for inserted row: 1
</pre>

<p>Время от времени это может быть хитро, чтобы использовать запрос
<code class="literal">SELECT LAST_INSERT_ID()</code>,
поскольку значение привязано к соединению. Так, если некоторый другой запрос
происходит на той же самой связи, значение переписано. С другой стороны,
метод <code class="function">getGeneratedKeys()</code> относится к экземпляру
<code class="classname">Statement</code>, таким образом, это может
использоваться, даже если другие запросы происходят на той же самой связи, но
не на том же самом <code class="classname">Statement</code>.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
