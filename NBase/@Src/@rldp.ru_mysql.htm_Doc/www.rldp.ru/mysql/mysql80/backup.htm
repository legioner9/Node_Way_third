<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 8. Резервирование и восстановление</title>
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="backup-and-recovery"></a>Глава 8. Резервирование и
восстановление</h1>
<p>Важно поддерживать Ваши базы данных так, чтобы можно было восстановить
свои данные в случае, если встречаются проблемы, такие как отказ системы,
оборудования или потребители, стирающие данные по ошибке. Резервные копии
являются также гарантией спокойствия при обновлении MySQL, и они могут
использоваться, чтобы переместить установку MySQL в другую систему.</p>

<p>MySQL предлагает множество стратегий резервного копирования из которых
можно выбрать методы, которые лучше всего удовлетворяют необходимым условиям
для Вашей установки. Эта глава обсуждает несколько тем резервного копирования
и восстановления, с которыми следует быть знакомыми:</p>

<ul><li><p>Типы резервных копий: логические против физических, полные или
частичные и так далее.</li>
<li>Методы создания резервных копий.</li>
<li>Методы восстановления, включая восстановление момента времени.</li>
<li>Планирование, сжатие и шифрование.</li>
<li>Табличная поддержка, чтобы восстановить поврежденную таблицу.
</p></li></ul>

<h2><a name="idm139965375612976"></a>Дополнительные ресурсы</h2>
<p>Ресурсы, связанные с резервным копированием или с поддержанием доступности
данных, включают следующее:</p>

<ul><li><p>Заказчики MySQL Enterprise Edition могут использовать продукт
MySQL Enterprise Backup для резервных копий. Для общего обзора продукта MySQL
Enterprise Backup см.
<a href="mysql.htm#mysql-enterprise-backup">раздел 27.2. Обзор
MySQL Enterprise Backup Overview</a>.</li>

<li>Форум, выделенный, чтобы сделать копию проблем, доступен на
<a href="../../../forums.mysql.com/list.php@28" target="_top">
http://forums.mysql.com/list.php?28</a>.</li>

<li>Подробные данные для <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> могут быть найдены в
<a href="programs.htm">главе 5</a>.</li>

<li>Синтаксис SQL-операторов, описанных здесь, дается в
<a href="sql.htm">главе 14</a>.</li>
<li>Для дополнительной информации о процедуре резервного копирования
<code>InnoDB</code> см. <a href="innodb.htm#innodb-backup">
раздел 16.17</a>.</li>

<li>Репликация позволяет Вам поддержать идентичные данные на нескольких
серверах. Это обладает несколькими преимуществами, такими как распределение
нагрузки между машинами, доступность данных при отказе части серверов и
возможность сделать резервные копии без воздействия на ведущее устройство при
использовании ведомого сервера. См. <a href="replica.htm">раздел 19</a>.
</li>

<li>MySQL Cluster обеспечивает высокую доступность, версию MySQL
адаптированную к распределенной вычислительной среде. См. материал
<a href="../../../dev.mysql.com/doc/refman/5.6/en/mysql-cluster.html"
target="_top">MySQL Cluster NDB 7.3 and MySQL Cluster NDB 7.4</a>,
который предоставляет информацию о MySQL Cluster NDB 7.3 (основанном на
MySQL 5.6, но содержащем самые последние улучшения и исправления для
механизма хранения данных
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDBCLUSTER</code></a>).</p>

<p>Механизм хранения данных
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDBCLUSTER</code></a> в настоящий момент не
поддерживается в MySQL 8.0.</p></li>

<li><p>Distributed Replicated Block Device (DRBD) является другим
высоконадежным решением. Это работает, тиражируя блочное устройство с
основного сервера на вторичный сервер на блочном уровне. См.
<a href="ha.htm">главу 18</a>.</p></li></ul>

<h2><a name="backup-types"></a>8.1. Типы резервирования и восстановления</h2>
<p>Этот раздел описывает характеристики различных типов резервных копий.</p>

<h3><a name="idm139965375591168"></a>Физические (сырые данные) против
логических резервных копий</h3>
<p>Физическое резервирование копирует каталоги и файлы, в которых хранится
база данных. Этот тип резервного копирования является подходящим для больших,
важных баз данных, которые должны быть восстановлены быстро.</p>

<p>Логические резервные копии сохраняют информацию, представленную как
логическая структура базы данных (операторы
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>,
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>) и
контент (операторы <a href="sql.htm#insert"><code>INSERT</code></a>
или разграниченные текстовые файлы). Этот тип резервного копирования является
подходящим для более малых объемов данных, где Вы могли бы отредактировать
значения данных или структуру таблицы, или воссоздать данные на
иной архитектуре машины.</p>

<p>Физические копии имеют такие характеристики:</p>
<ul><li><p>Они включают точные копии каталогов базы данных и файлов.
Обычно это копия всего или части каталога базы данных MySQL.</li>

<li>Они более быстры, чем логические, потому что они включают только
копирование файла без преобразования.</li>
<li>Вывод более компактен, чем для логического резервного копирования.</li>

<li>Поскольку скорость и размер копии важны для оживленных, важных баз
данных, продукт MySQL Enterprise Backup выполняет физические резервные копии.
Для общего обзора продукта MySQL Enterprise Backup, см.
<a href="mysql.htm#mysql-enterprise-backup">раздел 27.2</a>.</li>

<li>Гранулярность резервного копирования и восстановления колеблется от
уровня всего каталога базы данных вниз к уровню отдельных файлов. Это,
возможно, не предусматривает гранулярность на уровне таблицы, в зависимости
от механизма хранения. Например, таблицы <code>InnoDB</code> могут быть
каждая в отдельном файле или совместно использовать хранилище файлов с
другими таблицами <code>InnoDB</code>. Каждая таблица <code>MyISAM</code>
соответствует уникальному набору файлов.</li>

<li>В дополнение к базам данных резервное копирование может включать любые
связанные файлы, такие как журнал или конфигурационные файлы.</li>
<li>Данные из таблиц <code>MEMORY</code> таким способом сохранить сложно,
потому что их содержание не сохранено на диске. У продукта MySQL Enterprise
Backup есть функция, которой можно получить данные из таблицы
<code>MEMORY</code> во время резервного копирования.</li>

<li>Резервные копии переносимы только на другие машины, у которых есть
идентичные или подобные аппаратные характеристики.</li>
<li>Резервные копии могут быть выполнены, в то время как сервер MySQL
не работает. Если он работает, необходимо выполнить адекватную блокировку
так, чтобы сервер  не изменил содержание базы данных во время резервного
копирования. MySQL Enterprise Backup делает эту блокировку автоматически для
таблиц, которые требуют этого.</li>

<li>Вспомогательные инструменты включают
<span><strong>mysqlbackup</strong></span> MySQL Enterprise Backup для
<code>InnoDB</code> или любых других таблиц, или системные команды уровня
файла (такие как <span><strong>cp</strong></span>,
<span><strong>scp</strong></span>, <span><strong>tar</strong></span>,
<span><strong>rsync</strong></span>) для таблиц <code>MyISAM</code>.</li>

<li>Для восстановления</p>
<ul><li><p>MySQL Enterprise Backup восстанавливает <code>InnoDB</code>
и другие таблицы, которые поддерживает.</li>
<li><span><strong>ndb_restore</strong></span> восстанавливает таблицы
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>.</li>
<li>Файлы, скопированные на уровне файловой системы, могут быть скопированы
назад в их исходные расположения командами файловой системы.
</p></li></ul></li></ul>

<p>У логических резервных методов есть эти характеристики:</p>
<ul><li><p>Резервное копирование делается, запрашивая сервер MySQL, чтобы
получить информацию о контенте и структуре базы данных.</li>

<li>Резервное копирование медленнее, чем физические методы, потому что
сервер должен получить доступ к информации о базе данных и преобразовать ее в
логический формат. Если вывод пишется на стороне клиента, сервер должен также
отправить это программе резервирования.</li>

<li>Вывод больше, чем для физического резервного копирования, особенно когда
используется текстовый формат.</li>
<li>Гранулярность резервного копирования и восстановления доступна на уровне
сервера (все базы данных), уровне базы данных (все таблицы в определенной
базе данных) или таблицы. Это верно, независимо от механизма хранения.</li>

<li>Резервное копирование не включает журнал или конфигурационные файлы или
другие связанные с базой данных файлы, которые не являются частью баз данных.
</li>
<li>Резервные копии, сохраненные в логическом формате, независимы от
машины и очень переносимы.</li>

<li>Логические резервные копии выполняются только с
работающего сервера MySQL.</li>
<li>Вспомогательные инструменты включают программу
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
и оператор <a href="sql.htm#select"><code>SELECT ... INTO OUTFILE
</code></a>. Они работают на любом механизме хранения, включая
<code>MEMORY</code>.</li>

<li>Чтобы восстановить логические резервные копии, файлы дампа формата SQL
могут быть обработаны, используя клиент
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>.
Чтобы загрузить разграниченные текстовые файлы, используйте оператор
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a> или
клиент <a href="programs.htm#mysqlimport"><span><strong>mysqlimport</strong>
</span></a>.</p></li></ul>

<h3><a name="idm139965375542848"></a>Online и Offline резервирование</h3>
<p>Онлайновые резервные копии имеют место в то время, как сервер MySQL
работает так, чтобы информация о базе данных могла быть получена от него.
Офлайновые резервные копии имеют место в то время, как сервер остановлен.
Это различие может также быть описано как горячее и холодное резервирование,
теплое резервирование это когда сервер остается работать, но заблокирован
от изменения данных, в то время как Вы получаете доступ к файлам базы
данных внешним образом.</p>

<p>У онлайновых резервных методов есть такие характеристики:</p>
<ul><li><p>Резервное копирование является менее интрузивным другим клиентам,
которые могут соединиться с сервером MySQL во время резервного копирования
и могут быть в состоянии обратиться к данным в зависимости от того, какие
операции они должны выполнить.</li>

<li>Надо думать, как правильно поставить блокировку, чтобы резервируемые
данные были непротиворечивы. Продукт MySQL Enterprise Backup делает
такую блокировку автоматически.</p></li></ul>

<p>У офлайновых резервных методов есть такие характеристики:</p>
<ul><li><p>На клиенты можно плохо повлиять, потому что сервер недоступен
во время резервного копирования. По этой причине такие резервные копии часто
берутся от ведомого сервера репликации, который может быть остановлен,
не вредя доступности.</li>
<li>Процедура резервного копирования более проста, потому что нет никакой
возможности интерференции от клиентского действия.</p></li></ul>

<p>Похоже дело обстоит при восстановлении, но поскольку восстановление меняет
данные в базах, то клиенты не должны их читать. Здесь нужна более сильная
блокировка, чем при резервировании.</p>

<h3><a name="idm139965375533376"></a>Локальное и удаленное резервирование</h3>
<p>Локальное резервное копирование выполняется на том же самом хосте, где
работает сервер MySQL, тогда как удаленное резервное копирование делается с
другой машины. Для некоторых типов резервных копий резервное копирование
может инициироваться удаленно, даже если вывод пишется на сервер локально.
</p>

<ul><li><p><a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a> может соединиться с локальными или удаленными серверами. Для
вывода SQL (<code>CREATE</code> и <a href="sql.htm#insert"><code>
INSERT</code></a>) локальные или удаленные дампы могут быть сделаны,
они могут генерировать вывод на клиенте. Для вывода разграниченного текста
(опция <a href="programs.htm#option_mysqldump_tab"><code>--tab</code></a>)
файлы данных создаются на сервере.</li>

<li><a href="sql.htm#select-into"><code>SELECT ... INTO OUTFILE
</code></a> может инициироваться с локального или удаленного хоста клиента,
но выходной файл создается на сервере.</li>

<li>Физические резервные методы обычно инициируются локально на сервере
MySQL, хотя место назначения для скопированных файлов могло
бы быть и удаленным.</p></li></ul>

<h3><a name="idm139965375523296"></a>Резервирование образом</h3>
<p>Некоторые реализации файловой системы позволяют <span>образы (snapshot)
</span>. Они предоставляют логические копии файловой системы в данный момент
времени, не требуя материальной копии всей файловой системы. Например,
реализация может использовать методы копии на записи так, чтобы только части
файловой системы, модифицируемые после времени создания образа должны были
быть скопированы. Сам MySQL не обеспечивает возможность взятия образов
файловой системы. Это доступно через сторонние решения, такие как
Veritas, LVM или ZFS.</p>

<h3><a name="idm139965375521216"></a>Полное и инкрементальное резервирование
</h3>
<p>Полное резервное копирование включает все данные, которыми управляет
сервер MySQL в данный момент времени. Инкрементное резервное копирование
сохраняет только состав изменений, произведенных в данных во время заданного
промежутка времени (от одного момента времени до другого). У MySQL есть
различные способы выполнить полные резервные копии, такие как описанные ранее
в этом разделе. Инкрементные резервные копии возможны благодаря двоичному
журналу сервера, который используется, чтобы записать изменения в данных.</p>

<h3><a name="idm139965375519616"></a>Полное или до
заданной точки восстановление</h3>
<p>Полное восстановление восстанавливает все данные от полного резервного
копирования. Это восстанавливает экземпляр сервера к состоянию, которое он
имел, когда резервное копирование было сделано. Если то состояние не является
достаточно актуальным, полное восстановление может сопровождаться
восстановлением инкрементных резервных копий, сделанных начиная с полного
резервного копирования, чтобы привести сервер к более актуальному состоянию.
</p>

<p>Инкрементное восстановление это восстановление изменений, произведенных во
время заданного промежутка времени. Это также называют восстановлением
момента времени, потому что оно делает восстановление состояния сервера до
данного времени. Восстановление момента времени основано на двоичном журнале
и обычно следует за полным восстановлением после резервных копий файла,
которое восстанавливает сервер к его состоянию, когда резервное копирование
было сделано. Затем изменения данных, записанные в двоичных файлах журнала,
применяются как инкрементное восстановление, чтобы восстановить модификации
данных и привести сервер к требуемому моменту времени.</p>

<h3><a name="idm139965375517104"></a>Поддержка таблиц</h3>
<p>Целостность данных может оказаться под угрозу, если таблицы повреждаются.
Для таблиц <a href="innodb.htm"><code>InnoDB</code></a>
это не типичная проблема. Для информации о программах, чтобы проверить
таблицы
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>
и восстановить их, если есть проблемы, см.
<a href="#myisam-table-maintenance">раздел 8.6</a>.
</p>

<h3><a name="idm139965375512624"></a>Планирование, сжатие и шифрование</h3>
<p>Резервное планирование ценно для того, чтобы автоматизировать процедуры
резервного копирования. Сжатие резервного вывода уменьшает требования по
размещению, а шифрование вывода обеспечивает лучшую безопасность от
несанкционированного доступа к данным. Сам MySQL не обеспечивает эти
возможности. Продукт MySQL Enterprise Backup может сжать резервные копии
<code>InnoDB</code>, и сжатие или шифрование резервного вывода могут быть
достигнуты, используя утилиты файловой системы. Другие сторонние решения
могут быть доступны.</p>

<h2><a name="backup-methods"></a>8.2. Методы резервирования баз данных</h2>
<p>Этот раздел суммирует некоторые общие методы для того, чтобы
сделать резервные копии.</p>

<h3><a name="idm139965375508608"></a>Горячее резервное копирование с
MySQL Enterprise Backup</h3>
<p>Заказчики MySQL Enterprise Edition могут использовать продукт
<a href="glossary.htm#glos_mysql_enterprise_backup">MySQL Enterprise
Backup</a>, чтобы сделать <a href="glossary.htm#glos_physical">физические
</a> резервные копии всех или выбранных баз данных и таблиц. Этот продукт
включает функции
<a href="glossary.htm#glos_incremental_backup">инкрементального</a> и
<a href="glossary.htm#glos_compressed_backup">сжатого</a> резервирования.
Поддержка физических файлов базы данных делает восстановление намного
быстрее, чем логические методы такие, как команда <code>mysqldump</code>.
Таблицы <code>InnoDB</code> копируются, используя механизм
<a href="glossary.htm#glos_hot_backup">горячего резервирования</a>.
Идеально <code>InnoDB</code> должны представить значительное большинство
данных. Таблицы других механизмов хранения копируются, используя механизм
<a href="glossary.htm#glos_warm_backup">теплого резервирования</a>.
Для общего обзора продукта MySQL Enterprise Backup, см.
<a href="mysql.htm#mysql-enterprise-backup">раздел 27.2</a>.</p>

<h3><a name="idm139965375498448"></a>Резервирование с помощью mysqldump</h3>
<p>Программа <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a> может сделать резервные копии. Это может поддержать все
виды таблиц. (См. <a href="#using-mysqldump">раздел
8.4</a>.</p>

<p>Для таблиц <code>InnoDB</code> возможно выполнить онлайновое резервное
копирование, которое не блокирует таблицы, используя опцию
<a href="programs.htm#option_mysqldump_single-transaction"><code>
--single-transaction</code></a> в
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>.</p>

<h3><a name="idm139965375490192"></a>Создание резервных копий в виде
разграниченного текстового файла</h3>
<p>Чтобы создать текстовый файл, содержащий данные таблицы, можно
использовать <a href="sql.htm#select-into"><code>SELECT * INTO
OUTFILE '<em><code>file_name</code></em>' FROM
<em><code>tbl_name</code></em></code></a>.
Файл создается на сервере. Для этого оператора не может уже существовать
выходной файл, потому что доступ к файлам, которые будут перезаписаны,
составляет угрозу безопасности. См.
<a href="sql.htm#select">раздел 14.2.9</a>.
Этот метод работает на любом виде файла данных, но сохраняет только табличные
данные, не структуру таблицы.</p>

<p>Другой способ создать текстовые файлы данных (наряду с файлами,
содержащими операторы <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> для структуры таблиц), должен использовать
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
с опцией <a href="programs.htm#option_mysqldump_tab"><code>--tab</code></a>.
См. <a href="#mysqldump-delimited-text">раздел
8.4.3</a>.</p>

<p>Чтобы загрузить файл данных разграниченного текста, надо использовать
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a> или
<a href="programs.htm#mysqlimport"><span><strong>mysqlimport</strong></span>
</a>.</p>

<h3><a name="idm139965375478304"></a>Создание инкрементных резервных копий
с помощью двоичного журнала</h3>
<p>MySQL поддерживает инкрементные резервные копии: следует запустить сервер
с опцией <a href="replica.htm#option_mysqld_log-bin"><code>--log-bin
</code></a>, чтобы включить двоичное журналирование, см.
<a href="server.htm#binary-log">раздел 6.4.4</a>.
Двоичные файлы журнала предоставляют Вам информацию, Вы должны тиражировать
изменения в базу данных, что делается после точки, в которой Вы выполняли
резервное копирование. Когда Вы хотите сделать инкрементное резервное
копирование (содержащее все изменения, которые произошли, начиная с
последнего полного или инкрементного резервного копирования), следует
ротировать двоичный журнал, используя
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a>.
Вы должны скопировать в резервную копию все двоичные журналы, которые
находятся в диапазоне от момента последнего полного или инкрементного
резервного копирования до предпоследнего. Эти двоичные журналы и есть
инкрементное резервное копирование, во время восстановления Вы применяете их
как объяснено в <a href="#point-in-time-recovery">
разделе 8.5</a>. В следующий раз, когда Вы делаете полное резервное
копирование, следует также ротировать журнал с помощью
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a> или
<a href="programs.htm#mysqldump"><span><strong>mysqldump --flush-logs
</strong></span></a>.</p>

<h3><a name="idm139965375469648"></a>Создание резервных копий, используя
ведомый сервер репликации</h3>
<p>Если у Вас есть проблемы производительности с Вашим главным сервером
при резервировании, может помочь репликация. См.
<a href="replica.htm#replication-solutions-backups">раздел 19.3.1</a>.
</p>

<p>Если Вы поддерживаете ведомый сервер репликации, следует поддержать его
основную информацию и релейные репозитарии информации журнала (см.
<a href="replica.htm#slave-logs">раздел 19.2.4</a>), когда Вы
резервируете базы данных ведомого, независимо от того резервного метода,
который Вы выбираете. Эти информационные файлы всегда необходимы, чтобы
возобновить репликацию после того, как Вы восстанавливаете данные ведомого.
Если Ваш ведомый сервер тиражируется оператором
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>,
следует также резервировать любые файлы <code>SQL_LOAD-*</code>
в каталоге, который ведомый использует с этой целью. Ведомый сервер
нуждается в этих файлах, чтобы возобновить репликацию любой прерванной
операции <a href="sql.htm#load-data"><code>LOAD DATA INFILE</code>
</a>. Расположение этого каталога: значение опции
<a href="replica.htm#option_mysqld_slave-load-tmpdir"><code>
--slave-load-tmpdir</code></a>. Если сервер не был запущен с этой опцией,
расположение каталога надо смотреть в системной переменной
<a href="server.htm#sysvar_tmpdir"><code>tmpdir</code></a>.
</p>

<h3><a name="idm139965375460256"></a>Восстановление поврежденных таблиц</h3>
<p>Если необходимо восстановить таблицы <code>MyISAM</code>, попробуйте
применить к ним <a href="sql.htm#repair-table"><code>REPAIR TABLE
</code></a> или <a href="programs.htm#myisamchk"><span><strong>myisamchk
-r</strong></span></a>. Это должно помочь в 99.9% всех ситуаций. Если
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
провалился, обратитесь к
<a href="#myisam-table-maintenance">разделу 8.6</a>.
</p>

<h3><a name="idm139965375453824"></a>Создание резервных копий, используя
образ файловой системы</h3>
<p>Если Вы используете файловую систему Veritas, можно сделать резервное
копирование примерно так:</p>

<ol type="1"><li><p>Из клиентской программы, выполнить
<a href="sql.htm#flush"><code>FLUSH TABLES WITH READ LOCK</code></a>.
</li>
<li>Из другой оболочки выполнить <code>mount vxfs snapshot</code>.</li>
<li>Из первого клиента выполнить
<a href="sql.htm#lock-tables"><code>UNLOCK TABLES</code></a>.</li>
<li>Скопировать файлы из образа.</li>
<li>Отмонтировать обработанный образ.</p></li></ol>
<p>Подобные возможности могут быть доступны в других файловых системах, таких
как LVM или ZFS.</p>

<h2><a name="backup-strategy-example"></a>8.3. Стратегия резервного
копирования и восстановления в качестве примера</h2>
<p>Этот раздел обсуждает процедуру для того, чтобы выполнить резервные копии,
который позволяет Вам восстановить данные после нескольких
типов катастрофических отказов:</p>

<ul><li><p>Катастрофический отказ операционной системы.</li>
<li>Сбой питания.</li>
<li>Катастрофический отказ файловой системы.</li>
<li>Аппаратная проблема (жесткий диск, системная плата, и т.д.).
</p></li></ul>

<p>Команды в качестве примера не включают такие опции, как
<a href="programs.htm#option_general_user"><code>--user</code></a> и
<a href="programs.htm#option_general_password"><code>--password</code></a>
для клиентских программ
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
и <a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>.
Следует включать такие опции по мере необходимости, чтобы позволить
клиентским программам соединиться с сервером MySQL.</p>

<p>Предположите, что данные накапливаются в механизм хранения
<code>InnoDB</code>, у которого есть поддержка транзакций и автоматического
аварийного восстановления. Предположите также, что сервер MySQL пострадал
во время катастрофического отказа. Если бы это было не так, то никакое
восстановление никогда не было бы необходимо.</p>

<p>Для случаев катастрофических отказов операционной системы или сбоев
питания, мы можем предположить, что данные диска MySQL доступны после
рестарта. Файлы данных <code>InnoDB</code> не могут содержать
противоречивые данные вследствие катастрофического отказа, но
<code>InnoDB</code> читает журналы и ищет в них список фиксированных и
нефиксированных транзакций на ожидании, которые не были сброшены к файлам
данных. <code>InnoDB</code> автоматически откатывает те транзакции, которые
не фиксировались, и сбрасывает к файлам данных те, которые фиксировались.
Информация об этом процессе восстановления выдается через журнал ошибок
MySQL. Следующее выборка журнала в качестве примера:
<pre>
InnoDB: Database was not shut down normally.
InnoDB: Starting recovery from log files...
InnoDB: Starting log scan based on checkpoint at
InnoDB: log sequence number 0 13674004
InnoDB: Doing recovery: scanned up to log sequence number 0 13739520
InnoDB: Doing recovery: scanned up to log sequence number 0 13805056
InnoDB: Doing recovery: scanned up to log sequence number 0 13870592
InnoDB: Doing recovery: scanned up to log sequence number 0 13936128
...
InnoDB: Doing recovery: scanned up to log sequence number 0 20555264
InnoDB: Doing recovery: scanned up to log sequence number 0 20620800
InnoDB: Doing recovery: scanned up to log sequence number 0 20664692
InnoDB: 1 uncommitted transaction(s) which must be rolled back
InnoDB: Starting rollback of uncommitted transactions
InnoDB: Rolling back trx no 16745
InnoDB: Rolling back of trx no 16745 completed
InnoDB: Rollback of uncommitted transactions completed
InnoDB: Starting an apply batch of log records to the database...
InnoDB: Apply batch completed
InnoDB: Started
mysqld: ready for connections
</pre>

<p>Для случаев катастрофических отказов файловой системы или аппаратных
проблем, мы можем предположить, что данные диска MySQL недоступны после
рестарта. Это означает, что MySQL не в состоянии запуститься успешно, потому
что некоторые блоки данных диска больше не читаемы. В этом случае необходимо
переформатировать диск, установить новый или иначе исправить базовую
проблему. Затем необходимо восстановить наши данные MySQL с резервных копий,
что означает, что резервные копии уже были сделаны. Чтобы удостовериться,
что это имеет место, разработайте и реализуйте политику резервирования.</p>

<h3><a name="backup-policy"></a>8.3.1. Установление политики резервирования
</h3>
<p>Чтобы быть полезными, резервные копии должны регулярно планироваться.
Полное резервное копирование данных в некий момент времени может быть сделано
в MySQL несколькими инструментами. Например,
<a href="mysql.htm#mysql-enterprise-backup">MySQL Enterprise
Backup</a> может выполнить
<a href="glossary.htm#glos_physical_backup">физическое резервирование</a>
с оптимизацией, чтобы минимизировать издержки и избежать сбоя файлов данных
<code>InnoDB</code>,
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
обеспечивает онлайновое
<a href="glossary.htm#glos_logical_backup">логическое резервирование</a>.
Это обсуждение использует <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a>.</p>

<p>Предположите, что мы делаем полное резервное копирование всех таблиц
<code>InnoDB</code> во всех базах данных, используя следующую команду в
воскресенье в 13:00, когда загрузка низка:
<pre>
shell&gt; mysqldump --single-transaction --all-databases &gt; backup_sunday_1_PM.sql
</pre>

<p>Файл <code>.sql</code>, произведенный
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
содержит ряд операторов SQL <a href="sql.htm#insert"><code>INSERT
</code></a>, которые могут использоваться, чтобы перезагрузить выведенные
таблицы в более позднее время.</p>

<p>Эта операция резервного копирования получает глобальную блокировку чтения
на всех таблицах в начале дампа (используя
<a href="sql.htm#flush"><code>FLUSH TABLES WITH READ LOCK</code>
</a>). Как только эта блокировка была получена, координаты двоичного журнала
читаются, и блокировка снимается. Если долго обновляющие операторы работают,
когда делается <a href="sql.htm#flush"><code>FLUSH</code></a>,
операция резервного копирования может остановиться до их окончания.
После этого дамп делается без блокировок и не меняет чтения и записи таблиц.
</p>

<p>Предполагалось ранее, что таблицы для резервирования
<code>InnoDB</code>, таким образом,
<a href="programs.htm#option_mysqldump_single-transaction"><code>
--single-transaction</code></a> использует непротиворечивое чтение и
гарантирует, что данные, увиденные
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>, не изменяются (изменения, произведенные другими клиентами в
<code>InnoDB</code> не видны процессу
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>). Если операция резервного копирования включает нетранзакционные
таблицы, непротиворечивость требует, чтобы они не изменились во время
резервного копирования. Например, для таблиц <code>MyISAM</code> базы данных
<code>mysql</code>, не должно быть никаких административных изменений учетных
записей MySQL во время резервного копирования.</p>

<p>Полные резервные копии необходимы, но не всегда удобно создавать их. Они
производят большие файлы и занимают время. Они не оптимальны в том смысле,
что каждое последующее полное резервное копирование включает все данные,
включая часть, которая не изменилась с предыдущего полного резервного
копирования. Более эффективно сделать начальное полное резервное копирование,
а затем делать инкрементные резервные копии. Инкрементные резервные копии
более компактны и занимают меньше времени. Зато во время восстановления
невозможно восстановить свои данные только перезагружая полную резервную
копию. Следует также обработать инкрементные резервные копии, чтобы
восстановить инкрементные изменения.</p>

<p>Чтобы сделать инкрементные резервные копии, Вы должны сохранить
инкрементные изменения. В MySQL эти изменения представлены в двоичном
журнале, таким образом, MySQL должен всегда запускаться с опцией
<a href="replica.htm#option_mysqld_log-bin"><code>--log-bin</code></a>,
чтобы включить этот журнал. С включенным двоичным журналированием сервер
пишет каждое изменение данных в файл, в то время как обновляет данные.
При просмотре каталога базы данных MySQL, который был запущен с опцией
<a href="replica.htm#option_mysqld_log-bin"><code>--log-bin</code></a> и
работал в течение нескольких дней, обнаружим эти файлы журнала MySQL:
<pre>
-rw-rw---- 1 guilhem  guilhem   1277324 Nov 10 23:59 gbichot2-bin.000001
-rw-rw---- 1 guilhem  guilhem 4 Nov 10 23:59 gbichot2-bin.000002
-rw-rw---- 1 guilhem  guilhem79 Nov 11 11:06 gbichot2-bin.000003
-rw-rw---- 1 guilhem  guilhem 508 Nov 11 11:08 gbichot2-bin.000004
-rw-rw---- 1 guilhem  guilhem 220047446 Nov 12 16:47 gbichot2-bin.000005
-rw-rw---- 1 guilhem  guilhem    998412 Nov 14 10:08 gbichot2-bin.000006
-rw-rw---- 1 guilhem  guilhem 361 Nov 14 10:07 gbichot2-bin.index
</pre>

<p>Каждый раз, когда сервер перезапускается, он создает новый файл двоичного
журнала, используя следующее число в последовательности. В то время как
сервер работает, можно также явно сказать ему закрыть текущий файл журнала и
начать новый SQL-командой
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a>
или через команду <a href="programs.htm#mysqladmin"><span><strong>mysqladmin
flush-logs</strong></span></a>.
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
также имеет опцию для сброса логов. Файл <code>.index</code> в каталоге
данных содержит список всех файлов двоичных журналов MySQL в каталоге.</p>

<p>Двоичные журналы MySQL важны для восстановления, потому что они формируют
набор инкрементных резервных копий. Если Вы удостоверяетесь, что сбросили
журналы, когда Вы делаете свое полное резервное копирование, файлы двоичного
журнала, создаваемые позже, содержат все изменения данных, произведенные
начиная с резервного копирования. Модифицируйте предыдущую команду
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
так, чтобы она сбросила двоичные журналы MySQL в момент полного резервного
копирования, и чтобы файл дампа содержал имя нового
текущего двоичного журнала:
<pre>
shell&gt; mysqldump --single-transaction --flush-logs --master-data=2 \
 --all-databases &gt; backup_sunday_1_PM.sql
</pre>

<p>После выполнения этой команды каталог  базы данных содержит новый файл
двоичного журнала <code>gbichot2-bin.000007</code>, потому что опция
<a href="programs.htm#option_mysqldump_flush-logs"><code>--flush-logs
</code></a> предписывает серверу сбрасывать журналы. Опция
<a href="programs.htm#option_mysqldump_master-data"><code>--master-data
</code></a> предписывает <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> писать двоичные данные в вывод, таким образом,
окончательный файл дампа <code>.sql</code> включает эти строки:
<pre>
-- Position to start replication or point-in-time recovery from
-- CHANGE MASTER TO MASTER_LOG_FILE='gbichot2-bin.000007',MASTER_LOG_POS=4;
</pre>

<p>Поскольку команда <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> сделала полное резервное копирование, те строки
означают две вещи:</p>

<ul><li><p>Файл дампа содержит все изменения, произведенные перед любыми
изменениями, записанными в файл двоичного журнала
<code>gbichot2-bin.000007</code> или выше.</li>

<li>Все изменения данных, зарегистрированные после резервного копирования, не
присутствуют в файле дампа, но присутствуют в файле двоичного журнала
<code>gbichot2-bin.000007</code> или выше.</p></li></ul>

<p>В понедельник в 13:00, мы можем создать инкрементную резервную копию,
сбрасывая журналы, чтобы начать новый файл двоичного журнала. Например,
выполнение <a href="programs.htm#mysqladmin"><span><strong>mysqladmin
flush-logs</strong></span></a> создает <code>gbichot2-bin.000008</code>.
Все изменения между воскресным полным резервным копированием в 13:00 и
резервированием в понедельник в 13:00 попадут в файл
<code>gbichot2-bin.000007</code>. Это инкрементное резервное копирование
важно, таким образом, хорошая идея скопировать его в безопасное место.
Во вторник в 13:00, выполните другую команду
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-logs
</strong></span></a>. Все изменения между 13:00 в понедельник и 13:00 во
вторник попадут в файл <code>gbichot2-bin.000008</code>
(который также должен быть скопирован куда-нибудь подальше).</p>

<p>Двоичные журналы MySQL занимают место на диске. Чтобы освободить
пространство, производите чистку их время от времени. Стоит удалить файлы,
которые больше не нужны, в частности те, которые были сделаны до очередного
полного резервного копирования:
<pre>
shell&gt; mysqldump --single-transaction --flush-logs --master-data=2 \
 --all-databases --delete-master-logs &gt; backup_sunday_1_PM.sql
</pre>

<p>Удаление двоичных журналов MySQL с помощью
<a href="programs.htm#mysqldump"><span><strong>mysqldump
--delete-master-logs</strong></span></a> может быть опасным, если Ваш сервер
является главным сервером репликации, потому что ведомые серверы еще,
возможно, не полностью обработали содержание двоичного журнала. Описание для
команды <a href="sql.htm#purge-binary-logs"><code>PURGE BINARY
LOGS</code></a> объясняет, что должно быть проверено прежде, чем стереть
двоичные журналы MySQL. См. <a href="sql.htm#purge-binary-logs">
раздел 14.4.1.1</a>.</p>

<h3><a name="recovery-from-backups"></a>8.3.2. Использование резервных копий
для восстановления</h3>
<p>Теперь, предположите, что у нас есть катастрофический отказ в среду в
8:00, который требует восстановления из резервных копий.
Чтобы восстановиться, сначала мы восстанавливаем последнюю полную резервную
копию, которую имеем (от воскресенья 13:00). Полная резервная копия файла
это только ряд SQL-операторов, так что восстановление выглядит очень легко:
<pre>
shell&gt; mysql &lt; backup_sunday_1_PM.sql
</pre>

<p>В этой точке данные восстанавливаются по состоянию на воскресенье 13:00.
Чтобы восстановить изменения, произведенные с тех пор, мы должны использовать
инкрементные резервные копии, то есть файлы <code>gbichot2-bin.000007</code>
и <code>gbichot2-bin.000008</code> двоичного журнала:
<pre>
shell&gt; mysqlbinlog gbichot2-bin.000007 gbichot2-bin.000008 | mysql
</pre>

<p>Мы теперь восстановили данные к состоянию 13:00 во вторник, но все еще
пропускаем изменения с этого момента до момента сбоя. Чтобы не потерять их,
мы должны были бы сделать так, чтобы сервер MySQL сохранил двоичные журналы
в безопасное расположение (диски RAID, SAN...) так, чтобы эти журналы не были
на уничтоженном диске. Таким образом, мы можем запустить сервер с опцией
<a href="replica.htm#option_mysqld_log-bin"><code>--log-bin</code></a>,
которая указывает расположение на ином устройстве. Если бы мы сделали это, мы
имели бы файл <code>gbichot2-bin.000009</code> (и любые последующие файлы)
под рукой и могли быприменить их, используя
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong>
</span></a> и <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a>, чтобы восстановить новые изменения данных до момента отказа:
<pre>
shell&gt; mysqlbinlog gbichot2-bin.000009 ... | mysql
</pre>

<h3><a name="backup-strategy-summary"></a>8.3.3. Обзор стратегий
резервного копирования</h3>
<p>В случае катастрофического отказа операционной системы или сбоя питания
<code>InnoDB</code> непосредственно делает все восстановление данных. Но
чтобы в этом удостовериться, проверьте следующее:</p>

<ul><li><p>Всегда выполняйте сервер MySQL с опцией
<a href="replica.htm#option_mysqld_log-bin"><code>--log-bin</code></a>
или <a href="replica.htm#option_mysqld_log-bin"><code>--log-bin=<em>
<code>log_name</code></em></code></a>, где файл журнала располагается на
некотором безопасном носителе, отличающемся от диска, на котором
располагается каталог базы данных. Если у Вас есть такие безопасные носители,
этот метод может также быть хорошим для выравнивания нагрузки диска (что
имеет результатом повышение производительности).</li>

<li>Сделайте периодические полные резервные копии, используя команду
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>, которая делает онлайновое неблокирующее резервное копирование.</li>

<li>Сделайте периодические инкрементные резервные копии с помощью
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a> или
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-logs
</strong></span></a>.</p></li></ul>

<h2><a name="using-mysqldump"></a>8.4.
Использование mysqldump для резервирования</h2>
<p>Этот раздел описывает, как использовать
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>, чтобы произвести файлы дампа, и как перезагрузить файлы дампа.
Файл дампа может использоваться несколькими способами:</p>

<ul><li><p>Как резервная копия, чтобы обеспечить восстановление данных в
случае потери информации.</li>
<li>Как источник данных для ведомых устройств репликации.</li>
<li>Как источник данных для экспериментирования:
<ul><li><p>Сделать копию базы данных, которую можно использовать, не
изменяя исходные данные.</li>
<li>Чтобы протестировать потенциальные несовместимости обновлений.
</p></li></ul></li></ul>

<p><a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a> производит два типа вывода, в зависимости от наличия опции
<a href="programs.htm#option_mysqldump_tab"><code>--tab</code></a>:</p>

<ul><li><p>Без опции <a href="programs.htm#option_mysqldump_tab"><code>--tab
</code></a> <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a> пишет SQL-операторы в стандартный вывод. Этот вывод
включает команды <code>CREATE</code>, чтобы создать выведенные объекты (базы
данных, таблицы, хранимые процедуры и т.д.) и операторы <code>INSERT</code>,
чтобы зарядить данными таблицы. Вывод может быть сохранен в файле и загружен
позднее, используя <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a>, чтобы воссоздать выведенные объекты. Доступны опции, чтобы
модифицировать формат SQL-операторов и управлять тем,
какие объекты выводятся.</li>

<li>С опцией <a href="programs.htm#option_mysqldump_tab"><code>--tab</code>
</a> <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a> производит два выходных файла для каждой выведенной таблицы.
Сервер пишет один файл как разграниченный табуляциями текст, одну строку на
строку таблицы. Этот файл называют <code><em><code>tbl_name</code></em>.txt
</code> в выходном каталоге. Сервер также отправляет в
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
команды <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
для таблиц, которые пишутся в файл <code><em><code>tbl_name</code></em>.sql
</code> в выходном каталоге.</p></li></ul>

<h3><a name="mysqldump-sql-format"></a>8.4.1. Дамп данных в формат
SQL с помощью mysqldump</h3>
<p>Этот раздел описывает, как использовать <a href="programs.htm#mysqldump">
<span><strong>mysqldump</strong></span></a>, чтобы создать файлы дампа в
формате SQL. Для получения информации о загрузке таких файлов дампа см.
<a href="#reloading-sql-format-dumps">
раздел 8.4.2</a>.</p>

<p>По умолчанию <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a> пишет информацию как SQL-операторы на стандартный вывод.
Можно сохранить вывод в файле:
<pre>
shell&gt; mysqldump [<em><code>arguments</code></em>] &gt; <em><code>file_name</code></em>
</pre>

<p>Чтобы вывести все базы данных, вызовите
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
с опцией <a href="programs.htm#option_mysqldump_all-databases"><code>
--all-databases</code></a>:
<pre>
shell&gt; mysqldump --all-databases &gt; dump.sql
</pre>

<p>Чтобы вывести только определенные базы данных, назовите их в
командной строке и используйте опцию
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a>:
<pre>
shell&gt; mysqldump --databases db1 db2 db3 &gt; dump.sql
</pre>

<p>Опция <a href="programs.htm#option_mysqldump_databases"><code>--databases
</code></a> предписывает все имена в командной строке обработать как имена
баз данных. Без этой опции <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> обрабатывает первое имя как имя базы данных, а
остальные как имена таблиц.</p>

<p>С опцией <a href="programs.htm#option_mysqldump_all-databases"><code>
--all-databases</code></a> или
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a> <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a> пишет <a href="sql.htm#create-database"><code>CREATE
DATABASE</code></a> и <a href="sql.htm#use"><code>USE</code></a>
до дампа для каждой базы данных. Это гарантирует, что когда файл дампа
загружается, он создает каждую базу данных, если он не существует, и делает
его базой данных по умолчанию, таким образом, содержанием базы данных
заряжают ту же самую базу данных, из которой они прибыли. Если Вы хотите
полностью пересоздать базу данных перед тем, как вызвать файл дампа,
используйте опцию <a href="programs.htm#option_mysqldump_add-drop-database">
<code>--add-drop-database</code></a>.  В этом случае
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
пишет команду <a href="sql.htm#drop-database"><code>DROP DATABASE
</code></a> перед каждым вызовом <a href="sql.htm#create-database">
<code>CREATE DATABASE</code></a>.</p>

<p>Чтобы вывести единственную базу данных, назовите ее в командной строке:
<pre>
shell&gt; mysqldump --databases test &gt; dump.sql
</pre>

<p>В случае единственной базы данных допустимо пропустить опцию
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a>:
<pre>
shell&gt; mysqldump test &gt; dump.sql
</pre>

<p>Различие между двумя предыдущими командами в том, что без
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a> вывод не содержит <a href="sql.htm#create-database"><code>CREATE
DATABASE</code></a> или <a href="sql.htm#use"><code>USE</code></a>.
У этого есть несколько последствий:</p>

<ul><li><p>Когда Вы загружаете файл дампа, следует указать имя базы данных по
умолчанию так, чтобы сервер знал, которую база данных загрузить.</li>
<li>Для того, чтобы загрузить, можно указать имя базы данных, отличающееся от
настоящего имени, что позволяет Вам загрузить данные в иную базу данных.</li>
<li>Если база данных не существует, следует создать ее сначала.</li>

<li>Поскольку вывод не будет содержать
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>,
опция <a href="programs.htm#option_mysqldump_add-drop-database"><code>
--add-drop-database</code></a> не имеет никакого эффекта. Если Вы используете
ее, она не произведет оператор
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>.
</p></li></ul>

<p>Чтобы вывести только определенные таблицы из базы данных, назовите их в
командной строке после имени базы данных:
<pre>
shell&gt; mysqldump test t1 t3 t7 &gt; dump.sql
</pre>

<h3><a name="reloading-sql-format-dumps"></a>8.4.2.
Загрузка резервных копий формата SQL</h3>
<p>Чтобы загрузить файл дампа, записанный <a href="programs.htm#mysqldump">
<span><strong>mysqldump</strong></span></a>, состоящий из SQL-операторов,
используйте его как ввод для клиента
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>.
Если файл дампа создавался
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
с опцией <a href="programs.htm#option_mysqldump_all-databases"><code>
--all-databases</code></a> или
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a>, это содержит операторы <a href="sql.htm#create-database"><code>
CREATE DATABASE</code></a> и <a href="sql.htm#use"><code>USE</code>
</a>, а значит не надо указывать базу данных по умолчанию, в которую
можно загрузить данные:
data:
<pre>
shell&gt; mysql &lt; dump.sql
</pre>

<p>Альтернативно можно использовать в <a href="programs.htm#mysql"><span>
<strong>mysql</strong></span></a> команду <code>source</code>:
<pre>
mysql&gt; source dump.sql
</pre>

<p>Если файл дамп единственной базы данных, не содержащий операторов
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a> и
<a href="sql.htm#use"><code>USE</code></a>,
создайте базу данных сначала (в случае необходимости):
<pre>
shell&gt; mysqladmin create db1
</pre>

<p>Затем укажите имя базы данных, когда Вы загружаете файл дампа:
<pre>
shell&gt; mysql db1 &lt; dump.sql
</pre>

<p>Альтернативно в <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a> создайте базу данных, выберите ее как базу данных по умолчанию и
загрузите файл дампа:
<pre>
mysql&gt; CREATE DATABASE IF NOT EXISTS db1;
mysql&gt; USE db1;
mysql&gt; source dump.sql
</pre>

<p>Для любителей Windows PowerShell: поскольку символ "&lt;" резервируется
для перспективного использования в PowerShell, требуется использование
кавычек: <code>cmd.exe /c "mysql &lt; dump.sql"</code>.</p>

<h3><a name="mysqldump-delimited-text"></a>8.4.3. Дамп данных в формат
разграниченного текста с mysqldump</h3>
<p>Этот раздел описывает, как использовать <a href="programs.htm#mysqldump">
<span><strong>mysqldump</strong></span></a>, чтобы создать файл
дампа разграниченного текста.</p>

<p>Если Вы вызываете <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> с опцией
<a href="programs.htm#option_mysqldump_tab"><code>--tab=<em><code>
dir_name</code></em></code></a>, он использует <em><code>dir_name</code></em>
как выходной каталог и пишет таблицы в этом каталоге, используя два файла для
каждой таблицы. Имя таблицы это базовое имя для этих файлов. Для таблицы
<code>t1</code> будет два файла: <code>t1.sql</code> и <code>t1.txt</code>.
Файл <code>.sql</code> содержит оператор
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> для
таблицы. Файл <code>.txt</code> содержит табличные данные, одну строку
на строку таблицы.</p>

<p>Следующая команда выводит содержание базы данных
<code>db1</code> в файлы в каталоге <code>/tmp</code>:
<pre>
shell&gt; mysqldump --tab=/tmp db1
</pre>

<p>Файлы <code>.txt</code>, содержащие табличные данные, пишутся сервером,
таким образом, они принадлежат системной учетной записи, используемой для
того, чтобы выполнить сервер. Он использует
<a href="sql.htm#select-into"><code>SELECT ... INTO OUTFILE</code>
</a>, чтобы записать файлы, таким образом, Вы должны иметь привилегию
<a href="security.html#priv_file"><code>FILE</code></a>, чтобы выполнить эту
работу. Если файл <code>.txt</code> уже есть, происходит ошибка.</p>

<p>Сервер посылает определение <code>CREATE</code> для выведенных таблиц
в <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>, который пишет его в файлы <code>.sql</code>. Эти файлы поэтому
принадлежат пользователю, который выполняет
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>.</p>

<p>Лучше всего использовать
<a href="programs.htm#option_mysqldump_tab"><code>--tab</code></a> только
для резервирования локального сервера. Если Вы используете удаленный сервер,
каталог должен существовать на локальной и удаленной машинах, файлы
<code>.txt</code> будут записаны на сервере, а файлы <code>.sql</code> уже
на клиентском хосте.</p>

<p>Для <a href="programs.htm#mysqldump"><span><strong>mysqldump --tab
</strong></span></a> сервер по умолчанию пишет табличные данные в файлы
<code>.txt</code> одну строку на строку таблицы с табуляциями между
значениями столбцов, без кавычек вокруг значений столбцов и новой строкой как
разделителем строк. Такие же значения по умолчанию и у
<a href="sql.htm#select-into"><code>SELECT ... INTO OUTFILE</code>
</a>.</p>

<p>Чтобы позволить файлам данных использовать иной формат,
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
поддерживает эти опции:</p>

<ul><li><p><a href="programs.htm#option_mysqldump_fields">
<code>--fields-terminated-by=<em><code>str</code></em></code></a></p>
<p>Строка для того, чтобы разделить значения столбцов
(значение по умолчанию: tab).</li>

<li><a href="programs.htm#option_mysqldump_fields"><code>
--fields-enclosed-by=<em><code>char</code></em></code></a></p>
<p>Символ, в который включить значения столбцов (значение по умолчанию:
никакой символ не задан).</li>

<li><a href="programs.htm#option_mysqldump_fields"><code>
--fields-optionally-enclosed-by=<em><code>char</code></em></code></a></p>
<p>Символ, в который включить нечисловые значения столбцов (значение по
умолчанию: никакой символ).</li>

<li><a href="programs.htm#option_mysqldump_fields"><code>
--fields-escaped-by=<em><code>char</code></em></code></a></p>
<p>Символ для того, чтобы экранировать специальные символы (значение по
умолчанию: никакой символ не задан).</li>

<li><a href="programs.htm#option_mysqldump_lines-terminated-by"><code>
--lines-terminated-by=<em><code>str</code></em></code></a></p>
<p>Строка линейного окончания (значение по умолчанию: новая строка).
</p></li></ul>

<p>В зависимости от значения, которое Вы указываете для любой из этих опций,
могло бы быть необходимо в командной строке заключить в кавычки или
экранировать символы соответственно для Вашего интерпретатора команд. Либо
укажите значение, используя шестнадцатеричную нотацию. Предположите, что Вы
хотите предписать
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
заключить значения столбцов в двойные кавычки. Чтобы сделать так, укажите
двойную кавычку как значение для опции
<a href="programs.htm#option_mysqldump_fields"><code>--fields-enclosed-by
</code></a>. Но этот символ часто специальный для интерпретаторов команд и
должен быть обработан особенно. Например, в Unix, можно заключить двойную
кавычку в кавычки так:
<pre>
--fields-enclosed-by='"'
</pre>

<p>На любой платформе можно указать значение в шестнадцатеричном виде:
<pre>
--fields-enclosed-by=0x22
</pre>

<p>Это распространено, чтобы использовать несколько опций форматирования
данных вместе. Например, чтобы вывести таблицы в виде разделенных точками
значений со строками, завершенными парами возврата каретки/новой строки
(<code>\r\n</code>), используйте эту команду (введите ее в одну строку):
<pre>
shell&gt; mysqldump --tab=/tmp --fields-terminated-by=,
                    --fields-enclosed-by='"' --lines-terminated-by=0x0d0a db1
</pre>

<p>Если Вы используете любую из опций форматирования данных, чтобы вывести
табличные данные, Вы должны будете указать тот же самый формат, когда Вы
загрузите файлы данных позже, чтобы обеспечить правильную
интерпретацию содержания файла.</p>

<h3><a name="reloading-delimited-text-dumps"></a>8.4.4.
Загрузка резервных копий формата разграниченного текста</h3>
<p>Для резервных копий, произведенных
<a href="programs.htm#mysqldump"><span><strong>mysqldump --tab</strong>
</span></a>, каждая таблица представлена в выходном каталоге файлом
<code>.sql</code>, содержащим оператор
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
для таблицы, и файлом <code>.txt</code>, содержащим табличные данные. Чтобы
загрузить таблицу, сначала перейдите в выходной каталог. Затем обработайте
файл <code>.sql</code> программой
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>,
чтобы создать пустую таблицу, и обработайте файл <code>.txt</code>, чтобы
зарядить данными таблицу:
<pre>
shell&gt; mysql db1 &lt; t1.sql
shell&gt; mysqlimport db1 t1.txt
</pre>

<p>Можно использовать вместо <a href="programs.htm#mysqlimport"><span>
<strong>mysqlimport</strong></span></a> для загрузки файла данных оператор
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a> из
клиента <a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>:
<pre>
mysql&gt; USE db1;
mysql&gt; LOAD DATA INFILE 't1.txt' INTO TABLE t1;
</pre>

<p>Если бы Вы использовали какие-либо опции форматирования данных в
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>,
когда Вы первоначально вывели таблицу, то следует использовать те же самые
опции с <a href="programs.htm#mysqlimport"><span><strong>mysqlimport
</strong></span></a> или <a href="sql.htm#load-data"><code>LOAD DATA
INFILE</code></a>, чтобы обеспечить правильную интерпретацию
содержания файла данных:
<pre>
shell&gt; mysqlimport --fields-terminated-by=, --fields-enclosed-by='"'
                      --lines-terminated-by=0x0d0a db1 t1.txt
</pre>

или:
<pre>
mysql&gt; USE db1;
mysql&gt; LOAD DATA INFILE 't1.txt' INTO TABLE t1
    -&gt; FIELDS TERMINATED BY ',' FIELDS ENCLOSED BY '"'
    -&gt; LINES TERMINATED BY '\r\n';
</pre>

<h3><a name="mysqldump-tips"></a>8.4.5. Подсказки по mysqldump</h3>
<p>Этот раздел рассматривает методы, которые позволяют Вам использовать
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>, чтобы решить определенные проблемы:</p>

<ul><li><p>Как сделать копию базы данных.</li>
<li>Как скопировать базу данных с одного сервера на другой.</li>
<li>Как вывести хранимые программы (хранимые процедуры, триггеры и события).
</li>
<li>Как вывести определение и данные отдельно.</p></li></ul>

<h4><a name="mysqldump-copying-database"></a>8.4.5.1.
Создание копии базы данных</h4>
<pre>
shell&gt; mysqldump db1 &gt; dump.sql
shell&gt; mysqladmin create db2
shell&gt; mysql db2 &lt; dump.sql
</pre>

<p>Не используйте <a href="programs.htm#option_mysqldump_databases"><code>
--databases</code></a> в командной строке
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a>, потому что это вызывает включение в файл дампа оператора <code>USE db1
</code>, который переопределяет результат именования <code>db2</code> в
командной строке <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a>.</p>

<h4><a name="mysqldump-copying-to-other-server"></a>8.4.5.2.
Копирование базы данных с сервера на сервер</h4>
<p>На Server 1:
<pre>
shell&gt; mysqldump --databases db1 &gt; dump.sql
</pre>

<p>Скопируйте файл дампа с Server 1 на Server 2.</p>
<p>На Server 2:
<pre>
shell&gt; mysql &lt; dump.sql
</pre>

<p>Используйте <a href="programs.htm#option_mysqldump_databases">
<code>--databases</code></a> в <a href="programs.htm#mysqldump"><span>
<strong>mysqldump</strong></span></a>, чтобы файл дампа включал операторы
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a> и
<a href="sql.htm#use"><code>USE</code></a>, которые создают базу
данных, если она не существует и делают ее базой данных по умолчанию
для загруженных данных.</p>

<p>Альтернативно можно пропустить
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a> в <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a>. Затем Вы должны будете создать базу данных на Server 2 (в случае
необходимости) и указать ее как базу данных по умолчанию, когда
загрузите файл дампа.</p>

<p>На Server 1:
<pre>
shell&gt; mysqldump db1 &gt; dump.sql
</pre>

<p>На Server 2:
<pre>
shell&gt; mysqladmin create db1
shell&gt; mysql db1 &lt; dump.sql
</pre>

<p>Можно указать иное имя базы данных в этом случае, таким образом пропуская
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a> в вызове <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a>, ято позволяет Вам вывести данные из одной базы данных и
зарядить ими другую.</p>

<h4><a name="mysqldump-stored-programs"></a>8.4.5.3. Дамп хранимых программ
</h4>
<p>Несколько опций управляют тем, как
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
обрабатывает хранимые программы (хранимые процедуры, триггеры и события):</p>

<ul><li><p><a href="programs.htm#option_mysqldump_events"><code>--events
</code></a>: Дамп событий Event Scheduler.</li>
<li><a href="programs.htm#option_mysqldump_routines"><code>--routines</code>
</a>: Дамп хранимых процедур.</li>
<li><a href="programs.htm#option_mysqldump_triggers"><code>--triggers</code>
</a>: Дамп триггеров для таблиц.</p></li></ul>

<p>Опция <a href="programs.htm#option_mysqldump_triggers"><code>--triggers
</code></a> включается по умолчанию, чтобы, когда таблицы выводятся, они
сопровождались любыми триггерами, которые они имеют. Другие опции отключаются
по умолчанию и должны быть указаны явно, чтобы вывести соответствующие
объекты. Чтобы отключить любую из этих опций явно, используйте форму:
<a href="programs.htm#option_mysqldump_events"><code>--skip-events</code>
</a>, <a href="programs.htm#option_mysqldump_routines"><code>--skip-routines
</code></a> или <a href="programs.htm#option_mysqldump_triggers"><code>
--skip-triggers</code></a>.</p>

<h4><a name="mysqldump-definition-data-dumps"></a>8.4.5.4.
Дамп определения таблицы и контента отдельно</h4>
<p>Опция <a href="programs.htm#option_mysqldump_no-data"><code>--no-data
</code></a> говорит <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a> не выводить табличные данные, файл дампа, содержит
только операторы, чтобы создать таблицы. Наоборот опция
<a href="programs.htm#option_mysqldump_no-create-info"><code>
--no-create-info</code></a> предписывает <a href="programs.htm#mysqldump">
<span><strong>mysqldump</strong></span></a> подавлять в выводе операторы
<code>CREATE</code>, чтобы файл дампа содержал только табличные данные.</p>

<p>Например, чтобы вывести табличное определение и данные отдельно для
базы данных <code>test</code>, используйте эти команды:
<pre>
shell&gt; mysqldump --no-data test &gt; dump-defs.sql
shell&gt; mysqldump --no-create-info test &gt; dump-data.sql
</pre>

<p>Для дампа только определения добавьте опции
<a href="programs.htm#option_mysqldump_routines"><code>--routines</code></a>
и <a href="programs.htm#option_mysqldump_events"><code>--events</code></a>,
чтобы также включить сохраненные подпрограммы и события:
<pre>
shell&gt; mysqldump --no-data --routines --events test &gt; dump-defs.sql
</pre>

<h4><a name="mysqldump-upgrade-testing"></a>8.4.5.5.
Применение mysqldump, чтобы тестировать на совместимость обновления</h4>
<p>Рассматривая обновление MySQL, благоразумно установить более новую версию
отдельно от Вашей текущей версии. Затем можно вывести определения объектов и
базы данных с рабочего сервера и зарядить ими новый, чтобы проверить, что они
обрабатываются должным образом.</p>

<p>На рабочем сервере:<pre>
shell&gt; mysqldump --all-databases --no-data --routines --events &gt; dump-defs.sql
</pre>

<p>На новом сервере:
<pre>
shell&gt; mysql &lt; dump-defs.sql
</pre>

<p>Поскольку файл дампа не содержит табличные данные, он может быть обработан
быстро. Это позволяет Вам выявить потенциальные несовместимости, не ожидая
длинных загружающих данные операций. Ищите предупреждения или погрешности в
то время, как файл дампа обрабатывается. После того, как Вы проверили, что
определения обрабатываются должным образом, выводите данные и пытайтесь
зарядить ими обновленный сервер.</p>

<p>На рабочем сервере:
<pre>
shell&gt; mysqldump --all-databases --no-create-info &gt; dump-data.sql
</pre>

<p>На новом сервере:
<pre>
shell&gt; mysql &lt; dump-data.sql
</pre>
<p>Теперь проверьте табличное содержание и выполните тестовые запросы.</p>

<h2><a name="point-in-time-recovery"></a>8.5.
Инкрементное восстановление, используя двоичный журнал</h2>
<p>Восстановление момента времени обращается к восстановлению изменений
данных, произведенных начиная с данного момента времени. Как правило, этот
тип восстановления выполняется после восстановления полной резервной копии,
которое приводит сервер к его состоянию во время, когда было сделано
резервное копирование. Полное резервное копирование может быть сделано
несколькими способами, такими как перечисленные в
<a href="#backup-methods">разделе 8.2</a>.
Восстановление момента времени затем вводит сервер в курс дела со времени
полного резервного копирования.</p>

<p>Восстановление момента времени основано на этих принципах:</p>
<ul><li><p>Источник информации для восстановления момента времени это набор
инкрементных резервных копий, представленных файлами двоичного журнала,
сгенерированными вслед за полной операцией резервного копирования. Поэтому,
сервер должен быть запущен с опцией
<a href="replica.htm#option_mysqld_log-bin"><code>--log-bin</code></a>,
чтобы включить двоичное журналирование.</p>

<p>Чтобы восстановить данные из двоичного журнала, следует знать название и
местоположение текущих файлов журнала. По умолчанию сервер создает файлы
двоичного журнала в каталоге базы данных, но путь может быть указан с помощью
опции <a href="replica.htm#option_mysqld_log-bin"><code>--log-bin</code>
</a>, чтобы поместить файлы в иное расположение.</p>

<p>Чтобы увидеть список всех файлов двоичного журнала,
используйте этот оператор:
<pre>
mysql&gt; SHOW BINARY LOGS;
</pre>

<p>Чтобы определить имя текущего файла журнала, сделайте следующее:
<pre>
mysql&gt; SHOW MASTER STATUS;
</pre></li>

<li>Утилита <a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a> преобразует события в файлах журнала из двоичного
формата в текстовый, чтобы они могли быть выполнены или просмотрены.
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> имеет опции для того, чтобы выбрать разделы двоичного журнала,
основанные на времени события или позиции событий в пределах журнала.</li>

<li>Выполнение событий двоичного журнала вызывает модификации данных. Это
включает восстановление изменений данных для данного промежутка времени.
Чтобы выполнить события из двоичного журнала, обработайте вывод
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a>, используя клиент <a href="programs.htm#mysql"><span><strong>mysql
</strong></span></a>:
<pre>
shell&gt; mysqlbinlog <em><code>binlog_files</code></em> | mysql -u root -p
</pre></li>

<li>Просмотр содержания журнала может быть полезным, когда Вы должны
определить время события или позицию, чтобы выбрать частичное содержание
журнала до выполняющихся событий. Чтобы просмотреть события в журнале,
отправьте вывод
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> в любую программу оповещения:
<pre>
shell&gt; mysqlbinlog <em><code>binlog_files</code></em> | more
</pre>

<p>Альтернативно можно сохранить вывод в файле и просмотреть этот
файл в текстовом редакторе:
<pre>
shell&gt; mysqlbinlog <em><code>binlog_files</code></em> &gt; tmpfile
shell&gt; ... <em><code>edit tmpfile</code></em> ...
</pre></li>

<li>Сохранение вывода в файле полезно как предварительное мероприятие перед
выполнением содержания журнала с удаленными достоверными событиями, такими
как <a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>.
Можно стереть из файла любые операторы, которые не будут выполняться, прежде
чем выполнить его содержание. После редактирования файла выполните
содержание следующим образом:
<pre>
shell&gt; mysql -u root -p &lt; tmpfile
</pre></li></ul>

<p>Если у Вас есть больше, чем один двоичный журнал, надежный метод должен
обработать их все, используя одно и то же соединение. Вот пример, который
демонстрирует то, что может быть небезопасно:
<pre>
shell&gt; mysqlbinlog binlog.000001 | mysql -u root -p # DANGER!!
shell&gt; mysqlbinlog binlog.000002 | mysql -u root -p # DANGER!!
</pre>

<p>Обработка двоичного файла этим способом использует различные соединения,
что гарантирует проблемы, если первый файл журнала содержит оператор
<a href="sql.htm#create-table"><code>CREATE TEMPORARY TABLE</code>
</a>, а второй использует временную таблицу. Когда первый процесс
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
завершается, сервер отбрасывает временную таблицу. Когда второй процесс
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
пытается использовать таблицу, сервер сообщает <span>"unknown table"</span>.
</p>

<p>Чтобы избежать таких проблем, используйте <span><em>одно</em></span>
соединение, чтобы обработать содержание всех двоичных журналов, которые Вы
хотите обработать. Например, так:
<pre>
shell&gt; mysqlbinlog binlog.000001 binlog.000002 | mysql -u root -p
</pre>

<p>Другой подход записать все журналы в один файл и затем обработать файл:
    <pre>
shell&gt; mysqlbinlog binlog.000001 &gt;  /tmp/statements.sql
shell&gt; mysqlbinlog binlog.000002 &gt;&gt; /tmp/statements.sql
shell&gt; mysql -u root -p -e "source /tmp/statements.sql"
</pre>

<p>При записи в файл дампа, при чтении двоичного журнала, содержащего GTID
(см. <a href="replica.htm#replication-gtids">раздел 19.1.3</a>),
используйте опцию <a href="programs.htm#option_mysqlbinlog_skip-gtids">
<code>--skip-gtids</code></a> с <a href="programs.htm#mysqlbinlog"><span>
<strong>mysqlbinlog</strong></span></a>:
<pre>
shell&gt; mysqlbinlog --skip-gtids binlog.000001 &gt;  /tmp/dump.sql
shell&gt; mysqlbinlog --skip-gtids binlog.000002 &gt;&gt; /tmp/dump.sql
shell&gt; mysql -u root -p -e "source /tmp/dump.sql"
</pre>

<h3><a name="point-in-time-recovery-times"></a>8.5.1.
Восстановление момента времени, используя время события</h3>
<p>Чтобы указать начало и конец для восстановления, укажите опции
<a href="programs.htm#option_mysqlbinlog_start-datetime"><code>
--start-datetime</code></a> и
<a href="programs.htm#option_mysqlbinlog_stop-datetime"><code>
--stop-datetime</code></a> программы <a href="programs.htm#mysqlbinlog">
<span><strong>mysqlbinlog</strong></span></a> в формате
<a href="types.htm#datetime"><code>DATETIME</code></a>.
Например, предположите, что точно 20 апреля 2005 в 10:00 выполнялся
SQL-оператор, который стер большую таблицу. Чтобы восстановить таблицу и
данные, Вы могли восстановить резервную копию с предыдущей ночи, а затем
выполнить следующую команду:
<pre>
shell&gt; mysqlbinlog --stop-datetime="2005-04-20 9:59:59" \
                      /var/log/mysql/bin.123456 | mysql -u root -p
</pre>

<p>Эта команда восстанавливает все данные вплоть до даты и времени, заданной
опцией <a href="programs.htm#option_mysqlbinlog_stop-datetime">
<code>--stop-datetime</code></a>. Если Вы не обнаруживали ошибочный
SQL-оператор, Вы будете, вероятно, также хотеть восстановить действие,
которое встречалось позже. Исходя из этого, Вы могли выполнить
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a>, указав дату и время начала:
<pre>
shell&gt; mysqlbinlog --start-datetime="2005-04-20 10:01:00" \
                      /var/log/mysql/bin.123456 | mysql -u root -p
</pre>

<p>В этой команде будут повторно выполняться SQL-операторы,
зарегистрированные с 10:01. Сочетание восстановления файла дампа с предыдущей
ночи и двух команд <a href="programs.htm#mysqlbinlog"><span><strong>
mysqlbinlog</strong></span></a> восстанавливает все вплоть до одной секунды
до 10:00 и все после 10:01.</p>

<p>Чтобы использовать этот метод восстановления момента времени, следует
исследовать журнал, чтобы убедиться в точных временах для команд. Чтобы
вывести на экран содержание файла журнала, не выполняя его,
используйте эту команду:
<pre>
shell&gt; mysqlbinlog /var/log/mysql/bin.123456 &gt; /tmp/mysql_restore.sql
</pre>

<p>Затем откройте файл <code>/tmp/mysql_restore.sql</code> текстовым
редактором, чтобы исследовать его. Исключая определенные изменения,
указание времени для <a href="programs.htm#mysqlbinlog"><span><strong>
mysqlbinlog</strong></span></a> не подходит, если несколько операторов
выполнились одновременно с тем, который будет исключен.</p>

<h3><a name="point-in-time-recovery-positions"></a>8.5.2.
Восстановление момента времени, используя позиции события</h3>
<p>Вместо того, чтобы указать даты и времена, опции
<a href="programs.htm#option_mysqlbinlog_start-position"><code>
--start-position</code></a> и
<a href="programs.htm#option_mysqlbinlog_stop-position"><code>
--stop-position</code></a> для <a href="programs.htm#mysqlbinlog"><span>
<strong>mysqlbinlog</strong></span></a> могут использоваться для того, чтобы
указать позиции журнала. Они работают аналогично дате и времени, за
исключением того, что Вы указываете номера позиции журнала, а не даты.
Использование позиции может позволить Вам быть более точным, особенно если
много транзакций встречались в то же самое время, что и повреждающий
SQL-оператор. Чтобы определить числа позиции, выполните
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> для диапазона времен около времени, когда нежелательная транзакция
выполнялась, но перенаправьте результаты к текстовому файлу для исследования.
Это может быть сделано как-то так:
<pre>
shell&gt; mysqlbinlog --start-datetime="2005-04-20 9:55:00" \
                      --stop-datetime="2005-04-20 10:05:00" \
                      /var/log/mysql/bin.123456 &gt; /tmp/mysql_restore.sql
</pre>

<p>Эта команда создает малый текстовый файл в каталоге <code>/tmp</code>,
который содержит SQL-операторы во время, когда вредный SQL-оператор
выполнялся. Откройте этот файл текстовым редактором и ищите оператор, который
Вы не хотите повторить. Определите позиции в двоичном журнале для остановки и
возобновления восстановления и сделайте запись их. Позиции маркируются как
<code>log_pos</code> сопровождаемый числом. После восстановления предыдущей
резервной копии файла, используйте числа позиции, чтобы обработать файл
двоичного журнала. Например, Вы использовали бы команды:
<pre>
shell&gt; mysqlbinlog --stop-position=368312 /var/log/mysql/bin.123456 \
                      | mysql -u root -p
shell&gt; mysqlbinlog --start-position=368315 /var/log/mysql/bin.123456 \
                      | mysql -u root -p
</pre>

<p>Первая команда восстанавливает все транзакции вплоть до данного положения
остановки. Вторая команда восстанавливает все транзакции с исходного
положения до конца двоичного журнала. Поскольку вывод
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> включает операторы <code>SET TIMESTAMP</code> перед каждым записанным
SQL-оператором, восстановленные данные и связанные журналы MySQL отразят
исходные времена, в которые выполнялись транзакции.</p>

<h2><a name="myisam-table-maintenance"></a>8.6.
Поддержка и аварийное восстановление таблиц MyISAM</h2>
<p>Этот раздел обсуждает, как использовать <a href="programs.htm#myisamchk">
<span><strong>myisamchk</strong></span></a>, чтобы проверить или восстановить
таблицы <code>MyISAM</code> (таблицы, которые имеют файлы <code>.MYD</code> и
<code>.MYI</code> для данных и индексов). Для общего обзора
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
см. <a href="programs.htm#myisamchk">раздел 5.6.4</a>.</p>

<p>Можно использовать <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a>, чтобы проверить, восстановить или
оптимизировать таблицы базы данных. Следующие разделы описывают, как
выполнить эти операции. Для получения информации об использовании
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>,
чтобы получить информацию о Ваших таблицах, см.
<a href="programs.htm#myisamchk-table-info">раздел 5.6.4.5</a>.</p>

<p>Даже при том, что табличное восстановление с
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
довольно безопасно, всегда хорошая идея сделать резервную копию <span><em>
прежде, чем</em></span> сделать восстановление или любую операцию по
техническому обслуживанию, которая могла произвести много изменений таблиц.
</p>

<p>Действия <a href="programs.htm#myisamchk"><span><strong>myisamchk
</strong></span></a>, которые влияют на индексы, могут пересоздать индексы
<code>MyISAM</code> <code>FULLTEXT</code> с полнотекстовыми параметрами,
которые являются несовместимыми со значениями, используемыми сервером MySQL.
Чтобы избежать этой проблемы, следуйте инструкциям в
<a href="programs.htm#myisamchk-general-options">разделе 5.6.4.1</a>.</p>

<p>Поддержка таблиц <code>MyISAM</code> может также быть сделана, используя
SQL-операторы, которые выполняют операции, подобные тем, что может сделать
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>:</p>

<ul><li><p>Проверять таблицы <code>MyISAM</code> с помощью
<a href="sql.htm#check-table"><code>CHECK TABLE</code></a>.</li>
<li>Восстановить таблицы <code>MyISAM</code> с помощью
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>.</li>

<li>Оптимизировать таблицы <code>MyISAM</code> с помощью
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.
</li>
<li>Анализировать таблицы <code>MyISAM</code> с помощью
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
</p></li></ul>

<p>Эти операторы могут использоваться прямо или посредством программы
<a href="programs.htm#mysqlcheck"><span><strong>mysqlcheck</strong></span>
</a>. Одно преимущество этих операторов перед
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
в том, что сервер делает всю работу. С <a href="programs.htm#myisamchk">
<span><strong>myisamchk</strong></span></a> следует удостовериться, что
сервер не использует таблицы одновременно так, чтобы не было никакого
нежелательного взаимодействия между ним и <a href="programs.htm#myisamchk">
<span><strong>myisamchk</strong></span></a>.</p>

<h3><a name="myisam-crash-recovery"></a>8.6.1.
Применение myisamchk для аварийного восстановления</h3>
<p>Этот раздел описывает, как проверить нарушение целостности данных в базах
данных MySQL. Если Ваши таблицы становятся поврежденными часто, следует
попытаться обнаружить причину. См.
<a href="error.htm#crashing">раздел B.5.3.3</a>.</p>
<p>Причины повреждения таблиц <code>MyISAM</code> подробно рассмотрены в
<a href="storage.htm#myisam-table-problems">разделе 17.2.4</a>.</p>

<p>Если Вы выполняете <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> с отключенной внешней блокировкой (что является
значением по умолчанию), невозможно адекватно использовать
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>, чтобы проверить таблицу, когда
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
использует ту же самую таблицу. Если можно быть уверенным, что никто не
получит доступ к таблицам через
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>, в то
время как Вы выполняете <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a>, необходимо выполнить
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-tables
</strong></span></a> прежде, чем Вы начнете проверять таблицы. Если
невозможно гарантировать это, следует остановить
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>, в то
время как Вы проверяете таблицы. Если Вы выполняете
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>, чтобы проверить таблицы, которые
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
обновляет, можно получить предупреждение, что таблицы повреждены, даже когда
это не так.</p>

<p>Если сервер выполняется с внешней включенной блокировкой, можно
использовать <a href="programs.htm#myisamchk"><span><strong>myisamchk
</strong></span></a>, чтобы проверить таблицы в любое время. В этом случае,
если сервер пытается обновить таблицу, которую проверяет
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>, сервер будут ожидать завершения <a href="programs.htm#myisamchk">
<span><strong>myisamchk</strong></span></a>.</p>

<p>Если Вы используете <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a>, чтобы восстановить или оптимизировать таблицы,
Вы <span><em>должны</em></span> убедиться, что сервер не использует таблицу
(это также применяется, если внешняя блокировка отключается). Если Вы не
останавливаете <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a>, следует, по крайней мере, сделать
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-tables
</strong></span></a> прежде, чем Вы выполните
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>. Ваши таблицы <span><em>могут быть повреждены</em></span>, если сервер и
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
имеют доступ к таблице одновременно.</p>

<p>Выполняя аварийное восстановление, важно понять что каждая таблица
<code>MyISAM</code> <em><code>tbl_name</code></em>
в базе данных соответствует этим файлам в каталоге базы данных,
показанным в следующей таблице.</p>

<table border="1">
<thead><tr><th scope="col">Файл</th><th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><code><em><code>tbl_name</code></em>.MYD</code>
</td><td>Данные</td></tr>
<tr><td scope="row"><code><em><code>tbl_name</code></em>.MYI</code></td>
<td>Индекс</td></tr></tbody></table>

<p>Каждый из этих файлов подвержен повреждению различными способами, но
проблемы встречаются чаще всего в файлах данных</p>
<p><a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a> работает, создавая копию файла данных <code>.MYD</code> построчно.
Это заканчивает этап восстановления, удаляя старый файл <code>.MYD</code> и
переименовывая новый файл к имени файла оригинала. Если Вы используете
<a href="programs.htm#option_myisamchk_quick"><code>--quick</code></a>,
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
не создает временный файл<code>.MYD</code>, а вместо этого предполагает, что
файл <code>.MYD</code> корректен и генерирует только новый индексный файл, не
затрагивая файл <code>.MYD</code>. Это безопасно, потому что
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
автоматически обнаруживает, что файл <code>.MYD</code> поврежден и прерывает
восстановление, если это так. Можно также указать опцию
<a href="programs.htm#option_myisamchk_quick"><code>--quick</code></a>
дважды. В этом случае
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
не прерывается на некоторых погрешностях (таких как ошибка дублирования
ключа), но вместо этого пытается их решить, модифицируя файл
<code>.MYD</code>. Обычно использование двух опций
<a href="programs.htm#option_myisamchk_quick"><code>--quick</code></a>
полезно, только если слишком мало свободного пространства на диске, чтобы
выполнить нормальное восстановление. В этом случае следует, по крайней мере,
сделать резервное копирование таблицы прежде, чем выполнить
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>.</p>

<h3><a name="myisam-check"></a>8.6.2. Как проверить на ошибки таблицу MyISAM
</h3>
<p>Для проверки таблицы <code>MyISAM</code>, используйте следующие команды:
</p>

<ul><li><p><a href="programs.htm#myisamchk"><span><strong>myisamchk
<em><code>tbl_name</code></em></strong></span></a></p>
<p>Это обнаруживает 99.99% всех погрешностей. То, что это не может
обнаружить, является повреждением, которое включает <span><em>только</em>
</span> файл данных (что очень необычно). Если Вы хотите проверить таблицу,
следует обычно выполнять
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
без опций или с опцией <code>-s</code>.</li>

<li><a href="programs.htm#myisamchk"><span><strong>myisamchk -m
<em><code>tbl_name</code></em></strong></span></a></p>
<p>Это обнаруживает 99.999% всех погрешностей. Это сначала проверяет все
элементы индекса на погрешности и затем прочитывает все строки. Это вычисляет
контрольную сумму для всех значений ключа в строках и проверяет, что
контрольная сумма соответствует контрольным суммам для
ключей в индексном дереве.</li>

<li><a href="programs.htm#myisamchk"><span><strong>myisamchk -e
<em><code>tbl_name</code></em></strong></span></a></p>

<p>Это делает полную и тщательную проверку всех данных. Это делает
контрольное считывание каждого ключа для каждой строки, чтобы проверить, что
они действительно указывают на корректную строку. Это может занять много
времени для большой таблицы, у которой есть много индексов. Обычно
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
прерывается после первой погрешности, которую это обнаруживает. Если Вы
хотите получить больше информации, можно добавить опцию
<code>-v</code> (verbose). Это позвоялет
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
продолжать, но обработается максимум 20 сбоев.</li>

<li><a href="programs.htm#myisamchk"><span><strong>myisamchk -e -i
<em><code>tbl_name</code></em></strong></span></a></p>
<p>Это походит на предыдущую команду, но опция <code>-i</code> говорит
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
печатать дополнительную статистическую информацию.</p></li></ul>

<p>В большинстве случаев простая команда
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
без параметров кроме имени таблицы достаточна, чтобы проверить таблицу.</p>

<h3><a name="myisam-repair"></a>8.6.3. Как восстановить таблицы MyISAM</h3>
<p>Обсуждение в этом разделе описывает, как использовать
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
на таблицах <code>MyISAM</code> (расширения <code>.MYI</code> и
<code>.MYD</code>).</p>

<p>Можно также использовать <a href="sql.htm#check-table"><code>CHECK
TABLE</code></a> и <a href="sql.htm#repair-table"><code>REPAIR TABLE
</code></a>, чтобы проверить и восстановить таблицы <code>MyISAM</code>.</p>

<p>Симптомы поврежденных таблиц включают запросы, которые неожиданно
прерываются и наблюдаемые погрешности, такие как:</p>
<ul><li><p>Не может обнаружить файл
<code><em><code>tbl_name</code></em>.MYI</code>
(Errcode: <em><code>nnn</code></em>).</li>

<li>Неожиданный конец файла.</li>
<li>Запись в файле разрушена.</li>
<li>Получена ошибка <em><code>nnn</code></em> от табличного обработчика.
</p></li></ul>

<p>Чтобы получить больше информации о погрешности, выполните
<a href="programs.htm#perror"><span><strong>perror</strong></span></a>
<em><code>nnn</code></em>, где <em><code>nnn</code></em> задает номер ошибки.
Следующий пример показывает, как использовать <a href="programs.htm#perror">
<span><strong>perror</strong></span></a>, чтобы обнаружить значения для
наиболее распространенных кодов ошибки, которые указывают
на проблему с таблицей:
<pre>
shell&gt; perror 126 127 132 134 135 136 141 144 145
MySQL error code 126 = Index file is crashed
MySQL error code 127 = Record-file is crashed
MySQL error code 132 = Old database file
MySQL error code 134 = Record was already deleted (or record file crashed)
MySQL error code 135 = No more room in record file
MySQL error code 136 = No more room in index file
MySQL error code 141 = Duplicate unique key or constraint on write or update
MySQL error code 144 = Table is crashed and last repair failed
MySQL error code 145 = Table was marked as crashed and should be repaired
</pre>

<p>Отметьте, что ошибки 135 (no more room in record file) и 136 (no more room
in index file) не являются ошибками, которые могут быть исправлены простым
восстановлением. В этом случае следует использовать
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> для
увеличения значений опций <code>MAX_ROWS</code> и
<code>AVG_ROW_LENGTH</code> таблицы:
<pre>
ALTER TABLE <em><code>tbl_name</code></em> MAX_ROWS=<em><code>xxx</code></em> AVG_ROW_LENGTH=<em><code>yyy</code></em>;
</pre>

<p>Если Вы не знаете текущие значения опции, используйте
<a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE</code>
</a>.</p>

<p>Для других погрешностей следует восстановить свои таблицы.
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
может обычно обнаруживать и решать большинство проблем, которые встречаются.
</p>

<p>Процесс восстановления включает до трех этапов, описанных здесь. Прежде,
чем Вы начнете, следует перейти в каталог базы данных и проверить права
доступа табличных файлов. В Unix удостоверьтесь, что они читаемы
пользователем, от имени которого работает
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
(и Вами, потому что Вы должны получить доступ к файлам, которые проверяете).
Если придется модифицировать файлы, они также должны
быть перезаписываемыми Вами.</p>

<p>Этот раздел для случаев, где проверка таблиц перестала работать (такие,
как описанные в <a href="#myisam-check">разделе 8.6.2
</a>), или Вы хотите использовать расширенные функции, которые обеспечивает
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>.</p>

<p>Если Вы собираетесь восстановить таблицу из командной строки, следует
сначала остановить сервер <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a>. Отметьте, что когда Вы делаете
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin shutdown</strong>
</span></a> на удаленном сервере, <a href="programs.htm#mysqld"><span>
<strong>mysqld</strong></span></a> сервер все еще доступен некоторое время,
после <a href="programs.htm#mysqladmin"><span><strong>mysqladmin</strong>
</span></a>, пока вся обработка операторов не остановилась, а все индексные
изменения не были сброшены.</p>

<p><span><strong>Этап 1: Проверка Ваших таблиц</strong></span></p>
<p>Запустите <a href="programs.htm#myisamchk"><span><strong>myisamchk *.MYI
</strong></span></a> или <a href="programs.htm#myisamchk"><span><strong>
myisamchk -e *.MYI</strong></span></a>, если у Вас есть больше времени.
Используйте опцию <code>-s</code>, чтобы подавить ненужную информацию.</p>

<p>Если <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span>
</a> остановлен, следует использовать опцию
<a href="programs.htm#option_myisamchk_update-state"><code>--update-state
</code></a>, чтобы сказать
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
отмечать таблицу как проверенную.</p>

<p>Необходимо восстановить только те таблицы, для которых
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
сообщает об ошибке.</p>

<p>Если Вы получаете неожиданные ошибки при проверке (например, <code>out
of memory</code>) или <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a> вылетает, перейдите к этапу 3.</p>

<p><span><strong>Этап 2: Легкое безопасное восстановление</strong></span></p>
<p>Во-первых, попробуйте <a href="programs.htm#myisamchk"><span><strong>
myisamchk -r -q <em><code>tbl_name</code></em></strong></span></a> (<code>-r
-q</code> означает <span>quick recovery mode</span>). Это пытается
восстановить индексный файл, не касаясь файла данных. Если файл данных
содержит все, что он должен, это должно работать. Начните восстанавливать
следующую таблицу. Иначе, используйте следующую процедуру:</p>

<ol type="1"><li><p>Сделайте резервное копирование файла
данных перед продолжением.</li>
<li>Примените <a href="programs.htm#myisamchk"><span><strong>myisamchk -r
<em><code>tbl_name</code></em></strong></span></a>
(<code>-r</code> значит <span>recovery mode</span>). Это удаляет неправильные
и стертые строки от файла данных и реконструирует индексный файл.</li>

<li>Если предшествующая стадия перестала работать, используйте
<a href="programs.htm#myisamchk"><span><strong>myisamchk --safe-recover
<em><code>tbl_name</code></em></strong></span></a>. Безопасный режим
восстановления использует старый метод, который обрабатывает несколько
случаев, которые регулярный режим восстановления не делает (но медленнее).
</p></li></ol>

<p>Если Вы хотите, чтобы ремонтная операция пошла намного быстрее, следует
установить значения переменных
<a href="server.htm#sysvar_sort_buffer_size"><code>
sort_buffer_size</code></a> и
<a href="server.htm#sysvar_key_buffer_size"><code>
key_buffer_size</code></a> приблизительно к 25% Вашей доступной памяти,
запуская <a href="programs.htm#myisamchk"><span><strong>myisamchk</strong>
</span></a>.</p>

<p>Если Вы получаете неожиданные ошибки при проверке (например, <code>out
of memory</code>) или <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a> вылетает, перейдите к этапу 3.</p>

<p><span><strong>Этап 3: Трудное восстановление</strong></span></p>
<p>Следует достичь этой стадии, только если первые 16KB индексного файла
уничтожены или содержат неправильную информацию, или если индексный файл
разрушен. В этом случае необходимо создать новый индексный файл.
Сделайте следующим образом:</p>

<ol type="1"><li><p>Переместите файл данных в безопасное место.</li>
<li>Используйте табличный файл описания, чтобы создать новые (пустые)
данные и индексные файлы:
<pre>
shell&gt; mysql <em><code>db_name</code></em>
mysql&gt; SET autocommit=1;
mysql&gt; TRUNCATE TABLE <em><code>tbl_name</code></em>;
mysql&gt; quit
</pre></li>

<li>Скопируйте старый файл данных назад на недавно создаваемый файл данных
(не просто положите обратно старый файл на новый файл. Вы хотите сохранить
копию в случае, если что-то пойдет в раскосец).</p></li></ol>

<p>Если Вы используете репликацию, следует остановить ее до выполнения
вышеупомянутой процедуры, так как она включает операции файловой системы, а
они не регистрируются MySQL.</p>

<p>Вернитесь на этап 2. <a href="programs.htm#myisamchk"><span><strong>
myisamchk -r -q</strong></span></a> должен работать (это не должно
быть бесконечным циклом).</p>

<p>Можно также использовать SQL-оператор <code>REPAIR TABLE
<em><code>tbl_name</code></em> USE_FRM</code>, который выполняет процедуру
автоматически. Нет также никакой возможности нежелательного взаимодействия
между утилитой и сервером, потому что сервер делает всю работу, когда Вы
используете <a href="sql.htm#repair-table"><code>REPAIR TABLE</code>
</a>.</p>

<h3><a name="myisam-optimization"></a>8.6.4. Оптимизация таблиц MyISAM</h3>
<p>Чтобы объединить фрагментированные строки и отщепить потраченное впустую
пространство, которое следует из удаления или обновления строк, выполните
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
в режиме восстановления:
<pre>
shell&gt; myisamchk -r <em><code>tbl_name</code></em>
</pre>

<p>Можно оптимизировать таблицу таким же образом при использовании
SQL-оператора <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE
</code></a>. <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE
</code></a> делает табличное восстановление и ключевое исследование, а также
сортирует индексное дерево так, чтобы ключевые поиски были более быстрыми.
Нет также никакой возможности нежелательного взаимодействия между утилитой и
сервером, потому что сервер делает всю работу, когда Вы используете
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.</p>

<p>У <a href="programs.htm#myisamchk"><span><strong>myisamchk</strong>
</span></a> есть много других опций, которые можно использовать, чтобы
улучшить производительность таблицы:</p>

<ul><li><p><a href="programs.htm#option_myisamchk_analyze"><code>--analyze
</code></a> или <code>-a</code>: Выполнить исследование распределения ключей.
Это улучшает производительность связывания, позволяя оптимизатору лучше
выбрать порядок, в котором можно соединить таблицы, а также какие индекы
он должен использовать.</li>

<li><a href="programs.htm#option_myisamchk_sort-index"><code>--sort-index
</code></a> или <code>-S</code>: Сортировать индексные блоки. Это
оптимизирует поиск и делает сканирование таблиц, которые
используют индексы, быстрее.</li>

<li><a href="programs.htm#option_myisamchk_sort-records"><code>
--sort-records=<em><code>index_num</code></em></code></a> или
<code>-R <em><code>index_num</code></em></code>: Сортировать строки данных,
согласно данному индексу. Это делает Ваши данные намного больше
локализованными и может ускорить основанные на диапазоне операции
<a href="sql.htm#select"><code>SELECT</code></a> и <code>ORDER BY
</code>, которые используют этот индекс.</p></li></ul>

<h3><a name="myisam-maintenance-schedule"></a>8.6.5.
Установка графика текущего обслуживания таблиц MyISAM</h3>
<p>Стоит проверять таблицы регулярно, а не ждать проблем. Одним из вариантов
для проверки и ремонта таблиц <code>MyISAM</code> являются операторы
<a href="sql.htm#check-table"><code>CHECK TABLE</code></a> и
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>.</p>

<p>Другой способ проверить таблицы состоит в том, чтобы использовать
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a>. Для целей поддержки можно использовать
<a href="programs.htm#myisamchk"><span><strong>myisamchk -s</strong></span>
</a>. Опция <code>-s</code> (сокращение для
<a href="programs.htm#option_myisamchk_silent"><code>--silent</code></a>)
предписывает <a href="programs.htm#myisamchk"><span><strong>myisamchk
</strong></span></a> работать в тихом режиме и выводить сообщения только,
когда погрешности встречаются.</p>

<p>Также хорошая идея включить автоматическую табличную проверку
<code>MyISAM</code>. Например, всякий раз, когда машина сделала рестарт в
середине обновления, Вы обычно должны проверять каждую таблицу, на которую,
возможно, влияли прежде, чем она будет использоваться далее. Чтобы сервер
проверял таблицы <code>MyISAM</code> автоматически, запустите с опцией
<a href="server.htm#option_mysqld_myisam-recover-options">
<code>--myisam-recover-options</code></a>.</p>

<p>Следует также регулярно проверять свои таблицы во время работы нормальной
системы. Например, можно выполнить задание <span><strong>cron</strong>
</span>, чтобы проверить важные таблицы один раз в неделю, используя строку
в файле <code>crontab</code>:
<pre>
35 0 * * 0 <em><code>/path/to/myisamchk</code></em> --fast --silent <em><code>/path/to/datadir</code></em>/*/*.MYI
</pre>

<p>Это распечатывает информацию о разрушенных таблицах так, чтобы можно было
исследовать и восстановить их по мере необходимости.

Выполняйте <a href="programs.htm#myisamchk"><span><strong>myisamchk -s
</strong></span></a> каждую ночь на всех таблицах, которые были обновлены в
течение прошлых 24 часов. Поскольку Вы видите, что проблемы нечасто
встречаются, можно уменьшить частоту проверки до одного раза в неделю
или около этого.</p>

<p>Обычно таблицы MySQL нуждаются в небольшой поддержке. Если Вы выполняете
много обновлений с доведенными до требуемого размера строками (таблицы со
столбцами <a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>)
или имеете таблицы со многими стертыми строками, нужно дефрагментировать
пространство таблиц время от времени. Можно сделать это при использовании
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>
на рассматриваемых таблицах. Либо, если можно остановить сервер
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
на некоторое время, перейдите в каталог базы данных и используйте эту
команду, в то время как сервер остановлен:
<pre>
shell&gt; myisamchk -r -s --sort-index --myisam_sort_buffer_size=16M */*.MYI
</pre>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
