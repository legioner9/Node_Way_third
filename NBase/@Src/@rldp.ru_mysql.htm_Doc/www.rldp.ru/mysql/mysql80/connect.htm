<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 25. Коннекторы и API</title>
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="connectors-apis"></a>Глава 25. Коннекторы и API</h1>
<p>Коннекторы MySQL обеспечивают связь сервера MySQL и программ-клиентов.
API обеспечивает низкоуровневый доступ к протоколу и ресурсам MySQL. То и
другое позволяет работать с MySQL из почти любого языка или окружения.</p>
<p>Номера версий коннекторов не коррелируют с номерами версий MySQL.</p>

<h2><a name="idm139965280502688"></a>Коннекторы MySQL</h2>
<p>Oracle развивает много коннекторов:</p>
<ul><li><p><a href="../../../dev.mysql.com/doc/connector-odbc/en/default.htm">
Connector/ODBC</a> оказывает поддержку драйвера для Open Database
Connectivity (ODBC) API. Поддержка доступна для ODBC из Windows, Unix и OS X.
</li>

<li><a href="../../../dev.mysql.com/doc/connector-net/en/default.htm">Connector/Net</a>
позволяет разработчикам создавать .NET-приложения, которые соединяются с
MySQL. Connector/Net реализует полнофункциональный интерфейс ADO.NET.
Приложение может быть написано на любом языке с поддержкой .NET.</p>

<p>MySQL <a href="../../../dev.mysql.com/doc/visual-studio/en/default.htm">Visual Studio
Plugin</a> работает с Connector/Net и Visual Studio 2005. Плагин является
провайдером MySQL DDEX, это означает, что Вы можете использовать схему и
инструменты для манипуляции данными, доступные в Visual Studio, чтобы создать
и отредактировать объекты в пределах базы данных MySQL.</li>

<li><a href="../../../dev.mysql.com/doc/connector-j/5.1/en/default.htm">Connector/J</a>
оказывает поддержку драйвера для Java, используя стандартный API Java
Database Connectivity (JDBC).</li>

<li><a href="../../../dev.mysql.com/doc/connector-python/en/default.htm">Connector/Python
</a> позволяет работать с MySQL приложениям на Python, используя
<a href="../../../www.python.org/dev/peps/pep-0249/default.htm">Python DB API version 2.0
</a>. Никаких дополнительных модулей Python или библиотек клиента
MySQL не требуется.</li>

<li><a href="../../../dev.mysql.com/doc/connector-cpp/en/default.htm">Connector/C++</a>
позволяет приложениям C++ соединяться с MySQL.</li>
<li><a href="../../../dev.mysql.com/doc/connector-c/en/default.htm">Connector/C</a> это
автономная замена библиотеки клиента MySQL (<code>libmysqlclient</code>)
для приложений на C.</p></li></ul>

<h2><a name="idm139965280488192"></a>MySQL C API</h2>
<p>Для прямого доступа к MySQL в приложениях на C есть два метода:</p>
<ul><li><p><a href="#c-api">C API</a> обеспечивает
низкоуровневый доступ к протоколу MySQL клиент-сервер через библиотеку
<code>libmysqlclient</code>. Это основной метод. <code>libmysqlclient</code>
включена в дистрибутивы MySQL и Connector/C.</li>

<li><code>libmysqld</code> встроенная библиотека сервера MySQL, которая
позволяет Вам встроить экземпляр сервера MySQL в Ваши приложения на C.
<code>libmysqld</code> включена в дистрибутивы MySQL, но не Connector/C.
</p></li></ul>

<p>Чтобы получить доступ к MySQL из приложения C или создать интерфейс к
MySQL для языка, не поддержанного коннекторами или API в этой главе, стоит
начать с <a href="#c-api">C API
</a>. Есть много инструментов: которые могут помочь, см.
<a href="programs.htm#programs-development">главу 5.7</a>.</p>

<h2><a name="idm139965280476448"></a>MySQL API третьей стороны</h2>
<p>Оставшиеся API, описанные в этой главе, предоставляет интерфейс MySQL с
определенных языков. Эти решения не развиваются и не поддерживаются Oracle.
Основная информация об их использовании и способностях обеспечена здесь
только в справочных целях.</p>

<p>Все они реализованы через <code>libmysqlclient</code> или
<span>нативный драйвер</span>. Эти два решения
предлагают различные плюсы:</p>

<ul><li><p>Используя <span><em><code>libmysqlclient</code></em></span>, Вы
получаете полную совместимость с MySQL, потому что фактически пользуетесь
теми же самыми библиотеками, что и приложения-клиенты MySQL. Однако, набор
функций ограничен тем, что есть в <code>libmysqlclient</code> и скорость
работы может меньше, поскольку надо учитывать накладные расходы MySQL API.
</li>

<li><span><em>Нативные драйверы</em></span> реализуют сетевой протокол
MySQL полностью в пределах языка или среды. Они быстры, поскольку там меньше
копированият данных между компонентами, и могут предложить
усовершенствованную функциональность, недоступную через стандартный MySQL
API. Клиентская библиотека MySQL не требуется.</p></li></ul>

<p><a href="#connectors-apis-summary">Таблица 25.1</a>
перечисляет многие из библиотек и интерфейсов, доступных для MySQL.
<a href="#connectors-apis-versions">Таблица 25.2</a> показывает
соответствие версий коннекторов и сервера.</p>

<a name="connectors-apis-summary"></a><p><b>Таблица 25.1. MySQL API и
интерфейсы</b></p>
<table border="1"><thead><tr><th scope="col">Окружение</th>
<th scope="col">API</th><th scope="col">Тип</th>
<th scope="col">Замечания</th></tr></thead>
<tbody><tr><td scope="row">Ada</td><td>GNU Ada MySQL Bindings</td>
<td><code>libmysqlclient</code></td>
<td>См. <a href="../../../gnade.sourceforge.net/default.htm">MySQL Bindings for GNU
Ada</a></td></tr>
<tr><td scope="row">C</td><td>C API</td><td><code>libmysqlclient</code></td>
<td>См. <a href="#c-api">раздел
25.8. MySQL C API</a>.</td></tr>
<tr><td scope="row">C</td><td>Connector/C</td><td>Замена для
<code>libmysqlclient</code></td><td>См.
<a href="../../../dev.mysql.com/doc/connector-c/en/default.htm">MySQL Connector/C
Developer Guide</a>.</td></tr>
<tr><td scope="row">C++</td><td>Connector/C++</td><td><code>libmysqlclient
</code></td><td>См. <a href="../../../dev.mysql.com/doc/connector-cpp/en/default.htm">
MySQL Connector/C++ Developer Guide</a>.</td></tr>
<tr><td scope="row"></td><td>MySQL++</td><td><code>libmysqlclient</code></td>
<td>См. веб-сайт <a href="../../../tangentsoft.net/mysql++/doc/default.htm">MySQL++
</a>.</td></tr>
<tr><td scope="row"></td><td>MySQL wrapped</td><td><code>libmysqlclient
</code></td><td>См. <a href="../../../www.alhem.net/project/mysql/default.htm">MySQL
wrapped</a>.</td></tr>
<tr><td scope="row">Cocoa</td><td>MySQL-Cocoa</td><td><code>libmysqlclient
</code></td><td>Слвместим с окружением Objective-C Cocoa. См.
<a href="../../../mysql-cocoa.sourceforge.net/default.htm">
http://mysql-cocoa.sourceforge.net/</a></td></tr>
<tr><td scope="row">D</td><td>MySQL for D</td>
<td><code>libmysqlclient</code></td><td>См.
<a href="../../../www.steinmole.de/d/default.htm">MySQL for D</a>.</td></tr>
<tr><td scope="row">Eiffel</td><td>Eiffel MySQL</td><td><code>libmysqlclient
</code></td><td>См. <a href="#apis-eiffel" title="25.14
MySQL Eiffel Wrapper">раздел 25.14. MySQL Eiffel Wrapper</a>.</td></tr>
<tr><td scope="row">Erlang</td><td><code>erlang-mysql-driver</code></td>
<td><code>libmysqlclient</code></td><td>См.
<a href="../../../code.google.com/p/erlang-mysql-driver/default.htm"><code>
erlang-mysql-driver</code>.</a></td></tr>
<tr><td scope="row">Haskell</td><td>Haskell MySQL Bindings</td><td>Нативный
драйвер</td><td><a href="../../../www.serpentine.com/blog/software/mysql/default.htm">
Brian O'Sullivan's pure Haskell MySQL bindings</a>.</td></tr>
<tr><td scope="row"></td><td><code>hsql-mysql</code></td>
<td><code>libmysqlclient</code></td><td>
<a href="../../../hackage.haskell.org/cgi-bin/hackage-scripts/package/hsql-mysql-1.7">
Драйвер MySQL для Haskell</a>.</td></tr>
<tr><td scope="row">Java/JDBC</td><td>Connector/J</td><td>Нативный драйвер
</td><td>См. <a href="../../../dev.mysql.com/doc/connector-j/5.1/en/default.htm">MySQL
Connector/J 5.1 Developer Guide</a>.</td></tr>
<tr><td scope="row">Kaya</td><td>MyDB</td><td><code>libmysqlclient</code>
</td><td>См. <a href="../../../kayalang.org/library/latest/MyDB">MyDB</a>.
</td></tr>
<tr><td scope="row">Lua</td><td>LuaSQL</td><td><code>libmysqlclient</code>
</td><td>См. <a href="../../../keplerproject.github.io/luasql/doc/us/default.htm">LuaSQL
</a>.</td></tr>
<tr><td scope="row">.NET/Mono</td><td>Connector/Net</td><td>Нативный драйвер
</td><td>См. <a href="../../../dev.mysql.com/doc/connector-net/en/default.htm">MySQL
Connector/Net Developer Guide</a>.</td></tr>
<tr><td scope="row">Objective Caml</td><td>OBjective Caml MySQL Bindings</td>
<td><code>libmysqlclient</code></td><td>
<a href="../../../raevnos.pennmush.org/code/ocaml-mysql/default.htm">MySQL
Bindings for Objective Caml</a>.</td></tr>
<tr><td scope="row">Octave</td><td>Database bindings for GNU Octave</td>
<td><code>libmysqlclient</code></td><td>
<a href="../../../octave.sourceforge.net/database/index.html">Database
bindings for GNU Octave</a>.</td></tr>
<tr><td scope="row">ODBC</td><td>Connector/ODBC</td><td><code>libmysqlclient
</code></td><td>См. <a href="../../../dev.mysql.com/doc/connector-odbc/en/default.htm">
MySQL Connector/ODBC Developer Guide</a>.</td></tr>
<tr><td scope="row">Perl</td><td><code>DBI</code>/<code>DBD::mysql</code>
</td><td><code>libmysqlclient</code></td>
<td>См. <a href="#apis-perl">раздел 25.10. MySQL Perl API
</a>.</td></tr>
<tr><td scope="row"></td><td><code>Net::MySQL</code></td><td>Нативный драйвер
</td><td><a href="../../../search.cpan.org/dist/Net-MySQL/MySQL.pm"><code>
Net::MySQL</code></a> at CPAN</td></tr>
<tr><td scope="row">PHP</td><td><code>mysql</code> и устаревший
<code>ext/mysql</code></td><td><code>libmysqlclient</code></td>
<td>См. <a href="../../../dev.mysql.com/doc/apis-php/en/apis-php-mysql.html">
Original MySQL API</a>.</td></tr>
<tr><td scope="row"></td><td><code>mysqli</code>, <code>ext/mysqli</code>
interface</td><td><code>libmysqlclient</code></td><td>См.
<a href="../../../dev.mysql.com/doc/apis-php/en/apis-php-mysqli.html">MySQL
Improved Extension</a>.</td></tr>
<tr><td scope="row"> </td><td><code>PDO_MYSQL</code></td>
<td><code>libmysqlclient</code></td><td>См.
<a href="../../../dev.mysql.com/doc/apis-php/en/apis-php-pdo-mysql.html">MySQL
Functions (PDO_MYSQL)</a>.</td></tr>
<tr><td scope="row"> </td><td>PDO mysqlnd</td><td>Нативный драйвер</td>
<td></td></tr>
<tr><td scope="row">Python</td><td>Connector/Python</td><td>Нативный драйвер
</td><td>См. <a href="../../../dev.mysql.com/doc/connector-python/en/default.htm">MySQL
Connector/Python Developer Guide</a>.</td></tr>
<tr><td scope="row">Python</td><td>Connector/Python C Extension</td>
<td><code>libmysqlclient</code></td><td>См.
<a href="../../../dev.mysql.com/doc/connector-python/en/default.htm">MySQL
Connector/Python Developer Guide</a>.</td></tr>
<tr><td scope="row"></td><td>MySQLdb</td><td><code>libmysqlclient</code>
</td><td>См. <a href="#apis-python">раздел 25.11. MySQL
Python API</a>.</td></tr>
<tr><td scope="row">Ruby</td><td>MySQL/Ruby</td><td><code>libmysqlclient
</code></td><td><code>libmysqlclient</code>. См.
<a href="#apis-ruby-mysqlruby">раздел 25.12.1. MySQL/Ruby
API</a>.</td></tr>
<tr><td scope="row"></td><td>Ruby/MySQL</td><td>Нативный драйвер</td><td>См.
<a href="#apis-ruby-rubymysql">раздел 25.12.2. Ruby/MySQL
API</a>.</td></tr>
<tr><td scope="row">Scheme</td><td><code>Myscsh</code></td><td><code>
libmysqlclient</code></td><td><a href="../../../https@github.com/aehrisch/myscsh">
<code>Myscsh</code></a>.</td></tr>
<tr><td scope="row">SPL</td><td><code>sql_mysql</code></td><td><code>
libmysqlclient</code></td><td>
<a href="../../../www.clifford.at/spl/spldoc/sql_mysql.html"><code>sql_mysql
</code> for SPL</a>.</td></tr>
<tr><td scope="row">Tcl</td><td>MySQLtcl</td><td><code>libmysqlclient</code>
</td><td>См. <a href="#apis-tcl">раздел 25.13. MySQL Tcl
API</a>.</td></tr></tbody></table>

<a name="connectors-apis-versions"></a><p><b>Таблица 25.2. Версии MySQL
коннекторов и сервера</b></p>
<table border="1"><thead><tr><th scope="col">Connector</th>
<th scope="col">Версия коннектора</th>
<th scope="col">Версия сервера MySQL</th></tr></thead>
<tbody><tr><td scope="row">Connector/C</td><td>6.1.0 GA</td>
<td>5.6, 5.5, 5.1, 5.0, 4.1</td></tr><tr><td scope="row">Connector/C++</td>
<td>1.0.5 GA</td><td>5.6, 5.5, 5.1</td></tr>
<tr><td scope="row">Connector/J</td><td>5.1.8</td>
<td>5.6, 5.5, 5.1, 5.0, 4.1</td></tr>
<tr><td scope="row">Connector/Net</td><td>6.5</td>
<td>5.6, 5.5, 5.1, 5.0</td></tr>
<tr><td scope="row">Connector/Net</td><td>6.4</td>
<td>5.6, 5.5, 5.1, 5.0</td></tr>
<tr><td scope="row">Connector/Net</td><td>6.3</td>
<td>5.6, 5.5, 5.1, 5.0</td></tr>
<tr><td scope="row">Connector/Net</td><td>6.2 (Больше не поддерживается)</td>
<td>5.6, 5.5, 5.1, 5.0</td></tr>
<tr><td scope="row">Connector/Net</td><td>6.1 (Больше не поддерживается)</td>
<td>5.6, 5.5, 5.1, 5.0</td></tr>
<tr><td scope="row">Connector/Net</td><td>6.0 (Больше не поддерживается)</td>
<td>5.6, 5.5, 5.1, 5.0</td></tr>
<tr><td scope="row">Connector/Net</td><td>5.2 (Больше не поддерживается)</td>
<td>5.6, 5.5, 5.1, 5.0</td></tr>
<tr><td scope="row">Connector/Net</td><td>1.0 (Больше не поддерживается)</td>
<td>5.0, 4.0</td></tr>
<tr><td scope="row">Connector/ODBC</td><td>5.1</td>
<td>5.6, 5.5, 5.1, 5.0, 4.1.1+</td></tr>
<tr><td scope="row">Connector/ODBC</td><td>3.51 (Unicode не понимает)</td>
<td>5.6, 5.5, 5.1, 5.0, 4.1</td></tr>
<tr><td scope="row">Connector/Python</td><td>2.0</td>
<td>5.7, 5.6, 5.5</td></tr>
<tr><td scope="row">Connector/Python</td><td>1.2</td>
<td>5.7, 5.6, 5.5</td></tr></tbody></table>

<h2><a name="connector-odbc-info"></a>25.1. MySQL Connector/ODBC</h2>
<a class="indexterm" name="idm139965280318816"></a><p>Руководство по
MySQL Connector/ODBC публикуется отдельно, а не как часть руководства по
MySQL. Доступны следующие документы:</p>

<ul><li><p>Руководство: <a href="../../../dev.mysql.com/doc/connector-odbc/en/default.htm">
MySQL Connector/ODBC Developer Guide</a></li>
<li><a href="../../../dev.mysql.com/doc/relnotes/connector-odbc/en/default.htm">MySQL
Connector/ODBC Release Notes</a></p></li></ul>

<h2><a name="connector-net-info"></a>25.2. MySQL Connector/Net</h2>
<a class="indexterm" name="idm139965280312128"></a><p>Руководство по
MySQL Connector/Net публикуется отдельно, а не как часть руководства по
MySQL. Доступны следующие документы:</p>

<ul><li><p><a href="../../../dev.mysql.com/doc/connector-net/en/default.htm">MySQL
Connector/Net Developer Guide</a></li>
<li><a href="../../../dev.mysql.com/doc/relnotes/connector-net/en/default.htm">MySQL
Connector/Net Release Notes</a></p></li></ul>

<h2><a name="connector-j-info"></a>25.3. MySQL Connector/J</h2>
<p>Руководство по MySQL Connector/J публикуется отдельно, а не как часть
руководства по MySQL. Доступны следующие документы:</p>

<ul><li><p><a href="../../../dev.mysql.com/doc/connector-j/5.1/en/default.htm">MySQL
Connector/J 5.1 Developer Guide</a></li>
<li><a href="../../../dev.mysql.com/doc/relnotes/connector-j/en/default.htm">MySQL
Connector/J Release Notes</a></p></li></ul>

<h2><a name="connector-cpp-info"></a>25.4. MySQL Connector/C++</h2>
<p>Руководство по MySQL Connector/C++ публикуется отдельно, а не как часть
руководства по MySQL. Доступны следующие документы:</p>

<ul><li><p><a href="../../../dev.mysql.com/doc/connector-cpp/en/default.htm">MySQL
Connector/C++ Developer Guide</a></li>
<li><a href="../../../dev.mysql.com/doc/relnotes/connector-cpp/en/default.htm">MySQL
Connector/C++ Release Notes</a></p></li></ul>

<h2><a name="connector-c-info"></a>25.5. MySQL Connector/C</h2>
<p>Руководство по MySQL Connector/C публикуется отдельно, а не как часть
руководства по MySQL. Доступны следующие документы:</p>

<ul><li><p><a href="../../../dev.mysql.com/doc/connector-c/en/default.htm">MySQL
Connector/C Developer Guide</a></li>
<li><a href="../../../dev.mysql.com/doc/relnotes/connector-c/en/default.htm">MySQL
Connector/C Release Notes</a></p></li></ul>

<h2><a name="connector-python-info"></a>25.6. MySQL Connector/Python</h2>
<p>Руководство по MySQL Connector/Python публикуется отдельно, а не как часть
руководства по MySQL. Доступны следующие документы:</p>

<ul><li><p><a href="../../../dev.mysql.com/doc/connector-python/en/default.htm">MySQL
Connector/Python Developer Guide</a></li>
<li><a href="../../../dev.mysql.com/doc/relnotes/connector-python/en/default.htm">MySQL
Connector/Python Release Notes</a></p></li></ul>

<h2><a name="libmysqld"></a>25.7. libmysqld, встраиваемая библиотека сервера
MySQL</h2>
<p>Встраиваемая библиотека сервера MySQL позволяет выполнить
полнофункциональный сервер MySQL в приложении-клиенте. Основная выгода:
увеличенная скорость и более простое управление для встраиваемых приложений.
</p>

<p>Встроенная библиотека сервера основана на версии клиент-сервер MySQL,
которая написана на C/C++. Следовательно, встроенный сервер также написан на
C/C++. Нет никакого встроенного сервера, доступного на других языках.</p>

<p>API идентичен для встроенной версии MySQL и версии клиент-сервер. Чтобы
изменить поточное приложение так, чтобы пользоваться встроенной библиотекой,
Вы обычно только должны добавить вызовы в следующие функции.</p>

<a name="refman-apis-libmysqld-mysql-server-library-embeded-functions"></a>
<p><b>Таблица 25.3. Функции встраиваемой библиотеки сервера MySQL</b></p>
<table border="1"><thead><tr><th scope="col"><p>Функция</p></th>
<th scope="col"><p>Когда вызывается</p></th></tr></thead>
<tbody><tr><td scope="row"><p>
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a></p></td>
<td><p>Вызовите это прежде, чем любая другая функция MySQL будет вызвана,
предпочтительно пораньше в функции <code>main()</code>.</p></td></tr>
<tr><td scope="row"><p><a href="#mysql-library-end">
<code>mysql_library_end()</code></a></p></td>
<td><p>Вызовите перед завершением приложения.</p></td></tr>
<tr><td scope="row"><p><a href="#mysql-thread-init">
<code>mysql_thread_init()</code></a></p></td>
<td><p>Вызовите это в каждом потоке, который Вы создаете для доступа к MySQL.
</p></td></tr>
<tr><td scope="row"><a href="#mysql-thread-end"><code>
mysql_thread_end()</code></a></td><td>Вызовите это перед вызовом
<code>pthread_exit()</code>.</td></tr></tbody></table>

<p>Скомпонуйте свой код с <code>libmysqld.a</code> вместо
<code>libmysqlclient.a</code>. В целях двоичной совместимости приложения и
серверной библиотеки, всегда компилируйте приложение с заголовками от той
версии MySQL, которая использовалась для компиляции библиотеки. Например,
если <code>libmysqld</code> скомпилирована с заголовками MySQL 5.7, нельзя
компилировать приложение с заголовками от MySQL 8.0.</p>

<p>Поскольку функции <code>mysql_library_<em><code>xxx</code></em>()</code>
также включены в <code>libmysqlclient.a</code>, Вы можете переключаться между
версией клиент-сервер и встроенной, только компонуя Ваше приложение с
правильной библиотекой. См.
<a href="#mysql-library-init">раздел 25.8.7.41.
mysql_library_init()</a>.</p>
<p>Одно различие между встроенным и автономным сервером: у встроенного
сервера аутентификация для соединений отключена по умолчанию.</p>

<h3><a name="libmysqld-compiling"></a>25.7.1. Компиляция программ с libmysqld
</h3>
<p>В предварительно собранных двоичных дистрибутивах MySQL, которые включают
<code>libmysqld</code>, встроенную библиотеку сервера, MySQL создает
библиотеку, используя соответствующий компилятор, если он есть.</p>

<p>Чтобы получить библиотеку <code>libmysqld</code> при сборке MySQL из
исходных текстов, надо сконфигурировать MySQL с опцией
<a href="install.htm#option_cmake_with_embedded_server"><code>
-DWITH_EMBEDDED_SERVER=1</code></a>. См.
<a href="install.htm#source-configuration-options">раздел 2.8.4. Опции
настройки исходных текстов MySQL</a>.</p>

<p>Когда Вы компонуете свою программу с <code>libmysqld</code>, Вы должны
также включать определенные для системы библиотеки <code>pthread</code> и
некоторые библиотеки, которыми пользуется сервер MySQL. Вы можете получить
полный список библиотек, выполняя команду
<a href="programs.htm#mysql-config"><span><strong>mysql_config
--libmysqld-libs</strong></span></a>.</p>

<p>Правильные флаги для сборки поточной программы должны использоваться, даже
если Вы непосредственно не вызываете функций потока в своем коде.</p>

<p>Для компиляции программы на C, чтобы включать необходимые для встраивания
библиотеки сервера MySQL в выполняемую версию программы файлы, компилятор
должен будет знать, где найти различные файлы. Следующий пример показывает,
как программа могла быть собрана из командной строки, предполагая, что Вы
используете <span><strong>gcc</strong></span>:
<pre>
gcc mysql_test.c -o mysql_test \
    `/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`
</pre>

<p>Немедленно после команды <span><strong>gcc</strong></span> следует имя
исходного файла программы на C. После этого опция <code>-o</code> задана,
чтобы указать, что имя файла, которое следует за ней, является именем,
которое компилятор должен дать выходному файлу собранной программы.
Следующая строка предписывает компилятору получить местоположение включаемых
файлов и библиотек и других настроек для системы, на которой это собрано.</p>

<p>На некоторых не-<span><strong>gcc</strong></span> платформах
встроенная библиотека зависит от библиотеки времени выполнения C++.
Компоновка может привести к ошибкам недостающего символа (missing-symbol).
Чтобы решить это, явно перечислите необходимые библиотеки в командной строке
компоновщика или используйте в компоновке компилятор C++.</p>

<h3><a name="libmysqld-restrictions"></a>25.7.2. Ограничения использования
встроенного сервера MySQL</h3>
<p>У встроенного сервера есть следующие ограничения:</p>
<ul><li><p>Никакие определяемые пользователем функции (UDF) не работают.</li>
<li>Нет трассировки стека в дампе ядра.</li>

<li>Нет репликации (нельзя настроить как master или slave).</li>
<li>Очень большие наборы результатов могут быть непригодными на системах с
малым количеством памяти.</li>

<li>Вы не можете соединиться со встроенным сервером из внешнего процесса
через сокеты или TCP/IP. Однако, Вы можете соединиться с промежуточным
приложением, которое в свою очередь может соединиться со встроенным сервером
от имени удаленного клиента или вне процесса.</li>

<li><code>InnoDB</code> не используется повторно во встроенном сервере и не
может использоваться для нескольких соединений соединений (неважно,
последовательно или одновременно).</li>

<li>Нет планировщика событий (Event Scheduler). Из-за этого выключена
переменная <a href="server.htm#sysvar_event_scheduler"><code>
event_scheduler</code></a>.</li>

<li>Встроенный сервер не может совместно использовать тот же самый каталог
<a href="server.htm#sysvar_secure_file_priv"><code>
secure_file_priv</code></a> с другим сервером. Значение по умолчанию для
этого каталога может быть установлено при сборке опцией
<a href="install.htm#option_cmake_install_secure_file_priv_embeddeddir">
<code>INSTALL_SECURE_FILE_PRIV_EMBEDDEDDIR</code></a> для
<span><strong>CMake</strong></span>.</p></li></ul>
<p>Некоторые из этих ограничений могут быть изменены, редактируя включаемый
файл <code>mysql_embed.h</code> и перекомпилируя MySQL.</p>

<h3><a name="libmysqld-options"></a>25.7.3. Опции встроенного сервера</h3>
<p>Любые опции, которые могут быть заданы демоном сервера
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>,
могут использоваться со встроенной библиотекой сервера. Параметры сервера
могут быть даны в массиве как параметр функции
<a href="#mysql-library-init">
<code>mysql_library_init()</code></a>, которая инициализирует сервер.
Им также можно дать в файле опций (хотя бы <code>my.cnf</code>). Чтобы
определить файл опций для программы C, используйте параметр
<a href="programs.htm#option_general_defaults-file"><code>--defaults-file
</code></a> как один из элементов второго параметра функции
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a>. См. <a href="#mysql-library-init">раздел
25.8.7.41. mysql_library_init()</a>.</p>

<p>Использование файла опций может облегчить переключение между приложением
клиент-сервер и тем, где MySQL встроен. Поместите общие опции под группу
<code>[server]</code>. Они будут считаны обеими версиями MySQL. Опции для
Client/server-версии должны быть в секции <code>[mysqld]</code>. Опции для
встроенной библиотеки сервера MySQL пишутся в разделе <code>[embedded]</code>.
Опции, определенные для приложений, идут в разделе
<code>[ApplicationName_SERVER]</code>.</p>

<h3><a name="libmysqld-example"></a>25.7.4. Примеры встроенного сервера</h3>
<p>Эти два примера программы должны работать без изменений в Linux или
FreeBSD. Для других операционных систем незначительные изменения необходимы,
главным образом, с путями к файлам. Эти примеры разработаны, чтобы дать
достаточно информации для Вас, чтобы понять необходимую часть реального
приложения. Первый пример является очень простым. Второй пример немного
усовершенствован с некоторой проверкой на ошибки. Для первого приведена
команда для сборки, для второго показан файл сборки GNUmake.</p>

<p><strong>Пример 1</strong></span></p>
<p><code>test1_libmysqld.c</code>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include "mysql.h"

MYSQL *mysql;
MYSQL_RES *results;
MYSQL_ROW record;

static char *server_options[] = \
  { "mysql_test", "--defaults-file=my.cnf", NULL };
int num_elements = (sizeof(server_options) / sizeof(char *)) - 1;

static char *server_groups[] = { "libmysqld_server",
  "libmysqld_client", NULL };

int main(void)
{
  mysql_library_init(num_elements, server_options, server_groups);
  mysql = mysql_init(NULL);
  mysql_options(mysql, MYSQL_READ_DEFAULT_GROUP, "libmysqld_client");
  mysql_options(mysql, MYSQL_OPT_USE_EMBEDDED_CONNECTION, NULL);
  mysql_real_connect(mysql, NULL,NULL,NULL, "database1", 0,NULL,0);
  mysql_query(mysql, "SELECT column1, column2 FROM table1");
  results = mysql_store_result(mysql);
  while((record = mysql_fetch_row(results))) {
    printf("%s - %s \n", record[0], record[1]);
  }
  mysql_free_result(results);
  mysql_close(mysql);
  mysql_library_end();
  return 0;
}
</pre>

<p>Вот командная строка для того, чтобы собрать вышеупомянутую программу:
<pre>
gcc test1_libmysqld.c -o test1_libmysqld \
    `/usr/local/mysql/bin/mysql_config --include --libmysqld-libs`
</pre>

<p><strong>Пример 2</strong></span>
<p>Чтобы опробовать пример, создайте каталог <code>test2_libmysqld</code>
на том же самом уровне как исходный каталог MySQL. Сохраните
<code>test2_libmysqld.c</code> и <code>GNUmakefile</code> в нем и запустите
GNU <code>make</code> из каталога <code>test2_libmysqld</code>.</p>

<p><code>test2_libmysqld.c</code>
<pre>
/*
 * A simple example client, using the embedded MySQL server library
*/

#include &lt;mysql.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

MYSQL *db_connect(const char *dbname);
void db_disconnect(MYSQL *db);
void db_do_query(MYSQL *db, const char *query);

const char *server_groups[] = {
  "test2_libmysqld_SERVER", "embedded", "server", NULL};

int main(int argc, char **argv)
{
  MYSQL *one, *two;

  /* mysql_library_init() must be called before any other mysql
   * functions.
   *
   * You can use mysql_library_init(0, NULL, NULL), and it
   * initializes the server using groups = {
   *   "server", "embedded", NULL
   *  }.
   *
   * In your $HOME/.my.cnf file, you probably want to put:

[test2_libmysqld_SERVER]
language = /path/to/source/of/mysql/sql/share/english
   * You could, of course, modify argc and argv before passing
   * them to this function.  Or you could create new ones in any
   * way you like.  But all of the arguments in argv (except for
   * argv[0], which is the program name) should be valid options
   * for the MySQL server.
   *
   * If you link this client against the normal mysqlclient
   * library, this function is just a stub that does nothing.
   */
  mysql_library_init(argc, argv, (char **)server_groups);
  one = db_connect("test");
  two = db_connect(NULL);
  db_do_query(one, "SHOW TABLE STATUS");
  db_do_query(two, "SHOW DATABASES");
  mysql_close(two);
  mysql_close(one);
  /* This must be called after all other mysql functions */
  mysql_library_end();
  exit(EXIT_SUCCESS);
}

static void die(MYSQL *db, char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt);
  vfprintf(stderr, fmt, ap);
  va_end(ap);
  (void)putc('\n', stderr);
  if (db) db_disconnect(db);
  exit(EXIT_FAILURE);
}

MYSQL *db_connect(const char *dbname)
{
  MYSQL *db = mysql_init(NULL);
  if (!db) die(db, "mysql_init failed: no memory");
  /*
   * Notice that the client and server use separate group names.
   * This is critical, because the server does not accept the
   * client's options, and vice versa.
   */
  mysql_options(db, MYSQL_READ_DEFAULT_GROUP, "test2_libmysqld_CLIENT");
  if (!mysql_real_connect(db, NULL, NULL, NULL, dbname, 0, NULL, 0))
     die(db, "mysql_real_connect failed: %s", mysql_error(db));
  return db;
}

void db_disconnect(MYSQL *db)
{
  mysql_close(db);
}

void db_do_query(MYSQL *db, const char *query)
{
  if (mysql_query(db, query) != 0) goto err;
  if (mysql_field_count(db) &gt; 0)
  {
     MYSQL_RES   *res;
     MYSQL_ROW    row, end_row;
     int num_fields;

     if (!(res = mysql_store_result(db))) goto err;
     num_fields = mysql_num_fields(res);
     while ((row = mysql_fetch_row(res))) {
       (void)fputs("&gt;&gt; ", stdout);
       for (end_row = row + num_fields; row &lt; end_row; ++row)
         (void)printf("%s\t", row ? (char*)*row : "NULL");
       (void)fputc('\n', stdout);
     }
     (void)fputc('\n', stdout);
     mysql_free_result(res);
  }
  else (void)printf("Affected rows: %lld\n", mysql_affected_rows(db));
  return;
err:
  die(db, "db_do_query failed: %s [%s]", mysql_error(db), query);
}
</pre>

<p><code>GNUmakefile</code>
<pre>
# This assumes the MySQL software is installed in /usr/local/mysql
inc:= /usr/local/mysql/include/mysql
lib:= /usr/local/mysql/lib

# If you have not installed the MySQL software yet, try this instead
#inc:= $(HOME)/mysql-8.0/include
#lib:= $(HOME)/mysql-8.0/libmysqld

CC := gcc
CPPFLAGS := -I$(inc) -D_THREAD_SAFE -D_REENTRANT
CFLAGS   := -g -W -Wall
LDFLAGS  := -static
# You can change -lmysqld to -lmysqlclient to use the
# client/server library
LDLIBS    = -L$(lib) -lmysqld -lm -ldl -lcrypt

ifneq (,$(shell grep FreeBSD /COPYRIGHT 2&gt;/dev/null))
# FreeBSD
LDFLAGS += -pthread
else
# Assume Linux
LDLIBS += -lpthread
endif

# This works for simple one-file test programs
sources := $(wildcard *.c)
objects := $(patsubst %c,%o,$(sources))
targets := $(basename $(sources))

all: $(targets)

clean:
  rm -f $(targets) $(objects) *.core
</pre>

<h2><a name="c-api"></a>25.8. MySQL C API</h2>
<p>C API обеспечивает низкоуровневый доступ к MySQL протоколу клиент-сервер и
позволяет программам на C получить доступ к содержимому базы данных. Код C
API распространяется с MySQL и реализован в библиотеке
<code>libmysqlclient</code>.</p>

<p>Большинство других API используют <code>libmysqlclient</code>, чтобы
общаться с сервером MySQL. Это означает, что, например, Вы можете
использовать в своих интересах многие из тех же самых переменных окружения,
которые используются другими программами-клиентами, потому что на них есть
ссылки из библиотеки. Для получения списка этих переменных, см.
<a href="programs.htm#programs-overview">раздел 5.1. Обзор программ MySQL
</a>.</p>

<p>Для инструкций по созданию программ-клиентов, используя C API, см.
<a href="#c-api-building-clients">раздел
25.8.4.1. Создание программ-клиентов C API</a>. Для того, чтобы
программировать с потоками, см.
<a href="#c-api-threaded-clients">раздел 25.8.4.3.
Написание поточных программ-клиентов C API</a>. Чтобы создать автономное
приложение, которое включает клиент и сервер в той же самой программе (и не
общается с внешним сервером MySQL), см.
<a href="#libmysqld">раздел 25.7. libmysqld, библиотека
встроенного сервера MySQL</a>.</p>

<p>Если после обновления Вы испытываете проблемы с собранными
программами-клиентами, например, <code>Commands out of sync</code> или
дамп ядра, программы были, вероятно, собраны, используя старый заголовок или
файлы библиотеки. В этом случае, проверьте дату файла
<code>mysql.h</code> и библиотеки <code>libmysqlclient.a</code>,
использованных для компиляции, на предмет их соответствия новой версии MySQL.
Если не совпадают, повторно соберите программы с новыми заголовками и
библиотеками. Перекомпиляция также может быть необходимой для программ,
собранных с совместно используемой библиотекой клиента, если главный номер
версии библиотеки изменился (например, <code>libmysqlclient.so.17</code>
сменилась на <code>libmysqlclient.so.18</code>).</p>

<p>У клиентов есть максимальный размер коммуникационного буфера. Размер
буфера, который выделен первоначально (16 КБ), автоматически увеличен до
максимального размера (16 МБ по умолчанию). Поскольку буферные размеры
увеличены только по мере надобности, простое увеличение максимального предела
само по себе не заставляет использовать больше ресурсов. Эта проверка размера
направлена, главным образом, против ошибочных
команд и коммуникационных пакетов.</p>

<p>Коммуникационный буфер должен быть достаточно большим, чтобы вместить
единственное выражение SQL (для трафика client-server) и одну строку
возвращенных данных (для трафика server-client). Коммуникационный буфер
каждого сеанса будет динамически увеличен до максимального предела, чтобы
обработать любой запрос или строку. Например, если Вы имеете объект типа
<code>BLOB</code>, который содержит до 16 МБ данных, у Вас должен быть предел
коммуникационного буфера по крайней мере 16 МБ (и в сервере, и в клиенте).
Максимумом значения по умолчанию, встроенным в библиотеку клиента, является
1GB, но максимум значения по умолчанию в сервере составляет 1 МБ. Вы можете
увеличить это, изменяя значение параметра
<a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a> при запуске сервера. См.
<a href="server.htm#server-configuration">
раздел 6.1.1. Настройка сервера</a>.</p>

<p>Сервер MySQL сокращает каждый коммуникационный буфер до
<a href="server.htm#sysvar_net_buffer_length"><code>
net_buffer_length</code></a> байт после каждого запроса. Для клиентов размер
буфера, связанного с соединением, не будет уменьшен, пока
соединение не закрыто.</p>

<h3><a name="c-api-implementations"></a>25.8.1. Реализация MySQL C API</h3>
<p>MySQL C API является API, который приложения-клиенты, написанные на C,
могут использовать, чтобы общаться с сервером MySQL. Программы-клиенты во
время компиляции ссылаются на заголовочные файлы C API, а в процессе
компоновки компонуются с файлом библиотеки C API. Библиотека есть в двух
версиях, в зависимости от того, как приложение будет общаться с сервером:</p>

<ul><li><p><code>libmysqlclient</code>: Версия библиотеки, используется для
приложений, которые общаются по сетевому соединению как клиент
процесса автономного сервера.</li>

<li><code>libmysqld</code>: Встроенная версия сервера, используется для
приложений, которым надо иметь встроенный сервер MySQL в пределах приложения
непосредственно. Приложение общается с его собственным частным сервером.
</p></li></ul>

<p>У обеих библиотек есть тот же самый интерфейс. С точки зрения C API,
приложение общается с автономным сервером тем же самым путем, что и со
встроенным сервером. Клиент может быть создан, чтобы общаться с автономным
или встроенным сервером, в зависимости от того, как он скомпонован.</p>

<p>Есть два способа получить заголовок и файлы библиотеки C API, требуемые
чтобы создавать программы клиента C API:</p>
<ul><li><p>Установить пакет MySQL Server. Он включаект в себя
<code>libmysqlclient</code> и <code>libmysqld</code>.</li>
<li>Установить пакет Connector/C. Он включает только <code>libmysqlclient
</code>, но не <code>libmysqld</code>.</p></li></ul>

<p>В обоих случаях Вы можете установить двоичный дистрибутив, который
содержит прекомпилированные файлы C API, или Вы можете использовать
дистрибутив исходных текстов, чтобы собрать C API лично.</p>

<p>Обычно Вы устанавливаете что-то одно. Для получения информации о
проблемах, связанных с одновременной установкой MySQL Server и Connector/C,
см. <a href="#c-api-multiple-installations">раздел 25.8.2</a>.</p>

<p>Имена файлов библиотеки, для компоновки клиентов с C API зависят от типа
библиотеки и платформы, для которой создан дистрибутив:</p>
<ul><li><p>На Unix-системах статическая библиотека
<code>libmysqlclient.a</code>. Динамическая <code>libmysqlclient.so</code> на
на большинстве Unix-систем и <code>libmysqlclient.dylib</code> под OS X.</p>

<p>Для дистрибутивов, которые включают встроенные библиотеки сервера,
соответствующие имена библиотеки начинаются с
<code>libmysqld</code> вместо <code>libmysqlclient</code>.</li>

<li>Под Windows статическая библиотека <code>mysqlclient.lib</code> и
динамическая <code>libmysql.dll</code>. Также там есть
<code>libmysql.lib</code>, это статическая библиотека импорта, необходимая
для того, чтобы пользоваться динамической библиотекой.</p>

<p>Для дистрибутивов, которые включают встроенные библиотеки сервера,
соответствующие имена библиотек: <code>mysqlserver.lib</code>,
<code>libmysqld.dll</code> и <code>libmysqld.lib</code>.</p>

<p>Windows-дистрибутивы также включают набор библиотек для отладки. Они имеют
те же самые имена, что и библиотеки не для отладки, но расположены в
<code>lib/debug</code>. Вы должны пользоваться библиотеками отладки, когда
компилируете клиентов для использования отладки C runtime.</p></li></ul>

<p>Под Unix Вы можете также видеть библиотеки, которые включают в имена
<code>_r</code>. До MySQL 5.5 они были созданы как безопасные для потоков
(повторно используемые) библиотеки отдельно от не-<code>_r</code> версий.
С 5.5, обе библиотеки то же самое, а <code>_r</code>-имена являются ссылками
на не-<code>_r</code>-имена. Нет никакой надобности использовать
<code>_r</code>-библиотеки. Например, если Вы используете
<a href="programs.htm#mysql-config"><span><strong>mysql_config</strong>
</span></a>, чтобы получить флаги компоновщика, Вы можете использовать
<a href="programs.htm#mysql-config"><span><strong>mysql_config --libs
</strong></span></a>, во всех случаях, даже для поточных клиентов. Нет
никакой потребности использовать <a href="programs.htm#mysql-config"><span>
<strong>mysql_config --libs_r</strong></span></a>.</p>

<h3><a name="c-api-multiple-installations"></a>25.8.2. Совместная установка
MySQL Server и Connector/C</h3>
<p>Пакеты MySQL Server и Connector/C обеспечивают файлы для сборки и запуска
клиентов MySQL C API. Этот раздел обсуждает, когда возможно установить оба
продукта на той же самой системе. Для некоторых форматов упаковки это
возможно без конфликта. Для других оба продукта не могут быть установлены в
то же самое время.</p>

<p>Это обсуждение принимает использование подобных типов пакета для обоих
продуктов (например, пакеты RPM). Это не пытается описать сосуществование
пакетов разных типов (например, использование пакетов RPM
<span><strong>tar</strong></span> вместе). Также не рассматривается
сосуществование пакетов от Oracle и третьих лиц.</p>

<p>Если Вы устанавливаете оба продукта, может быть необходимо скорректировать
Ваши средства разработки или среду выполнения, чтобы выбрать один набор
заголовочных файлов и библиотек. См. разделы
<a href="#c-api-building-clients">25.8.4.1. Создание
клиентов C API</a> и <a href="#c-api-running-clients">
25.8.4.4. Запуск клиентов C API</a>.</p>

<p><span><strong>tar</strong></span> и Zip-файлы устанавливаются в
соответствии с каталогом, в который Вы распаковываете их. Например, Вы можете
распаковать MySQL Server и Connector/C <span><strong>tar</strong></span> под
<code>/usr/local</code>, и они распакуются в различные имена
каталогов без конфликта.</p>

<p>Windows MSI использует свой собственный каталог установки, таким образом,
MySQL Server и Connector/C не находятся в противоречии.</p>
<p>OS X DMG ставятся в соответствии с тем же самым родительским каталогом, но
в различные подкаталоги, таким образом, нет никакого конфликта. Например:
<pre>
/usr/local/mysql-5.6.11-osx10.7-x86_64/
/usr/local/mysql-connector-c-6.1.0-osx10.7-x86/
</pre>

<p>Solaris PKG ставятся в соответствии с тем же самым родительским каталогом, но
в различные подкаталоги, таким образом, нет никакого конфликта. Например:
<pre>
/opt/mysql/mysql
/opt/mysql/connector-c
</pre>

<p>Solaris Connector/C не создает символьных ссылок из системных каталогов
таких, как <code>/usr/bin</code> или <code>/usr/lib</code> в каталог
установки. Это должно быть сделано вручную при желании после установки.</p>

<p>Для RPM есть несколько типов пакетов RPM. MySQL Server <code>shared</code>
и <code>devel</code> RPM-пакеты подобны соответствующим пакетам RPM
Connector/C. Эти типы пакетов RPM не могут сосуществовать, потому что
RPM-пакеты MySQL Server и Connector/C используют те же самые места установки
для связанных с библиотекой файлов. Это означает следующие условия:</p>

<ul><li><p>Если установлены RPM-пакеты MySQL Server <code>shared</code> и
<code>devel</code>, они обеспечивают заголовки и библиотеки C API, и нет
никакой потребности установить пакеты Connector/C RPM. Для установки пакета
Connector/C Вы должны сначала удалить соответствующие пакеты MySQL Server.
</li>

<li>Чтобы установить RPM-пакеты MySQL Server, если у Вас уже есть
установленные RPM-пакеты Connector/C, Вы должны сначала удалить пакеты
RPM-пакеты Connector/C.</p></li></ul>

<p>RPM-пакеты MySQL Server кроме <code>shared</code> и <code>devel</code>
не находятся в противоречии с пакетами Connector/C, и могут быть установлены,
если стоит Connector/C. Это включает основной RPM-пакет
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.</p>

<h3><a name="c-api-example-programs"></a>25.8.3. Пример клиента C API</h3>
<p>Многие из клиентов в исходных текстах MySQL написаны на C, такие как
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>,
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin</strong></span>
</a> и <a href="programs.htm#mysqlshow"><span><strong>mysqlshow</strong>
</span></a>. Если Вы ищете примеры, которые демонстрируют, как использовать C
API, посмотрите на этих клиентов. В пакете исходных текстов пакета они
обитают в каталоге <code>client</code>.</p>

<h3><a name="c-api-building-running-clients"></a>25.8.4. Сборка и запуск
программ-клиентов C API</h3>
<p>Следующие разделы предоставляют информацию о создании программ-клиентов,
которые используют C API. Темы включают компиляцию и компоновку клиентов,
написание поточных клиентов и поиск неисправностей во время выполнения.</p>

<h4><a name="c-api-building-clients"></a>25.8.4.1. Сборка программ-клиентов C
API</h4>
<h5><a name="idm139965280067552"></a>Компиляция клиентов MySQL под Unix</h5>
<p>Примеры здесь используют <span><strong>gcc</strong></span> в качестве
компилятора. На некоторых системах могут быть другие компиляторы (например,
<span><strong>clang</strong></span> под OS X или FreeBSD, или Sun Studio под
Solaris). Скорректируйте примеры по мере необходимости.</p>

<p>Вы, возможно, должны определить опцию <code>-I</code>, когда Вы собираете
программу-клиента, которая использует заголовочные файлы MySQL, так, чтобы
компилятор мог найти их. Например, если заголовочные файлы установлены в
<code>/usr/local/mysql/include</code>, используйте эту опцию:
<pre>
-I/usr/local/mysql/include
</pre>

<p>Клиенты MySQL должны быть скомпонованы, используя опцию
<code>-lmysqlclient</code>. Вы, возможно, также должны определить опцию
<code>-L</code>, чтобы сказать компоновщику, где найти библиотеку. Например,
если библиотека установлена в <code>/usr/local/mysql/lib</code>, используйте
эти опции в команде:
<pre>
-L/usr/local/mysql/lib -lmysqlclient
</pre>

<p>Пути могут быть другими в Вашей системе. Корректируйте опции
<code>-I</code> и <code>-L</code> соответственно.</p>
<p>Чтобы сделать более простым процесс сборки, используйте скрипт
<a href="programs.htm#mysql-config"><span><strong>mysql_config</strong>
</span></a>.</p>

<p><a href="programs.htm#mysql-config"><span><strong>mysql_config</strong>
</span></a> выводит на экран опции, необходимые для
компиляции или компоновки:
<pre>
shell&gt; <strong><code>mysql_config --cflags</code></strong>
shell&gt; <strong><code>mysql_config --libs</code></strong>
</pre>

<p>Вы можете выполнить эти команды, чтобы получить надлежащие опции и
добавить их вручную к командам компиляции или компоновки. Альтернативно,
включайте вывод <a href="programs.htm#mysql-config"><span><strong>
mysql_config</strong></span></a> непосредственно в командные строки,
используя символы апострофа:

<pre>
shell&gt; <strong><code>gcc -c `mysql_config --cflags` progname.c</code></strong>
shell&gt; <strong><code>gcc -o progname progname.o `mysql_config --libs`</code></strong>
</pre>

<p>Под Unix компоновщик пользуется динамическими библиотеками по умолчанию.
Чтобы скомпоновать со статической библиотекой клиента вместо этого, добавьте
ее путь к команде. Например, если библиотека расположена в
<code>/usr/local/mysql/lib</code>:
<pre>
shell&gt; <strong><code>gcc -o progname progname.o /usr/local/mysql/lib/libmysqlclient.a</code></strong>
</pre>

<p>Или используйте <a href="programs.htm#mysql-config"><span><strong>
mysql_config</strong></span></a>, чтобы обеспечить имя библиотеки:
<pre>
shell&gt; <strong><code>gcc -o progname progname.o `mysql_config --variable=pkglibdir`/libmysqlclient.a</code></strong>
</pre>

<p><a href="programs.htm#mysql-config"><span><strong>mysql_config</strong>
</span></a> в настоящее время не обеспечивает способа перечислить все
библиотеки, необходимые для статической компоновки, таким образом, может быть
необходимо назвать дополнительные библиотеки (например,
<code>-lnsl -lsocket</code> под Solaris). Чтобы понять, какие библиотеки
добавить, используйте <a href="programs.htm#mysql-config"><span><strong>
mysql_config --libs</strong></span></a> и <span><strong>ldd libmysqlclient.so
</strong></span> (или <span><strong>otool -L libmysqlclient.dylib</strong>
</span> под OS X).</p>

<p><span><strong>pkg-config</strong></span> может использоваться в качестве
альтернативы <a href="programs.htm#mysql-config"><span><strong>mysql_config
</strong></span></a> для того, чтобы получить информацию, такую как флаги
компилятора или библиотеки, требуемые, чтобы собрать приложения MySQL.
Например, следующие пары команд эквивалентны:

<pre>
mysql_config --cflags
pkg-config --cflags mysqlclient

mysql_config --libs
pkg-config --libs mysqlclient
</pre>

<p>Чтобы получить флаги для статической компоновки, используйте эту команду:
<pre>
pkg-config --static --libs mysqlclient
</pre>

<h5><a name="idm139965280028064"></a>Компиляция клиентов MySQL под Windows
</h5>
<p>Чтобы определить местоположение заголовка и файла библиотеки, используйте
способы, предоставленные Вашей средой проектирования.</p>
<p>Для сборки клиентов C API под Windows, Вы должны скомпоновать клиентскую
библиотеку C, Windows ws2_32 sockets и библиотеку Secur32.</p>

<p>Под Windows Вы можете компоновать свой код с динамической или статической
библиотекой клиента C. Статическую библиотеку называют
<code>mysqlclient.lib</code>, а динамическую библиотеку
<code>libmysql.dll</code>. Кроме того, статическая библиотека импорта
<code>libmysql.lib</code> необходима для того, чтобы
пользоваться динамической библиотекой.</p>

<p>Если Вы компонуете со статической библиотекой, отказ может произойти, если
эти условия не удовлетворены:</p>
<ul><li><p>Приложение-клиент должно быть собрано той же самой версией
Visual Studio, которая использовалась, чтобы собрать библиотеку.</li>
<li>Приложение-клиент должно скомпоновать C runtime статически при
использовании опции компилятора <code>/MT</code>.</p></li></ul>

<p>Если приложение-клиент создано в режиме отладки и использует статический
отладочный C runtime (опция компилятора <code>/MTd</code>), это может
компоноваться со статической библиотекой <code>mysqlclient.lib</code>, если
эта библиотека была создана, используя ту же самую опцию. Если
приложение-клиент использует динамический отладочный C runtime
(опция <code>/MD</code> или <code>/MDd</code> в режиме отладки), это должно
быть скомпоновано с динамической библиотекой <code>libmysql.dll</code>. Это
не может компоноваться со статической библиотекой клиента.</p>

<p>Страница MSDN, описывающая опции:
<a href="../../../msdn.microsoft.com/en-us/library/2kzt1wy3.aspx">
http://msdn.microsoft.com/en-us/library/2kzt1wy3.aspx</a>.</p>

<h5><a name="idm139965280011584"></a>Решение проблем компоновки с клиентской
библиотекой MySQL</h5>
<p>Библиотека клиентов MySQL включает встроенную поддержку SSL. Не нужно
определить также <code>-lssl</code> или <code>-lcrypto</code> во время
компоновки. Это может фактически привести к проблемам во времени выполнения.
</p>

<p>Если компоновщик не может найти библиотеку клиентов MySQL, Вы можете
получить ошибки неопределенной ссылки для символов, которые начинаются с
<code>mysql_</code>:

<pre>
/tmp/ccFKsdPa.o: In function `main':
/tmp/ccFKsdPa.o(.text+0xb): undefined reference to `mysql_init'
/tmp/ccFKsdPa.o(.text+0x31): undefined reference to `mysql_real_connect'
/tmp/ccFKsdPa.o(.text+0x69): undefined reference to `mysql_error'
/tmp/ccFKsdPa.o(.text+0x9a): undefined reference to `mysql_close'
</pre>

<p>Вы должны быть в состоянии решить эту проблему, добавляя
<code>-L<em><code>dir_path</code></em> -lmysqlclient</code> в конце Вашей
команды компоновки, где <em><code>dir_path</code></em> задает путь каталога,
где расположена библиотека клиентов. Чтобы определить правильный каталог,
попробуйте эту команду:
<pre>
shell&gt; <strong><code>mysql_config --libs</code></strong>
</pre>

<p>Вывод <a href="programs.htm#mysql-config"><span><strong>mysql_config
</strong></span></a> может указать на другие библиотеки, которые должны быть
определены в команде компоновки. Вы можете включать вывод
<a href="programs.htm#mysql-config"><span><strong>mysql_config</strong>
</span></a> непосредственно в Вашу команду:
<pre>
shell&gt; <strong><code>gcc -o progname progname.o `mysql_config --libs`</code></strong>
</pre>

<p>Если ошибка происходит во время компоновки, когда символ
<code>floor</code> не определен, скомпонуйте с математической библиотекой,
добавляя <code>-lm</code> в конец команды. Точно так же, если Вы получаете
ошибки неопределенной ссылки для других функций, которые должны существовать
в Вашей системе, таких как <code>connect()</code>, проверьте страницу
руководства на рассматриваемую функцию, чтобы определить, какие библиотеки Вы
должны добавить к команде.</p>

<p>Если Вы получаете ошибки неопределенной ссылки, такие как следующяя, для
функций, которые не существуют на Вашей системе, это обычно означает, что
Ваша библиотека клиента MySQL была собрана на системе, которая не
на 100% совместима с Вашей:
<pre>
mf_format.o(.text+0x201): undefined reference to `__lxstat'
</pre>

<p>В этом случае Вы должны загрузить последний дистрибутив исходных текстов
MySQL или Connector/C и собрать библиотеку клиента MySQL самостоятельно. См.
<a href="install.htm#source-installation">раздел 2.8. Установка MySQL из
исходных текстов</a> и <a href="../../../dev.mysql.com/doc/connector-c/en/default.htm">
MySQL Connector/C Developer Guide</a>.</p>

<h4><a name="c-api-building-clients-pkg-config"></a>25.8.4.2.
Сборка клиентов C API с применением pkg-config</h4>
<p>MySQL включает файл <code>mysqlclient.pc</code>, который предоставляет
информацию о конфигурации MySQL для использования командой
<span><strong>pkg-config</strong></span>. Это позволяет
<span><strong>pkg-config</strong></span> использоваться в качестве
альтернативы <a href="programs.htm#mysql-config"><span><strong>mysql_config
</strong></span></a> для того, чтобы получить такую информацию, как флаги
компилятора или библиотеки, требуемые, чтобы собирать приложения MySQL.
Например, следующие пары команд эквивалентны:
<pre>
mysql_config --cflags
pkg-config --cflags mysqlclient

mysql_config --libs
pkg-config --libs mysqlclient
</pre>

<p>Последняя команда <span><strong>pkg-config</strong></span> производит
флаги для динамической компоновки. Чтобы произвести флаги для статической
компоновки, используйте эту команду:
<pre>
pkg-config --static --libs mysqlclient
</pre>

<p>На некоторых платформах вывод с и без <code>--static</code> одинаков.</p>
<p>Если <span><strong>pkg-config</strong></span> не находит информацию о
MySQL, может быть необходимо установить переменную окружения
<code>PKG_CONFIG_PATH</code> к каталогу, где расположен файл
<code>mysqlclient.pc</code>, обычно это подкаталог <code>pkgconfig</code>
каталога библиотек MySQL. Например
(корректируйте местоположение соответственно):
<pre>
export PKG_CONFIG_PATH=/usr/local/mysql/lib/pkgconfig # sh, bash, ...
setenv PKG_CONFIG_PATH /usr/local/mysql/lib/pkgconfig # csh, tcsh, ...
</pre>

<p>Местоположением установки <code>mysqlconfig.pc</code> можно управлять,
используя опцию
<a href="install.htm#option_cmake_install_pkgconfigdir"><code>
INSTALL_PKGCONFIGDIR</code></a> <span><strong>CMake</strong></span>.</p>

<p>Опция <code>--variable</code> берет имя переменной конфигурации и выводит
на экра значениен переменной:
<pre>
pkg-config --variable=prefix mysqlclient     # installation prefix directory
pkg-config --variable=includedir mysqlclient # header file directory
pkg-config --variable=libdir mysqlclient     # library directory
</pre>

<p>Чтобы посмотреть значение переменной с помощью
<span><strong>pkg-config</strong></span>, используйте параметр
<code>--variable</code>:
<pre>
pkg-config --print-variables mysqlclient
</pre>

<p>Вы можете использовать <span><strong>pkg-config</strong></span>
в пределах командной строки, используя апострофы, чтобы включить вывод,
который она производит для особых опций. Например, чтобы откомпилировать и
скомпоновать клиентскую программу MySQL, используйте
<span><strong>pkg-config</strong></span> так:
<pre>
gcc -c `pkg-config --cflags mysqlclient` progname.c
gcc -o progname progname.o `pkg-config --libs mysqlclient`
</pre>

<h4><a name="c-api-threaded-clients"></a>25.8.4.3. Написание поточных
клиентов C API</h4>
<p>Библиотека клиента почти безопасна для потоков. Самая большая проблема
состоит в том что подпрограммы в <code>sql/net_serv.cc</code>, которые
читают сокеты, не защищены от прерывания. Это было сделано с мыслью о том,
что Вы можете хотеть иметь свой собственный аварийный сигнал, который может
прервать долгое обращение к серверу. Если Вы устанавливаете обработчики
прерывания для <code>SIGPIPE</code>, обработка сокета должна быть
безопасной для потоков.</p>

<p>Чтобы программа не вылетела при прерывании соединения, MySQL блокирует
<code>SIGPIPE</code> при первом обращении к
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a>, <a href="#mysql-init"><code>mysql_init()
</code></a> или <a href="#mysql-connect"><code>
mysql_connect()</code></a>. Чтобы поставить свой обработчик
<code>SIGPIPE</code>, сначала вызовите
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a>, а потом установите свой обработчик.</p>

<p>Если происходят ошибки <span>undefined symbol</span> при компоновке с
<code>libmysqlclient</code>, в большинстве случаев это потому, что Вы не
включили библиотеки потока.</p>

<p>Библиотека клиента безопасна для потоков на соединении. Вы можете
позволить двум потокам совместно использовать то же самое соединение
со следующими оговорками:</p>

<ul><li><p>Несколько потоков не должны посылать запрос серверу MySQL в то же
самое время на том же самом соединении. В частности Вы должны гарантировать,
что между вызовами
<a href="#mysql-query"><code>mysql_query()</code></a> и
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> в одном потоке, никакой другой поток не использует то же самое
соединение. У Вас должна быть блокировка mutex вокруг Вашей пары вызовов
<a href="#mysql-query"><code>mysql_query()</code></a> и
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>. После вызова
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> блокировка может быть снята, и другие потоки могут запросить то
же самое соединение.</p>

<p>Если Вы используете потоки POSIX, Вы можете использовать
<code>pthread_mutex_lock()</code> и <code>pthread_mutex_unlock()</code>,
чтобы установить и выпустить блокировку mutex.</li>

<li>Много потоков могут получить доступ к различным наборам результатов,
которые получены с <a href="#mysql-store-result"><code>
mysql_store_result()</code></a>.</li>

<li>Используя <a href="#mysql-use-result">
<code>mysql_use_result()</code></a>, Вы должны гарантировать, что никакой
другой поток не использует то же самое соединение, пока набор результатов не
закрыт. Однако, это действительно является лучшим для поточных клиентов,
которые совместно используют то же самое соединение с использованием
<a href="#mysql-store-result">
<code>mysql_store_result()</code></a>.</p></li></ul>

<p>Вы должны знать следующее, если у Вас есть поток, который не создавал
соединение с базой данных MySQL, но вызывает функции MySQL:</p>
<p>При вызове <a href="#mysql-init">
<code>mysql_init()</code></a> MySQL создает определенную для потока
переменную, которая используется библиотекой отладки (в том числе). Если Вы
вызываете функцию MySQL прежде, чем поток вызовет
<a href="#mysql-init"><code>mysql_init()</code></a>,
у потока нет необходимых определенных для потока переменных, и Вы, вероятно,
закончите с дампом памяти рано или поздно. Чтобы избежать проблем, Вы
должны сделать следующее:</p>

<ol type="1"><li><p>Вызвать <a href="#mysql-library-init">
<code>mysql_library_init()</code></a> перед любыми другими функциями MySQL.
Это не безопасно для потока, так что вызовите это прежде, чем потоки будут
созданы, или защитите вызов с помощью mutex.</li>

<li>Организуйте вызов <a href="#mysql-thread-init">
<code>mysql_thread_init()</code></a> в обработчике потока прежде, чем вызвать
любую функцию MySQL. Если Вы вызываете
<a href="#mysql-init"><code>mysql_init()</code></a>,
она сама вызовет <a href="#mysql-thread-init">
<code>mysql_thread_init()</code></a>.</li>

<li>В потоке вызовите <a href="#mysql-thread-end">
<code>mysql_thread_end()</code></a> ДО <code>pthread_exit()</code>.
Это освобождает память, используемую MySQL для переменных,
определенных для потока.</p></li></ol>

<p>Предыдущие примечания относительно
<a href="#mysql-init"><code>mysql_init()</code></a>
также применимы к <a href="#mysql-connect"><code>
mysql_connect()</code></a>, который вызывает
<a href="#mysql-init"><code>mysql_init()</code></a>.</p>

<h4><a name="c-api-running-clients"></a>25.8.4.4 Запуск клиентских программ
C API</h4>
<p>Если после обновления Вы имете проблемы с собранными
программами-клиентами, такие как <code>Commands out of sync</code> или дамп
ядра, программы были, вероятно, собраны, используя старый заголовок или файлы
библиотеки. В этом случае проверьте дату <code>mysql.h</code> и
<code>libmysqlclient.a</code>. Повторно соберите программы с новыми
заголовками и библиотеками. Перекомпиляция также может быть необходимой для
программ, собранных с совместно используемыми библиотеками клиента, если
изменился главный номер версии библиотеки (например,
<code>libmysqlclient.so.17</code> заменена на
<code>libmysqlclient.so.18</code>).</p>

<p>Главный номер версии библиотеки определяет совместимость. Например, для
<code>libmysqlclient.so.18.1.0</code> главный номер версии 18.
Поэтому библиотеки, поставленные с более новыми версиями MySQL, являются
заменой для более старых версий, у которых есть тот же самый главный номер
версии. Пока главная версия библиотеки та же самая, Вы можете обновить
библиотеку, и старые приложения должны продолжать работать с ней.</p>

<p>Ошибки Undefined-reference могут произойти во время выполнения, когда Вы
пытаетесь выполнить программу MySQL. Если они определяют символы, которые
начинаются с <code>mysql_</code> или указывают, что бибилотека
<code>libmysqlclient</code> не может быть найдена, это означает, что Ваша
система не может найти совместно используемую библиотеку
<code>libmysqlclient.so</code>. Решение этой проблемы состоит в том, чтобы
указать Вашей системе искать совместно используемые библиотеки в каталоге,
где эта библиотека расположена. Используйте, какой-то из следующих методов,
который подходящий для Вашей системы:</p>

<ul><li><p>Добавьте путь к каталогу где находится
<code>libmysqlclient.so</code> в переменную окружения
<code>LD_LIBRARY_PATH</code> или <code>LD_LIBRARY</code>.</li>

<li>Под OS X добавьте путь к каталогу, где расположена
<code>libmysqlclient.dylib</code> в переменную окружения
<code>DYLD_LIBRARY_PATH</code>.</li>

<li>Скопируйте файлы совместно используемой библиотеки (такие, как
<code>libmysqlclient.so</code>) в каталог, который ищется Вашей системой,
например, в <code>/lib</code>, и обновите информацию библиотеки, выполнив
<code>ldconfig</code>. Убедитесь, что скопировали все связанные файлы.
Совместно используемая библиотека может бы существовать под несколькими
именами, используя символьные ссылки, чтобы
обеспечить альтернативные названия.</p></li></ul>

<p>Если приложение скомпоновано со встроенной библиотекой сервера, то
сообщения об ошибках во время выполнения укажут на
<code>libmysqld</code> вместо <code>libmysqlclient</code>, но решение
проблемы то же самое, как только что описано.</p>

<h4><a name="c-api-server-client-versions"></a>25.8.4.5. Версии сервера и
библиотеки клиента C API</h4>
<p>Строковая и числовая формы версии сервера MySQL доступны во время
компиляции как значения макросов <code>MYSQL_SERVER_VERSION</code> и
<code>MYSQL_VERSION_ID</code>, а во время выполнения как значения функций
<a href="#mysql-get-server-info"><code>
mysql_get_server_info()</code></a> и
<a href="#mysql-get-server-version"><code>
mysql_get_server_version()</code></a>.</p>

<p>Версия библиотеки клиента MySQL зависит от типа дистрибутива, который
предоставляет библиотеку:</p>
<ul><li><p>Для дистрибутивов MySQL версия библиотеки клиента это версия
MySQL. Строковая и числовая формы этой версии доступны во время компиляции
как значения макросов <code>MYSQL_SERVER_VERSION</code> и
<code>MYSQL_VERSION_ID</code>, а во время выполнения как значения функций
<a href="#mysql-get-server-info"><code>
mysql_get_server_info()</code></a> и
<a href="#mysql-get-server-version"><code>
mysql_get_server_version()</code></a>.</p>

<p>Макросы <code>LIBMYSQL_VERSION</code> и <code>LIBMYSQL_VERSION_ID</code>
имеют те же самые значения, что и <code>MYSQL_SERVER_VERSION</code> и
<code>MYSQL_VERSION_ID</code>, эти два набора макроопределений
могут использоваться попеременно.</li>

<li>Для дистрибутивов Connector/C версия библиотеки клиента это версия
Connector/C. Строковая и числовая формы этой версии доступны во время
компиляции как значения макросов <code>LIBMYSQL_VERSION</code> and
<code>LIBMYSQL_VERSION_ID</code>, а во время выполнения как значения функций
<a href="#mysql-get-client-info"><code>
mysql_get_client_info()</code></a> и
<a href="#mysql-get-client-version"><code>
mysql_get_client_version()</code></a>.</p>

<p>Макросы <code>MYSQL_SERVER_VERSION</code> и
<code>MYSQL_VERSION_ID</code> указывают строковую и числовую формы версии
MySQL, на которой базируется дистрибутив Connector/C.</p></li></ul>

<h3><a name="c-api-data-structures"></a>25.8.5. Структуры данных C API</h3>
<p>Этот раздел описывает структуры данных C API, кроме используемых
для готовых команд.</p>

<ul><li><p><code>MYSQL</code></p>
<p>Эта структура представляет дескриптор одному соединению с базой данных.
Это используется для почти всех функций MySQL. Не пытайтесь сделать копию
структуры <code>MYSQL</code>. Нет никакой гарантии, что такая
копия будет применима.</li>

<li><code>MYSQL_RES</code></p>
<p>Эта структура представляет результат запроса, который возвращает строки
(<a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#show"><code>SHOW</code></a>,
<a href="sql.htm#describe"><code>DESCRIBE</code></a>,
<a href="sql.htm#explain"><code>EXPLAIN</code></a>).
Информацию, возвращенную из запроса, называют
<span><em>набором результатов</em></span>.</li>

<li><code>MYSQL_ROW</code></p>
<p>Это безопасное представление одной строки данных. Это в настоящее время
осуществляется как массив строк, длиной не более 255 символов. Вы не можете
обработать их как законченные нулем строки, если значения полей могут
содержать двоичных данных, потому что такие значения могут содержать нулевые
байты внутренне. Строки получены вызовом
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a>.</li>

<li><code>MYSQL_FIELD</code></p>
<p>Эта структура содержит метаданные: информация о поле такая, как имя поля,
тип и размер. Его участники описаны более подробно позже в этом разделе. Вы
можете получить структуры <code>MYSQL_FIELD</code> для каждого поля вызовом
<a href="#mysql-fetch-field"><code>mysql_fetch_field().
Полевые данные не часть этой структуры; они содержатся в структуре
<code>MYSQL_ROW</code>.</li>

<li><code>MYSQL_FIELD_OFFSET</code></p>
<p>Это безопасное представление смещения в список полей MySQL. Исользуется в
<a href="#mysql-field-seek"><code>mysql_field_seek()
</code></a>. Смещения это номера полей в строке, начиная с 0.</li>

<li><code>my_ulonglong</code></p>
<p>Тип, используемый для числа строк и для
<a href="#mysql-affected-rows"><code>
mysql_affected_rows()</code></a>,
<a href="#mysql-num-rows"><code>mysql_num_rows()</code>
</a> и <a href="#mysql-insert-id"><code>mysql_insert_id()
</code></a>. Этот тип обеспечивает диапазон от <code>0</code> до
<code>1.84e19</code>.</p>

<p>Некоторые функции, которые возвращают количество строк, использующее этот
тип, возвращают -1 , чтобы указать на ошибку или исключительное условие. Вы
можете проверить на -1, сравнивая возвращаемое значение с
<code>(my_ulonglong)-1</code> (или <code>(my_ulonglong)~0</code>).</p>

<p>На некоторых системах, попытка напечатать значение типа
<code>my_ulonglong</code> не работает. Чтобы напечатать такое значение,
преобразуйте это в <code>unsigned long</code> и используйте
формат вывода <code>%lu</code>. Пример:
<pre>
printf ("Number of rows: %lu\n",
        (unsigned long) mysql_num_rows(result));
</pre></li>

<li><p><code>my_bool</code></p>
<p>Булев тип, для значений, которые являются истиной (отличное от нуля
значение) или ложью (ноль).</p></li></ul>

<p>Структура <code>MYSQL_FIELD</code> содержит члены, описанные в следующем
списке. Определения применяются прежде всего для столбцов наборов
результатов, таких как произведенные запросом
<a href="sql.htm#select"><code>SELECT</code></a>. Структура
<code>MYSQL_FIELD</code> также используется, чтобы обеспечить метаданные для
для параметров <code>OUT</code> и <code>INOUT</code> возврата из хранимых
процедур, выполненных, используя подготовленный запрос
<a href="sql.htm#call"><code>CALL</code></a>. Для таких параметров у
некоторых из членов структуры есть значение, отличающееся от
значения для столбцов.</p>

<ul><li><p><code>char * name</code></p>
<p>Имя поля, как законченная нулем строка. Если поле имеет псевдоним,
заданный через <code>AS</code>, значением <code>name</code> он и будет.
Для параметра процедуры это имя параметра.</li>

<li><code>char * org_name</code></p>
<p>Имя поля, как законченная нулем строка. Псевдонимы игнорируются.
Для выражений значением будет пустая строка. Для параметра процедуры
это имя параметра.</li>

<li><code>char * table</code></p>
<p>Имя таблицы, содержащей это поле, если это не вычисляемое поле. Для
вычисляемых полей значением будет пустая строка. Если столбец выбран из
представления, <code>table</code> имя представления. Если таблице или
представлению дали псевдоним с помощью <code>AS</code>, значение
<code>table</code> псевдонимом. Для
<a href="sql.htm#union"><code>UNION</code></a> значение пустая
строка. Для параметра процедуры значением будет имя процедуры.</li>

<li><code>char * org_table</code></p>
<p>Имя таблицы, как законченная нулем строка. Псевдонимы игнорируются.
Если столбец выбран из представления, <code>org_table</code> имя
представления. Для <a href="sql.htm#union"><code>UNION</code></a>
значение пустая строка. Для параметра процедуры значением
будет имя процедуры.</li>

<li><code>char * db</code></p>
<p>Имя базы данных, к которой относится поле, как законченная нулем строка.
Если поле является вычисляемым, <code>db</code> пустая строка. Для
<a href="sql.htm#union"><code>UNION</code></a> значение пустая
строка. Для параметра процедуры значением будет имя процедуры.</li>

<li><code>char * catalog</code></p>
<p>Имя каталога. Это значение всегда <code>"def"</code>.</li>
<li><code>char * def</code></p>
<p>Значение по умолчанию этого поля как законченная нулем строка. Это
установлено, только если Вы используете
<a href="#mysql-list-fields"><code>mysql_list_fields()
</code></a>.</li>

<li><code>unsigned long length</code></p>
<p>Ширина поля. Это соответствует отображаемой длине в байтах.</p>
<p>Сервер определяет значение <code>length</code> прежде, чем произведет
набор результатов, таким образом, это минимальная длина, требуемая для
обработки самого большого значения столбца результата этого типа данных, не
зная заранее фактические значения, которые будут произведены запросом
для набора результатов.</li>

<li><code>unsigned long max_length</code></p>
<p>Максимальная ширина поля для набора результатов (длина в байтах самого
большого значения поля для строк, фактически имеющихся в наборе результатов).
Если Вы используете <a href="#mysql-store-result"><code>
mysql_store_result()</code></a> или
<a href="#mysql-list-fields"><code>mysql_list_fields()
</code></a>, это содержит максимальную длину для поля. Если Вы используете
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a>, значение этой переменной ноль.</p>

<p>Значение <code>max_length</code> длина строкового представления значений в
наборе результатов. Например, если Вы получаете столбец типа
<a href="types.htm#floating-point-types"><code>FLOAT</code></a> и
значение <span>widest</span> <code>-12.345</code>, <code>max_length</code>
будет равно 7 (длина <code>'-12.345'</code>).</p>

<p>Если Вы используете подготовленные выражения, <code>max_length</code>
не установлен по умолчанию, потому что для протокола двоичной синхронной
передачи данных длины значений зависят от типов значений в наборе
результатов. Если Вы хотите получать значения <code>max_length</code> в
любом случае, включите опцию <code>STMT_ATTR_UPDATE_MAX_LENGTH</code> с
помощью <a href="#mysql-stmt-attr-set">
<code>mysql_stmt_attr_set()</code></a> и длины будут установлены, когда Вы
будете вызывать <a href="#mysql-stmt-store-result">
<code>mysql_stmt_store_result()</code></a>.</li>

<li><code>unsigned int name_length</code></p>
<p>Длина <code>name</code>.</li>
<li><code>unsigned int org_name_length</code></p>
<p>Длина <code>org_name</code>.</li>

<li><code>unsigned int table_length</code></p>
<p>Длина <code>table</code>.</li>
<li><code>unsigned int org_table_length</code></p>
<p>Длина <code>org_table</code>.</li>

<li><code>unsigned int db_length</code></p>
<p>Длина <code>db</code>.</li>
<li><code>unsigned int catalog_length</code></p>
<p>Длина <code>catalog</code>.</li>

<li><code>unsigned int def_length</code></p>
<p>Длина <code>def</code>.</li>
<li><code>unsigned int flags</code></p>
<p>Битовые флаги, которые описывают поле. Значение <code>flags</code>
может иметь 0 или больше бит, которые показаны в следующей таблице.</p>

<table border="1"><thead><tr><th scope="col">Значение Flag</th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><code>NOT_NULL_FLAG</code></td>
<td>Поле не может быть <code>NULL</code></td></tr>
<tr><td scope="row"><code>PRI_KEY_FLAG</code></td>
<td>Поле является частью первичного ключа</td></tr>
<tr><td scope="row"><code>UNIQUE_KEY_FLAG</code></td>
<td>Поле является частью уникального ключа</td></tr>
<tr><td scope="row"><code>MULTIPLE_KEY_FLAG</code></td>
<td>Поле является частью неуникального ключа</td></tr>
<tr><td scope="row"><code>UNSIGNED_FLAG</code></td>
<td>Поле имеет атрибут <code>UNSIGNED</code></td></tr>
<tr><td scope="row"><code>ZEROFILL_FLAG</code></td>
<td>Поле имеет атрибут <code>ZEROFILL</code></td></tr>
<tr><td scope="row"><code>BINARY_FLAG</code></td>
<td>Поле имеет атрибут <code>BINARY</code></td></tr>
<tr><td scope="row"><code>AUTO_INCREMENT_FLAG</code></td>
<td>Поле имеет атрибут <code>AUTO_INCREMENT</code></td></tr>
<tr><td scope="row"><code>ENUM_FLAG</code></td>
<td>Поле <a href="types.htm#enum"><code>ENUM</code></a></td></tr>
<tr><td scope="row"><code>SET_FLAG</code></td>
<td>Поле <a href="types.htm#set"><code>SET</code></a></td></tr>
<tr><td scope="row"><code>BLOB_FLAG</code></td>
<td>Поле <a href="types.htm#blob"><code>BLOB</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a> (устаревшее)</td></tr>
<tr><td scope="row"><code>TIMESTAMP_FLAG</code></td>
<td>Поле <a href="types.htm#datetime"><code>TIMESTAMP</code></a>
(устаревшее)</td></tr>
<tr><td scope="row"><code>NUM_FLAG</code></td>
<td>Поле числовое: дополнительные пояснения ниже</td></tr>
<tr><td scope="row"><code>NO_DEFAULT_VALUE_FLAG</code></td>
<td>Поле не имеет значения по умолчанию</td></tr></tbody></table>

<p>Некоторые из этих флагов указывают на информацию о типе данных и заменены
или используются вместе со значением <code>MYSQL_TYPE_<em><code>xxx</code>
</em></code> в <code>field-&gt;type</code>, описанным ниже:</p>

<ul><li><p>Для проверки на значения
To check for <a href="types.htm#blob"><code>BLOB</code></a> или
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>, проверьте
<code>type</code> на <code>MYSQL_TYPE_BLOB</code> или
<code>MYSQL_TYPE_TIMESTAMP</code> (флаги <code>BLOB_FLAG</code> и
<code>TIMESTAMP_FLAG</code> не нужны).</li>

<li>Значения <a href="types.htm#enum"><code>ENUM</code></a> и
<a href="types.htm#set"><code>SET</code></a> возвращены как строки.
Для них проверьте, что значение <code>type</code>
<code>MYSQL_TYPE_STRING</code>, а флаг <code>ENUM_FLAG</code> или
<code>SET_FLAG</code> установлен в значении <code>flags</code>.</p></li></ul>

<p><code>NUM_FLAG</code> показывает, что столбец является числовым. Это
включает столбцы типов <code>MYSQL_TYPE_DECIMAL</code>,
<code>MYSQL_TYPE_NEWDECIMAL</code>, <code>MYSQL_TYPE_TINY</code>,
<code>MYSQL_TYPE_SHORT</code>, <code>MYSQL_TYPE_LONG</code>,
<code>MYSQL_TYPE_FLOAT</code>, <code>MYSQL_TYPE_DOUBLE</code>,
<code>MYSQL_TYPE_NULL</code>, <code>MYSQL_TYPE_LONGLONG</code>,
<code>MYSQL_TYPE_INT24</code> и <code>MYSQL_TYPE_YEAR</code>.</p>

<p><code>NO_DEFAULT_VALUE_FLAG</code> показывает, что столбец не имеет
параметра <code>DEFAULT</code> в определении. Это не относится к
столбцам <code>NULL</code> (потому что, у таких столбцов есть значение по
умолчанию, и это именно <code>NULL</code>), а также к столбцам
<code>AUTO_INCREMENT</code> (у которых есть подразумеваемое
значение по умолчанию).</p>

<p>Следующий пример иллюстрирует типичное использование значения
<code>flags</code> value:
  <pre>
if (field-&gt;flags &amp; NOT_NULL_FLAG)
    printf("Field cannot be null\n");
</pre>

<p>Вы можете использовать макроопределения, которые, как показывают в
следующей таблице, определяют булево состояние <code>flags</code> value.</p>

<table border="1"><thead><tr><th scope="col">Статус Flag</th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><code>IS_NOT_NULL(flags)</code></td>
<td>Истина, если поле определено как <code>NOT NULL</code></td></tr>
<tr><td scope="row"><code>IS_PRI_KEY(flags)</code></td>
<td>Истина, если поле первичный ключ</td></tr>
<tr><td scope="row"><code>IS_BLOB(flags)</code></td>
<td>Истина, если поле <a href="types.htm#blob">
<code>BLOB</code></a> или <a href="types.htm#blob"><code>TEXT</code>
</a> (устарело: вместо этого проверяйте <code>field-&gt;type</code>)
</td></tr></tbody></table></li>

<li><p><code>unsigned int decimals</code></p>
<p>Число десятичных чисел для числовых полей и дробной точности
секунд для временных.</li>

<li><code>unsigned int charsetnr</code></p>
<p>Идентификационный номер, который указывает на набор символов для поля.</p>
<p>Обычно символьные значения в наборах результатов преобразованы в набор
символов, обозначенный системной переменной
<a href="server.htm#sysvar_character_set_results"><code>
character_set_results</code></a>. В этом случае <code>charsetnr</code>
соответствует набору символов, обозначенному этой переменной. Преобразование
набора символов может быть подавлено, устанавливая
<a href="server.htm#sysvar_character_set_results"><code>
character_set_results</code></a> в <code>NULL</code>. В этом случае
<code>charsetnr</code> соответствует набору символов оригинального столбца
таблицы или выражения.</p>

<p>Чтобы различить двоичные и недвоичные данные для строковых типов данных,
проверьте, равно ли значение <code>charsetnr</code> 63. Если так, набор
символов <code>binary</code>, который указывает на двоичные данные. Это
позволяет Вам отличить тип
<a href="types.htm#binary-varbinary"><code>BINARY</code></a> от
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a> от
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>BLOB</code></a> от
<a href="types.htm#blob"><code>TEXT</code></a>.</p>

<p>Значения <code>charsetnr</code> те же самое, что и выведенные на экран в
столбце <code>Id</code> команды <a href="sql.htm#show-collation">
<code>SHOW COLLATION</code></a> или столбце <code>ID</code> в
<code>INFORMATION_SCHEMA</code> таблицы
<a href="inform.htm#collations-table"><code>COLLATIONS</code>
</a>. Вы можете использовать те источники информации, чтобы видеть,
какой набор символов какому значению <code>charsetnr</code> соответствует.
<pre>
mysql&gt; <strong><code>SHOW COLLATION WHERE Id = 63;</code></strong>
+-----------+---------+----+---------+----------+---------+
| Collation | Charset | Id | Default | Compiled | Sortlen |
+-----------+---------+----+---------+----------+---------+
| binary    | binary  | 63 | Yes     | Yes      | 1       |
+-----------+---------+----+---------+----------+---------+

mysql&gt; <strong><code>SELECT COLLATION_NAME, CHARACTER_SET_NAME</code></strong>
    -&gt; <strong><code>FROM INFORMATION_SCHEMA.COLLATIONS WHERE ID = 33;</code></strong>
+-----------------+--------------------+
| COLLATION_NAME  | CHARACTER_SET_NAME |
+-----------------+--------------------+
| utf8_general_ci | utf8               |
+-----------------+--------------------+
</pre></li>

<li><p><code>enum enum_field_types type</code></p>
<p>Тип поля. Значение <code>type</code> может быть одним из символов
<code>MYSQL_TYPE_</code>, показанных в следующей таблице.</p>

<table border="1"><thead><tr><th scope="col">Значение Type</th>
<th scope="col">Описание</th></tr></thead><tbody>
<tr><td scope="row"><code>MYSQL_TYPE_TINY</code></td>
<td>Поле <a href="types.htm#integer-types"><code>TINYINT</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_SHORT</code></td>
<td>Поле <a href="types.htm#integer-types"><code>SMALLINT</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_LONG</code></td>
<td>Поле <a href="types.htm#integer-types"><code>INTEGER</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_INT24</code></td>
<td>Поле <a href="types.htm#integer-types"><code>MEDIUMINT</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_LONGLONG</code></td>
<td>Поле <a href="types.htm#integer-types"><code>BIGINT</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_DECIMAL</code></td>
<td>Поле <a href="types.htm#fixed-point-types"><code>DECIMAL</code></a>
или <a href="types.htm#fixed-point-types"><code>NUMERIC</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_NEWDECIMAL</code></td>
<td>Точная математика <a href="types.htm#fixed-point-types"><code>
DECIMAL</code></a> или <a href="types.htm#fixed-point-types"><code>
NUMERIC</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_FLOAT</code></td>
<td>Поле <a href="types.htm#floating-point-types"><code>FLOAT</code>
</a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_DOUBLE</code></td>
<td>Поле <a href="types.htm#floating-point-types"><code>DOUBLE</code>
</a> или <a href="types.htm#floating-point-types"><code>REAL</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_BIT</code></td>
<td>Поле <a href="types.htm#bit-type"><code>BIT</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_TIMESTAMP</code></td>
<td>Поле <a href="types.htm#datetime"><code>TIMESTAMP</code></a></td>
</tr>
<tr><td scope="row"><code>MYSQL_TYPE_DATE</code></td>
<td>Поле <a href="types.htm#datetime"><code>DATE</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_TIME</code></td>
<td>Поле <a href="types.htm#time"><code>TIME</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_DATETIME</code></td>
<td>Поле <a href="types.htm#datetime"><code>DATETIME</code></a></td>
</tr>
<tr><td scope="row"><code>MYSQL_TYPE_YEAR</code></td>
<td>Поле <a href="types.htm#year"><code>YEAR</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_STRING</code></td>
<td>Поле <a href="types.htm#char"><code>CHAR</code></a>
<a href="types.htm#binary-varbinary"><code>BINARY</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_VAR_STRING</code></td>
<td>Поле <a href="types.htm#char"><code>VARCHAR</code></a> или
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>
</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_BLOB</code></td>
<td>Поле <a href="types.htm#blob"><code>BLOB</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a> (используйте
<code>max_length</code> для определения максимальной длины)</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_SET</code></td>
<td>Поле <a href="types.htm#set"><code>SET</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_ENUM</code></td>
<td>Поле <a href="types.htm#enum"><code>ENUM</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_GEOMETRY</code></td>
<td>Поле геометрических данных</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_NULL</code></td>
<td>Поле <code>NULL</code>-type</td></tr></tbody></table>

<p>Типы <code>MYSQL_TYPE_TIME2</code>, <code>MYSQL_TYPE_DATETIME2</code> и
<code>MYSQL_TYPE_TIMESTAMP2</code> используются только на стороне сервера.
Клиенты видят коды <code>MYSQL_TYPE_TIME</code>,
<code>MYSQL_TYPE_DATETIME</code> и <code>MYSQL_TYPE_TIMESTAMP</code>.</p>

<p>Вы можете использовать макрос <code>IS_NUM()</code>, чтобы проверить, есть
ли у поля числовой тип. Передайте значение <code>type</code>
<code>IS_NUM()</code> и если это оценивается как TRUE, то
поле является числовым:
<pre>
if (IS_NUM(field-&gt;type)) printf("Field is numeric\n");
</pre>

<p>Значения <a href="types.htm#enum"><code>ENUM</code></a> и
<a href="types.htm#set"><code>SET</code></a> возвращены как строки. Для
них проверьте, что <code>type</code> <code>MYSQL_TYPE_STRING</code> и что
в <code>flags</code> установлен <code>ENUM_FLAG</code> или <code>SET_FLAG
</code>.</p></li></ul>

<h3><a name="c-api-function-overview"></a>25.8.6. Обзор функций C API</h3>
<p><b>Таблица 25.4. Имена и описания функций C API</b></p>
<table border="1"><thead><tr><th scope="col">Функция</th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><a href="#my-init">
<code>my_init()</code></a></td>
<td>Инициализирует глобальные переменные и обработчик потоков в безопасных
для потоков программах</td></tr>
<tr><td scope="row"><a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a></td>
<td>Возвращает число строк, измененных/удаленных/вставленных последним
запросом <a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#insert"><code>INSERT</code></a></td></tr>
<tr><td scope="row"><a href="#mysql-autocommit">
<code>mysql_autocommit()</code></a></td>
<td>Переключает режим autocommit вкл\выкл</td></tr>
<tr><td scope="row"><a href="#mysql-change-user">
<code>mysql_change_user()</code></a></td><td>Меняет пользователя и базу
данных на открытом соединении</td></tr>
<tr><td scope="row"><a href="#mysql-character-set-name">
<code>mysql_character_set_name()</code></a></td>
<td>Возвратите имя набора символов по умолчанию для текущего соединения
</td></tr>
<tr><td scope="row"><a href="#mysql-client-find-plugin">
<code>mysql_client_find_plugin()</code></a></td>
<td>Возвращает указатель на плагин</td></tr>
<tr><td scope="row">
<a href="#mysql-client-register-plugin">
<code>mysql_client_register_plugin()</code></a></td><td>Регистрирует плагин
</td></tr>
<tr><td scope="row"><a href="#mysql-close">
<code>mysql_close()</code></a></td><td>Закрывает соединение с сервером</td>
</tr>
<tr><td scope="row"><a href="#mysql-commit">
<code>mysql_commit()</code></a></td><td>Передает транзакцию</td></tr>
<tr><td scope="row"><a href="#mysql-connect">
<code>mysql_connect()</code></a></td>
<td>Связывается с сервером MySQL (функция устарела, используйте вместо нее
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>)</td></tr>
<tr><td scope="row"><a href="#mysql-create-db">
<code>mysql_create_db()</code></a></td>
<td>Создает базу данных (функция устарела, используйте оператор SQL
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>)
</td></tr>
<tr><td scope="row"><a href="#mysql-data-seek">
<code>mysql_data_seek()</code></a></td>
<td>Переходит на произвольный номер строки в наборе результатов запроса
</td></tr>
<tr><td scope="row"><a href="#mysql-debug"><code>
mysql_debug()</code></a></td>
<td>Делает <code>DBUG_PUSH</code> с данной строкой</td></tr>
<tr><td scope="row"><a href="#mysql-drop-db">
<code>mysql_drop_db()</code></a></td>
<td>Удаляет базу данных (функция устарела, используйте оператор SQL
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>)
</td></tr>
<tr><td scope="row"><a href="#mysql-dump-debug-info">
<code>mysql_dump_debug_info()</code></a></td>
<td>Заставляет сервер записать отладочную информацию в журнал</td></tr>
<tr><td scope="row"><a href="#mysql-eof">
<code>mysql_eof()</code></a></td>
<td>Определяет, была ли последняя строка набора результатов считана (функция
устарела, вместо нее используются
<a href="#mysql-errno"><code>mysql_errno()</code></a> или
<a href="#mysql-error"><code>mysql_error()</code></a>)
</td></tr>
<tr><td scope="row"><a href="#mysql-errno"><code>
mysql_errno()</code></a></td>
<td>Возвращает код ошибки для последней вызванной функции MySQL</td></tr>
<tr><td scope="row"><a href="#mysql-error">
<code>mysql_error()</code></a></td>
<td>Возвращает сообщение об ошибке для последней вызванной функции MySQL
</td></tr>
<tr><td scope="row"><a href="#mysql-escape-string">
<code>mysql_escape_string()</code></a></td><td>Экранирует специальные символы
в строке для использования в выражении SQL</td></tr>
<tr><td scope="row"><a href="#mysql-fetch-field">
<code>mysql_fetch_field()</code></a></td>
<td>Возвращает тип следующего поля таблицы</td></tr>
<tr><td scope="row"><a href="#mysql-fetch-field-direct">
<code>mysql_fetch_field_direct()</code></a></td>
<td>Возвращает тип поля таблицы по номеру</td></tr>
<tr><td scope="row"><a href="#mysql-fetch-fields">
<code>mysql_fetch_fields()</code></a></td>
<td>Возвращает массив всех структур полей</td></tr>
<tr><td scope="row"><a href="#mysql-fetch-lengths">
<code>mysql_fetch_lengths()</code></a></td>
<td>Возвращает длины всех столбцов в текущей строке</td></tr>
<tr><td scope="row"><a href="#mysql-fetch-row">
<code>mysql_fetch_row()</code></a></td>
<td>Возвращает следующую строку набора результатов</td></tr>
<tr><td scope="row"><a href="#mysql-field-count">
<code>mysql_field_count()</code></a></td>
<td>Возвращает число столбцов результата для запроса</td></tr>
<tr><td scope="row"><a href="#mysql-field-seek">
<code>mysql_field_seek()</code></a></td>
<td>Помещает курсор в указанный столбец</td></tr>
<tr><td scope="row"><a href="#mysql-field-tell">
<code>mysql_field_tell()</code></a></td>
<td>Возвращает позицию курсора, используемого для последнего запроса
<a href="#mysql-fetch-field"><code>mysql_fetch_field()
</code></a></td></tr>
<tr><td scope="row"><a href="#mysql-free-result"><code>
mysql_free_result()</code></a></td>
<td>Освобождает память, используемую набором результатов</td></tr>
<tr><td scope="row">
<a href="#mysql-get-character-set-info"><code>
mysql_get_character_set_info()</code></a></td>
<td>Возвратите информацию о наборе символов по умолчанию</td></tr>
<tr><td scope="row"><a href="#mysql-get-client-info">
<code>mysql_get_client_info()</code></a></td>
<td>Информация о версии клиента как строка</td></tr>
<tr><td scope="row"><a href="#mysql-get-client-version">
<code>mysql_get_client_version()</code></a></td>
<td>Информация о версии клиента как целое число</td></tr>
<tr><td scope="row"><a href="#mysql-get-host-info">
<code>mysql_get_host_info()</code></a></td>
<td>Возвращает строку, описывающую соединение</td></tr>
<tr><td scope="row"><a href="#mysql-get-option">
<code>mysql_get_option()</code></a></td>
<td>Возвращает значение <a href="#mysql-options">
<code>mysql_options()</code></a></td></tr>
<tr><td scope="row"><a href="#mysql-get-proto-info">
<code>mysql_get_proto_info()</code></a></td>
<td>Возвращает версию протокола, используемую соединением</td></tr>
<tr><td scope="row"><a href="#mysql-get-server-info">
<code>mysql_get_server_info()</code></a></td>
<td>Возвращает номер версии сервера</td></tr>
<tr><td scope="row"><a href="#mysql-get-server-version">
<code>mysql_get_server_version()</code></a></td>
<td>Номер версии сервера как целое число</td></tr>
<tr><td scope="row"><a href="#mysql-get-ssl-cipher">
<code>mysql_get_ssl_cipher()</code></a></td><td>Возвращает текущий шифр SSL
</td></tr>
<tr><td scope="row"><a href="#mysql-hex-string">
<code>mysql_hex_string()</code></a></td>
<td>Кодирует строку в шестнадцатеричном формате</td></tr>
<tr><td scope="row"><a href="#mysql-info"><code>
mysql_info()</code></a></td>
<td>Информация о последнем выполненном запросе</td></tr>
<tr><td scope="row"><a href="#mysql-init"><code>
mysql_init()</code></a></td>
<td>Получает или инициализирует структуру <code>MYSQL</code></td></tr>
<tr><td scope="row"><a href="#mysql-insert-id">
<code>mysql_insert_id()</code></a></td>
<td>Возвращает ID, сгенерированный столбцом <code>AUTO_INCREMENT</code>
для предыдущего запроса</td></tr>
<tr><td scope="row"><a href="#mysql-kill">
<code>mysql_kill()</code></a></td><td>Уничтожает заданный поток</td></tr>
<tr><td scope="row"><a href="#mysql-library-end"><code>
mysql_library_end()</code></a></td><td>Завершает библиотеку MySQL C API</td>
</tr>
<tr><td scope="row"><a href="#mysql-library-init">
<code>mysql_library_init()</code></a></td>
<td>Запускает библиотеку MySQL C API</td></tr>
<tr><td scope="row"><a href="#mysql-list-dbs"><code>
mysql_list_dbs()</code></a></td>
<td>Возвращает имена баз данных, соответствующие
простому регулярному выражению</td></tr>
<tr><td scope="row"><a href="#mysql-list-fields">
<code>mysql_list_fields()</code></a></td>
<td>Возвращает имена полей, соответствующие простому регулярному выражению
</td></tr>
<tr><td scope="row"><a href="#mysql-list-processes">
<code>mysql_list_processes()</code></a></td>
<td>Возвращает список текущих потоков сервера</td></tr>
<tr><td scope="row"><a href="#mysql-list-tables"><code>
mysql_list_tables()</code></a></td>
<td>Возвращает имена таблиц, соответствующие простому регулярному выражению
</td></tr>
<tr><td scope="row"><a href="#mysql-load-plugin">
<code>mysql_load_plugin()</code></a></td><td>Загружает плагин</td></tr>
<tr><td scope="row"><a href="#mysql-load-plugin-v">
<code>mysql_load_plugin_v()</code></a></td><td>Загружает плагин</td></tr>
<tr><td scope="row"><a href="#mysql-more-results">
<code>mysql_more_results()</code></a></td>
<td>Проверяет, существуют ли еще результаты</td></tr>
<tr><td scope="row"><a href="#mysql-next-result">
<code>mysql_next_result()</code></a></td>
<td>Возвращает/начинает следующий результат, когда их много</td></tr>
<tr><td scope="row"><a href="#mysql-num-fields"><code>
mysql_num_fields()</code></a></td>
<td>Возвращает число столбцов в наборе результатов</td></tr>
<tr><td scope="row"><a href="#mysql-num-rows"><code>
mysql_num_rows()</code></a></td>
<td>Возвращает число строк в наборе результатов</td></tr>
<tr><td scope="row"><a href="#mysql-options"><code>
mysql_options()</code></a></td><td>Задает опции соединения для
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a></td></tr>
<tr><td scope="row"><a href="#mysql-options4"><code>
mysql_options4()</code></a></td><td>Задает опции соединения для
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a></td></tr>
<tr><td scope="row"><a href="#mysql-ping"><code>
mysql_ping()</code></a></td>
<td>Проверяет, работает ли соединение с сервером, повторно соединяясь
по мере необходимости</td></tr>
<tr><td scope="row"><a href="#mysql-plugin-options">
<code>mysql_plugin_options()</code></a></td><td>Устанавливает опции плагина
</td></tr>
<tr><td scope="row"><a href="#mysql-query">
<code>mysql_query()</code></a></td>
<td>Выполняет запрос SQL, определенный как законченная нулем строка</td></tr>
<tr><td scope="row"><a href="#mysql-real-connect"><code>
mysql_real_connect()</code></a></td><td>Соединяется с сервером MySQL</td></tr>
<tr><td scope="row"><a href="#mysql-real-escape-string">
<code>mysql_real_escape_string()</code></a></td>
<td>Экранирует специальные символы в строке для использования в запросе
SQL, принимая во внимание текущий набор символов соединения</td></tr>
<tr><td scope="row">
<a href="#mysql-real-escape-string-quote"><code>
mysql_real_escape_string_quote()</code></a></td>
<td>Экранирует специальные символы в строке для использования в запросе
SQL, принимая во внимание текущий набор символов соединения и
контекст, заключенный в кавычки</td></tr>
<tr><td scope="row"><a href="#mysql-real-query">
<code>mysql_real_query()</code></a></td>
<td>Выполняет запрос SQL, определенный как строка</td></tr>
<tr><td scope="row"><a href="#mysql-refresh"><code>
mysql_refresh()</code></a></td><td>Сбрасывает или перезапускает
таблицы и кэши</td></tr>
<tr><td scope="row"><a href="#mysql-reload">
<code>mysql_reload()</code></a></td>
<td>Предписывает серверу перезагрузить таблицы привилегий</td></tr>
<tr><td scope="row"><a href="#mysql-reset-connection">
<code>mysql_reset_connection()</code></a></td>
<td>Перезапускает соединение с новым статусом сессии</td></tr>
<tr><td scope="row"><a href="#mysql-rollback"><code>
mysql_rollback()</code></a></td><td>Откатывает транзакцию</td></tr>
<tr><td scope="row"><a href="#mysql-row-seek">
<code>mysql_row_seek()</code></a></td>
<td>Переходит на смещение строки в наборе результатов, используя значение из
<a href="#mysql-row-tell"><code>mysql_row_tell()</code>
</a></td></tr>
<tr><td scope="row"><a href="#mysql-row-tell"><code>
mysql_row_tell()</code></a></td><td>Возвращает позицию курсора в строке
</td></tr>
<tr><td scope="row"><a href="#mysql-select-db"><code>
mysql_select_db()</code></a></td><td>Выбирает базу данных</td></tr>
<tr><td scope="row"><a href="#mysql-server-end"><code>
mysql_server_end()</code></a></td><td>Завершает библиотеку MySQL C API</td>
</tr>
<tr><td scope="row"><a href="#mysql-server-init">
<code>mysql_server_init()</code></a></td>
<td>Запускает библиотеку MySQL C API</td></tr>
<tr><td scope="row">
<a href="#mysql-session-track-get-first"><code>
mysql_session_track_get_first()</code></a></td>
<td>Получает первую часть информации об изменении статуса сессии</td></tr>
<tr><td scope="row">
<a href="#mysql-session-track-get-next"><code>
mysql_session_track_get_next()</code></a></td>
<td>Получает следующую часть информации об изменении статуса сессии</td></tr>
<tr><td scope="row"><a href="#mysql-set-character-set">
<code>mysql_set_character_set()</code></a></td>
<td>Задает набор символов по умолчанию для текущего соединения</td></tr>
<tr><td scope="row">
<a href="#mysql-set-local-infile-default"><code>
mysql_set_local_infile_default()</code></a></td>
<td>Устанавливает обработчик <a href="sql.htm#load-data"><code>LOAD
DATA LOCAL INFILE</code></a> к его значениям по умолчанию</td></tr>
<tr><td scope="row">
<a href="#mysql-set-local-infile-handler">
<code>mysql_set_local_infile_handler()</code></a></td>
<td>Устанавливает обработчик <a href="sql.htm#load-data"><code>
LOAD DATA LOCAL INFILE</code></a></td></tr>
<tr><td scope="row"><a href="#mysql-set-server-option">
<code>mysql_set_server_option()</code></a></td>
<td>Устанавливает опцию для соединения (например,
<code>multi-statements</code>)</td></tr>
<tr><td scope="row"><a href="#mysql-sqlstate"><code>
mysql_sqlstate()</code></a></td>
<td>Возвращает код SQLSTATE для последней ошибки</td></tr>
<tr><td scope="row"><a href="#mysql-ssl-set"><code>
mysql_ssl_set()</code></a></td>
<td>Подготавливается установить соединение SSL с сервером</td></tr>
<tr><td scope="row"><a href="#mysql-stat"><code>
mysql_stat()</code></a></td><td>Возвращает состояние сервера как строку</td>
</tr>
<tr><td scope="row"><a href="#mysql-store-result">
<code>mysql_store_result()</code></a></td>
<td>Передает полный набор результатов клиенту</td></tr>
<tr><td scope="row"><a href="#mysql-thread-end">
<code>mysql_thread_end()</code></a></td><td>Завершает обработчик потока</td>
</tr>
<tr><td scope="row"><a href="#mysql-thread-id">
<code>mysql_thread_id()</code></a></td>
<td>Возвращает ID текущего потока</td></tr>
<tr><td scope="row"><a href="#mysql-thread-init">
<code>mysql_thread_init()</code></a></td>
<td>Инициализирует обработчик потока</td></tr>
<tr><td scope="row"><a href="#mysql-thread-safe">
<code>mysql_thread_safe()</code></a></td>
<td>Возвращает 1, если клиент собран как безопасный для потоков</td></tr>
<tr><td scope="row"><a href="#mysql-use-result">
<code>mysql_use_result()</code></a></td>
<td>Начинает построчное извлечение набора результатов</td></tr>
<tr><td scope="row"><a href="#mysql-warning-count">
<code>mysql_warning_count()</code></a></td>
<td>Возвращает число предупреждений для предыдущего запроса SQL
</td></tr></tbody></table>

<p>Приложения должны использовать эту общую схему для того,
чтобы взаимодействовать с MySQL:</p>
<ol type="1"><li><p>Инициализируйте библиотеку MySQL вызовом
<a href="#mysql-library-init">
<code>mysql_library_init()</code></a>. Эта функция существует в обеих
библиотеках, <code>libmysqlclient</code> и <code>libmysqld</code>, таким
образом, это используется, создаете ли Вы регулярную программу-клиента,
компонуя с флагом <code>-libmysqlclient</code>, или встроенное приложение
сервера, компонуя с флагом <code>-libmysqld</code>.</li>

<li>Инициализируйте обработчик соединения вызовом
<a href="#mysql-init"><code>mysql_init()</code></a>
и соединитесь с сервером (<a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a>).</li>

<li>Сделайте запросы SQL и обработайте их результаты. Следующее обсуждение
предоставляет больше информации о том, как это сделать.</li>
<li>Закройте соединение с сервером MySQL вызовом
<a href="#mysql-close"><code>mysql_close()</code></a>.
</li>

<li>Завершите использование библиотеки MySQL через
<a href="#mysql-library-end"><code>mysql_library_end()
</code></a>.</p></li></ol>

<p>Цель вызова
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a> и
<a href="#mysql-library-end"><code>mysql_library_end()
</code></a> в том, чтобы обеспечить надлежащую инициализацию и завершение
библиотеки MySQL. Для приложений, которые скомпонованы с библиотекой клиента,
они предоставляют улучшенное управление памятью. Если Вы не вызвали
<a href="#mysql-library-end"><code>mysql_library_end()
</code></a>, блок памяти остается выделенным. Это не увеличивает объем
памяти, используемый приложением, но некоторые датчики утечки памяти будут
жаловаться на это. Для приложений, которые скомпонованы со встроенным
сервером, эти вызовы запускают и останавливают сервер.</p>

<p>В непоточной среде вызов
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a> может быть опущен, потому что
<a href="#mysql-init"><code>mysql_init()</code></a>
вызовет это автоматически по мере необходимости. Однако,
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a> не безопасен для потока в мультипоточной среде. Вы должны или
вызывать <a href="#mysql-library-init"><code>
mysql_library_init()</code></a> до порождения любых потоков, или иначе
использования mutex, чтобы защитить поток, вызываете вы
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a> или косвенно через
<a href="#mysql-init"><code>mysql_init()</code></a>.
Это должно быть сделано до любого другого вызова функции из библиотеки.</p>

<p>Чтобы соединиться с сервером, вызовите
<a href="#mysql-init"><code>mysql_init()</code></a>,
чтобы инициализировать обработчик соединения, а затем
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a> с этим обработчиком (наряду с другой информацией, такой как имя
хоста, имя пользователя и пароль). Для соединения
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a> устанавливает флаг <code>reconnect</code> (часть структуры
<code>MYSQL</code>) в <code>1</code> в версиях API до 5.0.3 или в
<code>0</code> в более новых. Значение <code>1</code> этого флага указывает
на то, что если запрос не может быть выполнен из-за потерянного соединения,
надо попытаться повторно соединиться с сервером перед отказом. Вы можете
использовать опцию <code>MYSQL_OPT_RECONNECT</code> в
<a href="#mysql-options"><code>mysql_options()</code></a>
чтобы управлять поведением пересоединения. Когда Вы закончите работу,
закройте соединение вызовом
<a href="#mysql-close"><code>mysql_close()</code></a>.
</p>

<p>В то время как соединение является активным, клиент может послать запросы
SQL серверу, используя <a href="#mysql-query">
<code>mysql_query()</code></a> или
<a href="#mysql-real-query">
<code>mysql_real_query()</code></a>. Различие между этими функциями в том,
что <a href="#mysql-query"><code>mysql_query()</code></a>
ожидает, что запрос будет определен как законченная нулем строка, тогда как
<a href="#mysql-real-query">
<code>mysql_real_query()</code></a> ожидает обычную строку. Если строка
содержит двоичные данные (которые могут включать нулевые байты), Вы должны
использовать <a href="#mysql-real-query">
<code>mysql_real_query()</code></a>.</p>

<p>Для не-<a href="sql.htm#select"><code>SELECT</code></a> запросов
(например, <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>),
Вы можете узнать, сколько строк было изменено (затронуто) вызовом
<a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a>.</p>

<p>Для запросов <a href="sql.htm#select"><code>SELECT</code></a>
Вы получаете выбранные строки в наборе результатов. Заметьте, что некоторые
команды, подобные <a href="sql.htm#select"><code>SELECT</code></a>,
тоже возвразают строки именно так. Это <a href="sql.htm#show"><code>
SHOW</code></a>, <a href="sql.htm#describe"><code>DESCRIBE</code>
</a> и <a href="sql.htm#explain"><code>EXPLAIN</code></a>.
Обработайте их так же, как <a href="sql.htm#select"><code>SELECT
</code></a>.</p>

<p>Есть два способа для клиента обработать наборы результатов. Один путь
состоит в том, чтобы получить весь набор результатов вызовом
<a href="#mysql-store-result"
<code>mysql_store_result()</code></a>. Эта функция получает от сервера все
строки, возвращенные запросом, и хранит их в клиенте. Второй путь в том,
чтобы начать извлечение набора результатов построчно вызовом
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a>. Эта функция инициализирует извлечение, но фактически не получает
строк от сервера.</p>

<p>В обоих случаях Вы получаете доступ к строкам через
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a>. С помощью <a href="#mysql-store-result">
<code>mysql_store_result()</code></a>,
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a> обращается к строкам, которые были ранее переданы с сервера. С
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a> <a href="#mysql-fetch-row"><code>
mysql_fetch_row()</code></a> фактически получает строку от сервера.
Информация о размере данных в каждой строке доступна через вызов
<a href="#mysql-fetch-lengths">
<code>mysql_fetch_lengths()</code></a>.</p>

<p>После того, как Вы закончите с набором результатов, вызовите
<a href="#mysql-free-result">
<code>mysql_free_result()</code></a>, чтобы освободить память,
используемую для этого.</p>

<p>Два механизма извлечения дополняют друг друга. Выберите подход, который
является самым подходящим для каждого приложения-клиента. Практически,
клиенты чаще склонны использовать
<a href="#mysql-store-result">
<code>mysql_store_result()</code></a>.</p>

<p>Преимущество <a href="#mysql-store-result">
<code>mysql_store_result()</code></a> в том, что все строки передаются
клиенту, Вы не только можете получить доступ к строкам последовательно, Вы
можете двигаться вперед-назад в использовании набора результатов, используя
result set using <a href="#mysql-data-seek">
<code>mysql_data_seek()</code></a> или
<a href="#mysql-row-seek"><code>mysql_row_seek()</code>
</a> изменить текущую позицию строки в пределах набора результатов. Вы можете
также узнать, сколько там строк через
<a href="#mysql-num-rows"><code>mysql_num_rows()</code>
</a>. С другой стороны, требования к памяти для
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> могут быть очень высоким для больших наборов результатов, и Вы,
более вероятно, столкнетесь с проблемами.</p>

<p>Преимущество <a href="#mysql-use-result">
<code>mysql_use_result()</code></a> в том, что клиент требует меньшей памяти
для набора результатов, потому что это поддерживает только одну строку за раз
(и потому что меньше накладных расходов
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a> может быть быстрее).
Недостатки: Вы должны обработать каждую строку быстро, чтобы избежать
задержек на сервере, у Вас нет произвольного доступа к строкам в пределах
набора результатов (Вы можете получить доступ к строкам только
последовательно) и число строк в наборе результатов неизвестно, пока Вы не
получили их все. Кроме того, Вы <span><em>должны</em></span> получить все
строки, даже если Вы определяете в середине извлечения, что нашли
информацию, которую искали.</p>

<p>API позволяет клиентам соответственно ответить на запросы получая строки
только по мере необходимости), не зная, является ли запрос
<a href="sql.htm#select"><code>SELECT</code></a>. Вы можете сделать
это вызовом <a href="#mysql-store-result"><code>
mysql_store_result()</code></a> после каждого
<a href="#mysql-query"><code>mysql_query()</code></a>
(или <a href="#mysql-real-query"><code>mysql_real_query()
</code></a>). Если требование набора результатов успешно, запросом был
<a href="sql.htm#select"><code>SELECT</code></a> и Вы можете читать
строки. Если требование набора результатов терпит неудачу, вызовите
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a>, чтобы определить, состоял ли результат в том, что фактически
ожидается. Если <a href="#mysql-field-count">
<code>mysql_field_count()</code></a> вернет 0, запрос не возвратил данных
(указывает, что это был <a href="sql.htm#insert"><code>INSERT</code>
</a>, <a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> и т.д.) и, как
ожидалось, не возвратил строки. Если
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a> не 0, запрос должен был возвратить строки, но этого не сделал.
Это указывает, что запрос <a href="sql.htm#select"><code>SELECT
</code></a> был неудачным.</p>

<p><a href="#mysql-store-result">
<code>mysql_store_result()</code></a> и
<a href="#mysql-use-result">
<code>mysql_use_result()</code></a> позволяют Вам получить информацию о
полях, которые составляют набор результатов (число, их имена и типы и т.д.).
Вы можете получить доступ к информации последовательно, неоднократно вызывая
calling <a href="#mysql-fetch-field">
<code>mysql_fetch_field()</code></a> или по номеру поля вызовом
<a href="#mysql-fetch-field-direct">
<code>mysql_fetch_field_direct()</code></a>. Текущая позиция курсора может
быть изменена через <a href="#mysql-field-seek">
<code>mysql_field_seek()</code></a>. Установка курсора затрагивает
последующие вызовы <a href="#mysql-fetch-field">
<code>mysql_fetch_field()</code></a>. Вы можете также получить информацию для
для всех полей вызовом <a href="#mysql-fetch-fields">
<code>mysql_fetch_fields()</code></a>.</p>

<p>Для обнаружения и сообщения об ошибках MySQL обеспечивает доступ к
информации об ошибке посредством функций
<a href="#mysql-errno"><code>mysql_errno()</code></a> и
<a href="#mysql-error"><code>mysql_error()</code></a>.
Они возвращают код ошибки или сообщение об ошибке для последний раз вызванной
функции, которая может потерпеть неудачу, позволяя Вам определить, когда
ошибка произошла и что это было.</p>

<h3><a name="c-api-functions"></a>25.8.7. Описание функций C API</h3>
<p>В описаниях здесь параметр или возвращаемое значение
<code>NULL</code> означает <code>NULL</code> в смысле языка программирования
C, а не значение <code>NULL</code> MySQL.</p>

<p>Функции, которые возвращают значение вообще, возвращают указатель или
целое число. Если не определено иное, функции, возвращая указатель,
возвращают значение не-<code>NULL</code>, чтобы указать на успех или
<code>NULL</code>, чтобы указать на ошибку, а функции, возвращающие целое
число, возвращают ноль, чтобы указать на успех или отличное от нуля значение,
чтобы указать на ошибку. Отметьте, что "не 0" означает только это. Если
функциональное описание не говорит иного, не проверяйте значения кроме ноля:
<pre>
if (result)     /* correct */
   ... error ...
if (result &lt; 0) /* incorrect */
   ... error ...
if (result == -1) /* incorrect */
   ... error ...
</pre>

<p>Когда функция возвращает ошибку, подраздел функционального описания
<strong>Ошибки</strong> перечисляет возможные типы ошибок. Вы можете узнать
что случилось, вызывая
<a href="#mysql-errno"><code>mysql_errno()</code></a>.
Строковое представление ошибки может быть получено с помощью
<a href="#mysql-error"><code>mysql_error()</code></a>.
</p>

<h4><a name="mysql-affected-rows"></a>25.8.7.1. mysql_affected_rows()</h4>
<p><code>my_ulonglong mysql_affected_rows(MYSQL *mysql)</code></p>
<h5><a name="idm139965279165936"></a>Описание</h5>
<p><a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a> может быть немедленно вызвана после
выполнения запроса <a href="#mysql-query"><code>
mysql_query()</code></a> или <a href="#mysql-real-query">
<code>mysql_real_query()</code></a>. Это возвращает число строк, которые
изменились, удалились или вставились последним запросом, если это был
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#insert"><code>INSERT</code></a>. Для запросов
<a href="sql.htm#select"><code>SELECT</code></a>
<a href="#mysql-affected-rows"><code>
mysql_affected_rows()</code></a> работает аналогично
<a href="#mysql-num-rows"><code>mysql_num_rows()</code>
</a>.</p>

<p>Для запроса <a href="sql.htm#update"><code>UPDATE</code></a>
значение затронутых строк по умолчанию равно числу строк, фактически
измененных. Если Вы определяете опцию <code>CLIENT_FOUND_ROWS</code> в
<a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a> соединяясь с
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>,
значение затронутых строк равно числу найденных строк, то есть,
соответствующих определению <code>WHERE</code>.</p>

<p>Для запроса <a href="sql.htm#replace"><code>REPLACE</code></a>
значение затронутых строк 2, если новая строка заменила старую, потому что в
этом случае одна строка была вставлена после того, как дубликат был удален.
</p>

<p>Для запросов <a href="sql.htm#insert-on-duplicate"><code>INSERT
... ON DUPLICATE KEY UPDATE</code></a> число затронутых строк для каждой
обработанной строки 1, если строка вставлена как новая строка, 2, если
существующая строка обновлена, и 0, если существующая строка оставлена в
текущем состоянии. Если Вы определяете опцию <code>CLIENT_FOUND_ROWS</code>,
значение затронутых строк 1 (не 0), если существующая строка была оставлена в
ее текущем состоянии.</p>

<p>Для запросов <a href="sql.htm#call"><code>CALL</code></a>
<a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a> возвращает значение, которое
возвратило бы для последнего запроса, выполненного в пределах хранимой
процедуры, или <code>0</code> этот запрос вернул бы <code>-1</code>.
В пределах процедуры Вы можете использовать
<a href="funct.htm#function_row-count"><code>ROW_COUNT()</code></a> на
уровне SQL, чтобы получить количество затронутых строк
для отдельных запросов.</p>

<h5><a name="idm139965279132688"></a>Возвращаемые значения</h5>
<p>Целое число, больше чем ноль, указывает на число строк, обработанных или
полученных. Ноль указывает, что никакие записи не были обновлены
<a href="sql.htm#update"><code>UPDATE</code></a>, никакие строки не
соответствовали <code>WHERE</code> или что никакой запрос еще не был
выполнен. -1 указывает, что запрос вернул ошибку или что для запроса
<a href="sql.htm#select"><code>SELECT</code></a>
<a href="#mysql-affected-rows"><code>
mysql_affected_rows()</code></a> был вызван до запроса
<a href="#mysql-store-result">
<code>mysql_store_result()</code></a>.</p>

<p>Поскольку <a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a> возвращает значение, Вы можете
проверить на-1, сравнивая возвращаемое значение с
<code>(my_ulonglong)-1</code> (или <code>(my_ulonglong)~0</code>).</p>

<h5><a name="idm139965279122416"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965279121312"></a>Пример</h5>
<pre>
char *stmt = "UPDATE products SET cost=cost*1.25 WHERE group=10";
mysql_query(&amp;mysql,stmt);
printf("%ld products updated", (long) mysql_affected_rows(&amp;mysql));
</pre>

<h4><a name="mysql-autocommit"></a>25.8.7.2. mysql_autocommit()</h4>
<p><code>my_bool mysql_autocommit(MYSQL *mysql, my_bool mode)</code></p>
<h5><a name="idm139965279116336"></a>Описание</h5>
<p>Устанавливает режим autocommit в on, если <code>mode</code> 1, и в
off, если <code>mode</code> 0.</p>

<h5><a name="idm139965279113776"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличный от нуля, если ошибка произошла.</p>
<h5><a name="idm139965279112624"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-change-user"></a>25.8.7.3. mysql_change_user()</h4>
<p><code>my_bool mysql_change_user(MYSQL *mysql, const char *user,
const char *password, const char *db)</code></p>

<h5><a name="idm139965279108064"></a>Описание</h5>
<p>Изменяет пользователя и устанавливает базу данных, определенную
<code>db</code>, в качестве базы данных по умолчанию для соединения
<code>mysql</code>. В последующих запросах эта база данных будет значением
по умолчанию для табличных ссылок, которые не включают явного
спецификатора базы данных.</p>

<p><a href="#mysql-change-user">
<code>mysql_change_user()</code></a> терпит неудачу, если пользователь не
может быть авторизован или не имеет разрешения использовать базу данных. В
этом случае пользователь и база данных не будут изменены.</p>
<p>Установите <code>db</code> в <code>NULL</code>,
если Вы не хотите иметь базу данных значения по умолчанию.</p>

<p>Эта функция сбрасывает статус сессии, как будто сделано новое подключение
с авторизацией. Это всегда выполняет
<a href="sql.htm#commit"><code>ROLLBACK</code></a> любых активных
транзакций, удаляет все временные таблицы и отпирает все заблокированные
таблицы. Системные переменные сеанса будут сброшены к значениям
соответствующих глобальных системных переменных. Готовые запросы завершены,
а переменные <a href="sql.htm#handler"><code>HANDLER</code></a>
закрыты. Блокировки, приобретенные с
<a href="funct.htm#function_get-lock"><code>GET_LOCK()</code></a>
снимаются. Эти эффекты происходят, даже если пользователь не изменялся.</p>

<p>Чтобы сбросить статус соединения в более легкой манере, не изменяя
пользователя, вызовите
<a href="#mysql-reset-connection">
<code>mysql_reset_connection()</code></a>.</p>

<h5><a name="idm139965279094608"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличный от нуля, если ошибка произошла.</p>

<h5><a name="idm139965279093456"></a>Ошибки</h5>
<p>То же самое, что Вы можете получить от
<a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a>, плюс:</p>

<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error">
<code>CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost">
<code>CR_SERVER_LOST</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error">
<code>CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</li>

<li><a href="error.htm#error_er_unknown_com_error">
<code>ER_UNKNOWN_COM_ERROR</code></a></p>
<p>Сервер MySQL не осуществляет эту команду (вероятно, старый сервер).</li>

<li><a href="error.htm#error_er_access_denied_error">
<code>ER_ACCESS_DENIED_ERROR</code></a></p>
<p>Пользователь или пароль были неправильные.</li>

<li><a href="error.htm#error_er_bad_db_error">
<code>ER_BAD_DB_ERROR</code></a></p>
<p>База данных не существует.</li>

<li><a href="error.htm#error_er_dbaccess_denied_error">
<code>ER_DBACCESS_DENIED_ERROR</code></a></p>
<p>У пользователя нет прав доступа к этой базе данных.</li>

<li><a href="error.htm#error_er_wrong_db_name">
<code>ER_WRONG_DB_NAME</code></a></p>
<p>Имя базы данных слишком длинное.</p></li></ul>

<h5><a name="idm139965279067056"></a>Пример</h5>
<pre>
if (mysql_change_user(&amp;mysql, "user", "password", "new_database")) {
   fprintf(stderr, "Failed to change user.  Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<h4><a name="mysql-character-set-name"></a>25.8.7.4.
mysql_character_set_name()</h4>
<p><code>const char *mysql_character_set_name(MYSQL *mysql)</code></p>

<h5><a name="idm139965279061856"></a>Описание</h5>
<p>Возвращает название набора символов по умолчанию для текущего соединения.
</p>

<h5><a name="idm139965279060672"></a>Возвращаемые значения</h5>
<p>Имя набора символов по умолчанию.</p>
<h5><a name="idm139965279059536"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-close"></a>25.8.7.5. mysql_close()</h4>
<p><code>void mysql_close(MYSQL *mysql)</code></p>

<h5><a name="idm139965279055040"></a>Описание</h5>
<p>Закрывает ранее открытое соединение.
<a href="#mysql-close"><code>mysql_close()</code></a>
также освобождает дескриптор соединения, который указан <code>mysql</code>,
если дескриптор был выделен автоматически
<a href="#mysql-init"><code>mysql_init()</code></a> или
<a href="#mysql-connect"><code>mysql_connect()</code>
</a>.</p>

<h5><a name="idm139965279049376"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h5><a name="idm139965279048272"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-commit"></a>25.8.7.6. mysql_commit()</h4>
<p><code>my_bool mysql_commit(MYSQL *mysql)</code></p>
<h5><a name="idm139965279043776"></a>Описание</h5>
<p>Закрывает текущую транзакцию.</p>

<p>Действие этой функции зависит от значения системной переменной
<a href="server.htm#sysvar_completion_type">
<code>completion_type</code></a>. В частности, если значение
<a href="server.htm#sysvar_completion_type">
<code>completion_type</code></a> равно <code>RELEASE</code> (или 2),
сервер выполняет сброс после прерывания транзакции и закрывает соединение
клиента. Вызовите <a href="#mysql-close"><code>
mysql_close()</code></a> из программы, чтобы закрыть соединение
со стороны клиента.</p>

<h5><a name="idm139965279037504"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965279036352"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-connect"></a>25.8.7.7. mysql_connect()</h4>
<a class="indexterm" name="idm139965279034016"></a><p>
  <code>MYSQL *mysql_connect(MYSQL *mysql, const char *host,
  const char *user, const char *passwd)</code>
</p>

<h5><a name="idm139965279031792"></a>Описание</h5>
<p>Эта функция устарела. Используйте вместо нее
<a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a>.</p>

<p><a href="#mysql-connect"><code>mysql_connect()</code>
</a> пытается установить соединение с сервером баз данных MySQL на машине
<code>host</code>. <a href="#mysql-connect"><code>
mysql_connect()</code></a> должен завершиться успешно прежде, чем Вы сможете
выполнить любую из других функций API, за исключением
<a href="#mysql-get-client-info"><code>
mysql_get_client_info()</code></a>.</p>

<p>Значения параметров те же самые, что и для
<a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a> с тем различием, что параметр
соединения может быть <code>NULL</code>. В этой ситуации C API выделяет
память для структуры соединения автоматически и освобождает ее, когда Вы
вызовете <a href="#mysql-close"><code>mysql_close()
</code></a>. Недостаток этого подхода: Вы не можете получить сообщение об
ошибке, если связь прерывается. Чтобы получить информацию от
<a href="#mysql-errno"><code>mysql_errno()</code></a> или
<a href="#mysql-error"><code>mysql_error()</code></a>,
Вы должны обеспечить допустимый указатель <code>MYSQL</code>.</p>

<h5><a name="idm139965279016496"></a>Возвращаемые значения</h5>
<p>Аналогично <a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a>.</p>

<h5><a name="idm139965279014144"></a>Ошибки</h5>
<p>Аналогично <a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a>.</p>

<h4><a name="mysql-create-db"></a>25.8.7.8. mysql_create_db()</h4>
<p><code>int mysql_create_db(MYSQL *mysql, const char *db)</code></p>
<h5><a name="idm139965279008368"></a>Описание</h5>
<p>Создает базу данных с именем, заданным в <code>db</code>.</p>

<p>Эта функция устарела, вместо нее используйте
<a href="#mysql-query"><code>mysql_query()</code></a>
для выполнения запроса SQL <a href="sql.htm#create-database"><code>
CREATE DATABASE</code></a>.</p>

<h5><a name="idm139965279002848"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965279001696"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h5><a name="idm139965278990848"></a>Пример</h5>
<pre>
if (mysql_create_db(&amp;mysql, "my_database")) {
   fprintf(stderr, "Failed to create new database.  Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<h4><a name="mysql-data-seek"></a>25.8.7.9. mysql_data_seek()</h4>
<a class="indexterm" name="idm139965278987936"></a><p>
<code>void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset)</code></p>
<h5><a name="idm139965278985744"></a>Описание</h5>
<p>Позиционируется  на произвольную строку в наборе результатов запроса.
<code>offset</code> задает номер строки. Определите значение в диапазоне от
<code>0</code> до <a href="#mysql-num-rows">
<code>mysql_num_rows(result)-1</code></a>.</p>

<p>Эта функция требует, чтобы структура набора результатов содержала весь
результат запроса, таким образом,
<a href="#mysql-data-seek"><code>mysql_data_seek()</code>
</a> может использоваться только вместе с
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, но не с <a href="#mysql-use-result"><code>
mysql_use_result()</code></a>.</p>

<h5><a name="idm139965278977632"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278976528"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-debug"></a>25.8.7.10. mysql_debug()</h4>
<p><code>void mysql_debug(const char *debug)</code></p>
<h5><a name="idm139965278972032"></a>Описание</h5>
<p>Делает <code>DBUG_PUSH</code> с заданной строкой.
<a href="#mysql-debug"><code>mysql_debug()</code></a>
пользуется библиотекой отладки Фреда Фиша. Чтобы использовать эту функцию, Вы
должны собрать библиотеку клиента с поддержкой отладки.</p>

<h5><a name="idm139965278968160"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278967056"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278965952"></a>Пример</h5>
<p>Вызов, показанный здесь, заставляет библиотеку клиента генерировать файл
трассировки в <code>/tmp/client.trace</code> на клиентской машине:

<pre>
mysql_debug("d:t:O,/tmp/client.trace");
</pre>

<h4><a name="mysql-drop-db"></a>25.8.7.11. mysql_drop_db()</h4>
<a class="indexterm" name="idm139965278962080"></a><p>
<code>int mysql_drop_db(MYSQL *mysql, const char *db)</code></p>

<h5><a name="idm139965278959904"></a>Описание</h5>
<p>Удаляет базу данных с именем из параметра <code>db</code>.</p>

<p>Эта функция устарела. Предпочтительно использовать вместо нее
<a href="#mysql-query"><code>mysql_query()</code></a>
для выполнения запроса SQL
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>.</p>

<h5><a name="idm139965278954400"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965278953248"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h5><a name="idm139965278942400"></a>Пример</h5>
<pre>
if (mysql_drop_db(&amp;mysql, "my_database"))
   fprintf(stderr, "Failed to drop the database: Error: %s\n",
           mysql_error(&amp;mysql));
</pre>

<h4><a name="mysql-dump-debug-info"></a>25.8.7.12. mysql_dump_debug_info()
</h4>
<a class="indexterm" name="idm139965278939520"></a><p>
<code>int mysql_dump_debug_info(MYSQL *mysql)</code></p>

<h5><a name="idm139965278937360"></a>Описание</h5>
<p>Предписывает серверу записать информацию об отладке в журнал ошибок.
Соединенный пользователь должен иметь привилегию
<a href="security.html#priv_super"><code>SUPER</code></a>.</p>

<h5><a name="idm139965278934912"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965278933760"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>
CR_SERVER_LOST</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-eof"></a>25.8.7.13. mysql_eof()</h4>
<a class="indexterm" name="idm139965278921680"></a><p>
<code>my_bool mysql_eof(MYSQL_RES *result)</code></p>

<h5><a name="idm139965278919520"></a>Описание</h5>
<p>Эта функция устарела. <a href="#mysql-errno"><code>
mysql_errno()</code></a> или <a href="#mysql-error">
<code>mysql_error()</code></a> может использоваться вместо нее.</p>

<p><a href="#mysql-eof"><code>mysql_eof()</code></a>
определяет, была ли последняя строка набора результатов считана.</p>
<p>Если Вы получаете набор результатов успешным вызовом
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, клиент получает весь набор данных. В этом случае
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a> вернет <code>NULL</code>, это всегда означает, что конец набора
результатов был достигнут и не нужно вызывать
<a href="#mysql-eof"><code>mysql_eof()</code></a>.
Когда используется
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, <a href="#mysql-eof"><code>mysql_eof()
</code></a> всегда возвращает true.</p>

<p>С другой стороны, если Вы используете
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a>, чтобы начать извлечение набора результатов, строки набора
будут получены с сервера одна за другой по мере того, как Вы вызываете
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a>. Поскольку ошибка может произойти в соединении во время этого процесса,
возвращаемое значение <code>NULL</code> из
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a> не обязательно означает, что конец набора результатов достигнут. В этом
случае Вы можете использовать
<a href="#mysql-eof"><code>mysql_eof()</code></a>, чтобы
определить, что произошло. <a href="#mysql-eof"><code>
mysql_eof()</code></a> возвращает ненулевое значение, если конец набора
результатов был достигнут и ноль, если ошибка произошла.</p>

<p>Исторически <a href="#mysql-eof"><code>mysql_eof()
</code></a> предшествует стандартным функциям ошибок MySQL
<a href="#mysql-errno"><code>mysql_errno()</code></a> и
<a href="#mysql-error"><code>mysql_error()</code></a>.
Поскольку эти функции ошибок предоставляют ту же самую информацию, их
использование предпочтительнее <a href="#mysql-eof">
<code>mysql_eof()</code></a>, которая устарела. Фактически они предоставляют
больше информации, потому что <a href="#mysql-eof"><code>
mysql_eof()</code></a> возвращает только булево значение, тогда как функции
ошибок указывают на причину ошибки.</p>

<h5><a name="idm139965278891312"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличное от нуля, если конец набора
результатов был достигнут.</p>

<h5><a name="idm139965278890128"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278889024"></a>Пример</h5>
<p>Следующий пример показывает, как Вы могли бы использовать
<a href="#mysql-eof"><code>mysql_eof()</code></a>:
<pre>
mysql_query(&amp;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&amp;mysql);
while((row = mysql_fetch_row(result))) {
  // do something with data
}
if (!mysql_eof(result))  // mysql_fetch_row() failed due to an error {
   fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
}
</pre>

<p>Однако, Вы можете достичь того же самого эффекта стандартными
функциями ошибок MySQL:
<pre>
mysql_query(&amp;mysql,"SELECT * FROM some_table");
result = mysql_use_result(&amp;mysql);
while((row = mysql_fetch_row(result))) {
  // do something with data
}
if (mysql_errno(&amp;mysql))  // mysql_fetch_row() failed due to an error {
   fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
}
</pre>

<h4><a name="mysql-errno"></a>25.8.7.14. mysql_errno()</h4>
<a class="indexterm" name="idm139965278882240"></a><p>
<code>unsigned int mysql_errno(MYSQL *mysql)</code></p>

<h5><a name="idm139965278880080"></a>Описание</h5>
<p>Для соединения, определенного <code>mysql</code>,
<a href="#mysql-errno"><code>mysql_errno()</code></a>
возвращает код ошибки для последней вызванной функции API, которая может
потерпеть неудачу. Возвращаемое значение 0, что никакой ошибки не произошло.
Коды сообщений об ошибках клиента перечислены в заголовочном файле MySQL
<code>errmsg.h</code>. Коды сообщений об ошибках сервера перечислены в
<code>mysqld_error.h</code>. Ошибки также перечислены в
<a href="error.htm">приложении B. <i>Ошибки, коды
ошибок и типичные проблемы</i></a>.</p>

<p>Некоторые функции такие, как
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a>, не устанавливают
<a href="#mysql-errno"><code>mysql_errno()</code></a>,
если они отработали нормально.</p>

<p>MySQL-специфичные коды ошибок, возвращенные
<a href="#mysql-errno"><code>mysql_errno()</code></a>,
отличаются от значений SQLSTATE, возвращенных
<a href="#mysql-sqlstate"><code>mysql_sqlstate()</code>
</a>. Например, клиент <a href="programs.htm#mysql"><span><strong>mysql
</strong></span></a> выводит на экран ошибки, используя следующий формат, где
<code>1146</code> значение
<a href="#mysql-errno"><code>mysql_errno()</code></a> и
<code>'42S02'</code> соответствующее значение
<a href="#mysql-sqlstate">
<code>mysql_sqlstate()</code></a>:

<pre>
shell&gt; <strong><code>SELECT * FROM no_such_table;</code></strong>
ERROR 1146 (42S02): Table 'test.no_such_table' doesn't exist
</pre>

<h5><a name="idm139965278860256"></a>Возвращаемые значения</h5>
<p>Значение кода ошибки для последнего вызова
<code>mysql_<em><code>xxx</code></em>()</code>,
если это потерпело неудачу. 0 означает, что никакая ошибка не произошла.</p>

<h5><a name="idm139965278857968"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-error"></a>25.8.7.15. mysql_error()</h4>
<p><code>const char *mysql_error(MYSQL *mysql)</code></p>
<h5><a name="idm139965278853536"></a>Описание</h5>
<p>Для соединения, определенного <code>mysql</code>,
<a href="#mysql-error"><code>mysql_error()</code></a>
возвращает законченную нулем строку, содержащую сообщение об ошибке для
последней вызванной функции API, которая потерпела неудачу. Если функция не
потерпела неудачу, возвращаемое значение
<a href="#mysql-error"><code>mysql_error()</code></a>
может быть предыдущей ошибкой или пустой строкой, чтобы не указать ни на
какую ошибку вообще.</p>

<p>Для функций, которые сбрасывают
<a href="#mysql-error"><code>mysql_error()</code></a>,
любой из этих двух тестов может использоваться, чтобы проверить на ошибку:

<pre>
if (*mysql_error(&amp;mysql)) {
   // an error occurred
}

if (mysql_error(&amp;mysql)[0]) {
   // an error occurred
}
</pre>

<p>Язык сообщений об ошибках клиента может быть изменен, повторно собирая
библиотеку клиента MySQL. Вы можете выбрать сообщения об ошибках на
нескольких различных языках. См.
<a href="global.htm#error-message-language">раздел 11.2.
Установка языка сообщений об ошибках</a>.</p>

<h5><a name="idm139965278843360"></a>Возвращаемые значения</h5>
<p>Законченная нулем строка символов, которая описывает ошибку. Пустая
строка, если никакая ошибка не произошла.</p>

<h5><a name="idm139965278842144"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-escape-string"></a>25.8.7.16. mysql_escape_string()</h4>
<p>Не используйте эту функцию.
<a href="#mysql-escape-string"><code>
mysql_escape_string()</code></a> не имеет параметров, которые позволяют
учитывать текущий набор символов или контекст в кавычках. Вместо этого
применяйте <a href="#mysql-real-escape-string-quote">
<code>mysql_real_escape_string_quote()</code></a>.</p>

<h4><a name="mysql-fetch-field"></a>25.8.7.17. mysql_fetch_field()</h4>
<p><code>MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result)</code></p>
<h5><a name="idm139965278831840"></a>Описание</h5>
<p>Возвращает определение одного столбца набора результатов как структуру
<code>MYSQL_FIELD</code>. Вызовите эту функцию неоднократно, чтобы получить
информацию обо всех столбцах в наборе результатов.
<a href="#mysql-fetch-field"><code>mysql_fetch_field()
</code></a> вернет <code>NULL</code>, когда полей больше нет.</p>

<p><a href="#mysql-fetch-field"><code>mysql_fetch_field()
</code></a> сбрасывается, чтобы возвратить информацию о первом поле каждый
раз, когда Вы выполняете новый запрос <a href="sql.htm#select"><code>
SELECT</code></a>. Поле, которое вернет
<a href="#mysql-fetch-field"><code>mysql_fetch_field()
</code></a>, также определяется вызовами
<a href="#mysql-field-seek"><code>mysql_field_seek()
</code></a>.</p>

<p>Если Вы вызывали <a href="#mysql-query"><code>
mysql_query()</code></a>, чтобы выполнить <a href="sql.htm#select">
<code>SELECT</code></a> на таблице, но не вызвали
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, MySQL возвращает длину blob по умолчанию (8KB), если Вы
вызываете <a href="#mysql-fetch-field"><code>
mysql_fetch_field()</code></a>, чтобы запросить длину поля типа
<a href="types.htm#blob"><code>BLOB</code></a>. Размер 8 КБ выбран,
потому что MySQL не знает максимальной длины для
<a href="types.htm#blob"><code>BLOB</code></a>. Когда-нибудь это должно
быть сделано конфигурируемым. Как только Вы получили набор результатов,
<code>field-&gt;max_length</code> содержит длину самого большого значения для
этого столбца в определенном запросе.</p>

<h5><a name="idm139965278813520"></a>Возвращаемые значения</h5>
<p>Структура <code>MYSQL_FIELD</code> для текущего столбца.
<code>NULL</code>, если никаких столбцов нет.</p>

<h5><a name="idm139965278810928"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278809824"></a>Пример</h5>
<pre>
MYSQL_FIELD *field;

while((field = mysql_fetch_field(result)))
{
  printf("field name %s\n", field-&gt;name);
}
</pre>

<h4><a name="mysql-fetch-field-direct"></a>25.8.7.18.
mysql_fetch_field_direct()</h4>
<p><code>MYSQL_FIELD *mysql_fetch_field_direct(MYSQL_RES *result,
unsigned int fieldnr)</code></p>

<h5><a name="idm139965278804752"></a>Описание</h5>
<p>Учитывая номер поля <code>fieldnr</code> для столбца в пределах набора
результатов, возвращает определение столбца как структуру
<code>MYSQL_FIELD</code>. Используйте эту функцию, чтобы получить определение
для произвольного столбца. Определите значение для <code>fieldnr</code> в
диапазоне от 0 до <a href="#mysql-num-fields"><code>
mysql_num_fields(result)-1</code></a>.</p>

<h5><a name="idm139965278800032"></a>Возвращаемые значения</h5>
<p>Структура <code>MYSQL_FIELD</code> для указанного столбца.</p>
<h5><a name="idm139965278798176"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278797072"></a>Пример</h5>
<pre>
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *field;

num_fields = mysql_num_fields(result);
for (i = 0; i &lt; num_fields; i++) {
  field = mysql_fetch_field_direct(result, i);
  printf("Field %u is %s\n", i, field-&gt;name);
}
</pre>

<h4><a name="mysql-fetch-fields"></a>25.8.7.19. mysql_fetch_fields()</h4>
<p><code>MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *result)</code></p>
<h5><a name="idm139965278791808"></a>Описание</h5>
<p>Возвращает массив из структур <code>MYSQL_FIELD</code> для набора
результатов. Каждая структура обеспечивает определение для одного
столбца набора результатов.</p>

<h5><a name="idm139965278789856"></a>Возвращаемые значения</h5>
<p>Массив из структур <code>MYSQL_FIELD</code> для всех
столбцов набора результатов.</p>

<h5><a name="idm139965278787984"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278786880"></a>Пример</h5>
<pre>
unsigned int num_fields;
unsigned int i;
MYSQL_FIELD *fields;

num_fields = mysql_num_fields(result);
fields = mysql_fetch_fields(result);
for (i = 0; i &lt; num_fields; i++) {
  printf("Field %u is %s\n", i, fields[i].name);
}
</pre>

<h4><a name="mysql-fetch-lengths"></a>25.8.7.20. mysql_fetch_lengths()</h4>
<p><code>unsigned long *mysql_fetch_lengths(MYSQL_RES *result)</code></p>
<h5><a name="idm139965278781792"></a>Описание</h5>
<p>Возвращает длины столбцов текущей строки в пределах набора результатов.
Если Вы планируете скопировать значения полей, эта информация о длине также
полезна для оптимизации, потому что Вы можете избежать вызовов
<code>strlen()</code>. Кроме того, если набор результатов содержит двоичные
данные, Вы <strong>должны</strong></span> использовать эту функцию, чтобы
определить размер данных, потому что <code>strlen()</code> возвращает
неправильные результаты для любого поля, содержащего нулевые символы.</p>

<p>Длина для пустых столбцов и для столбцов, содержащих значения
<code>NULL</code> = 0. Чтобы видеть, как отличить эти два случая, см.
описание для <a href="#mysql-fetch-row"><code>
mysql_fetch_row()</code></a>.</p>

<h5><a name="idm139965278775616"></a>Возвращаемые значения</h5>
<p>Массив unsigned long integer, представляющих размер каждого столбца (не
включая любые заканчивающие нулевые байты).
<code>NULL</code>, если ошибка произошла.</p>

<h5><a name="idm139965278773648"></a>Ошибки</h5>
<p><a href="#mysql-fetch-lengths">
<code>mysql_fetch_lengths()</code></a> допустимо только для текущей строки
набора результатов. Это возвращает <code>NULL</code>, если Вы вызываете это
перед запросом <a href="#mysql-fetch-row"><code>
mysql_fetch_row()</code></a> или после получения всех строк в результате.</p>

<h5><a name="idm139965278769264"></a>Пример</h5>
<pre>
MYSQL_ROW row;
unsigned long *lengths;
unsigned int num_fields;
unsigned int i;

row = mysql_fetch_row(result);
if (row) {
   num_fields = mysql_num_fields(result);
   lengths = mysql_fetch_lengths(result);
   for (i = 0; i &lt; num_fields; i++) {
     printf("Column %u is %lu bytes in length.\n", i, lengths[i]);
   }
}
</pre>

<h4><a name="mysql-fetch-row"></a>25.8.7.21. mysql_fetch_row()</h4>
<p><code>MYSQL_ROW mysql_fetch_row(MYSQL_RES *result)</code></p>
<h5><a name="idm139965278764096"></a>Описание</h5>
<p>Получает следующую строку набора результатов. Когда используется после
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, <a href="#mysql-fetch-row"><code>
mysql_fetch_row()</code></a> вернет <code>NULL</code>, если нет больше строк.
Когда используется после <a href="#mysql-use-result">
<code>mysql_use_result()</code></a>,
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a> вернет <code>NULL</code>, когда нет больше строк или произошла ошибка.
</p>

<p>Число значений в строке дает
<a href="#mysql-num-fields">
<code>mysql_num_fields(result)</code></a>. Если <code>row</code>
хранит возвращаемое значение от вызова
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a>, к указателям на значения получают доступ как <code>row[0]</code> до
<code>row[mysql_num_fields(result)-1]</code>. Значения <code>NULL</code> в
строке обозначены как указатели <code>NULL</code>.</p>

<p>Длины значений полей в строке могут быть получены вызовом
<a href="#mysql-fetch-lengths"><code>
mysql_fetch_lengths()</code></a>. Пустые поля и поля, содержащие
<code>NULL</code>, имеют длину 0. Вы можете отличить их, проверяя указатель
на значение поля. Если указатель <code>NULL</code>, поле <code>NULL</code>,
иначе оно пустое.</p>

<h5><a name="idm139965278745760"></a>Возвращаемые значения</h5>
<p>Структура <code>MYSQL_ROW</code> для следующей строки. <code>NULL</code>,
если нет больше строк или произошла ошибка.</p>

<h5><a name="idm139965278743136"></a>Ошибки</h5>
<p>Ошибки не сброшены между вызовами
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a>.</p>

<ul><li><p><a href="error.htm#error_cr_server_lost"><code>
CR_SERVER_LOST</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h5><a name="idm139965278735552"></a>Пример</h5>
<pre>
MYSQL_ROW row;
unsigned int num_fields;
unsigned int i;

num_fields = mysql_num_fields(result);
while ((row = mysql_fetch_row(result))) {
  unsigned long *lengths;

  lengths = mysql_fetch_lengths(result);
  for (i = 0; i &lt; num_fields; i++) {
    printf("[%.*s] ", (int) lengths[i], row[i] ? row[i] : "NULL");
  }
  printf("\n");
}
</pre>

<h4><a name="mysql-field-count"></a>25.8.7.22. mysql_field_count()</h4>
<p><code>unsigned int mysql_field_count(MYSQL *mysql)</code></p>
<h5><a name="idm139965278730336"></a>Описание</h5>
<p>Возвращает число столбцов для нового запроса на соединении.</p>

<p>Нормальная эксплуатация этой функции: когда
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> возвращает <code>NULL</code> и таким образом у Вас нет никакого
указателя на набор результатов. В этом случае Вы можете вызвать
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a>, чтобы определить
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> должен был привести к непустому результату. Это позволяет
программе-клиенту предпринять надлежащие меры, не зная, был ли запрос
<a href="sql.htm#select"><code>SELECT</code></a> (или подобным).
Пример, показанный здесь, иллюстрирует, как это может быть сделано.</p>

<h5><a name="idm139965278720240"></a>Возвращаемые значения</h5>
<p>Число типа unsigned integer представляющее число
столбцов в наборе результатов.</p>

<h5><a name="idm139965278719056"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278717952"></a>Пример</h5>
<pre>
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&amp;mysql,query_string)) {
   // error
}
else // query succeeded, process any data returned by it
{
  result = mysql_store_result(&amp;mysql);
  if (result)  // there are rows {
     num_fields = mysql_num_fields(result);
     // retrieve rows, then call mysql_free_result(result)
  }
  else  // mysql_store_result() returned nothing; should it have?
  {
    if (mysql_field_count(&amp;mysql) == 0) {
       // query does not return data
       // (it was not a SELECT)
       num_rows = mysql_affected_rows(&amp;mysql);
    }
    else // mysql_store_result() should have returned data
    {
      fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
    }
  }
}
</pre>

<p>Альтернатива должна заменить
<a href="#mysql-field-count"><code>
mysql_field_count(&amp;mysql)</code></a> на
<a href="#mysql-errno"><code>mysql_errno(&amp;mysql)
</code></a>. В этом случае Вы проверяете непосредственно на ошибку из
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> вместо того, чтобы делать выводы из значения
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a>, был ли запрос <a href="sql.htm#select"><code>SELECT
</code></a>.</p>

<h4><a name="mysql-field-seek"></a>25.8.7.23. mysql_field_seek()</h4>
<a class="indexterm" name="idm139965278707072"></a><p>
<code>MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result,
MYSQL_FIELD_OFFSET offset)</code></p>

<h5><a name="idm139965278704848"></a>Описание</h5>
<p>Устанавливает курсор на указанное смещение. Следующий вызов
<a href="#mysql-fetch-field"><code>mysql_fetch_field()
</code></a> получает определение столбца, связанного с этим смещением.
Чтобы перейти на начало строки, задайте <code>offset</code> = 0.</p>

<h5><a name="idm139965278701184"></a>Возвращаемые значения</h5>
<p>Предыдущее значение расположения курсора.</p>
<h5><a name="idm139965278700048"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-field-tell"></a>25.8.7.24. mysql_field_tell()</h4>
<p><code>MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *result)</code></p>
<h5><a name="idm139965278695520"></a>Описание</h5>
<p>Возвращает позицию курсора, используемого для последнего вызова
<a href="#mysql-fetch-field"><code>mysql_fetch_field()
</code></a>. Это значение может использоваться в качестве параметра
<a href="#mysql-field-seek"><code>mysql_field_seek()
</code></a>.</p>

<h5><a name="idm139965278691840"></a>Возвращаемые значения</h5>
<p>Текущая позиция курсора.</p>
<h5><a name="idm139965278690704"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-free-result"></a>25.8.7.25. mysql_free_result()</h4>
<p><code>void mysql_free_result(MYSQL_RES *result)</code></p>
<h5><a name="idm139965278686192"></a>Описание</h5>
<p>Освобождает память, выделенную для набора результатов
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, <a href="#mysql-use-result"><code>
mysql_use_result()</code></a>, <a href="#mysql-list-dbs">
<code>mysql_list_dbs()</code></a> и т. д. Когда Вы закончили работу с набором
результатов, Вы должны освободить память, которую это использует, вызывая
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a>. Не пытайтесь получить доступ к набору результатов
после освобождения памяти!</p>

<h5><a name="idm139965278679536"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278678432"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-get-character-set-info"></a>25.8.7.26.
mysql_get_character_set_info()</h4>
<p><code>void mysql_get_character_set_info(MYSQL *mysql,
MY_CHARSET_INFO *cs)</code></p>

<h5><a name="idm139965278673824"></a>Описание</h5>
<p>Эта функция предоставляет информацию о наборе символов клиента по
умолчанию. Набор символов по умолчанию может быть изменен с помощью функции
<a href="#mysql-set-character-set"><code>
mysql_set_character_set()</code></a>.</p>

<h5><a name="idm139965278671328"></a>Пример</h5>
<p>Этот пример показывает, которые доступны в структуре
<code>MY_CHARSET_INFO</code>:

<pre>
if (!mysql_set_character_set(&amp;mysql, "utf8")) {
   MY_CHARSET_INFO cs;

   mysql_get_character_set_info(&amp;mysql, &amp;cs);
   printf("character set information:\n");
   printf("character set+collation number: %d\n", cs.number);
   printf("character set name: %s\n", cs.name);
   printf("collation name: %s\n", cs.csname);
   printf("comment: %s\n", cs.comment);
   printf("directory: %s\n", cs.dir);
   printf("multi byte character min. length: %d\n", cs.mbminlen);
   printf("multi byte character max. length: %d\n", cs.mbmaxlen);
}
</pre>

<h4><a name="mysql-get-client-info"></a>25.8.7.27. mysql_get_client_info()
</h4>
<p><code>const char *mysql_get_client_info(void)</code></p>
<h5><a name="idm139965278663968"></a>Описание</h5>
<p>Возвращает строку, которая представляет версию библиотеки клиента MySQL;
например, <code>"8.0.1"</code>.</p>

<p>Функциональное значение: версия MySQL или Connector/C, которую
предоставляет библиотека клиента. Для получения дополнительной информации,
см. <a href="#c-api-server-client-versions">раздел
25.8.4.5, Версии сервера и библиотеки клиентов C API</a>.</p>

<h5><a name="idm139965278660640"></a>Возвращаемые значения</h5>
<p>Строка символов, которая представляет версию библиотеки клиента MySQL.</p>
<h5><a name="idm139965278659456"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-get-client-version"></a>25.8.7.28.
mysql_get_client_version()</h4>
<p>  <code>unsigned long mysql_get_client_version(void)</code></p>

<h5><a name="idm139965278654928"></a>Описание</h5>
<p>Возвращает целое число, которое представляет версию библиотеки клиента
MySQL. У значения есть формат <code>XYYZZ</code>, где
<code>X</code> главный номер версии, <code>YY</code> уровень выпуска (или
незначительная версия) и <code>ZZ</code> субверсия в пределах уровня выпуска:
<pre>
major_version*10000 + release_level*100 + sub_version
</pre>
<p>Например, версия <code>"8.0.1"</code> возвращается как <code>80001</code>.
</p>

<h5><a name="idm139965278646864"></a>Возвращаемые значения</h5>
<p>Целое число, которое представляет версию библиотеки клиента MySQL.</p>
<h5><a name="idm139965278645696"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-get-host-info"></a>25.8.7.29. mysql_get_host_info()</h4>
<p><code>const char *mysql_get_host_info(MYSQL *mysql)</code></p>
<h5><a name="idm139965278641184"></a>Описание</h5>
<p>Возвращает строку, описывающую тип соединения, включая имя хоста сервера.
</p>

<h5><a name="idm139965278639984"></a>Возвращаемые значения</h5>
<p>Строка символов, представляющая имя хоста сервера и тип подключения.</p>
<h5><a name="idm139965278638800"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-get-option"></a>25.8.7.30. mysql_get_option()</h4>
<p><code>int mysql_get_option(MYSQL *mysql, enum mysql_option option,
const void *arg)</code></p>

<h5><a name="idm139965278634288"></a>Описание</h5>
<p>Возвращает текущее значение опций, которые можно задать, используя
<a href="#mysql-options"><code>mysql_options()</code>
</a>. Значение должно быть обработано как "только для чтения".</p>

<p>Аргумент <code>option</code> это опция, для которой Вы хотите узнать ее
значение. Параметр <code>arg</code> указатель на переменную, в которой можно
сохранить значение опции. <code>arg</code> должен быть указателем на
переменную типа, подходящего для аргумента <code>option</code>. Следующяя
таблица показывает, какие переменные подходят для
каждого значения <code>option</code>.</p>

<table border="1"><thead><tr><th scope="col">Тип <code>arg</code></th>
<th scope="col">Допустимые значения <code>option</code></th></tr></thead>
<tbody><tr><td scope="row"><code>unsigned int</code></td>
<td><code>MYSQL_OPT_CONNECT_TIMEOUT</code>, <code>MYSQL_OPT_PROTOCOL</code>,
<code>MYSQL_OPT_READ_TIMEOUT</code>, <code>MYSQL_OPT_RETRY_COUNT</code>,
<code>MYSQL_OPT_WRITE_TIMEOUT</code></td></tr>
<tr><td scope="row"><code>unsigned long</code></td>
<td><code>MYSQL_OPT_MAX_ALLOWED_PACKET</code>,
<code>MYSQL_OPT_NET_BUFFER_LENGTH</code></td></tr>
<tr><td scope="row"><code>my_bool</code></td>
<td><code>MYSQL_ENABLE_CLEARTEXT_PLUGIN</code>,
<code>MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS</code>,
<code>MYSQL_OPT_COMPRESS</code>, <code>MYSQL_OPT_GUESS_CONNECTION</code>,
<code>MYSQL_OPT_LOCAL_INFILE</code>, <code>MYSQL_OPT_RECONNECT</code>,
<code>MYSQL_OPT_USE_EMBEDDED_CONNECTION</code>,
<code>MYSQL_OPT_USE_REMOTE_CONNECTION</code>,
<code>MYSQL_REPORT_DATA_TRUNCATION</code>,
<code>MYSQL_SECURE_AUTH</code></td></tr>
<tr><td scope="row"><code>const char *</code></td>
<td><code>MYSQL_DEFAULT_AUTH</code>, <code>MYSQL_OPT_BIND</code>,
<code>MYSQL_OPT_SSL_CA</code>, <code>MYSQL_OPT_SSL_CAPATH </code>,
<code>MYSQL_OPT_SSL_CERT</code>, <code>MYSQL_OPT_SSL_CIPHER</code>,
<code>MYSQL_OPT_SSL_CRL</code>, <code>MYSQL_OPT_SSL_CRLPATH</code>,
<code>MYSQL_OPT_SSL_KEY</code>, <code>MYSQL_OPT_SSL_MODE</code>,
<code>MYSQL_OPT_TLS_VERSION</code>, <code>MYSQL_PLUGIN_DIR</code>,
<code>MYSQL_READ_DEFAULT_FILE</code>, <code>MYSQL_READ_DEFAULT_GROUP</code>,
<code>MYSQL_SERVER_PUBLIC_KEY</code>, <code>MYSQL_SET_CHARSET_DIR</code>,
<code>MYSQL_SET_CHARSET_NAME</code>, <code>MYSQL_SET_CLIENT_IP</code>,
<code>MYSQL_SHARED_MEMORY_BASE_NAME</code></td></tr>
<tr><td scope="row">cannot be queried (error is returned)</td>
<td><code>MYSQL_INIT_COMMAND</code>,
<code>MYSQL_OPT_CONNECT_ATTR_DELETE</code>,
<code>MYSQL_OPT_CONNECT_ATTR_RESET</code>,
<code>MYSQL_OPT_NAMED_PIPE</code></td></tr></tbody></table>

<h5><a name="idm139965278586480"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличнок от нуля, если ошибка произошла: это происходит
для значений <code>option</code>, которые не могут быть запрошены.</p>

<h5><a name="idm139965278584576"></a>Пример</h5>
<p>Следующий вызов проверяет опцию <code>MYSQL_OPT_RECONNECT</code>.
После того, как вызов отработает успешно, значение <code>reconnect</code>
будет true или false, чтобы указать, включено
ли автоматическое пересоединение.

<pre>
my_bool reconnect;
if (mysql_get_option(mysql, MYSQL_OPT_RECONNECT, &amp;reconnect))
   fprintf(stderr, "mysql_get_options() failed\n");
</pre>

<h4><a name="mysql-get-proto-info"></a>25.8.7.31. mysql_get_proto_info()</h4>
<p><code>unsigned int mysql_get_proto_info(MYSQL *mysql)</code></p>
<h5><a name="idm139965278577648"></a>Описание</h5>
<p>Возвращает версию протокола, используемую текущим соединением.</p>

<h5><a name="idm139965278576480"></a>Возвращаемые значения</h5>
<p>Число типа unsigned integer, представляющее версию протокола, который
используется текущим соединением.</p>

<h5><a name="idm139965278575280"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-get-server-info"></a>25.8.7.32. mysql_get_server_info()</h4>
<p><code>const char *mysql_get_server_info(MYSQL *mysql)</code></p>
<h5><a name="idm139965278570768"></a>Описание</h5>
<p>Возвращает строку, которая представляет версию сервера MySQL, например,
<code>"8.0.1"</code>.</p>

<h5><a name="idm139965278568864"></a>Возвращаемые значения</h5>
<p>Строка символов, которая представляет версию сервера MySQL.</p>
<h5><a name="idm139965278567696"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-get-server-version"></a>25.8.7.33.
mysql_get_server_version()</h4>
<p><code>unsigned long mysql_get_server_version(MYSQL *mysql)</code></p>

<h5><a name="idm139965278563104"></a>Описание</h5>
<p>Возвращает целое число, которое представляет версию сервера MySQL. У
значения есть формат <code>XYYZZ</code>, где <code>X</code> главный номер
версия, <code>YY</code> уровень выпуска (или незначительная версия) и
<code>ZZ</code> субверсия в пределах уровня выпуска:

<pre>
major_version*10000 + release_level*100 + sub_version
</pre>

<p>Например, <code>"8.0.1"</code> возвращается как <code>80001</code>.</p>
Эта функция полезна в программах клиента для определения, существует ли
некоторая определенная для версии возможность сервера.</p>

<h5><a name="idm139965278555904"></a>Возвращаемые значения</h5>
<p>Целое число, которое представляет версию сервера MySQL.</p>
<h5><a name="idm139965278554752"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-get-ssl-cipher"></a>25.8.7.34. mysql_get_ssl_cipher()</h4>
<p><code>const char *mysql_get_ssl_cipher(MYSQL *mysql)</code></p>
<h5><a name="idm139965278550240"></a>Описание</h5>
<p><a href="#mysql-get-ssl-cipher">
<code>mysql_get_ssl_cipher()</code></a> возвращает шифр шифрования,
используемый для данного соединения с сервером. <code>mysql</code>
представляет собой обработчик соединения, возвращенный из
<a href="#mysql-init"><code>mysql_init()</code></a>.</p>

<h5><a name="idm139965278545872"></a>Возвращаемые значения</h5>
<p>Строка, называющая шифр шифрования, используемый для соединения, или
<code>NULL</code>, если никакой шифр не используется.</p>

<h4><a name="mysql-hex-string"></a>25.8.7.35. mysql_hex_string()</h4>
<p><code>unsigned long mysql_hex_string(char *to, const char *from,
unsigned long length)</code></p>

<h5><a name="idm139965278540512"></a>Описание</h5>
<p>Эта функция создает правильную строку SQL для использования в SQL-запросе.
См. <a href="lang.htm#string-literals">раздел 10.1.1.
Строки литералов</a> для подробностей.</p>

<p>Строка в параметре <code>from</code> будет закодирована в
шестнадцатеричном формате, с каждым символом, закодированным как две
шестнадцатеричных цифры. Результат помещен в параметр <code>to</code>,
сопровождаемый завершающим нулевым байтом.</p>

<p>Строка, на которую указывает <code>from</code> должна быть
<code>length</code> байт в длину. Вы должны выделить для <code>to</code>
буфер, как минимум, <code>length*2+1</code> байт длиной. Когда
<a href="#mysql-hex-string"><code>mysql_hex_string()
</code></a> сработает, в <code>to</code> будет законченная нулем строка.
Возвращаемое значение: длина закодированной строки, не включая заканчивающий
ее нулевой байт.</p>

<p>Возвращаемое значение может быть помещено в запрос SQL, используя также
формат <code>X'<em><code>value</code></em>'</code> или
<code>0x<em><code>value</code></em></code>. Однако, возвращаемое значение не
включает <code>X'...'</code> или <code>0x</code>.</p>

<h5><a name="idm139965278527152"></a>Пример</h5>
<pre>
char query[1000],*end;

end = strmov(query,"INSERT INTO test_table values(");
end = strmov(end,"X'");
end += mysql_hex_string(end,"What is this",12);
end = strmov(end,"',X'");
end += mysql_hex_string(end,"binary data: \0\r\n",16);
end = strmov(end,"')");
if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query))) {
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<p>Функция <code>strmov()</code>, используемая в примере, включена в
библиотеку <code>libmysqlclient</code> и работает как <code>strcpy()</code>,
но возвращает указатель на заканчивающий нуль первого параметра.</p>

<h5><a name="idm139965278522528"></a>Возвращаемые значения</h5>
<p>Длина закодированной строки, которая помещена в <code>to</code>,
не включая заканчивающий нулевой символ.</p>

<h5><a name="idm139965278520640"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-info"></a>25.8.7.36. mysql_info()</h4>
<p><code>const char *mysql_info(MYSQL *mysql)</code></p>
<h5><a name="idm139965278516144"></a>Описание</h5>
<p>Получает строку, предоставляющую информацию о последнем выполненном
запросе, но только для запросов, перечисленных здесь. Для других
<a href="#mysql-info"><code>mysql_info()</code></a>
вернет <code>NULL</code>. Формат строки изменяется в зависимости от типа
запроса. Числа только иллюстративны, строка содержит значения,
подходящие для запроса.</p>

<ul><li><p><a href="sql.htm#insert-select"><code>INSERT INTO
... SELECT ...</code></a></p>
<p>Формат строки: <code>Records: 100 Duplicates: 0 Warnings: 0</code></li>

<li><code>INSERT INTO ... VALUES (...),(...),(...)...</code></p>
<p>Формат строки: <code>Records: 3 Duplicates: 0 Warnings: 0</code></li>
<li><a href="sql.htm#load-data"><code>LOAD DATA INFILE ...</code></a>
</p>
<p>Формат строки: <code>Records: 1 Deleted: 0 Skipped: 0 Warnings: 0</code>
</li>

<li><a href="sql.htm#alter-table"><code>ALTER TABLE</code></a></p>
<p>Формат строки: <code>Records: 3 Duplicates: 0 Warnings: 0</code></li>
<li><a href="sql.htm#update"><code>UPDATE</code></a></p>
<p>Формат строки: <code>Rows matched: 40 Changed: 40 Warnings: 0</code>
</p></li></ul>

<p><a href="#mysql-info"><code>mysql_info()</code></a>
вернет не <code>NULL</code> для <a href="sql.htm#insert"><code>
INSERT ... VALUES</code></a> многострочной формы запроса (то есть, только
если определен список значений).</p>

<h5><a name="idm139965278493504"></a>Возвращаемые значения</h5>
<p>Строка символов о последнем выполненном запросе. <code>NULL</code>, если
никакая информация недоступна.</p>

<h5><a name="idm139965278491536"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-init"></a>25.8.7.37. mysql_init()</h4>
<p><code>MYSQL *mysql_init(MYSQL *mysql)</code></p>
<h5><a name="idm139965278487040"></a>Описание</h5>
<p>Выделяет или инициализирует объект <code>MYSQL</code>, подходящий для
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>. Если <code>mysql</code> = <code>NULL</code>, функция выделяет,
инициализирует и возвращает новый объект. Иначе, объект будет
инициализирован, а адрес объекта возвращен. Если
<a href="#mysql-init"><code>mysql_init()</code></a>
выделяет новый объект, он будет освобожден, когда
<a href="#mysql-close"><code>mysql_close()</code></a>
вызывается для закрытия соединения.</p>

<p>В непоточном окружении
<a href="#mysql-init"><code>mysql_init()</code></a>
вызывает <a href="#mysql-library-init"><code>
mysql_library_init()</code></a> автоматически по мере необходимости. Однако,
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a> не безопасна для потоков в мультипоточной среде. Перед вызовом
<a href="#mysql-init"><code>mysql_init()</code></a>
вызовите <a href="#mysql-library-init"><code>
mysql_library_init()</code></a> до порождения любых потоков или использования
mutex, чтобы защитить вызов <a href="#mysql-library-init">
<code>mysql_library_init()</code></a>. Это должно быть сделано до любого
другого вызова библиотеки клиента.</p>

<h5><a name="idm139965278470464"></a>Возвращаемые значения</h5>
<p>Инициализированный дескриптор <code>MYSQL*</code>. <code>NULL</code>,
если было недостаточно памяти, чтобы выделить новый объект.</p>
<h5><a name="idm139965278467840"></a>Ошибки</h5>
<p>В случае нехватки памяти вернется <code>NULL</code>.</p>

<h4><a name="mysql-insert-id"></a>25.8.7.38. mysql_insert_id()</h4>
<a class="indexterm" name="idm139965278464736"></a><p>
<code>my_ulonglong mysql_insert_id(MYSQL *mysql)</code></p>

<h5><a name="idm139965278462560"></a>Описание</h5>
<p>Возвращает значение, произведенное для столбца
<code>AUTO_INCREMENT</code> предыдущим запросом
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>. Используйте эту
функцию после того, как Вы применили <a href="sql.htm#insert">
<code>INSERT</code></a> к таблице, которая содержит поле
<code>AUTO_INCREMENT</code>, или использовали
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>, чтобы установить
значение столбца с <a href="funct.htm#function_last-insert-id">
<code>LAST_INSERT_ID(<em><code>expr</code></em>)</code></a>.</p>

<p>Возвращаемое значение
<a href="#mysql-insert-id">
<code>mysql_insert_id()</code></a> всегда ноль, если явно не обновлено при
одном из следующих условий:</p>

<ul><li><p>Запрос <a href="sql.htm#insert"><code>INSERT</code></a>,
который хранит значение в столбце <code>AUTO_INCREMENT</code>. Это верно в
любом случае, произведено ли значение автоматически, сохраняя специальное
значение <code>NULL</code> или <code>0</code> в столбец, или явное
не специальное значение.</li>

<li>В случае многострочного <a href="sql.htm#insert"><code>INSERT
</code></a> <a href="#mysql-insert-id"><code>
mysql_insert_id()</code></a> вернет возвращает первое, автоматически
произведенное значение <code>AUTO_INCREMENT</code>, которое
было успешно вставлено.</p>

<p>Если никакие строки успешно не вставлены,
<a href="#mysql-insert-id">
<code>mysql_insert_id()</code></a> вернет 0.</li>

<li>Если <a href="sql.htm#insert-select"><code>INSERT ... SELECT
</code></a> выполнен, и никакое автоматически произведенное значение успешно
не вставлено, <a href="#mysql-insert-id"><code>
mysql_insert_id()</code></a> вернет ID последней вставленной строки.</li>

<li>Если <a href="sql.htm#insert-select"><code>INSERT ... SELECT
</code></a> использует <a href="funct.htm#function_last-insert-id">
<code>LAST_INSERT_ID(<em><code>expr</code></em>)</code></a>,
<a href="#mysql-insert-id"><code>mysql_insert_id()</code>
</a> вернет <em><code>expr</code></em>.</li>

<li>Запросы <a href="sql.htm#insert"><code>INSERT</code></a>,
которые производят значение <code>AUTO_INCREMENT</code>, вставляя
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID(<em>
<code>expr</code></em>)</code></a> в любой столбец или обновляя любой столбец
в значение <a href="funct.htm#function_last-insert-id"><code>
LAST_INSERT_ID(<em><code>expr</code></em>)</code></a>.</li>

<li>Если предыдущий запрос возвратил ошибку, значение
<a href="#mysql-insert-id"><code>
mysql_insert_id()</code></a> неопределено.</p></li></ul>

<p>Возвращаемое значение
<a href="#mysql-insert-id"><code>mysql_insert_id()</code>
</a> может быть упрощено до следующей последовательности:</p>

<ol type="1"><li><p>Если есть столбец <code>AUTO_INCREMENT</code>, и
автоматически произведенное значение было успешно вставлено, вернет
первое такое значение.</li>

<li>Если <a href="funct.htm#function_last-insert-id"><code>
LAST_INSERT_ID(<em><code>expr</code></em>)</code></a> была в запросе, вернет
<em><code>expr</code></em>, даже если в таблице был столбец
<code>AUTO_INCREMENT</code>.</li>

<li>Возвращаемое значение изменяется в зависимости от используемого запроса.
Когда функция вызвана после <a href="sql.htm#insert"><code>INSERT
</code></a>:</p>

<ul><li><p>Если есть столбец <code>AUTO_INCREMENT</code> в таблице, и было
некоторое явное значение для этого столбца, которое было успешно вставлено в
таблицу, возвращается последнее из явных значений.</p></li></ul>

<p>Когда функция вызвана после
<a href="sql.htm#insert-on-duplicate"><code>
INSERT ... ON DUPLICATE KEY UPDATE</code></a>:</p>

<ul><li><p>Если есть столбец <code>AUTO_INCREMENT</code> в таблице, и было
некоторое явное значение для этого столбца, которое было успешно вставлено
или обновлено в таблице, возвращается последнее из явных значений.</p></li>
</ul></li></ol>

<p><a href="#mysql-insert-id"><code>mysql_insert_id()
</code></a> вернет <code>0</code>, если предыдущий запрос не использует
<code>AUTO_INCREMENT</code>. Если Вы должны сохранить значение для
последующего неспешного потребления, убедитесь, что вызвали
<a href="#mysql-insert-id"><code>mysql_insert_id()</code>
</a> сразу после запроса, который производит значение.</p>

<p>Значение <a href="#mysql-insert-id"><code>
mysql_insert_id()</code></a> затронуто только запросами, сделанными в
пределах текущего соединения клиента. Это не затронуто запросами,
сделанными другими клиентами.</p>

<p>SQL-функция <a href="funct.htm#function_last-insert-id"><code>
LAST_INSERT_ID()</code></a> будет содержать значение первого автоматически
произведенного значения, которое было успешно вставлено.
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a> не сбрасывается между запросами, потому что значение этой функции
поддерживается сервером. Другое отличие от
<a href="#mysql-insert-id"><code>mysql_insert_id()</code>
</a> в том, что
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a> не обновляется, если Вы устанавливаете столбец
<code>AUTO_INCREMENT</code> к определенному неспециальному значению.</p>

<p><a href="#mysql-insert-id"><code>mysql_insert_id()
</code></a> вернет <code>0</code> после команды
<a href="sql.htm#call"><code>CALL</code></a> для хранимой процедуры,
которая производит значение <code>AUTO_INCREMENT</code>, потому что в этом
случае <a href="#mysql-insert-id"><code>mysql_insert_id()
</code></a> относится к
<a href="sql.htm#call"><code>CALL</code></a>, а не запросу в
пределах процедуры. В пределах процедуры Вы можете использовать
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a> на уровне SQL, чтобы получить
значение <code>AUTO_INCREMENT</code>.</p>

<p>Причина различий между
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a> и <a href="#mysql-insert-id"><code>
mysql_insert_id()</code></a> в том, что
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a> удобней в скриптах, в то время как
<a href="#mysql-insert-id"><code>mysql_insert_id()</code>
</a> пытается предоставить более точную информацию о том, что происходит со
столбцом <code>AUTO_INCREMENT</code>.</p>

<h5><a name="idm139965278378224"></a>Возвращаемые значения</h5>
<p>Описаны в предыдущем обсуждении.</p>
<h5><a name="idm139965278377088"></a>Ошибки</h5>
<ul><li><p>
<a href="error.htm#error_er_auto_increment_conflict"><code>
ER_AUTO_INCREMENT_CONFLICT</code></a></p>

<p>Определенный пользователем <code>AUTO_INCREMENT</code> в нескольких
запросах <a href="sql.htm#insert"><code>INSERT</code></a>
находится в пределах диапазона между текущим значением
<code>AUTO_INCREMENT</code> и суммой текущего значения и
числа обработанных строк.</p></li></ul>

<h4><a name="mysql-kill"></a>25.8.7.39. mysql_kill()</h4>
<p><code>int mysql_kill(MYSQL *mysql, unsigned long pid)</code></p>
<h5><a name="idm139965278367152"></a>Описание</h5>
<p><code>mysql_kill()</code> устарела и будет удалена в будущей версии MySQL.
Вместо этого используйте
<a href="#mysql-query"><code>mysql_query()</code></a>
для выполнения запроса <a href="sql.htm#kill"><code>KILL</code></a>.
</p>

<p>Просит сервер уничтожить поток, определенный <code>pid</code>.</p>
<p><a href="#mysql-kill"><code>mysql_kill()</code></a>
не может обработать значения больше, чем 32 бита, но чтобы принять меры
против уничтожения неправильного потока, возвращает ошибку в случаях:</p>

<ul><li><p>Если дан ID больше, чем 32 бита,
<a href="#mysql-kill"><code>mysql_kill()</code></a>
вернет ошибку <a href="error.htm#error_cr_invalid_conn_handle">
<code>CR_INVALID_CONN_HANDLE</code></a>.</li>

<li>После того, как внутренний счетчик ID потока сервера достигает значения,
больше чем 32 бита, он возвращает ошибку
<a href="error.htm#error_er_data_out_of_range"><code>
ER_DATA_OUT_OF_RANGE</code></a> для любого вызова
<a href="#mysql-kill">
<code>mysql_kill()</code></a> и вызов терпит неудачу.</p></li></ul>

<h5><a name="idm139965278347952"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличный от нуля, если ошибка произошла./p>
<h5><a name="idm139965278346800"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_invalid_conn_handle"><code>
CR_INVALID_CONN_HANDLE</code></a></p>
<p><code>pid</code> был больше, чем 32 бита.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</li>

<li><a href="error.htm#error_er_data_out_of_range"><code>
ER_DATA_OUT_OF_RANGE</code></a></p>
<p>Внутренний счетчик ID потока сервера достиг значения больше, чем 32 бита.
</p></li></ul>

<h4><a name="mysql-library-end"></a>25.8.7.40. mysql_library_end()</h4>
<p><code>void mysql_library_end(void)</code></p>
<h5><a name="idm139965278325648"></a>Описание</h5>
<p>Эта функция завершает библиотеку MySQL. Вызовите ее, когда Вы
завершаете пользование библиотекой (например, после отсоединения от сервера).
Действия, предпринятые вызовом, зависят от того, скомпоновано ли Ваше
приложение с библиотекой клиента MySQL, или MySQL использует встроенную
библиотеку сервера. Для программы клиента, скомпонованной библиотекой
<code>libmysqlclient</code> флагом <code>-lmysqlclient</code>,
<a href="#mysql-library-end"><code>mysql_library_end()
</code></a> выполняет некоторое управление памятью, чтобы ее очистить.
Для встроенного приложения сервера, скомпонованного с библиотекой
<code>libmysqld</code> посредством флага <code>-lmysqld</code>,
<a href="#mysql-library-end"><code>mysql_library_end()
</code></a> закрывает встроенный сервер.</p>

<h4><a name="mysql-library-init"></a>25.8.7.41. mysql_library_init()</h4>
<p><code>int mysql_library_init(int argc, char **argv, char **groups)</code>
</p>

<h5><a name="idm139965278313872"></a>Описание</h5>
<p>Вызовите эту функцию, чтобы инициализировать библиотеку MySQL прежде, чем
Вы вызовете любую другую функцию MySQL и неважно, является ли Ваше приложение
обычной программой или использует встроенный сервер. Если приложение
использует встроенный сервер, это требование запускает сервер и
инициализирует любые подсистемы (<code>mysys</code>, <code>InnoDB</code> и
т.п.), которые использует сервер.</p>

<p>После того, как Ваше приложение завершило использование библиотеки MySQL,
вызовите <a href="#mysql-library-end"><code>
mysql_library_end()</code></a>.</p>

<p>Выбор того, действует ли приложение в качестве клиента или использует
встроенный сервер, зависит от того, используете ли Вы библиотеку
<code>libmysqlclient</code> или <code>libmysqld</code> во время компоновки.
</p>

<p>Аргументы <code>argc</code> и <code>argv</code> походят на параметры
<code>main()</code> и позволяют передать опции встроенному серверу. Для
удобства <code>argc</code> может быть <code>0</code>, если нет никаких
параметров командной строки серверу. Это обычный случай для приложений,
предназначенных для использования только в качестве регулярных (невстроенных)
клиентов, так что вызов обычно пишется как
<code>mysql_library_init(0, NULL, NULL)</code></a>:
<pre>
#include &lt;mysql.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
  if (mysql_library_init(0, NULL, NULL)) {
     fprintf(stderr, "could not initialize MySQL library\n");
     exit(1);
  }
  /* Use any MySQL API functions here */
  mysql_library_end();
  return EXIT_SUCCESS;
}
</pre>

<p>Когда параметры нужно передать (<code>argc</code> больше <code>0</code>),
первый элемент <code>argv</code> игнорируется (он как, правило, содержит имя
программы). <a href="#mysql-library-init"><code>
mysql_library_init()</code></a> делает копию параметров, таким образом,
безопасно разрушить <code>argv</code> или <code>groups</code> после вызова.
</p>

<p>Для встраиваемых приложений, если Вы хотите соединиться с внешним
сервером, не запуская встроенный сервер, Вы должны определить отрицательную
величину для <code>argc</code>.</p>

<p>Параметр <code>groups</code> массив строк, которые указывают на группы в
файлах опций, из которых можно считать параметры. Заключительный вход в
массиве всегда <code>NULL</code>. Для удобства если
<code>groups</code> <code>NULL</code>, группы <code>[server]</code> и
<code>[embedded]</code> используются по умолчанию.
<pre>
#include &lt;mysql.h&gt;
#include &lt;stdlib.h&gt;

static char *server_args[] = {
  "this_program", /* this string is not used */
  "--datadir=.",
  "--key_buffer_size=32M"
};

static char *server_groups[] = {"embedded", "server",
                                "this_program_SERVER",
                                (char *)NULL};

int main(void)
{
  if (mysql_library_init(sizeof(server_args) / sizeof(char *),
     server_args, server_groups)) {
     fprintf(stderr, "could not initialize MySQL library\n");
     exit(1);
  }
  /* Use any MySQL API functions here */
  mysql_library_end();
  return EXIT_SUCCESS;
}
</pre>

<h5><a name="idm139965278274192"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h4><a name="mysql-list-dbs"></a>25.8.7.42. mysql_list_dbs()</h4>
<p><code>MYSQL_RES *mysql_list_dbs(MYSQL *mysql, const char *wild)</code></p>
<h5><a name="idm139965278269616"></a>Описание</h5>
<p>Возвращает набор результатов, состоящий из имен баз данных на сервере,
которые соответствуют простому регулярному выражению, определенному
параметром <code>wild</code>. Он может содержать подстановочные символы
<code>%</code> или <code>_</code>, или может быть <code>NULL</code>, чтобы
соответствовать всем базам данных. Запрос
<a href="#mysql-list-dbs">
<code>mysql_list_dbs()</code></a> подобен выполнению запроса
<code>SHOW DATABASES [LIKE <em><code>wild</code></em>]</code>.</p>

<p>Вы должны освободить набор результатов с помощью
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a>.</p>

<h5><a name="idm139965278260672"></a>Возвращаемые значения</h5>
<p>Набор результатов <code>MYSQL_RES</code> для успеха.
<code>NULL</code>, если ошибка произошла.</p>

<h5><a name="idm139965278258096"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>
CR_SERVER_LOST</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-list-fields"></a>25.8.7.43. mysql_list_fields()</h4>
<p><code>MYSQL_RES *mysql_list_fields(MYSQL *mysql, const char *table,
const char *wild)</code></p>

<h5><a name="idm139965278241232"></a>Описание</h5>
<p><code>mysql_list_fields()</code> устарела и будет удалена в будущей версии
MySQL. Вместо этого используйте
<a href="#mysql-query"><code>mysql_query()</code></a> для
выполнения запроса <a href="sql.htm#show-columns"><code>SHOW COLUMNS
</code></a>.</p>

<p>Возвращает пустой набор результатов, для которого метаданные предоставляют
информацию о столбцах в данной таблице, которые соответствуют простому
регулярному выражению, определенному параметром <code>wild</code>. Он может
содержать подстановочные символы <code>%</code> или <code>_</code>, или может
быть <code>NULL</code>, чтобы соответствовать всем полям. Вызов
<a href="#mysql-list-fields">
<code>mysql_list_fields()</code></a> подобен выполнению запроса
<code>SHOW COLUMNS FROM <em><code>tbl_name</code></em> [LIKE
<em><code>wild</code></em>]</code>.</p>

<p>Предпочтительно использовать <code>SHOW COLUMNS FROM
<em><code>tbl_name</code></em></code> вместо
<a href="#mysql-list-fields">
<code>mysql_list_fields()</code></a>.</p>

<p>Вы должны освободить набор результатов с помощью
<a href="#mysql-free-result">
<code>mysql_free_result()</code></a>.</p>

<h5><a name="idm139965278225056"></a>Возвращаемые значения</h5>
<p>Набор результатов <code>MYSQL_RES</code> для успеха. <code>NULL</code>,
если ошибка произошла.</p>

<h5><a name="idm139965278222480"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>
CR_SERVER_LOST</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h5><a name="idm139965278211632"></a>Пример</h5>
<pre>
int i;

MYSQL_RES *tbl_cols = mysql_list_fields(mysql, "mytbl", "f%");
unsigned int field_cnt = mysql_num_fields(tbl_cols);
printf("Number of columns: %d\n", field_cnt);
for (i=0; i &lt; field_cnt; ++i) {
  /* col describes i-th column of the table */
  MYSQL_FIELD *col = mysql_fetch_field_direct(tbl_cols, i);
  printf ("Column %d: %s\n", i, col-&gt;name);
}
mysql_free_result(tbl_cols);
</pre>

<h4><a name="mysql-list-processes"></a>25.8.7.44. mysql_list_processes()</h4>
<p><code>MYSQL_RES *mysql_list_processes(MYSQL *mysql)</code></p>

<h5><a name="idm139965278206048"></a>Описание</h5>
<p><code>mysql_list_processes()</code> устарела и будет удалена в будущей
версии MySQL. Вместо нее используйте
<a href="#mysql-query"><code>mysql_query()</code></a>
для выполнения запроса <a href="sql.htm#show-processlist"><code>SHOW
PROCESSLIST</code></a>.</p>

<p>Возвращает набор результатов, описывающий текущие потоки сервера.
Это тот же самый вид информации, о котором сообщает команда
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin processlist
</strong></span></a> или запрос <a href="sql.htm#show-processlist">
<code>SHOW PROCESSLIST</code></a>.</p>

<p>Вы должны освободить набор результатов с помощью
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a>.</p>

<h5><a name="idm139965278196624"></a>Возвращаемые значения</h5>
<p>Набор результатов <code>MYSQL_RES</code> для успеха.
<code>NULL</code>, если ошибка произошла.</p>

<h5><a name="idm139965278194048"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>
CR_SERVER_LOST</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-list-tables"></a>25.8.7.45. mysql_list_tables()</h4>
<p><code>MYSQL_RES *mysql_list_tables(MYSQL *mysql, const char *wild)
</code></p>

<h5><a name="idm139965278179776"></a>Описание</h5>
<p>Возвращает набор результатов, состоящий из имен таблиц в текущей базе
данных, которые соответствуют простому регулярному выражению, определенному
параметром <code>wild</code>. Он может содержать подстановочные символы
<code>%</code> или <code>_</code>, или быть <code>NULL</code>, чтобы
соответствовать всем таблицам. Запрос
<a href="#mysql-list-tables"><code>mysql_list_tables()
</code></a> аналогичен вызову
<code>SHOW TABLES [LIKE <em><code>wild</code></em>]</code>.</p>

<p>Вы должны освободить набор результатов с помощью
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a>.</p>

<h5><a name="idm139965278170832"></a>Возвращаемые значения</h5>
<p>Набор результатов <code>MYSQL_RES</code> для успеха.
<code>NULL</code>, если ошибка произошла.</p>

<h5><a name="idm139965278168256"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-more-results"></a>25.8.7.46. mysql_more_results()</h4>
<p><code>my_bool mysql_more_results(MYSQL *mysql)</code></p>
<h5><a name="idm139965278154000"></a>Описание</h5>
<p>Эта функция используется, когда Вы выполняете много запросов, определенных
как единственная строка, или когда Вы выполняете запросы
<a href="sql.htm#call"><code>CALL</code></a>, которые могут
возвратить несколько наборов результатов.</p>

<p><a href="#mysql-more-results"><code>
mysql_more_results()</code></a> истина, если несколько результатов поступает
из выполняемого в настоящее время запроса, в этой ситуации приложение должно
вызывать <a href="#mysql-next-result"><code>
mysql_next_result()</code></a> для получения результатов.</p>

<h5><a name="idm139965278148512"></a>Возвращаемые значения</h5>
<p><code>TRUE</code> (1), если существует много результатов.
<code>FALSE</code> (0), если это не так.</p>

<p>В большинстве случаев Вы можете вместо этого вызвать
<a href="#mysql-next-result"><code>mysql_next_result()
</code></a>, чтобы проверить, существует ли больше результатов и начать
их извлечение, если они есть.</p>

<h5><a name="idm139965278142448"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-next-result"></a>25.8.7.47. mysql_next_result()</h4>
<p><code>int mysql_next_result(MYSQL *mysql)</code></p>
<h5><a name="idm139965278137952"></a>Описание</h5>
<p>Эта функция используется, когда Вы выполняете много запросов, определенных
как единственная строка, или когда Вы используете запрос
<a href="sql.htm#call"><code>CALL</code></a>, чтобы выполнить
хранимые процедуры, которые могут возвратить много наборов результатов.</p>

<p><a href="#mysql-next-result"><code>
mysql_next_result()</code></a> читает следующий результат и возвращает
состояние, чтобы указать, существуют ли еще результаты. Если
<a href="#mysql-next-result"><code>mysql_next_result()
</code></a> возвращает ошибку, результатов больше нет.</p>

<p>Перед каждым вызовом
<a href="#mysql-next-result">
<code>mysql_next_result()</code></a> Вы должны вызвать
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a> для текущего запроса, если этот запрос вернул набор результатов
(а не только состояние результата).</p>

<p>После вызова <a href="#mysql-next-result">
<code>mysql_next_result()</code></a> состояние соединения как будто Вы
вызвали <a href="#mysql-real-query"><code>
mysql_real_query()</code></a> или <a href="#mysql-query">
<code>mysql_query()</code></a> для следующего запроса. Это означает, что Вы
можете вызывать <a href="#mysql-store-result"><code>
mysql_store_result()</code></a>,
<a href="#mysql-warning-count">
<code>mysql_warning_count()</code></a>,
<a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a> и т. п.</p>

<p>Если Ваша программа использует вызов <a href="sql.htm#call"><code>
CALL</code></a>, чтобы выполнить хранимые процедуры, флаг
<code>CLIENT_MULTI_RESULTS</code> должен быть включен. Это потому, что каждый
<a href="sql.htm#call"><code>CALL</code></a> возвращает результат,
чтобы указать на состояние, в дополнение к любым наборам результатов, которые
могли бы быть возвращены запросами, выполненными в пределах процедуры.
Поскольку <a href="sql.htm#call"><code>CALL</code></a>
может возвращать много наборов результатов, обработайте их вызывая в цикле
<a href="#mysql-next-result">
<code>mysql_next_result()</code></a>, чтобы определить, есть
ли еще результаты.</p>

<p><code>CLIENT_MULTI_RESULTS</code> может быть включен явно, когда Вы
вызываете <a href="#mysql-real-connect"><code>
mysql_real_connect()</code></a>, передавая флаг непосредственно, или неявно
передачей флага <code>CLIENT_MULTI_STATEMENTS</code> (который также включает
<code>CLIENT_MULTI_RESULTS</code>). <code>CLIENT_MULTI_RESULTS</code>
включен по умолчанию.</p>

<p>Также возможно проверить, есть ли больше результатов, вызывая
<a href="#mysql-more-results"><code>mysql_more_results()
</code></a>. Однако, эта функция не изменяет статус соединения, так что, если
это возвращает истину, Вы все еще должны вызвать
<a href="#mysql-next-result"><code>mysql_next_result()
</code></a>, чтобы добраться до следующего результата.</p>

<h5><a name="idm139965278104240"></a>Возвращаемые значения</h5>
<table border="1">
<thead><tr><th scope="col">Возвращаемое значение</th><th scope="col">Описание
</th></tr></thead>
<tbody><tr><td scope="row">0</td><td>Успешно и есть еще результаты</td></tr>
<tr><td scope="row">-1</td>Успешно, но больше результатов нет</td></tr>
<tr><td scope="row">&gt;0</td><td>Ошибка произошла</td></tr></tbody></table>

<h5><a name="idm139965278093840"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке. Например, если Вы не
вызвали <a href="#mysql-use-result"><code>
mysql_use_result()</code></a> для предыдущего набора результатов.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-num-fields"></a>25.8.7.48. mysql_num_fields()</h4>
<p><code>unsigned int mysql_num_fields(MYSQL_RES *result)</code></p>
<p>Чтобы применить аргумент <code>MYSQL*</code>, используйте
<code>unsigned int mysql_field_count(MYSQL *mysql)</code>.</p>

<h5><a name="idm139965278075344"></a>Описание</h5>
<p>Возвращает число столбцов в наборе результатов. Вы можете получить число
столбцов по указателю на набор результатов или по дескриптору соединения.
Вы использовали бы дескриптор соединения, если
<a href="#mysql-store-result">
<code>mysql_store_result()</code></a> или
<a href="#mysql-use-result">
<code>mysql_use_result()</code></a> возвращает <code>NULL</code>
(и таким образом у Вас нет указателя на набор результатов). В этом случае Вы
можете вызвать <a href="#mysql-field-count"><code>
mysql_field_count()</code></a> и определить, должен ли был
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> привести к непустому результату. Это позволяет программе клиента
предпринять надлежащие меры, не зная, был ли запрос
<a href="sql.htm#select"><code>SELECT</code></a> (или подобный).
Пример, показанный здесь, иллюстрирует, как это может быть сделано.</p>

<h5><a name="idm139965278064112"></a>Возвращаемые значения</h5>
<p>Число типа unsigned integer, представляющее числ
о столбцов в наборе результатов.</p>

<h5><a name="idm139965278062928"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965278061824"></a>Пример</h5>
<pre>
MYSQL_RES *result;
unsigned int num_fields;
unsigned int num_rows;

if (mysql_query(&amp;mysql,query_string)) {
   // error
}
else // query succeeded, process any data returned by it
{
  result = mysql_store_result(&amp;mysql);
  if (result)  // there are rows {
     num_fields = mysql_num_fields(result);
     // retrieve rows, then call mysql_free_result(result)
  }
  else  // mysql_store_result() returned nothing; should it have?
  {
    if (mysql_errno(&amp;mysql)) {
       fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
    }
    else if (mysql_field_count(&amp;mysql) == 0) {
      // query does not return data
      // (it was not a SELECT)
      num_rows = mysql_affected_rows(&amp;mysql);
    }
  }
}
</pre>

<p>Альтернатива (если Вы знаете, что Ваш запрос должен был возвратить набор
результатов): заменить на вызов
<a href="#mysql-errno"><code>
mysql_errno(&amp;mysql)</code></a> с проверкой на то, что
<a href="#mysql-field-count"><code>
mysql_field_count(&amp;mysql)</code></a> возвращает 0. Это происходит, только
если что-то пошло не так, как надо.</p>

<h4><a name="mysql-num-rows"></a>25.8.7.49. mysql_num_rows()</h4>
<p><code>my_ulonglong mysql_num_rows(MYSQL_RES *result)</code></p>
<h5><a name="idm139965278052640"></a>Описание</h5>
<p>Возвращает число строк в наборе результатов.</p>

<p>Использование <a href="#mysql-num-rows">
<code>mysql_num_rows()</code></a> зависит от того, используете ли Вы
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> или <a href="#mysql-use-result"><code>
mysql_use_result()</code></a>, чтобы получить набор результатов. Если Вы
используете <a href="#mysql-store-result"><code>
mysql_store_result()</code></a>,
<a href="#mysql-num-rows"><code>mysql_num_rows()</code>
</a> может быть немедленно вызван. Если Вы используете
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a>, <a href="#mysql-num-rows"><code>
mysql_num_rows()</code></a> не возвращает правильное значение, пока все
строки в наборе результатов не будут получены.</p>

<p><a href="#mysql-num-rows"><code>mysql_num_rows()
</code></a> предназначен для использования с запросами, которые возвращают
набор результатов, таких как <a href="sql.htm#select"><code>SELECT
</code></a>. Для запросов наподобие
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>, число затронутых
строк может быть получено с помощью
<a href="#mysql-affected-rows"><code>
mysql_affected_rows()</code></a>.</p>

<h5><a name="idm139965278034352"></a>Возвращаемые значения</h5>
<p>Число строк в наборе результатов.</p>
<h5><a name="idm139965278033216"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-options"></a>25.8.7.50. mysql_options()</h4>
<p><code>int mysql_options(MYSQL *mysql, enum mysql_option option,
const void *arg)</code></p>

<h5><a name="idm139965278028672"></a>Описание</h5>
<p>Может использоваться, чтобы установить дополнительные опции соединения и
затрагивает поведение соединения. Эта функция может быть вызвана многократно,
чтобы установить несколько опций. Чтобы получить значения опции, используйте
<a href="#mysql-get-option"><code>mysql_get_option()
</code></a>.</p>

<p>Вызывайте <a href="#mysql-options"><code>
mysql_options()</code></a> после <a href="#mysql-init">
<code>mysql_init()</code></a>, но перед
<a href="#mysql-connect"><code>mysql_connect()</code></a>
или <a href="#mysql-real-connect"><code>
mysql_real_connect()</code></a>.</p>

<p>Аргумент <code>option</code> это опция, которую Вы хотите установить.
Параметр <code>arg</code> значение для опции. Если опция целое число,
определите указатель на значение целого числа как <code>arg</code>.</p>

<p>Следующий список описывает возможные варианты опций, их эффект, и как
<code>arg</code> используется для каждой опции. Несколько из опций
применяются только, когда приложение скомпоновано со встроенной библиотекой
сервера <code>libmysqld</code> и неприменима для приложений, скомпонованных с
библиотекой клиента <code>libmysqlclient</code>. Для описаний опции, которые
указывают, что <code>arg</code> не использован, его значение не важно, обычно
это 0 для правильного вызова функции.</p>

<ul><li><p><code>MYSQL_DEFAULT_AUTH</code> (argument type:
<code>char *</code>)</p>
<p>Название используемого плагина аутентификации.</li>

<li><code>MYSQL_ENABLE_CLEARTEXT_PLUGIN</code> (argument type:
<code>my_bool *</code>)</p>
<p>Включает плагин аутентификации открытым текстом
<code>mysql_clear_password</code>.</li>

<li><code>MYSQL_INIT_COMMAND</code> (argument type:
<code>char *</code>)</p>
<p>SQL-команда, которую надо выполнить, соединяясь с сервером MySQL.
Автоматически повторно выполнена, если пересоединение происходит.</li>

<li><code>MYSQL_OPT_BIND</code> (argument: <code>char *</code>)</p>
<p>Сетевой интерфейс, с которого можно соединиться с сервером. Это
используется, когда у хоста клиента есть много сетевых интерфейсов. Параметр
задает имя хоста или IP-адрес (определенный как строка).</li>

<li><code>MYSQL_OPT_CAN_HANDLE_EXPIRED_PASSWORDS</code>
(argument type: <code>my_bool *</code>)</p>
<p>Указывает, может ли клиент обработать истекшие пароли.</li>

<li><code>MYSQL_OPT_COMPRESS</code> (arg не используется)</p>
<p>Использовать сжатый протокол клиент-сервер.</li>
<li><code>MYSQL_OPT_CONNECT_ATTR_DELETE</code> (argument type:
<code>char *</code>)</p>
<p>Учитывая имя ключа, эта опция удаляет пару ключ/значение из текущего
набора признаков соединения, передаваемых серверу во время соединения.
Параметр указатель на законченную нулем строку с именем ключа. Сравнение
ключевого имени с существующими ключами является чувствительным к регистру.
</p>

<p>Исполнительная схема выставляет признаки соединения через таблицы
<a href="perfor.htm#session-connect-attrs-table"><code>
session_connect_attrs</code></a> и
<a href="perfor.htm#session-account-connect-attrs-table">
<code>session_account_connect_attrs</code></a>.</li>

<li><code>MYSQL_OPT_CONNECT_ATTR_RESET</code> (arg не используется)</p>
<p>Эта опция сбрасывает (очищает) текущий набор признаков соединения.</li>
<li><code>MYSQL_OPT_CONNECT_TIMEOUT</code> (argument type:
<code>unsigned int *</code>)</p>
<p>Тайм-аут соединения в секундах.</li>

<li><code>MYSQL_OPT_GUESS_CONNECTION</code> (arg не используется)</p>
<p>Для приложения скомпонованного с библиотекой <code>libmysqld</code>,
это позволяет библиотеке выбрать, использовать встроенный
или удаленный сервер. <span>Guess</span> означает что, если имя хоста
установлено и не <code>localhost</code>, используется удаленный сервер. Это
поведение по умолчанию. <code>MYSQL_OPT_USE_EMBEDDED_CONNECTION</code> и
<code>MYSQL_OPT_USE_REMOTE_CONNECTION</code> могут использоваться, чтобы
переопределить его. Эта опция проигнорирована для приложений, скомпонованных
с клиентской библиотекой <code>libmysqlclient</code>.</li>

<li><code>MYSQL_OPT_LOCAL_INFILE</code> (argument type: указатель на
<code>unsigned int</code>)</p>
<p>Если указатель не задан или если он указывает на
<code>unsigned int</code> с ненулевым значением, то разрешена команда
<a href="sql.htm#load-data"><code>LOAD DATA LOCAL INFILE</code></a>.
</li>

<li><code>MYSQL_OPT_MAX_ALLOWED_PACKET</code> (argument:
<code>unsigned long *</code>)</p>
<p>Эта опция устанавливает системную переменную
<a href="server.htm#sysvar_max_allowed_packet">
<code>max_allowed_packet</code></a>. Если параметр <code>mysql</code> не
<code>NULL</code>, вызов устанавливает значение переменной для этого сеанса.
Если <code>mysql</code> = <code>NULL</code>, вызов устанавливает глобальное
значение системной переменной.</li>

<li><code>MYSQL_OPT_NAMED_PIPE</code> (arg не используется)</p>
<p>Использовать именованный канал, чтобы соединиться с сервером MySQL под
Windows, если сервер разрешает такие соединения.</li>

<li><code>MYSQL_OPT_NET_BUFFER_LENGTH</code> (arg:
<code>unsigned long *</code>)</p>
<p>Эта опция устанавливает системную переменную
<a href="server.htm#sysvar_net_buffer_length">
<code>net_buffer_length</code></a>. Если параметр <code>mysql</code> не
<code>NULL</code>, вызов устанавливает значение переменной для этого сеанса.
Если <code>mysql</code> = <code>NULL</code>, вызов устанавливает глобальное
значение системной переменной.</li>

<li><code>MYSQL_OPT_PROTOCOL</code> (argument type:
<code>unsigned int *</code>)</p>
<p>Тип протокола, чтобы использовать. Определите одно из enum значений
<code>mysql_protocol_type</code>, определенных в <code>mysql.h</code>.</li>

<li><code>MYSQL_OPT_READ_TIMEOUT</code> (argument type:
<code>unsigned int *</code>)</p>
<p>Тайм-аут в секундах для каждой попытки читать с сервера. В случае
необходимости есть повторения, таким образом, полное эффективное значение
тайм-аута: три раза значение опции. Вы можете установить значение так, чтобы
потерянное соединение могло быть обнаружено ранее значения TCP/IP
<code>Close_Wait_Timeout</code> (10 минут).</li>

<li><code>MYSQL_OPT_RECONNECT</code> (argument type:
<code>my_bool *</code>)</p>
<p>Включает или отключает автоматическое пересоединение с сервером, если
соединение было потеряно. Повторное соединение задано по умолчанию, эта опция
обеспечивает способ установить поведение пересоединения явно.</li>

<li><code>MYSQL_OPT_RETRY_COUNT</code> (argument type:
<code>unsigned int *</code>)</p>
<p>Счетчик повторных попыток для системных вызовов I/O, которые прерваны при
соединении или общении с сервером. Значение по умолчанию 1 (1 повтор).</li>

<li><code>MYSQL_OPT_SSL_CA</code> (argument type:
<code>char *</code>)</p>
<p>Путь к файлу в формате PEM, который содержит список доверенных SSL CA.
</li>

<li><code>MYSQL_OPT_SSL_CAPATH</code> (argument type:
<code>char *</code>)</p>
<p>Путь к каталогу, который содержит сертификаты доверенных SSL
CA в формате PEM.</li>

<li><code>MYSQL_OPT_SSL_CERT</code> (argument type: <code>char *</code>)</p>
<p>Имя файла сертификата SSL в формате PEM, чтобы использовать для
создания безопасного соединения.</li>

<li><code>MYSQL_OPT_SSL_CIPHER</code> (argument type: <code>char *</code>)
</p>
<p>Список допустимых шифров, чтобы использовать для шифрования SSL.</li>

<li><code>MYSQL_OPT_SSL_CRL</code> (argument type: <code>char *</code>)</p>
<p>Путь к файлу, содержащему список аннулированных
сертификатов в формате PEM.</li>

<li><code>MYSQL_OPT_SSL_CRLPATH</code> (argument type: <code>char *</code>)
</p>
<p>Путь к каталогу с файлами аннулированных сертификатов в формате PEM.</li>

<li><code>MYSQL_OPT_SSL_KEY</code> (argument type: <code>char *</code>)</p>
<p>Имя файла SSL-ключа в формате PEM для создания безопасного соединения.
</li>

<li><code>MYSQL_OPT_SSL_MODE</code> (argument type:
<code>unsigned int *</code>)</p>
<p>Статус безопасности, чтобы использовать для соединения с сервером:
<code>SSL_MODE_DISABLED</code>, <code>SSL_MODE_PREFERRED</code>,
<code>SSL_MODE_REQUIRED</code>, <code>SSL_MODE_VERIFY_CA</code>,
<code>SSL_MODE_VERIFY_IDENTITY</code>. По умолчанию
<code>SSL_MODE_PREFERRED</code>. Эти режимы определяют разрешенные значения
<code>mysql_ssl_mode</code>, определенные в <code>mysql.h</code>.</li>

<li><code>MYSQL_OPT_TLS_VERSION</code> (argument type: <code>char *</code>)
</p>
<p>Протоколы, разрешенные клиентом для зашифрованных соединений. Значение
представляет собой список разделенных запятой значений, содержащий одно или
более имен протокола. Протоколы, которые могут быть названы по имени в этой
опции, зависят от библиотеки SSL, использовавшейся, чтобы собрать MySQL.</li>

<li><code>MYSQL_OPT_USE_EMBEDDED_CONNECTION</code> (arg не используется)</p>
<p>Для приложения скомпонованного с <code>libmysqld</code>, это вызывает
использование встроенного сервера для соединения. Эта опция проигнорирована
для приложений скомпонованных с библиотекой <code>libmysqlclient</code>.</li>

<li><code>MYSQL_OPT_USE_REMOTE_CONNECTION</code> (arg не используется)</p>
<p>Для приложения скомпонованного с <code>libmysqld</code>, это вызывает
использование удаленного сервера для соединения. Эта опция проигнорирована
для приложений скомпонованных с библиотекой <code>libmysqlclient</code>.</li>

<li><code>MYSQL_OPT_USE_RESULT</code> (arg не используется)</p>
<p>Опция не используется.</li>
<li><code>MYSQL_OPT_WRITE_TIMEOUT</code> (argument type:
<code>unsigned int *</code>)</p>
<p>Тайм-аут в секундах для каждой попытки писать данные на сервер. В случае
необходимости есть повторная попытка, таким образом, полное эффективное
значение тайм-аута в два раза превышает значения опции.</li>

<li><code>MYSQL_PLUGIN_DIR</code> (argument type: <code>char *</code>)</p>
<p>Каталог, в котором нужно искать плагины клиента.</li>
<li><code>MYSQL_READ_DEFAULT_FILE</code> (argument type: <code>char *</code>)
</p>
<p>Считывать опции из названного файла опций вместо <code>my.cnf</code>.</li>

<li><code>MYSQL_READ_DEFAULT_GROUP</code> (argument type:
<code>char *</code>)</p>
<p>Считывать опции из названной группы <code>my.cnf</code> или файла,
указанного в опции <code>MYSQL_READ_DEFAULT_FILE</code>.</li>

<li><code>MYSQL_REPORT_DATA_TRUNCATION</code> (argument type:
<code>my_bool *</code>)</p>
<p>Включает или отключает сообщение об ошибке усечения данных для готовых
запросов, используя член <code>error</code> структуры <code>MYSQL_BIND</code>.
Значение по умолчанию: включено.</li>

<li><code>MYSQL_SECURE_AUTH</code> (argument type:
<code>my_bool *</code>)</p>
<p>Соединиться ли с сервером, который не поддерживает хеширование паролей,
используемое в MySQL 4.1.1 и позже. Эта опция включена по умолчанию.</li>

<li><code>MYSQL_SERVER_PUBLIC_KEY</code> (argument type:
<code>char *</code>)</p>
<p>Путь к файлу, содержащему открытый ключ RSA сервера. Файл должен быть в
формате PEM. Открытый ключ используется для шифрования RSA-пароля клиента для
соединений с сервером, сделанных, используя учетные записи, которые
подтверждают подлинность с плагином <code>sha256_password</code>. Эта опция
проигнорирована для учетных записей клиента, которые не подтверждают
подлинность с этим плагином. Это также проигнорировано, если шифрование
пароля не необходимо, как имеет место, когда клиент соединяется с сервером,
используя соединение SSL.</p></li>

<li><code>MYSQL_SET_CHARSET_DIR</code> (argument type:
<code>char *</code>)</p>
<p>Путь к каталогу, который содержит файлы определения набора символов.</li>

<li><code>MYSQL_SET_CHARSET_NAME</code> (argument type: <code>char *</code>)
</p>
<p>Название набора символов, чтобы использовать в качестве набора символов
по умолчанию. Параметр может быть
<code>MYSQL_AUTODETECT_CHARSET_NAME</code>, чтобы набор символов был
установлен автоматически, исходя из настроек ОС.</li>

<li><code>MYSQL_SET_CLIENT_IP</code> (argument type: <code>char *</code>)</p>
<p>Для приложения скомпонованного с <code>libmysqld</code>, (когда
<code>libmysqld</code> собрана с поддержкой аутентификации), это означает,
что пользователь соединился с указанного IP-адреса (определенного как строка)
в целях аутентификации. Эта опция проигнорирована для приложений
скомпонованных с библиотекой <code>libmysqlclient</code>.</li>

<li><code>MYSQL_SHARED_MEMORY_BASE_NAME</code> (argument type:
<code>char *</code>)</p>
<p>Название объекта совместно используемой памяти для коммуникации с сервером
под Windows, если сервер поддерживает соединения совместно используемой
памяти. Определите то же самое значение, что и в опции
<a href="server.htm#option_mysqld_shared-memory-base-name">
<code>--shared-memory-base-name</code></a> для сервера
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>, с
которым Вы хотите соединиться.</p></li></ul>

<p>Группа <code>client</code> всегда читается, если Вы используете
<code>MYSQL_READ_DEFAULT_FILE</code> или
<code>MYSQL_READ_DEFAULT_GROUP</code>.</p>

<p>Указанная группа в файле опции может содержать следующие опции.</p>
<table border="1">
<thead><tr><th scope="col">Опция</th><th scope="col">Описание</th></tr>
</thead>
<tbody><tr><td scope="row"><code>character-sets-dir=<em><code>dir_name</code>
</em></code></td><td>Каталог, где наборы символов установлены.</td></tr>
<tr><td scope="row"><code>compress</code></td>
<td>Использовать сжатый протокол клиент-сервер.</td></tr>
<tr><td scope="row"><code>connect-timeout=<em><code>seconds</code></em>
</code></td>
<td>Тайм-аут соединения в секундах. На Linux этот тайм-аут также используется
для того, чтобы ждать первого ответа от сервера.</td></tr>
<tr><td scope="row"><code>database=<em><code>db_name</code></em></code></td>
<td>Соединиться с этой базой данных, если никакая база данных не была
определена в команде соединения.</td></tr>
<tr><td scope="row"><code>debug</code></td><td>Опции отладки.</td></tr>
<tr><td scope="row"><code>default-character-set=<em><code>charset_name</code>
</em></code></td>
<td>Набор символов, чтобы использовать по умолчанию.</td></tr>
<tr><td scope="row"><code>disable-local-infile</code></td>
<td>Отключить использование <a href="sql.htm#load-data"><code>LOAD
DATA LOCAL INFILE</code></a>.</td></tr>
<tr><td scope="row"><code>enable-cleartext-plugin</code></td>
<td>Включить плагин <code>mysql_clear_password</code>.</td></tr>
<tr><td scope="row"><code>host=<em><code>host_name</code></em></code></td>
<td>Имя хоста по умолчанию.</td></tr>
<tr><td scope="row"><code>init-command=<em><code>stmt</code></em></code></td>
<td>Запрос, который надо выполнить, соединяясь с сервером MySQL.
Автоматически повторно выполнен, если пересоединение происходит.</td></tr>
<tr><td scope="row"><code>interactive-timeout=<em><code>seconds</code></em>
</code></td><td>Аналогично указанию <code>CLIENT_INTERACTIVE</code> в
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>.</td></tr>
<tr><td scope="row"><code>local-infile[={0|1}]</code></td>
<td>Если никакой параметр не задан или параметр отличен от нуля, включить
использование <a href="sql.htm#load-data"><code>LOAD DATA LOCAL
</code></a>, иначе выключить.</td></tr>
<tr><td scope="row"><code>max_allowed_packet=<em><code>bytes
</code></em></code></td>
<td>Максимальный размер пакета, который клиент может считать с сервера.</td>
</tr>
<tr><td scope="row"><code>multi-queries</code>, <code>multi-results</code>
</td><td>Разрешить множественные наборы результатов для запросов или хранимых
процедур.</td></tr>
<tr><td scope="row"><code>multi-statements</code></td>
<td>Позволить клиенту посылать много запросов в единственной строке
(отделенных символом <code>;</code>).</td></tr>
<tr><td scope="row"><code>password=<em><code>password</code></em></code></td>
<td>Пароль по умолчанию.</td></tr>
<tr><td scope="row"><code>pipe</code></td>
<td>Использовать именованные каналы, чтобы соединиться с сервером MySQL под
Windows.</td></tr>
<tr><td scope="row"><code>port=<em><code>port_num</code></em></code></td>
<td>Порт по умолчанию.</td></tr>
<tr><td scope="row"><code>protocol={TCP|SOCKET|PIPE|MEMORY}</code></td>
<td>Протокол, чтобы использовать, соединяясь с сервером.</td></tr>
<tr><td scope="row"><code>return-found-rows</code></td>
<td>Предписывает <a href="#mysql-info"><code>mysql_info()
</code> вернуть число найденных строк вместо обновленных строк, используя
<a href="sql.htm#update"><code>UPDATE</code></a>.</td></tr>
<tr><td scope="row"><code>shared-memory-base-name=<em><code>name</code></em>
</code></td><td>Имя совместно используемой памяти, чтобы соединиться с
сервером.</td></tr>
<tr><td scope="row"><code>socket={<em><code>file_name</code></em>|<em><code>
pipe_name</code></em>}</code></td><td>Файл сокета по умолчанию.</td></tr>
<tr><td scope="row"><code>ssl-ca=<em><code>file_name</code></em></code></td>
<td>Файл центра сертификации.</td></tr>
<tr><td scope="row"><code>ssl-capath=<em><code>dir_name</code>
</em></code></td>
<td>Каталог центра сертификации.</td></tr>
<tr><td scope="row"><code>ssl-cert=<em><code>file_name</code></em></code>
</td><td>Файл сертификата.</td></tr>
<tr><td scope="row"><code>ssl-cipher=<em><code>cipher_list</code>
</em></code></td><td>Допустимые шифры SSL.</td></tr>
<tr><td scope="row"><code>ssl-key=<em><code>file_name</code></em></code></td>
<td>Файл ключа.</td></tr>
<tr><td scope="row"><code>timeout=<em><code>seconds</code></em></code></td>
<td>Аналогично <code>connect-timeout</code>.</td></tr>
<tr><td scope="row"><code>user</code></td><td>Пользователь по умолчанию.
</td></tr></tbody></table>
<p><code>timeout</code> был заменен <code>connect-timeout</code>, но
<code>timeout</code> все еще поддержан для обратной совместимости.</p>

<h5><a name="idm139965277771904"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличное от нуля, если Вы определяете неизвестную опцию.
</p>

<h5><a name="idm139965277770736"></a>Пример</h5>
<p>Следующий вызов <a href="#mysql-options"><code>
mysql_options()</code></a> предписывает использование сжатия в протоколе
клиент-сервер, заставляет считать опции из группы <code>[odbc]</code>
файла опций <code>my.cnf</code> и отключает режим autocommit:
<pre>
MYSQL mysql;

mysql_init(&amp;mysql);
mysql_options(&amp;mysql,MYSQL_OPT_COMPRESS,0);
mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,"odbc");
mysql_options(&amp;mysql,MYSQL_INIT_COMMAND,"SET autocommit=0");
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",
    0,NULL,0)) {
   fprintf(stderr, "Failed to connect to database: Error: %s\n",
   mysql_error(&amp;mysql));
}
</pre>

<h4><a name="mysql-options4"></a>25.8.7.51. mysql_options4()</h4>
<p><code>int mysql_options4(MYSQL *mysql, enum mysql_option option,
const void *arg1, const void *arg2)</code></p>

<h5><a name="idm139965277760848"></a>Описание</h5>
<p><a href="#mysql-options4"><code>mysql_options4()
</code></a> подобен <a href="#mysql-options"><code>
mysql_options()</code></a>, но имеет дополнительный четвертый параметр, чтобы
два значения можно было передать для опции, определенной во втором параметре.
</p>

<p>Следующий список описывает разрешенные опции, их эффект и то, как
использовать <code>arg1</code> и <code>arg2</code>.</p>
<ul><li><p><code>MYSQL_OPT_CONNECT_ATTR_ADD</code> (argument types:
<code>char *, char *</code>)</p>

<p>Эта опция добавляет пару ключ/значение к текущему набору атрибутов
соединения во время соединения. Оба параметра указатели на законченные нулем
строки. Первые и вторые строки указывают на ключ и значение, соответственно.
Если ключ пуст или уже существует в текущем наборе признаков соединения,
происходит ошибка. Сравнение ключевого имени с существующими ключами
является чувствительным к регистру.</p>

<p>Ключевые имена, которые начинаются с подчеркивания (<code>_</code>),
зарезервированы для внутреннего использования и не должны быть созданы
приложениями. Это соглашение разрешает новым признакам быть введенными MySQL,
не сталкиваясь с признаками приложения.</p>

<p><a href="#mysql-options4"><code>mysql_options4()
</code></a> налагает предел в 64 КБ на совокупный размер данных о признаке
соединения. Для запросов, превышающих этот предел, происходит ошибка
<a href="error.htm#error_cr_invalid_parameter_no"><code>
CR_INVALID_PARAMETER_NO</code></a>. Проверка предела размера признака также
происходит на стороне сервера.</p></li></ul>

<h5><a name="idm139965277740496"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличный от нуля, если Вы определяете неизвестную опцию.
</p>

<h5><a name="idm139965277739328"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_duplicate_connection_attr">
<code>CR_DUPLICATE_CONNECTION_ATTR</code></a></p>
<p>Был определен дубликат имени атрибута.</li>

<li><a href="error.htm#error_cr_invalid_parameter_no"><code>
CR_INVALID_PARAMETER_NO</code></a></p>
<p>Ключевое имя было пустое, или количество данных о признаке соединения
превышает предел 64 КБ.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</p></li></ul>

<h5><a name="idm139965277730736"></a>Пример</h5>
<p>Этот пример демонстрирует требования, которые
определяют признаки соединения:
<pre>
MYSQL mysql;

mysql_init(&amp;mysql);
mysql_options(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_RESET, 0);
mysql_options4(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key1", "value1");
mysql_options4(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key2", "value2");
mysql_options4(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_ADD, "key3", "value3");
mysql_options(&amp;mysql,MYSQL_OPT_CONNECT_ATTR_DELETE, "key1");
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",0,NULL,0))
{
    fprintf(stderr, "Failed to connect to database: Error: %s\n",
  mysql_error(&amp;mysql));
}
</pre>

<h4><a name="mysql-ping"></a>25.8.7.52. mysql_ping()</h4>
<p><code>int mysql_ping(MYSQL *mysql)</code></p>
<h5><a name="idm139965277724912"></a>Описание</h5>
<p>Проверяет, работает ли соединение с сервером. Если соединение прервано и
включено автоматическое пересоединение, будет предпринята попытка повторно
соединиться. Если соединение прервано, но автоматическое пересоединение
выключено, <a href="#mysql-ping"><code>mysql_ping()
</code></a> вернет ошибку.</p>

<p>Автоматическое пересоединение по умолчанию выключено. Чтобы включить,
вызовите <a href="#mysql-options"><code>mysql_options()
</code></a> с опцией <code>MYSQL_OPT_RECONNECT</code>.</p>

<p><a href="#mysql-ping"><code>mysql_ping()</code></a>
может использоваться клиентами, которые остаются неактивными долгое время,
чтобы проверить, закрыл ли сервер соединение и повторно соединиться
с ним в случае необходимости.</p>

<p>Если <a href="#mysql-ping"><code>mysql_ping()</code>
</a> действительно вызывает повторно соединение, нет никакого явного признака
этого. Чтобы определить, происходит ли повторно соединение, вызовите
<a href="#mysql-thread-id"><code>mysql_thread_id()</code>
</a>, чтобы получить оригинальный идентификатор соединения перед запросом
<a href="#mysql-ping"><code>mysql_ping()</code></a>, а
потом вызовите <a href="#mysql-thread-id"><code>
mysql_thread_id()</code></a> снова, чтобы увидеть, изменился ли
идентификатор. Если повторное соединение происходит, некоторые его
характеристики соединения будут сброшены.</p>

<h5><a name="idm139965277710640"></a>Возвращаемые значения</h5>
<p>Ноль, если соединение с сервером является активным. Отличное от нуля, если
ошибка произошла. Возвращение отличное от нуля не указывает проблему с
сервером: соединение может быть потеряно по другим причинам, таким как
сетевые проблемы, например.</p>

<h5><a name="idm139965277709280"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-query"></a>25.8.7.53. mysql_query()</h4>
<p><code>int mysql_query(MYSQL *mysql, const char *stmt_str)</code></p>
<h5><a name="idm139965277697456"></a>Описание</h5>
<p>Выполняет запрос SQL, на который указывает законченная нулем строка
<code>stmt_str</code>. Обычно строка должна состоять из единственного запроса
SQL без заканчивающей точки с запятой (<code>;</code>) или <code>\g</code>.
Если выполнение многих запросов было включено, строка может содержать
несколько запросов, отделенных точками с запятой.</p>

<p><a href="#mysql-query"><code>mysql_query()</code></a>
не может использоваться для запросов, которые содержат двоичные данные. Вы
должны использовать <a href="#mysql-real-query"><code>
mysql_real_query()</code></a>. Двоичные данные могут содержать символ
<code>\0</code>, который <a href="#mysql-query"><code>
mysql_query()</code></a> интерпретирует как конец строки.</p>

<p>Если Вы хотите знать, возвращает ли запрос набор результатов, Вы можете
использовать <a href="#mysql-field-count"><code>
mysql_field_count()</code></a>.</p>

<h5><a name="idm139965277685952"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277684800"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>
CR_SERVER_LOST</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-real-connect"></a>25.8.7.54. mysql_real_connect()</h4>
<p><code>MYSQL *mysql_real_connect(MYSQL *mysql, const char *host,
const char *user, const char *passwd, const char *db, unsigned int port,
const char *unix_socket, unsigned long client_flag)</code></p>

<h5><a name="idm139965277670384"></a>Описание</h5>
<p><a href="#mysql-real-connect"><code>
mysql_real_connect()</code></a> пытается установить соединение с сервером
MySQL на машине <code>host</code>.
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a> должен завершиться успешно прежде, чем Вы сможете выполнить любые
другие функции API, которые требуют допустимого дескриптора соединения
<code>MYSQL</code>. Параметры определены следующим образом:</p>

<ul><li><p>Для первого параметра определите адрес существующей структуры
<code>MYSQL</code>. Перед вызовом
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a> вызовите <a href="#mysql-init"><code>
mysql_init()</code></a>, чтобы инициализировать структуру <code>MYSQL</code>.
Вы можете изменить многие опции соединения с помощью
<a href="#mysql-options"><code>mysql_options()</code></a>.
</li>

<li>Значение <code>host</code> может быть именем хоста или IP-адресом. Если
<code>host</code> равен <code>NULL</code> или строке <code>"localhost"</code>,
принято соединение с локальным хостом. Для Windows клиент соединяется,
используя объект совместно используемой памяти, если серверу включили этот
вариант. Иначе используется TCP/IP. Для Unix клиент соединяется, используя
файл сокета Unix. Для местных соединений Вы можете также влиять на тип
соединения с помощью опций <code>MYSQL_OPT_PROTOCOL</code> или
<code>MYSQL_OPT_NAMED_PIPE</code> для
<a href="#mysql-options"><code>mysql_options()</code>
</a>. Тип соединения должен быть поддержан сервером. Для значения
<code>"."</code> в <code>host</code> под Windows клиент соединяется,
используя именованный канал, если серверу включили соединения по именованным
каналам. Если соединения по именованным каналам
не включены, происходит ошибка.</li>

<li>Параметр <code>user</code> содержит идентификатор пользователя для входа
в систему MySQL. Если <code>user</code> <code>NULL</code> или пустая строка,
<code>""</code>, текущий пользователь принят. Под Unix это текущее имя для
входа в систему. Под Windows ODBC текущее имя пользователя должно
быть определено явно.</li>

<li>Параметр <code>passwd</code> содержит пароль для <code>user</code>. Если
<code>passwd</code> <code>NULL</code>, только записи в таблице
<code>user</code>, у которых есть пустое поле пароля будут проверены на
соответствие. Это позволяет администратору базы данных настроить систему
привилегии MySQL таким способом, что пользователи получают различные права в
зависимости от того, определили ли они пароль.</p>

<p>Не пытайтесь зашифровать пароль перед запросом
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>, шифрование пароля обработано автоматически клиентом API.</p>
</li>

<li><p>Параметры <code>user</code> и <code>passwd</code> используют любой
набор символов, который был сконфигурирован для объекта
<code>MYSQL</code>. Обычно это <code>latin1</code> но может быть изменен
вызовом <a href="#mysql-options"><code>
mysql_options(mysql, MYSQL_SET_CHARSET_NAME,
"<em><code>charset_name</code></em>")</code></a> до соединения.</li>

<li><code>db</code> имя базы данных. Если <code>db</code> не
<code>NULL</code>, соединение устанавливает базу данных по
умолчанию в это значение.</li>

<li>Если <code>port</code> не 0, значение используется в качестве номера
порта для соединения TCP/IP. Отметьте что параметр <code>host</code>
определяет тип соединения.</li>

<li>Если <code>unix_socket</code> не <code>NULL</code>, строка определяет
сокет или именованный канал. Отметьте что параметр <code>host</code>
определяет тип соединения.</li>

<li>Значение <code>client_flag</code> обычно 0, но может быть установлено в
комбинацию следующих флагов, чтобы активировать определенные опции.</p>

<table border="1">
<thead><tr><th scope="col">Имя флага</th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><code>CAN_HANDLE_EXPIRED_PASSWORDS</code></td>
<td>Клиент может обработать истекшие пароли.</td></tr>
<tr><td scope="row"><code>CLIENT_COMPRESS</code></td>
<td>Использовать сжатие в протоколе клиент-сервер.</td></tr>
<tr><td scope="row"><code>CLIENT_FOUND_ROWS</code></td>
<td>Вернуть число найденных (соответствующих) строк, а не число измененных.
</td></tr>
<tr><td scope="row"><code>CLIENT_IGNORE_SIGPIPE</code></td>
<td>Препятствует тому, чтобы библиотека клиента установила обработчик сигнала
<code>SIGPIPE</code>. Это может использоваться, чтобы избежать конфликтов с
обработчиком, который уже установило приложение.</td></tr>
<tr><td scope="row"><code>CLIENT_IGNORE_SPACE</code></td>
<td>Пробелы разрешены после имен функций. Делает все зарезервированные слова
именами функций.</td></tr>
<tr><td scope="row"><code>CLIENT_INTERACTIVE</code></td>
<td>Разрешает <a href="server.htm#sysvar_interactive_timeout">
<code>interactive_timeout</code></a> секунд неактивности (а не
<a href="server.htm#sysvar_wait_timeout"><code>wait_timeout
</code></a>) прежде, чем закрыть соединение. Сеанс клиента
<a href="server.htm#sysvar_wait_timeout"><code>wait_timeout
</code></a> переменная установлена в значение сеанса
<a href="server.htm#sysvar_interactive_timeout"><code>
interactive_timeout</code></a>.</td></tr>
<tr><td scope="row"><code>CLIENT_LOCAL_FILES</code></td>
<td>Разрешает обработку <a href="sql.htm#load-data"><code>LOAD DATA
LOCAL</code></a>.</td></tr>
<tr><td scope="row"><code>CLIENT_MULTI_RESULTS</code></td>
<td>Сообщает серверу, что клиент может обработать много наборы результатов от
выполнения запроса или хранимых процедур. Этот флаг автоматически включен,
если включить <code>CLIENT_MULTI_STATEMENTS</code>.
<tr><td scope="row"><code>CLIENT_MULTI_STATEMENTS</code></td>
<td>Сообщает серверу, что клиент может послать много запросов в одной строке
(разделяя символом <code>;</code>). Если этот флаг не установлен, выполнение
нескольких команд отключено.</td></tr>
<tr><td scope="row"><code>CLIENT_NO_SCHEMA</code></td>
<td>Не разрешать синтаксис <em><code>db_name.tbl_name.col_name</code></em>.
Это для ODBC. Это заставляет анализатор производить ошибку, если Вы
используете тот синтаксис, который полезен для заманивания в ловушку ошибок в
некоторых программах ODBC.</td></tr>
<tr><td scope="row"><code>CLIENT_ODBC</code></td><td>Не используется.
</td></tr>
<tr><td scope="row"><code>CLIENT_SSL</code></td>
<td>Использовать SSL (зашифрованный протокол). Не устанавливайте эту опцию в
пределах приложения, это установлено внутренне в библиотеке клиента. Вместо
этого используйте <a href="#mysql-ssl-set"><code>
mysql_ssl_set()</code></a> перед вызовом
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>.</td></tr>
<tr><td scope="row"><code>CLIENT_REMEMBER_OPTIONS</code></td>
<td>Помнить опции, определенные
<a href="#mysql-options"><code>mysql_options()</code></a>.
Без этой опции, если <a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a> терпит неудачу, Вы должны повторить
<a href="#mysql-options"><code>mysql_options()</code></a>
прежде, чем попытаться соединиться снова. С этой опцией
<a href="#mysql-options"><code>mysql_options()</code></a>
повторять не надо.</td></tr></tbody></table></li></ul>

<p>Если Ваша программа использует вызов <a href="sql.htm#call"><code>
CALL</code></a>, чтобы выполнить хранимые процедуры, флаг
<code>CLIENT_MULTI_RESULTS</code> должен быть включен. Это потому, что каждый
<a href="sql.htm#call"><code>CALL</code></a> возвращает результат,
чтобы указать на состояние запроса, в дополнение к любым наборам результатов,
которые могли бы быть возвращены запросами, выполненными в пределах
процедуры. Поскольку <a href="sql.htm#call"><code>CALL</code></a>
может возвратить много наборов результатов, их надо обработать в цикле с
помощью <a href="#mysql-next-result"><code>
mysql_next_result()</code></a>.</p>

<p><code>CLIENT_MULTI_RESULTS</code> может быть включен, когда Вы вызываете
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a> явно, устанавливая флаг <code>CLIENT_MULTI_RESULTS</code>
непосредственно, или неявно с помощью флага <code>CLIENT_MULTI_STATEMENTS
</code> (который все равно включает <code>CLIENT_MULTI_RESULTS</code>).
По умолчанию <code>CLIENT_MULTI_RESULTS</code> включен.</p>

<p>Если Вы включаете <code>CLIENT_MULTI_STATEMENTS</code> или
<code>CLIENT_MULTI_RESULTS</code>, обработайте результат для каждого вызова
<a href="#mysql-query"><code>mysql_query()</code></a> или
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a>, используя цикличный вызов
<a href="#mysql-next-result"><code>mysql_next_result()
</code></a>.</p>

<p>Для некоторых параметров возможно взять значение из файла опции, а не от
явного значения в вызове
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>. Чтобы сделать это, вызовите
<a href="#mysql-options"><code>mysql_options()</code></a>
с опцией <code>MYSQL_READ_DEFAULT_FILE</code> или
<code>MYSQL_READ_DEFAULT_GROUP</code> до вызова
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>. Тогда в <a href="#mysql-real-connect"><code>
mysql_real_connect()</code></a> укажите отсутствие значения для каждого
параметра, который будет считан из файла опции:</p>

<ul><li><p>Для <code>host</code> определите значение <code>NULL</code>
или пустую строку (<code>""</code>).</li>
<li>Для <code>user</code> определите значение <code>NULL</code>
или пустую строку.</li>
<li>Для <code>passwd</code> определите значение <code>NULL</code>. Для пароля
значение пустой строки в <a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a> не может быть переопределено в файле
опций, потому что пустая строка указывает явно, что у учетной записи MySQL
должен быть пустой пароль.</li>

<li>Для <code>db</code> определите значение <code>NULL</code>
или пустую строку.</li>
<li>Для <code>port</code> определите значение 0.</li>
<li>Для <code>unix_socket</code> определите значение <code>NULL</code>.
</p></li></ul>

<p>Если никакое значение не найдено в файле опций для параметра, его значение
по умолчанию используется как обозначено в описаниях, данных
ранее в этом разделе.</p>

<h5><a name="idm139965277535424"></a>Возвращаемые значения</h5>
<p>Дескриптор соединения <code>MYSQL*</code>, если соединение было успешно,
<code>NULL</code>, если соединение было неудачно. Для успешного соединения
возвращаемое значение то же самое, что и значение первого параметра.</p>

<h5><a name="idm139965277532688"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_conn_host_error"><code>
CR_CONN_HOST_ERROR</code></a></p>
<p>Не удалось связаться с сервером MySQL.</li>

<li><a href="error.htm#error_cr_connection_error"><code>
CR_CONNECTION_ERROR</code></a></p>
<p>Не удалось связаться с локальным сервером MySQL.</li>

<li><a href="error.htm#error_cr_ipsock_error"><code>CR_IPSOCK_ERROR
</code></a></p>
<p>Ошибка создания IP-сокета.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_socket_create_error"><code>
CR_SOCKET_CREATE_ERROR</code></a></p>
<p>Ошибка создания Unix-сокета.</li>

<li><a href="error.htm#error_cr_unknown_host"><code>CR_UNKNOWN_HOST
</code></a></p>
<p>Не найден IP-адрес для имени хоста.</li>

<li><a href="error.htm#error_cr_version_error"><code>
CR_VERSION_ERROR</code></a></p>
<p>Несоответствие протокола по причине попытки соединиться с сервером с
библиотекой клиента, которая использует иную версию протокола.</li>

<li><a href="error.htm#error_cr_namedpipeopen_error"><code>
CR_NAMEDPIPEOPEN_ERROR</code></a></p>
<p>Не удалось создать именованный канал под Windows.</li>

<li><a href="error.htm#error_cr_namedpipewait_error"><code>
CR_NAMEDPIPEWAIT_ERROR</code></a></p>
<p>Не удалось дождаться именованного канала под Windows.</li>

<li><a href="error.htm#error_cr_namedpipesetstate_error"><code>
CR_NAMEDPIPESETSTATE_ERROR</code></a></p>
<p>Не удалось дескриптор канала под Windows.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Если <a href="server.htm#sysvar_connect_timeout"><code>
connect_timeout</code></a> &gt; 0, а это заняло больше времени чем
<a href="server.htm#sysvar_connect_timeout"><code>
connect_timeout</code></a> секунд, чтобы соединиться с сервером, или если
сервер упал, выполняя <code>init-command</code>.</li>

<li><a href="error.htm#error_cr_already_connected"><code>
CR_ALREADY_CONNECTED</code></a></p>
<p>Дескриптор соединения <code>MYSQL</code> уже соединен.</p></li></ul>

<h5><a name="idm139965277496336"></a>Пример</h5>
<pre>
MYSQL mysql;

mysql_init(&amp;mysql);
mysql_options(&amp;mysql,MYSQL_READ_DEFAULT_GROUP,"your_prog_name");
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",
    0,NULL,0)) {
   fprintf(stderr, "Failed to connect to database: Error: %s\n",
   mysql_error(&amp;mysql));
}
</pre>

<p>При использовании <a href="#mysql-options"><code>
mysql_options()</code></a> MySQL читает секции <code>[client]</code> и
<code>[your_prog_name]</code> в файле <code>my.cnf</code>, что гарантирует,
что Ваша программа работает, даже если кто-то настроил MySQL
некоторым нестандартным способом.</p>

<p>При подключении <a href="#mysql-real-connect"><code>
mysql_real_connect()</code></a> устанавливает флаг <code>reconnect</code>
(часть структуры <code>MYSQL</code>) в <code>1</code> в версиях более старого
API чем 5.0.3, или в <code>0</code> в более новых версиях. Значение
<code>1</code> этого флага указывает на это, если запрос не может быть
выполнен из-за потерянного соединения, надо попытаться повторно соединиться с
сервером перед отказом. Вы можете использовать опцию
<code>MYSQL_OPT_RECONNECT</code> в
<a href="#mysql-options"><code>mysql_options()</code></a>,
чтобы управлять поведением пересоединения.</p>

<h4><a name="mysql-real-escape-string"></a>25.8.7.55.
mysql_real_escape_string()</h4>
<p><code>unsigned long mysql_real_escape_string(MYSQL *mysql,
char *to, const char *from, unsigned long length)</code></p>

<h5><a name="idm139965277479344"></a>Описание</h5>
<p>Эта функция создает правильную строку для использования в SQL-запросе.
<a href="#mysql-real-escape-string"><code>
mysql_real_escape_string()</code></a> производит ошибку
<a href="error.htm#error_cr_insecure_api_err"><code>
CR_INSECURE_API_ERR</code></a>, если включен режим SQL
<a href="server.htm#sqlmode_no_backslash_escapes"><code>
NO_BACKSLASH_ESCAPES</code></a>. В этом случае функция не может выйти из
символов кавычки, кроме как удваивая их, а чтобы сделать это должным образом,
она должна знать больше информации о контексте, заключенном в кавычки, чем ей
доступно. Вместо этого используйте
<a href="#mysql-real-escape-string-quote"><code>
mysql_real_escape_string_quote()</code></a>, которая берет дополнительный
параметр для определения контекста, заключенного в кавычки.</p>

<p>Параметр <code>mysql</code> должен быть допустимым, открытым соединением,
потому что символьный вывод зависит от набора
символов, используемом сервером.</p>

<p>Строка в <code>from</code> будет закодирована, чтобы произвести строку
SQL, принимая во внимание текущий набор символов соединения. Результат
помещен в параметр <code>to</code>, сопровождаемый
заканчивающим нулевым байтом.</p>

<p>Закодированные символы <code>\</code>, <code>'</code>, <code>"</code>,
<code>NUL</code> (ASCII 0), <code>\n</code>, <code>\r</code> и Control+Z.
Строго говоря, MySQL требует только, чтобы наклонная черта влево и символ
кавычки, используемые для цитирования строки в запросе, были экранированы.
<a href="#mysql-real-escape-string"><code>
mysql_real_escape_string()</code></a> заключает другие символы в кавычки,
чтобы их было легче читать в файлах системного журнала. Для сравнения, см.
правила заключения в кавычки для строк литералов и SQL-функции
<a href="funct.htm#function_quote"><code>QUOTE()</code></a> в
<a href="lang.htm#string-literals">разделе 10.1.1.
Строковые литералы</a> и <a href="funct.htm#string-functions">
раздел 13.5. Строковые функции</a>.</p>

<p>Строка, указанная в <code>from</code> должна быть <code>length</code>
байтов в длину. Вы должны выделить буфер для <code>to</code> по крайней мере
<code>length*2+1</code> байт. В худшем случае каждый символ, возможно, должен
быть закодирован как два байта и должно быть место для заканчивающего
нулевого байта. Когда <a href="#mysql-real-escape-string">
<code>mysql_real_escape_string()</code></a> завершится, содержанием
<code>to</code> будет строка, законченная нулем. Возвращаемое значение длина
закодированной строки, не включая заканчивающий нулевой байт.</p>

<p>Если Вы должны изменить набор символов соединения, используйте функцию
<a href="#mysql-set-character-set"><code>
mysql_set_character_set()</code></a> вместо того, чтобы выполнить
<a href="sql.htm#set-names"><code>SET NAMES</code></a> (или
<a href="sql.htm#set-character-set"><code>SET CHARACTER SET</code>
</a>). <a href="#mysql-set-character-set"><code>
mysql_set_character_set()</code></a> работает подобно
<a href="sql.htm#set-names"><code>SET NAMES</code></a>, но
затрагивает также и набор символов, используемый
<a href="#mysql-real-escape-string"><code>
mysql_real_escape_string()</code></a>.</p>

<h5><a name="idm139965277443152"></a>Пример</h5>
<p>Следующий пример вставляет две экранированных строки в запрос
<code>INSERT</code>, каждая берется в символы одинарной кавычки:
<pre>
char query[1000],*end;

end = my_stpcpy(query,"INSERT INTO test_table VALUES('");
end += mysql_real_escape_string(&amp;mysql,end,"What is this",12);
end = my_stpcpy(end,"','");
end += mysql_real_escape_string(&amp;mysql,end,"binary data: \0\r\n",16);
end = my_stpcpy(end,"')");
if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query))) {
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<p>Функция <code>my_stpcpy()</code>, используемая в примере, включена в
библиотеку <code>libmysqlclient</code> и работает как <code>strcpy()</code>,
но возвращает указатель на заканчивающий нуль первого параметра.</p>

<h5><a name="idm139965277437200"></a>Возвращаемые значения</h5>
<p>Длина закодированной строки, которая помещена в параметр
<code>to</code>, не включая заканчивающий нулевой байт, или -1,
если ошибка происходит.</p>

<p>Поскольку <a href="#mysql-real-escape-string">
<code>mysql_real_escape_string()</code></a> возвращает значение без знака,
Вы можете проверить на-1, сравнивая возвращаемое значение с
<code>(unsigned long)-1</code>.</p>

<h5><a name="idm139965277432016"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_insecure_api_err"><code>
CR_INSECURE_API_ERR</code></a></p>

<p>Эта ошибка происходит, если режим SQL
<a href="server.htm#sqlmode_no_backslash_escapes"><code>
NO_BACKSLASH_ESCAPES</code></a> включен.</p></li></ul>

<h4><a name="mysql-real-escape-string-quote"></a>25.8.7.56.
mysql_real_escape_string_quote()</h4>
<p><code>unsigned long mysql_real_escape_string_quote(MYSQL *mysql,
char *to, const char *from, unsigned long length, char quote)</code></p>

<h5><a name="idm139965277420928"></a>Описание</h5>
<p>Эта функция создает правильную строку для использования в SQL-запросе в
целом аналогично <a href="#mysql-real-escape-string">
<code>mysql_real_escape_string()</code></a>. Однако, есть отличия.</p>

<p>Если включен режим SQL
<a href="server.htm#sqlmode_ansi_quotes"><code>
ANSI_QUOTES</code></a>,
<a href="#mysql-real-escape-string-quote"><code>
mysql_real_escape_string_quote()</code></a> не может использоваться, чтобы
экранировать символы двойной кавычки для использования в идентификаторах в
двойных кавычках. Функция не может сказать, позволено ли режиму определить
надлежащий символ экранировки.</p>

<p>Строка, указанная в <code>from</code> должна быть <code>length</code>
байтов в длину. Вы должны выделить буфер для <code>to</code> по крайней мере
<code>length*2+1</code> байт. В худшем случае каждый символ, возможно, должен
быть закодирован как два байта и должно быть место для заканчивающего
нулевого байта. Когда <a href="#mysql-real-escape-string">
<code>mysql_real_escape_string()</code></a> завершится, содержанием
<code>to</code> будет строка, законченная нулем. Возвращаемое значение длина
закодированной строки, не включая заканчивающий нулевой байт.</p>

<p>Параметр <code>quote</code> указывает на контекст, в который должна быть
помещена экранированная строка. Предположим, что Вы намереваетесь
экранировать параметр <code>from</code> и вставить строку (определяемую здесь
как <em><code>str</code></em>) в один из следующих запросов:
<pre>
1) SELECT * FROM table WHERE name = '<em><code>str</code></em>'
2) SELECT * FROM table WHERE name = "<em><code>str</code></em>"
3) SELECT * FROM `<em><code>str</code></em>` WHERE id = 103
</pre>

<p>Чтобы выполнить экранировку должным образом для каждого запроса, выполните
<a href="#mysql-real-escape-string-quote"><code>
mysql_real_escape_string_quote()</code></a> следующим образом, где
заключительный параметр указывает на контекст заключения в кавычки:
<pre>
1) len = mysql_real_escape_string_quote(&amp;mysql,to,from,from_len,'\'');
2) len = mysql_real_escape_string_quote(&amp;mysql,to,from,from_len,'"');
3) len = mysql_real_escape_string_quote(&amp;mysql,to,from,from_len,'`');
</pre>

<p>Если Вы должны изменить набор символов соединения, используйте функцию
<a href="#mysql-set-character-set"><code>
mysql_set_character_set()</code></a> вместо того, чтобы выполнить команду
<a href="sql.htm#set-names"><code>SET NAMES</code></a> (или
<a href="sql.htm#set-character-set"><code>SET CHARACTER SET</code>
</a>). <a href="#mysql-set-character-set"><code>
mysql_set_character_set()</code></a> работает похоже на
<a href="sql.htm#set-names"><code>SET NAMES</code></a>, но также
затрагивает и набор символов, используемый
<a href="#mysql-real-escape-string-quote"><code>
mysql_real_escape_string_quote()</code></a>, который
<a href="sql.htm#set-names"><code>SET NAMES</code></a> не трогает.
</p>

<h5><a name="idm139965277379616"></a>Пример</h5>
<p>Следующий пример вставляет две строки в запрос
<code>INSERT</code>, каждая в обрамлении символов одинарной кавычки:
<pre>
char query[1000],*end;

end = my_stpcpy(query,"INSERT INTO test_table VALUES('");
end += mysql_real_escape_string_quote(&amp;mysql,end,"What is this",12,'\'');
end = my_stpcpy(end,"','");
end += mysql_real_escape_string_quote(&amp;mysql,end,"binary data: \0\r\n",
                                      16,'\'');
end = my_stpcpy(end,"')");
if (mysql_real_query(&amp;mysql,query,(unsigned int) (end - query))) {
   fprintf(stderr, "Failed to insert row, Error: %s\n",
           mysql_error(&amp;mysql));
}
</pre>

<h5><a name="idm139965277373632"></a>Возвращаемые значения</h5>
<p>Длина закодированной строки, которая помещена в параметр <code>to</code>,
не включая заканчивающий нулевой байт.</p>

<h5><a name="idm139965277371728"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-real-query"></a>25.8.7.57. mysql_real_query()</h4>
<a class="indexterm" name="idm139965277369456"></a><p>
<code>int mysql_real_query(MYSQL *mysql, const char *stmt_str,
unsigned long length)</code></p>

<h5><a name="idm139965277367248"></a>Описание</h5>
<p>Выполняет SQL-запрос, указанный в строке <code>stmt_str</code>
<code>length</code> байтов длиной. Обычно строка должна состоять из
единственного запроса SQL без заканчивающей точки с запятой (<code>;</code>)
или <code>\g</code>. Если выполнение нескольких запросов было включено,
строка может содержать несколько запросов, отделенных точками с запятой.</p>

<p><a href="#mysql-query"><code>mysql_query()</code></a>
не может использоваться для запросов, которые содержат двоичные данные, Вы
должны использовать вместо этого
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a>. Двоичные данные могут содержать символ <code>\0</code>, который
<a href="#mysql-query"><code>mysql_query()</code></a>
интерпретирует как конец строки. Кроме того,
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a> быстрее, чем
<a href="#mysql-query"><code>mysql_query()</code></a>,
поскольку не вызывает <code>strlen()</code>.</p>

<p>Если Вы хотите знать, возвращает ли запрос набор результатов, Вы можете
использовать <a href="#mysql-field-count"><code>
mysql_field_count()</code></a>, чтобы проверить это.</p>

<h5><a name="idm139965277351760"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277350608"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-refresh"></a>25.8.7.58. mysql_refresh()</h4>
<p><code>int mysql_refresh(MYSQL *mysql, unsigned int options)</code></p>
<h5><a name="idm139965277336336"></a>Описание</h5>
<p><code>mysql_refresh()</code> устарела и будет удалена в будущих версиях
MySQL. Вместо нее используйте
<a href="#mysql-query"><code>mysql_query()</code></a>,
чтобы выполнить команду <a href="sql.htm#flush"><code>FLUSH</code>
</a>.</p>

<p>Эта функция сбрасывает таблицы или кэши, или информацию о сервере
репликаций. Соединенный пользователь должен иметь привилегию
<a href="security.html#priv_reload"><code>RELOAD</code></a>.</p>

<p>Параметр <code>options</code> является битовой маской, составленной из
любой комбинации следующих значений. Много значений могут быть объединены
через OR вместе, чтобы выполнить много операций за один вызов.</p>

<ul><li><p><code>REFRESH_GRANT</code></p>
<p>Освежить таблицы привилегий, аналог
<a href="sql.htm#flush"><code>FLUSH PRIVILEGES</code></a>.</li>

<li><code>REFRESH_LOG</code></p>
<p>Сбросить протоколы, аналог
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a>.</li>

<li><code>REFRESH_TABLES</code></p>
<p>Сбросить кэши таблиц, аналог
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a>.</li>

<li><code>REFRESH_HOSTS</code></p>
<p>Сбросить кэш хостов, аналог
<a href="sql.htm#flush"><code>FLUSH HOSTS</code></a>.</li>

<li><code>REFRESH_STATUS</code></p>
<p>Сбросить статусную информацию, аналог
<a href="sql.htm#flush"><code>FLUSH STATUS</code></a>.</li>

<li><code>REFRESH_THREADS</code></p>
<p>Сбросить кэш потоков.</li>
<li><code>REFRESH_SLAVE</code></p>
<p>На ведомом сервере репликации сбросить информацию о главном сервере и
перезапуск ведомое устройство, как
<a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a>.</li>

<li><code>REFRESH_MASTER</code></p>
<p>На основном сервере репликации удалить двоичные файлы системного журнала,
перечисленные в индексе двоичного журнала и усечь индексный файл, как
<a href="sql.htm#reset-master"><code>RESET MASTER</code></a>.
</p></li></ul>

<h5><a name="idm139965277304016"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277302864"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-reload"></a>25.8.7.59. mysql_reload()</h4>
<p><code>int mysql_reload(MYSQL *mysql)</code></p>
<h5><a name="idm139965277288624"></a>Описание</h5>
<p>Просит сервер MySQL перезагрузить таблицы привилегий. Соединенный
пользователь должен иметь привилегию <a href="security.html#priv_reload">
<code>RELOAD</code></a>.</p>

<p>Эта функций устарела. Вместо нее следует использовать
<a href="#mysql-query"><code>mysql_query()</code></a>
для выполнения запроса SQL <a href="sql.htm#flush"><code>FLUSH
PRIVILEGES</code></a>.</p>

<h5><a name="idm139965277282496"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277281344"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-reset-connection"></a>25.8.7.60. mysql_reset_connection()
</h4>
<p><code>int mysql_reset_connection(MYSQL *mysql)</code></p>
<h5><a name="idm139965277267056"></a>Описание</h5>
<p>Сбрасывает соединение, чтобы очистить статус сеанса.</p>

<p><a href="#mysql-reset-connection"><code>
mysql_reset_connection()</code></a> имеет эффекты, подобные
<a href="#mysql-change-user"><code>mysql_change_user()
</code></a> или автоматическому переподключению за исключением того, что
соединение не закрыто и вновь открыто, а переаутентификация не сделана.</p>

<p>Связанное с соединением состояние меняется следующим образом:</p>
<ul><li><p>Любые активные транзакции откатываются и сбрасывается режим
autocommit.</li>

<li>Все табличные блокировки снимаются.</li>
<li>Все таблицы <code>TEMPORARY</code> будут закрыты и удалены.</li>
<li>Системные переменные сеанса повторно инициализированы к значениям
соответствующих глобальных системных переменных, включая системные
переменные, которые установлены неявно командами типа
<a href="sql.htm#set-names"><code>SET NAMES</code></a>.</li>

<li>Пользовательские настройки переменных потеряны.</li>
<li>Подготовленные запросы сбрасываются.</li>
<li>Переменные <a href="sql.htm#handler"><code>HANDLER</code></a>
закрываются.</li>
<li>Значение <a href="funct.htm#function_last-insert-id"><code>
LAST_INSERT_ID()</code></a> устанавливается в 0.</li>

<li>Блокировки, созданные функцией
<a href="funct.htm#function_get-lock"><code>GET_LOCK()</code></a>,
отменяются.</p></li></ul>

<h5><a name="idm139965277246480"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h4><a name="mysql-rollback"></a>25.8.7.61. mysql_rollback()</h4>
<a class="indexterm" name="idm139965277244096"></a><p>
<code>my_bool mysql_rollback(MYSQL *mysql)</code></p>

<h5><a name="idm139965277241936"></a>Описание</h5>
<p>Откатывает текущую транзакцию. Действие этой функции зависит от значения
системной переменной
<a href="server.htm#sysvar_completion_type"><code>
completion_type</code></a>. В частности, если значение
<a href="server.htm#sysvar_completion_type"><code>
completion_type</code></a> <code>RELEASE</code> (или 2), сервер выполняет
отмену после завершения транзакции и закрывает соединение клиента. Вызовите
<a href="#mysql-close"><code>mysql_close()</code></a> из
из программы клиента, чтобы закрыть соединение со стороны клиента.</p>

<h5><a name="idm139965277235664"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277234512"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-row-seek"></a>25.8.7.62. mysql_row_seek()</h4>
<a class="indexterm" name="idm139965277232176"></a><p>
<code>MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result,
MYSQL_ROW_OFFSET offset)</code></p>

<h5><a name="idm139965277229968"></a>Описание</h5>
<p>Устанавливает курсор строки в произвольную строку в наборе результатов
запроса. Значение <code>offset</code> смещение строки, как правило значение
из <a href="#mysql-row-tell"><code>mysql_row_tell()
</code></a> или <a href="#mysql-row-seek"><code>
mysql_row_seek()</code></a>. Это значение не номер строки, чтобы перейти на
строку в пределах набора результатов по номеру, используйте
<a href="#mysql-data-seek"><code>mysql_data_seek()</code>
</a>.</p>

<p>Эта функция требует, чтобы структура набора результатов содержала весь
результат запроса, таким образом,
<a href="#mysql-row-seek"><code>mysql_row_seek()</code>
</a> может использоваться только вместе с
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, но не с
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a>.</p>

<h5><a name="idm139965277219968"></a>Возвращаемые значения</h5>
<p>Предыдущяя позиция курсора строки. Это значение можно передать
последующему вызову
<a href="#mysql-row-seek"><code>mysql_row_seek()</code>
</a>.</p>

<h5><a name="idm139965277217536"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-row-tell"></a>25.8.7.63. mysql_row_tell()</h4>
<a class="indexterm" name="idm139965277215200"></a><p>
<code>MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *result)</code></p>

<h5><a name="idm139965277213008"></a>Описание</h5>
<p>Возвращает текущую позицию курсора строки для последнего вызова
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a>. Это значение может использоваться в качестве параметра
<a href="#mysql-row-seek"><code>mysql_row_seek()</code>
</a>.</p>

<p>Используйте <a href="#mysql-row-tell"><code>
mysql_row_tell()</code></a> только после
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, но не после
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a>.</p>

<h5><a name="idm139965277205216"></a>Возвращаемые значения</h5>
<p>Текущее смещение курсора строки.</p>
<h5><a name="idm139965277204080"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-select-db"></a>25.8.7.64. mysql_select_db()</h4>
<p><code>int mysql_select_db(MYSQL *mysql, const char *db)</code></p>
<h5><a name="idm139965277199552"></a>Описание</h5>
<p>Назначает базу данных, определенную <code>db</code>, базой данных по
умолчанию для соединения, определенного <code>mysql</code>. В последующих
запросах эта база данных будет значением по умолчанию для табличных ссылок,
которые не включают явного спецификатора базы данных.</p>

<p><a href="#mysql-select-db"><code>mysql_select_db()
</code></a> терпит неудачу, если соединенный пользователь не имеет права
использовать эту базу данных.</p>

<h5><a name="idm139965277195088"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277193936"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-session-track-get-first"></a>25.8.7.65.
mysql_session_track_get_first()</h4>
<p><code>int mysql_session_track_get_first(MYSQL *mysql,
enum enum_session_state_type type, const char **data, size_t *length)</code>
</p>

<h5><a name="idm139965277178448"></a>Описание</h5>
<p>Эта функция приносит первую информацию об изменении состояния сеанса,
полученную от сервера.</p>

<p>Чтобы управлять уведомлением об изменениях состояния сессии, используйте
системные переменные
<a href="server.htm#sysvar_session_track_state_change"><code>
session_track_state_change</code></a>,
<a href="server.htm#sysvar_session_track_schema"><code>
session_track_schema</code></a>,
<a href="server.htm#sysvar_session_track_system_variables">
<code>session_track_system_variables</code></a> и
<a href="server.htm#sysvar_session_track_gtids"><code>
session_track_gtids</code></a>.</p>

<p>Функциональные параметры используются следующим образом. Эти описания
также относятся к
<a href="#mysql-session-track-get-first"><code>
mysql_session_track_get_first()</code></a>, которая берет те
же самые параметры.</p>

<ul><li><p><code>mysql</code>: Дескриптор соединения.</li>
<li><code>type</code>: Тип информации, которую надо получить. Разрешенные
значения для этого параметра: члены <code>enum_session_state_type</code>,
определенного в <code>mysql_com.h</code>:
<pre>
enum enum_session_state_type
{
  SESSION_TRACK_SYSTEM_VARIABLES, /* Session system variables */
  SESSION_TRACK_SCHEMA,     /* Current schema */
  SESSION_TRACK_STATE_CHANGE/* track session state changes */
  SESSION_TRACK_GTIDS,/* track GTIDs/*
};
</pre>

<p>Макросы <code>SESSION_TRACK_BEGIN</code> и
<code>SESSION_TRACK_END</code> равны первому и последнему членам
<code>enum_session_state_type</code>. Пример кода, показанный позже в этом
разделе, демонстрирует этот метод.</li>

<li><code>data</code>: Адрес переменной <code>const char *</code>.
После успешного вызова эта переменная указывает на возвращенные данные,
которые нужно обработать только для чтения.</li>

<li><code>length</code>: Адрес переменной <code>size_t</code>.
После успешного вызова эта переменная содержит длину данных, на которые
указывает параметр <code>data</code>.</p></li></ul>

<p>После успешного вызова, интерпретируйте значения <code>data</code> и
<code>length</code> согласно <code>type</code> следующим образом:</p>
<ul><li><p><code>SESSION_TRACK_SCHEMA</code>:
<code>data</code> новое имя схемы по умолчанию и
<code>length</code> длина имени.</li>

<li><code>SESSION_TRACK_SYSTEM_VARIABLES</code>: Когда системная переменная
сеанса изменяется, два значения на переменную возвращены (в отдельных
запросах). Для первого <code>data</code> имя переменной и
<code>length</code> длина имени. Для второго
<code>data</code> значение переменной и <code>length</code> длина значения.
Оба значения данных представлены как строки.</li>

<li><code>SESSION_TRACK_STATE_CHANGE</code>:
<code>data</code> представляет байт, содержащий булев флаг, который
указывает, произошли ли изменения состояния сессии <code>length</code>
должен быть 1. Флаг представлен как значение ASCII, а не в двоичном виде
(например, <code>'1'</code>, а не <code>0x01</code>).</p></li></ul>

<h5><a name="idm139965277139792"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277138640"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965277137536"></a>Пример</h5>
<p>Следующий пример показывает, как вызвать
<a href="#mysql-session-track-get-first">
<code>mysql_session_track_get_first()</code></a> и
<a href="#mysql-session-track-get-next"><code>
mysql_session_track_get_next()</code></a>, чтобы получить и вывести на экран
всю доступную информацию об изменении состояния сессии после успешного
выполнения строки запроса SQL <code>stmt_str</code>.
<pre>
printf("Execute: %s\n", stmt_str);
if (mysql_query(mysql, stmt_str) != 0) {
   fprintf(stderr, "Error %u: %s\n", mysql_errno(mysql), mysql_error(mysql));
   return;
}
MYSQL_RES *result = mysql_store_result(mysql);
if (result) /* there is a result set to fetch */ {
   /* ... process rows here ... */
   printf("Number of rows returned: %lu\n",
          (unsigned long) mysql_num_rows(result));
   mysql_free_result(result);
}
else  /* there is no result set */
{
  if (mysql_field_count(mysql) == 0) {
     printf("Number of rows affected: %lu\n",
            (unsigned long) mysql_affected_rows(mysql));
  }
  else /* an error occurred */
  {
    fprintf(stderr, "Error %u: %s\n", mysql_errno(mysql), mysql_error(mysql));
  }
}
/* extract any available session state-change information */
enum enum_session_state_type type;
for (type = SESSION_TRACK_BEGIN; type &lt;= SESSION_TRACK_END; type++) {
  const char *data;
  size_t length;

  if (mysql_session_track_get_first(mysql, type, &amp;data,
     &amp;length) == 0) {
     printf("Type=%d:\n", type);
     printf("mysql_session_track_get_first() returns: %*.*s\n",
            (int) length, (int) length, data);
     /* check for more data */
     while (mysql_session_track_get_next(mysql, type, &amp;data,
            &amp;length) == 0) {
       printf("mysql_session_track_get_next() returns: %*.*s\n",
              (int) length, (int) length, data);
     }
  }
}
</pre>

<h4><a name="mysql-session-track-get-next"></a>25.8.7.66. mysql_session_track_get_next()</h4>
<p><code>int mysql_session_track_get_next(MYSQL *mysql,
enum enum_session_state_type type, const char **data, size_t *length)</code>
</p>

<h5><a name="idm139965277125824"></a>Описание</h5>
<p>Эта функция приносит информацию об изменении состояния сеанса,
полученную от сервера после
<a href="#mysql-session-track-get-first"><code>
mysql_session_track_get_first()</code></a>.</p>

<p>После успешного вызова
<a href="#mysql-session-track-get-first"><code>
mysql_session_track_get_first()</code></a> вызывайте
<a href="#mysql-session-track-get-next"><code>
mysql_session_track_get_next()</code></a> неоднократно, пока это не
вернет отличное от нуля значение, чтобы указать, что больше информации не
доступно. Последовательность запроса для
<a href="#mysql-session-track-get-next"><code>
mysql_session_track_get_next()</code></a> подобна
<a href="#mysql-session-track-get-first"><code>
mysql_session_track_get_first()</code></a>.</p>

<h5><a name="idm139965277116784"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277115632"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-set-character-set"></a>25.8.7.67.
mysql_set_character_set()</h4>
<p><code>int mysql_set_character_set(MYSQL *mysql, const char *csname)</code>
</p>

<h5><a name="idm139965277111120"></a>Описание</h5>
<p>Эта функция используется, чтобы установить набор символов по умолчанию для
текущего соединения. Строка <code>csname</code> определяет допустимое имя
набора символов. Сопоставление соединения становится сопоставлением по
умолчанию набора символов. Эта функция работает как
<a href="sql.htm#set-names"><code>SET NAMES</code></a>, но также
меняет значение <code>mysql-&gt;charset</code> и таким образом затрагивает
набор символов, используемый
<a href="#mysql-real-escape-string"><code>
mysql_real_escape_string()</code></a>.</p>

<h5><a name="idm139965277105760"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277104608"></a>Пример</h5>
<pre>
MYSQL mysql;

mysql_init(&amp;mysql);
if (!mysql_real_connect(&amp;mysql,"host","user","passwd","database",
    0,NULL,0)) {
   fprintf(stderr, "Failed to connect to database: Error: %s\n",
   mysql_error(&amp;mysql));
}
if (!mysql_set_character_set(&amp;mysql, "utf8")) {
   printf("New client character set: %s\n",
          mysql_character_set_name(&amp;mysql));
}
</pre>

<h4><a name="mysql-set-local-infile-default"></a>25.8.7.68.
mysql_set_local_infile_default()</h4>
<p><code>void mysql_set_local_infile_default(MYSQL *mysql);</code></p>

<h5><a name="idm139965277098032"></a>Описание</h5>
<p>Устанавливает обработчик <a href="sql.htm#load-data"><code>LOAD
DATA LOCAL INFILE</code></a> в значение по умолчанию, используемое внутренне
библиотекой клиента C. Библиотека вызывает эту функцию автоматически, если
<a href="#mysql-set-local-infile-handler"><code>
mysql_set_local_infile_handler()</code></a> не был вызван или не поставляет
допустимые функции для каждого из вызовов.</p>

<h5><a name="idm139965277094176"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h5><a name="idm139965277093072"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-set-local-infile-handler"></a>25.8.7.69.
mysql_set_local_infile_handler()</h4>
<p><code>void mysql_set_local_infile_handler(MYSQL *mysql, int
(*local_infile_init)(void **, const char *, void *), int
(*local_infile_read)(void *, char *, unsigned int), void
(*local_infile_end)(void *), int (*local_infile_error)(void *, char*,
unsigned int), void *userdata);</code></p>

<h5><a name="idm139965277089328"></a>Описание</h5>
<p>Эта функция устанавливает обработчики, которые будут использоваться во
время выполнения <a href="sql.htm#load-data"><code>LOAD DATA LOCAL
INFILE</code></a>. Это позволяет приложениям осуществить контроль над местным
(сторона клиента) чтением файла с данными. Параметры: обработчик соединения,
ряд указателей на функции обратного вызова и указатель на область данных,
которую могут использовать, чтобы поделиться информацией.</p>

<p>Чтобы использовать
<a href="#mysql-set-local-infile-handler"><code>
mysql_set_local_infile_handler()</code></a>, Вы должны написать следующие
функции обратного вызова:
<pre>
int local_infile_init(void **ptr, const char *filename, void *userdata);
</pre>

<p>Функция инициализации. Это вызывают однажды, чтобы сделать любую
необходимую настройку, открыть файл с данными, выделить структуры данных и
т.д. Первый аргумент <code>void**</code> указатель на указатель. Вы можете
установить указатель (то есть, <code>*ptr</code>) к значению, которое
передадут каждому из других обработчиков (как <code>void*</code>).
Обработчики могут использовать этот указатель на значение, чтобы поддержать
информацию статуса. Параметр <code>userdata</code> то же самое значение,
которое передают
<a href="#mysql-set-local-infile-handler"><code>
mysql_set_local_infile_handler()</code></a>.</p>

<p>Заставьте функцию инициализации возвратить ноль для успеха, отличное от
нуля значение для ошибки.
<pre>
int local_infile_read(void *ptr, char *buf, unsigned int buf_len);
</pre>

<p>Читающая данные функция. Это вызывают неоднократно, чтобы считать файл с
данными. <code>buf</code> указывает на буфер, где данные о чтении хранятся, а
<code>buf_len</code> задает максимальное количество байтов, которые
обработчик может считать и сохранить в буфере. Это может считать меньше
байтов, но не должно читать больше.</p>

<p>Возвращаемое значение: число реально прочитанных байтов или ноль, когда
больше данных не могло быть считано (это указывает на EOF). Верните значение
меньше, чем ноль, если ошибка происходит.

<pre>
void local_infile_end(void *ptr)
</pre>
<p>Функция завершения. Это вызывают однажды после того, как
<code>local_infile_read()</code> вернет 0 (EOF) или ошибку.
В пределах этой функции, освободите любую память, выделенную
<code>local_infile_init()</code>, и выполните любую другую необходимую
уборку. Это вызвано, даже если функция инициализации возвращает ошибку.

<pre>
int local_infile_error(void *ptr, char *error_msg,
                       unsigned int error_msg_len);
</pre>
<p>Функция обработки ошибок. Это вызывают, чтобы вернуть пользователю
текстовое сообщение об ошибке в случае, если любая из Ваших других функций
возвращает ошибку. <code>error_msg</code> указывает на буфер, в который
сообщение записано, а <code>error_msg_len</code> является длиной буфера.
Пишите сообщение как законченную нулем строку, самое большее
<code>error_msg_len</code>-1 байт длиной.</p>

<p>Возвращаемое значение код ошибки. Как правило, обработчики хранят
сообщение об ошибке в структуре данных, которую указывают в
<code>ptr</code> так, чтобы <code>local_infile_error()</code> мог
скопировать сообщение оттуда в <code>error_msg</code>.</p>

<p>После вызова <a href="#mysql-set-local-infile-handler">
<code>mysql_set_local_infile_handler()</code></a> в Вашем коде C и обработке
указателей на ваши обработчики, Вы можете вызвать оператор
<a href="sql.htm#load-data"><code>LOAD DATA LOCAL INFILE</code></a>
(например, через <a href="#mysql-query"><code>
mysql_query()</code></a>). Библиотека клиента автоматически вызывает Ваши
обработчики. Имя файла, определенное в <a href="sql.htm#load-data">
<code>LOAD DATA LOCAL INFILE</code></a>, будет передано как второй параметр
в <code>local_infile_init()</code>.</p>

<h5><a name="idm139965277058832"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h5><a name="idm139965277057728"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-set-server-option"></a>25.8.7.70.
mysql_set_server_option()</h4>
<p><code>int mysql_set_server_option(MYSQL *mysql,
enum enum_mysql_set_option option)</code></p>

<h5><a name="idm139965277053152"></a>Описание</h5>
<p>Включает или отключает опцию для соединения. <code>option</code>
может иметь одно из следующих значений.</p>

<table border="1">
<thead><tr><th scope="col">Опция</th><th scope="col">Описание
</th></tr></thead>
<tbody><tr><td scope="row"><code>MYSQL_OPTION_MULTI_STATEMENTS_ON</code></td>
<td>Включить поддержку нескольких запросов сразу.</td></tr>
<tr><td scope="row"><code>MYSQL_OPTION_MULTI_STATEMENTS_OFF</code></td>
<td>Выключить поддержку нескольких запросов сразу.</td></tr></tbody></table>

<p>Если Вы включите поддержку нескольких запросов сразу, Вы должны получить
результаты вызовов
<a href="#mysql-query"><code>mysql_query()</code></a> или
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a> применяя циклический вызов
<a href="#mysql-next-result"><code>mysql_next_result()
</code></a>, чтобы определить, есть ли еще результаты.</p>

<p>Включение поддержки нескольких запросов сразу с помощью
<code>MYSQL_OPTION_MULTI_STATEMENTS_ON</code> имеет не вполне тот же самый
эффект, как включение с помощью флага <code>CLIENT_MULTI_STATEMENTS</code> в
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>: <code>CLIENT_MULTI_STATEMENTS</code> также включает
<code>CLIENT_MULTI_RESULTS</code>. Если Вы используете SQL-запрос
<a href="sql.htm#call"><code>CALL</code></a> в Ваших программах,
поддержка многоих результатов должна быть включена, это означает, что
<code>MYSQL_OPTION_MULTI_STATEMENTS_ON</code> отдельно недостаточно, чтобы
разрешить использование <a href="sql.htm#call"><code>CALL</code></a>.
</p>

<h5><a name="idm139965277028880"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965277027728"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_er_unknown_com_error"><code>
ER_UNKNOWN_COM_ERROR</code></a></p>
<p>Сервер не поддерживает
<a href="#mysql-set-server-option"><code>
mysql_set_server_option()</code></a> (это имеет место, если сервер старше
версии 4.1.1) или сервер не поддерживает опцию, которую пытаетесь установить.
</p></li></ul>

<h4><a name="mysql-sqlstate"></a>25.8.7.71. mysql_sqlstate()</h4>
<a class="indexterm" name="idm139965277014240"></a><p>
<code>const char *mysql_sqlstate(MYSQL *mysql)</code></p>

<h5><a name="idm139965277012064"></a>Описание</h5>
<p>Возвращает законченную нулем строку, содержащую код ошибки SQLSTATE для
последнего выполненного SQL-запроса. Код ошибки состоит из пяти символов.
<code>'00000'</code> означает отсутствие ошибки. Значения определены
ANSI SQL и ODBC.</p>

<p>Значения SQLSTATE, возвращенные
<a href="#mysql-sqlstate"><code>mysql_sqlstate()</code>
</a> отличаются от MySQL-специфичных кодов ошибки, возвращенных
<a href="#mysql-errno"><code>mysql_errno()</code></a>.
Например, программа клиента <a href="programs.htm#mysql"><span><strong>mysql
</strong></span></a> выводит на экран ошибки, используя следующий формат, где
<code>1146</code> значение из
<a href="#mysql-errno"><code>mysql_errno()</code></a>, а
<code>'42S02'</code> значение из
<a href="#mysql-sqlstate"><code>mysql_sqlstate()</code>
</a>:
<pre>
shell&gt; <strong><code>SELECT * FROM no_such_table;</code></strong>
ERROR 1146 (42S02): Table 'test.no_such_table' doesn't exist
</pre>

<p>Не все коды ошибок MySQL отображены на коды ошибки SQLSTATE. Значение
<code>'HY000'</code> (general error) используется для
неотображенных кодов ошибки.</p>

<p>Если Вы вызываете
<a href="#mysql-sqlstate"><code>mysql_sqlstate()</code>
</a> после сбоя
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>,
<a href="#mysql-sqlstate"><code>mysql_sqlstate()</code>
</a> не может возвратить полезное значение. Например, это происходит, если
сервер свалился, и соединение закрыто без какого-либо значения
SQLSTATE, посылаемого клиенту.</p>
<h5><a name="idm139965276993648"></a>Возвращаемые значения</h5>
<p>Законченная нулем строка символов, содержащая код ошибки SQLSTATE.</p>

<h4><a name="mysql-ssl-set"></a>25.8.7.72. mysql_ssl_set()</h4>
<p><code>my_bool mysql_ssl_set(MYSQL *mysql, const char *key,
const char *cert, const char *ca, const char *capath, const char *cipher)
</code></p>

<h5><a name="idm139965276985712"></a>Описание</h5>
<p><a href="#mysql-ssl-set"><code>mysql_ssl_set()</code>
</a> используется для того, чтобы создавать безопасные соединения, используя
SSL. Это нужно вызвать прежде, чем
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a>. <a href="#mysql-ssl-set"><code>
mysql_ssl_set()</code></a> ничего не делает, если поддержка SSL
не включена в библиотеке клиента.</p>

<p><code>mysql</code> это дескриптор соединения, возвращенный из
<a href="#mysql-init"><code>mysql_init()</code></a>.
Другие параметры определены следующим образом:</p>

<ul><li><p><code>key</code> путь к файлу ключа.</li>
<li><code>cert</code> путь к файлу сертификата.</li>
<li><code>ca</code> путь к файлу центра сертификации.</li>

<li><code>capath</code> путь к каталогу, который содержит, доверенные
сертификаты SSL CA в формате PEM.</li>
<li><code>cipher</code> список допустимых шифров, чтобы использовать
для шифрования SSL.</p></li></ul>
<p>Любые неиспользованные параметры SSL могут быть заданы как
<code>NULL</code>.</p>

<h5><a name="idm139965276968704"></a>Возвращаемые значения</h5>
<p>Эта функция всегда возвращает <code>0</code>. Если установка SSL является
неправильной,
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a> возвращает ошибку, когда Вы пытаетесь соединиться.</p>

<h4><a name="mysql-stat"></a>25.8.7.73. mysql_stat()</h4>
<a class="indexterm" name="idm139965276964352"></a><p>
<code>const char *mysql_stat(MYSQL *mysql)</code></p>

<h5><a name="idm139965276962192"></a>Описание</h5>
<p>Возвращает строку символов, содержащую информацию, подобную
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin status</strong>
</span></a>. Это включает продолжительность работы в секундах, число
выполняемых потоков, количество запросов, перезагрузок и открытых таблиц.</p>

<h5><a name="idm139965276959648"></a>Возвращаемые значения</h5>
<p>Строка символов, описывающая состояние сервера. <code>NULL</code>,
если ошибка произошла.</p>

<h5><a name="idm139965276957760"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-store-result"></a>25.8.7.74. mysql_store_result()</h4>
<a class="indexterm" name="idm139965276945680"></a><p>
<code>MYSQL_RES *mysql_store_result(MYSQL *mysql)</code></p>

<h5><a name="idm139965276943504"></a>Описание</h5>
<p>После вызова
<a href="#mysql-query"><code>mysql_query()</code></a> или
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a> Вы должны вызвать
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> или <a href="#mysql-use-result"><code>
mysql_use_result()</code></a> для каждого запроса, который успешно производит
набор результатов (<a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#show"><code>SHOW</code></a>,
<a href="sql.htm#describe"><code>DESCRIBE</code></a>,
<a href="sql.htm#explain"><code>EXPLAIN</code></a>,
<a href="sql.htm#check-table"><code>CHECK TABLE</code></a> и т.п.).
Вы должны также вызвать
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a> после того, как Вы завершили работу с набором результатов.</p>

<p>Вы не должны вызывать
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> или
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a> для других запросов, но это не делает ничего плохого, если Вы
вызовете <a href="#mysql-store-result"><code>
mysql_store_result()</code></a> в любом случае. Вы можете обнаружить, есть ли
у запроса набор результатов проверяя, что
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> возвращает ненулевое значение.</p>

<p>Если Вы включаете поддержку многих запросов, Вы должны получить результаты
вызовов <a href="#mysql-query"><code>mysql_query()</code>
</a> или <a href="#mysql-real-query"><code>
mysql_real_query()</code></a>, применяя в цикле
<a href="#mysql-next-result"><code>mysql_next_result()
</code></a>, чтобы определить, есть ли еще результаты.</p>

<p>Если Вы хотите знать, должен ли запрос вообще вернуть набор результатов,
Вы можете использовать <a href="#mysql-field-count">
<code>mysql_field_count()</code></a>.</p>

<p><a href="#mysql-store-result"><code>
mysql_store_result()</code></a> читает весь результат запроса клиенту,
выделяет структуру <code>MYSQL_RES</code> и помещает
результат в эту структуру.</p>

<p><a href="#mysql-store-result"><code>
mysql_store_result()</code></a> возвращает нулевой указатель, если запрос
не возвращал набор результатов (например, если это был
<a href="sql.htm#insert"><code>INSERT</code></a>).</p>

<p><a href="#mysql-store-result"><code>
mysql_store_result()</code></a> также возвращает нулевой указатель, если
набор результатов не может быть прочитан. Вы можете проверить, произошла ли
ошибка, вызовом
<a href="#mysql-error"><code>mysql_error()</code></a>.
Здесь надо проверить, вернет ли этот вызов непустую строку.
<a href="#mysql-errno"><code>mysql_errno()</code></a>
вернет значение, отличное от нуля, или
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a> вернет 0.</p>

<p>Пустой набор результатов возвращен, если нет никаких возвращенных строк.
Пустой набор результатов отличается от нулевого указателя
как возвращаемое значение.</p>

<p>После того, как Вы вызвали
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> и получили результат, который не является нулевым указателем, Вы
можете вызвать <a href="#mysql-num-rows"><code>
mysql_num_rows()</code></a>, чтобы узнать, сколько строк
находится в наборе результатов.</p>

<p>Вы можете вызвать <a href="#mysql-fetch-row"><code>
mysql_fetch_row()</code></a>, чтобы получить строки из набора результатов,
или <a href="#mysql-row-seek"><code>mysql_row_seek()
</code></a> и <a href="#mysql-row-tell"><code>
mysql_row_tell()</code></a>, чтобы получить или установить текущую позицию
строки в пределах набора результатов.</p>

<h5><a name="idm139965276897136"></a>Возвращаемые значения</h5>
<p>Структура <code>MYSQL_RES</code> с результатами. <code>NULL</code> (0),
если ошибка произошла.</p>

<h5><a name="idm139965276894544"></a>Ошибки</h5>
<p><a href="#mysql-store-result"><code>
mysql_store_result()</code></a> сбрасывает
<a href="#mysql-error"><code>mysql_error()</code></a> и
<a href="#mysql-errno"><code>mysql_errno()</code></a>,
если все хорошо.</p>

<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-thread-id"></a>25.8.7.75. mysql_thread_id()</h4>
<a class="indexterm" name="idm139965276875984"></a><p>
<code>unsigned long mysql_thread_id(MYSQL *mysql)</code></p>

<h5><a name="idm139965276873808"></a>Описание</h5>
<p>Возвращает ID потока текущего соединения. Это значение может
использоваться в качестве параметра
<a href="#mysql-kill"><code>mysql_kill()</code></a>,
чтобы уничтожить поток.</p>

<p>Если соединение потеряно, и Вы повторно соединяетесь с
<a href="#mysql-ping"><code>mysql_ping()</code></a>,
ID меняется. Это означает, что Вы не должны получить ID потока и сохранить
его для использования позже. Вы должны получить его, когда это надо.</p>

<p>Эта функция не работает правильно, если ID становятся больше, чем 32
бита, что может произойти на некоторых системах. Чтобы избежать проблем с
<a href="#mysql-thread-id"><code>mysql_thread_id()</code>
</a>, не используйте это. Чтобы получить ID, выполните запрос <code>SELECT
CONNECTION_ID()</code> и получите результат.</p>

<h5><a name="idm139965276866528"></a>Возвращаемые значения</h5>
<p>ID потока для текущего соединения.</p>
<h5><a name="idm139965276865376"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-use-result"></a>25.8.7.76. mysql_use_result()</h4>
<p><code>MYSQL_RES *mysql_use_result(MYSQL *mysql)</code></p>
<h5><a name="idm139965276860864"></a>Описание</h5>
<p>После вызова
<a href="#mysql-query"><code>mysql_query()</code></a> или
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a> Вы должны вызвать
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> или <a href="#mysql-use-result"><code>
mysql_use_result()</code></a> для каждого запроса, который успешно производит
набор результатов (<a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#show"><code>SHOW</code></a>,
<a href="sql.htm#describe"><code>DESCRIBE</code></a>,
<a href="sql.htm#explain"><code>EXPLAIN</code></a>,
<a href="sql.htm#check-table"><code>CHECK TABLE</code></a> и т.п.).
Вы должны также вызвать <a href="#mysql-free-result">
<code>mysql_free_result()</code></a> после завершения
работы с набором результатов.</p>

<p><a href="#mysql-use-result"><code>mysql_use_result()
</code></a> начинает извлечение набора результатов, но фактически не
загружает набор результатов в клиента как
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>. Вместо этого каждая строка должна быть получена индивидуально,
делая запросы <a href="#mysql-fetch-row"><code>
mysql_fetch_row()</code></a>. Это читает результат запроса непосредственно с
сервера, не храня его во временной таблице или местном буфере, который
несколько быстрее, и использует намного меньше памяти, чем
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>. Клиент выделяет память только для текущей строки и
коммуникационного буфера, который может расти до
<a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a> байт.</p>

<p>С другой стороны, Вы не должны использовать
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a> для того, чтобы заблокировать чтения, если Вы делаете большую
обработку для каждой строки на стороне клиента, или если вывод посылаете на
экран, на котором пользователь может нажать <code>^S</code> (stop scroll).
Это связывает сервер и препятствует тому, чтобы другие потоки обновили любые
таблицы, из которых читаются данные.</p>

<p>Используя <a href="#mysql-use-result"><code>
mysql_use_result()</code></a>, Вы должны выполнять
<a href="#mysql-fetch-row"><code>mysql_fetch_row()</code>
</a> до получения значения <code>NULL</code>, иначе непрочитанные строки
будут возвращены как часть набора результатов для Вашего следующего запроса.
C API дает ошибку <code>Commands out of sync; you can't run this command now
</code>, если Вы забываете делать это! Ну и на том спасибо, еще бы молча
вернул не то...</p>

<p>Вы не можете использовать
<a href="#mysql-data-seek"><code>mysql_data_seek()</code>
</a>,
<a href="#mysql-row-seek"><code>mysql_row_seek()</code>
</a>,
<a href="#mysql-row-tell"><code>mysql_row_tell()</code>
</a>,
<a href="#mysql-num-rows"><code>mysql_num_rows()</code>
</a> или <a href="#mysql-affected-rows"><code>
mysql_affected_rows()</code></a> с результатом, возвращенным из
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a> и при этом Вы не можете запустить другие запросы, пока
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a> не закончится. Однако, после того, как Вы получили все строки,
<a href="#mysql-num-rows"><code>mysql_num_rows()</code>
</a> точно возвращает число строк.</p>

<p>Вы должны вызвать <a href="#mysql-free-result"><code>
mysql_free_result()</code></a> как только закончите с набором результатов.
Используя <code>libmysqld</code>, выгода по памяти по существу теряется,
потому что использование памяти не увеличивается с каждой строкой, полученной
от <a href="#mysql-free-result"><code>mysql_free_result()
</code></a>.</p>

<h5><a name="idm139965276818240"></a>Возвращаемые значения</h5>
<p>Структура результата <code>MYSQL_RES</code>. <code>NULL</code>,
если ошибка произошла.</p>

<h5><a name="idm139965276815664"></a>Ошибки</h5>
<p><a href="#mysql-use-result"><code>mysql_use_result()
</code></a> сбрасывает <a href="#mysql-error"><code>
mysql_error()</code></a> и <a href="#mysql-errno"><code>
mysql_errno()</code></a>, если все нормально.</p>

<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync">
<code>CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-warning-count"></a>25.8.7.77. mysql_warning_count()</h4>
<a class="indexterm" name="idm139965276797104"></a><p>
<code>unsigned int mysql_warning_count(MYSQL *mysql)</code></p>

<h5><a name="idm139965276794928"></a>Описание</h5>
<p>Возвращает число ошибок, предупреждений и примечаний во время выполнения
предыдущего SQL-запроса.</p>

<h5><a name="idm139965276792864"></a>Возвращаемые значения</h5>
<p>Количество сгенерированных предупреждений.</p>
<h5><a name="idm139965276791744"></a>Ошибки</h5>
<p>
Нет.
</p>

<h3><a name="c-api-prepared-statements"></a>25.8.8. Подготовленные запросы в
C API</h3>
<p>Протокол клиент-сервер MySQL предусматривает использование готовых
запросов. Эта способность использует структуру данных обработчика <code>
MYSQL_STMT</code>, возвращенную функцией инициализации
<a href="#mysql-stmt-init"><code>mysql_stmt_init()</code>
</a>. Готовое выполнение эффективный способ выполнить запрос не раз. Запрос
сначала разобран, чтобы подготовить его к выполнению. Потом он будет выполнен
один или более раз в более позднее время, используя дескриптор запроса,
возвращенный функцией инициализации.</p>

<p>Готовое выполнение быстрее, чем прямое выполнение для запросов,
выполненных не раз, прежде всего потому что запрос будет разобран только
однажды. В случае прямого выполнения запрос разобран каждый раз, когда
выполнен. Готовое выполнение также может обеспечить сокращение сетевого
трафика, потому что для каждого выполнения готового запроса необходимо
послать только данные для параметров.</p>

<p>Готовые запросы не могли бы обеспечить исполнительное ускорение некоторых
ситуаций. Для лучших результатов проверьте свое приложение с готовыми и с не
готовыми запросами. Ввыберите, что приводит к лучшей работе.</p>

<p>Другое преимущество готовых запросов состоит в том, что это использует
протокол двоичной синхронной передачи данных, который делает передачу данных
между клиентом и сервером более эффективной.</p>

<p>За списком команд SQL, которые могут использоваться в качестве
подготовленных, обратитесь к
<a href="sql.htm#sql-syntax-prepared-statements">разделу 14.5.
Синтаксис подготовленных SQL-запросов</a>.</p>

<p>Метаданные, измененные для таблицы или обзора, связанных с готовым
запросом, будут обнаружены и вызывают автоматическую переподготовку запроса.
Для получения дополнительной информации, см.
<a href="optimiz.htm#statement-caching">раздел 9.10.4. Кэширование
подготовленных запросов и сохраненных процедур</a>.</p>

<h3><a name="c-api-prepared-statement-data-structures"></a>25.8.9. Структуры
данных подготовленных запросов C API</h3>
<p>Готовые запросы используют несколько структур данных:</p>
<ul><li><p>Чтобы получить дескриптор запроса, передайте обработчик соединения
<code>MYSQL</code> в <a href="#mysql-stmt-init"><code>
mysql_stmt_init()</code></a>, которая возвращает указатель на структуру
данных <code>MYSQL_STMT</code>. Эта структура используется для дальнейших
операций с запросом. Чтобы определить запрос передайте указатель на
<code>MYSQL_STMT</code> и строку запроса в
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a>.</li>

<li>Чтобы обеспечить входные параметры для готового запроса, задайте
структуру <code>MYSQL_BIND</code> и передайте ее в
<a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>. Чтобы получить выходные значения
столбцов, надо настроить структуру <code>MYSQL_BIND</code> и передать ее в
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>.</li>

<li>Структура <code>MYSQL_TIME</code> используется, чтобы передать временные
данные в обоих направлениях.</p></li></ul>
<p>Следующее обсуждение описывает готовые типы данных подробно. Для примеров,
которые показывают, как использовать их, см.
<a href="#mysql-stmt-execute">раздел 25.8.11.10.
mysql_stmt_execute()</a> и
<a href="#mysql-stmt-fetch">раздел 25.8.11.11.
mysql_stmt_fetch()</a>.</p>

<ul><li><p><code>MYSQL_STMT</code></p>
<p>Эта структура дескриптор для готового запроса. Дескриптор создается
вызовом <a href="#mysql-stmt-init"><code>
mysql_stmt_init()</code></a>, который возвращает указатель на
<code>MYSQL_STMT</code>. Дескриптор используется для всех последующих
операций с запросом, пока Вы не закрываете это с помощью
<a href="#mysql-stmt-close"><code>mysql_stmt_close()
</code></a>, после чего дескриптор становится недопустимым.</p>

<p>Структура <code>MYSQL_STMT</code> не имеет никаких членов, предназначенных
для использования в приложении. Приложения не должны пытаться скопировать
<code>MYSQL_STMT</code>. Нет никакой гарантии, что такая
копия будет применима.</p>

<p>Несколько дескрипторов запроса могут быть связаны с единственным
соединением. Предел числа дескрипторов зависит от
доступных системных ресурсов.</li>

<li><code>MYSQL_BIND</code></p>
<p>Эта структура используется для ввода (значения данных, посланные серверу)
и вывода (значения результатов с сервера):</p>

<ul><li><p>Для ввода примените структуру <code>MYSQL_BIND</code> с
<a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>, чтобы связать значения данных параметра с
буферами для использования <a href="#mysql-stmt-execute">
<code>mysql_stmt_execute()</code></a>.</li>

<li>Для вывода примените структуру <code>MYSQL_BIND</code> с
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>, чтобы связать буферы со столбцами набора
результатов для использования в строках с
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>.</p></li></ul>

<p>Для использования структуры <code>MYSQL_BIND</code>, обнулите ее
содержание, чтобы инициализировать, а затем установите свои параметры
соответственно. Например, чтобы объявить и инициализировать массив из трех
структур <code>MYSQL_BIND</code>, используйте этот код:
<pre>
MYSQL_BIND bind[3];
memset(bind, 0, sizeof(bind));
</pre>

<p>Структура <code>MYSQL_BIND</code> содержит следующие члены для
использования приложениями. Для нескольких членов манера использования
зависит от того, используется ли структура для ввода или вывода.</p>

<ul><li><p><code>enum enum_field_types buffer_type</code></p>
<p>Тип буфера. Этот член указывает на тип данных переменной языка C,
связанной с параметром запроса или столбцом набора результатов. Для ввода
<code>buffer_type</code> указывает на тип переменной, содержащей значение,
которое будет послано серверу. Для вывода это указывает на тип переменной, в
которую должно быть сохранено значение, полученное от сервера.</li>

<li><code>void *buffer</code></p>
<p>Указатель на буфер, который будет использоваться для передачи данных.
Это адрес переменной языка C.</p>

<p>Для ввода <code>buffer</code> указатель на переменную, в которой Вы
храните значение данных для параметра. Когда Вы вызываете
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>, MySQL использует значение, сохраненное в переменной вместо
соответствующего маркера параметра в запросе (определенного с помощью
<code>?</code> в строке запроса).</p>

<p>Для вывода <code>buffer</code> указатель на переменную, в которой можно
возвратить значение столбца набора результатов. Когда Вы вызываете
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>, MySQL сохранит значение столбца из текущей строки набора
результатов в этой переменной. Вы можете получить доступ к значению,
когда вызов завершается.</p>

<p>Чтобы минимизировать потребность MySQL в преобразованиях типов между
значениями языка C на стороне клиента и значениями SQL на стороне сервера,
используйте переменные C, у которых есть типы, подобные таковым из
соответствующих значений SQL:</p>

<ul><li><p>Для типов числовых данных <code>buffer</code> должен указать на
переменную надлежащего числового типа C. Для переменных целого числа
(которые могут быть <code>char</code> для однобайтовых значений или
integer для больших значений), Вы должны также указать, имеет ли переменная
атрибут <code>unsigned</code>, устанавливая член
<code>is_unsigned</code>, описанный позже.</li>

<li>Для символа (не двоичного) и двоичных типов строковых данных
<code>buffer</code> должен указать на символьный буфер.</li>
<li>Для типов данных даты и времени <code>buffer</code> должен указать на
структуру <code>MYSQL_TIME</code>.</p></li></ul></li>

<li><code>unsigned long buffer_length</code></p>
<p>Фактический размер <code>*buffer</code> в байтах. Это указывает на
максимальный объем данных, который может быть сохранен в буфере. Для символов
и двоичных данных C значение <code>buffer_length</code> определяет длину
<code>*buffer</code>, когда используется с
<a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>, чтобы определить входные значения,
или максимальное количество байтов выходных данных, которые могут быть
внесены в буфер, когда применяется с
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>.</li>

<li><code>unsigned long *length</code></p>
<p>Указатель на переменную <code>unsigned long</code>, которая указывает
на фактическое число байтов данных, хранившихся в <code>*buffer</code>.
<code>length</code> используется для символов или двоичных данных C.</p>

<p>Для входной привязки данных о параметре установите
<code>*length</code>, чтобы указать на фактическую длину значения параметра,
сохраненного в <code>*buffer</code>. Это используется
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>.</p>

<p>Для выходной привязки значения MySQL установит <code>*length</code>, когда
Вы вызовете <a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a>. Возвращаемое значение
<a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a> определяет, как интерпретировать длину:</p>

<ul><li><p>Если возвращаемое значение 0, <code>*length</code>
указывает на фактическую длину значения параметра.</li>
<li>Если возвращаемое значение <code>MYSQL_DATA_TRUNCATED</code>,
<code>*length</code> указывает на неусеченную длину значения параметра. В
этом случае минимум <code>*length</code> и <code>buffer_length</code>
указывает на фактическую длину значения.</p></li></ul>

<p><code>length</code> проигнорирован для числовых и временных типов данных,
потому что значение <code>buffer_type</code> определяет
длину значения данных.</p>

<p>Если Вы должны определить длину возвращенного значения прежде, чем
получите его, см. <a href="#mysql-stmt-fetch">раздел
25.8.11.11. mysql_stmt_fetch()</a>.</li>

<li><code>my_bool *is_null</code></p>
<p>Этот член указывает на переменную <code>my_bool</code>, которая является
истиной, если значение <code>NULL</code> и ложной, если это не
<code>NULL</code>. Для ввода установите <code>*is_null</code> в истину, чтобы
указать, что Вы передаете <code>NULL</code> как параметр запроса.</p>

<p><code>is_null</code> это <span><em>указатель</em></span> на булев скаляр,
а не сам булев скаляр, чтобы обеспечить гибкость в том, как Вы определяете
значения <code>NULL</code>:</p>

<ul><li><p>Если Ваши значения данных всегда <code>NULL</code>, используйте
<code>MYSQL_TYPE_NULL</code> как значение <code>buffer_type</code>, когда Вы
связываете столбец. Другие члены <code>MYSQL_BIND</code>, включая
<code>is_null</code>, при этом не имеют значения.</li>

<li>Если Ваши значения данных всегда <code>NOT NULL</code>, установите
<code>is_null = (my_bool*) 0</code> и задайте другие члены соответственно для
переменной, которую Вы связываете.</li>

<li>Во всех других случаях установите другие члены соответственно и
<code>is_null</code> к адресу переменной <code>my_bool</code>. Установите
значение переменной в истину или ложь соответственно, чтобы указать, является
ли соответствующее значение данных <code>NULL</code> или
<code>NOT NULL</code>.</p></li></ul>

<p>Для вывода когда Вы получаете строку, MySQL устанавливает значение,
которым указывают <code>is_null</code> в истину или ложь согласно тому,
возвратилось ли значение столбца набора результатов <code>NULL</code>
из запроса.</li>

<li><code>my_bool is_unsigned</code></p>
<p>Этот член связывает переменные C с типами данных, которые могут быть
<code>unsigned</code> (<code>char</code>, <code>short int</code>,
<code>int</code>, <code>long long int</code>). Установите
<code>is_unsigned</code> в истину, если переменная, которая указывает на
<code>buffer</code> <code>unsigned</code>. Например, если Вы связываете
переменную <code>signed char</code> с <code>buffer</code>, определите код
типа <code>MYSQL_TYPE_TINY</code> и установите в ложь
<code>is_unsigned</code>. Если Вы связываете
<code>unsigned char</code> код типа тот же, но <code>is_unsigned</code>
должен быть истиной. Для <code>char</code> это не определено.</p>

<p><code>is_unsigned</code> применяется только к переменной языка C на
стороне клиента. Это указывает, что наличие знака соответствующего SQL не
оценивается стороной сервера. Например, если Вы используете переменную
<code>int</code>, чтобы поставлять значение для столбца
<code>BIGINT UNSIGNED</code>, <code>is_unsigned</code> должен быть ложным,
потому что <code>int</code> знаковый тип. Если Вы используете переменную
<code>unsigned int</code>, чтобы поставлять значение для стобца
<a href="types.htm#integer-types"><code>BIGINT</code></a>,
<code>is_unsigned</code> должен быть истиной, потому что
<code>unsigned int</code> тип без знака. MySQL выполняет надлежащее
преобразование между значениями в обоих направлениях, хотя предупреждение
происходит, если результат усекается.</li>

<li><code>my_bool *error</code></p>
<p>Для вывода установите этот член, чтобы указать на переменную
<code>my_bool</code>, чтобы иметь информацию об усечении для параметра,
сохраненного после получения строки. Когда сообщение усечения включено,
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> вернет <code>MYSQL_DATA_TRUNCATED</code> и
<code>*error</code> = true в структуре <code>MYSQL_BIND</code> для
параметров, в которых произошло усечение. Усечение указывает на потерю знака
или существенных цифр, или что строка была слишком длинной, чтобы поместиться
в столбец. Сообщение усечения включено по умолчанию, но может управляться
вызовом <a href="#mysql-options"><code>mysql_options()
</code></a> с опцией <code>MYSQL_REPORT_DATA_TRUNCATION</code>.
</p></li></ul></li>

<li><p><a class="indexterm" name="idm139965276634656"></a>
<code>MYSQL_TIME</code></p>
<p>Эта структура используется, чтобы обмениваться данными типов
<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> и
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>
непосредственно с сервером. Установите <code>buffer</code>, чтобы указать на
структуру <code>MYSQL_TIME</code>, а <code>buffer_type</code> на
<code>MYSQL_BIND</code>, привязанную к одному из временных типов
(<code>MYSQL_TYPE_TIME</code>, <code>MYSQL_TYPE_DATE</code>,
<code>MYSQL_TYPE_DATETIME</code>, <code>MYSQL_TYPE_TIMESTAMP</code>).</p>

<p>Структура <code>MYSQL_TIME</code> содержит члены,
перечисленные в следующей таблице.</p>
<table border="1"><thead><tr><th scope="col">Член</th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><code>unsigned int year</code></td>
<td>Год</td></tr>
<tr><td scope="row"><code>unsigned int month</code></td>
<td>Месяц года</td></tr>
<tr><td scope="row"><code>unsigned int day</code></td>
<td>День месяца</td></tr>
<tr><td scope="row"><code>unsigned int hour</code></td>
<td>Час дня</td></tr>
<tr><td scope="row"><code>unsigned int minute</code></td>
<td>Минута часа</td></tr>
<tr><td scope="row"><code>unsigned int second</code></td>
<td>Секунда минуты</td></tr>
<tr><td scope="row"><code>my_bool neg</code></td>
<td>Булев флаг, указывающий, отрицательно ли время</td></tr>
<tr><td scope="row"><code>unsigned long second_part</code></td>
<td>Дробная часть секунды в микросекундах</td></tr></tbody></table>

<p>Только те части структуры <code>MYSQL_TIME</code>, которые относятся к
данному типу временного значения, используется. Элементы
<code>year</code>, <code>month</code> и <code>day</code> используются для
значений <a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a>, и
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>. Элементы
<code>hour</code>, <code>minute</code> и <code>second</code>
используются для значений
<a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> и
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>.</p></li></ul>

<h4><a name="c-api-prepared-statement-type-codes"></a>25.8.9.1. Коды типа
подготовленных запросов C API</h4>
<p>Член <code>buffer_type</code> структуры <code>MYSQL_BIND</code> указывает
тип данных переменной языка C, связанной с параметром запроса или столбцом
набора результатов. Для ввода <code>buffer_type</code> указывает на тип
переменной, содержащей значение, которое будет послано серверу. Для вывода
это указывает на тип переменной, в которую должно быть сохранено значение,
полученное от сервера.</p>

<p>Следующая таблица показывает допустимые значения для члена
<code>buffer_type</code> структуры <code>MYSQL_BIND</code> для входных
значений, посланных серверу. Таблица показывает типы переменных C, которые Вы
можете использовать, соответствующие коды типа и типы данных SQL, для которых
поставляемое значение может использоваться без преобразования. Выберите
значение <code>buffer_type</code> согласно типу данных переменной языка C,
которую Вы связываете. Для типов целого числа Вы должны также установить
член <code>is_unsigned</code>, чтобы указать со знаком число или без него.
</p>

<table border="1"><thead><tr><th scope="col">Тип входной переменной на C</th>
<th scope="col">Значение <code>buffer_type</code></th>
<th scope="col">SQL-тип целевого значения</th></tr></thead>
<tbody><tr><td scope="row"><code>signed char</code></td>
<td><code>MYSQL_TYPE_TINY</code></td>
<td><a href="types.htm#integer-types"><code>TINYINT</code></a></td></tr>
<tr><td scope="row"><code>short int</code></td>
<td><code>MYSQL_TYPE_SHORT</code></td>
<td><a href="types.htm#integer-types"><code>SMALLINT</code>
</a></td></tr>
<tr><td scope="row"><code>int</code></td><td><code>MYSQL_TYPE_LONG</code>
</td><td><a href="types.htm#integer-types"><code>INT</code>
</a></td></tr>
<tr><td scope="row"><code>long long int</code></td>
<td><code>MYSQL_TYPE_LONGLONG</code></td>
<td><a href="types.htm#integer-types"><code>BIGINT</code></a></td></tr>
<tr><td scope="row"><code>float</code></td><td><code>MYSQL_TYPE_FLOAT</code>
</td><td><a href="types.htm#floating-point-types"><code>FLOAT</code>
</a></td></tr>
<tr><td scope="row"><code>double</code></td><td><code>MYSQL_TYPE_DOUBLE
</code></td><td><a href="types.htm#floating-point-types"><code>DOUBLE
</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TIME</code></td><td><code>MYSQL_TYPE_TIME
</code></td><td><a href="types.htm#time"><code>TIME</code></a></td></tr>
<tr><td scope="row"><code>MYSQL_TIME</code></td><td><code>MYSQL_TYPE_DATE
</code></td><td><a href="types.htm#datetime"><code>DATE</code>
</a></td></tr>
<tr><td scope="row"><code>MYSQL_TIME</code></td><td><code>MYSQL_TYPE_DATETIME
</code></td><td><a href="types.htm#datetime"><code>DATETIME</code>
</a></td></tr>
<tr><td scope="row"><code>MYSQL_TIME</code></td><td><code>
MYSQL_TYPE_TIMESTAMP</code></td><td><a href="types.htm#datetime"><code>
TIMESTAMP</code></a></td></tr>
<tr><td scope="row"><code>char[]</code></td><td><code>MYSQL_TYPE_STRING
</code></td><td><a href="types.htm#blob"><code>TEXT</code></a>,
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a></td></tr>
<tr><td scope="row"><code>char[]</code></td><td><code>MYSQL_TYPE_BLOB</code>
</td><td><a href="types.htm#blob"><code>BLOB</code></a>,
<a href="types.htm#binary-varbinary"><code>BINARY</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code>
</a></td></tr>
<tr><td scope="row"></td><td><code>MYSQL_TYPE_NULL</code></td>
<td><code>NULL</code></td></tr></tbody></table>

<p>Используйте <code>MYSQL_TYPE_NULL</code> как обозначено в описании для
<code>is_null</code> в
<a href="#c-api-prepared-statement-data-structures">
разделе 25.8.9. Структуры данных подготовленных запросов C API</a>.</p>

<p>Для входных строковых данных, используйте <code>MYSQL_TYPE_STRING</code>
или <code>MYSQL_TYPE_BLOB</code> в зависимости от того, является ли значение
символьной или двоичной строкой:</p>

<ul><li><p><code>MYSQL_TYPE_STRING</code> указывает на строковые данные.
Значение, как предполагается, находится в наборе символов, обозначенном в
системной переменной
<a href="server.htm#sysvar_character_set_client"><code>
character_set_client</code></a>. Если сервер сохранит значение в столбец с
иным набором символов, он преобразовывает значение в тот набор символов.</li>

<li><code>MYSQL_TYPE_BLOB</code> указывает на двоичные строковые данные.
Значение обработано как набор символов <code>binary</code>. Таким образом,
это обработано как строка байт и никакое преобразование не происходит.
</p></li></ul>

<p>Следующая таблица показывает допустимые значения для
<code>buffer_type</code> структуры <code>MYSQL_BIND</code> для выходных
значений, полученных от сервера. Таблица показывает типы SQL полученных
значений, соответствующие коды типа, что такие значения имеют в метаданных о
наборе результатов и рекомендуемые типы данных языка C, чтобы связать со
структурой <code>MYSQL_BIND</code>, чтобы получить значения SQL без
преобразования. Выберите значение <code>buffer_type</code> согласно типу
данных переменной языка C, которую Вы связываете. Для типов целого числа Вы
должны также установить член <code>is_unsigned</code>, чтобы указать
наличие признака знака числа.</p>

<table border="1"><thead><tr><th scope="col">SQL-тип полученного значения
</th>
<th scope="col">Значение <code>buffer_type</code></th>
<th scope="col">Тип выходной переменной C</th></tr></thead>
<tbody><tr><td scope="row"><a href="types.htm#integer-types">
<code>TINYINT</code></a></td><td><code>MYSQL_TYPE_TINY</code></td>
<td><code>signed char</code></td></tr>
<tr><td scope="row"><a href="types.htm#integer-types"><code>SMALLINT
</code></a></td><td><code>MYSQL_TYPE_SHORT</code></td>
<td><code>short int</code></td></tr>
<tr><td scope="row"><a href="types.htm#integer-types">
<code>MEDIUMINT</code></a></td><td><code>MYSQL_TYPE_INT24</code></td>
<td><code>int</code></td></tr>
<tr><td scope="row"><a href="types.htm#integer-types"><code>INT</code>
</a></td><td><code>MYSQL_TYPE_LONG</code></td><td><code>int</code></td></tr>
<tr><td scope="row"><a href="types.htm#integer-types"><code>BIGINT
</code></a></td><td><code>MYSQL_TYPE_LONGLONG</code></td>
<td><code>long long int</code></td></tr>
<tr><td scope="row"><a href="types.htm#floating-point-types"><code>
FLOAT</code></a></td><td><code>MYSQL_TYPE_FLOAT</code></td>
<td><code>float</code></td></tr>
<tr><td scope="row"><a href="types.htm#floating-point-types"><code>
DOUBLE</code></a></td><td><code>MYSQL_TYPE_DOUBLE</code></td><td><code>
double</code></td></tr>
<tr><td scope="row"><a href="types.htm#fixed-point-types"><code>DECIMAL
</code></a></td><td><code>MYSQL_TYPE_NEWDECIMAL</code></td>
<td><code>char[]</code></td></tr>
<tr><td scope="row"><a href="types.htm#year"><code>YEAR</code></a></td>
<td><code>MYSQL_TYPE_SHORT</code></td><td><code>short int</code></td></tr>
<tr><td scope="row"><a href="types.htm#time"><code>TIME</code></a></td>
<td><code>MYSQL_TYPE_TIME</code></td><td><code>MYSQL_TIME</code></td></tr>
<tr><td scope="row"><a href="types.htm#datetime"><code>DATE</code></a>
</td>
<td><code>MYSQL_TYPE_DATE</code></td><td><code>MYSQL_TIME</code></td></tr>
<tr><td scope="row"><a href="types.htm#datetime"><code>DATETIME</code>
</a></td><td><code>MYSQL_TYPE_DATETIME</code></td>
<td><code>MYSQL_TIME</code></td></tr>
<tr><td scope="row"><a href="types.htm#datetime"><code>TIMESTAMP</code>
</a></td><td><code>MYSQL_TYPE_TIMESTAMP</code></td>
<td><code>MYSQL_TIME</code></td></tr>
<tr><td scope="row"><a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>BINARY</code></a></td>
<td><code>MYSQL_TYPE_STRING</code></td><td><code>char[]</code></td></tr>
<tr><td scope="row"><a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a></td>
<td><code>MYSQL_TYPE_VAR_STRING</code></td><td><code>char[]</code></td></tr>
<tr><td scope="row"><a href="types.htm#blob"><code>TINYBLOB</code></a>,
<a href="types.htm#blob"><code>TINYTEXT</code></a></td>
<td><code>MYSQL_TYPE_TINY_BLOB</code></td><td><code>char[]</code></td></tr>
<tr><td scope="row"><a href="types.htm#blob"><code>BLOB</code></a>,
<a href="types.htm#blob"><code>TEXT</code></a></td><td><code>
MYSQL_TYPE_BLOB</code></td><td><code>char[]</code></td></tr>
<tr><td scope="row"><a href="types.htm#blob"><code>MEDIUMBLOB</code>
</a>, <a href="types.htm#blob"><code>MEDIUMTEXT</code></a></td>
<td><code>MYSQL_TYPE_MEDIUM_BLOB</code></td><td><code>char[]</code></td></tr>
<tr><td scope="row"><a href="types.htm#blob"><code>LONGBLOB</code></a>,
<a href="types.htm#blob"><code>LONGTEXT</code></a></td>
<td><code>MYSQL_TYPE_LONG_BLOB</code></td><td><code>char[]</code></td></tr>
<tr><td scope="row"><a href="types.htm#bit-type"><code>BIT</code></a>
</td><td><code>MYSQL_TYPE_BIT</code></td><td><code>char[]</code></td>
</tr></tbody></table>

<h4><a name="c-api-prepared-statement-type-conversions"></a>25.8.9.2.
Преобразования типа готовых запросов в C API</h4>
<p>Готовые запросы передают данные между клиентом и сервером, используя
переменные языка C на стороне клиента, которые соответствуют значениям SQL на
стороне сервера. Если есть несоответствие между типом C на стороне клиента
и соответствующим типом значения SQL на стороне сервера, MySQL выполняет
неявные преобразования типа в обоих направлениях.</p>

<p>MySQL знает код типа для значения SQL на стороне сервера. Значение
<code>buffer_type</code> в структуре <code>MYSQL_BIND</code> указывает на код
типа переменной C, которая содержит значение на стороне клиента. Два кода
вместе говорят MySQL, какое преобразование должно быть выполнено, если надо.
Вот некоторые примеры:</p>

<ul><li><p>Если Вы используете <code>MYSQL_TYPE_LONG</code> с переменной
<code>int</code>, чтобы передать целочисленное значение серверу, которое
должен быть сохранен в столбце
<a href="types.htm#floating-point-types"><code>FLOAT</code></a>,
MySQL преобразовывает значение в формат с плавающей запятой прежде,
чем сохранить это.</li>

<li>Если Вы получаете значение столбца типа SQL
<a href="types.htm#integer-types"><code>MEDIUMINT</code></a>, но
<code>buffer_type</code> определен как <code>MYSQL_TYPE_LONGLONG</code> и
используется C-переменная типа <code>long long int</code> как целевой буфер,
MySQL преобразовывает значение <a href="types.htm#integer-types">
<code>MEDIUMINT</code></a> (которое требует меньше, чем 8 байтов) для
хранения в <code>long long int</code> (8-байтовая переменная).</li>

<li>Если Вы получаете числовой столбец со значением 255 в символьный массив
<code>char[4]</code> и <code>buffer_type</code> определен как
<code>MYSQL_TYPE_STRING</code>, получающееся значение в массиве будет
4-байтовой строкой <code>'255\0'</code>.</li>

<li>MySQL возвращает значения <a href="types.htm#fixed-point-types">
<code>DECIMAL</code></a> как строковое представление оригинального
серверного значения соответствующего типу C <code>char[]</code>. Например,
<code>12.345</code> возвращен клиенту как <code>'12.345'</code>.
Если Вы определяете <code>MYSQL_TYPE_NEWDECIMAL</code> и связываете строковый
буфер со структурой <code>MYSQL_BIND</code>,
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> сохранит значение в буфере как строку без преобразования.
Если вместо этого Вы определяете числовую переменную и код типа,
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> преобразовывает строковый формат
<a href="types.htm#fixed-point-types">
<code>DECIMAL</code></a> в числовую форму.</li>

<li>Для кодов типа <code>MYSQL_TYPE_BIT</code> значения
<a href="types.htm#bit-type"><code>BIT</code></a>
значения возвращены в строковый буфер, который соответствует типу C
<code>char[]</code>. Значение представляет битовые строки, которые требуют
интерпретации на стороне клиента. Чтобы возвратить значение как тип, который
легче обработать Вы можете транслировать значение к целому числу,
используя любой из следующих типов выражений:
<pre>
SELECT bit_col + 0 FROM t
SELECT CAST(bit_col AS UNSIGNED) FROM t
</pre>

<p>Чтобы получить значение, свяжите переменную целого числа, достаточно
большую, чтобы содержать это значение, и определите соответствующий код
типа целого числа.</p></li></ul>

<p>Перед обязательными переменными структуры <code>MYSQL_BIND</code>,
которые должны использоваться для того, чтобы принести значения столбцов, Вы
можете проверить коды типа на каждый столбец набора результатов. Это может
быть желательно, если Вы хотите определить, какие типы переменных были бы
лучше, чтобы избежать преобразований типа. Чтобы получить коды типа,
вызовите
<a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a> после выполнения готового запроса с
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>. Метаданные обеспечивают доступ к кодам типа для набора
результатов как описано в
<a href="#mysql-stmt-result-metadata">разделе 25.8.11.23.
mysql_stmt_result_metadata()</a> и
<a href="#c-api-data-structures">разделе 25.8.5.
Структуры данных C API</a>.</p>

<p>Чтобы определить, содержат ли выведенные строковые значения в наборе
результатов с сервера двоичные данные проверьте, равно ли значение
<code>charsetnr</code> метаданных о наборе результатов 63. Если это так,
набор символов <code>binary</code>, который указывает на двоичные данные. Это
позволяет Вам отличить тип <a href="types.htm#binary-varbinary"><code>
BINARY</code></a> от <a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a> от
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>BLOB</code></a> от
<a href="types.htm#blob"><code>TEXT</code></a>.</p>

<p>Если Вы устанавливаете член <code>max_length</code> метаструктуры данных
<code>MYSQL_FIELD</code> столбца (вызовом
<a href="#mysql-stmt-attr-set"><code>
mysql_stmt_attr_set()</code></a>), знайте что значения
<code>max_length</code> для набора результатов указывают на размер
самого длинного строкового, а не двоичного представления значений результата.
Таким образом, <code>max_length</code> не обязательно соответствует размеру
буфера, который должен был принести значения с протоколом двоичной синхронной
передачи данных, используемым для готовых запросов. Выберите размер буферов
согласно типам переменных, в которые Вы сохраняете значения. Например,
столбец <code>TINYINT</code>, содержащий значение -128, может иметь значение
<code>max_length</code> 4. Но двойное представление любого
<code>TINYINT</code> требует только 1 байт для хранения, таким образом, Вы
можете задействовать переменную <code>signed char</code>, в которой можно
сохранить значение и установить <code>is_unsigned</code>, чтобы указать, что
значения со знаком.</p>

<p>Метаданные измененные для таблиц или обзоров, упомянутых готовыми
запросами, обнаружены и вызывают автоматическую переподготовку запроса, когда
он затем выполнен.</p>

<h3><a name="c-api-prepared-statement-function-overview"></a>25.8.10.
Обзор функций C API для подготовленных запросов</h3>
<p>Функции, доступные для готовой обработки запроса обобщены здесь и описаны
более подробно в позже.</p>

<table border="1"><thead><tr><th scope="col">Функция</th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row">
<a href="#mysql-stmt-affected-rows">
<code>mysql_stmt_affected_rows()</code></a></td>
<td>Возвращает число строк измененных, удаленных или вставленных запросом
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#insert"><code>INSERT</code></a>.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-attr-get"><code>
mysql_stmt_attr_get()</code></a></td>
<td>Получает значение признака для готового запроса.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-attr-set"><code>
mysql_stmt_attr_set()</code></a></td>
<td>Задает значение признака для готового запроса.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-bind-param">
<code>mysql_stmt_bind_param()</code></a></td>
<td>Связывает буфера данных приложения с маркерами параметра в
готовом запросе SQL.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-bind-result">
<code>mysql_stmt_bind_result()</code></a></td>
<td>Связывает буфера данных приложения со столбцами в наборе результатов.
</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-close"><code>
mysql_stmt_close()</code></a></td>
<td>Освобождает используемую память.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-data-seek">
<code>mysql_stmt_data_seek()</code></a></td>
<td>Переходит на произвольный номер строки в наборе результатов.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-errno"><code>
mysql_stmt_errno()</code></a></td>
<td>Возвращает код ошибки для последнего выполнения запроса.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-error"><code>
mysql_stmt_error()</code></a></td>
<td>Возвращает сообщение об ошибке для последнего выполнения запроса.</td>
</tr>
<tr><td scope="row"><a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a></td>
<td>Выполняет готовый запрос.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a></td>
<td>Приносит следующую строку данных из набора результатов и возвращает
данные для всех связанных столбцов.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-fetch-column">
<code>mysql_stmt_fetch_column()</code></a></td>
<td>Получает данные для одного столбца текущей строки набора результатов.
</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-field-count">
<code>mysql_stmt_field_count()</code></a></td>
<td>Возвращает число столбцов результата для нового запроса.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-free-result">
<code>mysql_stmt_free_result()</code></a></td>
<td>Освобождает ресурсы, выделенные дескриптору запроса.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-init"><code>
mysql_stmt_init()</code></a></td>
<td>Выделяет память для структуры <code>MYSQL_STMT</code> и инициализирует ее.
</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-insert-id">
<code>mysql_stmt_insert_id()</code></a></td>
<td>Возвращает ID, произведенное для столбца
<code>AUTO_INCREMENT</code> готовым запросом.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-next-result">
<code>mysql_stmt_next_result()</code></a></td>
<td>Возвращает/начинает следующий результат, если результатов несколько.
</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-num-rows"><code>
mysql_stmt_num_rows()</code></a></td>
<td>Возвращает количество строк из буферизованного набора результатов запроса.
</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-param-count">
<code>mysql_stmt_param_count()</code></a></td>
<td>Возвращает число параметров в готовом запросе.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-param-metadata">
<code>mysql_stmt_param_metadata()</code></a></td>
<td>Эта функция ничего не делает.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-prepare">
<code>mysql_stmt_prepare()</code></a></td>
<td>Готовит строку запроса SQL к выполнению.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-reset"><code>
mysql_stmt_reset()</code></a></td>
<td>Сбрасывает буферы запроса в сервере.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-result-metadata">
<code>mysql_stmt_result_metadata()</code></a></td>
<td>Возвращает подготовленные метаданные о запросе в форме набора результатов.
</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-row-seek"><code>
mysql_stmt_row_seek()</code></a></td>
<td>Переходит на смещение строки в наборе результатов, используя значение
возвращенное из <a href="#mysql-stmt-row-tell"><code>
mysql_stmt_row_tell()</code></a>.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-row-tell">
<code>mysql_stmt_row_tell()</code></a></td>
<td>Возвращает позицию курсора строки запроса.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-send-long-data">
<code>mysql_stmt_send_long_data()</code></a></td>
<td>Посылает длинные данные в кусках серверу.</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-sqlstate">
<code>mysql_stmt_sqlstate()</code></a></td>
<td>Возвращает код ошибки SQLSTATE для последнего выполнения запроса.
</td></tr>
<tr><td scope="row"><a href="#mysql-stmt-store-result">
<code>mysql_stmt_store_result()</code></a></td>
<td>Получает полный набор результатов.</td></tr></tbody></table>

<p>Вызовите
<a href="#mysql-stmt-init"><code>mysql_stmt_init()</code>
</a>, чтобы создать дескриптор заявления, затем
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a>, чтобы подготовить строку, снабдите ее данными для параметров
через <a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a> и выполните с помощью
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>. Вы можете повторить
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> изменяя параметры в соответствующих буферах, поставляемых через
<a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>.</p>

<p>Вы можете послать текст или двоичные данные в кусках серверу, используя
<a href="#mysql-stmt-send-long-data"><code>
mysql_stmt_send_long_data()</code></a>.</p>

<p>Если запрос <a href="sql.htm#select"><code>SELECT</code></a>
или любой другой, который производит набор результатов,
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a> также возвращает информацию о метаданных о наборе результатов в
форме набора результатов <code>MYSQL_RES</code> через
<a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a>.</p>

<p>Вы можете работать с буферами результатов через
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a> так, чтобы
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> автоматически возвращал данные в них.</p>

<p>Когда выполнение запроса было завершено, закройте использование
дескриптора запроса с помощью
<a href="#mysql-stmt-close"><code>mysql_stmt_close()
</code></a>, чтобы могли быть освобождены все ресурсы, связанные с ним.</p>

<p>Если Вы получили метаданные о наборе результатов запроса
<a href="sql.htm#select"><code>SELECT</code></a> через
<a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a>, Вы должны также
освободить метаданные, используя
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a>.</p>

<h4><a name="idm139965276258320"></a>Шаги выполнения</h4>
<p>Чтобы подготовить и выполнить запрос, надо:</p>
<ol type="1"><li><p>Создайте готовый дескриптор запроса с помощью
<a href="#mysql-stmt-init"><code>mysql_stmt_init()</code>
</a>. Чтобы подготовить запрос на сервере, вызовите
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a> и передайте этой функции строку, содержащую запрос SQL.</li>

<li>Если запрос произведет набор результатов, вызовите
<a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a>, чтобы получить метаданные о наборе
результатов. Эти метаданные находятся самостоятельно в форме набора
результатов, хотя и отдельно от того, который содержит строки, возвращенные
запросом. Набор результатов метаданных указывает, сколько столбцов находится
в результате и содержит информацию о каждом столбце.</li>

<li>Установите значения любых параметров, используя
<a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>. Все параметры должны быть установлены.
Иначе выполнение запроса возвращает ошибку или
приводит к неожиданным результатам.</li>

<li>Вызовите <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a>, чтобы выполнить запрос.</li>
<li>Если запрос производит набор результатов, используйте связанные буферы
данных для того, чтобы получить значения строк, вызывая
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>.</li>

<li>Получите построчно данные в буферы, вызывая
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> циклично, пока строки не кончатся.</li>
<li>Повторите шаги 3-6 по мере необходимости, изменяя значения параметров и
повторно выполняя запрос.</p></li></ol>

<p>Когда <a href="#mysql-stmt-prepare"><code>
mysql_stmt_prepare()</code></a> вызван, протокол клиент-сервер MySQL
выполняет эти действия:</p>

<ul><li><p>Сервер разбирает запрос и посылает состояние okay назад клиенту,
назначая ID запроса. Это также посылает общее количество параметров,
количество столбцов и их метаданные, если это набор результатов. Весь
синтаксис и семантика запроса проверены сервером во время этого требования.
</li>
<li>Клиент использует это ID для дальнейших операций, чтобы сервер мог
идентифицировать запрос.</p></li></ul>

<p>Когда <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a> вызван, протокол клиент-сервер MySQL
выполняет эти действия:</p>

<ul><li><p>Клиент использует дескриптор запроса и посылает
данные о параметрах серверу.</li>
<li>Сервер идентифицирует запрос, используя ID, обеспеченное клиентом,
заменяет маркеры параметров данными и выполняет запрос. Если запрос
производит набор результатов, сервер отсылает данные назад клиенту. Иначе это
посылает состояние okay и число строк, которые изменились,
удалились или вставились.</p></li></ul>

<p>Когда <a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a> вызван, протокол клиент-сервер MySQL
выполняет эти действия:</p>

<ul><li><p>Клиент читает данные из текущей строки набора результатов и
помещает их в буферы данных приложения, делая необходимые преобразования.
Если буферный тип приложения тот же самый, что и возвращенный из поля данных
сервера, преобразования являются прямыми.</p></li></ul>

<p>Если ошибка происходит, Вы можете получить код ошибки, сообщение об
ошибке и код SQLSTATE, используя функции
<a href="#mysql-stmt-errno"><code>mysql_stmt_errno()
</code></a>,
<a href="#mysql-stmt-error"><code>mysql_stmt_error()
</code></a> и
<a href="#mysql-stmt-sqlstate"><code>
mysql_stmt_sqlstate()</code></a> соответственно.</p>

<h4><a name="idm139965276225024"></a>Протоколирование подготовленных запросов
</h4>
<p>Для готовых запросов, которые выполнены с помощью функций C API
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a> и <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a> сервер пишет строки <code>Prepare</code> и
<code>Execute</code> в общий журнал регистрации запросов, чтобы Вы могли
сказать, когда запрос был подготовлен и выполнен.</p>

<p>Предположите, что Вы готовите и выполняете запрос следующим образом:</p>
<ol type="1"><li><p>Вызываете
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a> для подготовки строки <code>"SELECT ?"</code>.</li>

<li>Вызываете <a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>, чтобы привязать значение
<code>3</code> к параметру в готовом запросе.</li>
<li>Вызываете <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a> для выполнения запроса.</p></li></ol>

<p>В результате предыдущих действий сервер пишет следующие строки в
общий журнал запросов:
<pre>
Prepare  [1] SELECT ?
Execute  [1] SELECT 3
</pre>

<p>Каждая строка <code>Prepare</code> и <code>Execute</code> в журнале
тегирована идентификатором <code>[<em><code>N</code></em>]</code> запроса,
чтобы Вы могли отследить, из которого подготовленного запроса регистрируется
что-либо. <em><code>N</code></em> положительное целое число. Если есть много
подготовленных запросов, активных одновременно для клиента,
<em><code>N</code></em> может быть больше, чем 1. Каждая строка
<code>Execute</code> показывает готовый запрос после замены значений
данными для параметра <code>?</code>.</p>

<h3><a name="c-api-prepared-statement-functions"></a>25.8.11. Описание
функций подготовленных запросов в C API</h3>
<p>Чтобы подготовить и выполнить запросы, используйте функции, описанные
подробно в следующих разделах.</p>

<p>Все функции, которые работают со структурой <code>MYSQL_STMT</code>,
начинаются с префикса <code>mysql_stmt_</code>. Чтобы создать дескриптор,
<code>MYSQL_STMT</code> используйте функцию
<a href="#mysql-stmt-init"><code>mysql_stmt_init()</code>
</a>.</p>

<h4><a name="mysql-stmt-affected-rows"></a>25.8.11.1.
mysql_stmt_affected_rows()</h4>
<p><code>my_ulonglong mysql_stmt_affected_rows(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965276194624"></a>Описание</h5>
<p><a href="#mysql-stmt-affected-rows"><code>
mysql_stmt_affected_rows()</code></a> может быть вызвана немедленно после
выполнения запроса с помощью
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>. Это схоже с вызовом
<a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a>, но для готовых запросов.</p>

<h5><a name="idm139965276188944"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965276187840"></a>Пример</h5>
<p>См. пример в <a href="#mysql-stmt-execute">разделе
25.8.11.10. mysql_stmt_execute()</a>.</p>

<h4><a name="mysql-stmt-attr-get"></a>25.8.11.2. mysql_stmt_attr_get()</h4>
<a class="indexterm" name="idm139965276184816"></a><p>
<code>my_bool mysql_stmt_attr_get(MYSQL_STMT *stmt, enum
enum_stmt_attr_type option, void *arg)</code></p>

<h5><a name="idm139965276182592"></a>Описание</h5>
<p>Может использоваться, чтобы получить текущее значение признака запроса.
Аргумент <code>option</code> это опция, которую Вы хотите получить,
<code>arg</code> должен указать на переменную, которая должна содержать
значение опции. Если опция целое число, <code>arg</code> должен указать на
значение целого числа.</p>

<h5><a name="idm139965276177552"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличное от нуля, если <code>option</code> неизвестно.
</p>
<h5><a name="idm139965276175728"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-attr-set"></a>25.8.11.3. mysql_stmt_attr_set()</h4>
<p><code>my_bool mysql_stmt_attr_set(MYSQL_STMT *stmt, enum
enum_stmt_attr_type option, const void *arg)</code></p>

<h5><a name="idm139965276171168"></a>Описание</h5>
<p>Может использоваться, чтобы управлять поведением готового запроса. Эта
функция может быть вызвана многократно, чтобы установить несколько опций.</p>

<p>Параметр <code>option</code> это опция, которую Вы хотите установить.
<code>arg</code> значение для опции. <code>arg</code> должен указать на
переменную, которая установлена в желаемое значение атрибута. Тип переменной
обозначен в следующей таблице.</p>

<table border="1"><thead><tr><th scope="col">Опция</th>
<th scope="col">Тип аргумента</th><th scope="col">Действие</th></tr></thead>
<tbody><tr><td scope="row"><code>STMT_ATTR_UPDATE_MAX_LENGTH</code></td>
<td><code>my_bool *</code></td><td>Если установлено в 1,
<a href="#mysql-stmt-store-result">
<code>mysql_stmt_store_result()</code></a> обновит в метаданных значение
<code>MYSQL_FIELD-&gt;max_length</code>.</td></tr>
<tr><td scope="row"><code>STMT_ATTR_CURSOR_TYPE</code></td>
<td><code>unsigned long *</code></td><td>Тип курсора для запроса, когда
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> вызван. <code>*arg</code> может быть
<code>CURSOR_TYPE_NO_CURSOR</code> (по умолчанию) или
<code>CURSOR_TYPE_READ_ONLY</code>.</td></tr>
<tr><td scope="row"><code>STMT_ATTR_PREFETCH_ROWS</code></td>
<td><code>unsigned long *</code></td>
<td>Число строк для передачи от сервера во время использования курсора.
<code>*arg</code> может быть в диапазоне от 1 до максимального значения
<code>unsigned long</code>. Значение по умолчанию 1.</td></tr></tbody></table>

<p>Если Вы используете опцию <code>STMT_ATTR_CURSOR_TYPE</code> с
<code>CURSOR_TYPE_READ_ONLY</code>, курсор открыт для запроса, когда Вы
вызываете <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a>. Если уже есть открытый курсор от предыдущего
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>, это закрывает курсор прежде, чем открыть новый.
<a href="#mysql-stmt-reset"><code>mysql_stmt_reset()
</code></a> также закрывает любой открытый курсор прежде, чем подготовить
запрос к повторному выполнению.
<a href="#mysql-stmt-free-result"><code>
mysql_stmt_free_result()</code></a> закроет любой открытый курсор.</p>

<p>Если Вы открываете курсор для готового за запроса,
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a> не нужна, потому что та
функция буферизует набор результатов на стороне клиента.</p>

<h5><a name="idm139965276135664"></a>Возвращаемые значения</h5>
<p>Ноль для успеха. Отличное от нуля, если неизвестно <code>option</code>.</p>
<h5><a name="idm139965276133808"></a>Ошибки</h5>
<p>
Нет.
</p>

<h5><a name="idm139965276132704"></a>Пример</h5>
<p>Следующий пример открывает курсор для готового запроса и определяет число
возвращаемых за один раз строк в 5:

<pre>
MYSQL_STMT *stmt;
int rc;
unsigned long type;
unsigned long prefetch_rows = 5;

stmt = mysql_stmt_init(mysql);
type = (unsigned long) CURSOR_TYPE_READ_ONLY;
rc = mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &amp;type);
/* ... check return value ... */
rc = mysql_stmt_attr_set(stmt, STMT_ATTR_PREFETCH_ROWS,
     (void*) &amp;prefetch_rows);
/* ... check return value ... */
</pre>

<h4><a name="mysql-stmt-bind-param"></a>25.8.11.4. mysql_stmt_bind_param()
</h4>
<a class="indexterm" name="idm139965276129120"></a><p>
<code>my_bool mysql_stmt_bind_param(MYSQL_STMT *stmt,
MYSQL_BIND *bind)</code></p>

<h5><a name="idm139965276126912"></a>Описание</h5>
<p><a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a> используется, чтобы связать входные данные
для маркеров параметра в запросе SQL, который передан
<a href="#mysql-stmt-prepare"><code>
mysql_stmt_prepare()</code></a>. Это использует структуру
<code>MYSQL_BIND</code>, чтобы снабдить данными. <code>bind</code> адрес
массива структур <code>MYSQL_BIND</code>. Библиотека клиента ожидает, что
массив будет содержать один элемент для каждого маркер параметра
<code>?</code>, который присутствует в запросе.</p>

<p>Предположите, что Вы готовите следующий запрос:
<pre>
INSERT INTO mytbl VALUES(?,?,?)
</pre>

<p>Когда Вы связываете параметры, массив структур <code>MYSQL_BIND</code>
должен содержать три элемента, которые могут быть объявлены так:
<pre>
MYSQL_BIND bind[3];
</pre>

<h5><a name="idm139965276115216"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965276114064"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_unsupported_param_type">
<code>CR_UNSUPPORTED_PARAM_TYPE</code></a></p>
<p>Преобразование не поддерживается. Возможно, значение
<code>buffer_type</code> недопустимо или не является одним
из поддерживаемых типов.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h5><a name="idm139965276104736"></a>Пример</h5>
<p>См. пример в <a href="#mysql-stmt-execute">разделе
25.8.11.10. mysql_stmt_execute()</a>.</p>

<h4><a name="mysql-stmt-bind-result"></a>25.8.11.5. mysql_stmt_bind_result()
</h4>
<p><code>my_bool mysql_stmt_bind_result(MYSQL_STMT *stmt,
MYSQL_BIND *bind)</code></p>

<h5><a name="idm139965276099472"></a>Описание</h5>
<p><a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a> используется, чтобы привязать выходные
столбцы в наборе результатов к буферам длины и  данных. Когда
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> вызвана, чтобы принести данные, протокол клиент-сервер MySQL
помещает данные для связанных столбцов в указанные буферы.</p>

<p>Все столбцы должны быть связаны с буферами до запроса
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>. <code>bind</code> адрес массива структур
<code>MYSQL_BIND</code>. Библиотека клиента ожидает, что массив будет
содержать один элемент для каждого столбца набора результатов. Если Вы не
связываете столбцы со структурами <code>MYSQL_BIND</code>,
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> просто игнорирует данные. Буферы должны быть достаточно
большими, чтобы содержать значения данных, потому что протокол не возвращает
значения данных в кусках.</p>

<p>Столбец может быть связан в любое время, даже после того, как набор
результатов был частично получен. Новая привязка вступает в силу в следующем
вызове <a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a>. Предположите, что приложение связывает столбцы
в наборе результатов и вызывает
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>. Протокол клиент-сервер возвращает данные в связанные буферы.
Тогда предположим, что приложение связывает столбцы с иным набором буферов.
Протокол помещает данные в недавно связанные буферы при следующем вызове
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>.</p>

<p>Чтобы привязать столбец, приложение вызывает
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a> и передает тип, адрес и длину выходного
буфера, в который должно быть сохранено значение.
<a href="#c-api-prepared-statement-data-structures">
Раздел 25.8.9</a> описывает членов каждого элемента <code>MYSQL_BIND</code> и
то, как они должны быть установлены, чтобы получить выходные значения.</p>

<h5><a name="idm139965276082288"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965276081136"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_unsupported_param_type">
<code>CR_UNSUPPORTED_PARAM_TYPE</code></a></p>
<p>Преобразование не поддерживается. Возможно, значение
<code>buffer_type</code> недопустимо или не является одним
из поддерживаемых типов.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-stmt-close"></a>25.8.11.6. mysql_stmt_close()</h4>
<p><code>my_bool mysql_stmt_close(MYSQL_STMT *)</code></p>
<h5><a name="idm139965276066800"></a>Описание</h5>
<p>Закрывает готовый запрос. <a href="#mysql-stmt-close">
<code>mysql_stmt_close()</code></a> также освобождает дескриптор запроса,
который указан <code>stmt</code>. Если у текущего запроса есть ожидание или
непрочитанные результаты, эта функция отменяет их так, чтобы следующий запрос
мог быть выполнен.</p>

<h5><a name="idm139965276063120"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965276061968"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-stmt-data-seek"></a>25.8.11.7. mysql_stmt_data_seek()</h4>
<p><code>void mysql_stmt_data_seek(MYSQL_STMT *stmt, my_ulonglong offset)
</code></p>

<h5><a name="idm139965276050800"></a>Описание</h5>
<p>Переходит на произвольную строку в наборе результатов запроса.
<code>offset</code> задает номер строки и должно быть в диапазоне от
<code>0</code> до <a href="#mysql-stmt-num-rows"><code>
mysql_stmt_num_rows(stmt)-1</code></a>.</p>

<p>Эта функция требует, чтобы структура набора результатов содержала весь
результат последнего выполненного запроса, таким образом,
<a href="#mysql-stmt-data-seek"><code>
mysql_stmt_data_seek()</code></a> может использоваться только в сочетании с
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a>.</p>

<h5><a name="idm139965276043872"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h5><a name="idm139965276042768"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-errno"></a>25.8.11.8. mysql_stmt_errno()</h4>
<p><code>unsigned int mysql_stmt_errno(MYSQL_STMT *stmt)</code></p>
<h5><a name="idm139965276038256"></a>Описание</h5>
<p>Для запроса, определенного <code>stmt</code>,
<a href="#mysql-stmt-errno"><code>mysql_stmt_errno()
</code></a> возвращает код ошибки для последней вызванной функции API,
которая может преуспеть или потерпеть неудачу. Возвращаемое значение 0
значит, что ошибка не произошла. Коды сообщений об ошибке клиента
перечислены в заголовочном файле MySQL <code>errmsg.h</code>. Коды сообщений
об ошибке сервера перечислены в <code>mysqld_error.h</code>.</p>

<h5><a name="idm139965276032752"></a>Возвращаемые значения</h5>
<p>Значение кода ошибки. Ноль если ошибка не произошла.</p>
<h5><a name="idm139965276031600"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-error"></a>25.8.11.9. mysql_stmt_error()</h4>
<p><code>const char *mysql_stmt_error(MYSQL_STMT *stmt)</code></p>
<h5><a name="idm139965276027088"></a>Описание</h5>
<p>Для запроса <code>stmt</code>
<a href="#mysql-stmt-error"><code>mysql_stmt_error()
</code></a> возвращает законченную нулем строку, содержащую сообщение об
ошибке для последней функции API, которая может преуспеть или потерпеть
неудачу. Пустая строка (<code>""</code>) возвращена, если ошибка не произошла.
Любой из этих двух тестов может использоваться, чтобы проверить на ошибку:

<pre>
if (*mysql_stmt_errno(stmt)) {
   // an error occurred
}
if (mysql_stmt_error(stmt)[0]) {
   // an error occurred
}
</pre>

<p>Язык сообщений об ошибках клиента может быть изменен перекомпиляцией
библиотеки клиента MySQL. Вы можете выбрать сообщения об ошибках на
нескольких различных языках.</p>

<h5><a name="idm139965276021680"></a>Возвращаемые значения</h5>
<p>Строка символов, которая описывает ошибку. Пустая строка, если
ошибка не произошла.</p>

<h5><a name="idm139965276020480"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-execute"></a>25.8.11.10. mysql_stmt_execute()</h4>
<p><code>int mysql_stmt_execute(MYSQL_STMT *stmt)</code></p>
<h5><a name="idm139965276015968"></a>Описание</h5>
<p><a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a> выполняет готовый запрос, связанный с
дескриптором. В настоящее время связываемые значения маркера параметра
посылаются серверу во время этого вызова, и сервер заменяет маркеры этими
данными. Обработка запроса после
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> зависит от его типа:</p>

<ul><li><p>Для <a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#insert"><code>INSERT</code></a> число измененных,
удаленных или вставленных строк может быть получено вызовом
<a href="#mysql-stmt-affected-rows"><code>
mysql_stmt_affected_rows()</code></a>.</li>

<li>Для запросов, подобных
<a href="sql.htm#select"><code>SELECT</code></a>, которые
производят набор результатов, Вы должны вызвать
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>, чтобы получить данные до вызова любых других функций, которые
приводят к обработке запроса.</p>

<p>Не делайте следующего вызова
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> с последующим вызовом
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> или <a href="#mysql-use-result"><code>
mysql_use_result()</code></a>. Эти функции не предназначены для того, чтобы
обработать результаты готовых запросов.</p></li></ul>

<p>Для запросов , которые производят набор результатов, Вы можете запросить
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> открыть курсор для запроса вызовом
<a href="#mysql-stmt-attr-set"><code>
mysql_stmt_attr_set()</code></a> перед выполнением запроса. Если Вы
выполняете запрос многократно,
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> закроет любой открытый курсор прежде, чем открыть новый.</p>

<h5><a name="idm139965275990592"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965275989440"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h5><a name="idm139965275976192"></a>Пример</h5>
<p>Следующий пример демонстрирует, как создать и заполнить таблицу, применяя
<a href="#mysql-stmt-init"><code>mysql_stmt_init()</code>
</a>, <a href="#mysql-stmt-prepare"><code>
mysql_stmt_prepare()</code></a>,
<a href="#mysql-stmt-param-count"><code>
mysql_stmt_param_count()</code></a>,
<a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>,
<a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a> и
<a href="#mysql-stmt-affected-rows"><code>
mysql_stmt_affected_rows()</code></a>. Переменная <code>mysql</code> является
допустимым дескриптором соединения. Для примера, который показывает, как
получить данные, см. <a href="#mysql-stmt-fetch">раздел
25.8.11.11. mysql_stmt_fetch()</a>.

<pre>
#define STRING_SIZE 50
#define DROP_SAMPLE_TABLE "DROP TABLE IF EXISTS test_table"
#define CREATE_SAMPLE_TABLE "CREATE TABLE test_table(col1 INT,\
        col2 VARCHAR(40), col3 SMALLINT, col4 TIMESTAMP)"
#define INSERT_SAMPLE "INSERT INTO test_table(col1,col2,col3) \
        VALUES(?,?,?)"

MYSQL_STMT    *stmt;
MYSQL_BIND    bind[3];
my_ulonglong  affected_rows;
int     param_count;
short   small_data;
int     int_data;
char    str_data[STRING_SIZE];
unsigned long str_length;
my_bool is_null;

if (mysql_query(mysql, DROP_SAMPLE_TABLE)) {
   fprintf(stderr, " DROP TABLE failed\n");
   fprintf(stderr, " %s\n", mysql_error(mysql));
   exit(0);
}
if (mysql_query(mysql, CREATE_SAMPLE_TABLE)) {
   fprintf(stderr, " CREATE TABLE failed\n");
   fprintf(stderr, " %s\n", mysql_error(mysql));
   exit(0);
}
/* Prepare an INSERT query with 3 parameters */
/* (the TIMESTAMP column is not named; the server */
/*  sets it to the current date and time) */
stmt = mysql_stmt_init(mysql);
if (!stmt) {
   fprintf(stderr, " mysql_stmt_init(), out of memory\n");
   exit(0);
}
if (mysql_stmt_prepare(stmt, INSERT_SAMPLE, strlen(INSERT_SAMPLE))) {
   fprintf(stderr, " mysql_stmt_prepare(), INSERT failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
fprintf(stdout, " prepare, INSERT successful\n");
/* Get the parameter count from the statement */
param_count= mysql_stmt_param_count(stmt);
fprintf(stdout, " total parameters in INSERT: %d\n", param_count);
if (param_count != 3) /* validate parameter count */ {
   fprintf(stderr, " invalid parameter count returned by MySQL\n");
   exit(0);
}
/* Bind the data for all 3 parameters */
memset(bind, 0, sizeof(bind));
/* INTEGER PARAM */
/* This is a number type, so there is no need to specify buffer_length */
bind[0].buffer_type= MYSQL_TYPE_LONG;
bind[0].buffer= (char *)&amp;int_data;
bind[0].is_null= 0;
bind[0].length= 0;
/* STRING PARAM */
bind[1].buffer_type= MYSQL_TYPE_STRING;
bind[1].buffer= (char *)str_data;
bind[1].buffer_length= STRING_SIZE;
bind[1].is_null= 0;
bind[1].length= &amp;str_length;
/* SMALLINT PARAM */
bind[2].buffer_type= MYSQL_TYPE_SHORT;
bind[2].buffer= (char *)&amp;small_data;
bind[2].is_null= &amp;is_null;
bind[2].length= 0;
/* Bind the buffers */
if (mysql_stmt_bind_param(stmt, bind)) {
   fprintf(stderr, " mysql_stmt_bind_param() failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
/* Specify the data values for the first row */
int_data= 10; /* integer */
strncpy(str_data, "MySQL", STRING_SIZE); /* string  */
str_length= strlen(str_data);
/* INSERT SMALLINT data as NULL */
is_null= 1;
/* Execute the INSERT statement - 1*/
if (mysql_stmt_execute(stmt)) {
   fprintf(stderr, " mysql_stmt_execute(), 1 failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
/* Get the number of affected rows */
affected_rows= mysql_stmt_affected_rows(stmt);
fprintf(stdout, " total affected rows(insert 1): %lu\n",
        (unsigned long) affected_rows);
if (affected_rows != 1) /* validate affected rows */ {
   fprintf(stderr, " invalid affected rows by MySQL\n");
   exit(0);
}
/* Specify data values for second row, then re-execute the statement */
int_data= 1000;
strncpy(str_data, "The most popular Open Source database", STRING_SIZE);
str_length= strlen(str_data);
small_data= 1000;   /* smallint */
is_null= 0; /* reset */
/* Execute the INSERT statement - 2*/
if (mysql_stmt_execute(stmt)) {
   fprintf(stderr, " mysql_stmt_execute, 2 failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
/* Get the total rows affected */
affected_rows= mysql_stmt_affected_rows(stmt);
fprintf(stdout, " total affected rows(insert 2): %lu\n",
        (unsigned long) affected_rows);
if (affected_rows != 1) /* validate affected rows */ {
   fprintf(stderr, " invalid affected rows by MySQL\n");
   exit(0);
}
/* Close the statement */
if (mysql_stmt_close(stmt)) {
   fprintf(stderr, " failed while closing the statement\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
</pre>

<p>Для изучения полных примеров использования функций готовых запросов
обратитесь к файлу <code>tests/mysql_client_test.c</code>. Этот файл может
быть получен из набора исходных текстов MySQL (см.
<a href="install.htm#source-installation">раздел 2.8.
Установка MySQL из исходных текстов</a>).</p>

<h4><a name="mysql-stmt-fetch"></a>25.8.11.11. mysql_stmt_fetch()</h4>
<a class="indexterm" name="idm139965275953088"></a><p>
<code>int mysql_stmt_fetch(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965275950928"></a>Описание</h5>
<p><a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> возвращает следующую строку в наборе результатов. Это можно
назвать только в то время, когда набор результатов существует, то есть, после
вызова <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a> для запроса, подобного
<a href="sql.htm#select"><code>SELECT</code></a>, который
производит набор результатов.</p>

<p><a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> вернет данные о строке, используя буферы, связанные
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>. Это возвращает данные в буферах для всех
столбцов в текущем наборе строк, длины будут возвращены в указатель
<code>length</code>. Все столбцы должны быть связаны приложением прежде, чем
оно будет вызывать <a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a>.</p>

<p>По умолчанию наборы результатов получены построчно с сервера. Чтобы
буферизовать весь набор результатов на клиенте, вызовите
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a> после привязки буферов данных и перед
запросом <a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a>.</p>

<p>Если полученное значение данных <code>NULL</code>, то значение
<code>*is_null</code> соответствующей структуры <code>MYSQL_BIND</code>
содержит TRUE (1). Иначе данные и его длина возвращены в элементах
<code>*buffer</code> и <code>*length</code>, основанных на типе буфера,
определенном приложением. У каждого числового и временного типа есть
фиксированная длина, как перечислено в следующей таблице. Длина строковых
типов зависит от длины фактического значения данных, как обозначено
<code>data_length</code>.</p>

<table border="1"><thead><tr><th scope="col">Тип</th>
<th scope="col">Длина</th></tr></thead>
<tbody><tr><td scope="row"><code>MYSQL_TYPE_TINY</code></td><td>1</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_SHORT</code></td><td>2</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_LONG</code></td><td>4</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_LONGLONG</code></td><td>8</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_FLOAT</code></td><td>4</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_DOUBLE</code></td><td>8</td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_TIME</code></td>
<td><code>sizeof(MYSQL_TIME)</code></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_DATE</code></td>
<td><code>sizeof(MYSQL_TIME)</code></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_DATETIME</code></td>
<td><code>sizeof(MYSQL_TIME)</code></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_STRING</code></td>
<td><code>data length</code></td></tr>
<tr><td scope="row"><code>MYSQL_TYPE_BLOB</code></td>
<td><code>data_length</code></td></tr></tbody></table>

<p>В некоторых случаях Вы могли бы определить длину значения столбца прежде,
чем получить его с помощью
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>. Например, значение могло бы быть длинной строкой или объектом
<a href="types.htm#blob"><code>BLOB</code></a>, для которого Вы хотите
знать, сколько места должно быть выделено. Чтобы достигнуть этого, Вы можете
использовать эти стратегии:</p>

<ul><li><p>Перед вызовом
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>, чтобы получить отдельные строки, передайте
<code>STMT_ATTR_UPDATE_MAX_LENGTH</code> в
<a href="#mysql-stmt-attr-set"><code>
mysql_stmt_attr_set()</code></a>, затем вызовите
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a>, чтобы буферизовать весь результат на
стороне клиента. Установка атрибута <code>STMT_ATTR_UPDATE_MAX_LENGTH</code>
предписывает максимальную длину значений столбцов записать в член
<code>max_length</code> набора результатов метаданных, возвращенных
<a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a>.</li>

<li>Вызовите <a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a> с буфером нулевой длины для рассматриваемого
столбца и указателем, в котором может быть сохранена реальная длина. Тогда
используйте реальную длину с
<a href="#mysql-stmt-fetch-column"><code>
mysql_stmt_fetch_column()</code></a>.

<pre>
real_length= 0;
bind[0].buffer= 0;
bind[0].buffer_length= 0;
bind[0].length= &amp;real_length
mysql_stmt_bind_result(stmt, bind);
mysql_stmt_fetch(stmt);
if (real_length &gt; 0) {
   data= malloc(real_length);
   bind[0].buffer= data;
   bind[0].buffer_length= real_length;
   mysql_stmt_fetch_column(stmt, bind, 0, 0);
}
</pre></li></ul>

<h5><a name="idm139965275891824"></a>Возвращаемые значения</h5>
<table border="1"><thead><tr><th scope="col">Возвращаемое значение</th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row">0</td><td>Успешно, данные были сохранены
в буферы данных приложения.</td></tr>
<tr><td scope="row">1</td><td>Ошибка произошла. Код ошибки и сообщение могут
быть получены, вызывая
<a href="#mysql-stmt-errno"><code>mysql_stmt_errno()
</code></a> и <a href="#mysql-stmt-error"><code>
mysql_stmt_error()</code></a>.</td></tr>
<tr><td scope="row"><code>MYSQL_NO_DATA</code></td><td>Больше строк/данных
не существует.</td></tr>
<tr><td scope="row"><code>MYSQL_DATA_TRUNCATED</code></td>
<td>Усечение данных произошло.</td></tr></tbody></table>

<p><code>MYSQL_DATA_TRUNCATED</code> возвращается, когда сообщение об
усечении включено. Чтобы определить, какие значения столбцов были усеченными,
когда это значение возвращено, проверьте член <code>error</code> структур
<code>MYSQL_BIND</code>, используемых для получения значений. Сообщение об
усечении включено по умолчанию, но может управляться
<a href="#mysql-options"><code>mysql_options()</code></a>
с опцией <code>MYSQL_REPORT_DATA_TRUNCATION</code>.</p>

<h5><a name="idm139965275872080"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</li>

<li><a href="error.htm#error_cr_unsupported_param_type"><code>
CR_UNSUPPORTED_PARAM_TYPE</code></a></p>
<p>Буферный тип <code>MYSQL_TYPE_DATE</code>, <code>MYSQL_TYPE_TIME</code>,
<code>MYSQL_TYPE_DATETIME</code> или <code>MYSQL_TYPE_TIMESTAMP</code>,
но тип данных не <a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> или
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>.</li>

<li>Все другие неподдержанные конверсионные ошибки возвращены из
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>.</p></li></ul>

<h5><a name="idm139965275846448"></a>Пример</h5>
<p>Следующий пример демонстрирует, как получить данные из таблицы, используя
<a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a>,
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a> и
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>. Этот пример ожидает получить две строки, вставленные примером,
показанным в <a href="#mysql-stmt-execute">разделе
25.8.11.10. mysql_stmt_execute()</a>. Переменная <code>mysql</code>
является допустимым дескриптором соединения.

<pre>
#define STRING_SIZE 50
#define SELECT_SAMPLE "SELECT col1, col2, col3, col4 \
                              FROM test_table"
MYSQL_STMT    *stmt;
MYSQL_BIND    bind[4];
MYSQL_RES     *prepare_meta_result;
MYSQL_TIME    ts;
unsigned long length[4];
int     param_count, column_count, row_count;
short   small_data;
int     int_data;
char    str_data[STRING_SIZE];
my_bool is_null[4];
my_bool error[4];

/* Prepare a SELECT query to fetch data from test_table */
stmt = mysql_stmt_init(mysql);
if (!stmt) {
   fprintf(stderr, " mysql_stmt_init(), out of memory\n");
   exit(0);
}
if (mysql_stmt_prepare(stmt, SELECT_SAMPLE, strlen(SELECT_SAMPLE))) {
   fprintf(stderr, " mysql_stmt_prepare(), SELECT failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
fprintf(stdout, " prepare, SELECT successful\n");
/* Get the parameter count from the statement */
param_count= mysql_stmt_param_count(stmt);
fprintf(stdout, " total parameters in SELECT: %d\n", param_count);
if (param_count != 0) /* validate parameter count */ {
   fprintf(stderr, " invalid parameter count returned by MySQL\n");
   exit(0);
}
/* Fetch result set meta information */
prepare_meta_result = mysql_stmt_result_metadata(stmt);
if (!prepare_meta_result) {
   fprintf(stderr, " mysql_stmt_result_metadata(), \
           returned no meta information\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
/* Get total columns in the query */
column_count= mysql_num_fields(prepare_meta_result);
fprintf(stdout, " total columns in SELECT statement: %d\n", column_count);
if (column_count != 4) /* validate column count */ {
   fprintf(stderr, " invalid column count returned by MySQL\n");
   exit(0);
}
/* Execute the SELECT query */
if (mysql_stmt_execute(stmt)) {
   fprintf(stderr, " mysql_stmt_execute(), failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
/* Bind the result buffers for all 4 columns before fetching them */
memset(bind, 0, sizeof(bind));
/* INTEGER COLUMN */
bind[0].buffer_type= MYSQL_TYPE_LONG;
bind[0].buffer= (char *)&amp;int_data;
bind[0].is_null= &amp;is_null[0];
bind[0].length= &amp;length[0];
bind[0].error= &amp;error[0];
/* STRING COLUMN */
bind[1].buffer_type= MYSQL_TYPE_STRING;
bind[1].buffer= (char *)str_data;
bind[1].buffer_length= STRING_SIZE;
bind[1].is_null= &amp;is_null[1];
bind[1].length= &amp;length[1];
bind[1].error= &amp;error[1];
/* SMALLINT COLUMN */
bind[2].buffer_type= MYSQL_TYPE_SHORT;
bind[2].buffer= (char *)&amp;small_data;
bind[2].is_null= &amp;is_null[2];
bind[2].length= &amp;length[2];
bind[2].error= &amp;error[2];
/* TIMESTAMP COLUMN */
bind[3].buffer_type= MYSQL_TYPE_TIMESTAMP;
bind[3].buffer= (char *)&amp;ts;
bind[3].is_null= &amp;is_null[3];
bind[3].length= &amp;length[3];
bind[3].error= &amp;error[3];
/* Bind the result buffers */
if (mysql_stmt_bind_result(stmt, bind)) {
   fprintf(stderr, " mysql_stmt_bind_result() failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
/* Now buffer all results to client (optional step) */
if (mysql_stmt_store_result(stmt)) {
   fprintf(stderr, " mysql_stmt_store_result() failed\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
/* Fetch all rows */
row_count= 0;
fprintf(stdout, "Fetching results ...\n");
while (!mysql_stmt_fetch(stmt)) {
  row_count++;
  fprintf(stdout, "  row %d\n", row_count);
  /* column 1 */
  fprintf(stdout, "   column1 (integer)  : ");
  if (is_null[0]) fprintf(stdout, " NULL\n");
  else fprintf(stdout, " %d(%ld)\n", int_data, length[0]);
  /* column 2 */
  fprintf(stdout, "   column2 (string)   : ");
  if (is_null[1]) fprintf(stdout, " NULL\n");
  else fprintf(stdout, " %s(%ld)\n", str_data, length[1]);
  /* column 3 */
  fprintf(stdout, "   column3 (smallint) : ");
  if (is_null[2]) fprintf(stdout, " NULL\n");
  else fprintf(stdout, " %d(%ld)\n", small_data, length[2]);
  /* column 4 */
  fprintf(stdout, "   column4 (timestamp): ");
  if (is_null[3]) fprintf(stdout, " NULL\n");
  else fprintf(stdout, " %04d-%02d-%02d %02d:%02d:%02d (%ld)\n",
               ts.year, ts.month, ts.day, ts.hour, ts.minute, ts.second,
               length[3]);
  fprintf(stdout, "\n");
}
/* Validate rows fetched */
fprintf(stdout, " total rows fetched: %d\n", row_count);
if (row_count != 2) {
   fprintf(stderr, " MySQL failed to return all rows\n");
   exit(0);
}
/* Free the prepared result metadata */
mysql_free_result(prepare_meta_result);
/* Close the statement */
if (mysql_stmt_close(stmt)) {
   fprintf(stderr, " failed while closing the statement\n");
   fprintf(stderr, " %s\n", mysql_stmt_error(stmt));
   exit(0);
}
</pre>

<h4><a name="mysql-stmt-fetch-column"></a>25.8.11.12.
mysql_stmt_fetch_column()</h4>
<p><code>int mysql_stmt_fetch_column(MYSQL_STMT *stmt,
MYSQL_BIND *bind, unsigned int column, unsigned long offset)</code></p>

<h5><a name="idm139965275823440"></a>Описание</h5>
<p>Получает один столбец текущей строки набора результатов. <code>bind</code>
обеспечивает буфер, куда данные должны быть помещены. Это должно быть
настроено так же, как и
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>. <code>column</code> указывает, который
столбец нужен. Первый столбец пронумерован как 0. <code>offset</code>
смещение в пределах значения данных, где начать получать данные. Это может
использоваться для того, чтобы принести значение данных по частям. Начало
значения имеет offset 0.</p>

<h5><a name="idm139965275818544"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965275817392"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_invalid_parameter_no"><code>
CR_INVALID_PARAMETER_NO</code></a></p>
<p>Недопустимый номер столбца.</li>

<li><a href="error.htm#error_cr_no_data"><code>CR_NO_DATA</code>
</a></p>
<p>Конец набора результатов был уже достигнут.</p></li></ul>

<h4><a name="mysql-stmt-field-count"></a>25.8.11.13. mysql_stmt_field_count()
</h4>
<p><code>unsigned int mysql_stmt_field_count(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965275807792"></a>Описание</h5>
<p>Возвращает число столбцов для нового запроса для обработчика запроса.
Это значение ноль для таких запросов, как
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>, которые не
производят наборы результатов.</p>

<p><a href="#mysql-stmt-field-count"><code>
mysql_stmt_field_count()</code></a> может быть вызвана после того, как Вы
подготовили запрос вызовом <a href="#mysql-stmt-prepare">
<code>mysql_stmt_prepare()</code></a>.</p>

<h5><a name="idm139965275801120"></a>Возвращаемые значения</h5>
<p>Целое число без знака, представляющее число столбцов в наборе результатов.
</p>

<h5><a name="idm139965275799936"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-free-result"></a>25.8.11.14. mysql_stmt_free_result()
</h4>
<p><code>my_bool mysql_stmt_free_result(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965275795376"></a>Описание</h5>
<p>Освобождает память связанную с набором результатов, произведенным
выполнением готового запроса. Если есть курсор, открытый для запроса,
<a href="#mysql-stmt-free-result"><code>
mysql_stmt_free_result()</code></a> его закроет.</p>

<h5><a name="idm139965275792848"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h4><a name="mysql-stmt-init"></a>25.8.11.15. mysql_stmt_init()</h4>
<p><code>MYSQL_STMT *mysql_stmt_init(MYSQL *mysql)</code></p>
<h5><a name="idm139965275787600"></a>Описание</h5>
<p>Создает дескриптор <code>MYSQL_STMT</code>. Дескриптор должен быть
освобожден с помощью <a href="#mysql-stmt-close">
<code>mysql_stmt_close(MYSQL_STMT *)</code></a>.</p>

<h5><a name="idm139965275783248"></a>Возвращаемые значения</h5>
<p>Указатель на структуру <code>MYSQL_STMT</code> в случае успеха.
<code>NULL</code>, если мало памяти.</p>

<h5><a name="idm139965275780656"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</p></li></ul>

<h4><a name="mysql-stmt-insert-id"></a>25.8.11.16. mysql_stmt_insert_id()
</h4>
<p><code>my_ulonglong mysql_stmt_insert_id(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965275773824"></a>Описание</h5>
<p>Возвращает значение, произведенное для столбца
<code>AUTO_INCREMENT</code> подготовленным запросом
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>. Используйте эту
функцию после того, как Вы выполнили готовый запрос
<a href="sql.htm#insert"><code>INSERT</code></a> на таблице, которая
содержит поле <code>AUTO_INCREMENT</code> field.</p>

<h5><a name="idm139965275766304"></a>Возвращаемые значения</h5>
<p>Значение для столбца <code>AUTO_INCREMENT</code>, которое было
автоматически произведено или явно установлено во время выполнения готового
запроса, или значение, произведенное функцией
<a href="funct.htm#function_last-insert-id"><code>
LAST_INSERT_ID(<em><code>expr</code></em>)</code></a>.
Возвращаемое значение неопределено, если запрос не устанавливает значение
<code>AUTO_INCREMENT</code>.</p>

<h5><a name="idm139965275761040"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-next-result"></a>25.8.11.17. mysql_stmt_next_result()
</h4>
<a class="indexterm" name="idm139965275758656"></a><p>
<code>int mysql_stmt_next_result(MYSQL_STMT *mysql)</code></p>

<h5><a name="idm139965275756496"></a>Описание</h5>
<p>Эта функция используется, когда Вы используете подготовленный запрос
<a href="sql.htm#call"><code>CALL</code></a>, чтобы выполнить
хранимые процедуры, которые могут возвратить много наборов результатов.
Используйте цикл для вызова
<a href="#mysql-stmt-next-result">
<code>mysql_stmt_next_result()</code></a>, чтобы определить, есть ли еще
результаты. Если процедура имеет параметры <code>OUT</code> или
<code>INOUT</code>, их значения будут возвращены как набор результатов
единственной строки после любых других наборов результатов. Значения появятся
в порядке, в котором они объявлены в списке параметров процедуры.</p>

<p><a href="#mysql-stmt-next-result"><code>
mysql_stmt_next_result()</code></a> возвращает состояние, чтобы указать,
существует ли больше результатов. Если
<a href="#mysql-stmt-next-result"><code>
mysql_stmt_next_result()</code></a> возвращает ошибку,
нет больше результатов.</p>

<p>Перед каждым вызовом
<a href="#mysql-stmt-next-result"><code>
mysql_stmt_next_result()</code></a> Вы должны вызвать
<a href="#mysql-stmt-free-result"><code>
mysql_stmt_free_result()</code></a> для текущего результата, если это
произвело набор результатов (а не только состояние результата).</p>

<p>После вызова <a href="#mysql-stmt-next-result"><code>
mysql_stmt_next_result()</code></a> состояние аналогично тому, если Вы
вызвали <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a>. Это означает, что Вы можете вызвать
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>,
<a href="#mysql-stmt-affected-rows"><code>
mysql_stmt_affected_rows()</code></a> и т.д.</p>

<p>Также возможно проверить, есть ли еще результаты, вызывая
<a href="#mysql-more-results"><code>mysql_more_results()
</code></a>. Однако, эта функция не изменяет состояние соединения, так что,
если это возвращает истину, Вы должны вызывать
<a href="#mysql-stmt-next-result"><code>
mysql_stmt_next_result()</code></a>,
чтобы обратиться к следующему результату.</p>

<p>Для примера, который показывает, как использовать
<a href="#mysql-stmt-next-result"><code>
mysql_stmt_next_result()</code></a>, см.
<a href="#c-api-prepared-call-statements">раздел 25.8.20
</a>.</p>

<h5><a name="idm139965275733936"></a>Возвращаемые значения</h5>
<table border="1">
<thead><tr><th scope="col">Возвращаемое значение</th><th scope="col">Описание
</th></tr></thead>
<tbody><tr><td scope="row">0</td><td>Успешно и есть еще результаты.</td></tr>
<tr><td scope="row">-1</td><td>Успешно и нет больше результатов.</td></tr>
<tr><td scope="row">&gt;0</td><td>Ошибка произошла</td></tr></tbody></table>

<h5><a name="idm139965275723568"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-stmt-num-rows"></a>25.8.11.18. mysql_stmt_num_rows()</h4>
<p><code>my_ulonglong mysql_stmt_num_rows(MYSQL_STMT *stmt)</code></p>
<h5><a name="idm139965275709296"></a>Описание</h5>
<p>Возвращает число строк в наборе результатов.</p>

<p>Использование <a href="#mysql-stmt-num-rows"><code>
mysql_stmt_num_rows()</code></a> зависит от того, использовали ли Вы
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a>, чтобы буферизовать весь набор
результатов в дескрипторе запроса. Если Вы используете
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a>,
<a href="#mysql-stmt-num-rows"><code>
mysql_stmt_num_rows()</code></a> может быть вызван немедленно. Иначе
количество строк недоступно, если Вы не считаете строки, пока забираете их.
</p>

<p><a href="#mysql-stmt-num-rows"><code>
mysql_stmt_num_rows()</code></a> предназначен для использования с запросами,
которые возвращают набор результатов, например,
<a href="sql.htm#select"><code>SELECT</code></a>. Для запросов типа
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a> число обработанных
строк может быть получено с помощью
<a href="#mysql-stmt-affected-rows"><code>
mysql_stmt_affected_rows()</code></a>.</p>

<h5><a name="idm139965275694608"></a>Возвращаемые значения</h5>
<p>Число строк в наборе результатов.</p>
<h5><a name="idm139965275693472"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-param-count"></a>25.8.11.19. mysql_stmt_param_count()
</h4>
<p><code>unsigned long mysql_stmt_param_count(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965275688912"></a>Описание</h5>
<p>Возвращает число маркеров параметра, существующих в готовом запросе.</p>
<h5><a name="idm139965275687728"></a>Возвращаемые значения</h5>
<p>unsigned long integer, представляющее число параметров в запросе.</p>

<h5><a name="idm139965275686544"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-param-metadata"></a>25.8.11.20.
mysql_stmt_param_metadata()</h4>
<a class="indexterm" name="idm139965275682368"></a><p>
<code>MYSQL_RES *mysql_stmt_param_metadata(MYSQL_STMT *stmt)</code></p>
<p>Эта функция в настоящее время ничего не делает.</p>

<h4><a name="mysql-stmt-prepare"></a>25.8.11.21. mysql_stmt_prepare()</h4>
<p><code>int mysql_stmt_prepare(MYSQL_STMT *stmt, const char *stmt_str,
unsigned long length)</code></p>

<h5><a name="idm139965275674192"></a>Описание</h5>
<p>Учитывая дескриптор, возвращенный
<a href="#mysql-stmt-init">
<code>mysql_stmt_init()</code></a>, готовит запрос SQL, на который указывает
строка <code>stmt_str</code> и возвращает значение состояния. Строковая длина
должна быть дана параметром <code>length</code>. Строка должна состоять из
единственного запроса SQL. Вы не должны добавить заканчивающую точку с
запятой (<code>;</code>) или <code>\g</code>.</p>

<p>Приложение может включать один или более маркеров параметра в запрос SQL,
встраивая вопросительный знак (<code>?</code>) в
SQL-строку в соответствующих позициях.</p>

<p>Маркеры являются законными только в определенных местах в заявлениях SQL.
Например, они разрешаются в списке <code>VALUES()</code> запроса
<a href="sql.htm#insert"><code>INSERT</code></a> (чтобы определить
значения столбцов для строки) или в сравнении со столбцом в
предложении <code>WHERE</code>, чтобы определить сравнительное значение.
Однако, они не разрешаются для идентификаторов (таких как имена таблиц или
имена столбцов) или в определении обоих операндов бинарного оператора,
подобного <code>=</code>. Последнее ограничение необходимо, потому что было
бы невозможно определить тип параметра. Вообще, параметры являются законными
только в командах Data Manipulation Language (DML), а не в
Data Definition Language (DDL).</p>

<p>Маркеры параметра должны быть привязаны к используемым переменным
приложения с помощью <a href="#mysql-stmt-bind-param">
<code>mysql_stmt_bind_param()</code></a> прежде, чем выполнить запрос.</p>

<h5><a name="idm139965275660000"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965275658848"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<p>Если подготовительная работа была неудачна (то есть,
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a> вернула не 0), сообщение об ошибке может быть получено
посредством <a href="#mysql-stmt-error"><code>
mysql_stmt_error()</code></a>.</p>

<h4><a name="mysql-stmt-reset"></a>25.8.11.22. mysql_stmt_reset()</h4>
<p><code>my_bool mysql_stmt_reset(MYSQL_STMT *stmt)</code></p>
<h5><a name="idm139965275637408"></a>Описание</h5>
<p>Сбрасывает готовый запрос на клиенте и сервере к состоянию после
подготовки. Это сбрасывает запрос на сервере, данные, посланные через
<a href="#mysql-stmt-send-long-data"><code>
mysql_stmt_send_long_data()</code></a>, небуферизованные наборы результатов и
текущие ошибки. Это не очищает привязку или сохраненные наборы результатов.
Сохраненные наборы результатов будут очищены при выполнении готового или
закрытии готового запроса.</p>

<p>Чтобы повторно подготовить запрос, примените
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a>.</p>

<h5><a name="idm139965275632992"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965275631840"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-stmt-result-metadata"></a>25.8.11.23.
mysql_stmt_result_metadata()</h4>
<p><code>MYSQL_RES *mysql_stmt_result_metadata(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965275617504"></a>Описание</h5>
<p>Если к <a href="#mysql-stmt-prepare">
<code>mysql_stmt_prepare()</code></a> прошел запрос, который производит набор
результатов, <a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a> возвращает метаданные о наборе
результатов в форме указателя на структуру <code>MYSQL_RES</code>, которая
может использоваться, чтобы обработать метаинформацию, такую как число полей
и информация об отдельных полях. Этот указатель набора результатов можно
передать как параметр любой из основанных на полях функций API, которые
обрабатывают метаданные о наборе результатов, такие как:</p>

<ul><li><p><a href="#mysql-num-fields"><code>
mysql_num_fields()</code></a></li>
<li><a href="#mysql-fetch-field"><code>
mysql_fetch_field()</code></a></li>
<li><a href="#mysql-fetch-field-direct"><code>
mysql_fetch_field_direct()</code></a></li>
<li><a href="#mysql-fetch-fields"><code>
mysql_fetch_fields()</code></a></li>
<li><a href="#mysql-field-count"><code>
mysql_field_count()</code></a></li>
<li><a href="#mysql-field-seek"><code>
mysql_field_seek()</code></a></li>
<li><a href="#mysql-field-tell"><code>mysql_field_tell()
</code></a></li>
<li><a href="#mysql-free-result"><code>
mysql_free_result()</code></a></p></li></ul>

<p>Структура набора результатов должна быть освобождена, когда Вы закончите
с ней работать. Это можно сделать, передавая ее в
<a href="#mysql-free-result"><code>mysql_free_result()
</code></a>. Это подобно способу, которым Вы освобождаете набор результатов,
полученный из <a href="#mysql-store-result"><code>
mysql_store_result()</code></a>.</p>

<p>Набор результатов, возвращенный
<a href="#mysql-stmt-result-metadata"><code>
mysql_stmt_result_metadata()</code></a> содержит только метаданные. Это не
содержит результатов строки. Строки получены при использовании дескриптора
запроса в <a href="#mysql-stmt-fetch"><code>
mysql_stmt_fetch()</code></a>.</p>

<h5><a name="idm139965275590432"></a>Возвращаемые значения</h5>
<p>Структура результата <code>MYSQL_RES</code>. <code>NULL</code>,
если никакой метаинформации не существует для готового запроса.</p>

<h5><a name="idm139965275587824"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h4><a name="mysql-stmt-row-seek"></a>25.8.11.24. mysql_stmt_row_seek()</h4>
<p><code>MYSQL_ROW_OFFSET mysql_stmt_row_seek(MYSQL_STMT *stmt,
MYSQL_ROW_OFFSET offset)</code></p>

<h5><a name="idm139965275576704"></a>Описание</h5>
<p>Устанавливает курсор строки в произвольную строку в наборе результатов.
Значение <code>offset</code> определяет смещение строки, которое должно быть
значением, возвращенным из
<a href="#mysql-stmt-row-tell"><code>
mysql_stmt_row_tell()</code></a> или
<a href="#mysql-stmt-row-seek"><code>
mysql_stmt_row_seek()</code></a>. Это значение не номер строки, если Вы
хотите перейти на строку в пределах набора результатов по номеру, надо
использовать <a href="#mysql-stmt-data-seek"><code>
mysql_stmt_data_seek()</code></a>.</p>

<p>Эта функция требует, чтобы структура набора результатов содержала весь
результат запроса, таким образом
<a href="#mysql-stmt-row-seek"><code>
mysql_stmt_row_seek()</code></a> может использоваться только вместе с
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a>.</p>

<h5><a name="idm139965275567888"></a>Возвращаемые значения</h5>
<p>Предыдущее значение курсора строки. Это значение можно передать
последующему вызову <a href="#mysql-stmt-row-seek"><code>
mysql_stmt_row_seek()</code></a>.</p>

<h5><a name="idm139965275565456"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-row-tell"></a>25.8.11.25. mysql_stmt_row_tell()</h4>
<p><code>MYSQL_ROW_OFFSET mysql_stmt_row_tell(MYSQL_STMT *stmt)</code></p>
<h5><a name="idm139965275560928"></a>Описание</h5>
<p>Возвращает текущую позицию курсора строки для последнего вызова
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a>. Это значение может использоваться в качестве параметра
<a href="#mysql-stmt-row-seek"><code>
mysql_stmt_row_seek()</code></a>.</p>

<p>Вы должны использовать <a href="#mysql-stmt-row-tell">
<code>mysql_stmt_row_tell()</code></a> только после
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a>.</p>

<h5><a name="idm139965275554336"></a>Возвращаемые значения</h5>
<p>Текущее смещение курсора строки.</p>
<h5><a name="idm139965275553200"></a>Ошибки</h5>
<p>
Нет.
</p>

<h4><a name="mysql-stmt-send-long-data"></a>25.8.11.26.
mysql_stmt_send_long_data()</h4>
<p><code>my_bool mysql_stmt_send_long_data(MYSQL_STMT *stmt,
unsigned int parameter_number, const char *data,
unsigned long length)</code></p>

<h5><a name="idm139965275548528"></a>Описание</h5>
<p>Позволяет приложению послать данные параметров серверу в кусках (или
(<span>chunks</span>). Вызовите эту функцию после
<a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a> и перед
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>. Это можно вызвать многократно, чтобы послать части символьного
столбца или двоичные данные, которые должны быть одним из типов данных
<a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>.</p>

<p><code>parameter_number</code> указывает, который параметр связать с
данными. Параметры пронумерованы, начиная с 0. <code>data</code>
указатель на буфер, содержащий данные, которые будут посланы, и
<code>length</code> указывает на число байтов в буфере.</p>

<p>Следующий вызов <a href="#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a> игнорирует связыванные буферы для всех
параметров, которые использовались с
<a href="#mysql-stmt-send-long-data"><code>
mysql_stmt_send_long_data()</code></a> с последнего
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> или <a href="#mysql-stmt-reset"><code>
mysql_stmt_reset()</code></a>.</p>

<p>Если Вы хотите сбросить посланные данные, Вы можете сделать это с помощью
<a href="#mysql-stmt-reset"><code>mysql_stmt_reset()
</code></a>.</p>

<p>Системная переменная
<a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a> управляет максимальным размером значений
параметра, которые можно послать с помощью
<a href="#mysql-stmt-send-long-data"><code>
mysql_stmt_send_long_data()</code></a>.</p>

<h5><a name="idm139965275527744"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965275526592"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_invalid_buffer_use"><code>
CR_INVALID_BUFFER_USE</code></a></p>
<p>Параметр не имеет строкового или двоичного типа.</li>

<li><a href="error.htm#error_cr_invalid_parameter_no"><code>
CR_INVALID_PARAMETER_NO</code></a></p>
<p>Недопустимое число параметров.</li>

<li><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h5><a name="idm139965275510752"></a>Пример</h5>
<p>Следующий пример демонстрирует, как послать данные для столбца
<a href="types.htm#blob"><code>TEXT</code></a> кусками. Это вставляет
значение данных <code>'MySQL - The most popular Open Source database'</code>
в столбец <code>text_column</code>. Переменная <code>mysql</code> является
допустимым дескриптором соединения.

<pre>
#define INSERT_QUERY "INSERT INTO \
                     test_long_data(text_column) VALUES(?)"

MYSQL_BIND bind[1];
long length;

stmt = mysql_stmt_init(mysql);
if (!stmt) {
   fprintf(stderr, " mysql_stmt_init(), out of memory\n");
   exit(0);
}
if (mysql_stmt_prepare(stmt, INSERT_QUERY, strlen(INSERT_QUERY))) {
   fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
   fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
   exit(0);
}
memset(bind, 0, sizeof(bind));
bind[0].buffer_type= MYSQL_TYPE_STRING;
bind[0].length= &amp;length;
bind[0].is_null= 0;
/* Bind the buffers */
if (mysql_stmt_bind_param(stmt, bind)) {
   fprintf(stderr, "\n param bind failed");
   fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
   exit(0);
}
/* Supply data in chunks to server */
if (mysql_stmt_send_long_data(stmt,0,"MySQL",5)) {
   fprintf(stderr, "\n send_long_data failed");
   fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
   exit(0);
}
/* Supply the next piece of data */
if (mysql_stmt_send_long_data(stmt,0,
   " - The most popular Open Source database",40)) {
   fprintf(stderr, "\n send_long_data failed");
   fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
   exit(0);
}
/* Now, execute the query */
if (mysql_stmt_execute(stmt)) {
   fprintf(stderr, "\n mysql_stmt_execute failed");
   fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
   exit(0);
}
</pre>

<h4><a name="mysql-stmt-sqlstate"></a>25.8.11.27. mysql_stmt_sqlstate()</h4>
<p><code>const char *mysql_stmt_sqlstate(MYSQL_STMT *stmt)</code></p>
<h5><a name="idm139965275498160"></a>Описание</h5>
<p>Для запроса, определенного <code>stmt</code>,
<a href="#mysql-stmt-sqlstate"><code>
mysql_stmt_sqlstate()</code></a> возвращает законченную нулем строку,
содержащую код ошибки SQLSTATE для последнего вызванного готового запроса.
Код ошибки состоит из пяти символов. <code>"00000"</code> означает <span>
"нет ошибки"</span>. Значения определены ANSI SQL и ODBC.</p>

<p>Не все ошибки MySQL отображены на коды SQLSTATE. Значение
<code>"HY000"</code> (general error)
используется для неотображенных ошибок.</p>
<h5><a name="idm139965275491680"></a>Возвращаемые значения</h5>
<p>Законченная нулем строка символов, содержащая код ошибки SQLSTATE.</p>

<h4><a name="mysql-stmt-store-result"></a>25.8.11.28.
mysql_stmt_store_result()</h4>
<p><code>int mysql_stmt_store_result(MYSQL_STMT *stmt)</code></p>

<h5><a name="idm139965275487056"></a>Описание</h5>
<p>Наборы результатов, произведены вызовом
<a href="#mysql-stmt-execute">
<code>mysql_stmt_execute()</code></a> для выполнения подготовленных
SQL-запросов, подобных <a href="sql.htm#select"><code>SELECT</code>
</a>, <a href="sql.htm#show"><code>SHOW</code></a>,
<a href="sql.htm#describe"><code>DESCRIBE</code></a> и
<a href="sql.htm#explain"><code>EXPLAIN</code></a>. По умолчанию
наборы результатов для успешно выполненных готовых запросов не буферизованы
в клиенте и
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> забирает их по одному с сервера. Чтобы заставить полный набор
результатов буферизоваться в клиенте, вызовите
<a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a> после привязки буферов данных с
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a> и перед
<a href="#mysql-stmt-fetch"><code>mysql_stmt_fetch()
</code></a> для получения строк. Пример есть в
<a href="#mysql-stmt-fetch">разделе 25.8.11.11.
mysql_stmt_fetch()</a>.</p>

<p><a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a> является опциональным для обработки
набора результатов, если Вы не будете вызывать функции
<a href="#mysql-stmt-data-seek"><code>
mysql_stmt_data_seek()</code></a>,
<a href="#mysql-stmt-row-seek"><code>
mysql_stmt_row_seek()</code></a> или
<a href="#mysql-stmt-row-tell"><code>
mysql_stmt_row_tell()</code></a>. Эти функции требуют
позиционируемого набора результатов.</p>

<p>Не надо вызывать <a href="#mysql-stmt-store-result">
<code>mysql_stmt_store_result()</code></a> после выполнения запроса SQL,
который не производит набор результатов, но если Вы так сделаете, это ничему
не повредит. Вы можете проверить, произвел ли запрос набор результатов,
проверяя, вернет ли <a href="#mysql-stmt-result-metadata">
<code>mysql_stmt_result_metadata()</code></a> <code>NULL</code>.</p>

<p>MySQL по умолчанию не вычисляет <code>MYSQL_FIELD-&gt;max_length</code>
для всех столбцов в <a href="#mysql-stmt-store-result">
<code>mysql_stmt_store_result()</code></a> потому, что вычисление этого
замедлило бы <a href="#mysql-stmt-store-result"><code>
mysql_stmt_store_result()</code></a> значительно, а большинство приложений не
нуждается в <code>max_length</code>. Если Вы хотите, чтобы
<code>max_length</code> обновлялось, вызовите
<a href="#mysql-stmt-attr-set"><code>
mysql_stmt_attr_set(MYSQL_STMT, STMT_ATTR_UPDATE_MAX_LENGTH, &amp;flag)
</code></a>, чтобы это включить. См.
<a href="#mysql-stmt-attr-set">
раздел 25.8.11.3. mysql_stmt_attr_set()</a>.</p>

<h5><a name="idm139965275455920"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h5><a name="idm139965275454768"></a>Ошибки</h5>
<ul><li><p><a href="error.htm#error_cr_commands_out_of_sync"><code>
CR_COMMANDS_OUT_OF_SYNC</code></a></p>
<p>Команды были выполнены в неподходящем порядке.</li>

<li><a href="error.htm#error_cr_out_of_memory"><code>
CR_OUT_OF_MEMORY</code></a></p>
<p>Мало памяти.</li>

<li><a href="error.htm#error_cr_server_gone_error"><code>
CR_SERVER_GONE_ERROR</code></a></p>
<p>Сервер MySQL недоступен.</li>

<li><a href="error.htm#error_cr_server_lost"><code>CR_SERVER_LOST
</code></a></p>
<p>Соединение с сервером было потеряно во время запроса.</li>

<li><a href="error.htm#error_cr_unknown_error"><code>
CR_UNKNOWN_ERROR</code></a></p>
<p>Произошла неизвестная ошибка.</p></li></ul>

<h3><a name="c-api-thread-functions"></a>25.8.12. Описание функций потоков
C API</h3>
<h4><a name="my-init"></a>25.8.12.1. my_init()</h4>
<p><code>void my_init(void)</code></p>

<h5><a name="idm139965275435664"></a>Описание</h5>
<p><a href="#my-init"><code>my_init()</code></a>
инициализирует некоторые глобальные переменные MySQL. Это также вызывает
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a> для этого потока.</p>

<p>Необходимо вызвать
<a href="#my-init"><code>my_init()</code></a>
в фазе инициализации использования программы библиотеки MySQL. Однако,
<a href="#my-init"><code>my_init()</code></a>
автоматически вызывается <a href="#mysql-init"><code>
mysql_init()</code></a>,
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a>, <a href="#mysql-server-init"><code>
mysql_server_init()</code></a> и
<a href="#mysql-connect"><code>mysql_connect()</code></a>.
Если Вы гарантируете, что Ваша программа вызывает одну из этих функций перед
любыми вызовами MySQL, нет потребности вызвать
<a href="#my-init"><code>my_init()</code></a> явно.</p>

<p>Чтобы получить доступ к прототипу
<a href="#my-init"><code>my_init()</code></a>
Ваша программа должна включать эти заголовочные файлы:
<pre>
#include &lt;my_global.h&gt;
#include &lt;my_sys.h&gt;
</pre>

<h5><a name="idm139965275420272"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h4><a name="mysql-thread-end"></a>25.8.12.2. mysql_thread_end()</h4>
<p><code>void mysql_thread_end(void)</code></p>

<h5><a name="idm139965275415776"></a>Описание</h5>
<p>Вызовите эту функцию перед запросом <code>pthread_exit()</code> для
освобождения памяти, выделенной
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a>.</p>

<p><a href="#mysql-thread-end"><code>mysql_thread_end()
</code></a> <span><em>не вызывается автоматически библиотекой клиента</em>
</span>. До MySQL 5.7.9 это нужно вызвать для каждого обращения к
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a>, чтобы избежать утечки памяти. С MySQL 5.7.9 внутренности C API
были переделаны, чтобы уменьшить количество информации, выделенной
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a>, это должно быть освобождено
<a href="#mysql-thread-end"><code>mysql_thread_end()
</code></a>:</p>

<ul><li><p>Поскольку релиз создается без поддержки отладки,
<a href="#mysql-thread-end"><code>mysql_thread_end()
</code></a> не должен быть вызван.</li>

<li>Для отладочных сборок
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a> выделяет информацию об отладке для пакета DBUG (см.
<a href="extend.htm#dbug-package">раздел 26.5.3. Пакет DBUG</a>).
<a href="#mysql-thread-end"><code>mysql_thread_end()
</code></a> должен быть вызван для каждого вызова
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a>, чтобы избежать утечки памяти.</p></li></ul>

<h5><a name="idm139965275398832"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h4><a name="mysql-thread-init"></a>25.8.12.3. mysql_thread_init()</h4>
<a class="indexterm" name="idm139965275396496"></a><p>
<code>my_bool mysql_thread_init(void)</code></p>

<h5><a name="idm139965275394336"></a>Описание</h5>
<p>Эта функция должна быть вызвана первой в пределах каждого создаваемого
потока, чтобы инициализировать определенные для потока переменные. Однако, Вы
не должны обязательно вызывать это явно:
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a> автоматически вызывает
<a href="#my-init"><code>my_init()</code></a>, которая
вызывается из <a href="#mysql-init"><code>mysql_init()
</code></a>,
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a>,
<a href="#mysql-server-init"><code>mysql_server_init()
</code></a> и
<a href="#mysql-connect"><code>mysql_connect()</code></a>.
Если Вы вызываете какую-либо из этих функций,
<a href="#mysql-thread-init"><code>mysql_thread_init()
</code></a> будет вызвана.</p>

<h5><a name="idm139965275384288"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h4><a name="mysql-thread-safe"></a>25.8.12.4. mysql_thread_safe()</h4>
<a class="indexterm" name="idm139965275381904"></a><p>
<code>unsigned int mysql_thread_safe(void)</code></p>

<h5><a name="idm139965275379744"></a>Описание</h5>
<p>Эта функция указывает, собрана ли библиотека клиента как
безопасная для потока.</p>
<h5><a name="idm139965275378560"></a>Возвращаемые значения</h5>
<p>1, если библиотека клиента безопасна для потока, 0 иначе.</p>

<h3><a name="c-api-embedded-server-functions"></a>25.8.13. Описание функций
C API встроенного сервера</h3>
<p>Приложения MySQL могут быть написаны, чтобы использовать встроенный
сервер. Чтобы написать такое приложение, Вы должны его скомпоновать с
библиотекой <code>libmysqld</code>, используя параметр <code>-lmysqld</code>
вместо <code>-lmysqlclient</code>. Однако, требования инициализировать и
завершить библиотеку являются теми же самыми, пишете ли Вы приложение-клиент
или то, которое использует встроенный сервер: вызовите
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a>, чтобы инициализировать библиотеку и
<a href="#mysql-library-end"><code>mysql_library_end()
</code></a>, когда Вы с ней закончите.</p>

<h4><a name="mysql-server-init"></a>25.8.13.1. mysql_server_init()</h4>
<p><code>int mysql_server_init(int argc, char **argv, char **groups)</code>
</p>

<h5><a name="idm139965275365760"></a>Описание</h5>
<p>Эта функция инициализирует библиотеку MySQL, она должна быть вызвана
прежде, чем Вы вызовете любую другую функцию MySQL. Однако,
<a href="#mysql-server-init"><code>mysql_server_init()
</code></a> устарела, поэтому Вы должны вызывать
<a href="#mysql-library-init"><code>mysql_library_init()
</code></a>.</p>

<h5><a name="idm139965275361360"></a>Возвращаемые значения</h5>
<p>
Ноль для успеха. Отличный от нуля, если ошибка произошла.
</p>

<h4><a name="mysql-server-end"></a>25.8.13.2. mysql_server_end()</h4>
<p><code>void mysql_server_end(void)</code></p>

<h5><a name="idm139965275356816"></a>Описание</h5>
<p>Эта функция завершает библиотеку MySQL, она должна быть вызвана, когда Вы
завершаете работу с MySQL. Но
<a href="#mysql-server-end"><code>mysql_server_end()
</code></a> устарела, поэтому вместо нее надо использовать
<a href="#mysql-library-end"><code>mysql_library_end()
</code></a>.</p>

<h5><a name="idm139965275352432"></a>Возвращаемые значения</h5>
<p>
Нет.
</p>

<h3><a name="c-api-plugin-functions"></a>25.8.14. Функции плагинов C API</h3>
<p>Этот раздел описывает функции, используемые для клиентского плагина API.
Они включают управление плагинами клиента. Для описания структуры
<code>st_mysql_client_plugin</code>, используемой этими функциями, см.
<a href="extend.htm#client-plugin-descriptors">раздел
26.2.4.2.3. Дескриптор плагина клиента</a>.</p>

<p>Маловероятно, что программа клиента должна вызвать функции в этом разделе.
Например, клиент, который поддерживает использование плагинов аутентификации,
обычно загружает плагин вызовом <a href="#mysql-options">
<code>mysql_options()</code></a> для установки опций
<code>MYSQL_DEFAULT_AUTH</code> и <code>MYSQL_PLUGIN_DIR</code>:

<pre>
char *plugin_dir = "<em><code>path_to_plugin_dir</code></em>";
char *default_auth = "<em><code>plugin_name</code></em>";

/* ... process command-line options ... */

mysql_options(&amp;mysql, MYSQL_PLUGIN_DIR, plugin_dir);
mysql_options(&amp;mysql, MYSQL_DEFAULT_AUTH, default_auth);
</pre>

<p>Как правило, программа также примет опции <code>--plugin-dir</code> и
<code>--default-auth</code>, которые позволяют пользователям переопределить
значения по умолчанию.</p>

<h4><a name="mysql-client-find-plugin"></a>25.8.14.1.
mysql_client_find_plugin()</h4>
<p><code>struct st_mysql_client_plugin *mysql_client_find_plugin(MYSQL *mysql,
const char *name, int type)</code></p>

<h5><a name="idm139965275337760"></a>Описание</h5>
<p>Возвращает указатель на загруженный плагин, сначала загружая плагин в
случае необходимости. Ошибка происходит, если тип недопустим, или плагин не
может быть найден или загружен. Определите параметры следующим образом:</p>

<ul><li><p><code>mysql</code>: Указатель на структуру <code>MYSQL</code>.
API плагинов не требует соединения с сервером MySQL, но эта структура должна
быть должным образом инициализирована. Структура используется, чтобы получить
связанную с соединением информацию.</li>
<li><code>name</code>: Имя плагина.</li>
<li><code>type</code>: Тип плагина.</p></li></ul>

<h5><a name="idm139965275330192"></a>Возвращаемые значения</h5>
<p>Указатель на плагин для успеха. <code>NULL</code> если ошибка произошла.
</p>

<h5><a name="idm139965275328320"></a>Ошибки</h5>
<p>Чтобы проверить на ошибки, вызовите функцию
<a href="#mysql-error"><code>mysql_error()</code></a> или
<a href="#mysql-errno"><code>mysql_errno()</code></a>.
</p>

<h5><a name="idm139965275323376"></a>Пример</h5>
<pre>
MYSQL mysql;
struct st_mysql_client_plugin *p;

if ((p = mysql_client_find_plugin(&amp;mysql, "myplugin",
                                  MYSQL_CLIENT_AUTHENTICATION_PLUGIN, 0))) {
   printf("Plugin version: %d.%d.%d\n", p-&gt;version[0], p-&gt;version[1],
          p-&gt;version[2]);
}
</pre>

<h4><a name="mysql-client-register-plugin"></a>25.8.14.2.
mysql_client_register_plugin()</h4>
<p><code>struct st_mysql_client_plugin
*mysql_client_register_plugin(MYSQL *mysql, struct
st_mysql_client_plugin *plugin)</code></p>

<h5><a name="idm139965275317856"></a>Описание</h5>
<p>Добавляет структуру к списку загруженных плагинов. Ошибка происходит, если
плагин уже загружен. Определите параметры следующим образом:</p>

<ul><li><p><code>mysql</code>: Указатель на структуру <code>MYSQL</code>.
API плагинов не требует соединения с сервером MySQL, но эта структура должна
быть должным образом инициализирована. Структура используется, чтобы получить
связанную с соединением информацию.</li>
<li><code>plugin</code>: указатель на структуру плагина.</p></li></ul>

<h5><a name="idm139965275311824"></a>Возвращаемые значения</h5>
<p>Указатель на плагин для успеха. <code>NULL</code> если ошибка произошла.
</p>

<h5><a name="idm139965275309952"></a>Ошибки</h5>
<p>Чтобы проверить на ошибки, вызовите функцию
<a href="#mysql-error"><code>mysql_error()</code></a> или
<a href="#mysql-errno"><code>mysql_errno()</code></a>.
</p>

<h4><a name="mysql-load-plugin"></a>25.8.14.3. mysql_load_plugin()</h4>
<p><code>struct st_mysql_client_plugin *mysql_load_plugin(MYSQL *mysql,
const char *name, int type, int argc, ...)</code></p>

<h5><a name="idm139965275301536"></a>Описание</h5>
<p>Загружает плагин клиента MySQL, определенный по имени и типу. Ошибка
происходит, если тип недопустим, или плагин не может быть загружен.</p>

<p>Невозможно загрузить много плагины того же самого типа. Ошибка происходит,
если Вы пытаетесь загрузить плагин уже загруженного типа. Определите
параметры следующим образом:</p>

<ul><li><p><code>mysql</code>: Указатель на структуру <code>MYSQL</code>.
API плагинов не требует соединения с сервером MySQL, но эта структура должна
быть должным образом инициализирована. Структура используется, чтобы получить
связанную с соединением информацию.</li>

<li><code>name</code>: Имя плагина.</li>
<li><code>type</code>: Тип плагина или -1, чтобы отключить проверку типа.
Если тип не -1, только плагины соответствующего типа
рассматриваются для загрузки.</li>
<li><code>argc</code>: Число следующих параметров (0, если нет ни одного).
Интерпретация любого параметра зависит от типа плагина.</p></li></ul>

<p>Другой способ загрузить плагины состоит в том, чтобы установить переменную
окружения <code>LIBMYSQL_PLUGINS</code> в список имен (разделителем является
точка с запятой). Например:
<pre>
shell&gt; export LIBMYSQL_PLUGINS="myplugin1;myplugin2"
</pre>

<p>Плагины, названные в <code>LIBMYSQL_PLUGINS</code> загружены, когда
программа клиента вызывает <a href="#mysql-library-init">
<code>mysql_library_init()</code></a>. Ни о какой ошибке не сообщается, если
проблемы происходят, загружая эти плагины.</p>

<p>Переменная окружения <code>LIBMYSQL_PLUGIN_DIR</code> может быть
установлена в путь к каталогу, в котором можно искать плагины клиента. Эта
переменная используется двумя способами:</p>

<ul><li><p>Во время предварительной загрузки плагина клиента, значение
опции <code>--plugin-dir</code> недоступно, таким образом, загрузка плагина
клиента терпит неудачу, если плагины не расположены в каталоге по умолчанию.
Если плагины расположены в другом месте, переменная окружения
<code>LIBMYSQL_PLUGIN_DIR</code> может быть установлена в надлежащий каталог.
</li>

<li>Для явной загрузки плагина клиента функции C API
<a href="#mysql-load-plugin"><code>mysql_load_plugin()
</code></a> и <a href="#mysql-load-plugin-v"><code>
mysql_load_plugin_v()</code></a> используют значение
<code>LIBMYSQL_PLUGIN_DIR</code>, если это существует и опцию
<code>--plugin-dir</code> в противном случае. Если задана
<code>--plugin-dir</code>, <a href="#mysql-load-plugin">
<code>mysql_load_plugin()</code></a> и
<a href="#mysql-load-plugin-v"><code>
mysql_load_plugin_v()</code></a> игнорируют
<code>LIBMYSQL_PLUGIN_DIR</code>.</p></li></ul>

<h5><a name="idm139965275269568"></a>Возвращаемые значения</h5>
<p>Указатель на плагин, если он был загружен успешно. <code>NULL</code>,
если ошибка произошла.</p>

<h5><a name="idm139965275267664"></a>Ошибки</h5>
<p>Для проверки на ошибки, используйте функцию
<a href="#mysql-error"><code>mysql_error()</code></a> или
<a href="#mysql-errno"><code>mysql_errno()</code></a>.
</p>

<h5><a name="idm139965275262720"></a>Пример</h5>
<pre>
MYSQL mysql;

if (!mysql_load_plugin(&amp;mysql, "myplugin",
                       MYSQL_CLIENT_AUTHENTICATION_PLUGIN, 0)) {
   fprintf(stderr, "Error: %s\n", mysql_error(&amp;mysql));
   exit(-1);
}
</pre>

<h4><a name="mysql-load-plugin-v"></a>25.8.14.4. mysql_load_plugin_v()</h4>
<p><code>struct st_mysql_client_plugin *mysql_load_plugin_v(MYSQL *mysql,
const char *name, int type, int argc, va_list args)</code></p>

<h5><a name="idm139965275254368"></a>Описание</h5>
<p>Эта функция эквивалентна
<a href="#mysql-load-plugin"><code>mysql_load_plugin()
</code></a>, но это принимает <code>va_list</code>
вместо переменной со списком параметров.</p>

<h4><a name="mysql-plugin-options"></a>25.8.14.5. mysql_plugin_options()</h4>
<p><code>int mysql_plugin_options(struct st_mysql_client_plugin *plugin,
const char *option, const void *value)</code></p>

<h5><a name="idm139965275245968"></a>Описание</h5>
<p>Передает тип опции и значение плагину. Эта функция может быть вызвана
многократно, чтобы установить несколько опций. Если у плагина нет обработчика
опции, происходит ошибка. Определите параметры следующим образом:</p>

<ul><li><p><code>plugin</code>: Указатель на структуру плагина.</li>
<li><code>option</code>: Опция, которая будет установлена.</li>
<li><code>value</code>: Указатель на значение опции.</p></li></ul>

<h5><a name="idm139965275239280"></a>Возвращаемые значения</h5>
<p>Ноль для успеха, 1, если ошибка произошла. Если у плагина есть обработчик
опции, он должен также возвратить ноль для успеха и 1, если ошибка произошла.
</p>

<h3><a name="c-api-problems"></a>25.8.15. Основные вопросы и проблемы при
использовании C API</h3>
<h4><a name="null-mysql-store-result"></a>25.8.15.1. Почему
Why mysql_store_result() иногда возвращает NULL после успешной mysql_query()
</h4>
<p>Это возможно. Когда это происходит, это означает, что одно из
следующих условий произошло:</p>

<ul><li><p>Был сбой <code>malloc()</code> (например, если набор результатов
был слишком большим).</li>
<li>Данные не могли быть прочитаны (ошибка произошла в соединении).</li>

<li>Запрос не возвратил данных (например, это был
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>).</p></li></ul>

<p>Вы можете всегда проверить, должен ли запрос привести к непустому
результату, вызывая
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a>. Если <a href="#mysql-field-count"><code>
mysql_field_count()</code></a> вернет 0, результат пуст, и последний запрос
был запросом, который не делает возвращаемых значений (например,
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>). Если
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a> возвращает ненулевое значение, запрос должен был привести к
непустому результату. См. описание функции
<a href="#mysql-field-count"><code>mysql_field_count()
</code></a>.</p>

<p>Вы можете проверить ситуацию на ошибку, вызывая
<a href="#mysql-error"><code>mysql_error()</code></a> или
<a href="#mysql-errno"><code>mysql_errno()</code></a>.
</p>

<h4><a name="query-results"></a>25.8.15.2. Какие результаты Вы можете
получить от запроса</h4>
<p>В дополнение к набору результатов, возвращенному запросом, Вы можете также
получить следующую информацию:</p>

<ul><li><p><a href="#mysql-affected-rows">
<code>mysql_affected_rows()</code></a> возвращает число строк, затронутых
последним запросом <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>.</p>

<p>Поскольку быстрее работает обновление, используйте
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>.
</li>

<li><a href="#mysql-num-rows"><code>mysql_num_rows()
</code></a> возвращает число строк в наборе результатов. С
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a>, <a href="#mysql-num-rows"><code>
mysql_num_rows()</code></a> может быть вызвана как только
<a href="#mysql-store-result"><code>mysql_store_result()
</code></a> завершится. С
<a href="#mysql-use-result"><code>mysql_use_result()
</code></a>, <a href="#mysql-num-rows"><code>
mysql_num_rows()</code></a> может быть вызвана только после того, как Вы
получили все строки через <a href="#mysql-fetch-row">
<code>mysql_fetch_row()</code></a>.</li>

<li><a href="#mysql-insert-id"><code>mysql_insert_id()
</code></a> возвращает ID, произведенный последним запросом, который вставил
строку в таблицу с индексом <code>AUTO_INCREMENT</code>.</li>

<li>Некоторые запросы (<a href="sql.htm#load-data"><code>LOAD DATA
INFILE ...</code></a>,
<a href="sql.htm#insert-select"><code>INSERT INTO ... SELECT ...
</code></a>, <a href="sql.htm#update"><code>UPDATE</code></a>)
возвращают дополнительную информацию. Результат возвращен
<a href="#mysql-info"><code>mysql_info()</code></a>. См.
описание <a href="#mysql-info"><code>mysql_info()</code>
</a> для формата строки, которую это возвращает.
<a href="#mysql-info"><code>mysql_info()</code></a>
возвращает <code>NULL</code>, если нет никакой дополнительной информации.
</p></li></ul>

<h4><a name="getting-unique-id"></a>25.8.15.3. Как получить уникальный ID для
последней вставленной строки</h4>
<p>Если Вы вставляете запись в таблицу, которая содержит столбец
<code>AUTO_INCREMENT</code>, Вы можете получить значение, сохраненное в тот
столбец, вызывая функцию <a href="#mysql-insert-id">
<code>mysql_insert_id()</code></a>.</p>

<p>Вы можете проверить из своих приложений C, было ли значение сохранено в
столбец <code>AUTO_INCREMENT</code>, выполняя следующий код (который
предполагает, что Вы проверили, что запрос прошел нормально). Это определяет,
был ли запрос <a href="sql.htm#insert"><code>INSERT</code></a>
с индексом <code>AUTO_INCREMENT</code>:

<pre>
if ((result = mysql_store_result(&amp;mysql)) == 0 &amp;&amp;
    mysql_field_count(&amp;mysql) == 0 &amp;&amp;
    mysql_insert_id(&amp;mysql) != 0) {
    used_id = mysql_insert_id(&amp;mysql);
}
</pre>

<p>Когда новое значение было произведено <code>AUTO_INCREMENT</code>, Вы
можете также получить его, выполняя <code>SELECT LAST_INSERT_ID()</code>
через <a href="#mysql-query">
<code>mysql_query()</code></a> и получая значение из набора результатов.</p>

<p>Когда вставляется много значений, вернется последнее
автоматически увеличенное значение. Для
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a> последний произведенный ID хранится на сервере с привязкой к
соединению. Это не изменено другим клиентом. Это даже не изменено, если Вы
обновляете другой столбец <code>AUTO_INCREMENT</code> с неволшебным значением
(то есть, значение, которое не является <code>NULL</code> или
<code>0</code>). Использование функции
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a> и столбцов <code>AUTO_INCREMENT</code> одновременно для многих
клиентов допустимо. Каждый клиент получит последний вставленный ID для
последнего запроса, который выполнял <span><em>этот</em></span> клиент.</p>

<p>Если Вы хотите использовать ID, который был произведен для одной таблицы,
и вставить его во вторую таблицу, Вы можете использовать запрос SQL:
<pre>
INSERT INTO foo (auto,text)
    VALUES(NULL,'text');   # generate ID by inserting NULL
INSERT INTO foo2 (id,text)
    VALUES(LAST_INSERT_ID(),'text');  # use ID in second table
</pre>

<p><a href="#mysql-insert-id">
<code>mysql_insert_id()</code></a> возвращает значение, сохраненное в
столбце <code>AUTO_INCREMENT</code>, произведено ли это значение
автоматически или было определено как явное значение.
<a href="funct.htm#function_last-insert-id">
<code>LAST_INSERT_ID()</code></a> возвращает только автоматически
произведенные значения <code>AUTO_INCREMENT</code>. Если Вы сохраняете явное
значение, кроме <code>NULL</code> или <code>0</code>, это не затрагивает
значение, возвращенное <a href="funct.htm#function_last-insert-id">
<code>LAST_INSERT_ID()</code></a>.</p>

<h3><a name="auto-reconnect"></a>25.8.16.
Управление автоматическим пересоединением</h3>
<p>Библиотека клиента MySQL может выполнить автоматическое пересоединение к
серверу, если находит, что соединение оборвалось, когда Вы пытаетесь послать
запрос серверу. Если автоматическое пересоединение включено, библиотека
попытается связаться зново и послать запрос.</p>

<p>По умолчанию пересоединение выключено. Если для Вашего приложения важно
знать, что соединение было оборвано, убедитесь, что пересоединение выключено.
Чтобы гарантировать это, вызовите
<a href="#mysql-options"><code>mysql_options()</code></a>
с опцией <code>MYSQL_OPT_RECONNECT</code>:

<pre>
my_bool reconnect = 0;
mysql_options(&amp;mysql, MYSQL_OPT_RECONNECT, &amp;reconnect);
</pre>

<p>Если соединение оборвалось эффект
<a href="#mysql-ping"><code>mysql_ping()</code></a>
зависит от состояния auto-reconnect. Если пересоединение включено,
<a href="#mysql-ping"><code>mysql_ping()</code></a>
выполняет повторное соединение. Иначе это возвращает ошибку.</p>

<p>Некоторые программы-клиенты могли бы обеспечить способность управления
автоматическим пересоединением. Например, <a href="programs.htm#mysql"><span>
<strong>mysql</strong></span></a> повторно соединяется по умолчанию, но
опция <a href="programs.htm#option_mysql_reconnect">
<code>--skip-reconnect</code></a> может использоваться, чтобы
подавить это поведение.</p>

<p>Если автоматическое пересоединение действительно происходит (например, в
результате запроса <a href="#mysql-ping"><code>
mysql_ping()</code></a>), нет никакого явного признака этого. Чтобы проверить
на пересоединение, вызовите <a href="#mysql-thread-id">
<code>mysql_thread_id()</code></a>, чтобы получить оригинальный идентификатор
соединения перед запросом
<a href="#mysql-ping"><code>mysql_ping()</code></a>,
затем вызовите
<a href="#mysql-thread-id"><code>mysql_thread_id()</code>
</a> снова, чтобы видеть, изменился ли идентификатор.</p>

<p>Автоматическое пересоединение может быть удобным, потому что Вы не должны
осуществить свое собственное, но если пересоединение действительно
происходит, несколько аспектов соединения сброшены на стороне сервера, и Ваше
приложение не будет об этом предупреждено.</p>

<p>Связанный с соединением статус затронут следующим образом:</p>
<ul><li><p>Любые активные транзакции откатываются,
режим autocommit сбрасывается.</li>

<li>Все блокировки таблиц снимаются.</li>
<li>Все таблицы <code>TEMPORARY</code> закрыты (и удалены).</li>
<li>Системные переменные сеанса повторно инициализированы к значениям
соответствующих глобальных системных переменных, включая системные
переменные, которые установлены неявно, например,
<a href="sql.htm#set-names"><code>SET NAMES</code></a>.</li>

<li>Пользовательские настройки переменных потеряны.</li>
<li>Готовые запросы отменены.</li>
<li>Переменные <a href="sql.htm#handler"><code>HANDLER</code></a>
закрыты.</li>

<li>Значение <a href="funct.htm#function_last-insert-id"><code>
LAST_INSERT_ID()</code></a> сброшено к 0.</li>
<li>Блокировки, приобретенные с <a href="funct.htm#function_get-lock">
<code>GET_LOCK()</code></a> снимаются.</li>

<li>Ассоциация клиента с исполнительной схемой
<a href="perfor.htm#threads-table"><code>threads</code></a>
строки таблицы, которая определяет инструментовку потока соединения,
потеряна. Если клиент повторно соединяется после разъединения, сеанс будет
связан с новой строкой в таблице
<a href="perfor.htm#threads-table"><code>threads</code></a> и
статус мониторинга потока может отличаться. См.
<a href="perfor.htm#threads-table">раздел
23.9.16.3. Таблица threads</a>.</p></li></ul>

<p>Если соединение разорвано, возможно, что сеанс, связанный с соединением на
стороне сервера, будет все еще работать, если сервер еще не обнаружил, что
клиент больше не соединен. В этом случае любые блокировки, проводимые
оригинальным соединением все еще, принадлежат тому сеансу, таким образом, Вы
можете хотеть уничтожить его вызовом
<a href="#mysql-kill"><code>mysql_kill()</code></a>.</p>

<h3><a name="c-api-multiple-queries"></a>25.8.17. Поддержка C API выполнения
нескольких запросов сразу</h3>
<p>По умолчанию <a href="#mysql-query"><code>
mysql_query()</code></a> и
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a> интерпретирует строковый параметр как единственный запрос,
который будет выполнен, а Вы обрабатываете результат согласно тому,
производит ли запрос набор результатов (ряд строк, как для
<a href="sql.htm#select"><code>SELECT</code></a> или количество
затронутых строк, как для <a href="sql.htm#insert"><code>INSERT
</code></a>, <a href="sql.htm#update"><code>UPDATE</code></a> и
т.п.).</p>

<p>MySQL также поддерживает выполнение строки, содержащей много запросов,
разделенных точкой с запятой (<code>;</code>). Эта способность включена
специальными опциями, которые определены также, когда Вы соединяетесь с
сервером с помощью <a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a> или вызовом
<a href="#mysql-set-server-option">
<code>mysql_set_server_option()</code></a> после соединения.</p>

<p>Выполнение строки с несколькими запросами может произвести много наборов
результатов или индикаторов количества строк. Обработка этих результатов
вовлекает другой подход, чем для случая единственного запроса: после
обработки результата первого запроса необходимо проверить, существуют ли
еще результаты и обработать их в свою очередь. Чтобы поддержать обработку
многих результатов C API включает функции
<a href="#mysql-more-results"><code>
mysql_more_results()</code></a> и
<a href="#mysql-next-result"><code>mysql_next_result()
</code></a>. Эти функции используются в цикле, который повторяется, пока еще
есть результаты. <span><em>Отказ обработать результат этим путем может
привести к сбою соединения с сервером</em></span>.</p>

<p>Обработка нескольких результатов также требуется, если Вы выполняете
вызов <a href="sql.htm#call"><code>CALL</code></a> для хранимых
процедур. У резултатов хранимой процедуры есть эти характеристики:</p>

<ul><li><p>Запросы в пределах процедуры могут произвести наборы результатов
(например, если она выполняет запросы <a href="sql.htm#select">
<code>SELECT</code></a>). Эти наборы результатов возвращены в том порядке, в
каком они произведены.</p>

<p>Вообще вызывающая сторона не может знать, сколько наборов результатов
процедура возвратит. Выполнение процедуры может зависеть от циклов или
условных запросов, которые заставляют путь выполнения отличаться от одного
вызова к другому. Поэтому Вы должны быть подготовлены к
получению многих результатов.</li>

<li>Окончательный результат процедуры результат состояния, который не
включает набор результатов. Состояние указывает, выполнилась ли процедура,
или была ошибка.</p></li></ul>

<p>Возможность использования нескольких запросов и наборов результатов можно
использовать только с
<a href="#mysql-query"><code>mysql_query()</code></a> или
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a>. Они не могут использоваться с интерфейсом готового запроса.
Готовые дескрипторы запроса определены, чтобы работать только со строками,
которые содержат единственный запрос.</p>

<p>Чтобы включить выполнению многих запросов и обработку результата,
следующие опции могут использоваться:
<ul><li><p>Функция <a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a> имеет параметр <code>flags</code>, для
которого два значения опции важны:</p>

<ul><li><p><code>CLIENT_MULTI_RESULTS</code> позволяет программе клиента
обработать много результатов. Эта опция <span><em>должна</em></span> быть
включена, если Вы выполняете запрос <a href="sql.htm#call"><code>CALL
</code></a> для хранимых процедур, которые производят наборы результатов.
Иначе, такие процедуры приводят к ошибке <code>Error 1312 (0A000):
PROCEDURE <em><code>proc_name</code></em> can't return a result set in the
given context</code>. <code>CLIENT_MULTI_RESULTS</code>
включена по умолчанию.</li>

<li><code>CLIENT_MULTI_STATEMENTS</code> включает в
<a href="#mysql-query"><code>mysql_query()</code></a> и
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a> выполнение строк запросов, содержащих много запросов, отделенных
точками с запятой. Эта опция также включает
<code>CLIENT_MULTI_RESULTS</code> неявно, таким образом, параметр
<code>flags</code> <code>CLIENT_MULTI_STATEMENTS</code> для
<a href="#mysql-real-connect"><code>mysql_real_connect()
</code></a> эквивалентен параметру
<code>CLIENT_MULTI_STATEMENTS | CLIENT_MULTI_RESULTS</code>. Таким образом,
<code>CLIENT_MULTI_STATEMENTS</code> достаточно, чтобы включить выполнение
многих запросов и всей обработки многих результатов.</li></ul></li>

<li><p>После того, как соединение с сервером было установлено, Вы можете
использовать функцию <a href="#mysql-set-server-option">
<code>mysql_set_server_option()</code></a>, чтобы включить или отключить
выполнение многих запросов, передавая параметр
<code>MYSQL_OPTION_MULTI_STATEMENTS_ON</code> или
<code>MYSQL_OPTION_MULTI_STATEMENTS_OFF</code>. Включение выполнения многих
запросов с этой функцией также позволяет обработать простые результаты для
строки запроса, где каждый запрос приводит к единственному результату, но
недостаточно, чтобы разрешить обрабатывать хранимые процедуры, которые
производят наборы результатов.</p></li></ul>

<p>Следующая процедура обрисовывает в общих чертах предложенную стратегию
обработки для запросов:</p>

<ol type="1"><li><p>Передайте <code>CLIENT_MULTI_STATEMENTS</code> в
<a href="#mysql-real-connect">
<code>mysql_real_connect()</code></a>, чтобы полностью включить выполнение
множественных запросов и обработку многих результатов.</li>

<li>После вызова <a href="#mysql-query">
<code>mysql_query()</code></a> или
<a href="#mysql-real-query"><code>mysql_real_query()
</code></a> и подтверждения, что все прошло нормально, входите в цикл,
в пределах которого Вы обрабатываете результаты запросов.</li>

<li>Для каждой итерации цикла обработайте текущий результат запроса, получая
набор результатов или количество затронутых строк. Если ошибка происходит,
выйдите из цикла.</li>

<li>В конце цикла вызовите <a href="#mysql-next-result">
<code>mysql_next_result()</code></a>, чтобы проверить, существует ли другой
результат и если он есть, начинайте работу с ним. Если больше результатов
нет, выходите из цикла.</p></li></ol>

<p>Одно возможное выполнение предыдущей стратегии показывают следующее.
Заключительная часть цикла может быть уменьшена до простого теста: возвращает
ли <a href="#mysql-next-result">
<code>mysql_next_result()</code></a> не 0.

<pre>
/* connect to server with the CLIENT_MULTI_STATEMENTS option */
if (mysql_real_connect (mysql, host_name, user_name, password,
    db_name, port_num, socket_name, CLIENT_MULTI_STATEMENTS) == NULL) {
   printf("mysql_real_connect() failed\n");
   mysql_close(mysql);
   exit(1);
}

/* execute multiple statements */
status = mysql_query(mysql, "DROP TABLE IF EXISTS test_table;\
                     CREATE TABLE test_table(id INT);\
                     INSERT INTO test_table VALUES(10);\
                     UPDATE test_table SET id=20 WHERE id=10;\
                     SELECT * FROM test_table;\
                     DROP TABLE test_table");
if (status) {
   printf("Could not execute statement(s)");
   mysql_close(mysql);
   exit(0);
}

/* process each statement result */
do {
  /* did current statement return data? */
  result = mysql_store_result(mysql);
  if (result) {
     /* yes; process rows and free the result set */
     process_result_set(mysql, result);
     mysql_free_result(result);
  }
  else    /* no result set or error */
  {
    if (mysql_field_count(mysql) == 0) {
       printf("%lld rows affected\n", mysql_affected_rows(mysql));
    }
    else  /* some error occurred */
    {
      printf("Could not retrieve result set\n");
      break;
    }
  }
  /* more results? -1 = no, &gt;0 = error, 0 = yes (keep looping) */
  if ((status = mysql_next_result(mysql)) &gt; 0)
     printf("Could not execute statement\n");
} while (status == 0);
mysql_close(mysql);
</pre>

<h3><a name="c-api-prepared-statement-problems"></a>25.8.18. Проблемы
подготовленных запросов в C API</h3>
<p>Это список известных в настоящее время проблем с готовыми запросами:
<ul><li><p><a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>TIMESTAMP</code></a> и
<a href="types.htm#datetime"><code>DATETIME</code></a>
не поддерживают части секунд (например, из
<a href="funct.htm#function_date-format"><code>DATE_FORMAT()</code>
</a>).</li>

<li>При конвертации integer в string <code>ZEROFILL</code>
не обрабатывается в некоторых случаях, где сервер MySQL не печатает начальные
нули. (Например, с <a href="funct.htm#function_min"><code>MIN(<em><code>
number-with-zerofill</code></em>)</code></a>).</li>

<li>При конвертации числа с плавающей запятой в строку в клиенте, самые
правые цифры переделанного значения могут отличаться немного от таковых
из оригинального значения.</li>

<li>Готовые запроса используют кэш запроса при условиях, описанных в
<a href="optimiz.htm#query-cache-operation">разделе 9.10.3.1.
Как работает кэш запросов</a>.</li>
<li>Готовые запроса не поддерживают множественные запросы в пределах
единственной строки, отделенные символом <code>;</code>.</li>

<li>Возможности готовых запросов
<a href="sql.htm#call"><code>CALL</code></a> рассмотрены в
<a href="#c-api-prepared-call-statements">
разделе 25.8.20. Поддержка C API подготовленных запросов CALL</a>.
</p></li></ul>

<h3><a name="c-api-prepared-statement-date-handling"></a>25.8.19.
Обработка даты и времени подготовленными запросами в C API</h3>
<p>Двоичный протокол позволяет Вам послать и получить значения даты и времени
(<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> и
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>),
используя структуру <code>MYSQL_TIME</code>. Члены этой структуры описаны в
<a href="#c-api-prepared-statement-data-structures">
разделе 25.8.9. Структуры данных подготовленных запросов в C API</a>.</p>

<p>Чтобы послать временные значения данных, создайте готовый запрос, применив
<a href="#mysql-stmt-prepare"><code>mysql_stmt_prepare()
</code></a>. Потом, перед запросом
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a> для выполнения запроса, используйте следующую процедуру, чтобы
настроить каждый параметр:</p>

<ol type="1"><li><p>В структуре <code>MYSQL_BIND</code> связанной со
значением данных установите член <code>buffer_type</code> к типу, который
указывает, какое временное значение Вы посылаете. Для значений
<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> или
<a href="types.htm#datetime"><code>TIMESTAMP</code></a> установите
<code>buffer_type</code> соответственно в
<code>MYSQL_TYPE_DATE</code>, <code>MYSQL_TYPE_TIME</code>,
<code>MYSQL_TYPE_DATETIME</code> или <code>MYSQL_TYPE_TIMESTAMP</code>.</li>

<li>Установите член <code>buffer</code> структуры <code>MYSQL_BIND</code>
к адресу структуры <code>MYSQL_TIME</code>, в которой Вы
передаете временное значение.</li>
<li>Заполните члены структуры <code>MYSQL_TIME</code>, которые являются
подходящими для типа временного значения.</p></li></ol>

<p>Используйте <a href="#mysql-stmt-bind-param"><code>
mysql_stmt_bind_param()</code></a>, чтобы связать данные о параметре с
запросом. Тогда Вы можете вызвать
<a href="#mysql-stmt-execute"><code>mysql_stmt_execute()
</code></a>.</p>

<p>Чтобы получить временные значения, процедура подобна, за исключением того,
что Вы устанавливаете <code>buffer_type</code> к типу, имеющему значение,
которое Вы ожидаете получить, а <code>buffer</code> в адресу структуры
<code>MYSQL_TIME</code>, в которую должно быть помещено возвращенное
значение. Используйте
<a href="#mysql-stmt-bind-result"><code>
mysql_stmt_bind_result()</code></a>, чтобы привязать буферы с запросом после
<a href="#mysql-stmt-execute">
<code>mysql_stmt_execute()</code></a> и прежде, чем получить результаты.</p>

<p>Вот простой пример, который вставляет данные
<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a> и
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>. Переменная
<code>mysql</code> является допустимым дескриптором соединения.</p>

<pre>
MYSQL_TIME  ts;
MYSQL_BIND  bind[3];
MYSQL_STMT  *stmt;

strmov(query, "INSERT INTO test_table(date_field, time_field, \
       timestamp_field) VALUES(?,?,?");
stmt = mysql_stmt_init(mysql);
if (!stmt) {
   fprintf(stderr, " mysql_stmt_init(), out of memory\n");
   exit(0);
}
if (mysql_stmt_prepare(mysql, query, strlen(query))) {
   fprintf(stderr, "\n mysql_stmt_prepare(), INSERT failed");
   fprintf(stderr, "\n %s", mysql_stmt_error(stmt));
   exit(0);
}
/* set up input buffers for all 3 parameters */
bind[0].buffer_type= MYSQL_TYPE_DATE;
bind[0].buffer= (char *)&amp;ts;
bind[0].is_null= 0;
bind[0].length= 0;
...
bind[1]= bind[2]= bind[0];
...
mysql_stmt_bind_param(stmt, bind);
/* supply the data to be sent in the ts structure */
ts.year= 2002;
ts.month= 02;
ts.day= 03;
ts.hour= 10;
ts.minute= 45;
ts.second= 20;
mysql_stmt_execute(stmt);
..
</pre>

<h3><a name="c-api-prepared-call-statements"></a>25.8.20.
Поддержка C API подготовленных запросов CALL</h3>
<p>Этот раздел описывает поддержку готовых запросов в C API для хранимых
процедур, выполненных, используя вызов
<a href="sql.htm#call"><code>CALL</code></a>:</p>

<p>Хранимые процедуры, выполняемые через подготовленные запросы
<a href="sql.htm#call"><code>CALL</code></a>, могут
использоваться следующими способами:</p>

<ul><li><p>Хранимая процедура может произвести любое число наборов
результатов. Число столбцов и типы данных столбцов не должны быть теми же
самым для всех наборов результатов.</li>

<li>Заключительные значения параметров <code>OUT</code> и <code>INOUT</code>
доступны приложению после завершения процедуры. Эти параметры возвращены как
дополнительный набор результатов единственной строки после любых наборов
результатов, произведенных процедурой непосредственно. Строка содержит
значения параметров <code>OUT</code> и <code>INOUT</code> в порядке, в
котором они объявлены в списке параметров процедуры.</p></li></ul>

<p>Следующее обсуждение показывает, как использовать эти способности через C
API для готовых запросов. Для использования подготовленных запросов
<a href="sql.htm#call"><code>CALL</code></a> с запросами
<a href="sql.htm#prepare"><code>PREPARE</code></a> и
<a href="sql.htm#execute"><code>EXECUTE</code></a> см.
<a href="sql.htm#call">раздел 14.2.1. Синтаксис CALL</a>.</p>

<p>Если приложение могло быть собрано или выполнено в контексте, где версия
MySQL старше 5.5.3, подготовленный <a href="sql.htm#call"><code>CALL
</code></a> не может обработать множественные наборы результатов и параметры
<code>OUT</code> или <code>INOUT</code>:</p>

<ul><li><p>Не следует компилировать клиентское приложение, если не будут
доступны библиотеки от MySQL 5.5.3 или выше (функция API и символы, введенные
в этой версии, не будут присутствовать).</li>

<li>Чтобы проверить во время выполнения, что сервер является достаточно
свежим, клиент может использовать этот тест:
<pre>
if (mysql_get_server_version(mysql) &lt; 50503) {
   fprintf(stderr, "Server does not support required CALL capabilities\n");
   mysql_close(mysql);
   exit (1);
}
</pre></li></ul>

<p>Приложение, которое выполняет готовый запрос
<a href="sql.htm#call"><code>CALL</code></a>, должно использовать
цикл, который обрабатывает результаты и затем вызывает
<a href="#mysql-stmt-next-result">
<code>mysql_stmt_next_result()</code></a> для определения наличия других
наборов результатов. Результаты состоят из любых наборов результатов,
произведенных хранимой процедурой, сопровождаемых значением окончательного
статуса, которое указывает, закончилась ли процедура успешно.</p>

<p>Если процедура имеет параметры <code>OUT</code> или <code>INOUT</code>,
набор результатов, предшествующий значению окончательного статуса, содержит
их значения. Чтобы определить, содержит ли набор результатов значения
параметра, проверьте установлен ли бит <code>SERVER_PS_OUT_PARAMS</code> в
члене <code>server_status</code> обработчика соединения <code>MYSQL</code>:
<pre>
mysql-&gt;server_status &amp; SERVER_PS_OUT_PARAMS
</pre>

<p>Следующий пример использует готовый запрос
<a href="sql.htm#call"><code>CALL</code></a>, чтобы выполнить
хранимую процедуру, которая производит множественные наборы результатов, и
предоставляет значения параметра посредством
<code>OUT</code> и <code>INOUT</code>. Процедура берет параметры всех трех
типов (<code>IN</code>, <code>OUT</code> и <code>INOUT</code>), выводит на
экран их начальные значения, назначает новые значения, выводит на экран
обновленные значения и завершается. Информация об ожидаемом возврате из
процедуры поэтому состоит из множественных наборов
результатов и окончательного статуса:</p>

<ul><li><p>Один набор результатов от
<a href="sql.htm#select"><code>SELECT</code></a>, это выводит на
экран начальные значения параметра: <code>10</code>, <code>NULL</code>,
<code>30</code>. Параметру <code>OUT</code> назначает значение вызывающий
код, но это будет неэффективно: параметры <code>OUT</code> выглядят как
<code>NULL</code> в пределах процедуры, пока им явно не будет назначено
значение в пределах процедуры.</li>

<li>Один набор результатов от
<a href="sql.htm#select"><code>SELECT</code></a>, это выводит на
экран измененные значения параметра:
<code>100</code>, <code>200</code>, <code>300</code>.</li>

<li>Один набор результатов, содержащий финальные значения параметров
<code>OUT</code> и <code>INOUT</code>: <code>200</code>, <code>300</code>.
</li>
<li>Пакет окончательного статуса.</p></li></ul>

<p>Код, чтобы выполнить процедуру:</p>
<pre>
MYSQL_STMT *stmt;
MYSQL_BIND ps_params[3];  /* input parameter buffers */
int        int_data[3];   /* input/output values */
my_bool    is_null[3];    /* output value nullability */
int        status;

/* set up stored procedure */
status = mysql_query(mysql, "DROP PROCEDURE IF EXISTS p1");
test_error(mysql, status);
status = mysql_query(mysql, "CREATE PROCEDURE p1("
                     "  IN p_in INT, "
                     "  OUT p_out INT, "
                     "  INOUT p_inout INT) "
                     "BEGIN "
                     "  SELECT p_in, p_out, p_inout; "
                     "  SET p_in = 100, p_out = 200, p_inout = 300; "
                     "  SELECT p_in, p_out, p_inout; "
                     "END");
test_error(mysql, status);
/* initialize and prepare CALL statement with parameter placeholders */
stmt = mysql_stmt_init(mysql);
if (!stmt) {
   printf("Could not initialize statement\n");
   exit(1);
}
status = mysql_stmt_prepare(stmt, "CALL p1(?, ?, ?)", 16);
test_stmt_error(stmt, status);
/* initialize parameters: p_in, p_out, p_inout (all INT) */
memset(ps_params, 0, sizeof (ps_params));
ps_params[0].buffer_type = MYSQL_TYPE_LONG;
ps_params[0].buffer = (char *) &amp;int_data[0];
ps_params[0].length = 0;
ps_params[0].is_null = 0;
ps_params[1].buffer_type = MYSQL_TYPE_LONG;
ps_params[1].buffer = (char *) &amp;int_data[1];
ps_params[1].length = 0;
ps_params[1].is_null = 0;
ps_params[2].buffer_type = MYSQL_TYPE_LONG;
ps_params[2].buffer = (char *) &amp;int_data[2];
ps_params[2].length = 0;
ps_params[2].is_null = 0;
/* bind parameters */
status = mysql_stmt_bind_param(stmt, ps_params);
test_stmt_error(stmt, status);
/* assign values to parameters and execute statement */
int_data[0]= 10;  /* p_in */
int_data[1]= 20;  /* p_out */
int_data[2]= 30;  /* p_inout */
status = mysql_stmt_execute(stmt);
test_stmt_error(stmt, status);
/* process results until there are no more */
do {
  int i;
  int num_fields; /* number of columns in result */
  MYSQL_FIELD *fields;  /* for result set metadata */
  MYSQL_BIND *rs_bind;  /* for output buffers */

  /* the column count is &gt; 0 if there is a result set */
  /* 0 if the result is only the final status packet */
  num_fields = mysql_stmt_field_count(stmt);
  if (num_fields &gt; 0) {
     /* there is a result set to fetch */
     printf("Number of columns in result: %d\n", (int) num_fields);
     /* what kind of result set is this? */
     printf("Data: ");
     if (mysql-&gt;server_status &amp; SERVER_PS_OUT_PARAMS)
        printf("this result set contains OUT/INOUT parameters\n");
     else printf("this result set is produced by the procedure\n");
     MYSQL_RES *rs_metadata = mysql_stmt_result_metadata(stmt);
     test_stmt_error(stmt, rs_metadata == NULL);
     fields = mysql_fetch_fields(rs_metadata);
     rs_bind = (MYSQL_BIND *) malloc(sizeof (MYSQL_BIND) * num_fields);
     if (!rs_bind) {
        printf("Cannot allocate output buffers\n");
        exit(1);
     }
     memset(rs_bind, 0, sizeof (MYSQL_BIND) * num_fields);
     /* set up and bind result set output buffers */
     for (i = 0; i &lt; num_fields; ++i) {
       rs_bind[i].buffer_type = fields[i].type;
       rs_bind[i].is_null = &amp;is_null[i];
       switch (fields[i].type) {
         case MYSQL_TYPE_LONG:
           rs_bind[i].buffer = (char *) &amp;(int_data[i]);
           rs_bind[i].buffer_length = sizeof (int_data);
           break;
         default:
           fprintf(stderr, "ERROR: unexpected type: %d.\n", fields[i].type);
           exit(1);
       }
     }
     status = mysql_stmt_bind_result(stmt, rs_bind);
     test_stmt_error(stmt, status);
     /* fetch and display result set rows */
     while (1) {
       status = mysql_stmt_fetch(stmt);
       if (status == 1 || status == MYSQL_NO_DATA) break;
       for (i = 0; i &lt; num_fields; ++i) {
         switch (rs_bind[i].buffer_type) {
           case MYSQL_TYPE_LONG:
             if (*rs_bind[i].is_null) printf(" val[%d] = NULL;", i);
             else printf(" val[%d] = %ld;", i,
                         (long) *((int *) rs_bind[i].buffer));
             break;
           default:
             printf("  unexpected type (%d)\n", rs_bind[i].buffer_type);
         }
       }
       printf("\n");
     }
     mysql_free_result(rs_metadata); /* free metadata */
     free(rs_bind);    /* free output buffers */
  }
  else
  {
    /* no columns = final status packet */
    printf("End of procedure output\n");
  }
  /* more results? -1 = no, &gt;0 = error, 0 = yes (keep looking) */
  status = mysql_stmt_next_result(stmt);
  if (status &gt; 0) test_stmt_error(stmt, status);
} while (status == 0);
mysql_stmt_close(stmt);
</pre>

<p>Выполнение процедуры должно произвести следующий вывод:</p>
<pre>
Number of columns in result: 3
Data: this result set is produced by the procedure
      val[0] = 10; val[1] = NULL; val[2] = 30;
Number of columns in result: 3
Data: this result set is produced by the procedure
      val[0] = 100; val[1] = 200; val[2] = 300;
Number of columns in result: 2
Data: this result set contains OUT/INOUT parameters
      val[0] = 200; val[1] = 300;
End of procedure output
</pre>

<p>Код использует две служебных функции
<code>test_error()</code> и <code>test_stmt_error()</code>, чтобы проверять
на ошибки и печати диагностической информации, если ошибка произошла:
<pre>
static void test_error(MYSQL *mysql, int status)
{
  if (status) {
     fprintf(stderr, "Error: %s (errno: %d)\n",
             mysql_error(mysql), mysql_errno(mysql));
     exit(1);
  }
}

static void test_stmt_error(MYSQL_STMT *stmt, int status)
{
  if (status) {
     fprintf(stderr, "Error: %s (errno: %d)\n",
             mysql_stmt_error(stmt), mysql_stmt_errno(stmt));
     exit(1);
  }
}
</pre>

<h2><a name="apis-php-info"></a>25.9. MySQL PHP API</h2>
<p>Руководство MySQL PHP API теперь издан в автономной форме, не как часть
полного руководства MySQL. См.
<a href="../../../dev.mysql.com/doc/apis-php/en/default.htm">MySQL и PHP</a>.</p>

<h2><a name="apis-perl"></a>25.10. MySQL Perl API</h2>
<p>Perl <code>DBI</code> модуль обеспечивает интерфейс для доступа к базе
данных. Вы можете написать скрипт DBI, который работает со многими различными
механизмами базы данных без изменения. Чтобы использовать DBI с
MySQL, установите следующее:</p>

<ol type="1"><li><p>Модуль <code>DBI</code>.</li>
<li>Модуль <code>DBD::mysql</code>. Это модуль DataBase Driver
(DBD) для Perl.</li>
<li>Опционально модуль DBD для любого другого типа сервера базы данных, к
которому Вы хотите получить доступ.</p></li></ol>

<p>Perl DBI является рекомендуемым интерфейсом Perl. Это заменяет старый
интерфейс <code>mysqlperl</code>, который нужно считать устаревшим.</p>
<p>Эти разделы содержат информацию об использовании Perl с MySQL и написании
приложений MySQL на Perl:</p>

<ul><li><p>Для инструкций по установке Perl DBI, см.
<a href="install.htm#perl-support">раздел 2.11</a>.</li>
<li>Для примера чтения опций из файлов опции, см.
<a href="server.htm#multiple-server-clients">раздел 6.7.4
</a>.</li>

<li>Для подсказок по безопасному кодированию см.
<a href="security.html#security-guidelines">раздел 7.1.1</a>.</li>
<li>Для того, чтобы отладить программу см.
<a href="extend.htm#using-gdb-on-mysqld">раздел
26.5.1.4</a>.</li>

<li>Для изучения некоторых Perl-определенных переменных окружения, см.
<a href="programs.htm#environment-variables">раздел 5.9</a>.</li>
<li>Для соображений о том, как работать на OS X, см.
<a href="install.htm#osx-installation">раздел 2.4</a>.</li>

<li>Для способов заключить строковые литералы в кавычки, см.
<a href="lang.htm#string-literals">раздел 10.1.1</a>.
</p></li></ul>

<p>Информация о DBI доступна в командной строке, онлайн или в печатной форме:
</p>
<ul><li><p>Как только Вы установите модули <code>DBI</code> и
<code>DBD::mysql</code>, Вы можете получить информацию о них в командной
строке командой <code>perldoc</code>:
<pre>
shell&gt; <strong><code>perldoc DBI</code></strong>
shell&gt; <strong><code>perldoc DBI::FAQ</code></strong>
shell&gt; <strong><code>perldoc DBD::mysql</code></strong>
</pre>
Вы можете также использовать <code>pod2man</code>, <code>pod2html</code>
и так далее, чтобы преобразовывать эту информацию в другие форматы.</li>

<li>Для информации онлайн о Perl DBI, посетите Веб-сайт DBI
<a href="../../../dbi.perl.org/default.htm">http://dbi.perl.org</a>. Этот сайт размещает
общий список рассылки DBI. Oracle Corporation размещает список определенно о
<code>DBD::mysql</code>, см.
<a href="intro.htm#mailing-lists">раздел 1.6.1</a>.</li>

<li>Для получения печатной информации есть официальная книга DBI
<em class="citetitle">Programming the Perl DBI</em> (Alligator Descartes and
Tim Bunce, O'Reilly &amp; Associates, 2000). Информация о книге доступна на
Веб-сайте DBI <a href="../../../dbi.perl.org/default.htm">http://dbi.perl.org</a>.</p>

<p>Для получения информации, которая сосредотачивается определенно на
использовании DBI с MySQL, см. <em class="citetitle">MySQL and Perl for the
Web</em> (Paul DuBois, New Riders, 2001). Веб-сайт этой книги
<a href="../../../www.kitebird.com/mysql-perl/default.htm">
http://www.kitebird.com/mysql-perl/</a>.</p></li></ul>

<h2><a name="apis-python"></a>25.11. MySQL Python API</h2>
<p><code>MySQLdb</code> драйвер третьей фирмы, который оказывает поддержку
MySQL для Python в соответствии с Python DB API version 2.0. Это может быть
найдено на <a href="../../../sourceforge.net/projects/mysql-python/default.htm">
http://sourceforge.net/projects/mysql-python/</a>.</p>

<p>Новый компонент MySQL Connector/Python предоставляет интерфейс к тому же
самому Python API, встроен в MySQL Server и поддерживается Oracle. См.
<a href="../../../dev.mysql.com/doc/connector-python/en/default.htm">MySQL
Connector/Python Developer Guide</a> для деталей.</p>

<h2><a name="apis-ruby"></a>25.12. MySQL Ruby API</h2>
<p>Два API доступны Ruby-программистам, разрабатывающим приложения MySQL:</p>
<ul><li><p>MySQL/Ruby API базируется на библиотеке
<code>libmysqlclient</code>. Для информации об установке и использовании
MySQL/Ruby API см. <a href="#apis-ruby-mysqlruby">
раздел 25.12.1</a>.</li>

<li>Ruby/MySQL API написан, чтобы использовать протокол MySQL (нативный
драйвер). Для информации об установке и использовании см.
<a href="#apis-ruby-rubymysql">раздел 25.12.2</a>.
</p></li></ul>

<h3><a name="apis-ruby-mysqlruby"></a>25.12.1. MySQL/Ruby API</h3>
<p>Модуль MySQL/Ruby обеспечивает доступ к базам данных MySQL, используя
Ruby через <code>libmysqlclient</code>.</p>
<p>Для информации об установке модуля и функциях см.
<a href="../../../tmtm.org/en/mysql/ruby/default.htm">MySQL/Ruby</a>.</p>

<h3><a name="apis-ruby-rubymysql"></a>25.12.2. Ruby/MySQL API</h3>
<p>Модуль Ruby/MySQL обеспечивает доступ к базам данных MySQL, используя
Ruby через интерфейс драйвера, используя протокол сети MySQL. Для информации
об установке модуля и функциях см.
<a href="../../../tmtm.org/en/ruby/mysql/README_en.html">Ruby/MySQL</a>.</p>

<h2><a name="apis-tcl"></a>25.13. MySQL Tcl API</h2>
<p><code>MySQLtcl</code> простой API для того, чтобы получить доступ к
серверу базы данных MySQL с помощью языка
<a href="../../../en.wikipedia.org/wiki/Tcl">Tcl</a>. Это может быть найдено на
<a href="../../../www.xdobry.de/mysqltcl/default.htm">http://www.xdobry.de/mysqltcl/</a>.
</p>

<h2><a name="apis-eiffel"></a>25.14. MySQL Eiffel Wrapper</h2>
<p>Eiffel MySQL является интерфейсом к серверу базы данных MySQL, используя
язык <a href="../../../en.wikipedia.org/wiki/Eiffel_(programming_language)">
Eiffel</a>, созданный Michael Ravits. Скачать можно на
<a href="../../../efsa.sourceforge.net/archive/ravits/mysql.htm">
http://efsa.sourceforge.net/archive/ravits/mysql.htm</a>.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
