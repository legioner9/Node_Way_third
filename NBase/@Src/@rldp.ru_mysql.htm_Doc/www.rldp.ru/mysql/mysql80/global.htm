<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 11. Глобализация</title>
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="globalization"></a>Глава 11. Глобализация</h1>
<p>Эта глава охватывает проблемы глобализации, которая включает
интернационализацию (способности MySQL к приспосабливанию к местному
использованию) и локализацию (выбирающую особые местные соглашения):</p>

<ul><li><p>MySQL поддерживает наборы символов в запросах SQL.</li>
<li>Как сконфигурировать сервер, чтобы поддержать различные наборы символов.
</li>

<li>Выбор языка для сообщений об ошибках.</li>
<li>Как установить часовой пояс сервера и включить зональную
поддержку времени соединения.</li>
<li>Выбор места для имен дня и месяца.</p></li></ul>

<h2><a name="charset"></a>11.1. Поддержка набора символов</h2>
<p>MySQL включает поддержку набора символов, которая позволяет Вам хранить
данные, используя множество наборов символов и выполнить сравнения согласно
множеству сопоставлений. Вы можете определить наборы символов в уровне
сервера, базы данных, таблицы и столбца. MySQL поддерживает использование
наборов символов для типов хранения
<code>MyISAM</code>, <code>MEMORY</code> и <code>InnoDB</code>.</p>

<p>Эта глава обсуждает следующие темы:</p>
<ul><li><p>Каковы наборы символов и сопоставления?</li>
<li>Многоуровневая система значений по умолчанию для
назначения набора символов.</li>

<li>Синтаксис для того, чтобы определить наборы символов и сопоставления.</li>
<li>Затронутые функции и операции.</li>
<li>Поддержка Unicode.</li>
<li>Наборы символов и сопоставления, которые доступны.</p></li></ul>

<p>Проблемы набора символов затрагивают не только хранение данных, но также и
связь между программами клиента и сервером MySQL. Если Вы будете хотеть,
чтобы программа клиента общалась с сервером, используя набор символов,
отличающийся от значения по умолчанию, то Вы должны будете указать, который
нужно задействовать. Например, чтобы использовать <code>utf8</code> набор
символов Unicode, сделайте эту команду после соединения с сервером:
<pre>
SET NAMES 'utf8';
</pre>

<h3><a name="charset-general"></a>11.1.1.
Наборы символов и сопоставления в общем виде</h3>
<p><span>Набор символов</span> ряд символов и кодировок.
<span>Сопоставление</span> ряд правил для того, чтобы сравнить символы в
наборе символов. Давайте ясно дадим понять различие с примером
воображаемого набора символов.</p>

<p>Предположите, что у нас есть алфавит с четырьмя буквами
<code>A</code>, <code>B</code>, <code>a</code>, <code>b</code>.
Мы даем каждой букве номер <code>A</code> = 0, <code>B</code> = 1,
<code>a</code> = 2, <code>b</code> = 3. Символ с номером 0
<span><em>кодирует</em></span> букву <code>A</code>,
комбинация всех четырех букв и их кодов и
есть <span><em>набор символов</em></span>.</p>

<p>Предположите, что мы хотим сравнить два строковых значения,
<code>A</code> и <code>B</code>. Самый простой способ сделать это: посмотреть
на коды: 0 для <code>A</code> и 1 для <code>B</code>. Поскольку 0 меньше 1,
<code>A</code> меньше <code>B</code>. То, что мы только что сделали, это
применение сопоставления к нашему набору символов. Сопоставление это ряд
правил (только одно правило в этом случае). Мы называем это самым простым из
всех возможных двоичных (<span>binary</span>) сопоставлений.</p>

<p>Но что, если мы хотим сказать, что строчные и прописные буквы
эквивалентны? Тогда у нас было бы по крайней мере два правила:
(1) Обрабатывать строчные буквы <code>a</code> и
<code>b</code> как эквивалент <code>A</code> и <code>B</code>.
(2) После этого сравнить коды. Мы называем это
<span>нечувствительным к регистру</span> сопоставлением. Это немного более
сложно, чем двоичное (binary) сопоставление.</p>

<p>В действительности у большинства наборов символов есть много символов:
не только <code>A</code> и <code>B</code>, а целые алфавиты, иногда
несколько алфавитов, или восточные системы письменности с тысячами символов,
наряду со многими специальными символами и знаками препинания.
Также в действительности, у большинства сопоставлений есть много правил, не
только для того, отличить ли регистр символов, но также и для того, отличить
ли акценты, присоединенные к символу как на немецком языке,
и для многосимвольных отображений (таких, как <code>ц√</code> = <code>OE
</code> в одном из двух немецких сопоставлений).</p>

<p>MySQL может сделать эти вещи для Вас:</p>
<ul><li><p>Строки хранятся, используя множество наборов символов.</li>
<li>Сравнивать строки, используя множество сопоставлений.</li>
<li>Смешивать строки с различными наборами символов или сопоставлениями в том
же самом сервере, той же самой базе данных или даже той же самой таблице.
</li>
<li>Включить спецификации набора символов и сопоставления на любом уровне.
</p></li></ul>

<p>Чтобы использовать эти функции эффективно, Вы должны знать, какие наборы
символов и сопоставления доступны, как изменить значения по умолчанию и как
они затрагивают поведение строковых операторов и функций.</p>

<h3><a name="charset-mysql"></a>11.1.2.
Наборы символов и сопоставления в MySQL</h3>
<p>Сервер MySQL поддерживает много наборов символов. Чтобы вывести на экран
доступные наборы символов, используйте таблицу
<a href="inform.htm#character-sets-table"><code>CHARACTER_SETS</code></a> из
<code>INFORMATION_SCHEMA</code> или запрос
<a href="sql.htm#show-character-set"><code>SHOW CHARACTER SET</code></a>.
Частичное перечисление следует. Для более полной информации см.
<a href="#charset-charsets">раздел 11.1.10</a>.
<pre>
mysql&gt; SHOW CHARACTER SET;
+---------+-----------------------------+--------------------+--------+
| Charset | Description                 | Default collation  | Maxlen |
+---------+-----------------------------+--------------------+--------+
| big5    | Big5 Traditional Chinese    | big5_chinese_ci    | 2      |
...
| latin1  | cp1252 West European        | latin1_swedish_ci  | 1      |
| latin2  | ISO 8859-2 Central European | latin2_general_ci  | 1      |
...
| utf8    | UTF-8 Unicode               | utf8_general_ci    | 3      |
| ucs2    | UCS-2 Unicode               | ucs2_general_ci    | 2      |
...
| utf8mb4 | UTF-8 Unicode               | utf8mb4_general_ci | 4      |
...
| binary  | Binary pseudo charset       | binary             | 1      |
...
</pre>

<p>По умолчанию <a href="sql.htm#show-character-set"><code>SHOW CHARACTER
SET</code></a> выводит на экран все доступные наборы символов. Это берет
дополнительно выражение <a href="funct.htm#operator_like"><code>LIKE</code>
</a> или <code>WHERE</code>, который указывает, какой набор символов
установить к соответствию. Например:
<pre>
mysql&gt; SHOW CHARACTER SET LIKE 'latin%';
+---------+-----------------------------+-------------------+--------+
| Charset | Description                 | Default collation | Maxlen |
+---------+-----------------------------+-------------------+--------+
| latin1  | cp1252 West European        | latin1_swedish_ci | 1      |
| latin2  | ISO 8859-2 Central European | latin2_general_ci | 1      |
| latin5  | ISO 8859-9 Turkish          | latin5_turkish_ci | 1      |
| latin7  | ISO 8859-13 Baltic          | latin7_general_ci | 1      |
+---------+-----------------------------+-------------------+--------+
</pre>

<p>У данного набора символов всегда есть по крайней мере одно сопоставление,
и у большинства наборов символов есть несколько. Чтобы перечислить
сопоставления для набора символов, используйте таблицу
<a href="inform.htm#collations-table"><code>COLLATIONS</code></a>
<code>INFORMATION_SCHEMA</code> или запрос
<a href="sql.htm#show-collation"><code>SHOW COLLATION</code></a>.</p>

<p>По умолчанию <a href="sql.htm#show-collation"><code>SHOW COLLATION</code>
</a> выводит на экран все доступные сопоставления. Это берет дополнительное
выражение <a href="funct.htm#operator_like"><code>LIKE</code></a> или
<code>WHERE</code>, который указывает сопоставление для показа. Например,
чтобы видеть сопоставления для набора символов <code>latin1</code> (cp1252
West European), используйте этот запрос:
<pre>
mysql&gt; SHOW COLLATION WHERE Charset = 'latin1';
+-------------------+---------+----+---------+----------+---------+
| Collation         | Charset | Id | Default | Compiled | Sortlen |
+-------------------+---------+----+---------+----------+---------+
| latin1_german1_ci | latin1  |  5 |         | Yes      | 1       |
| latin1_swedish_ci | latin1  |  8 | Yes     | Yes      | 1       |
| latin1_danish_ci  | latin1  | 15 |         | Yes      | 1       |
| latin1_german2_ci | latin1  | 31 |         | Yes      | 2       |
| latin1_bin        | latin1  | 47 |         | Yes      | 1       |
| latin1_general_ci | latin1  | 48 |         | Yes      | 1       |
| latin1_general_cs | latin1  | 49 |         | Yes      | 1       |
| latin1_spanish_ci | latin1  | 94 |         | Yes      | 1       |
+-------------------+---------+----+---------+----------+---------+
</pre>

<p>У <code>latin1</code> сопоставлений есть следующие значения.</p>
<table border="1">
<thead><tr><th scope="col">Сопоставление</th><th scope="col">Значение
</th></tr></thead>
<tbody><tr><td scope="row"><code>latin1_bin</code></td>
<td>Двоичное кодирование <code>latin1</code></td></tr>
<tr><td scope="row"><code>latin1_danish_ci</code></td>
<td>Danish/Norwegian</td></tr>
<tr><td scope="row"><code>latin1_general_ci</code></td>
<td>Multilingual (Western European)</td></tr>
<tr><td scope="row"><code>latin1_general_cs</code></td>
<td>Multilingual (ISO Western European), чувствительный к регистру</td></tr>
<tr><td scope="row"><code>latin1_german1_ci</code></td>
<td>German DIN-1 (лексикографический порядок)</td></tr>
<tr><td scope="row"><code>latin1_german2_ci</code></td>
<td>German DIN-2 (порядок телефонной книги)</td></tr>
<tr><td scope="row"><code>latin1_spanish_ci</code></td>
<td>Современный Spanish</td></tr>
<tr><td scope="row"><code>latin1_swedish_ci</code></td>
<td>Swedish/Finnish</td></tr></tbody></table>

<p>У сопоставлений есть эти общие характеристики:</p>
<ul><li><p>У двух различных наборов символов не может быть того
же самого сопоставления.</li>

<li>У каждого набора символов есть <span><em>сопоставление по умолчанию</em>
</span>. Например, сопоставление по умолчанию для
<code>latin1</code> и <code>utf8</code> <code>latin1_swedish_ci</code> и
<code>utf8_general_ci</code>, соответственно. Таблица
<code>INFORMATION_SCHEMA</code> <a href="inform.htm#character-sets-table">
<code>CHARACTER_SETS</code></a> и запрос
<a href="sql.htm#show-character-set"><code>SHOW CHARACTER SET</code></a>
указывают на сопоставление значения по умолчанию для каждого набора символов.
Таблица <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#collations-table"><code>COLLATIONS</code></a> и запрос
<a href="sql.htm#show-collation"><code>SHOW COLLATION</code></a>
имеют столбец, который указывает для каждого сопоставления, является ли это
значением по умолчанию для своего набора символов (<code>Yes</code>, если да
пустой, если нет).</li>

<li>Имена сопоставления начинаются с названия набора символов, с которым они
связаны и сопровождаются одним или более суффиксами, указывающими на другие
характеристики сопоставления. Для дополнительной информации о соглашениях о
присвоении имен см.
<a href="#charset-collation-names">раздел 11.1.3.1</a>.
</p></li></ul>

<p>Когда у набора символов есть много сопоставления, не ясно, какое
сопоставление является самым подходящим для данного приложения.
Чтобы избежать выбора несоответствующего сопоставления, выполните некоторые
сравнения с представительными значениями данных, чтобы удостовериться, что
данное сопоставление подходит.</p>

<h4><a name="charset-repertoire"></a>11.1.2.1. Строковый репертуар</h4>
<p><span>Репертуар</span> набора символов это все символы в наборе.</p>
<p>У строковых выражений есть признак репертуара, у которого может
быть два значения:</p>

<ul><li><p><code>ASCII</code>: Выражение может содержать только символы в
диапазоне Unicode от <code>U+0000</code> до <code>U+007F</code>.</li>
<li><code>UNICODE</code>: Выражение может содержать символы в диапазоне
Unicode от <code>U+0000</code> до <code>U+FFFF</code>.</p></li></ul>

<p>Диапазон <code>ASCII</code> подмножество <code>UNICODE</code>, таким
образом, строка с репертуаром <code>ASCII</code> может быть преобразована
безопасно без потери информации к набору символов любой строки с репертуаром
<code>UNICODE</code> или к набору символов, который является супернабором
<code>ASCII</code>. Все наборы символов MySQL супернаборы <code>ASCII</code>
за исключением <code>swe7</code>, какие повторно использует некоторые символы
пунктуации для шведских акцентированных символов.
Использование репертуара включает преобразование набора символов в выражениях
для многих случаев, когда MySQL иначе возвратил бы ошибку
<span>illegal mix of collations</span>.</p>

<p>Следующее обсуждение обеспечивает примеры выражений и их репертуаров и
описывает, как использование репертуара изменяет строковую оценку выражения:
</p>
<ul><li><p>Репертуар для строковых констант зависит от строкового контента:
<pre>
SET NAMES utf8; SELECT 'abc';
SELECT _utf8'def';
SELECT N'MySQL';
</pre>

<p>Строки набора символов <code>utf8</code> в каждом из предыдущих
случаев фактически не содержат символов вне диапазона ASCII, таким образом,
их репертуар <code>ASCII</code> вместо <code>UNICODE</code>.</li>

<li>Столбцы, имеющие <code>ascii</code> набор символов, имеют репертуар
<code>ASCII</code> из-за их набора символов. В следующей таблице
<code>c1</code> имеет репертуар <code>ASCII</code>:
<pre>
CREATE TABLE t1 (c1 CHAR(1) CHARACTER SET ascii);
</pre>

<p>Следующий пример иллюстрирует, как репертуар позволяет результату быть
определенным в случае, где ошибка происходит без репертуара:
<pre>
CREATE TABLE t1 (c1 CHAR(1) CHARACTER SET latin1,
                 c2 CHAR(1) CHARACTER SET ascii);
INSERT INTO t1 VALUES ('a','b');
SELECT CONCAT(c1,c2) FROM t1;
</pre>

<p>Без репертуара происходит эта ошибка:
<pre>
ERROR 1267 (HY000): Illegal mix of collations (latin1_swedish_ci,IMPLICIT)
and (ascii_general_ci,IMPLICIT) for operation 'concat'
</pre>

<p>Используя репертуар, подмножество определяется для супернабора
(<code>ascii</code> в <code>latin1</code>),
преобразование может произойти и результат возвращен:
<pre>
+---------------+
| CONCAT(c1,c2) |
+---------------+
| ab            |
+---------------+
</pre></li>

<li>Функции с одним строковым параметром наследуют репертуар своего
параметра. Результат <a href="funct.htm#function_upper"><code>UPPER
(_utf8'<em><code>abc</code></em>')</code></a> имеет репертуар
<code>ASCII</code>, потому что параметр имеет <code>ASCII</code> репертуар.
</li>

<li>Для функций, которые возвращают строку, но не имеют строковых параметров
и используют <a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> как набор символов результата, репертуар
результата <code>ASCII</code>, если
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> <code>ascii</code> и
<code>UNICODE</code> иначе:
<pre>
FORMAT(<em><code>numeric_column</code></em>, 4);
</pre>

<p>Использование репертуара изменяет то, как MySQL
оценивает следующий пример:
<pre>
SET NAMES ascii;
CREATE TABLE t1 (a INT, b VARCHAR(10) CHARACTER SET latin1);
INSERT INTO t1 VALUES (1,'b');
SELECT CONCAT(FORMAT(a, 4), b) FROM t1;
</pre>

<p>Без репертуара происходит эта ошибка:
<pre>
ERROR 1267 (HY000): Illegal mix of collations (ascii_general_ci,COERCIBLE)
and (latin1_swedish_ci,IMPLICIT) for operation 'concat'
</pre>

<p>С репертуаром возвращен результат:
<pre>
+-------------------------+
| CONCAT(FORMAT(a, 4), b) |
+-------------------------+
| 1.0000b                 |
+-------------------------+
</pre></li>

<li>Функции с двумя или больше строковыми параметрами используют
наибольший репертуар параметра для репертуара результата
(<code>UNICODE</code> более широк, чем <code>ASCII</code>).
Рассмотрите следующий вызов
<a href="funct.htm#function_concat"><code>CONCAT()</code></a>:
<pre>
CONCAT(_ucs2 X'0041', _ucs2 X'0042')
CONCAT(_ucs2 X'0041', _ucs2 X'00C2')
</pre>

<p>Для первого вызова репертуар <code>ASCII</code>, потому что оба параметра
в пределах диапазона <code>ascii</code>. Для второго вызова репертуар
<code>UNICODE</code>, потому что второй параметр вне диапазона
набора символов <code>ascii</code>.</li>

<li>Репертуар для функциональных возвращаемых значений определен исходя
только из репертуара параметров, которые затрагивают набор
символов результата и сопоставление.
<pre>
IF (column1 &lt; column2, 'smaller', 'greater')
</pre>

<p>Репертуар результата <code>ASCII</code>, потому что два строковых
параметра (второй и третий параметры) оба имеют репертуар <code>ASCII</code>.
Первый параметр не имеет значения для репертуара результата, даже если
выражение использует строковые значения.</p></li></ul>

<h4><a name="charset-metadata"></a>11.1.2.2. UTF-8 для метаданных</h4>
<p><span>Метаданные</span> это <span>данные о данных</span>. Что-либо, что
<span><em>описывает</em></span> базу данных в противоположность тому, что
<span><em>содержит</em></span> база данных.
Таким образом имена столбцов, имена базы данных, имена пользователей, имена
версий и большая часть строковых результатов из
<a href="sql.htm#show"><code>SHOW</code></a> являются метаданными.
Это также верно для содержания таблиц в <code>INFORMATION_SCHEMA</code>
потому, что те таблицы по определению содержат информацию об
объектах базы данных.</p>

<p>Представление метаданных должно удовлетворить эти требования:</p>
<ul><li><p>Все метаданные должны быть в том же самом наборе символов. Иначе,
ни один запрос <a href="sql.htm#show"><code>SHOW</code></a> или
<a href="sql.htm#select"><code>SELECT</code></a> для таблиц в
<code>INFORMATION_SCHEMA</code> не сработает должным образом,
потому что различные строки в том же самом столбце результатов этих операций
будут в различных наборах символов.</li>

<li>Метаданные должны включать все символы во всех языках.
Иначе, пользователи не будут в состоянии назвать столбцы и таблицы, используя
свои собственные языки.</p></li></ul>

<p>Чтобы удовлетворить оба требования, MySQL хранит метаданные в наборе
символов Unicode, а именно, UTF-8. Это не вызывает разрушения, если Вы
никогда не используете акцентированные или нелатинские символы. Но если Вы
это делаете, Вы должны знать, что метаданные находятся в UTF-8.</p>

<p>Метатребования к данным означают что возвращаемые значения функций
<a href="funct.htm#function_user"><code>USER()</code></a>,
<a href="funct.htm#function_current-user"><code>CURRENT_USER()</code></a>,
<a href="funct.htm#function_session-user"><code>SESSION_USER()</code></a>,
<a href="funct.htm#function_system-user"><code>SYSTEM_USER()</code></a>,
<a href="funct.htm#function_database"><code>DATABASE()</code></a> и
<a href="funct.htm#function_version"><code>VERSION()</code></a>
имеют набор символов UTF-8 по умолчанию.</p>

<p>Сервер устанавливает переменную
<a href="server.htm#sysvar_character_set_system"><code>character_set_system
</code></a> к названию набора символов метаданных:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'character_set_system';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| character_set_system | utf8  |
+----------------------+-------+
</pre>

<p>Хранение метаданных с использованием Unicode <span><em>не</em></span>
подразумевает, что сервер возвращает заголовки столбцов и результаты функции
<a href="sql.htm#describe"><code>DESCRIBE</code></a> в наборе символов
<a href="server.htm#sysvar_character_set_system"><code>character_set_system
</code></a> по умолчанию. Когда Вы используете
<code>SELECT column1 FROM t</code>, имя <code>column1</code>
непосредственно возвращено сервером клиенту в наборе символов, определенном
значением переменной <a href="server.htm#sysvar_character_set_results"><code>
character_set_results</code></a>, у которой есть значение по умолчанию
<code>latin1</code>. Если Вы хотите, чтобы сервер возвращал
результаты метаданных в ином наборе символов, используйте команду
<a href="sql.htm#set-names"><code>SET NAMES</code></a>, чтобы вынудить сервер
выполнить преобразование набора символов.
<a href="sql.htm#set-names"><code>SET NAMES</code></a> устанавливает
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a> и другие связанные системные переменные. См.
<a href="#charset-connection">раздел 11.1.4</a>.
Альтернативно, программа клиента может выполнить преобразование после
получения ответа сервера. Более эффективно для клиента выполнить
преобразование, но эта опция не всегда доступна всем клиентам.</p>

<p>Если
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a> установлена в <code>NULL</code>,
никакое преобразование не выполнено и метаданные возвращены сервером,
используя его оригинальный набор символов (набор, обозначенный
<a href="server.htm#sysvar_character_set_system"><code>character_set_system
</code></a>).</p>

<p>Сообщения об ошибках, возвращенные клиенту, преобразованы в набор символов
клиента автоматически, как с метаданными.</p>
<p>Если Вы используете (например) функцию
<a href="funct.htm#function_user"><code>USER()</code></a>
для сравнения или назначения в пределах единственного запроса,
MySQL выполняет автоматическое преобразование для Вас.
<pre>
SELECT * FROM t1 WHERE USER() = latin1_column;
</pre>

<p>Это работает потому, что содержание <code>latin1_column</code>
автоматически преобразовано в UTF-8 перед сравнением.
<pre>
INSERT INTO t1 (latin1_column) SELECT USER();
</pre>

<p>Это работает потому, что содержание
<a href="funct.htm#function_user"><code>USER()</code></a>
автоматически преобразовано в <code>latin1</code> перед назначением.</p>

<p>Хотя автоматическое преобразование не находится в стандарте SQL, документ
о стандарте SQL действительно говорит, что каждый набор символов (с точки
зрения поддержанных символов) <span>подмножество</span> Unicode.
Поскольку известный принцип, что <span>все, относящееся к супернабору,
может относиться к подмножеству</span>, сопоставление для Unicode
может применяться для сравнения со строками не-Unicode.</p>

<h3><a name="charset-syntax"></a>11.1.3.
Определение наборов символов и сопоставлений</h3>
<p>Есть настройки по умолчанию для наборов символов и сопоставлений на
четырех уровнях: сервер, база данных, таблица и столбец.
Описание в следующих разделах может казаться сложным, но было найдено
практически, что многоуровневая установка по умолчанию приводит к
естественным и очевидным результатам.</p>

<p><code>CHARACTER SET</code> используется в пунктах, которые определяют
набор символов. <code>CHARSET</code> может использоваться в качестве синонима
для <code>CHARACTER SET</code>.</p>

<p>Проблемы набора символов затрагивают не только хранение данных,
но также и связь между программами клиента и сервером MySQL. Если Вы будете
хотеть, чтобы программа клиента общалась с сервером, используя набор
символов, отличающийся от значения по умолчанию, то Вы должны будете указать,
который использовать. Например, чтобы использовать набор символов Unicode
<code>utf8mb4</code>, сделайте эту команду после соединения с сервером:
<pre>
SET NAMES 'utf8mb4';
</pre>

<h4><a name="charset-collation-names"></a>11.1.3.1.
Соглашения о присвоении имен сопоставлениям</h4>
<p>Имена сопоставлений MySQL следуют этим соглашениям:</p>

<ul><li><p>Имя сопоставления начинается с названия набора символов, с которым
это связано, сопровождается одним или более суффиксами, указывающими на
другие характеристики сопоставления. Например,
<code>utf8mb4_general_ci</code> и <code>latin1_swedish_ci</code>
сопоставления для наборов символов <code>utf8mb4</code> и
<code>latin1</code>, соответственно. У набора символов <code>binary</code>
есть единственное сопоставление, также названное
<code>binary</code> без суффиксов.</li>

<li>Определенное для языка сопоставление включает код места действия или
языковое имя. Например, <code>utf8mb4_tr_0900_ai_ci</code> и
<code>utf8mb4_hu_0900_ai_ci</code> сортируют символы набора
<code>utf8mb4</code>, используя правила Turkish и Hungarian, соответственно.
<code>utf8mb4_turkish_ci</code> и <code>utf8mb4_hungarian_ci</code>
подобны, но основаны на разных версиях алгоритма сопоставления Unicode
(Unicode Collation Algorithm).</li>

<li>Суффиксы сопоставления указывают, является ли сопоставление
чувствительным к регистру, диакритическим знакам или двочиным. Следующая
таблица показывает, что суффиксы имеют обыкновение указывать
на эти характеристики.</p>

<a name="charset-collation-sensitivity-suffixes"></a><p><b>
Таблица 11.1. Суффиксы чувствительности сопоставления</b></p>
<table><thead><tr><td align="center">Суффикс</td>
<td align="center">Смысл</td></tr></thead>
<tbody><tr><td><code>_ai</code></td>
<td>Нечувствительное к диакритическим знакам</td></tr>
<tr><td><code>_as</code></td>
<td>Чувствительное к диакритическим знакам</td></tr>
<tr><td><code>_ci</code></td><td>Нечувствительное к регистру</td></tr>
<tr><td><code>_cs</code></td><td>Чувствительное к регистру</td></tr>
<tr><td><code>_bin</code></td><td>Двоичное</td></tr></tbody></table>

<p>Для недвоичных имен сопоставления, которые не определяют чувствительность
акцента, это определено чувствительностью к регистру. Если имя сопоставления
не содержит <code>_ai</code> или <code>_as</code>, <code>_ci</code> в имени
подразумевает <code>_ai</code>, а <code>_cs</code> в имени подразумевает
<code>_as</code>. Например, <code>latin1_general_ci</code>
является явно нечувствительным к регистру и неявно не чувствительным к
диакритическим знакам, <code>latin1_general_cs</code>
является явно чувствительным к регистру и неявно чувствительным к
диакритическим знакам, а <code>utf8mb4_0900_ai_ci</code>
явно не чувствительное к регистру и диакритическим знакам.</p>

<p>Для сопоставления <code>binary</code> набора символов <code>binary</code>
сравнения основаны на числовых значениях байта. Для
сопоставления <code>_bin</code> недвоичного набора символов, сравнения
основаны на кодовых обозначениях символов , которые отличаются от значений
байта для мультибайтных символов. Для получения дополнительной информации см.
<a href="#charset-binary-collations">раздел 11.1.8.5</a>.</li>

<li>Для наборов символов Unicode имена сопоставления могут включать номер
версии, чтобы указать на версию алгоритма сопоставления Unicode (UCA), на
которой базируется сопоставление. UCA-сопоставления без номера версии
используют версию 4.0.0 UCA. Например:</p>

<ul><li><p><code>utf8mb4_0900_ai_ci</code> основано на UCA 9.0.0
(<a href="../../../www.unicode.org/Public/UCA/9.0.0/allkeys.txt"
target="_top">http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt</a>).</li>

<li><code>utf8mb4_unicode_520_ci</code> основано на UCA 5.2.0
(<a href="../../../www.unicode.org/Public/UCA/5.2.0/allkeys.txt"
target="_top">http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt</a>).</li>

<li><code>utf8mb4_unicode_ci</code> (без названной версии) основано на UCA
4.0.0 (<a href="../../../www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt"
target="_top">http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt</a>).
</p></li></ul></li>

<li><p>Для наборов символов Unicode
<code><em><code>xxx</code></em>_general_mysql500_ci</code> сопоставления
сохраняют упорядочивание pre-5.1.24 оригинального сопоставления
<code><em><code>xxx</code></em>_general_ci</code> и разрешение обновлять
таблицы, составленные до MySQL 5.1.24.</p></li></ul>

<h4><a name="charset-server"></a>11.1.3.2.
Набор символов сервера и сопоставление</h4>
<p>У сервера MySQL есть набор символов и сопоставление сервера.
Они могут быть установлены при запуске сервера в командной строке или в файле
опции и изменены во время выполнения.</p>

<p>Первоначально, набор символов сервера и сопоставление зависят от опций,
которые Вы используете, когда запускаете
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.
Вы можете использовать
<a href="server.htm#option_mysqld_character-set-server"><code>
--character-set-server</code></a> для набора символов. Наряду с этим, Вы
можете добавить <a href="server.htm#option_mysqld_collation-server"><code>
--collation-server</code></a> для сопоставления.
Если Вы определяете только набор символов (например, <code>latin1</code>),
но не сопоставление, оно является тем же самым, что в
<a href="server.htm#option_mysqld_character-set-server"><code>
--character-set-server=latin1</code></a> и
<a href="server.htm#option_mysqld_collation-server"><code>
--collation-server=latin1_swedish_ci</code></a>, потому что
<code>latin1_swedish_ci</code> сопоставление по умолчанию для
<code>latin1</code>. Поэтому, следующие три команды все имеют тот
же самый эффект:
<pre>
shell&gt; mysqld
shell&gt; mysqld --character-set-server=latin1
shell&gt; mysqld --character-set-server=latin1 \
                 --collation-server=latin1_swedish_ci
</pre>

<p>Один способ изменить настройки, это повторно собрать сервер.
Чтобы изменить набор символов сервера и сопоставление по умолчанию, создавая
пакет из исходных текстов, используйте опции
<a href="install.htm#option_cmake_default_charset"><code>DEFAULT_CHARSET
</code></a> и <a href="install.htm#option_cmake_default_collation"><code>
DEFAULT_COLLATION</code></a> для <span><strong>CMake
</strong></span>. Например:
<pre>
shell&gt; cmake . -DDEFAULT_CHARSET=latin1
</pre>

<p>Или:
<pre>
shell&gt; cmake . -DDEFAULT_CHARSET=latin1 \
                  -DDEFAULT_COLLATION=latin1_german1_ci
</pre>

<p><a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a> и
<span><strong>CMake</strong></span> проверяют, что комбинация набор
символов/сопоставление допустима.</p>

<p>Набор символов сервера и сопоставление используются в качестве значений по
умолчанию, если набор символов базы данных и сопоставление не определены в
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>.
У них нет никакой другой цели.</p>

<p>Текущий набор символов сервера и сопоставление могут быть определены из
значений системных переменных
<a href="server.htm#sysvar_character_set_server"><code>
character_set_server</code></a> и
<a href="server.htm#sysvar_collation_server"><code>collation_server</code>
</a>. Эти переменные могут быть изменены во время выполнения.</p>

<h4><a name="charset-database"></a>11.1.3.3.
Набор символов и сопоставление базы данных</h4>
<p>У каждой базы данных есть набор символов и сопоставление базы данных.
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>
и <a href="sql.htm#alter-database"><code>ALTER DATABASE</code></a>
имеют дополнительные пункты для того, чтобы определить набор символов
базы данных и сопоставление:
<pre>
CREATE DATABASE <em><code>db_name</code></em>
       [[DEFAULT] CHARACTER SET <em><code>charset_name</code></em>]
       [[DEFAULT] COLLATE <em><code>collation_name</code></em>]

ALTER DATABASE <em><code>db_name</code></em>
      [[DEFAULT] CHARACTER SET <em><code>charset_name</code></em>]
      [[DEFAULT] COLLATE <em><code>collation_name</code></em>]
</pre>

<p>Ключевое слово <code>SCHEMA</code> может
использоваться вместо <code>DATABASE</code>.</p>
<p><code>CHARACTER SET</code> и <code>COLLATE</code>
позволяют создать базы данных с различными наборами символов и
сопоставлениями на том же самом сервере MySQL.</p>

<p>Опции базы данных сохранены в словаре данных и могут быть исследованы,
проверяя таблицу <a href="inform.htm#schemata-table">
<code>INFORMATION_SCHEMA.SCHEMATA</code></a> table.</p>

<p>Пример:
<pre>
CREATE DATABASE <em><code>db_name</code></em> CHARACTER SET latin1
       COLLATE latin1_swedish_ci;
</pre>

<p>MySQL выбирает набор символов базы данных и
сопоставление в следующей манере:</p>

<ul><li><p>Если указаны <code>CHARACTER SET
<em><code>charset_name</code></em></code> и
<code>COLLATE <em><code>collation_name</code></em></code>, используются
набор символов <em><code>charset_name</code></em> и сопоставление
<em><code>collation_name</code></em>.</li>

<li>Если определен только <code>CHARACTER SET <em><code>charset_name</code>
</em></code> без <code>COLLATE</code>, используется набор символов
<em><code>charset_name</code></em> и его сопоставление по умолчанию.
Чтобы видеть сопоставление по умолчанию для каждого набора символов,
используйте команду <a href="sql.htm#show-character-set"><code>
SHOW CHARACTER SET</code></a>.</li>

<li>Если определен <code>COLLATE <em><code>collation_name</code></em></code>
без <code>CHARACTER SET</code>, используется набор символов, связанный с
<em><code>collation_name</code></em>, и сопоставление
<em><code>collation_name</code></em>.</li>

<li>Есои не определено ничего, используются
набор символов сервера и сопоставление сервера.
</p></li></ul>

<p>Набор символов и сопоставление для базы данных
по умолчанию могут быть определены через системные переменные
<a href="server.htm#sysvar_character_set_database"><code>
character_set_database</code></a> и
<a href="server.htm#sysvar_collation_database"><code>collation_database
</code></a>. Сервер устанавливает эти переменные всякий раз, когда база
данных по умолчанию изменяется. Если нет никакой базы данных по умолчанию, у
переменных есть те же самые значения, как у соответствующих системных
переменных на уровне сервера,
<a href="server.htm#sysvar_character_set_server"><code>character_set_server
</code></a> и <a href="server.htm#sysvar_collation_server"><code>
collation_server</code></a>.</p>

<p>Чтобы видеть набор символов и сопоставление по умолчанию для этой базы
данных, используйте эти запросы:
<pre>
USE <em><code>db_name</code></em>;
SELECT @@character_set_database, @@collation_database;
</pre>

<p>Альтернативно, чтобы вывести на экран значения, не изменяя базу
данных по умолчанию:
<pre>
SELECT DEFAULT_CHARACTER_SET_NAME, DEFAULT_COLLATION_NAME
       FROM INFORMATION_SCHEMA.SCHEMATA
       WHERE SCHEMA_NAME = '<em><code>db_name</code></em>';
</pre>

<p>Набор символов базы данных и сопоставление затрагивают эти
аспекты работы сервера:</p>
<ul><li><p>Для <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
набор символов базы данных и сопоставление используются в качестве значений
по умолчанию для табличных определений, если табличный набор символов и
сопоставление не определены. Чтобы переопределить это, обеспечьте явные
опции таблицы <code>CHARACTER SET</code> и <code>COLLATE</code>.</li>

<li>Для <a href="sql.htm#load-data"><code>LOAD DATA</code></a>, которые не
включают <code>CHARACTER SET</code>, сервер использует набор символов,
обозначенный системной переменной
<a href="server.htm#sysvar_character_set_database"><code>
character_set_database</code></a>, чтобы интерпретировать информацию в файле.
Чтобы переопределить это, обеспечьте явный
параметр <code>CHARACTER SET</code>.</li>

<li>Для сохраненных подпрограмм (процедуры и функции), набор символов базы
данных и сопоставление в момент создания используются в качестве набора
символов и сопоставления символьных параметров данных, для которых декларация
не включает признак <code>CHARACTER SET</code> или <code>COLLATE</code>.
Чтобы переопределить это, обеспечьте явное указание
<code>CHARACTER SET</code> и <code>COLLATE</code>.</p></li></ul>

<h4><a name="charset-table"></a>11.1.3.4.
Табличный набор символов и сопоставление</h4>
<p>У каждой таблицы есть табличный набор символов и табличное сопоставление.
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> имеют
дополнительные пункты для того, чтобы определить табличный
набор символов и сопоставление:
<pre>
CREATE TABLE <em><code>tbl_name</code></em> (<em><code>column_list</code></em>)
       [[DEFAULT] CHARACTER SET <em><code>charset_name</code></em>]
       [COLLATE <em><code>collation_name</code></em>]]

ALTER TABLE <em><code>tbl_name</code></em>
      [[DEFAULT] CHARACTER SET <em><code>charset_name</code></em>]
      [COLLATE <em><code>collation_name</code></em>]
</pre>

<p>Пример:
<pre>
CREATE TABLE t1 ( ... )
       CHARACTER SET latin1 COLLATE latin1_danish_ci;
</pre>

<p>MySQL выбирает табличный набор символов и
сопоставление в следующей манере:</p>
<ul><li><p>Если заданы набол символов <code>CHARACTER SET <em><code>
charset_name</code></em></code> и сопоставление <code>COLLATE <em><code>
collation_name</code></em></code>, они и будут использованы.</li>

<li>Если <code>CHARACTER SET <em><code>charset_name</code></em></code>
определен без <code>COLLATE</code>, используются набор символов
<em><code>charset_name</code></em> и его сопоставление по умолчанию.
Чтобы видеть сопоставление по умолчанию для каждого набора символов,
используйте <a href="sql.htm#show-character-set"><code>
SHOW CHARACTER SET</code></a>.</li>

<li>Если <code>COLLATE <em><code>collation_name</code></em></code>
определен без <code>CHARACTER SET</code>, используются набор символов,
связанный с <em><code>collation_name</code></em>, и сопоставление
<em><code>collation_name</code></em>.</li>

<li>Если не определено ничего, используются
набор символов базы данных и сопоставление.
</p></li></ul>

<p>Табличный набор символов и сопоставление используются в качестве значений
по умолчанию для определений столбца, если набор символов столбца и
сопоставление не определены в отдельных определениях столбца.
Табличный набор символов и сопоставление это расширения MySQL: в стандартном
SQL нет таких вещей.</p>

<h4><a name="charset-column"></a>11.1.3.5.
Набор символов и сопоставление столбца</h4>
<p>Каждый <span>символьный</span> столбец (то есть, столбец типа
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>)
имеет набор символов и сопоставление столбца. Синтаксис определения столбца
для <a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> имеет
дополнительные пункты для того, чтобы определить набор
символов столбца и сопоставление:
<pre>
<em><code>col_name</code></em> {CHAR | VARCHAR | TEXT} (<em><code>col_length</code></em>)
    [CHARACTER SET <em><code>charset_name</code></em>]
    [COLLATE <em><code>collation_name</code></em>]
</pre>

<p>Эти пункты могут также использоваться для столбцов
<a href="types.htm#enum"><code>ENUM</code></a> и
<a href="types.htm#set"><code>SET</code></a>:
<pre>
<em><code>col_name</code></em> {ENUM | SET} (<em><code>val_list</code></em>)
    [CHARACTER SET <em><code>charset_name</code></em>]
    [COLLATE <em><code>collation_name</code></em>]
</pre>

<p>Примеры:
<pre>
CREATE TABLE t1 (col1 VARCHAR(5) CHARACTER SET latin1
       COLLATE latin1_german1_ci);
ALTER TABLE t1 MODIFY col1 VARCHAR(5) CHARACTER SET latin1
      COLLATE latin1_swedish_ci;
</pre>

<p>MySQL выбирает набор символов столбца и сопоставление в следующей манере:
</p>

<ul><li><p>Если заданы <code>CHARACTER SET <em><code>charset_name</code></em>
</code> и <code>COLLATE <em><code>collation_name</code></em></code>,
используются набор символов <em><code>charset_name</code></em> и
сопоставление <em><code>collation_name</code></em>.
<pre>
CREATE TABLE t1 (col1 CHAR(10) CHARACTER SET utf8 COLLATE utf8_unicode_ci)
       CHARACTER SET latin1 COLLATE latin1_bin;
</pre>

<p>Набор символов и сопоставление определены для столбца, таким образом, они
используются. У столбца есть набор символов
<code>utf8</code> и сопоставление <code>utf8_unicode_ci</code>.</li>

<li>Если определен <code>CHARACTER SET <em><code>charset_name</code></em>
</code> без <code>COLLATE</code>, используются набор символов
set <em><code>charset_name</code></em> и его сопоставление по умолчанию.
<pre>
CREATE TABLE t1 (col1 CHAR(10) CHARACTER SET utf8) CHARACTER SET latin1
       COLLATE latin1_bin;
</pre>

<p>Набор символов определен для столбца, но сопоставление нет.
У столбца есть набор символов <code>utf8</code>
и сопоставление по умолчанию для <code>utf8</code>
<code>utf8_general_ci</code>. Чтобы видеть сопоставление по умолчанию для
каждого набора символов, используйте команду
<a href="sql.htm#show-character-set"><code>SHOW CHARACTER SET</code></a>.
</li>

<li>Если <code>COLLATE <em><code>collation_name</code></em></code> задан без
<code>CHARACTER SET</code>, используется набор символов, связанный с
<em><code>collation_name</code></em> и сопоставление
<em><code>collation_name</code></em>.<pre>
CREATE TABLE t1 (col1 CHAR(10) COLLATE utf8_polish_ci)
       CHARACTER SET latin1 COLLATE latin1_bin;
</pre>

<p>Сопоставление определено для столбца, но набор символов нет. У
столбца есть сопоставление <code>utf8_polish_ci</code> и набор символов,
связанный с сопоставлением, <code>utf8</code>.</li>

<li>Иначе используются табличный набор символов и сопоставление.
<pre>
CREATE TABLE t1 (col1 CHAR(10)) CHARACTER SET latin1 COLLATE latin1_bin;
</pre>

<p>Ни набор символов, ни сопоставление не определены для столбца, таким
образом, табличные значения по умолчанию используются. У столбца есть набор
символов <code>latin1</code> и сопоставление <code>latin1_bin</code>.
</p></li></ul>

<p><code>CHARACTER SET</code> и <code>COLLATE</code> стандарт SQL.</p>
<p>Если Вы используете <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>, чтобы преобразовать столбец из одного набора символов в другой, MySQL
пытается отобразить значения данных, но если наборы символов являются
несовместимыми, может быть потеря данных.</p>

<h4><a name="charset-literal"></a>11.1.3.6. Набор символов и сопоставление
строк символов</h4>
<p>У каждой строки символов есть набор символов и сопоставление.</p>

<p>Для простого запроса <code>SELECT '<em><code>string</code></em>'</code>
у строки есть набор символов по умолчанию соединения и сопоставление,
определенные системными переменными
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> и
<a href="server.htm#sysvar_collation_connection"><code>collation_connection
</code></a>.</p>

<p>У буквальной строки символов может быть дополнительный набор символов
и пункт <code>COLLATE</code>, чтобы определять это как строку, которая
использует особый набор символов и сопоставление:
<pre>
[_<em><code>charset_name</code></em>]'<em><code>string</code></em>' [COLLATE <em><code>collation_name</code></em>]
</pre>

<p>Набор символов и <code>COLLATE</code>
осуществлены согласно стандартным техническим требованиям SQL.</p>
<p>Примеры:
<pre>
SELECT 'abc';
SELECT _latin1'abc';
SELECT _binary'abc';
SELECT _utf8'abc' COLLATE utf8_danish_ci;
</pre>

<p>Выражение <code>_<em><code>charset_name</code></em></code> формально
называют <span><em>introducer</em></span>. Это говорит анализатору, что
строка, которая следует за набором символов, использует
<em><code>charset_name</code></em></span>. Здесь introducer
не изменяет строку на набор символов introducer как
<a href="funct.htm#function_convert"><code>CONVERT()</code></a>.
Это не изменяет строковое значение, хотя дополнение может произойти.
introducer только сигнал.</p>

<p>MySQL определяет набор символов и сопоставление строки
символов аналогично определениям для столбца (см. выше). Набор символов
задается <em><code>_charset_name</code></em>, сопоставление через
<code>COLLATE <em><code>collation_name</code></em></code>. Например:

<ul><li><p>Недвоичная строка с набором символов <code>latin1</code>
и сопоставлением <code>latin1_german1_ci</code>:
<pre>
SELECT _latin1'Mц╪ller' COLLATE latin1_german1_ci;
</pre></li>

<li>Недвоичная строка с набором символов <code>utf8</code> и его
сопоставлением по умолчанию (то есть, <code>utf8_general_ci</code>):
<pre>
SELECT _utf8'Mц╪ller';
</pre></li>

<li>Двоичная строка с набором символов <code>binary</code>
и его сопоставлением по умолчанию (то есть, <code>binary</code>):
<pre>
SELECT _binary'Mц╪ller';
</pre></li>

<li>Недвоичная строка с набором символов соединения по умолчанию и
сопоставлением <code>utf8_general_ci</code>
(терпит неудачу, если набор символов соединения не <code>utf8</code>):
<pre>
SELECT 'Mц╪ller' COLLATE utf8_general_ci;
</pre></li>

<li>Строка с набором символов и сопоставлением соединения по умолчанию:
<pre>
SELECT 'Mц╪ller';
</pre></li></ul>

<p>introducer указывает на набор символов для следующей строки, но не
изменяется, когда анализатор выполняет обработку escape в пределах строки.
Escape всегда интерпретируются анализатором согласно набору символов, данному
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>.</p>

<p>Следующие примеры показывают, что обработка escape происходит, используя
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>
даже в присутствии introducer. Использование в качестве примера
<a href="sql.htm#set-names"><code>SET NAMES</code></a> (который изменяет
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>, как обсуждается в
<a href="#charset-connection">разделе 11.1.4</a>),
и вывод на экран получающихся строк, используют функцию
<a href="funct.htm#function_hex"><code>HEX()</code></a>
так, чтобы точное строковое содержание могло быть замечено.</p>

<p>Пример 1:
<pre>
mysql&gt; SET NAMES latin1;
mysql&gt; SELECT HEX('ц═\n'), HEX(_sjis'ц═\n');
+------------+-----------------+
| HEX('ц═\n')| HEX(_sjis'ц═\n')|
+------------+-----------------+
| E00A       | E00A            |
+------------+-----------------+
</pre>

<p>Здесь <code>ц═</code> (шестнадцатеричное значение <code>E0</code>)
сопровождается <code>\n</code>, escape-последовательностью
для новой строки. Escape-последовательность интерпретируется, используя
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> значение которой <code>latin1</code>
предписывает произвести буквальную новую строку (шестнадцатеричное значение
<code>0A</code>). Это происходит даже для второй строки. Таким образом,
introducer <code>_sjis</code> не затрагивает обработку escape анализатором.
</p>

<p>Пример 2:
<pre>
mysql&gt; SET NAMES sjis;
mysql&gt; SELECT HEX('ц═\n'), HEX(_latin1'ц═\n');
+-------------+--------------------+
| HEX('ц═\n') | HEX(_latin1'ц═\n') |
+-------------+--------------------+
| E05C6E      | E05C6E             |
+-------------+--------------------+
</pre>

<p>Здесь <a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> <code>sjis</code>,
набор символов тот, в котором последовательность <code>ц═</code>,
сопровождаемая <code>\</code> (шестнадцатеричные значения <code>05</code>
и <code>5C</code>) допустимый мультибайтный символ. Следовательно, первые два
байта строки интерпретируются как один символ в <code>sjis</code>, а
<code>\</code> не интерпретируется как символ ESC. Следующий <code>n</code>
(шестнадцатеричное значение <code>6E</code>) не интерпретируется как часть
escape-последовательности. Это истина даже для второй строки, introducer
<code>_latin1</code> не затрагивает обработку escape.</p>

<h4><a name="charset-national"></a>11.1.3.7. Национальные наборы символов</h4>
<p>Стандартный SQL определяет <a href="types.htm#char"><code>NCHAR</code></a>
или <a href="types.htm#char"><code>NATIONAL CHAR</code></a>
как способ указать, что этот столбец
<a href="types.htm#char"><code>CHAR</code></a>
должен использовать некоторый предопределенный набор символов. MySQL
использует <code>utf8</code> как этот предопределенный набор символов.
Например, эти декларации типа данных эквивалентны:
<pre>
CHAR(10) CHARACTER SET utf8 NATIONAL CHARACTER(10) NCHAR(10)
</pre>

<p>Как они:
<pre>
VARCHAR(10) CHARACTER SET utf8
NATIONAL VARCHAR(10)
NVARCHAR(10)
NCHAR VARCHAR(10)
NATIONAL CHARACTER VARYING(10)
NATIONAL CHAR VARYING(10)
</pre>

<p>Вы можете использовать
<code>N'<em><code>literal</code></em>'</code> (или
<code>n'<em><code>literal</code></em>'</code>), чтобы
создать строку в национальном наборе. Эти заявления эквивалентны:
<pre>
SELECT N'some text';
SELECT n'some text';
SELECT _utf8'some text';
</pre>

<h4><a name="charset-introducer"></a>11.1.3.8. Набор символов Introducer</h4>
<p>У строки символов буквальное, шестнадцатеричное буквальное или буквальное
битовое значение может иметь дополнительный introducer набора символов и
предложение <code>COLLATE</code>, чтобы определять это как строку, которая
использует особый набор символов и сопоставление:
<pre>
[_<em><code>charset_name</code></em>] <em><code>literal</code></em> [COLLATE <em><code>collation_name</code></em>]
</pre>

<p>Набор символов и <code>COLLATE</code>
осуществлены согласно стандартным техническим требованиям SQL. Например:
<pre>
SELECT 'abc';
SELECT _latin1'abc';
SELECT _binary'abc';
SELECT _utf8'abc' COLLATE utf8_danish_ci;
SELECT _latin1 X'4D7953514C';
SELECT _utf8 0x4D7953514C COLLATE utf8_danish_ci;
SELECT _latin1 b'1000001';
SELECT _utf8 0b1000001 COLLATE utf8_danish_ci;
</pre>

<p>Выражение <code>_<em><code>charset_name</code></em> формально называют
<span><em>introducer</em></span>. Это говорит анализатору, что
строка, которая следует за introducer, использует набор символов
<em><code>charset_name</code></em></span>. introducer не изменяет строку,
как функция <a href="funct.htm#function_convert"><code>CONVERT()</code></a>.
Это не изменяет строковое значение, хотя дополнение может произойти.
introducer только сигнал.</p>

<p>Для строки символов пробелы между introducer и строкой разрешены,
но не требуются.</p>
<p>Строки символов могут определяться как двоичные строки при использовании
introducer <code>_binary</code>. Шестнадцатеричные и литералы битового
значения двоичные строки по умолчанию, таким образом, <code>_binary</code>
разрешен, но не нужен.</p>

<p>MySQL определяет набор символов и сопоставление строки символов
или битового значения в следующей манере:</p>
<ul><li><p>Если заданы <em><code>_charset_name</code></em> и
<code>COLLATE <em><code>collation_name</code></em></code>, используются
набор символов <em><code>charset_name</code></em> и сопоставление
<em><code>collation_name</code></em>. <em><code>collation_name</code></em>
должно быть разрешенным сопоставлением для
<em><code>charset_name</code></em>.</li>

<li>Если <em><code>_charset_name</code></em> указан без
<code>COLLATE</code>, используются набор символов
<em><code>charset_name</code></em> и его сопоставление
по умолчанию. Чтобы видеть сопоставление по умолчанию для каждого набора
символов, используйте команду <a href="sql.htm#show-character-set"><code>
SHOW CHARACTER SET</code></a>.</li>

<li>Если <em><code>_charset_name</code></em> не задан, а
<code>COLLATE <em><code>collation_name</code></em></code> указан, то:</p>
<ul><li><p>Для буквальной строки символов применяются набор символов
соединения по умолчанию, заданный переменной
<a href="server.htm#sysvar_character_set_connection">
<code>character_set_connection</code></a>, и сопоставление
<em><code>collation_name</code></em>. <em><code>collation_name</code></em>
должно быть разрешенным сопоставлением для набора символов
соединения по умолчанию.</li>

<li>Для шестнадцатеричного буквального или битового значения единственное
разрешенное сопоставление <code>binary</code> потому что эти типы данных
двоичные строки по умолчанию.</p></li></ul></li>

<li><p>Иначе:
<ul><li><p>Для буквальной строки символов используются набор символов по
умолчанию соединения и сопоставление, данные переменными
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>
и <a href="server.htm#sysvar_collation_connection"><code>collation_connection
</code></a>.</li>

<li>Для шестнадцатеричного буквального или битового значения набор символов и
сопоставление <code>binary</code> всегда.</p></li></ul></li></ul>
<p>Примеры:</p>
<ul><li><p>Недвоичные строки с набором символов <code>latin1</code> и
сопоставлением <code>latin1_german1_ci</code>:
<pre>
SELECT _latin1'Mц╪ller' COLLATE latin1_german1_ci;
SELECT _latin1 X'0A0D' COLLATE latin1_german1_ci;
SELECT _latin1 b'0110' COLLATE latin1_german1_ci;
</pre></li>

<li>Недвоичные строки с набором символов <code>utf8</code>
и его сопоставлением по умолчанию (то есть <code>utf8_general_ci</code>):
<pre>
SELECT _utf8'Mц╪ller';
SELECT _utf8 X'0A0D';
SELECT _utf8 b'0110';
</pre></li>

<li>Двоичные строки с набором<code>binary</code> символов и его
сопоставлением по умолчанию (то есть <code>binary</code>):
<pre>
SELECT _binary'Mц╪ller';
SELECT X'0A0D';
SELECT b'0110';
</pre>
<p>Шестнадцатеричные и битовые литералы не имеют
никакого introducer, потому что они двоичные строки по умолчанию.</li>

<li>Недвоичная строка с набором символов соединения по умолчанию и
сопоставлением <code>utf8_general_ci</code>
(терпит неудачу, если набор символов соединения не <code>utf8</code>):
<pre>
SELECT 'Mц╪ller' COLLATE utf8_general_ci;
</pre>

<p>Эта конструкция (только <code>COLLATE</code>), не работает на
шестнадцатеричных или битовых литералах, потому что их набор символов
<code>binary</code> независимо от того, какой набор символов соединения, и
<code>binary</code> несовместим с сопоставлением <code>utf8_general_ci
</code>.</li>

<li>Строка с набором символов и сопоставлением соединения по умолчанию:
<pre>
SELECT 'Mц╪ller';
</pre></li></ul>

<p>Для набора символов литерала introducer указывает на набор символов
следующей строки, но не изменяется, когда анализатор выполняет обработку
escape в пределах строки. Escape всегда интерпретируются анализатором
согласно набору символов, данному
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>.</p>

<h4><a name="charset-examples"></a>11.1.3.9.
Примеры назначения набора символов и сопоставления</h4>
<p>Следующие примеры показывают, как MySQL определяет набор символов и
сопоставление по умолчанию.</p>

<p><span><strong>Пример 1: Определение таблицы и столбца</strong></span>
<pre>
CREATE TABLE t1 (c1 CHAR(10) CHARACTER SET latin1 COLLATE latin1_german1_ci)
       DEFAULT CHARACTER SET latin2 COLLATE latin2_bin;
</pre>

<p>Здесь у нас есть столбец с набором символов <code>latin1</code> и
сопоставлением <code>latin1_german1_ci</code>. Определение является явным.
Заметьте, что нет никакой проблемы с хранением столбца
<code>latin1</code> в таблице <code>latin2</code>.</p>

<p><span><strong>Пример 2: Определение таблицы и столбца</strong></span>
<pre>
CREATE TABLE t1 (c1 CHAR(10) CHARACTER SET latin1)
       DEFAULT CHARACTER SET latin1 COLLATE latin1_danish_ci;
</pre>

<p>На сей раз у нас есть столбец с набором символов <code>latin1</code>
и сопоставлением по умолчанию. Хотя это могло бы казаться естественным,
сопоставление по умолчанию не взято с табличного уровня.
Вместо этого, потому что сопоставление значения по умолчанию для
<code>latin1</code> <code>latin1_swedish_ci</code>, столбец
<code>c1</code> имеет сопоставление
<code>latin1_swedish_ci</code> (не <code>latin1_danish_ci</code>).</p>

<p><span><strong>Пример 3: Определение таблицы и столбца</strong></span>
<pre>
CREATE TABLE t1 (c1 CHAR(10)) DEFAULT CHARACTER SET latin1
       COLLATE latin1_danish_ci;
</pre>

<p>У нас есть столбец с набором символов по умолчанию и сопоставлением
по умолчанию. При этом обстоятельстве MySQL проверяет табличный уровень,
чтобы определить набор символов столбца и сопоставление. Следовательно, набор
символов для столбца <code>c1</code> <code>latin1</code> и его сопоставление
<code>latin1_danish_ci</code>.</p>

<p><span><strong>Пример 4: Определение базы данных, таблицы и столбца
</strong></span>
<pre>
CREATE DATABASE d1 DEFAULT CHARACTER SET latin2 COLLATE latin2_czech_ci;
USE d1;
CREATE TABLE t1 (c1 CHAR(10));
</pre>

<p>Мы создаем столбец, не определяя его набор символов и сопоставление.
Мы также не определяем набор символов и сопоставление на табличном уровне.
При этом обстоятельстве MySQL проверяет уровень базы данных, чтобы определить
табличные настройки, которые после этого становятся настройками столбца.
Следовательно, набор символов для столбца <code>c1</code>
<code>latin2</code> и его сопоставление <code>latin2_czech_ci</code>.</p>

<h4><a name="charset-compatibility"></a>11.1.3.10.
Совместимость с другими СУБД</h4>
<p>Для MaxDB эти два запроса то же самое:
<pre>
CREATE TABLE t1 (f1 CHAR(<em><code>N</code></em>) UNICODE);
CREATE TABLE t1 (f1 CHAR(<em><code>N</code></em>) CHARACTER SET ucs2);
</pre>

<h3><a name="charset-connection"></a>11.1.4.
Наборы символов и сопоставления соединения</h3>
<p>Несколько наборов символов и системных переменных сопоставления касаются
взаимодействия клиента с сервером. Некоторые из них были упомянуты в
более ранних разделах:</p>

<ul><li><p>Набор символов сервера и сопоставление значения переменных
<a href="server.htm#sysvar_character_set_server"><code>character_set_server
</code></a> и <a href="server.htm#sysvar_collation_server"><code>
collation_server</code></a>.</li>

<li>Набор символов и сопоставление базы данных по умолчанию значения
переменных <a href="server.htm#sysvar_character_set_database"><code>
character_set_database</code></a> и
<a href="server.htm#sysvar_collation_database"><code>collation_database
</code></a>.</p></li></ul>

<p>Дополнительный набор символов и системные переменные сопоставления
вовлечены в обработку трафика для соединения между клиентом и сервером. У
каждого клиента есть связанный с соединением набор символов и
системные переменные сопоставления.</p>

<p><span>Соединение</span> это то, что Вы делаете, когда соединяетесь с
сервером. Клиент посылает запросы SQL по соединению с сервером. Сервер
посылает ответы, такие как наборы результатов или сообщения об ошибках, по
соединению назад клиенту. Это приводит к нескольким вопросам о наборе
символов и обработке сопоставления для соединений клиента, на каждый из
которых можно ответить с точки зрения системных переменных:</p>

<ul><li><p>Какой набор символов у запроса при передаче с клиента?</p>
<p>Сервер берет набор символов из системной переменной
<a href="server.htm#sysvar_character_set_client"><code>character_set_client
</code></a> в качестве набора символов, в котором клиент посылает запросы.
</li>

<li>К какому набору символов сервер должен преобразовать
запрос после получения?</p>
<p>Для этого сервер использует системные переменные
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>
и <a href="server.htm#sysvar_collation_connection"><code>
collation_connection</code></a>. Это преобразовывает запросы, посланные
клиентом из <a href="server.htm#sysvar_character_set_client"><code>
character_set_client</code></a> в
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> (за исключением строковых литералов,
у которых есть такой introducer как <code>_latin1</code> или <code>_utf8
</code>). <a href="server.htm#sysvar_collation_connection"><code>
collation_connection</code></a> важна для сравнений буквальных строк. Для
сравнений строк со значениями столбцов
<a href="server.htm#sysvar_collation_connection"><code>collation_connection
</code></a> не имеет значения, потому что у столбцов есть свое собственное
сопоставление, у которого есть более высокий приоритет сопоставления.</li>

<li>В какой набор символов сервер должен преобразовать наборы результатов или
сообщения об ошибках прежде, чем поставить назад клиенту?</p>
<p>Системная переменная
<a href="server.htm#sysvar_character_set_results"><code>
character_set_results</code></a> указывает на набор символов, в котором
сервер возвращает результаты запроса клиенту. Это включает данные о
результате, такие как значения столбцов, и метаданные о результате, такие как
имена столбцов и сообщения об ошибках.</p></li></ul>

<p>Клиенты могут точно задать настройки для этих переменных или зависеть от
значений по умолчанию (тогда Вы можете пропустить остальную часть этого
раздела). Если Вы не используете значения по умолчанию, Вы должны изменить
символьные настройки <span><em>для каждого соединения с сервером</em></span>.
</p>

<p>Два запроса затрагивают связанные с соединением переменные набора
символов как группу:</p>
<ul><li><p><code>SET NAMES '<em><code>charset_name</code></em>'
[COLLATE '<em><code>collation_name</code></em>']</code></p>

<p><a href="sql.htm#set-names"><code>SET NAMES</code></a>
указывает на то, какой набор символов клиент будет использовать, чтобы
послать запросы SQL серверу. Таким образом, <code>SET NAMES 'cp1251'</code>
говорит серверу, что <span>будущие входящие сообщения от этого клиента в
наборе символов <code>cp1251</code></span>. Это также определяет набор
символов, который сервер должен использовать для того, чтобы отослать
результаты назад клиенту. Например, это указывает на то, какой набор символов
использовать для значений столбцов, если Вы используете
<a href="sql.htm#select"><code>SELECT</code></a>.</p>

<p>Команда <code>SET NAMES '<em><code>charset_name</code></em>'</code>
эквивалентна этим трем запросам:
<pre>
SET character_set_client = <em><code>charset_name</code></em>;
SET character_set_results = <em><code>charset_name</code></em>;
SET character_set_connection = <em><code>charset_name</code></em>;
</pre>

<p>Установка <a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> в
<em><code>charset_name</code></em> также неявно задает
<a href="server.htm#sysvar_collation_connection"><code>
collation_connection</code></a> к сопоставлению по умолчанию для
<em><code>charset_name</code></em>. Не нужно устанавливать это сопоставление
явно. Чтобы определить особое сопоставление, используйте
дополнительный параметр <code>COLLATE</code>:
<pre>
SET NAMES '<em><code>charset_name</code></em>' COLLATE '<em><code>collation_name</code></em>'
</pre></li>

<li><code>SET CHARACTER SET <em><code>charset_name</code></em></code></p>
<p><a href="sql.htm#set-character-set"><code>SET CHARACTER SET</code></a>
подобно <a href="sql.htm#set-names"><code>SET NAMES</code></a>, но задает
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> и
<a href="server.htm#sysvar_collation_connection"><code>collation_connection
</code></a> в
<a href="server.htm#sysvar_character_set_database"><code>
character_set_database</code></a> и
<a href="server.htm#sysvar_collation_database"><code>collation_database
</code></a>. <a href="sql.htm#set-character-set"><code>SET CHARACTER SET
<em><code>charset_name</code></em></code></a>
эквивалентно этим трем запросам:
<pre>
SET character_set_client = <em><code>charset_name</code></em>;
SET character_set_results = <em><code>charset_name</code></em>;
SET collation_connection = @@collation_database;
</pre>

<p>Установка <a href="server.htm#sysvar_collation_connection"><code>
collation_connection</code></a> также неявно задает
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> в набор символов, связанному с
сопоставлением (эквивалентно выполнению
<code>SET character_set_connection = @@character_set_database</code>).
Не надо устанавливать <a href="server.htm#sysvar_character_set_connection">
<code>character_set_connection</code></a> явно.</p></li></ul>

<p><code>ucs2</code>, <code>utf16</code>, <code>utf16le</code> и
<code>utf32</code> не могут использоваться в качестве набора символов
клиента, это означает, что они не работают в
<a href="sql.htm#set-names"><code>SET NAMES</code></a> или
<a href="sql.htm#set-character-set"><code>SET CHARACTER SET</code></a>.</p>

<p>Программы-клиенты MySQL <code>mysql</code>,
<code>mysqladmin</code>, <code>mysqlcheck</code>,
<code>mysqlimport</code> и <code>mysqlshow</code>
определяют набор символов по умолчанию следующим образом:</p>

<ul><li><p>В отсутствие другой информации программы используют
вкомпилированный набор символов по умолчанию, обычно <code>latin1</code>.
</li>
<li>Программы могут автоматически обнаружить, который набор символов
использовать, основываясь на установке операционной системы, такой как
значение локальной переменной окружения <code>LANG</code> или <code>LC_ALL
</code> в Unix или установка кодовой страницы на системах Windows. Для
систем, на которых место действия доступно от OS, клиент использует это,
чтобы установить набор символов по умолчанию вместо того, чтобы использовать
вкомпилированный. Например, установка <code>LANG</code> в
<code>ru_RU.KOI8-R</code> предписывает использовать набор символов
<code>koi8r</code>. Таким образом, пользователи могут сконфигурировать место
действия в своей среде для использования клиентами MySQL.</p>

<p>Набор символов OS отображен на самый близкий набор символов MySQL, если
нет никакого точного совпадения. Если клиент не поддерживает соответствующий
набор символов, он использует вкомпилированный. Например,
<code>ucs2</code> не поддержан как набор символов соединения.</p>

<p>C-приложение может использовать автоматическое обнаружение набора
символов, основанное на установке OS, вызывая
<a href="connect.htm#mysql-options"><code>mysql_options()</code></a>
следующим образом прежде, чем соединиться с сервером:
<pre>
mysql_options(mysql, MYSQL_SET_CHARSET_NAME, MYSQL_AUTODETECT_CHARSET_NAME);
</pre></li>

<li>Программы поддерживают опцию
<a href="programs.htm#option_mysql_default-character-set"><code>
--default-character-set</code></a>, которая позволяет пользователям
определить набор символов явно, чтобы переопределить значение клиента.
</p></li></ul>

<p>Когда клиент соединяется с сервером, это посылает название набора
символов, который хочет использовать. Сервер использует имя для установки
системных переменных <a href="server.htm#sysvar_character_set_client"><code>
character_set_client</code></a>,
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a> и
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>. В действительности сервер выполняет
<a href="sql.htm#set-names"><code>SET NAMES</code></a>, используя
имя набора символов.</p>

<p>С клиентом <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a>, чтобы использовать набор символов, отличающийся от значения по
умолчанию, Вы можете явно выполнить
<a href="sql.htm#set-names"><code>SET NAMES</code></a>
каждый раз, когда Вы запускаете клиент. Чтобы достигнуть того же самого
результата более легко, добавьте опцию
<a href="programs.htm#option_mysql_default-character-set"><code>
--default-character-set</code></a> в Вашу командную строку
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
или в Ваш файл опции. Например, следующая установка файла опции изменяет три
связанных с соединением набора переменных, задавая
<code>koi8r</code> каждый раз, когда Вы вызываете
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>:
<pre>
[mysql]
default-character-set=koi8r
</pre>

<p>Если Вы используете <a href="programs.htm#mysql"><span><strong>mysql
</strong></span></a> с включенным автоматическим пересоединением
(не рекомендуется), предпочтительно использовать команду <code>charset
</code>, а не <a href="sql.htm#set-names"><code>SET NAMES</code></a>. Пример:
<pre>
mysql&gt; charset utf8
Charset changed
</pre>

<p>Команда <code>charset</code> вызывает
<a href="sql.htm#set-names"><code>SET NAMES</code></a>
и также изменяет набор символов по умолчанию, который использует
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>,
когда повторно соединяется после того, как соединение прервалось.</p>

<p>Пример: Предположите, что <code>column1</code> определен как
<code>CHAR(5) CHARACTER SET latin2</code>. Если Вы не говорите
<a href="sql.htm#set-names"><code>SET NAMES</code></a> или
<a href="sql.htm#set-character-set"><code>SET CHARACTER SET</code></a>,
тогда для <code>SELECT column1 FROM t</code>
сервер отсылает все значения для <code>column1</code> назад с использованием
набора символов, который определил клиент, когда он соединялся.
С другой стороны, если Вы говорите <code>SET NAMES 'latin1'</code> или
<code>SET CHARACTER SET latin1</code> прежде, чем вызвать
<a href="sql.htm#select"><code>SELECT</code></a>, сервер преобразовывает
значения <code>latin2</code> в <code>latin1</code>
прежде, чем отослать результаты назад. Преобразование может быть с потерями,
если есть символы, которые не находятся в обоих наборах символов.</p>

<p>Если Вы хотите, чтобы сервер не выполнил преобразования наборов
результатов или сообщений об ошибках, установите
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a> в <code>NULL</code> или <code>binary</code>:
<pre>
SET character_set_results = NULL;
</pre>

<p>Чтобы видеть значения набора символов и системных переменных
сопоставления, которые относятся к Вашему соединению,
используйте эти запросы:
<pre>
SHOW VARIABLES LIKE 'character_set%';
SHOW VARIABLES LIKE 'collation%';
</pre>

<p>Вы должны также рассмотреть окружающую среду, в пределах которой Ваши
приложения MySQL выполняются. См.
<a href="#charset-applications">раздел 11.1.5</a>.</p>

<h3><a name="charset-applications"></a>11.1.5.
Конфигурирование набора символов и сопоставления приложения</h3>
<p>Для приложений, которые хранят данные, используя набор символов MySQL и
сопоставление по умолчанию (<code>latin1</code>,
<code>latin1_swedish_ci</code>), никакая специальная конфигурация не нужна.
Если приложения требуют хранения данных, используя иной набор символов или
сопоставление, Вы можете сконфигурировать информацию о наборе
символов несколько путями:</p>

<ul><li><p>Определите символьные настройки базы данных. Например, приложения,
которые используют одну базу данных, могли бы потребовать <code>utf8</code>,
тогда как приложения, которые используют другую базу данных, <code>sjis
</code>.</li>

<li>Определите символьные настройки при запуске сервера. Это заставляет
сервер использовать данные настройки для всех приложений, которые не
делают другие приготовления.</li>

<li>Определите символьные настройки во время конфигурации, если Вы создаете
MySQL из исходных текстов. Это заставляет сервер использовать данные
настройки для всех приложений, не имея необходимость определять их
при запуске сервера.</p></li></ul>

<p>Когда различные приложения требуют различных символьных настроек,
метод базы данных обеспечивает большую гибкость. Если больше всего или все
приложения используют тот же самый набор символов, определение символьных
настройек при запуске сервера или во время конфигурации может
быть самым удобным.</p>

<p>Для методов базы данных или запуска сервера настройки управляют набором
символов для хранения данных. Приложения должны также сказать серверу,
который набор символов использовать для коммуникаций клиент-сервер,
как описано в следующих инструкциях.</p>

<p>Примеры, показанные здесь, принимают использование набора символов
<code>utf8</code> и сопоставления <code>utf8_general_ci</code>.</p>
<p><span><strong>Определите символьные настройки для базы данных</strong>
</span>. Чтобы создать базу данных таким образом, что ее таблицы будут
использовать данный набор символов по умолчанию и сопоставление для хранения
данных, используйте запрос <a href="sql.htm#create-database"><code>CREATE
DATABASE</code></a> как этот:
<pre>
CREATE DATABASE mydb DEFAULT CHARACTER SET utf8
       DEFAULT COLLATE utf8_general_ci;
</pre>

<p>Таблицы, составленные в базе данных, будут использовать <code>utf8</code>
и <code>utf8_general_ci</code> по умолчанию для любых символьных столбцов.
</p>
<p>Приложения, которые используют базу данных, должны также сконфигурировать
свое соединение с сервером каждый раз, когда они соединяются.
Это может быть сделано, выполняя команду <code>SET NAMES 'utf8'</code> после
соединения. Запрос может использоваться независимо от метода соединения:
клиент <a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>,
PHP-скрипт или что-то еще.</p>

<p>В некоторых случаях может быть возможно сконфигурировать соединение, чтобы
использовать желаемый набор символов некоторым другим путем. Например, для
соединений, сделанных, используя <a href="programs.htm#mysql"><span><strong>
mysql</strong></span></a>, Вы можете определить опцию командной строки
<a href="programs.htm#option_mysql_default-character-set"><code>
--default-character-set=utf8</code></a>, чтобы достигнуть того же самого
эффекта, что и от <code>SET NAMES 'utf8'</code>.</p>

<p>Если Вы изменяете набор символов или сопоставление для базы данных,
сохраненные подпрограммы, которые используют значения по умолчанию базы
данных, должны быть удалены и обновлены так, чтобы они использовали новые
значения по умолчанию. В сохраненной подпрограмме переменные с символьными
типами данных используют значения по умолчанию базы данных, если набор
символов или сопоставление не определены явно. См.
<a href="sql.htm#create-procedure">раздел 14.1.13</a>.</p>

<p><span><strong>Определите символьные настройки при запуске сервера
</strong></span>. Чтобы выбрать набор символов и сопоставление при запуске
сервера, используйте опции
<a href="server.htm#option_mysqld_character-set-server"><code>
--character-set-server</code></a> и
<a href="server.htm#option_mysqld_collation-server"><code>--collation-server
</code></a>. Например, чтобы определить опции в файле опции,
включите эти строки:
<pre>
[mysqld]
character-set-server=utf8
collation-server=utf8_general_ci
</pre>

<p>Эти настройки применяются для всего серверакак значения по умолчанию для
баз данных, создаваемых любым приложением, и для таблиц, составленных в
тех базах данных.</p>

<p>Все еще необходимо для приложений сконфигурировать их использование
соединения с помощью <a href="sql.htm#set-names"><code>SET NAMES</code></a>
или эквивалента после того, как они соединяются, как описано ранее. Вы могли
запустить сервер с опцией
<a href="server.htm#sysvar_init_connect"><code>--init_connect="SET NAMES
'utf8'"</code></a>, чтобы вызвать выполнение
<a href="sql.htm#set-names"><code>SET NAMES</code></a> автоматически
для каждого клиента, который соединяется. Однако, это приведет к
непоследовательным результатам, потому что значение
<a href="server.htm#sysvar_init_connect"><code>init_connect</code></a>
не выполнено для пользователей, которые имеют привилегию
<a href="security.html#priv_super"><code>SUPER</code></a>.</p>

<p><span><strong>Определите символьные настройки во время конфигурации MySQL
</strong></span>. Чтобы выбрать набор символов и сопоставление, когда Вы
конфигурируете и создаете MySQL из исходных текстов, используйте опции
<a href="install.htm#option_cmake_default_charset"><code>DEFAULT_CHARSET
</code></a> и <a href="install.htm#option_cmake_default_collation"><code>
DEFAULT_COLLATION</code></a> для <span><strong>CMake</strong></span>:
<pre>
shell&gt; cmake . -DDEFAULT_CHARSET=utf8 \
                  -DDEFAULT_COLLATION=utf8_general_ci
</pre>

<p>В итоге сервер использует <code>utf8</code> и <code>utf8_general_ci</code>
как значение по умолчанию для баз данных, таблиц и для соединений клиента.
Не надо использовать <a href="server.htm#option_mysqld_character-set-server">
<code>--character-set-server</code></a> и
<a href="server.htm#option_mysqld_collation-server"><code>--collation-server
</code></a>, чтобы определить эти значения по умолчанию при запуске сервера.
Для приложений нет надобности конфигурировать их использование соединения
через <a href="sql.htm#set-names"><code>SET NAMES</code></a>
после того, как они соединяются с сервером.</p>

<p>Независимо от того, как Вы конфигурируете набор символов MySQL для
использования приложения, Вы должны также рассмотреть окружающую среду, в
пределах которой те приложения выполняются. Если Вы пошлете запросы,
используя текст UTF-8, взятый из файла, который Вы создаете в редакторе, Вы
должны отредактировать файл с местом действия Вашей окружающей среды, задав
UTF-8 так, чтобы кодирование файла было правильно и операционная система
обработала это правильно. Если Вы используете клиент
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
из окна терминала, окно должно быть сконфигурировано, чтобы использовать
UTF-8, или символы, возможно, не выведутся на экран должным образом.
Для скрипта, который выполняется в Веб-среде, скрипт должен обработать
кодировку символов должным образом для ее взаимодействия с сервером MySQL, и
это должно произвести страницы, которые правильно указывают на кодировку
так, чтобы браузеры знали, как вывести на экран контент страниц.
Например, Вы можете включать этот тэг <code>&lt;meta&gt;</code>
в пределах Вашего элемента <code>&lt;head&gt;</code>:
<pre>
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
</pre>

<h3><a name="charset-errors"></a>11.1.6.
Набор символов для сообщений об ошибках</h3>
<p>Этот раздел описывает, как сервер MySQL использует наборы символов для
того, чтобы создать сообщения об ошибках и возвратить их клиентам. Для
информации о языке сообщений об ошибках (а не набор символов) см.
<a href="#error-message-language">раздел 11.2</a>.</p>

<p>Сервер создает сообщения об ошибках, используя UTF-8 и возвращает их
клиентам в наборе символов, определенном переменной
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a>.</p>

<p>Сервер создает сообщения об ошибках следующим образом:</p>
<ul><li><p>Шаблон сообщения использует UTF-8.</li>
<li>Параметры в шаблоне сообщения заменены значениями, которые относятся к
определенной ошибочной ситуации:</p>

<ul><li><p>Идентификаторы, такие как имена таблиц или столбцов, используют
UTF-8 внутренне, таким образом, они скопированы как есть.</li>
<li>Символьные (недвоичные) строковые значения преобразованы из их
набора символов в UTF-8.</li>

<li>Двоичные строковые значения скопированы, как есть для байтов в диапазоне
от <code>0x20</code> до <code>0x7E</code> и с использованием <code>\x</code>
шестнадцатеричного кодирования для байтов вне этого диапазона.
Например, если ошибка дублировани ключа происходит для попытки вставить
<code>0x41CF9F</code> в уникальный столбец
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>,
получающееся сообщение об ошибке использует UTF-8 с некоторыми
байтами, закодированными шестнадцатерично:
<pre>
Duplicate entry 'A\xC3\x9F' for key 1
</pre></li></ul></li></ul>

<p>Чтобы возвратить сообщение клиенту после того, как это было создано,
сервер преобразовывает его из UTF-8 в набор символов, определенный
системной переменной <a href="server.htm#sysvar_character_set_results"><code>
character_set_results</code></a>. Если
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a> имеет значение <code>NULL</code> или <code>binary</code>,
никакое преобразование не происходит. Никакого преобразования не происходит,
если переменная имеет значение <code>utf8</code>, потому что это
соответствует оригинальному набору символов сообщения об ошибке.</p>

<p>Для символов, которые не могут быть представлены в
<a href="server.htm#sysvar_character_set_results"><code>
character_set_results</code></a>, некоторое кодирование может произойти во
время преобразования. Кодирование использует значения кодовой точки Unicode:
</p>

<ul><li><p>Символы в Basic Multilingual Plane (BMP)
(диапазон <code>0x0000</code> до <code>0xFFFF</code>) записаны, используя
нотацию <code>\<em><code>nnnn</code></em></code>.</li>

<li>Символы вне диапазона BMP (<code>0x01000</code> до <code>0x10FFFF</code>)
записаны, используя нотацию <code>\+<em><code>nnnnnn</code></em></code>.
</p></li></ul>

<p>Клиенты могут установить
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a>, чтобы управлять набором символов, в котором они получают
сообщения об ошибках. Переменная может быть установлена непосредственно или
косвенно, средствами
<a href="sql.htm#set-names"><code>SET NAMES</code></a>.</p>

<p>Кодирование, которое происходит во время преобразования в
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a> прежде, чем возвратить сообщения об ошибках клиентам может
привести к различному контенту сообщения по сравнению с более ранними
версиями (до MySQL 5.5). Например, если ошибка происходит для попытки
удалить названную таблицу с именем <code>Ц┐ </code> (KATAKANA LETTER PE) и
<a href="server.htm#sysvar_character_set_results"><code>character_set_results
</code></a> установлена в такой набор символов, как <code>latin1</code>,
который не содержит этот символ, у получающегося сообщения, посланного
клиенту, есть закодированное имя таблицы:
<pre>
ERROR 1051 (42S02): Unknown table '\30DA'
</pre>

<p>До MySQL 5.5 имя не кодировалось:
<pre>
ERROR 1051 (42S02): Unknown table 'Ц┐ '
</pre>

<h3><a name="charset-conversion"></a>11.1.7.
Преобразование набора символов столбца</h3>
<p>Чтобы преобразовать двоичный или недвоичный строковый столбец, чтобы
использовать особый набор символов, надо использовать
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Для успешного
преобразования должно примениться одно из следующих условий:</p>

<ul><li><p>Если у столбца есть тип двоичных данных
(<a href="types.htm#binary-varbinary"><code>BINARY</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>),
все значения, которые он содержит, должны быть закодированы, используя
единственный набор символов (набор символов, в который Вы преобразуете
столбец). Если Вы используете двоичный столбец, чтобы хранить информацию в
нескольких наборах символов, у MySQL нет никакого способа узнать, какое
значение какой набор символов использует, и сервер не может преобразовать
данные должным образом.</li>

<li>Если у столбца есть тип недвоичных данных
(<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>),
его содержание должно быть закодировано в наборе символов столбца, а не
некотором другом наборе символов. Если содержание закодировано в ином наборе
символов, Вы можете преобразовать столбец, чтобы сначала использовать
двоичные данные, а затем перейти к недвоичному столбцу с
желаемым набором символов.</p></li></ul>

<p>Предположите, что таблица <code>t</code> имеет двоичной столбец
определенный как <code>VARBINARY(50)</code>. Предполагая, что информация в
столбце закодирована, используя единственный набор символов, Вы можете
преобразовать это в недвоичной столбец, у которого есть тот набор символов.
Например, если <code>col1</code> содержит двоичные данные, представляющие
символы в наборе символов <code>greek</code>, Вы можете преобразовать
это следующим образом:
<pre>
ALTER TABLE t MODIFY col1 VARCHAR(50) CHARACTER SET greek;
</pre>

<p>Если у Вашего оригинального столбца есть тип <code>BINARY(50)</code>,
Вы могли преобразовать это в <code>CHAR(50)</code>,
но получающиеся значения будут дополнены в конце байтами <code>0x00</code>,
которые могут быть нежелательны. Чтобы удалить эти байты, используйте
функцию <a href="funct.htm#function_trim"><code>TRIM()</code></a>:
<pre>
UPDATE t SET col1 = TRIM(TRAILING 0x00 FROM col1);
</pre>

<p>Предположите, что таблица <code>t</code> имеет недвоичной столбец
<code>col1</code> определенный как <code>CHAR(50) CHARACTER SET latin1
</code>, но Вы хотите преобразовать это, чтобы использовать <code>utf8</code>
так, чтобы Вы могли сохранить значения многих языков.
Следующий запрос достигает этого:
<pre>
ALTER TABLE t MODIFY col1 CHAR(50) CHARACTER SET utf8;
</pre>

<p>Преобразование может быть с потерями, если столбец содержит символы,
которые не находятся в обоих наборах символов.</p>

<p>Особый случай происходит, если у Вас есть старые таблицы до MySQL 4.1, где
недвоичной столбец содержит значения, которые фактически закодированы в
наборе символов, отличающемся от набора символов значения по умолчанию
сервера. Например, приложение, возможно, сохранило значения
<code>sjis</code> в столбце, даже при том, что набор символов значения по
умолчанию MySQL был <code>latin1</code>. Возможно преобразовать столбец,
чтобы использовать надлежащий набор символов, но требуется дополнительный
шаг. Предположите, что набор символов по умолчанию сервера был
<code>latin1</code> и <code>col1</code> определен как <code>CHAR(50)</code>,
но его содержание значения <code>sjis</code>. Первый шаг должен преобразовать
столбец в тип двоичных данных, который удаляет существующую информацию о
наборе символов, не выполняя преобразования символов:
<pre>
ALTER TABLE t MODIFY col1 BLOB;
</pre>

<p>Следующий шаг должен преобразовать столбец в тип недвоичных данных с
надлежащим набором символов:
<pre>
ALTER TABLE t MODIFY col1 CHAR(50) CHARACTER SET sjis;
</pre>

<p>Эта процедура требует, чтобы таблица не была изменена такими запросами,
как <a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a> после обновления до MySQL
4.1 или позже. В этом случае MySQL сохранил бы новые значения в
<code>latin1</code>, и столбец будет содержать чудовищную смесь значений
<code>sjis</code> и <code>latin1</code>, которую уже не преобразовать.</p>

<p>Если Вы определили признаки, создавая столбец первоначально,
то Вы должны также определить их, изменяя таблицу с
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Например, если Вы определили <code>NOT NULL</code> и явное значение
<code>DEFAULT</code>, Вы должны также обеспечить их в
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Иначе получающееся определение столбца не будет включать те признаки.</p>

<p>Преобразовать все символьные столбцы в таблице, может быть полезным
запрос <code>ALTER TABLE ... CONVERT TO CHARACTER SET
<em><code>charset</code></em></code>.
См. <a href="sql.htm#alter-table">раздел 14.1.7</a>.</p>

<h3><a name="charset-collations"></a>11.1.8. Проблемы сопоставления</h3>
<p>Следующие разделы обсуждают различные аспекты
сопоставлений набора символов.</p>

<h4><a name="charset-collate"></a>11.1.8.1.
Использование COLLATE в запросах SQL</h4>
<p>С <code>COLLATE</code> Вы можете переопределить сопоставление
по умолчанию для сравнения. <code>COLLATE</code> может использоваться в
различных частях запросов SQL. Вот некоторые примеры:</p>

<ul><li><p>С <code>ORDER BY</code>:
<pre>
SELECT k FROM t1 ORDER BY k COLLATE latin1_german2_ci;
</pre></li>

<li>С <code>AS</code>:
<pre>
SELECT k COLLATE latin1_german2_ci AS k1 FROM t1 ORDER BY k1;
</pre></li>

<li>С <code>GROUP BY</code>:
<pre>
SELECT k FROM t1 GROUP BY k COLLATE latin1_german2_ci;
</pre></li>

<li>С агрегатными функциями:
<pre>
SELECT MAX(k COLLATE latin1_german2_ci) FROM t1;
</pre></li>

<li>С <code>DISTINCT</code>:
<pre>
SELECT DISTINCT k COLLATE latin1_german2_ci FROM t1;
</pre></li>

<li>С <code>WHERE</code>:
<pre>
SELECT * FROM t1 WHERE _latin1 'Mц╪ller' COLLATE latin1_german2_ci = k;
SELECT * FROM t1 WHERE k LIKE _latin1 'Mц╪ller' COLLATE latin1_german2_ci;
</pre></li>

<li>С <code>HAVING</code>:
<pre>
SELECT k FROM t1 GROUP BY k HAVING k = _latin1 'Mц╪ller'
       COLLATE latin1_german2_ci;
</pre></li></ul>

<h4><a name="charset-collate-precedence"></a>11.1.8.2. Приоритет COLLATE</h4>
<p><code>COLLATE</code> имеет высокий приоритет (выше, чем
<a href="funct.htm#operator_or"><code>||</code></a>),
таким образом, следующие два выражения эквивалентны:
<pre>
x || y COLLATE z
x || (y COLLATE z)
</pre>

<h4><a name="charset-collation-compatibility"></a>11.1.8.3.
Набор символов и совместимость сопоставления</h4>
<p>У каждого набора символов есть одно или более сопоставлений, но каждое
сопоставление связано с одним и только одним набором символов. Поэтому,
следующий запрос вызывает сообщение об ошибке потому, что сопоставление
<code>latin2_bin</code> не является законным с
набором символов <code>latin1</code>:
<pre>
mysql&gt; SELECT _latin1 'x' COLLATE latin2_bin;
ERROR 1253 (42000): COLLATION 'latin2_bin' is not valid
for CHARACTER SET 'latin1'
</pre>

<h4><a name="charset-collation-expressions"></a>11.1.8.4.
Сопоставление выражений</h4>
<p>В значительном большинстве запросов очевидно, что сопоставление решает
работу сравнения. Например, в следующих случаях, должно быть ясно, что
сопоставлением будет сопоставление столбца <code>charset_name</code>:
<pre>
SELECT x FROM T ORDER BY x;
SELECT x FROM T WHERE x = x;
SELECT DISTINCT x FROM T;
</pre>

<p>Однако, с несколькими операндами, может быть двусмысленность. Например:
<pre>
SELECT x FROM T WHERE x = 'Y';
</pre>

<p>Использовать в сравнении сопоставление столбца <code>x</code> или
буквальной строки <code>'Y'</code>? Оба объекта <code>x</code> и
<code>'Y'</code> имейте сопоставления, какое сопоставление имеет приоритет?
</p>

<p>Стандартный SQL решает эту проблему, используя правила
<span>coercibility</span>. MySQL назначает значения
coercibility следующим образом:</p>

<ul><li><p>Явное <code>COLLATE</code> имеет coercibility 0.
(Не coercible вообще.)</li>
<li>У связи двух строк с различными сопоставлениями есть coercibility 1.</li>

<li>У сопоставления столбца, сохраненного обычного параметра или местной
переменной есть coercibility 2.</li>
<li><span>Системная константа</span> (строка, возвращенная такими функциями,
как <a href="funct.htm#function_user"><code>USER()</code></a> или
<a href="funct.htm#function_version"><code>VERSION()</code></a>)
имеет coercibility 3.</li>

<li>У сопоставления литерала есть coercibility 4.</li>
<li><code>NULL</code> или выражение, которое получено из
<code>NULL</code>, имеет coercibility 5.</p></li></ul>

<p>MySQL использует значения coercibility со следующими правилами,
чтобы решить двусмысленности:</p>

<ul><li><p>Используйте сопоставление с самым низким значением coercibility.
</li>
<li>Если у обеих сторон есть тот же самый coercibility, то:</p>
<ul><li><p>Если обе стороны Unicode, или обе стороны не Unicode, это ошибка.
</li>

<li>Если у одной из сторон есть набор символов Unicode, и у другой стороны
есть не-Unicode набор символов, сторона с набором символов Unicode важней, и
автоматическое преобразование набора символов применено к не-Unicode стороне.
Например, следующий запрос не возвращает ошибку:
<pre>
SELECT CONCAT(utf8_column, latin1_column) FROM t1;
</pre>

<p>Это возвращает результат, у которого есть набор символов
<code>utf8</code> и то же самое сопоставление, какое у
<code>utf8_column</code>. Значения <code>latin1_column</code>
автоматически преобразованы в <code>utf8</code> перед связыванием.</li>

<li>Для работы с операндами того же самого набора символов, но в смеси
сопоставлений <code>_bin</code> и <code>_ci</code> или <code>_cs</code>
сопоставление <code>_bin</code> используется. Это подобно тому, как операции,
которые смешивают недвоичные и двоичные строки, оценивают операнды как
двоичные строки, за исключением того, что это для сопоставлений, а
не типов данных.</p></li></ul></li></ul>

<p>Хотя автоматическое преобразование не в стандарте SQL, стандартный
документ SQL действительно говорит, что каждый набор символов (с точки зрения
поддержанных символов) <span>подмножество</span> Unicode.
Поскольку известный принцип гласит, что
<span>то, что применяется к к супернабору, может относиться к подмножеству
</span>, мы полагаем, что сопоставление для Unicode может просить сравнения
со строками не-Unicode. Например:</p>

<table border="1">
<thead><tr><th scope="col">Сравнение</th>
<th scope="col">Используемое сопоставление</th></tr></thead>
<tbody><tr><td scope="row"><code>column1 = 'A'</code></td>
<td>Используйте сопоставление <code>column1</code></td></tr>
<tr><td scope="row"><code>column1 = 'A' COLLATE x</code></td>
<td>Используйте сопоставление <code>'A' COLLATE x</code></td></tr>
<tr><td scope="row"><code>column1 COLLATE x = 'A' COLLATE y</code></td>
<td>Ошибка</td></tr></tbody></table>

<p>Функция <a href="funct.htm#function_coercibility"><code>COERCIBILITY()
</code></a> может использоваться, чтобы определить
coercibility строкового выражения:
<pre>
mysql&gt; SELECT COERCIBILITY('A' COLLATE latin1_swedish_ci);
    -&gt; 0
mysql&gt; SELECT COERCIBILITY(VERSION());
    -&gt; 3
mysql&gt; SELECT COERCIBILITY('A');
    -&gt; 4
</pre>

<p>Для неявного преобразования числового или временного значения к строке,
которое происходит для параметра <code>1</code> в выражении
<a href="funct.htm#function_concat"><code>CONCAT(1, 'abc')</code></a>,
результат символьная (недвоичная) строка, у которой есть набор символов и
сопоставление, определенное переменными
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a> и
<a href="server.htm#sysvar_collation_connection"><code>collation_connection
</code></a>. См. <a href="funct.htm#type-conversion">раздел 13.2</a>.</p>

<h4><a name="charset-binary-collations"></a>11.1.8.5.
Двоичное сопоставление по сравнению с сопоставлениями _bin</h4>
<p>Этот раздел описывает как сопоставление <code>binary</code>
для двоичных строк сравнивается с сопоставлением <code>_bin</code>
для недвоичных строк.</p>

<p>Двоичные строки (сохраненные с использованием типов данных
<a href="types.htm#binary-varbinary"><code>BINARY</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a> и
<a href="types.htm#blob"><code>BLOB</code></a>)
имеют набор символов и сопоставление <code>binary</code>.
Двоичные строки это просто последовательности байтов, числовые значения тех
байтов определяют сравнение и порядок сортировки.</p>

<p>Недвоичные строки (сохраненные с использованием типов данных
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>)
имеют набор символов и сопоставление не <code>binary</code>.
У данного недвоичного набора символов может быть несколько сопоставлений,
каждое из которых определяет особое сравнение и порядок сортировки для
символов в наборе. Один из них двоичное сопоставление для набора символов,
обозначенное суффиксом <code>_bin</code>. Например, двоичные сопоставления
для <code>latin1</code> и <code>utf8</code> названы
<code>latin1_bin</code> и <code>utf8_bin</code>, соответственно.</p>
<p>Сопоставление <code>binary</code> отличается от
<code>_bin</code> в нескольких отношениях.</p>

<p><b>Модуль для сравнения и сортировки.</b> Двоичные строки это
последовательности байтов. Для сопоставления <code>binary</code>
сравнение и сортировка основаны на числовых значениях байта. Недвоичные
строки последовательности символов, которые могли бы быть мультибайтными.
Сопоставления для недвоичных строк определяют упорядочивание символьных
значений для сравнения и сортировки. Для сопоставления <code>_bin</code>
упорядочивание основано на кодовых обозначениях цифры, что подобно
упорядочиванию для двоичных строк за исключением того, что символьные кодовые
обозначения могут быть мультибайтными.</p>

<p><b>Преобразование набора символов.</b> Недвоичная строка имеет набор
символов и автоматически преобразована в другой набор символов во многих
случаях, даже когда у строки есть сопоставление <code>_bin</code>:</p>

<ul><li><p>Назначая значения столбцов от другого столбца, у которого есть
иной набор символов:
<pre>
UPDATE t1 SET utf8_bin_column=latin1_column;
INSERT INTO t1 (latin1_column) SELECT utf8_bin_column FROM t2;
</pre></li>

<li>Назначая значения столбцов для
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>
с использование буквальной строки:
<pre>
SET NAMES latin1;
INSERT INTO t1 (utf8_bin_column) VALUES ('string-in-latin1');
</pre></li>

<li>Посылая результаты с сервера клиенту:
<pre>
SET NAMES latin1;
SELECT utf8_bin_column FROM t2;
</pre></li></ul>
<p>Для двоичных строковых столбцов не происходит никакого преобразования.
Для предыдущих случаев строковое значение скопировано побайтно.</p>

<p><b>Преобразование регистра.</b> Сопоставления для недвоичных наборов
символов предоставляют информацию о регистре символов, таким образом, символы
в недвоичной строке могут быть преобразованы из одного регистра в другой,
даже для сопоставления <code>_bin</code>, которое игнорирует регистр
для того, чтобы упорядочить:
<pre>
mysql&gt; SET NAMES latin1 COLLATE latin1_bin;
mysql&gt; SELECT LOWER('aA'), UPPER('zZ');
+-------------+-------------+
| LOWER('aA') | UPPER('zZ') |
+-------------+-------------+
| aa          | ZZ          |
+-------------+-------------+
</pre>

<p>Понятие регистра не относится к байтам в двоичной строке. Чтобы выполнить
преобразование, строка должна быть преобразована в недвоичную строку:
<pre>
mysql&gt; SET NAMES binary;
mysql&gt; SELECT LOWER('aA'), LOWER(CONVERT('aA' USING latin1));
+-------------+-----------------------------------+
| LOWER('aA') | LOWER(CONVERT('aA' USING latin1)) |
+-------------+-----------------------------------+
| aA          | aa                                |
+-------------+-----------------------------------+
</pre>

<p><b>Обработка конечного пробела в сравнениях.</b> Недвоичные строки имеют
логику <code>PADSPACE</code> для всех сопоставлений, включая
<code>_bin</code>. Конечные пробелы являются незначащими в сравнениях:
<pre>
mysql&gt; SET NAMES utf8 COLLATE utf8_bin;
mysql&gt; SELECT 'a ' = 'a';
+------------+
| 'a ' = 'a' |
+------------+
|  1         |
+------------+
</pre>

<p>Для двоичных строк все символы являются существенными в сравнениях,
включая конечные пробелы:
<pre>
mysql&gt; SET NAMES binary;
mysql&gt; SELECT 'a ' = 'a';
+------------+
| 'a ' = 'a' |
+------------+
|  0         |
+------------+
</pre>

<p><b>Обработка конечного пробела для вставок и извлечения.</b> Столбцы
<code>CHAR(<em><code>N</code></em>)</code> хранят недвоичные строки. Значения
короче <em><code>N</code></em> символов расширены пробелами при вставке. Для
извлечения удалены конечные пробелы.</p>

<p>Столбцы <code>BINARY(<em><code>N</code></em>)</code>
столбцы хранят двоичные строки. Значения короче
<em><code>N</code></em> байт расширены
байтами <code>0x00</code> при вставке. Для извлечения ничто не удалено,
значение заявленной длины всегда возвращается.
<pre>
mysql&gt; CREATE TABLE t1 (a CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin,
                 b BINARY(10));
mysql&gt; INSERT INTO t1 VALUES ('a','a');
mysql&gt; SELECT HEX(a), HEX(b) FROM t1;
+--------+----------------------+
| HEX(a) | HEX(b)               |
+--------+----------------------+
| 61     | 61000000000000000000 |
+--------+----------------------+
</pre>

<h4><a name="charset-collation-effect"></a>11.1.8.6.
Примеры эффекта сопоставления</h4>
<p><span><strong>Пример 1: Сортировка немецких умляутов</strong></span></p>
<p>Предположите, что столбец <code>X</code> в таблице <code>T</code> имеет
значения столбцов <code>latin1</code>:
<pre>
Muffler
Mц╪ller
MX Systems
MySQL
</pre>

<p>Предположите также, что значения столбцов получены,
используя следующий запрос:
<pre>
SELECT X FROM T ORDER BY X COLLATE <em><code>collation_name</code></em>;
</pre>

<p>Следующая таблица показывает получающийся порядок значений, если мы
используем <code>ORDER BY</code> с различными сопоставлениями.</p>
<table border="1">
<thead><tr><th scope="col"><code>latin1_swedish_ci</code></th>
<th scope="col"><code>latin1_german1_ci</code></th>
<th scope="col"><code>latin1_german2_ci</code></th></tr></thead>
<tbody><tr><td scope="row">Muffler</td><td>Muffler</td><td>Mц╪ller</td></tr>
<tr><td scope="row">MX Systems</td><td>Mц╪ller</td><td>Muffler</td></tr>
<tr><td scope="row">Mц╪ller</td><td>MX Systems</td><td>MX Systems</td></tr>
<tr><td scope="row">MySQL</td><td>MySQL</td><td>MySQL</td>
</tr></tbody></table>

<p>Символ, который вызывает различные порядки сортировки в этом примере,
является U с двумя точками, который немцы называют <span>U-umlaut</span>.</p>
<ul><li><p>Первый столбец показывает результат
<a href="sql.htm#select"><code>SELECT</code></a>
с использованием правила сопоставления Swedish/Finnish, которое говорит,
что U-umlaut сортируются как Y.</li>

<li>Второй столбец показывает результат
<a href="sql.htm#select"><code>SELECT</code></a>
с использованием правила сопоставления German DIN-1, которое говорит,
что U-umlaut сортируются как U.</li>

<li>Третий столбец показывает результат
<a href="sql.htm#select"><code>SELECT</code></a>
с использованием правила сопоставления German DIN-2, которое говорит,
что U-umlaut сортируются как UE.</li></p></li></ul>

<p><span><strong>Пример 2: Поиск немецких умляутов</strong></span></p>
<p>Предположите, что у Вас есть три таблицы, которые отличаются только
набором символов и используемым сопоставлением:
<pre>
mysql&gt; SET NAMES utf8;
mysql&gt; CREATE TABLE german1 (c CHAR(10)) CHARACTER SET latin1
                 COLLATE latin1_german1_ci;
mysql&gt; CREATE TABLE german2 (c CHAR(10)) CHARACTER SET latin1
                 COLLATE latin1_german2_ci;
mysql&gt; CREATE TABLE germanutf8 (c CHAR(10)) CHARACTER SET utf8
                 COLLATE utf8_unicode_ci;
</pre>

<p>Каждая таблица содержит две записи:
<pre>
mysql&gt; INSERT INTO german1 VALUES ('Bar'), ('Bц╓r');
mysql&gt; INSERT INTO german2 VALUES ('Bar'), ('Bц╓r');
mysql&gt; INSERT INTO germanutf8 VALUES ('Bar'), ('Bц╓r');
</pre>

<p>Два из вышеупомянутых сопоставлений имеют
равенство <code>A = ц└</code> и у одного нет равенства
(<code>latin1_german2_ci</code>). По этой причине, Вы получите
эти результаты в сравнениях:
<pre>
mysql&gt; SELECT * FROM german1 WHERE c = 'Bц╓r';
+------+
| c    |
+------+
| Bar  |
| Bц╓r |
+------+
mysql&gt; SELECT * FROM german2 WHERE c = 'Bц╓r';
+------+
| c    |
+------+
| Bц╓r |
+------+
mysql&gt; SELECT * FROM germanutf8 WHERE c = 'Bц╓r';
+------+
| c    |
+------+
| Bar  |
| Bц╓r |
+------+
</pre>

<p>Это не ошибка, а скорее последствие свойств сортировки
<code>latin1_german1_ci</code> и <code>utf8_unicode_ci</code>
(показанная сортировка сделана согласно немецкому стандарту DIN 5007).</p>

<h4><a name="charset-collation-information-schema"></a>11.1.8.7.
Используя сопоставления в поисках INFORMATION_SCHEMA</h4>
<p>Строковые столбцы в <code>INFORMATION_SCHEMA</code> у таблиц имеют
сопоставление <code>utf8_general_ci</code>, которое является нечувствительным
к регистру. Однако, для значений, которые соответствуют объектам, которые
представлены в файловой системе, таким как базы данных и таблицы,
строковые столбцы в <code>INFORMATION_SCHEMA</code>
могут быть чувствительными к регистру или нечувствительными, в зависимости от
характеристик основной файловой системы и значения переменной
<a href="server.htm#sysvar_lower_case_table_names"><code>
lower_case_table_names</code></a>. Например, поиски могут быть
чувствительными к регистру, если файловая система является чувствительной к
регистру. Этот раздел описывает это поведение и как изменить
это в случае необходимости.</p>

<p>Предположите, что запрос ищет столбец <code>SCHEMATA.SCHEMA_NAME</code>
для базы данных <code>test</code>. В Linux файловые системы являются
чувствительными к регистру, таким образом, сравнение
<code>SCHEMATA.SCHEMA_NAME</code> с <code>'test'</code>
соответствует, но сравнение с <code>'TEST'</code> уже нет:
<pre>
mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME = 'test';
+-------------+
| SCHEMA_NAME |
+-------------+
| test        |
+-------------+

mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME = 'TEST';
Empty set (0.00 sec)
</pre>

<p>Эти результаты происходят, если переменная
<a href="server.htm#sysvar_lower_case_table_names"><code>
lower_case_table_names</code></a> установлена в 0. Изменение значения
<a href="server.htm#sysvar_lower_case_table_names"><code>
lower_case_table_names</code></a> в 1 или 2
приводит к тому, что второй запрос возвратит тот же самый (непустой)
результат, как первый запрос.</p>

<p>В Windows или OS X, файловые системы не являются чувствительными к
регистру, таким образом, сравнения соответствуют обоим
вариантам, <code>'test'</code> и <code>'TEST'</code>:
<pre>
mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME = 'test';
+-------------+
| SCHEMA_NAME |
+-------------+
| test        |
+-------------+

mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME = 'TEST';
+-------------+
| SCHEMA_NAME |
+-------------+
| TEST        |
+-------------+
</pre>

<p>Значение <a href="server.htm#sysvar_lower_case_table_names"><code>
lower_case_table_names</code></a> не имеет никакого
значения в этом контексте.</p>

<p>Предыдущее поведение происходит, потому что сопоставление
<code>utf8_general_ci</code> не используется для запросов
<code>INFORMATION_SCHEMA</code>, ища значения, которые соответствуют
объектам, представленным в файловой системе.</p>

<p>Если результат строковой работы на столбце
<code>INFORMATION_SCHEMA</code> отличается от ожиданий, обходное решение
должно использовать явный <code>COLLATE</code>, чтобы вызвать подходящее
сопоставление (см. <a href="#charset-collate">раздел 11.1.8.1</a>).
Например, чтобы выполнить поиск без учета регистра, надо использовать
<code>COLLATE</code> и имя столбца в <code>INFORMATION_SCHEMA</code>:
<pre>
mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME COLLATE utf8_general_ci = 'test';
+-------------+
| SCHEMA_NAME |
+-------------+
| test        |
+-------------+

mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME COLLATE utf8_general_ci = 'TEST';
+-------------+
| SCHEMA_NAME |
+-------------+
| test        |
+-------------+
</pre>

<p>Вы можете также использовать функции
<a href="funct.htm#function_upper"><code>UPPER()</code></a> или
<a href="funct.htm#function_lower"><code>LOWER()</code></a>:
<pre>
WHERE UPPER(SCHEMA_NAME) = 'TEST'
WHERE LOWER(SCHEMA_NAME) = 'test'
</pre>

<p>Хотя нечувствительное к регистру сравнение может быть выполнено даже на
платформах с чувствительными к регистру файловыми системами, как только что
показано, это не обязательно всегда правильная вещь. На таких платформах
возможно иметь много объектов с именами, которые отличаются только по
регистру. Например, таблицы называют <code>city</code>, <code>CITY</code> и
<code>City</code>, они все могут существовать одновременно.
Рассмотрите, должен ли поиск соответствовать всем таким именам или только
одному, и напишите запросы соответственно. Первое из следующих сравнений (с
<code>utf8_bin</code>) является чувствительным к регистру, другие нет:
<pre>
WHERE TABLE_NAME COLLATE utf8_bin = 'City'
WHERE TABLE_NAME COLLATE utf8_general_ci = 'city'
WHERE UPPER(TABLE_NAME) = 'CITY'
WHERE LOWER(TABLE_NAME) = 'city'
</pre>

<p>Поиск в <code>INFORMATION_SCHEMA</code> строковых столбцов для значений,
которые обращаются к <code>INFORMATION_SCHEMA</code>
непосредственно использует сопоставление <code>utf8_general_ci</code>,
потому что <code>INFORMATION_SCHEMA</code> <span>виртуальная</span>
база данных, не представленная в файловой системе. Например, сравнения с
<code>SCHEMATA.SCHEMA_NAME</code> соответствуют
<code>'information_schema'</code> или <code>'INFORMATION_SCHEMA'</code>
независимо от платформы:
<pre>
mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME = 'information_schema';
+--------------------+
| SCHEMA_NAME        |
+--------------------+
| information_schema |
+--------------------+

mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA
                 WHERE SCHEMA_NAME = 'INFORMATION_SCHEMA';
+--------------------+
| SCHEMA_NAME        |
+--------------------+
| information_schema |
+--------------------+
</pre>

<h3><a name="charset-unicode"></a>11.1.9. Поддержка Unicode</h3>
<p>Начальное выполнение поддержки Unicode (в MySQL 4.1) включало два набора
символов для того, чтобы хранить данные Unicode:</p>

<ul><li><p><code>utf8</code>, UTF-8 кодирование набора символов Unicode,
используя один-три байта на символ.</li>
<li><code>ucs2</code>, кодирование UCS-2 набора символов Unicode,
используя 16 битов на символ.</p></li></ul>

<p>Эти два набора символов поддерживают символы из Basic
Multilingual Plane (BMP) Unicode Version 3.0.
BMP-символы имеют эти характеристики:</p>

<ul><li><p>Их кодовые обозначения между 0 и 65535 (или
<code>U+0000</code> .. <code>U+FFFF</code>).</li>
<li>Они могут быть закодированы 8, 16 или 24 битами, как в <code>utf8</code>.
</li>

<li>Они могут быть закодированы с фиксрованным 16-битовым
словом, как в <code>ucs2</code>.</li>
<li>Они достаточны для почти всех символов на главных языках.</p></li></ul>

<p>Символы, не поддержанные вышеупомянутыми наборами символов, включают
дополнительные символы, которые лежат вне BMP. Символы вне BMP сравниваются
как REPLACEMENT CHARACTER и преобразовываются в <code>'?'</code>, когда
конвертируются в набор символов Unicode.</p>

<p>Поддержка Unicode дополнительных символов требует наборов символов,
которые имеют более широкий диапазон (включая не-BMP символы) и поэтому
занимают больше места. Следующая таблица показывает краткое сравнение
особенностей оригинальной и расширенной поддержки Unicode.</p>

<table border="1">
<thead><tr><th scope="col">До MySQL 5.5</th><th scope="col">MySQL 5.5 и выше
</th></tr></thead>
<tbody><tr><td scope="row">Все символы Unicode 3.0</td>
<td>Все символы Unicode 5.0 и 6.0</td></tr>
<tr><td scope="row">Никаких дополнительных символов</td>
<td>С дополнительными символами</td></tr>
<tr><td scope="row">Набор символов <code>utf8</code> для трех
байтов, BMP только</td><td>Никаких изменений</td></tr>
<tr><td scope="row">Набор символов <code>ucs2</code>, BMP только</td>
<td>Никаких изменений</td></tr>
<tr><td scope="row"> </td><td>Набор символов <code>utf8mb4</code>
для четырех байтов, BMP или дополнительный</td></tr>
<tr><td scope="row"> </td><td>Набор символов <code>utf16</code>,
BMP или дополнительный</td></tr>
<tr><td scope="row"> </td><td>Набор символов <code>utf16le</code>,
BMP или дополнительный</td></tr>
<tr><td scope="row"> </td><td>Набор символов <code>utf32</code>,
BMP или дополнительный</td></tr></tbody></table>

<p>Если Вы хотите использовать наборы символов, которые <span>шире</span>,
чем оригинальные наборы символов <code>utf8</code> и <code>ucs2</code>,
есть потенциальные проблемы несовместимости для Ваших приложений, см.
<a href="#charset-unicode-conversion">раздел 11.1.9.8</a>.
Тот раздел также описывает, как преобразовать таблицы из <code>utf8</code> в
(4-байта) <code>utf8mb4</code> и какие ограничения могут применяться при этом.
</p>

<p>MySQL поддерживает эти наборы символов Unicode:</p>
<ul><li><p><code>utf8</code>, кодирование UTF-8 набора символов Unicode,
используя один-три байта на символ.</li>

<li><code>utf8mb4</code>, кодирование UTF-8 набора символов Unicode,
используя один-четыре байта на символ.</li>
<li><code>ucs2</code>, кодирование UCS-2 набора символов Unicode, используя
16 бит на символ.</li>

<li><code>utf16</code>, кодирование UTF-16 для набора символов Unicode,
аналог <code>ucs2</code>, но с расширением для дополнительных символов.</li>
<li><code>utf16le</code>, кодирование UTF-16LE для набора символов Unicode,
аналог <code>utf16</code>, но little-endian вместо big-endian.</li>
<li><code>utf32</code>, кодирование UTF-32 для набора символов Unicode,
используя 32 бита на символ.</p></li></ul>

<p><code>utf8</code> и <code>ucs2</code> поддерживают символы BMP.
<code>utf8mb4</code>, <code>utf16</code>, <code>utf16le</code> и
<code>utf32</code> поддерживают символы BMP и дополнительные символы.</p>

<p>Подобный набор сопоставлений доступен для большинства наборов символов
Unicode. Например, у каждого есть датское сопоставление, имена которого
<code>ucs2_danish_ci</code>, <code>utf16_danish_ci</code>,
<code>utf32_danish_ci</code>, <code>utf8_danish_ci</code> и
<code>utf8mb4_danish_ci</code>. Исключение <code>utf16le</code>,
у которого есть только два сопоставления. Для описания сопоставлений Unicode
и их свойств дифференциации, включая свойства сопоставления для
дополнительных символов см. <a href="#charset-unicode-sets">раздел
11.1.10.1</a>.</p>

<p>MySQL хранит символы UCS-2, UTF-16 и UTF-32 в порядке байтов
big-endian и не использует марку порядка байтов (BOM) в начале значений.
Другие системы базы данных могли бы использовать другой подход. В таких
случаях преобразование значений должно будет быть выполнено, передавая данные
между теми системами и MySQL. Выполнение UTF-16LE little-endian.</p>

<p>MySQL не использует BOM для значений UTF-8.</p>
<p>Приложения-клиенты, которые должны работать с сервером с использованием
Unicode, должны установить набор символов клиента соответственно,
например, через <code>SET NAMES 'utf8'</code>. <code>ucs2</code>,
<code>utf16</code>, <code>utf16le</code> и <code>utf32</code> не может
использоваться в качестве набора символов клиента, это означает, что они не
работают в <a href="sql.htm#set-names"><code>SET NAMES</code></a> или
<a href="sql.htm#set-character-set"><code>SET CHARACTER SET</code></a>.</p>
<p>Следующие разделы обеспечивают дополнительные детале о наборах
символов Unicode в MySQL.</p>

<h4><a name="charset-unicode-utf8"></a>11.1.9.1.
Набор символов utf8 (3 байта UTF-8 Unicode)</h4>
<p>UTF-8 (формат преобразования Unicode с 8-битовыми модулями,
Unicode Transformation Format with 8-bit) является альтернативным способом
хранить данные Unicode. Это осуществлено согласно RFC 3629, который описывает
последовательности кодирования, которые берут от одного до четырех байтов.
Более старый стандарт для кодирования UTF-8, RFC 2279, описывает
последовательности UTF-8, которые берут от одного до шести байтов. RFC 3629
представляет RFC 2279 устаревшим, по этой причине, последовательности с пятью
и шестью байтами больше не используются.</p>

<p>Идея UTF-8 состоит в том, что различные символы Unicode закодированы,
используя последовательности байтов различных длин:</p>
<ul><li><p>Основные латинские буквы, цифры и знаки пунктуации
используют один байт.</li>

<li>Большинство европейских и ближневосточных
вписываются в 2-байтовую последовательность: расширенные латинские
символы (с тильдой, знаком долготы гласного звука, острыми, серьезными и
другими акцентами), кириллица, греческий язык, армянский язык, иврит,
арабский язык, сирийский язык и другие.</li>

<li>Корейские, китайские и японские идеограммы используют 3-байтовые
или 4-байтовые последовательности.</p></li></ul>
<p>У набора символов <code>utf8</code> в MySQL есть эти характеристики:</p>
<ul><li><p>Никакой поддержки дополнительных символов (символы BMP только).
</li>
<li>Максимум три байта на символ.</p></li></ul>

<p>Точно тот же самый набор символов доступен в <code>utf8</code> и
<code>ucs2</code>. Таким образом, у них есть тот же самый репертуар.</p>
<p>Чтобы сэкономить место в UTF-8, надо использовать
<a href="types.htm#char"><code>VARCHAR</code></a> вместо
<a href="types.htm#char"><code>CHAR</code></a>. Иначе MySQL должен
зарезервировать три байта для каждого символа в столбце <code>CHAR
CHARACTER SET utf8</code> потому что это максимальная возможная символьная
длина. Например, MySQL должен зарезервировать 30 байт для стобца
<code>CHAR(10) CHARACTER SET utf8</code>.</p>

<h4><a name="charset-unicode-utf8mb3"></a>11.1.9.2.
Набор символов utf8mb3 (псевдоним для utf8)</h4>
<p>Набор символов <code>utf8</code> использует максимум три байта на символ.
Чтобы сделать этот символьный предел явным (как предел в четыре байта на
символ является явным в <code>utf8mb4</code>),
используйте имя набора символов <code>utf8mb3</code>, которое является
псевдонимом для <code>utf8</code>. <code>utf8mb3</code>
может использоваться в <code>CHARACTER SET</code> и
<code>utf8mb3_<em><code>collation_substring</code></em></code>
в <code>COLLATE</code>, где <em><code>collation_substring</code></em>
<code>bin</code>, <code>czech_ci</code>,
<code>danish_ci</code>, <code>esperanto_ci</code>,
<code>estonian_ci</code> и т.д. Пример:
<pre>
CREATE TABLE t (s1 CHAR(1) CHARACTER SET utf8mb3;
SELECT * FROM t WHERE s1 COLLATE utf8mb3_general_ci = 'x';
DECLARE x VARCHAR(5) CHARACTER SET utf8mb3 COLLATE utf8mb3_danish_ci;
SELECT CAST('a' AS CHAR CHARACTER SET utf8) COLLATE utf8_czech_ci;
</pre>

<p>MySQL немедленно преобразовывает
<code>utf8mb3</code> в псевдонимы <code>utf8</code>,
так в таких запросах, как <code>SHOW CREATE TABLE</code>,
<code>SELECT CHARACTER_SET_NAME FROM INFORMATION_SCHEMA.COLUMNS</code> или
<code>SELECT COLLATION_NAME FROM INFORMATION_SCHEMA.COLUMNS</code>,
пользователи будут видеть истинное имя <code>utf8</code> или
<code>utf8_<em><code>collation_substring</code></em></code>.</p>

<p>Псевдоним <code>utf8mb3</code> также допустим в определенных местах, кроме
<code>CHARACTER SET</code>. Например, это является законным:
<pre>
mysqld --character-set-server=utf8mb3
SET NAMES 'utf8mb3'; /* and other SET statements that have similar effect */
SELECT _utf8mb3 'a';
</pre>

<h4><a name="charset-unicode-utf8mb4"></a>11.1.9.3.
Набор символов utf8mb4 (4-байта UTF-8 Unicode)</h4>
<p>Набор символов <code>utf8</code> использует максимум три байта на символ и
содержит только символы BMP. Набор символов <code>utf8mb4</code> использует
максимум четыре байта на символ для поддержки дополнительных символов:</p>

<ul><li><p>Для символов BMP <code>utf8</code> и <code>utf8mb4</code>
имеют идентичные характеристики хранения: те же самые кодовые обозначения, то
же самое кодирование, та же самая длина.</li>

<li>Для дополнительных символов <code>utf8</code>
не может сохранить символ вообще, тогда как <code>utf8mb4</code>
требует, чтобы четыре байта сохранили это.
Поскольку <code>utf8</code> не может сохранить символ вообще, у Вас нет
никаких дополнительных символов в столбцах <code>utf8</code>.</p></li></ul>

<p><code>utf8mb4</code> супернабор <code>utf8</code>,
так что у результата опреаций с ним есть набор символов
<code>utf8mb4</code> и сопоставление <code>utf8mb4_col</code>:
<pre>
SELECT CONCAT(utf8_col, utf8mb4_col);
</pre>

<p>Точно так же следующее сравнение в <code>WHERE</code> работает согласно
сопоставлению <code>utf8mb4_col</code>:
<pre>
SELECT * FROM utf8_tbl, utf8mb4_tbl
         WHERE utf8_tbl.utf8_col = utf8mb4_tbl.utf8mb4_col;
</pre>

<p><span><strong>Совет</strong></span>: для экономии места с
<code>utf8mb4</code>, применяйте <a href="types.htm#char"><code>VARCHAR
</code></a> вместо <a href="types.htm#char"><code>CHAR</code></a>.
Иначе MySQL должен зарезервировать четыре байта для каждого символа в столбце
<code>CHAR CHARACTER SET utf8mb4</code> потому что это максимальная возможная
длина. Например, MySQL должен зарезервировать 40 байт для
<code>CHAR(10) CHARACTER SET utf8mb4</code>.</p>

<h4><a name="charset-unicode-ucs2"></a>11.1.9.4.
Набор символов UCS-2 Unicode</h4>
<p>В UCS-2 каждый символ представлен 2-байтовым кодом Unicode со старшим
значащим байтом сначала. Например:
<code>LATIN CAPITAL LETTER A</code> имеет код <code>0x0041</code>
и это сохранено как 2-байтовая последовательность:
<code>0x00 0x41</code>. <code>CYRILLIC SMALL LETTER YERU</code> (Unicode
<code>0x044B</code>) сохранен как 2-байтовая последовательность:
<code>0x04 0x4B</code>. Для символов Unicode и их кодов, пожалуйста,
обратитесь к <a href="../../../www.unicode.org/default.htm" target="_top">
Unicode Home Page</a>.</p>
<p>В MySQL набор символов <code>ucs2</code> 16-битовое кодирование
фиксированной длины для символов Unicode BMP.</p>

<h4><a name="charset-unicode-utf16"></a>11.1.9.5.
Набор символов UTF-16 Unicode</h4>
<p>Набор символов <code>utf16</code> это <code>ucs2</code>
с расширением, которое позволяет кодировать дополнительные символы:</p>

<ul><li><p>Для символа BMP <code>utf16</code> и <code>ucs2</code>
имеют идентичные характеристики хранения: те же самые кодовые обозначения, то
же самое кодирование, та же самая длина.</li>

<li>Для дополнительных символов <code>utf16</code>
имеет специальную последовательность для того, чтобы представить символ,
используя 32 бита. Это называют механизм <span>surrogate</span>:
для числа больше <code>0xffff</code> возьмите 10 бит, добавьте их к
<code>0xd800</code>, поместите это
в первое 16-битовое слово, возьмите еще 10 бит, добавьте их к
<code>0xdc00</code> и поместите это в следующее 16-битовое слово.
Следовательно, все дополнительные символы требуют 32 бит, где первые 16 бит
задают число между <code>0xd800</code> и <code>0xdbff</code>, а
а последние 16 бит число между
<code>0xdc00</code> и <code>0xdfff</code>.</p></li></ul>

<p>Поскольку <code>utf16</code> поддерживает surrogates, а <code>ucs2</code>
нет, есть проверка достоверности, которая применяется только в
<code>utf16</code>: Вы не можете ввести верхний surrogate
без нижнего. Пример:
<pre>
INSERT INTO t (ucs2_column) VALUES (0xd800); /* legal */
INSERT INTO t (utf16_column)VALUES (0xd800); /* illegal */
</pre>

<p>Нет никакой проверки достоверности для символов, которые технически
допустимы, но не являются истинным Unicode (то есть, символы, которые
Unicode рассматривает как символы <span>без назначенной точки кода</span>,
<span>частные символы</span> или <span>неправильные</span>, подобно
<code>0xffff</code>). Например, с тех пор как
<code>U+F8FF</code> стал логотипом Apple, это легально:
<pre>
INSERT INTO t (utf16_column)VALUES (0xf8ff); /* legal */
</pre>

<p>Такие символы не будут значить ту же самую вещь для всех.</p>
<p>Поскольку MySQL должен учесть худший случай (что один символ требует
четырех байтов), максимальная длина столбца или индекса <code>utf16</code>
только половина максимальной длины для <code>ucs2</code>.
Например, максимальная длина ключа индекса таблицы <code>MEMORY</code>
3072 байт, таким образом, эти запросы составляют таблицы с разрешенным самым
длинным индексом для столбцов <code>ucs2</code> и <code>utf16</code>:
<pre>
CREATE TABLE tf (s1 VARCHAR(1536) CHARACTER SET ucs2) ENGINE=MEMORY;
CREATE INDEX i ON tf (s1);
CREATE TABLE tg (s1 VARCHAR(768) CHARACTER SET utf16) ENGINE=MEMORY;
CREATE INDEX i ON tg (s1);
</pre>

<h4><a name="charset-unicode-utf16le"></a>11.1.9.6.
Набор символов UTF-16LE Unicode</h4>
<p>Это то же самое, как <code>utf16</code>, но
little-endian вместо big-endian.</p>

<h4><a name="charset-unicode-utf32"></a>11.1.9.7.
Набор символов UTF-32 Unicode</h4>
<p>Набор символов <code>utf32</code> имеет фиксированную длину, как
<code>ucs2</code>. <code>utf32</code> использует 32 бита
для каждого символа, в отличие от <code>ucs2</code>
(который использует 16 битов для каждого символа), и в отличие от
<code>utf16</code> (который использует 16 битов для некоторых символов и 32
бита для других).</p>

<p><code>utf32</code> занимает вдвое больше места, чем
<code>ucs2</code> и больше пространства, чем <code>utf16</code>, но
<code>utf32</code> имеет то же самое преимущество, как <code>ucs2</code>:
это предсказуемо для хранения, необходимое число байтов для
<code>utf32</code> равно числу символов, умноженному на 4. Кроме того, в
отличие от <code>utf16</code>, нет никаких уловок для того, чтобы
кодировать в <code>utf32</code>, таким образом, хранимое значение
равняется кодовому значению.</p>

<p>Чтобы продемонстрировать, как последнее преимущество полезно, вот пример,
который показывает, как определить значение <code>utf8mb4</code>, данное
как кодовое обозначение <code>utf32</code>:
<pre>
/* Assume code value = 100cc LINEAR B WHEELED CHARIOT */
CREATE TABLE tmp (utf32_col CHAR(1) CHARACTER SET utf32,
       utf8mb4_col CHAR(1) CHARACTER SET utf8mb4);
INSERT INTO tmp VALUES (0x000100cc,NULL);
UPDATE tmp SET utf8mb4_col = utf32_col;
SELECT HEX(utf32_col),HEX(utf8mb4_col) FROM tmp;
</pre>

<p>MySQL мало проверяет относительно добавлений неназначенных символов
Unicode или символов области личного пользования. Есть фактически только одна
проверка достоверности для <code>utf32</code>: никакое кодовое обозначение не
может быть больше <code>0x10ffff</code>. Например, это незаконно:
<pre>
INSERT INTO t (utf32_column) VALUES (0x110000); /* illegal */
</pre>

<h4><a name="charset-unicode-conversion"></a>11.1.9.8.
Преобразование между 3 и 4 байтными наборами символов Unicode</h4>
<p>Этот раздел описывает проблемы, с которыми Вы можете столкнуться,
преобразовывая из набора символов <code>utf8</code> в <code>utf8mb4</code>.
</p>

<p>Обсуждение здесь сосредотачивается прежде всего на преобразовании между
<code>utf8</code> и <code>utf8mb4</code>, но подобные принципы относятся к
преобразованию между <code>ucs2</code> и такими наборами символов, как
<code>utf16</code> или <code>utf32</code>.</p>

<p>Наборы символов <code>utf8</code> и <code>utf8mb4</code>
отличаются следующим образом:</p>
<ul><li><p><code>utf8</code> поддерживает только символы в
Basic Multilingual Plane (BMP). <code>utf8mb4</code>
поддерживает дополнительные символы, которые лежат вне BMP.</li>

<li><code>utf8</code> использует максимум три байта на символ.
<code>utf8mb4</code> использует максимум четыре байта на символ.
</p></li></ul>

<p>Одно преимущество преобразования из <code>ut8</code> в
<code>utf8mb4</code>: это позволяет приложениям использовать дополнительные
символы. Проблема состоит в том, что это может увеличить требования места
для хранения данных.</p>

<p>В большинстве отношений, преобразование <code>utf8</code> в
<code>utf8mb4</code> должно представить немного проблем.
Это основные потенциальные области несовместимости:</p>

<ul><li><p>Для типов данных с символами переменной длины
(<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>)
максимальная разрешенная длина в символах меньше для столбцов
<code>utf8mb4</code>, чем для <code>utf8</code>.</li>

<li>Для всех символьных типов данных
(<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>)
максимальное количество символов, которые могут быть индексированы, меньше
для столбцов <code>utf8mb4</code>, чем для <code>utf8</code>.</p></li></ul>

<p>Следовательно, чтобы преобразовать таблицы из <code>utf8</code>
в <code>utf8mb4</code>, может быть необходимо изменить
некоторый столбец или определения индекса.</p>

<p>Таблицы могут быть преобразованы из <code>utf8</code> в
<code>utf8mb4</code> с помощью <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>. Предположите, что таблица была первоначально
определена следующим образом:
<pre>
CREATE TABLE t1 (col1 CHAR(10) CHARACTER SET utf8 COLLATE utf8_unicode_ci
       NOT NULL, col2 CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin NOT NULL)
       CHARACTER SET utf8;
</pre>

<p>Следующие запросы конвертируют <code>t1</code>
для использования <code>utf8mb4</code>:
<pre>
ALTER TABLE t1 DEFAULT CHARACTER SET utf8mb4, MODIFY col1 CHAR(10)
      CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
      MODIFY col2 CHAR(10) CHARACTER SET utf8mb4
      COLLATE utf8mb4_bin NOT NULL;
</pre>

<p>С точки зрения табличного контента, преобразование
<code>utf8</code> в <code>utf8mb4</code> никакие проблемы не создает:</p>
<ul><li><p>Для символов BMP <code>utf8</code> и <code>utf8mb4</code>
имеют идентичные характеристики хранения: те же самые кодовые обозначения, то
же самое кодирование, та же самая длина.</li>

<li>Для дополнительного символа <code>utf8</code>
не может сохранить символ вообще, тогда как <code>utf8mb4</code> требует
четырех байтов. Поскольку <code>utf8</code> не может сохранить символ вообще,
столбцы <code>utf8</code> не имеют никаких дополнительных символов,
и Вы не должны волноваться о преобразовании символов или потере данных,
преобразуя их в <code>utf8mb4</code>.</p></li></ul>

<p>С точки зрения структуры таблицы, выгоды, преобразования из
<code>utf8</code> в <code>utf8mb4</code>
это максимальная длина столбца или ключ индекса, неизменный с точки зрения
<span><em>байт</em></span>. Поэтому это меньше с точки зрения
<span><em>символов</em></span>, потому что максимальная длина символа
составляет четыре байта вместо трех. Для типов данных
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>
следите за этими проблемами, преобразовывая Ваши таблицы MySQL:</p>

<ul><li><p>Проверьте все определения столбцов <code>utf8</code>
и удостоверьтесь, что они не будут превышать максимальную длину
для механизма хранения.</li>

<li>Проверьте все индексы на столбцах <code>utf8</code>
и удостоверьтесь, что они не будут превышать максимальную длину
для механизма хранения. Иногда максимум может измениться из-за
улучшений механизма хранения. Не факт, что именно улучшений...</p></li></ul>

<p>Если предыдущие условия применяются, Вы должны или уменьшить определенную
длину столбцов (или индексов), или продолжить использовать
<code>utf8</code> вместо <code>utf8mb4</code>.</p>

<p>Вот некоторые примеры, где структурные изменения могут быть необходимы:
</p>
<ul><li><p>столбец <a href="types.htm#blob"><code>TINYTEXT</code></a>
может держать до 255 байтов, таким образом, он может держать до 85 3 байтных
или 63 4-байтных символов. Предположите, что у Вас есть столбец
<a href="types.htm#blob"><code>TINYTEXT</code></a>, который использует
<code>utf8</code>, но должен быть в состоянии содержать больше, чем 63
символа. Вы не можете преобразовать это в <code>utf8mb4</code>,
если Вы также не изменяете тип данных на более длинный тип такой, как
<a href="types.htm#blob"><code>TEXT</code></a>.</p>

<p>Точно так же очень длинный столбец
<a href="types.htm#char"><code>VARCHAR</code></a>
столбец, возможно, должен быть изменен на один из типов
<a href="types.htm#blob"><code>TEXT</code></a>, если Вы хотите преобразовать
это из <code>utf8</code> в <code>utf8mb4</code>.</li>

<li><code>InnoDB</code> имеет максимум длины индекса в 767 байтов для таблиц,
которые используют формат строк
<code><a href="glossary.htm#glos_compact_row_format">COMPACT</a></code>
или <code><a href="glossary.htm#glos_redundant_row_format">REDUNDANT</a>
</code>, так что для столбцов <code>utf8</code> или <code>utf8mb4</code>
Вы можете индексировать максимум 255 или 191 символа, соответственно. Если Вы
в настоящее время имеете столбцы <code>utf8</code> с индексами больше 190
символов, Вы должны индексировать меньшее число символов.</p>

<p>В таблице <code>InnoDB</code>, которая использует формат строк
<code><a href="glossary.htm#glos_compact_row_format">COMPACT</a></code> или
<code><a href="glossary.htm#glos_redundant_row_format">REDUNDANT</a></code>,
эти определения столбца и индекса являются законными:
<pre>
col1 VARCHAR(500) CHARACTER SET utf8, INDEX (col1(255))
</pre>

<p>Чтобы использовать <code>utf8mb4</code> вместо этого, индексирование
должно быть меньшим:
<pre>
col1 VARCHAR(500) CHARACTER SET utf8mb4, INDEX (col1(191))
</pre>

<p>Для таблиц <code>InnoDB</code>, которые используют формат строк
<code><a href="glossary.htm#glos_compressed_row_format">COMPRESSED</a>
</code> или <code><a href="glossary.htm#glos_dynamic_row_format">DYNAMIC</a>
</code>, разрешены <a href="glossary.htm#glos_index_prefix">префиксы
индексного ключа</a> длинней 767 байт (до 3072 байт).
Таблицы, составленные с этими форматами строки, позволяют Вам индексировать
максимум 1024 или 768 символов для столбцов
for <code>utf8</code> или <code>utf8mb4</code>, соответственно.
Для соответствующей информации см. разделы
<a href="innodb.htm#innodb-restrictions">16.8.7</a> и
<a href="innodb.htm#innodb-row-format-dynamic">16.10.3</a>.</p></li></ul>

<p>Предыдущие типы изменений, наиболее вероятно, будут требоваться, только
если у Вас есть очень длинные столбцы или индексы. Иначе, Вы должны быть в
состоянии преобразовать свои таблицы из <code>utf8</code> в
<code>utf8mb4</code> без проблем, используя <a href="sql.htm#alter-table">
<code>ALTER TABLE</code></a> как описано ранее.</p>

<p>Следующие элементы суммируют другие потенциальные области несовместимости:
</p>
<ul><li><p>Исполнение 4-байтового UTF-8 (<code>utf8mb4</code>)
медленнее, чем для 3-байтового UTF-8 (<code>utf8</code>).
Чтобы избежать это проблемы, продолжите использовать <code>utf8</code>.</li>

<li><code>SET NAMES 'utf8mb4'</code> предписывает использовать
4-байтового набора символов для соединения. Пока 4-байтные символы
посылаются с сервера, не должно быть никаких проблем. У приложений, которые
ожидают получить максимум три байта на символ, могут быть проблемы. Наоборот,
приложения, которые будут посылать 4-байтовые символы, должны гарантировать,
что сервер понимает их. Более широко, приложения не могут послать данные
<code>utf8mb4</code>, <code>utf16</code>,
<code>utf16le</code> или <code>utf32</code>
более старому серверу, который не понимает это:</p>

<ul><li><p><code>utf8mb4</code>, <code>utf16</code>
и <code>utf32</code> не распознаются до MySQL 5.5.3.</li>
<li><code>utf16le</code> не распознается до MySQL 5.6.1.</p></li></ul></li>

<li><p>Для репликации, если наборы символов, которые поддерживают
дополнительные символы, должны использоваться на ведущем устройстве, все
ведомые устройства также должны их понять. Если Вы пытаетесь копировать с
более нового ведущего устройства к более старому ведомому устройству,
данные <code>utf8</code> будут замечены ведомым устройством как
<code>utf8</code> и должны копироваться правильно. Но Вы не можете послать
<code>utf8mb4</code>, <code>utf16</code>, <code>utf16le</code> или
<code>utf32</code> более старому ведомому устройству, которое
не понимает это:</p>

<ul><li><p><code>utf8mb4</code>, <code>utf16</code>
и <code>utf32</code> не распознаются до MySQL 5.5.3.</li>
<li><code>utf16le</code> не распознается до MySQL 5.6.1.</p></li></ul></li>

<p>Кроме того, имейте в виду общий принцип, что если у таблицы есть различные
определения на ведущем и ведомом устройствах, это может привести к
неожиданным результатам. Например, различия в максимуме длины ключа индекса
делают опасным использование <code>utf8</code> на ведущем и
<code>utf8mb4</code> на ведомом устройстве.</p></li></ul>

<p>Если Вы преобразовали в <code>utf8mb4</code>,
<code>utf16</code>, <code>utf16le</code> или <code>utf32</code>,
а затем решите преобразовать назад в
<code>utf8</code> или <code>ucs2</code>,
эти соображения применяются:</p>

<ul><li><p>Данные <code>utf8</code> и <code>ucs2</code>
не должны представить проблемы.</li>
<li>Сервер должен быть достаточно свежим, чтобы признать определения,
относящиеся к набору символов, из которого Вы преобразуете.</li>

<li>Для определений объекта, которые относятся к набору символов
<code>utf8mb4</code>, Вы можете вывести их с помощью
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>,
отредактировать файл дампа, чтобы изменить
<code>utf8mb4</code> на <code>utf8</code>, и
перезагрузите файл в более старый сервер, пока нет 4-байтных символов
в данных. Более старый сервер будет видеть <code>utf8</code>
в дампе файла определений и создаст новые объекты, которые используют
набор символов <code>utf8</code> (3 байта).</p></li></ul>

<h3><a name="charset-charsets"></a>11.1.10.
Поддерживаемые наборы символов и сопоставления</h3>
<p>Этот раздел указывает, какие наборы символов MySQL поддерживает.
Есть один подраздел для каждой группы связанных наборов символов.
Для каждого набора символов перечислены допустимые сопоставления.</p>

<p>Чтобы перечислить доступные наборы символов и их сопоставления по
умолчанию, используйте команду <a href="sql.htm#show-character-set"><code>
SHOW CHARACTER SET</code></a> или запрос к таблице <code>INFORMATION_SCHEMA
</code> <a href="inform.htm#character-sets-table"><code>CHARACTER_SETS</code>
</a>. Пример:
<pre>
mysql&gt; SHOW CHARACTER SET;
+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci | 1      |
| ascii    | US ASCII                        | ascii_general_ci    | 1      |
| big5     | Big5 Traditional Chinese        | big5_chinese_ci     | 2      |
| binary   | Binary pseudo charset           | binary              | 1      |
| cp1250   | Windows Central European        | cp1250_general_ci   | 1      |
| cp1251   | Windows Cyrillic                | cp1251_general_ci   | 1      |
| cp1256   | Windows Arabic                  | cp1256_general_ci   | 1      |
| cp1257   | Windows Baltic                  | cp1257_general_ci   | 1      |
| cp850    | DOS West European               | cp850_general_ci    | 1      |
| cp852    | DOS Central European            | cp852_general_ci    | 1      |
| cp866    | DOS Russian                     | cp866_general_ci    | 1      |
| cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   | 2      |
| dec8     | DEC West European               | dec8_swedish_ci     | 1      |
| eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci | 3      |
| euckr    | EUC-KR Korean                   | euckr_korean_ci     | 2      |
| gb18030  | China National Standard GB18030 | gb18030_chinese_ci  | 4      |
| gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   | 2      |
| gbk      | GBK Simplified Chinese          | gbk_chinese_ci      | 2      |
| geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  | 1      |
| greek    | ISO 8859-7 Greek                | greek_general_ci    | 1      |
| hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   | 1      |
| hp8      | HP West European                | hp8_english_ci      | 1      |
| keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  | 1      |
| koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    | 1      |
| koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    | 1      |
| latin1   | cp1252 West European            | latin1_swedish_ci   | 1      |
| latin2   | ISO 8859-2 Central European     | latin2_general_ci   | 1      |
| latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   | 1      |
| latin7   | ISO 8859-13 Baltic              | latin7_general_ci   | 1      |
| macce    | Mac Central European            | macce_general_ci    | 1      |
| macroman | Mac West European               | macroman_general_ci | 1      |
| sjis     | Shift-JIS Japanese              | sjis_japanese_ci    | 2      |
| swe7     | 7bit Swedish                    | swe7_swedish_ci     | 1      |
| tis620   | TIS620 Thai                     | tis620_thai_ci      | 1      |
| ucs2     | UCS-2 Unicode                   | ucs2_general_ci     | 2      |
| ujis     | EUC-JP Japanese                 | ujis_japanese_ci    | 3      |
| utf16    | UTF-16 Unicode                  | utf16_general_ci    | 4      |
| utf16le  | UTF-16LE Unicode                | utf16le_general_ci  | 4      |
| utf32    | UTF-32 Unicode                  | utf32_general_ci    | 4      |
| utf8     | UTF-8 Unicode                   | utf8_general_ci     | 3      |
| utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  | 4      |
+----------+---------------------------------+---------------------+--------+
</pre>

<p>В случаях, где у набора символов есть много сопоставлений, не ясно, какое
сопоставление является самым подходящим для данного приложения. Чтобы
избежать выбора неправильного сопоставления, может быть полезно выполнить
некоторые сравнения с представительными значениями данных, чтобы
удостовериться, что данное сопоставление подходит.</p>

<h4><a name="charset-unicode-sets"></a>11.1.10.1.
Наборы символов Unicode</h4>
<p>MySQL поддерживает много наборов символов Unicode:</p>
<ul><li><p><code>utf8</code>, кодирование UTF-8 набора символов Unicode,
используя один-три байта на символ.</li>

<li><code>utf8mb4</code>, кодирование UTF-8 набора символов Unicode,
используя один-четыре байта на символ.</li>
<li><code>ucs2</code>, кодирование UCS-2 набора символов Unicode, используя
16 бит на символ.</li>

<li><code>utf16</code>, кодирование UTF-16 для набора символов Unicode,
аналог <code>ucs2</code>, но с расширением для дополнительных символов.</li>
<li><code>utf16le</code>, кодирование UTF-16LE для набора символов Unicode,
аналог <code>utf16</code>, но little-endian вместо big-endian.</li>
<li><code>utf32</code>, кодирование UTF-32 для набора символов Unicode,
используя 32 бита на символ.</p></li></ul>

<p><code>utf8</code> и <code>ucs2</code> поддерживают символы
Basic Multilingual Plane (BMP). <code>utf8mb4</code>, <code>utf16</code>,
<code>utf16le</code> и <code>utf32</code> поддерживают
BMP и дополнительные символы.</p>

<p>Этот раздел описывает сопоставления, доступные для наборов символов
Unicode и их свойства дифференциации. Для общей информации о Unicode см.
<a href="#charset-unicode">раздел 11.1.9</a>.</p>

<p>У большинства наборов символов Unicode есть общее сопоставление
(обозначено <code>_general</code> в имени или отсутствием языкового
спецификатора), двоичное сопоставление (обозначенное <code>_bin</code> в
имени) и несколько определенных для языка сопоставлений (обозначены языковыми
спецификаторами). Например, для <code>utf8</code>,
<code>utf8_general_ci</code> и <code>utf8_bin</code>
его общие и двоичные сопоставления, а <code>utf8_danish_ci</code>
одно из его определенных для языка сопоставлений.</p>

<p>Поддержка сопоставления <code>utf16le</code> ограничена.
Единственные доступные сопоставления <code>utf16le_general_ci</code> и
<code>utf16le_bin</code>. Они подобны
<code>utf16_general_ci</code> и <code>utf16_bin</code>.</p>

<p>Код места действия или языковое имя, показанное в следующей таблице,
указывают на определенное для языка сопоставление. Наборы символов Unicode
могут включать сопоставления для одного или большего числа этих языков.</p>

<a name="charset-unicode-collation-language-specifiers"></a><p><b>Таблица
11.2. Языковые спецификаторы сопоставления Unicode</b></p>
<table id="charset-unicode-collation-language-specifiers">
<thead><tr><td align="center">Язык</td>
<td align="center">Языковой спецификатор</td></tr></thead>
<tbody><tr><td>Общий Latin</td>
<td><code>la</code> или <code>roman</code></td></tr>
<tr><td>Croatian</td><td><code>hr</code> или <code>croatian</code></td></tr>
<tr><td>Czech</td><td><code>cs</code> или <code>czech</code></td></tr>
<tr><td>Danish</td><td><code>da</code> или <code>danish</code></td></tr>
<tr><td>Esperanto</td>
<td><code>eo</code> или <code>esperanto</code></td></tr>
<tr><td>Estonian</td><td><code>et</code> или <code>estonian</code></td></tr>
<tr><td>German (порядок телефонной книги)</td>
<td><code>de_pb</code> или <code>german2</code></td></tr>
<tr><td>Hungarian</td>
<td><code>hu</code> или <code>hungarian</code></td></tr>
<tr><td>Icelandic</td>
<td><code>is</code> или <code>icelandic</code></td></tr>
<tr><td>Latvian</td><td><code>lv</code> или <code>latvian</code></td></tr>
<tr><td>Lithuanian</td>
<td><code>lt</code> or <code>lithuanian</code></td></tr>
<tr><td>Persian</td><td><code>persian</code></td></tr>
<tr><td>Polish</td><td><code>pl</code> или <code>polish</code></td></tr>
<tr><td>Romanian</td><td><code>ro</code> или <code>romanian</code></td></tr>
<tr><td>Sinhala</td><td><code>sinhala</code></td></tr>
<tr><td>Slovak</td><td><code>sk</code> или <code>slovak</code></td></tr>
<tr><td>Slovenian</td>
<td><code>sl</code> или <code>slovenian</code></td></tr>
<tr><td>Современный Spanish</td>
<td><code>es</code> или <code>spanish</code></td></tr>
<tr><td>Традиционный Spanish</td>
<td><code>es_trad</code> или <code>spanish2</code></td></tr>
<tr><td>Swedish</td><td><code>sv</code> или <code>swedish</code></td></tr>
<tr><td>Turkish</td><td><code>tr</code> или <code>turkish</code></td></tr>
<tr><td>Vietnamese</td>
<td><code>vi</code> или <code>vietnamese</code></td></tr></tbody></table>

<p>Хорватские (Croatian) сопоставления сделаны для этих хорватских символов:
<code>д▄</code>, <code>д├</code>, <code>Dе╬</code>, <code>д░</code>,
<code>Lj</code>, <code>Nj</code>, <code>е═</code>, <code>е╫</code>.</p>

<p>Датские (Danish) сопоставления могут также использоваться
для норвежского языка.</p>
<p>Для Classical Latin сопоставлений, которые не чувствительны к
диакритическим знакам, <code>I</code> и <code>J</code>, а также
<code>U</code> и <code>V</code> сравниваются как равные на основном уровне
написания. Другими словами, <code>J</code> расценен как акцентированный
<code>I</code>, и <code>U</code> расценен как акцентированный <code>V</code>.
</p>

<p>Spanish сопоставления доступны для современного и традиционного испанского
языка. Для обоих <code>ц╠</code> (n-tilde) отдельный символ между
<code>n</code> и <code>o</code>. Кроме того, для традиционного испанского
языка <code>ch</code> отдельный символ между
<code>c</code> и <code>d</code>, а <code>ll</code> отдельный символ между
<code>l</code> и <code>m</code>.</p>

<p>Традиционные испанские сопоставления могут также использоваться
для Asturian и Galician.</p>
<p>Swedish сопоставления включают шведские правила. Например, на шведском
языке применяются следующие отношения, которые не является ожидаемыми на
немецком или французском:
<pre>
ц° = Y &lt; ц√
</pre>

<p>Для вопросов об особых языковых упорядочиваниях см.
<a href="unicode.org" target="_top">unicode.org</a> и Common Locale Data
Repository (CLDR) collation charts на
<a href="../../../www.unicode.org/cldr/charts/29/collation/index.html"
target="_top">http://www.unicode.org/cldr/charts/29/collation/index.html</a>.
</p>

<p>Сопоставления <code><em><code>xxx</code></em>_general_mysql500_ci</code>
используют порядок pre-5.1.24 оригинального сопоставления
<code><em><code>xxx</code></em>_general_ci</code> и позволяют
обновления для таблиц, составленных до MySQL 5.1.24.</p>

<p>MySQL осуществляет сопоставления <code><em><code>
xxx</code></em>_unicode_ci</code> согласно алгоритму сопоставления Unicode
(UCA), описанному в
<a href="../../../www.unicode.org/reports/tr10/default.htm" target="_top">
http://www.unicode.org/reports/tr10/</a>. Сопоставление использует
version-4.0.0 UCA weight keys:
<a href="../../../www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt"
target="_top">http://www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt</a>.
У сопоставлений <code><em><code>xxx</code></em>_unicode_ci</code>
есть только частичная поддержка алгоритма сопоставления Unicode. Некоторые
символы не поддержаны, и combining marks не полностью поддержаны. Это
затрагивает прежде всего вьетнамский, Yoruba и некоторые меньшие языки, такие
как язык навахо. Объединенный символ считают отличающимся от того же самого
символа, написанного с единственным unicode символом в строковых сравнениях,
и у этих двух символов, как полагают, есть различная длина (например, как
возвращено фукцией <a href="funct.htm#function_char-length"><code>
CHAR_LENGTH()</code></a> или в метаданных о наборе результатов).</p>

<p>Сопоставления Unicode, основанные на версиях UCA позже 4.0.0
включают версию в имя сопоставления. Таким образом,
<code>utf8mb4_unicode_520_ci</code> основано на UCA 5.2.0 weight keys
(<a href="../../../www.unicode.org/Public/UCA/5.2.0/allkeys.txt" target="_top">
http://www.unicode.org/Public/UCA/5.2.0/allkeys.txt</a>), тогда как
<code>utf8mb4_0900_ai_ci</code> основано на UCA 9.0.0 weight keys
(<a href="../../../www.unicode.org/Public/UCA/9.0.0/allkeys.txt" target="_top">
http://www.unicode.org/Public/UCA/9.0.0/allkeys.txt</a>). Для сопоставлений
<code>utf8</code> это включает версию UCA, см.
<a href="#charset-unicode-utf8mb3">раздел 11.1.9.2</a>.</p>

<p>MySQL осуществляет определенные для языка сопоставления Unicode, если
упорядочивание, основанное только на UCA, не работает хорошо на языке.
Определенные для языка сопоставления UCA с
дополнительными языковыми правилами.</p>

<p>Например, определенное для неязыковой специфики
<code>utf8mb4_0900_ai_ci</code> и для языковой специфики
<code>utf8mb4_<em><code>LOCALE</code></em>_0900_ai_ci</code>
сопоставления Unicode имеют эти характеристики:</p>

<ul><li><p>Сопоставление, основанное на алгоритме
сопоставления Unicode (UCA) (UCA) 9.0.0 и Common Locale Data Repository
(CLDR) v30, является не чувствительным к диакритическим знакам и к регистру.
Эти характеристики обозначены <code>_0900</code>,
<code>_ai</code>, and <code>_ci</code> в имени сопоставления. Исключение:
<code>utf8mb4_la_0900_ai_ci</code> не основано на
CLDR, так как Classical Latin не определена в CLDR.</li>

<li>Сопоставление работает на всех символах в диапазоне [U+0, U+10FFFF].</li>
<li>Если сопоставление не специфично для языка, это сортирует все символы,
включая дополнительные символы, в порядке значения по умолчанию (описан
позже). Если сопоставление специфично для языка, это сортирует символы языка
правильно, согласно определенным для языка правилам, а символы не на этом
языке в порядке по умолчанию.</li>

<li>По умолчанию, символы сопоставления, перечисляющие кодовую точку в
таблице DUCET (Default Unicode Collation Element Table) сортируются
согласно значению веса, назначенному в таблице. Символы не перечисляющие
кодовую точку в таблице DUCET сортируются, используя их неявное значение
веса, которое создано согласно UCA.</li>
<li>Символы в последовательностях сокращения обработаны
как отдельные символы.</p></li></ul>

<p><a href="funct.htm#function_lower"><code>LOWER()</code></a> и
<a href="funct.htm#function_upper"><code>UPPER()</code></a>
выполняются согласно сопоставлению их параметра. Символ, у которого есть
верхний регистр и строчные версии только в версии Unicode более свежей, чем
4.0.0, преобразован этими функциями, только если у параметра есть
сопоставление, которое использует достаточно недавнюю версию UCA.</p>

<p>Для любого набора символов Unicode операции выполненные с использованием
сопоставления <code><em><code>xxx</code></em>_general_ci</code> быстрее, чем
с использованием сопоставления <code><em><code>xxx</code></em>_unicode_ci
</code>. Например, сравнения для сопоставления <code>utf8_general_ci</code>
быстрее, но немного менее правильны, чем сравнения для
<code>utf8_unicode_ci</code>. Причина этого: <code>utf8_unicode_ci</code>
поддерживает расширения, то есть, когда один символ сравнивается как равный
комбинациям других символов. Например, на немецком языке и некоторых других
языках <code>ц÷</code> равен <code>ss</code>. <code>utf8_unicode_ci</code>
также поддерживает сокращения и игнорируемые символы.
<code>utf8_general_ci</code> старое сопоставление, которое не поддерживает
расширения, сокращения, или игнорируемые символы. Это может сделать только
непосредственные сравнения между символами.</p>

<p>Для наглядности следующие равенства держатся в обоих сопоставлениях
<code>utf8_general_ci</code> и <code>utf8_unicode_ci</code>
(для эффекта этого в сравнениях или поисках см.
<a href="#charset-collation-effect">раздел 11.1.8.6</a>):
<pre>
ц└ = A
ц√ = O
ц° = U
</pre>

<p>Различие между сопоставлениями в том, что это верно для
<code>utf8_general_ci</code>:
<pre>
ц÷ = s
</pre>

<p>Принимая во внимание, что это истина для <code>utf8_unicode_ci</code>,
который поддерживает упорядочивание German DIN-1
(также известно как лексикографический порядок):
<pre>
ц÷ = ss
</pre>

<p>MySQL реализует определенные для языка сопоставления <code>utf8</code>,
если упорядочивание с <code>utf8_unicode_ci</code>
не работает хорошо с языком. Например, <code>utf8_unicode_ci</code> хорошо
работает для немецкого лексикографического порядка и французского языка,
таким образом нет никакой потребности создавать особое сопоставление.</p>

<p><code>utf8_general_ci</code> также является удовлетворительным
для немецкого и для французского языка, за исключением того, что
<code>ц÷</code> равно <code>s</code>, а не <code>ss</code>.
Если это является приемлемым для Вашего приложения, Вы должны использовать
<code>utf8_general_ci</code>, потому что это быстрее. Если это не является
приемлемым (например, если Вы требуете немецкого лексикографического
порядка), следует использовать <code>utf8_unicode_ci</code>,
потому что это более точно.</p>

<p>Если Вы требуете, чтобы сортировки по German DIN-2 (phone book),
используйте сопоставление <code>utf8_german2_ci</code>,
которое сравнивает следующие наборы равных символов:
<pre>
ц└ = ц├ = AE
ц√ = е▓ = OE
ц° = UE
ц÷ = ss
</pre>

<p><code>utf8_german2_ci</code> подобно <code>latin1_german2_ci</code>,
но последнее не сравнивает <code>ц├</code> как <code>AE</code> или
<code>е▓</code> как <code>OE</code>. Нет сопоставления
<code>utf8_german_ci</code> и <code>latin1_german_ci</code> для немецкого
лексикографического порядка, потому что достаточно
<code>utf8_general_ci</code>.</p>

<p>Для всех сопоставлений Unicode кроме <code>_bin</code> MySQL
выполняет поиск по таблице, чтобы найти вес сопоставления символа. Этот вес
может быть выведен на экран, используя функцию
<a href="funct.htm#function_weight-string"><code>WEIGHT_STRING()</code></a>.
См. <a href="funct.htm#string-functions">раздел 13.5</a>.
Если символ не находится в таблице (например, потому что это
<span>новый</span> символ, определение веса становится более сложным:</p>

<ul><li><p>Для символов BMP в общих сопоставлениях
(<code><em><code>xxx</code></em>_general_ci</code>) вес=кодовая точка.</li>
<li>Для символов BMP в сопоставлениях UCA (например,
<code><em><code>xxx</code></em>_unicode_ci</code> и специфичные для языка
сопоставления) применяется следующий алгоритм:
<pre>
if (code &gt;= 0x3400 &amp;&amp; code &lt;= 0x4DB5)
   base= 0xFB80; /* CJK Ideograph Extension */
else if (code &gt;= 0x4E00 &amp;&amp; code &lt;= 0x9FA5)
        base= 0xFB40; /* CJK Ideograph */
     else base= 0xFBC0; /* All other characters */
aaaa= base +  (code &gt;&gt; 15);
bbbb= (code &amp; 0x7FFF) | 0x8000;
</pre>

<p>Результат последовательность двух элементов сопоставления
<code>aaaa</code> сопровождаемого <code>bbbb</code>. Пример:
<pre>
mysql&gt; SELECT HEX(WEIGHT_STRING(_ucs2 0x04CF COLLATE ucs2_unicode_ci));
+----------------------------------------------------------+
| HEX(WEIGHT_STRING(_ucs2 0x04CF COLLATE ucs2_unicode_ci)) |
+----------------------------------------------------------+
| FBC084CF                                                 |
+----------------------------------------------------------+
</pre>

<p>Таким образом, <code>U+04cf CYRILLIC SMALL LETTER PALOCHKA</code> со всеми
сопоставлениями UCA 4.0.0 больше <code>U+04c0 CYRILLIC LETTER PALOCHKA
</code>. С сопоставлениями UCA 5.2.0 все палочки сортируются вместе.</li>

<li>Для дополнительных символов в общих сопоставлениях весом будет вес для
<code>0xfffd REPLACEMENT CHARACTER</code>. Для дополнительных символов в
сопоставлениях UCA 4.0.0 их вес <code>0xfffd</code>. Таким образом, в MySQL
все дополнительные символы равны друг другу и больше, чем почти
все символы BMP.</p>

<p>Пример с символами Deseret и <code>COUNT(DISTINCT)</code>:
<pre>
CREATE TABLE t (s1 VARCHAR(5) CHARACTER SET utf32 COLLATE utf32_unicode_ci);
INSERT INTO t VALUES (0xfffd);   /* REPLACEMENT CHARACTER */
INSERT INTO t VALUES (0x010412); /* DESERET CAPITAL LETTER BEE */
INSERT INTO t VALUES (0x010413); /* DESERET CAPITAL LETTER TEE */
SELECT COUNT(DISTINCT s1) FROM t;
</pre>

<p>Результат 2 потому что в сопоставлении MySQL
<code><em><code>xxx</code></em>_unicode_ci</code>
у символа замены есть вес <code>0x0dc6</code>, тогда как у Deseret Tee
вес <code>0xfffd</code>. Если вместо этого использовать сопоставление
<code>utf32_general_ci</code>, результат 1, потому что у всех трех символов
есть вес <code>0xfffd</code> в этом сопоставлении.</p>

<p>Пример с клинообразными символами и
<a href="funct.htm#function_weight-string"><code>WEIGHT_STRING()</code></a>:
<pre>
/*
The four characters in the INSERT string are
00000041  # LATIN CAPITAL LETTER A
0001218F  # CUNEIFORM SIGN KAB
000121A7  # CUNEIFORM SIGN KISH
00000042  # LATIN CAPITAL LETTER B
*/
CREATE TABLE t (s1 CHAR(4) CHARACTER SET utf32 COLLATE utf32_unicode_ci);
INSERT INTO t VALUES (0x000000410001218f000121a700000042);
SELECT HEX(WEIGHT_STRING(s1)) FROM t;
</pre>

<p>Результат:
<pre>
0E33 FFFD FFFD 0E4A
</pre>

<p><code>0E33</code> и <code>0E4A</code> основные веса как в
<a href="../../../ftp@www.unicode.org/Public/UCA/4.0.0/allkeys-4.0.0.txt"
target="_top">UCA 4.0.0</a>. <code>FFFD</code> вес для KAB и KISH.</p>

<p>Правило, что все дополнительные символы равны друг другу, неоптимально,
но, как ожидают, не доставит неприятности. Эти символы очень редки, таким
образом, очень редко строка символов состояла полностью из дополнительных
символов. Если Вы действительно хотите строки, сортированные правилом MySQL и
во вторую очередь значением кодовой точки, это легко:
<pre>
ORDER BY s1 COLLATE utf32_unicode_ci, s1 COLLATE utf32_bin
</pre></li>

<li>Для дополнительных символов, основанных на версиях UCA выше
4.0.0 (например, <code><em><code>xxx</code></em>_unicode_520_ci</code>),
у дополнительных символов не обязательно есть тот же самый вес
сопоставления. У некоторых есть явные веса из файла UCA
<code>allkeys.txt</code>. Другим вычислили веса от этого алгоритма:
<pre>
aaaa= base +  (code &gt;&gt; 15);
bbbb= (code &amp; 0x7FFF) | 0x8000;
</pre></li></ul>

<p>Есть различие между <span>упорядочивание кодом символа</span> и
<span>упорядочивание двоичным представлением символа</span>.
Различие, которое появляется только с <code>utf16_bin</code>.</p>

<p>Предположите, что <code>utf16_bin</code> (двоичное сопоставление для
<code>utf16</code>) использует двоичное сравнение <span>побайтно</span>
вместо <span>посимвольного</span>. Если бы это было так, порядок символов в
<code>utf16_bin</code> отличался бы от порядка в <code>utf8_bin</code>.
Например, следующая диаграмма показывает два редких символа. Первый символ
находится в диапазоне <code>E000</code>-<code>FFFF</code>, таким образом, это
больше, чем заместитель, но меньше, чем дополнительный.
Второй символ дополнительный.
<pre>
Code point  Character                 utf8         utf16
----------  ---------                 ----         -----
0FF9D       HALFWIDTH KATAKANA LETTER N            EF BE 9D FF 9D
10384       UGARITIC LETTER DELTA     F0 90 8E 84  D8 00 DF 84
</pre>

<p>Эти два символа в диаграмме в порядке значения кодовой точки потому, что
<code>0xff9d</code> &lt; <code>0x10384</code>. И они в порядке значений
<code>utf8</code>, потому что <code>0xef</code> &lt; <code>0xf0</code>.
Но они не в порядке значений <code>utf16</code>, если мы используем сравнение
побайтно, потому что <code>0xff</code> &gt; <code>0xd8</code>.</p>

<p>Так сопоставление MySQL <code>utf16_bin</code> не побайтно.
Оно сравнивает по кодовым точкам. Когда MySQL видит, что
дополнительные символы кодируются в <code>utf16</code>,
это преобразовывается в значение кодовой точки символа, а затем сравнивается.
Поэтому <code>utf8_bin</code> и <code>utf16_bin</code>
то же самое упорядочивание. Это совместимо со стандартным требованием
SQL:2008 для сопоставления UCS_BASIC: <span>UCS_BASIC это сопоставление, в
котором упорядочивание определено полностью значениями скаляра
Unicode-символов в сортируемых строках. Это применимо к символьному
репертуару UCS. Так как каждый символьный репертуар подмножество репертуара
UCS, сопоставление UCS_BASIC потенциально применимо к каждому набору
символов. Скалярное значение Unicode символа это кодовая точка, обработанная
как unsigned integer</span>.</p>
<p>Если набор символов <code>ucs2</code>, сравнение побайтно, но строки
<code>ucs2</code> не должны содержать заместителей.</p>

<h4><a name="charset-we-sets"></a>11.1.10.2. Наборы символов West European
</h4>
<p>Наборы символов Western European
покрывают большинство западноевропейских языков, таких как
French, Spanish, Catalan, Basque,
Portuguese, Italian, Albanian, Dutch, German, Danish, Swedish,
Norwegian, Finnish, Faroese, Icelandic, Irish, Scottish и English.</p>

<ul><li><p><code>ascii</code> (US ASCII) сопоставления:</p>
<ul><li><p><code>ascii_bin</code></li>
<li><code>ascii_general_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>cp850</code> (DOS West European) сопоставления:</p>
<ul><li><p><code>cp850_bin</code></li>
<li><code>cp850_general_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>dec8</code> (DEC Western European) сопоставления:</p>
<ul><li><p><code>dec8_bin</code></li>
<li><code>dec8_swedish_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>hp8</code> (HP Western European) сопоставления:</p>
<ul><li><p><code>hp8_bin</code></li>
<li><code>hp8_english_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>latin1</code> (cp1252 West European) сопоставления:</p>
<ul><li><p><code>latin1_bin</code></li>
<li><code>latin1_danish_ci</code></li>
<li><code>latin1_general_ci</code></li>
<li><code>latin1_general_cs</code></li>
<li><code>latin1_german1_ci</code></li>
<li><code>latin1_german2_ci</code></li>
<li><code>latin1_spanish_ci</code></li>
<li><code>latin1_swedish_ci</code> (значение по умолчанию)</p></li></ul>

<p><code>latin1</code> набор символов значения по умолчанию. MySQL
<code>latin1</code> то же самое, что и Windows <code>cp1252</code>.
Это означает, что этот набор то же самое, что и официальный
<code>ISO 8859-1</code> или IANA (Internet Assigned Numbers
Authority) <code>latin1</code>, за исключением того, что IANA
<code>latin1</code> обрабатывает кодовые точки между
<code>0x80</code> и <code>0x9f</code> как <span>undefined</span>,
тогда как <code>cp1252</code> и MySQL <code>latin1</code>
назначают символы для тех позиций. Например, <code>0x80</code> символ Euro.
Для записей <span>undefined</span> в <code>cp1252</code> MySQL
преобразовывает <code>0x81</code> в Unicode <code>0x0081</code>,
<code>0x8d</code> в <code>0x008d</code>,
<code>0x8f</code> в <code>0x008f</code>,
<code>0x90</code> в <code>0x0090</code> и
<code>0x9d</code> в <code>0x009d</code>.</p>

<p>Сопоставление <code>latin1_swedish_ci</code> значение по умолчанию,
которое, вероятно, используется большинством клиентов MySQL. Хотя часто
говорится, что это основано на Swedish/Finnish правилах сопоставления,
есть шведы и финны, которые не соглашаются с этим заявлением.</p>

<p>Сопоставления <code>latin1_german1_ci</code> и
<code>latin1_german2_ci</code> основаны на стандартах DIN-1 и DIN-2, где
DIN это <span><em>Deutsches Institut fц╪r Normung</em></span>
(немецкая версия ANSI). DIN-1 называют <span>сопоставлением словаря</span>, а
DIN-2 <span>сопоставлением телефонной книги</span>.
Для примера эффекта, который это имеет в сравнениях или поисках см.
<a href="#charset-collation-effect">раздел 11.1.8.6</a>.</p>

<ul><li><p>Правила <code>latin1_german1_ci</code> (словарное):
<pre>
ц└ = A
ц√ = O
ц° = U
ц÷ = s
</pre></li>

<li>Правила <code>latin1_german2_ci</code> (телефонной книги):
<pre>
ц└ = AE
ц√ = OE
ц° = UE
ц÷ = ss
</pre></li></ul>

<p>В <code>latin1_spanish_ci</code> collation,
<code>ц╠</code> (n-tilde) отдельный символ между
<code>n</code> и <code>o</code>.</li>

<li>Сопоставление <code>macroman</code> (Mac West European):</p>
<ul><li><p><code>macroman_bin</code></li>
<li><code>macroman_general_ci</code> (значение по умолчанию)</li></ul></li>

<li><p><code>swe7</code> (7bit Swedish) сопоставление:</p>
<ul><li><p><code>swe7_bin</code></li>
<li><code>swe7_swedish_ci</code> (значение по умолчанию)</li></ul></li></ul>

<h4><a name="charset-ce-sets"></a>11.1.10.3. Наборы символов Central European
</h4>
<p>MySQL оказывает некоторую поддержку для наборов символов, используемых в
Czech Republic, Slovakia, Hungary, Romania, Slovenia, Croatia,
Poland и Serbia (Latin).</p>

<ul><li><p><code>cp1250</code> (Windows Central European) сопоставление:</p>
<ul><li><p><code>cp1250_bin</code></li>
<li><code>cp1250_croatian_ci</code></li>
<li><code>cp1250_czech_cs</code></li>
<li><code>cp1250_general_ci</code> (значение по умолчанию)</li>
<li><code>cp1250_polish_ci</code></p></li></ul></li>

<li><p><code>cp852</code> (DOS Central European) сопоставление:</p>
<ul><li><p><code>cp852_bin</code></li>
<li><code>cp852_general_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>keybcs2</code> (DOS Kamenicky Czech-Slovak) сопоставление:</p>
<ul><li><p><code>keybcs2_bin</code></li>
<li><code>keybcs2_general_ci</code> (значение по умолчанию)</li></ul></li>

<li><p><code>latin2</code> (ISO 8859-2 Central European) сопоставление:</p>
<ul><li><p><code>latin2_bin</code></li>
<li><code>latin2_croatian_ci</code></li>
<li><code>latin2_czech_cs</code></li>
<li><code>latin2_general_ci</code> (значение по умолчанию)</li>
<li><code>latin2_hungarian_ci</code></p></li></ul></li>

<li><p><code>macce</code> (Mac Central European) сопоставление:</p>
<ul><li><p><code>macce_bin</code></li>
<li><code>macce_general_ci</code> (значение по умолчанию)</li></ul></li></ul>

<h4><a name="charset-se-me-sets"></a>11.1.10.4. Наборы символов
South European и Middle East</h4>
<p>Южноевропейские и ближневосточные наборы символов, поддержанные MySQL,
включают Armenian, Arabic, Georgian, Greek, Hebrew и Turkish.</p>

<ul><li><p><code>armscii8</code> (ARMSCII-8 Armenian) сопоставление:</p>
<ul><li><p><code>armscii8_bin</code></li>
<li><code>armscii8_general_ci</code> (значение по умолчанию)</li></ul></li>

<li><p><code>cp1256</code> (Windows Arabic) сопоставление:</p>
<ul><li><p><code>cp1256_bin</code></li>
<li><code>cp1256_general_ci</code> (значение по умолчанию)</li></ul></li>

<li><p><code>geostd8</code> (GEOSTD8 Georgian) сопоставление:</p>
<ul><li><p><code>geostd8_bin</code></li>
<li><code>geostd8_general_ci</code> (значение по умолчанию)</li></ul></li>

<li><p><code>greek</code> (ISO 8859-7 Greek) сопоставление:</p>
<ul><li><p><code>greek_bin</code></li>
<li><code>greek_general_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>hebrew</code> (ISO 8859-8 Hebrew) сопоставление:</p>
<ul><li><p><code>hebrew_bin</code></li>
<li><code>hebrew_general_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>latin5</code> (ISO 8859-9 Turkish) сопоставление:</p>
<ul><li><p><code>latin5_bin</code></li>
<li><code>latin5_turkish_ci</code> (значение по умолчанию)
</li></ul></li></ul>

<h4><a name="charset-baltic-sets"></a>11.1.10.5. Балтийские наборы символов
</h4>
<p>Балтийские наборы символов покрывают Estonian, Latvian и Lithuanian.</p>
<ul><li><p><code>cp1257</code> (Windows Baltic) сопоставление:</p>
<ul><li><p><code>cp1257_bin</code></li>
<li><code>cp1257_general_ci</code> (значение по умолчанию)</li>
<li><code>cp1257_lithuanian_ci</code></p></li></ul></li>

<li><p><code>latin7</code> (ISO 8859-13 Baltic) сопоставление:</p>
<ul><li><p><code>latin7_bin</code></li>
<li><code>latin7_estonian_cs</code></li>
<li><code>latin7_general_ci</code> (значение по умолчанию)</li>
<li><code>latin7_general_cs</code></p></li></ul></li></ul>

<h4><a name="charset-cyrillic-sets"></a>11.1.10.6.
Кириллические наборы символов</h4>
<p>Кириллические наборы символов и сопоставления предназначены для
использования с Belarusian, Bulgarian, Russian,
Ukrainian и Serbian (Cyrillic).</p>

<ul><li><p><code>cp1251</code> (Windows Cyrillic) сопоставление:</p>
<ul><li><p><code>cp1251_bin</code></li>
<li><code>cp1251_bulgarian_ci</code></li>
<li><code>cp1251_general_ci</code> (значение по умолчанию)</li>
<li><code>cp1251_general_cs</code></li>
<li><code>cp1251_ukrainian_ci</code></p></li></ul></li>

<li><p><code>cp866</code> (DOS Russian) сопоставление:</p>
<ul><li><p><code>cp866_bin</code></li>
<li><code>cp866_general_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>koi8r</code> (KOI8-R Relcom Russian) сопоставление:</p>
<ul><li><p><code>koi8r_bin</code></li>
<li><code>koi8r_general_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>koi8u</code> (KOI8-U Ukrainian) сопоставление:</p>
<ul><li><p><code>koi8u_bin</code></li>
<li><code>koi8u_general_ci</code> (значение по умолчанию)</li></ul></li></ul>

<h4><a name="charset-asian-sets"></a>11.1.10.7.
Азиатские наборы символов</h4>
<p>Азиатские наборы символов, которые мы поддерживаем, включают Chinese,
Japanese, Korean и Thai. Они могут быть сложными. Например, китайские наборы
должны учесть тысячи различных символов. См.
<a href="#charset-cp932">раздел 11.1.10.7.1</a>
для дополнительной информации о наборах символов <code>cp932</code> и
<code>sjis</code>. См. <a href="#charset-gb18030">раздел
11.1.10.7.2</a> для дополнительной информации о поддержке набора символов
Chinese National Standard GB 18030.</p>

<p>Для ответов на некоторые общие вопросы и проблемы, связывающие поддержку
азиатских наборов символов в MySQL см.
<a href="faqs.html#faqs-cjk">раздел A.11</a>.</p>

<ul><li><p><code>big5</code> (Big5 Traditional Chinese) сопоставление:</p>
<ul><li><p><code>big5_bin</code></li>
<li><code>big5_chinese_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><a href="#charset-cp932"><code>cp932</code></a>
(SJIS for Windows Japanese) сопоставление:</p>
<ul><li><p><code>cp932_bin</code></li>
<li><code>cp932_japanese_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>eucjpms</code> (UJIS for Windows Japanese) сопоставление:</p>
<ul><li><p><code>eucjpms_bin</code></li>
<li><code>eucjpms_japanese_ci</code> (значение по умолчанию)</li></ul></li>

<li><p><code>euckr</code> (EUC-KR Korean) сопоставление:</p>
<ul><li><p><code>euckr_bin</code></li>
<li><code>euckr_korean_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>gb2312</code> (GB2312 Simplified Chinese) сопоставление:</p>
<ul><li><p><code>gb2312_bin</code></li>
<li><code>gb2312_chinese_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>gbk</code> (GBK Simplified Chinese) сопоставление:</p>
<ul><li><p><code>gbk_bin</code></li>
<li><code>gbk_chinese_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><a href="#charset-gb18030"><code>gb18030</code></a>
(China National Standard GB18030) сопоставление:</p>
<ul><li><p><code>gb18030_bin</code></li>
<li><code>gb18030_chinese_ci</code> (значение по умолчанию)</li>
<li><code>gb18030_unicode_520_ci</code></p></li></ul></li>

<li><p><code>sjis</code> (Shift-JIS Japanese) сопоставление:</p>
<ul><li><p><code>sjis_bin</code></li>
<li><code>sjis_japanese_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>tis620</code> (TIS620 Thai) сопоставление:</p>
<ul><li><p><code>tis620_bin</code></li>
<li><code>tis620_thai_ci</code> (значение по умолчанию)</p></li></ul></li>

<li><p><code>ujis</code> (EUC-JP Japanese) сопоставление:</p>
<ul><li><p><code>ujis_bin</code></li>
<li><code>ujis_japanese_ci</code> (значение по умолчанию)</li></ul></li></ul>
<p>Сопоставление <code>big5_chinese_ci</code> сортирует по числу штрихов.</p>

<h5><a name="charset-cp932"></a>11.1.10.7.1. Набор символов cp932</h5>
<p><span><strong>Почему <code>cp932</code> необходим?</strong></span></p>
<p>В MySQL набор символов <code>sjis</code> соответствует набору символов
<code>Shift_JIS</code>, определенному IANA, который поддерживает символы
JIS X0201 и JIS X0208. См.
<a href="../../../www.iana.org/assignments/character-sets" target="_top">
http://www.iana.org/assignments/character-sets</a>.</p>

<p>Однако, значение <span>SHIFT JIS</span> как описательного термина стало
очень неопределенным, и это часто включает расширения <code>Shift_JIS</code>,
которые определены различными поставщиками.</p>

<p>Например, <span>SHIFT JIS</span> используемый в японской среде
Windows является расширением Microsoft <code>Shift_JIS</code>
и его точное имя <code>Microsoft Windows Codepage: 932</code> или
<code>cp932</code>. В дополнение к символам, поддержанным
<code>Shift_JIS</code>, <code>cp932</code> имеет символы расширения
такие как спецсимволы NEC, NEC selected-IBM extended и IBM selected.</p>

<p>Много японских пользователей испытали проблемы, используя эти символы
расширения. Эти проблемы происходят от следующих факторов:</p>
<ul><li><p>MySQL автоматически преобразовывает наборы символов.</li>
<li>Наборы символов преобразованы, используя Unicode (<code>ucs2</code>).
</li>
<li>Набор символов <code>sjis</code> не поддерживает преобразование
этих символов расширения.</li>

<li>Есть несколько конверсионных правил от так называемого
<span>SHIFT JIS</span> в Unicode и некоторые символы преобразованы в Unicode
по-другому в зависимости от конверсионного правила. MySQL поддерживает только
одно из этих правил.</p></li></ul>

<p>Набор символов MySQL <code>cp932</code>
разработан, чтобы решить эти проблемы.</p>
<p>Поскольку MySQL поддерживает преобразование набора символов, важно
разделить IANA <code>Shift_JIS</code> и <code>cp932</code> на два различных
набора символов, потому что они обеспечивают различные конверсионные правила.
</p>

<p><span><strong>В чем разница между <code>cp932</code> и
<code>sjis</code>?</strong></span></p>
<p>Набор символов <code>cp932</code> отличается
от <code>sjis</code> следующим:</p>

<ul><li><p><code>cp932</code> поддерживает спецсимволы NEC, NEC selected-IBM
extended и символы IBM selected.</li>
<li>Некоторые символы <code>cp932</code> имеют
две различных кодовых точки, обе из которых преобразовывают в ту же самую
кодовую точку Unicode. Преобразовывая из Unicode назад в <code>cp932</code>,
одна из кодовых точек должна быть выбрана. Для этого используется правило
преобразования туда и обратно, рекомендуемое Microsoft. См.
<a href="../../../support.microsoft.com/kb/170559/EN-US/default.htm" target="_top">
http://support.microsoft.com/kb/170559/EN-US/</a>.</p>

<p>Конверсионное правило работает как это:</p>
<ul><li><p>Если символ находится JIS X 0208 и спецсимволах NEC, используйте
кодовую точку JIS X 0208.</li>

<li>Если символ находится в спецсимволах NEC и символах IBM selected,
используйте кодовую точку NEC.</li>
<li>Если символ находится в символах IBM selected и NEC selected-IBM
extended, используйте кодовую точку IBM extended.</p></li></ul>

<p>Таблица, показанная на
<a href="../../../https@msdn.microsoft.com/en-us/goglobal/cc305152.aspx"
target="_top">https://msdn.microsoft.com/en-us/goglobal/cc305152.aspx</a>
предоставляет информацию о значениях Unicode символов <code>cp932</code>. Для
записью таблицы с символами <code>cp932</code>, под которыми четырехзначное
число появляется, представляют соответствующий Unicode (<code>ucs2</code>)
код. Поскольку записи таблицы с подчеркнутым значением с двумя цифрами
появляются, есть диапазон символьных значений <code>cp932</code>, которые
начинаются с тех двух цифр. Щелчок по такой записи таблицы отправит Вас к
странице, которая выводит на экран значение Unicode для каждого из
символов <code>cp932</code>, которые начинаются с тех цифр.</p>

<p>Ссылки особенно интересны. Они соответствуют кодировкам для
следующих наборов символов:</p>
<ul><li><p>NEC спецсимволы (лидирующий байт <code>0x87</code>):
<pre>
<a href="../../../https@msdn.microsoft.com/en-us/goglobal/gg674964" target="_top">
https://msdn.microsoft.com/en-us/goglobal/gg674964</a>
</pre></li>

<li>Символы NEC selected-IBM extended (лидирующие байты
<code>0xED</code> и <code>0xEE</code>):
<pre>
<a href="../../../https@msdn.microsoft.com/en-us/goglobal/gg671837" target="_top">
https://msdn.microsoft.com/en-us/goglobal/gg671837</a>
<a href="../../../https@msdn.microsoft.com/en-us/goglobal/gg671838" target="_top">
https://msdn.microsoft.com/en-us/goglobal/gg671838</a>
</pre></li>

<li>Символы IBM selected (лидирующие байты
<code>0xFA</code>, <code>0xFB</code> и <code>0xFC</code>):
<pre>
<a href="../../../https@msdn.microsoft.com/en-us/goglobal/gg671839" target="_top">
https://msdn.microsoft.com/en-us/goglobal/gg671839</a>
<a href="../../../https@msdn.microsoft.com/en-us/goglobal/gg671840" target="_top">
https://msdn.microsoft.com/en-us/goglobal/gg671840</a>
<a href="../../../https@msdn.microsoft.com/en-us/goglobal/gg671841" target="_top">
https://msdn.microsoft.com/en-us/goglobal/gg671841</a>
</pre></li></ul></li>

<li><p><code>cp932</code> понимает преобразование
определяемых пользователем символов в комбинации с <code>eucjpms</code>
и решает проблемы с преобразованием <code>sjis</code>/<code>ujis</code>.
Для деталей, пожалуйста, обратитесь к
<a href="../../../www.sljfaq.org/afaq/encodings.html" target="_top">
http://www.sljfaq.org/afaq/encodings.html</a>.</p></li></ul>

<p>Для некоторых символов, преобразования в и из
<code>ucs2</code> отличается для <code>sjis</code> и <code>cp932</code>.
Следующие таблицы иллюстрируют эти различия.</p>

<p>Преобразование в <code>ucs2</code>:</p>
<table border="1">
<thead><tr><th scope="col">Значение <code>sjis</code>/<code>cp932</code></th>
<th scope="col">Преобразование <code>sjis</code> -&gt; <code>ucs2</code></th>
<th scope="col">Преобразование <code>cp932</code> -&gt; <code>ucs2</code>
</th></tr></thead>
<tbody><tr><td scope="row">5C</td><td>005C</td><td>005C</td></tr>
<tr><td scope="row">7E</td><td>007E</td><td>007E</td></tr>
<tr><td scope="row">815C</td><td>2015</td><td>2015</td></tr>
<tr><td scope="row">815F</td><td>005C</td><td>FF3C</td></tr>
<tr><td scope="row">8160</td><td>301C</td><td>FF5E</td></tr>
<tr><td scope="row">8161</td><td>2016</td><td>2225</td></tr>
<tr><td scope="row">817C</td><td>2212</td><td>FF0D</td></tr>
<tr><td scope="row">8191</td><td>00A2</td><td>FFE0</td></tr>
<tr><td scope="row">8192</td><td>00A3</td><td>FFE1</td></tr>
<tr><td scope="row">81CA</td><td>00AC</td><td>FFE2</td></tr></tbody></table>

<p>Преобразование из <code>ucs2</code>:</p>
<table border="1">
<thead><tr><th scope="col">Значение <code>ucs2</code></th><th scope="col">
Преобразование<code>ucs2</code> -&gt; <code>sjis</code></th>
<th scope="col">Преобразование<code>ucs2</code> -&gt; <code>cp932</code>
</th></tr></thead>
<tbody><tr><td scope="row">005C</td><td>815F</td><td>5C</td></tr>
<tr><td scope="row">007E</td><td>7E</td><td>7E</td></tr>
<tr><td scope="row">00A2</td><td>8191</td><td>3F</td></tr>
<tr><td scope="row">00A3</td><td>8192</td><td>3F</td></tr>
<tr><td scope="row">00AC</td><td>81CA</td><td>3F</td></tr>
<tr><td scope="row">2015</td><td>815C</td><td>815C</td></tr>
<tr><td scope="row">2016</td><td>8161</td><td>3F</td></tr>
<tr><td scope="row">2212</td><td>817C</td><td>3F</td></tr>
<tr><td scope="row">2225</td><td>3F</td><td>8161</td></tr>
<tr><td scope="row">301C</td><td>8160</td><td>3F</td></tr>
<tr><td scope="row">FF0D</td><td>3F</td><td>817C</td></tr>
<tr><td scope="row">FF3C</td><td>3F</td><td>815F</td></tr>
<tr><td scope="row">FF5E</td><td>3F</td><td>8160</td></tr>
<tr><td scope="row">FFE0</td><td>3F</td><td>8191</td></tr>
<tr><td scope="row">FFE1</td><td>3F</td><td>8192</td></tr>
<tr><td scope="row">FFE2</td><td>3F</td><td>81CA</td></tr></tbody></table>

<p>Пользователи любых японских наборов символов должны знать
что использование
<a href="server.htm#option_mysqld_character-set-client-handshake">
<code>--character-set-client-handshake</code></a> (или
<a href="server.htm#option_mysqld_character-set-client-handshake"><code>
--skip-character-set-client-handshake</code></a>) имеет важный эффект. См.
<a href="server.htm#server-options">раздел 6.1.4</a>.</p>

<h5><a name="charset-gb18030"></a>11.1.10.7.2. Набор символов gb18030</h5>
<p>В MySQL набор символов <code>gb18030</code> соответствует
<span>Chinese National Standard GB 18030-2005: Information technology
Chinese coded character set</span>, который является официальным набором
символов Китайской Народной Республики.</p>

<h6>Характеристики набора символов MySQL gb18030</h6>
<ul><li><p>Поддерживает все кодовые точки, определенные GB 18030-2005.
Неназначенные кодовые точки в диапазонах
(GB+8431A439, GB+90308130) и (GB+E3329A36, GB+EF39EF39)
обработаны как '<code>?</code>' (0x3F).
Преобразование неназначенных кодовых точек возвращает '<code>?</code>'.</li>

<li>Поддерживает преобразование UPPER и LOWER для всех кодовых точек GB18030.
Конвертация регистров, определенная Unicode, также поддержана (основана на
<code>CaseFolding-6.3.0.txt</code>).</li>

<li>Преобразование данных в и из других наборов символов.</li>
<li>Поддерживает запросы SQL вроде <a href="sql.htm#set-names"><code>SET
NAMES</code></a>.</li>

<li>Поддерживает сравнение строк <code>gb18030</code>
и строки других наборов символов. Есть преобразование, если у строк есть
различные наборы символов. Сравнения, которые включают или игнорируют
конечные пробелы, также поддержаны.</li>

<li>Область частного пользования (U+E000, U+F8FF) в Unicode
отображена на <code>gb18030</code>.</li>
<li>Нет никакого отображения между (U+D800, U+DFFF) и GB18030. Предпринятое
преобразование кодовых точек в этом диапазоне возвращает '<code>?</code>'.
</li>

<li>Если поступающая последовательность незаконна, ошибка или предупреждение
возвращены. Если незаконная последовательность используется в
<code>CONVERT()</code>, ошибка возвращена. Иначе, предупреждение возвращено.
</li>

<li>Для последовательности с <code>utf8</code> и <code>utf8mb4</code> UPPER
не поддержан для связей.</li>
<li>Поиски связей также соответствуют связи верхнего регистра, используя
сопоставление <code>gb18030_unicode_520_ci</code>.</li>

<li>Если у символа есть больше одного символа верхнего регистра, выбранный
символ верхнего регистра тот, нижний регистр которого исходный символ.</li>
<li>Минимальная длина мультибайтного символа 1, максимальная 4.
Набор символов определяет длину последовательности, используя
первые 1 или 2 байта.</p></li></ul>

<h6><a name="idm139965363080496"></a>Поддержанные сопоставления</h6>
<ul><li><p><code>gb18030_bin</code>: двоичное сопоставление.</li>
<li><code>gb18030_chinese_ci</code>: Сопоставление по умолчанию, которое
поддерживает Pinyin. Сортировка некитайских символов основана на порядке
оригинальной сортировки ключа. Это <code>GB(UPPER(ch))</code>, если есть
<code>UPPER(ch)</code>. Иначе это <code>GB(ch)</code>.
Китайские символы сортированы согласно сопоставлению Pinyin, определенному в
Unicode Common Locale Data Repository (CLDR 24).
Некитайские символы сортированы перед китайскими символами за исключением
<code>GB+FE39FE39</code>, который является максимумом кодовой точки.</li>

<li><code>gb18030_unicode_520_ci</code>: Сопоставление Unicode. Используйте
это сопоставление, если Вы должны гарантировать, что
связи сортированы правильно.</p></li></ul>

<h4><a name="charset-binary-set"></a>11.1.10.8.
Двоичный набор символов <code>binary</code></h4>
<p>Набор символов <code>binary</code> это набор символов двоичных строк,
которые являются последовательностями байтов. <code>binary</code> имеет
одно сопоставление, также названное <code>binary</code>. Сравнение и
сортировка основаны на числовых значениях байта. Эффект состоит в том, что
различия в акценте и регистре являются существенными в сравнениях. Таким
образом, сопоставление <code>binary</code> чувствительным к
регистру и диакритическим знакам.
<pre>
mysql&gt; SET NAMES 'binary';
mysql&gt; SELECT CHARSET('abc'), COLLATION('abc');
+----------------+------------------+
| CHARSET('abc') | COLLATION('abc') |
+----------------+------------------+
| binary         | binary           |
+----------------+------------------+
mysql&gt; SELECT 'abc' = 'ABC', 'a' = 'ц╓';
+---------------+------------+
| 'abc' = 'ABC' | 'a' = 'ц╓' |
+---------------+------------+
| 0             |  0         |
+---------------+------------+
</pre>

<p>Для информации о различиях между сопоставлением
<code>binary</code> набора символов <code>binary</code>
сопоставлениями <code>_bin</code> недвоичных наборов символов см.
<a href="#charset-binary-collations">раздел 11.1.8.5</a>.</p>

<p>Чтобы преобразовать строковое выражение в двоичную строку, любая из
этих конструкций эквивалентна:
<pre>
BINARY <em><code>expr</code></em>
CAST(<em><code>expr</code></em> AS BINARY)
CONVERT(<em><code>expr</code></em> USING BINARY)
</pre>

<p>Если <em><code>expr</code></em> буквальная строка символов,
introducer <code>_binary</code> может использоваться, чтобы определить это
как двоичную строку. Пример:
<pre>
_binary 'a'
</pre>
<p>introducer <code>_binary</code> разрешен для шестнадцатеричных
битовых литералов также, но не нужен: это двоичные строки по умолчанию.</p>

<h2><a name="error-message-language"></a>11.2.
Установка языка сообщений об ошибках</h2>
<p>По умолчанию <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> производит сообщения об ошибках на английском языке, но они могут
также быть выведены на экран на любом из нескольких других языков:
Czech, Danish, Dutch, Estonian, French, German, Greek,
Hungarian, Italian, Japanese, Korean, Norwegian, Norwegian-ny,
Polish, Portuguese, Romanian, Russian, Slovak, Spanish или Swedish.</p>

<p>Вы можете выбрать, какой язык сервер использует для сообщений об ошибках,
используя инструкции в этом разделе.</p>
<p>Сервер ищет файл сообщения об ошибке в двух местах:</p>

<ul><li><p>Это пытается найти файл в каталоге с именем из двух значений
системных переменных: <a href="server.htm#sysvar_lc_messages_dir"><code>
lc_messages_dir</code></a> и <a href="server.htm#sysvar_lc_messages"><code>
lc_messages</code></a>, преобразованным в языковое имя. Предположите, что Вы
запускаете сервер, используя эту команду:
<pre>
shell&gt; mysqld --lc_messages_dir=/usr/share/mysql --lc_messages=fr_FR
</pre>

<p>В этом случае <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> отображает <code>fr_FR</code> на язык <code>french</code>
и ищет файл в каталоге <code>/usr/share/mysql/french</code>.</li>

<li>Если файл сообщений не может быть найден в каталоге, созданном как только
что описано, сервер игнорирует значение
<a href="server.htm#sysvar_lc_messages"><code>lc_messages</code></a> и
использует только <a href="server.htm#sysvar_lc_messages_dir"><code>
lc_messages_dir</code></a>.</p></li></ul>

<p>Переменная <a href="server.htm#sysvar_lc_messages_dir"><code>
lc_messages_dir</code></a> имеет только глобальное значение и только для
чтения. <a href="server.htm#sysvar_lc_messages"><code>lc_messages</code></a>
имеет значения глобальное и сеанса и может быть изменена во время выполнения,
таким образом, язык сообщения об ошибке может быть изменен в то время, как
сервер работает, и отдельные клиенты могут иметь различные языки сообщения об
ошибке, изменяя их сеансовое значение
<a href="server.htm#sysvar_lc_messages"><code>lc_messages</code></a>.
Например, если сервер использует <code>fr_FR</code>
для сообщений об ошибках, клиент может выполнить этот запрос, чтобы получить
сообщения об ошибках на английском языке:
<pre>
mysql&gt; SET lc_messages = 'en_US';
</pre>

<p>По умолчанию языковые файлы расположены в подкаталоге
<code>share/mysql/<em><code>LANGUAGE</code></em></code>
базового каталога MySQL.</p>

<p>Вы можете изменить контент сообщений об ошибках, произведенных сервером,
используя инструкции в руководстве MySQL Internals, доступном на
<a href="../../../dev.mysql.com/doc/internals/en/error-messages.html"
target="_top">MySQL Internals: Error Messages</a>.
Если Вы действительно изменяете контент сообщений об ошибках, не забудьте
повторять свои изменения после каждого обновления до более
новой версии MySQL.</p>

<h2><a name="adding-character-set"></a>11.3. Добавление набора символов</h2>
<p>Этот раздел обсуждает процедуру для того, чтобы добавить набор символов
к MySQL. Надлежащая процедура зависит от того, прост набор
символов или сложен:</p>

<ul><li><p>Если набор символов не нуждается в специальных строковых
подпрограммах сопоставления для того, чтобы сортировать и не нуждается в
поддержке мультибайтных символов, он простой.</li>
<li>Если набор символов нуждается в любой из этих особенностей, он сложный.
</p></li></ul>

<p>Например, <code>greek</code> и <code>swe7</code>
простые наборы символов, тогда как <code>big5</code> и <code>czech</code>
сложные наборы символов.</p>

<p>Чтобы использовать следующие инструкции, у Вас должны быть исходные
тексты MySQL. В инструкциях <em><code>MYSET</code></em>
представляет название набора символов, который Вы хотите добавить.</p>

<ol type="1"><li><p>Добавьте элемент <code>&lt;charset&gt;</code> для
<em><code>MYSET</code></em> в файл <code>sql/share/charsets/Index.xml</code>.
Используйте существующее содержание в файле как руководство по добавлению
нового содержания. Частичное перечисление для элемента <code>latin1</code>
<code>&lt;charset&gt;</code>:
<pre>
&lt;charset name="latin1"&gt;
  &lt;family&gt;Western&lt;/family&gt;
  &lt;description&gt;cp1252 West European&lt;/description&gt;
  ...
  &lt;collation name="latin1_swedish_ci" id="8" order="Finnish, Swedish"&gt;
&lt;flag&gt;primary&lt;/flag&gt;
&lt;flag&gt;compiled&lt;/flag&gt;
  &lt;/collation&gt;
  &lt;collation name="latin1_danish_ci" id="15" order="Danish"/&gt;
  ...
  &lt;collation name="latin1_bin" id="47" order="Binary"&gt;
&lt;flag&gt;binary&lt;/flag&gt;
&lt;flag&gt;compiled&lt;/flag&gt;
  &lt;/collation&gt;
  ...
&lt;/charset&gt;
</pre>

<p>Элемент <code>&lt;charset&gt;</code> должен перечислить все сопоставления
для набора символов. Они должны включать, по крайней мере, двоичное
сопоставление и значение по умолчанию (основное). Сопоставление по умолчанию
часто называют, используя суффикс <code>general_ci</code> (общее,
нечувствительное к регистру). Для двоичного сопоставления возможно быть
сопоставлением по умолчанию, но обычно они отличаются. У сопоставления по
умолчанию должен быть флаг <code>primary</code>.
У двоичного сопоставления должен быть флаг <code>binary</code>.</p>

<p>Вы должны назначить уникальный идентификационный номер на каждое
сопоставление. Диапазон ID от 1024 до 2047 сохранен для определяемых
пользователем сопоставлений. Чтобы найти максимум в настоящее время
используемых ID, используйте этот запрос:
<pre>
SELECT MAX(ID) FROM INFORMATION_SCHEMA.COLLATIONS;
</pre></li>

<li>Этот шаг зависит от того, добавляете ли Вы простой или сложный набор
символов. Простой набор символов требует только конфигурационного файла,
тогда как сложный набор символов требует исходного файла C, который
определяет функции сопоставления, мультибайтные функции или обе.</p>

<p>Для простого набора символов, создайте конфигурационный файл
<code><em><code>MYSET</code></em>.xml</code>, который
описывает свойства набора символов. Создайте этот файл в каталоге
<code>sql/share/charsets</code>. Вы можете использовать копию
<code>latin1.xml</code> как основание для этого файла. Синтаксис для
файла очень прост:</p>

<ul><li><p>Комментарии написаны как обычные XML-комментарии
(<code>&lt;!-- <em><code>text</code></em>
--&gt;</code>).</li>

<li>Слова в пределах элементов массива <code>&lt;map&gt;</code>
отделены произвольным количеством пробелов.</li>
<li>Каждое слово в пределах элементов массива <code>&lt;map&gt;</code>
должно быть числом в шестнадцатеричном формате.</li>

<li>Элемент массива <code>&lt;map&gt;</code> для
<code>&lt;ctype&gt;</code> имеет 257 слов. Другие элементы массива
<code>&lt;map&gt;</code> после него имеют 256 слов. См.
<a href="#character-arrays">раздел 11.3.1</a>.</li>

<li>Для каждого сопоставления, перечисленного в элементе
<code>&lt;charset&gt;</code> для набора символов в <code>Index.xml</code>,
<code><em><code>MYSET</code></em>.xml</code> должен содержать элемент
<code>&lt;collation&gt;</code>, который определяет символьное упорядочивание.
</p></li></ul>

<p>Для сложного набора символов, создайте исходный файл C, который описывает
свойства набора символов и определяет подпрограммы поддержки, необходимые,
чтобы должным образом выполнить операции на наборе символов:</p>

<ul><li><p>Создайте файл
<code>ctype-<em><code>MYSET</code></em>.c</code> в каталоге
<code>strings</code>. Смотрите на один из существующих файлов
<code>ctype-*.c</code> (такой, как <code>ctype-big5.c</code>), чтобы понять
их устройство. У массивов в Вашем файле должны быть имена
<code>ctype_<em><code>MYSET</code></em></code>,
<code>to_lower_<em><code>MYSET</code></em></code> и т.д.
Они соответствуют массивам для простого набора символов. См.
<a href="#character-arrays">раздел 11.3.1</a>.</li>

<li>Для каждого элемента <code>&lt;collation&gt;</code>, перечисленного в
<code>&lt;charset&gt;</code> для набора символов в <code>Index.xml</code>
файл <code>ctype-<em><code>MYSET</code></em>.c</code>
должен обеспечить выполнение сопоставления.</li>

<li>Если набор символов требует строковых функций сопоставления, см.
<a href="#string-collating">раздел 11.3.2</a>.</li>
<li>Если набор символов требует поддержки мультибайтных символов, см.
<a href="#multibyte-characters">раздел 11.3.3</a>.</li></ul></li>

<li><p>Измените информацию о конфигурации. Используйте существующую
информацию о конфигурации в качестве руководства по добавлению информации для
<em><code>MYSYS</code></em>. Пример здесь предполагает, что у набора символов
есть значение по умолчанию и двоичные сопоставления, но больше строк
необходимо, если <em><code>MYSET</code></em>
имеет дополнительные сопоставления.</p>

<ol type="a"><li><p>Отредактируйте <code>mysys/charset-def.c</code> и
<span>зарегистрируйте</span> сопоставления для нового набора символов.</p>
<p>Добавьте эти строки к секции <span>declaration</span>:
<pre>
#ifdef HAVE_CHARSET_<em><code>MYSET</code></em>
   extern CHARSET_INFO my_charset_<em><code>MYSET</code></em>_general_ci;
   extern CHARSET_INFO my_charset_<em><code>MYSET</code></em>_bin;
#endif
</pre>

<p>Добавьте эти строки к секции <span>registration</span>:
<pre>
#ifdef HAVE_CHARSET_<em><code>MYSET</code></em>
   add_compiled_collation(&amp;my_charset_<em><code>MYSET</code></em>_general_ci);
   add_compiled_collation(&amp;my_charset_<em><code>MYSET</code></em>_bin);
#endif
</pre></li>

<li>Если набор символов использует
<code>ctype-<em><code>MYSET</code></em>.c</code>, отредактируйте
<code>strings/CMakeLists.txt</code> и добавьте
<code>ctype-<em><code>MYSET</code></em>.c</code> к определению переменной
<code>STRINGS_SOURCES</code>.</li>

<li>Отредактируйте <code>cmake/character_sets.cmake</code>:</p>
<ol type="i"><li><p>Добавьте <em><code>MYSET</code></em> к значению с
<code>CHARSETS_AVAILABLE</code> в алфавитном порядке.</li>

<li>Добавьте <em><code>MYSET</code></em> к значению с
<code>CHARSETS_COMPLEX</code> в алфавитном порядке.
Это необходимо даже для простых наборов символов, или
<span><strong>CMake</strong></span> не будет признавать
<a href="install.htm#option_cmake_default_charset"><code>
-DDEFAULT_CHARSET=<em><code>MYSET</code></em></code></a>.
</p></li></ol></li></ol></li>
<li><p>Реконфигурируйте, повторно соберите и тестируйте.</p></li></ol>

<h3><a name="character-arrays"></a>11.3.1.
Символьные массивы определения</h3>
<p>Каждому простому набору символов определили местонахождение
конфигурационного файла в каталоге <code>sql/share/charsets</code>.
Для названного набора символов <em><code>MYSYS</code></em>, файл называется
<code><em><code>MYSET</code></em>.xml</code>. Это использует элементы
массива <code>&lt;map&gt;</code>, чтобы перечислить свойства набора символов.
Элементы <code>&lt;map&gt;</code> появляются в пределах этих элементов:</p>

<ul><li><p><code>&lt;ctype&gt;</code> определяет признаки
для каждого символа.</li>
<li><code>&lt;lower&gt;</code> и <code>&lt;upper&gt;</code>
перечисляют символы нижнего регистра и символы верхнего регистра.</li>

<li><code>&lt;unicode&gt;</code> отображает 8-битовые символьные значения
на значения Unicode.</li>
<li><code>&lt;collation&gt;</code> указывают на упорядочивание символа для
сравнения и сортировки, одного элемента за сопоставление. Двоичные
сопоставления не нуждаются в элементе <code>&lt;map&gt;</code>,
потому что символьные коды сами обеспечивают упорядочивание.</p></li></ul>

<p>Для сложного набора символов, как осуществлено в файле
<code>ctype-<em><code>MYSET</code></em>.c</code> каталога
<code>strings</code>, есть соответствующие массивы:
<code>ctype_<em><code>MYSET</code></em>[]</code>,
<code>to_lower_<em><code>MYSET</code></em>[]</code> и т. д. Не у каждого
сложного набора символов есть все массивы. См. также существующие файлы
<code>ctype-*.c</code> для примеров. См. файл
<code>CHARSET_INFO.txt</code> в каталоге <code>strings</code>
для дополнительной информации.</p>

<p>Большинство массивов индексировано символьным значением и имеет 256
элементов. Массив <code>&lt;ctype&gt;</code> индексирован символьным
значением+1 и имеет 257 элементов. Это соглашение наследства для того,
чтобы обработать <code>EOF</code>.</p>

<p>Элементы массива <code>&lt;ctype&gt;</code> битовые значения. Каждый
элемент описывает признаки единственного символа в наборе символов. Каждый
признак связан с битовой маской, как определено в
<code>include/m_ctype.h</code>:
<pre>
#define _MY_U   01    /* Upper case */
#define _MY_L   02    /* Lower case */
#define _MY_NMR 04    /* Numeral (digit) */
#define _MY_SPC 010   /* Spacing character */
#define _MY_PNT 020   /* Punctuation */
#define _MY_CTR 040   /* Control character */
#define _MY_B   0100  /* Blank */
#define _MY_X   0200  /* heXadecimal digit */
</pre>

<p>Значение <code>&lt;ctype&gt;</code> для данного символа должно быть
объединением значений битовой маски, которые описывают символ. Например,
code>'A'</code> символ верхнего регистра (<code>_MY_U</code>)
так же как шестнадцатеричная цифра (<code>_MY_X</code>), так значение
<code>ctype</code> должно быть определено как это:
<pre>
ctype['A'+1] = _MY_U | _MY_X = 01 | 0200 = 0201
</pre>

<p>Битовая маска в <code>m_ctype.h</code> имеет октальные значения, но
элементы массива <code>&lt;ctype&gt;</code> в
<code><em><code>MYSET</code></em>.xml</code>
должны быть написаны как шестнадцатеричные значения.</p>

<p>Массивы <code>&lt;lower&gt;</code> и <code>&lt;upper&gt;</code>
хранят символы нижнего регистра и символы верхнего регистра, соответствующие
каждому члену набора символов. Например:
<pre>
lower['A'] should contain 'a'
upper['a'] should contain 'A'
</pre>

<p>Каждый массив <code>&lt;collation&gt;</code> указывает, как
символы должны быть упорядочены в целях сортировки и сравнения. Символы
сортируются MySQL, основываясь на этой информации. В некоторых случаях это то
же самое, как массив <code>&lt;upper&gt;</code>, это означает, что
сортировка является нечувствительной к регистру. Для более сложных правил
сортировки (для сложных наборов символов) см. обсуждение строкового
сопоставления в <a href="#string-collating">разделе 11.3.2</a>.</p>

<h3><a name="string-collating"></a>11.3.2.
Строковая поддержка сопоставления сложных наборов символов</h3>
<p>Для простого набора символов <em><code>MYSET</code></em>
сортирующие правила определены в конфигурационном файле
<code><em><code>MYSET</code></em>.xml</code> с использованием массива
<code>&lt;map&gt;</code> в элементах <code>&lt;collation&gt;</code>.
Если правила сортировки для Вашего языка слишком сложны, чтобы быть
обработанными с простыми массивами, Вы должны определить строковые функции
сопоставления в исходном файле <code>ctype-<em><code>MYSET</code></em>.c
</code> в каталоге <code>strings</code>.</p>

<p>Существующие наборы символов обеспечивают лучшую документацию и примеры,
чтобы показать, как эти функции осуществлены. Смотрите файлы
the <code>ctype-*.c</code> в каталоге
<code>strings</code>, такие как the <code>big5</code>, <code>czech</code>,
<code>gbk</code>, <code>sjis</code> и <code>tis160</code>. Смотрите на
структуры <code>MY_COLLATION_HANDLER</code>, чтобы видеть, как они
используются. См. также файл <code>CHARSET_INFO.txt</code> в каталоге
<code>strings</code> для дополнительной информации.</p>

<h3><a name="multibyte-characters"></a>11.3.3.
Поддержка мультибайтных символов</h3>
<p>Если Вы хотите добавить поддержку нового набора символов
<em><code>MYSET</code></em>, который включает мультибайтные символы,
Вы должны использовать функции мультибайтных символов в исходном файле
<code>ctype-<em><code>MYSET</code></em>.c</code>
каталога <code>strings</code>.</p>

<p>Существующие наборы символов обеспечивают лучшую документацию и примеры,
чтобы показать, как эти функции осуществлены. Смотрите файлы
the <code>ctype-*.c</code> в каталоге <code>strings</code>, такие как
the <code>euc_kr</code>, <code>gb2312</code>, <code>gbk</code>,
<code>sjis</code> и <code>ujis</code>. Смотрите структуры
<code>MY_CHARSET_HANDLER</code>, чтобы видеть, как они используются. См.
также файл <code>CHARSET_INFO.txt</code> в каталоге <code>strings</code>
для дополнительной информации.</p>

<h2><a name="adding-collation"></a>11.4.
Добавление сопоставления к набору символов</h2>
<p>Сопоставление это ряд правил, который определяет, как сравнить и
сортировать строки символов. Каждое сопоставление в MySQL принадлежит
единственному набору символов. У каждого набора символов есть по крайней мере
одно сопоставление, и у большинства есть два или больше сопоставлений.</p>

<p>Сопоставление упорядочивает символы, основываясь на весах.
Каждый символ в наборе символов отображается на вес. Символы с равными весами
сравниваются как равные, а символы с неравными весами сравниваются согласно
относительной величине их весов.</p>

<p>Функция <a href="funct.htm#function_weight-string"><code>WEIGHT_STRING()
</code></a> может использоваться, чтобы видеть веса для символов в строке.
Значение, которое это возвращает, чтобы указать на веса, является двоичной
строкой, таким образом, удобно использовать
<code>HEX(WEIGHT_STRING(<em><code>str</code></em>))</code>, чтобы
вывести на экран веса в пригодной для печати форме. Следующий пример
показывает, что веса не отличаются для регистра символов в
<code>'AaBb'</code>, если это недвоичная нечувствительная к регистру строка,
но отличаются, если это двоичная строка:
<pre>
mysql&gt; SELECT HEX(WEIGHT_STRING('AaBb' COLLATE latin1_swedish_ci));
+------------------------------------------------------+
| HEX(WEIGHT_STRING('AaBb' COLLATE latin1_swedish_ci)) |
+------------------------------------------------------+
| 41414242                                             |
+------------------------------------------------------+
mysql&gt; SELECT HEX(WEIGHT_STRING(BINARY 'AaBb'));
+-----------------------------------+
| HEX(WEIGHT_STRING(BINARY 'AaBb')) |
+-----------------------------------+
| 41614262                          |
+-----------------------------------+
</pre>

<p>MySQL поддерживает несколько сопоставлений, как обсуждено в
<a href="#charset-collation-implementations">разделе 11.4.1</a>.
Некоторые из них могут быть добавлены к MySQL без перекомпилирования:</p>

<ul><li><p>Простые сопоставления для 8-битовых наборов символов.</li>
<li>UCA сопоставления для наборов символов Unicode.</li>
<li>Двоичные сопоставления (<code><em><code>xxx</code></em>_bin</code>).
</p></li></ul>

<p>Следующие разделы описывают, как добавить сопоставления первых двух типов
к существующим наборам символов. У всех существующих наборов символов уже
есть двоичное сопоставление, таким образом нет никакой потребности здесь
описывать, как его добавить.</p>

<p>Резюме процедуры для того, чтобы добавить новое сопоставление:</p>
<ol type="1"><li><p>Выберите ID сопоставления.</li>
<li>Добавьте информацию о конфигурации, которая называет сопоставление
и описывает упорядочивающие символы правила.</li>
<li>Перезапустите сервер.</li>
<li>Проверьте, что сопоставление присутствует.</p></li></ol>

<p>Инструкции здесь покрывают только сопоставления, которые могут быть
добавлены, не собирая MySQL повторно. Чтобы добавить сопоставление, которое
действительно требует перекомпилирования (как осуществлено посредством
функций в исходном файле C), используйте инструкции в
<a href="#adding-character-set">разделе 11.3</a>.
Однако, вместо того, чтобы добавить всю информацию, запрошенную для полного
набора символов, измените только соответствующие файлы для существующего
набора символов. Таким образом, основываясь на том, что уже присутствует для
текущих сопоставлений набора символов, добавьте структуры данных,
функции и информацию о конфигурации для нового сопоставления.</p>

<p>Если Вы изменяете существующее сопоставление, оно может затронуть
упорядочивание строк для индексов на столбцах, которые используют
сопоставление. В этом случае восстановите любой такой индекс, чтобы избежать
таких проблем, как неправильные результаты запроса. Для дополнительной
информации см. <a href="install.htm#checking-table-incompatibilities">
раздел 2.10.3</a>.</p>

<h3><a name="idm139965362834096"></a>Дополнительные ресурсы</h3>
<ul><li><p>The Unicode Collation Algorithm (UCA) specification:
<a href="../../../www.unicode.org/reports/tr10/default.htm" target="_top">
http://www.unicode.org/reports/tr10/</a></li>

<li>The Locale Data Markup Language (LDML) specification:
<a href="../../../www.unicode.org/reports/tr35/default.htm" target="_top">
http://www.unicode.org/reports/tr35/</a></p></li></ul>

<h3><a name="charset-collation-implementations"></a>11.4.1.
Типы выполнения сопоставления</h3>
<p>MySQL осуществляет несколько типов сопоставлений:</p>

<p><span><strong>Простые сопоставления для 8-битовых наборов символов
</strong></span></p>
<p>Этот вид сопоставления осуществлен, используя массив из 256 весов, который
определяет непосредственное отображение символьных кодов в весы.
<code>latin1_swedish_ci</code> пример такого варианта.
Это нечувствительное к регистру сопоставление, таким образом, у верхнего
регистра и строчных версий символа есть те же самые веса, и они
сравниваются как равные.
<pre>
mysql&gt; SET NAMES 'latin1' COLLATE 'latin1_swedish_ci';
Query OK, 0 rows affected (0.01 sec)

mysql&gt; SELECT HEX(WEIGHT_STRING('a')), HEX(WEIGHT_STRING('A'));
+-------------------------+-------------------------+
| HEX(WEIGHT_STRING('a')) | HEX(WEIGHT_STRING('A')) |
+-------------------------+-------------------------+
| 41                      | 41                      |
+-------------------------+-------------------------+
1 row in set (0.01 sec)

mysql&gt; SELECT 'a' = 'A';
+-----------+
| 'a' = 'A' |
+-----------+
| 1         |
+-----------+
1 row in set (0.12 sec)
</pre>
<p>Для инструкций выполнения см.
<a href="#adding-collation-simple-8bit">раздел 11.4.3</a>.</p>

<p><span><strong>Сложные сопоставления для 8-битовых наборов символов
</strong></span></p>
<p>Этот вид сопоставления осуществлен, используя функции в исходном файле C,
которые определяют, как упорядочить символы, как описано в
<a href="#adding-character-set">разделе 11.3</a>.</p>

<p><span><strong>Сопоставления для не-Unicode многобайтовых наборов символов
</strong></span></p>
<p>Для этого типа сопоставления 8-битовые и мультибайтные символы обработаны
по-другому. Для 8-битовых символов символьные коды отображаются на веса
нечувствительным к регистру способом. Например, символы единственного байта
<code>'a'</code> и <code>'A'</code> имеют вес <code>0x41</code>. Для
мультибайтных символов есть два типа отношений между
символьными кодами и весами:</p>

<ul><li><p>Веса равные символьным кодам. Пример: <code>sjis_japanese_ci
</code>. Мультибайтный символ <code>'Ц│╒'</code> имеет символьный код
<code>0x82C0</code> и вес также <code>0x82C0</code>.
<pre>
mysql&gt; CREATE TABLE t1 (c1 VARCHAR(2) CHARACTER SET sjis
                 COLLATE sjis_japanese_ci);
Query OK, 0 rows affected (0.01 sec)

mysql&gt; INSERT INTO t1 VALUES ('a'),('A'),(0x82C0);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; SELECT c1, HEX(c1), HEX(WEIGHT_STRING(c1)) FROM t1;
+-----+---------+------------------------+
| c1  | HEX(c1) | HEX(WEIGHT_STRING(c1)) |
+-----+---------+------------------------+
| a   | 61      | 41                     |
| A   | 41      | 41                     |
| Ц│╒ | 82C0    | 82C0                   |
+-----+---------+------------------------+
3 rows in set (0.00 sec)
</pre></li>

<li>Символьные коды отображаются непосредственно на веса, но код не
обязательно равен весу. Пример этого: <code>gbk_chinese_ci</code>.
Мультибайтный символ <code>'Х├╟'</code> имеет символьный код
<code>0x81B0</code>, но вес <code>0xC286</code>.
<pre>
mysql&gt; CREATE TABLE t1 (c1 VARCHAR(2) CHARACTER SET gbk
                 COLLATE gbk_chinese_ci);
Query OK, 0 rows affected (0.33 sec)

mysql&gt; INSERT INTO t1 VALUES ('a'),('A'),(0x81B0);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; SELECT c1, HEX(c1), HEX(WEIGHT_STRING(c1)) FROM t1;
+----+---------+------------------------+
| c1 | HEX(c1) | HEX(WEIGHT_STRING(c1)) |
+----+---------+------------------------+
| a  | 61      | 41                     |
| A  | 41      | 41                     |
| Х╟ | 81B0    | C286                   |
+----+---------+------------------------+
3 rows in set (0.00 sec)
</pre></li></ul>
<p>Для инструкций выполнения см.
<a href="#adding-character-set">раздел 11.3</a>.</p>

<p><span><strong>Сопоставления для многобайтовых наборов символов Unicode
</strong></span></p>
<p>Некоторые из этих сопоставлений основаны на Unicode Collation Algorithm
(UCA), другие нет.</p>

<p>Не-UCA сопоставления имеют непосредственное отображение символьного кода
на вес. В MySQL такие сопоставления являются нечувствительными к регистру и
не чувствительными к диакритическим знакам. Пример
<code>utf8_general_ci</code>: <code>'a'</code>, <code>'A'</code>,
<code>'ц─'</code> и <code>'ц║'</code> имеют различные символьные коды, но у
всех есть вес <code>0x0041</code> и сравниваются как равные.
<pre>
mysql&gt; SET NAMES 'utf8' COLLATE 'utf8_general_ci';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; CREATE TABLE t1 (c1 CHAR(1) CHARACTER SET UTF8
                 COLLATE utf8_general_ci);
Query OK, 0 rows affected (0.01 sec)

mysql&gt; INSERT INTO t1 VALUES ('a'),('A'),('ц─'),('ц║');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; SELECT c1, HEX(c1), HEX(WEIGHT_STRING(c1)) FROM t1;
+----+---------+------------------------+
| c1 | HEX(c1) | HEX(WEIGHT_STRING(c1)) |
+----+---------+------------------------+
| a  | 61      | 0041                   |
| A  | 41      | 0041                   |
| ц─ | C380    | 0041                   |
| ц║ | C3A1    | 0041                   |
+----+---------+------------------------+
4 rows in set (0.00 sec)
</pre>

<p>У UCA-сопоставлений в MySQL есть эти свойства:</p>
<ul><li><p>Если у символа есть веса, каждый вес
использует 2 байта (16 битов).</li>

<li>У символа могут быть нулевые веса (или пустой вес).
В этом случае, символ является игнорируемым. Пример: "U+0000 NULL"
не имеет веса и является игнорируемым.</li>

<li>У символа может быть один вес. Пример:
<code>'a'</code> имеет вес <code>0x0E33</code>.
<pre>
mysql&gt; SET NAMES 'utf8' COLLATE 'utf8_unicode_ci';
Query OK, 0 rows affected (0.05 sec)

mysql&gt; SELECT HEX('a'), HEX(WEIGHT_STRING('a'));
+----------+-------------------------+
| HEX('a') | HEX(WEIGHT_STRING('a')) |
+----------+-------------------------+
| 61       | 0E33                    |
+----------+-------------------------+
1 row in set (0.02 sec)
</pre></li>

<li>У символа может быть много весов. Это расширение. Пример: немецкий символ
<code>'ц÷'</code> (SZ или SHARP S) имеет вес <code>0x0FEA0FEA</code>.
<pre>
mysql&gt; SET NAMES 'utf8' COLLATE 'utf8_unicode_ci';
Query OK, 0 rows affected (0.11 sec)

mysql&gt; SELECT HEX('ц÷'), HEX(WEIGHT_STRING('ц÷'));
+-----------+--------------------------+
| HEX('ц÷') | HEX(WEIGHT_STRING('ц÷')) |
+-----------+--------------------------+
| C39F      | 0FEA0FEA                 |
+-----------+--------------------------+
1 row in set (0.00 sec)
</pre></li>

<li>У многих символов может быть один вес. Это сокращение. Пример: <code>'ch'
</code> одна буква на чешском языке и имеет вес <code>0x0EE2</code>.
<pre>
mysql&gt; SET NAMES 'utf8' COLLATE 'utf8_czech_ci';
Query OK, 0 rows affected (0.09 sec)

mysql&gt; SELECT HEX('ch'), HEX(WEIGHT_STRING('ch'));
+-----------+--------------------------+
| HEX('ch') | HEX(WEIGHT_STRING('ch')) |
+-----------+--------------------------+
| 6368      | 0EE2                     |
+-----------+--------------------------+
1 row in set (0.00 sec)
</pre></li></ul>

<p>Отображение &quot;много символов ко многим весам&quot; также возможно
(это сокращение с расширением), но не поддержано MySQL.</p>
<p>Для инструкций выполнения сопоставления не-UCA см.
<a href="#adding-character-set">раздел 11.3</a>. Для сопоставления
UCA см. <a href="#adding-collation-unicode-uca">раздел 11.4.4</a>.
</p>

<p><span><strong>Разные сопоставления</strong></span></p>
<p>Есть также несколько сопоставлений, которые не попадают ни в одну
из предыдущих категорий.</p>

<h3><a name="adding-collation-choosing-id"></a>11.4.2. Выбор ID сопоставления
</h3>
<p>У каждого сопоставления должен быть уникальный ID. Чтобы добавить
сопоставление, Вы должны выбрать значение идентификатора, которое в настоящее
время не используется. MySQL поддерживает двухбайтовые ID сопоставления.
Диапазон ID от 1024 до 2047 сохранен для определяемых пользователем
сопоставлений. ID сопоставления, которое Вы выбираете,
появится в этих контекстах:</p>

<ul><li><p><code>ID</code> столбца таблицы
<a href="inform.htm#collations-table"><code>INFORMATION_SCHEMA.COLLATIONS
</code></a>.</li>

<li><code>Id</code> столбца в выводе
<a href="sql.htm#show-collation"><code>SHOW COLLATION</code></a>.</li>
<li>Член <code>charsetnr</code> структуры <code>MYSQL_FIELD</code> C API.
</li>

<li>Член <code>number</code> структуры <code>MY_CHARSET_INFO</code>,
возвращенной функцией C API
<a href="connect.htm#mysql-get-character-set-info"><code>
mysql_get_character_set_info()</code></a>.</p></li></ul>

<p>Чтобы определить самый большой в настоящее время используемый ID,
сделайте следующий запрос:
<pre>
mysql&gt; SELECT MAX(ID) FROM INFORMATION_SCHEMA.COLLATIONS;
+---------+
| MAX(ID) |
+---------+
| 210     |
+---------+
</pre>

<p>Чтобы вывести на экран список всех в настоящее время используемых ID:
<pre>
mysql&gt; SELECT ID FROM INFORMATION_SCHEMA.COLLATIONS ORDER BY ID;
+-----+
| ID  |
+-----+
|   1 |
|   2 |
| ... |
|  52 |
|  53 |
|  57 |
|  58 |
| ... |
|  98 |
|  99 |
| 128 |
| 129 |
| ... |
| 210 |
+-----+
</pre>

<p>До MySQL 5.5, который предусматривает диапазон определяемых пользователем
ID сопоставления, Вы должны выбрать ID в диапазоне от 1 до 254. В этом
случае, если Вы обновляете MySQL, Вы можете найти, что ID сопоставления,
который Вы выбираете, был назначен сопоставлению, включенному в новый
дистрибутив MySQL. В этом случае Вы должны будете выбрать новое значение для
своего собственного сопоставления.</p>

<p>Кроме того, перед обновлением Вы должны сохранить конфигурационные файлы,
которые Вы изменяете. Если Вы обновитесь без этого, процесс заменит
Ваши измененные файлы.</p>

<h3><a name="adding-collation-simple-8bit"></a>11.4.3.
Добавление простого сопоставления к 8-битовому набору символов</h3>
<p>Этот раздел описывает, как добавить простое сопоставление для 8-битового
набора символов при записи элементов <code>&lt;collation&gt;</code>,
связанных с описанием набора символов <code>&lt;charset&gt;</code> в файле
MySQL <code>Index.xml</code>. Процедура, описанная здесь, не требует
перекомпилирования MySQL. Пример добавляет сопоставление
<code>latin1_test_ci</code> в набор символов <code>latin1</code>.</p>

<ol type="1"><li><p>Выберите ID сопоставления, как показано в
<a href="#adding-collation-choosing-id">разделе 11.4.2</a>.
Следующие шаги используют ID 1024.</li>

<li>Измените конфигурационные файлы <code>Index.xml</code> и
<code>latin1.xml</code>. Эти файлы расположены в каталоге, указанном в
переменной <a href="server.htm#sysvar_character_sets_dir"><code>
character_sets_dir</code></a>. Вы можете проверить значение переменной
следующим образом, хотя путь мог бы отличаться в Вашей системе:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'character_sets_dir';
+--------------------+-----------------------------------------+
| Variable_name      | Value                                   |
+--------------------+-----------------------------------------+
| character_sets_dir | /user/local/mysql/share/mysql/charsets/ |
+--------------------+-----------------------------------------+
</pre></li>

<li>Выберите название сопоставления и перечислите его в файле
<code>Index.xml</code>. Найдите элемент <code>&lt;charset&gt;</code>
для набора символов, к которому сопоставление добавляется, и добавьте
элемент <code>&lt;collation&gt;</code>, который указывает на имя
сопоставления и ID, чтобы связать имя с ID. Пример:
<pre>
&lt;charset name="latin1"&gt;
  ...
  &lt;collation name="latin1_test_ci" id="1024"/&gt;
  ...
&lt;/charset&gt;
</pre></li>

<li>В конфигурационном файле <code>latin1.xml</code> добавьте элемент
<code>&lt;collation&gt;</code>, который называет сопоставление и содержит
элемент <code>&lt;map&gt;</code>, который определяет символьную таблицу
отображения кода к весу для символьных кодов от 0 до 255. Каждое значение в
пределах элемента <code>&lt;map&gt;</code>
должно быть числом в шестнадцатеричном формате.
<pre>
&lt;collation name="latin1_test_ci"&gt;
&lt;map&gt;
 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F
 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F
 30 31 32 33 34 35 36 37 38 39 3A 3B 3C 3D 3E 3F
 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F
 50 51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F
 60 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F
 50 51 52 53 54 55 56 57 58 59 5A 7B 7C 7D 7E 7F
 80 81 82 83 84 85 86 87 88 89 8A 8B 8C 8D 8E 8F
 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F
 A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF
 B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC BD BE BF
 41 41 41 41 5B 5D 5B 43 45 45 45 45 49 49 49 49
 44 4E 4F 4F 4F 4F 5C D7 5C 55 55 55 59 59 DE DF
 41 41 41 41 5B 5D 5B 43 45 45 45 45 49 49 49 49
 44 4E 4F 4F 4F 4F 5C F7 5C 55 55 55 59 59 DE FF
&lt;/map&gt;
&lt;/collation&gt;
</pre></li>

<li>Перезапустите сервер и используйте этот запрос, чтобы проверить,
что сопоставление присутствует:
<pre>
mysql&gt; SHOW COLLATION WHERE Collation = 'latin1_test_ci';
+----------------+---------+------+---------+----------+---------+
| Collation      | Charset | Id   | Default | Compiled | Sortlen |
+----------------+---------+------+---------+----------+---------+
| latin1_test_ci | latin1  | 1024 |         |          | 1       |
+----------------+---------+------+---------+----------+---------+
</pre></li></ol>

<h3><a name="adding-collation-unicode-uca"></a>11.4.4.
Добавление сопоставления UCA к набору символов Unicode</h3>
<p>Этот раздел описывает, как добавить сопоставление UCA для набора символов
Unicode при написании элемента
<code>&lt;collation&gt;</code> в пределах описания набора символов
<code>&lt;charset&gt;</code> в файле MySQL <code>Index.xml</code>.
Процедура, описанная здесь, не требует перекомпилирования MySQL. Это
использует спецификацию Locale Data Markup Language (LDML), которая доступна
на <a href="../../../www.unicode.org/reports/tr35/default.htm" target="_top">
http://www.unicode.org/reports/tr35/</a>.
С этим методом Вы не должны определить все сопоставление. Вместо этого Вы
начинаете с существующего сопоставления <span>base</span>
и описываете новое сопоставление с точки зрения того, как это отличается от
основного сопоставления. Следующая таблица приводит основные сопоставления
наборов символов Unicode, для которых могут быть определены сопоставления
UCA. Невозможно создать определяемые пользователем сопоставления UCA для
<code>utf16le</code>: нет сопоставления<code>utf16le_unicode_ci</code>,
которое служило бы основанием для таких сопоставлений.</p>

<a name="idm139965362708176"></a><p><b>Таблица 11.3. Наборы символов MySQL,
доступные для определяемых пользователем сопоставлений UCA</b></p>
<table border="1">
<thead><tr><th scope="col">Набор символов</th><th scope="col">Основное
сопоставление</th></tr></thead>
<tbody><tr><td scope="row"><code>utf8</code></td>
<td><code>utf8_unicode_ci</code></td></tr>
<tr><td scope="row"><code>ucs2</code></td>
<td><code>ucs2_unicode_ci</code></td></tr>
<tr><td scope="row"><code>utf16</code></td>
<td><code>utf16_unicode_ci</code></td></tr>
<tr><td scope="row"><code>utf32</code></td>
<td><code>utf32_unicode_ci</code></td></tr></tbody></table>

<p>Следующие разделы показывают, как добавить сопоставление, которое
определено, используя синтаксис LDML, и обеспечить резюме правил
LDML, поддержанных в MySQL.</p>

<h4><a name="ldml-collation-example"></a>11.4.4.1.
Определение сопоставления UCA, используя синтаксис LDML</h4>
<p>Чтобы добавить сопоставление UCA для набора символов Unicode, не собирая
повторно MySQL, используйте следующую процедуру. Если Вы не знакомы с
правилами LDML, используемыми, чтобы описать характеристики вида
сопоставления, см. <a href="#ldml-rules">раздел 11.4.4.2</a>.</p>

<p>Пример добавляет сопоставление <code>utf8_phone_ci</code> к набору
символов <code>utf8</code>. Сопоставление разработано для скрипта,
вовлекающего Веб-приложение, для которого пользователи отправляют свои имена
и телефонные номера. Номера телефона могут быть в совсем разных форматах:
<pre>
+7-12345-67
+7-12-345-67
+7 12 345 67
+7 (12) 345 67
+71234567
</pre>

<p>Проблема, поднятая, имея дело с этими видами значений, состоит в том,
что переменные допустимые форматы делают поиск определенного номера телефона
очень трудным. Решение состоит в том, чтобы определить новое сопоставление,
которое переупорядочивает символы пунктуации, делая их игнорируемыми.</p>

<ol type="1"><li><p>Выберите ID сопоставления, как показано в
<a href="#adding-collation-choosing-id">разделе 11.4.2</a>.
Следующие шаги используют ID 1029.</li>

<li>Измените конфигурационный файл <code>Index.xml</code>. Этот файл
расположен в каталоге, названном в переменной
<a href="server.htm#sysvar_character_sets_dir"><code>character_sets_dir
</code></a>. Вы можете проверить значение переменной следующим образом, хотя
путь мог бы отличаться в Вашей системе:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'character_sets_dir';
+--------------------+-----------------------------------------+
| Variable_name      | Value                                   |
+--------------------+-----------------------------------------+
| character_sets_dir | /user/local/mysql/share/mysql/charsets/ |
+--------------------+-----------------------------------------+
</pre></li>

<li>Выберите название сопоставления и перечислите его в файле
<code>Index.xml</code>. Кроме того, Вы должны будете обеспечить правила
упорядочивания сопоставления. Найдите элемент
<code>&lt;charset&gt;</code> для набора символов, к которому сопоставление
добавляется, и добавьте элемент <code>&lt;collation&gt;</code>, который
указывает на имя сопоставления и ID, чтобы связать имя с ID. В пределах
элемента <code>&lt;collation&gt;</code> обеспечьте элемент
<code>&lt;rules&gt;</code>, содержащий правила упорядочивания:
<pre>
&lt;charset name="utf8"&gt;
  ...
  &lt;collation name="utf8_phone_ci" id="1029"&gt;
&lt;rules&gt;
&lt;reset&gt;\u0000&lt;/reset&gt;
&lt;i&gt;\u0020&lt;/i&gt; &lt;!-- space --&gt;
&lt;i&gt;\u0028&lt;/i&gt; &lt;!-- left parenthesis --&gt;
&lt;i&gt;\u0029&lt;/i&gt; &lt;!-- right parenthesis --&gt;
&lt;i&gt;\u002B&lt;/i&gt; &lt;!-- plus --&gt;
&lt;i&gt;\u002D&lt;/i&gt; &lt;!-- hyphen --&gt;
&lt;/rules&gt;
  &lt;/collation&gt;
  ...
&lt;/charset&gt;
</pre></li>

<li>Если Вы хотите подобное сопоставление для других наборов символов
Unicode, добавьте другой элемент <code>&lt;collation&gt;</code>.
Например, чтобы определить <code>ucs2_phone_ci</code>, добавьте элемент
<code>&lt;collation&gt;</code> в элемент
<code>&lt;charset name="ucs2"&gt;</code>. Помните, что у каждого
сопоставления должно быть свой собственный уникальный ID.</li>

<li>Перезапустите сервер и используйте этот запрос, чтобы проверить,
что сопоставление присутствует:
<pre>
mysql&gt; SHOW COLLATION WHERE Collation = 'utf8_phone_ci';
+---------------+---------+------+---------+----------+---------+
| Collation     | Charset | Id   | Default | Compiled | Sortlen |
+---------------+---------+------+---------+----------+---------+
| utf8_phone_ci | utf8    | 1029 |         |          | 8       |
+---------------+---------+------+---------+----------+---------+
</pre></li></ol>

<p>Теперь проверьте сопоставление, чтобы удостовериться, что у него
есть желаемые свойства.</p>

<p>Составьте таблицу, содержащую некоторые типовые номера телефона,
используя новое сопоставление:
<pre>
mysql&gt; CREATE TABLE phonebook (name VARCHAR(64),
                 phone VARCHAR(64) CHARACTER SET utf8
                 COLLATE utf8_phone_ci);
Query OK, 0 rows affected (0.09 sec)

mysql&gt; INSERT INTO phonebook VALUES ('Svoj','+7 912 800 80 02');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO phonebook VALUES ('Hf','+7 (912) 800 80 04');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO phonebook VALUES ('Bar','+7-912-800-80-01');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO phonebook VALUES ('Ramil','(7912) 800 80 03');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO phonebook VALUES ('Sanja','+380 (912) 8008005');
Query OK, 1 row affected (0.00 sec)
</pre>

<p>Выполните некоторые запросы, чтобы видеть, проигнорированы ли
проигнорированные символы пунктуации фактически для сравнения и сортировки:
<pre>
mysql&gt; SELECT * FROM phonebook ORDER BY phone;
+-------+--------------------+
| name  | phone              |
+-------+--------------------+
| Sanja | +380 (912) 8008005 |
| Bar   | +7-912-800-80-01   |
| Svoj  | +7 912 800 80 02   |
| Ramil | (7912) 800 80 03   |
| Hf    | +7 (912) 800 80 04 |
+-------+--------------------+
5 rows in set (0.00 sec)

mysql&gt; SELECT * FROM phonebook WHERE phone='+7(912)800-80-01';
+------+------------------+
| name | phone            |
+------+------------------+
| Bar  | +7-912-800-80-01 |
+------+------------------+
1 row in set (0.00 sec)

mysql&gt; SELECT * FROM phonebook WHERE phone='79128008001';
+------+------------------+
| name | phone            |
+------+------------------+
| Bar  | +7-912-800-80-01 |
+------+------------------+
1 row in set (0.00 sec)

mysql&gt; SELECT * FROM phonebook WHERE phone='7 9 1 2 8 0 0 8 0 0 1';
+------+------------------+
| name | phone            |
+------+------------------+
| Bar  | +7-912-800-80-01 |
+------+------------------+
1 row in set (0.00 sec)
</pre>

<h4><a name="ldml-rules"></a>11.4.4.2.
Синтаксис LDML, поддержанный в MySQL</h4>
<p>Этот раздел описывает синтаксис LDML, который признает MySQL.
Это подмножество синтаксиса, описанного в спецификации LDML, доступной на
<a href="../../../www.unicode.org/reports/tr35/default.htm" target="_top">
http://www.unicode.org/reports/tr35/</a>, с которой нужно консультироваться
для дополнительной информации. MySQL признает достаточно большое подмножество
синтаксиса, во многих случаях, возможно загрузить определение сопоставления
из Unicode Common Locale Data Repository
и вставить соответствующую часть (то есть, часть между тэгами
<code>&lt;rules&gt;</code> и <code>&lt;/rules&gt;</code>) в файл MySQL
<code>Index.xml</code>. Правила, описанные здесь, все поддержаны за
исключением того, что символьная сортировка происходит только на основном
уровне. Правила, которые определяют различия на вторичных или более
высоких уровнях, признаны (и таким образом могут быть включены в определения
сопоставления), но обработаны как равенство на основном уровне.</p>

<p>Сервер MySQL производит диагностику, когда находит проблемы, разбирая
файл <code>Index.xml</code>. См.
<a href="#collation-diagnostics">раздел 11.4.4.3</a>.</p>

<p><span><strong>Символьное представление</strong></span></p>
<p>Символы, названные в правилах LDML, могут быть написаны буквально или в
формате <code>\u<em><code>nnnn</code></em></code>, где
<em><code>nnnn</code></em> шестнадцатеричное значение кодовой точки Unicode.
Например, <code>A</code> и <code>ц║</code> может быть написан буквально или
как <code>\u0041</code> и <code>\u00E1</code>.
В пределах шестнадцатеричных значений цифры от <code>A</code> до
<code>F</code> не являются чувствительными к регистру: <code>\u00E1</code> и
<code>\u00e1</code> эквивалентны. Для сопоставления UCA 4.0.0
шестнадцатеричная нотация может использоваться только для символов в
Basic Multilingual Plane, но не для символов вне диапазона BMP
от <code>0000</code> до <code>FFFF</code>. Для сопоставления UCA 5.2.0
шестнадцатеричная нотация может использоваться для любого символа.</p>
<p>Файл <code>Index.xml</code> должен быть написан,
используя кодирование UTF-8.</p>

<p><span><strong>Правила синтаксиса</strong></span></p>
<p>LDML имеет ряд правил, чтобы определить символьное упорядочивание.
Упорядочивания даны как ряд правил, которые начинаются с правила сброса,
которое устанавливает точку привязки, сопровождаемую правилами сдвига,
которые указывают сортировку символов относительно точки привязки.</p>

<ul><li><p>Правило <code>&lt;reset&gt;</code>
не определяет упорядочивания. Вместо этого оно сбрасывает
упорядочивание для последующего сдвига, чтобы заставить его быть взятым
относительно данного символа. Любое из следующих правил сбрасывает
последующие правила сдвига, которые будут
взяты относительно символа <code>'A'</code>:
<pre>
&lt;reset&gt;A&lt;/reset&gt;
&lt;reset&gt;\u0041&lt;/reset&gt;
</pre></li>

<li>Правила сдвига <code>&lt;p&gt;</code>,
<code>&lt;s&gt;</code> и <code>&lt;t&gt;</code> определяют основные,
вторичные и третичные различия символа от другого символа:</p>

<ul><li><p>Используйте первичные различия, чтобы отличить отдельные символы.
</li>
<li>Используйте вторичные различия, чтобы отличить изменения акцента.</li>
<li>Используйте третичные различия, чтобы отличить изменения регистра.
</p></li></ul>

<p>Любое из этих правил определяет основное правило сдвига для символа
the <code>'G'</code>:
<pre>
&lt;p&gt;G&lt;/p&gt;
&lt;p&gt;\u0047&lt;/p&gt;
</pre></li>

<li>Правило сдвига <code>&lt;i&gt;</code> указывает, что сортируемый
символ тождественнен другому. Следующее правило сортирует
<code>'b'</code> как <code>'a'</code>:
<pre>
&lt;reset&gt;a&lt;/reset&gt;
&lt;i&gt;b&lt;/i&gt;
</pre></li>

<li>Сокращенный синтаксис сдвига определяет многократные правила сдвига,
используя единственную пару тегов. Следующая таблица показывает связь между
сокращенными правилами синтаксиса и эквивалентными несокращенными правилами.
</p>

<a name="idm139965362616160"></a><p><b>Таблица 11.4.
Сокращенный синтаксис сдвига</b></p>
<table border="1">
<thead><tr><th scope="col">Сокращенный синтаксис</th>
<th scope="col">Несокращенный синтаксис</th></tr></thead>
<tbody><tr><td scope="row"><code>&lt;pc&gt;xyz&lt;/pc&gt;</code></td>
<td><code>&lt;p&gt;x&lt;/p&gt;&lt;p&gt;y&lt;/p&gt;&lt;p&gt;z&lt;/p&gt;</code>
</td></tr>
<tr><td scope="row"><code>&lt;sc&gt;xyz&lt;/sc&gt;</code></td>
<td><code>&lt;s&gt;x&lt;/s&gt;&lt;s&gt;y&lt;/s&gt;&lt;s&gt;z&lt;/s&gt;</code>
</td></tr>
<tr><td scope="row"><code>&lt;tc&gt;xyz&lt;/tc&gt;</code></td>
<td><code>&lt;t&gt;x&lt;/t&gt;&lt;t&gt;y&lt;/t&gt;&lt;t&gt;z&lt;/t&gt;</code>
</td></tr>
<tr><td scope="row"><code>&lt;ic&gt;xyz&lt;/ic&gt;</code></td>
<td><code>&lt;i&gt;x&lt;/i&gt;&lt;i&gt;y&lt;/i&gt;&lt;i&gt;z&lt;/i&gt;</code>
</td></tr></tbody></table></li>

<li><p>Расширение правило сброса, которое устанавливает точку привязки
для многосимвольной последовательности. MySQL поддерживает расширения
в 2-6 символов длиной. Следующие правила помещают <code>'z'</code> в основном
уровне на большее место, чем последовательность
трех символов <code>'abc'</code>:
<pre>
&lt;reset&gt;abc&lt;/reset&gt;
&lt;p&gt;z&lt;/p&gt;
</pre></li>

<li>Сокращение правило сдвига, которое сортирует многосимвольную
последовательность. MySQL поддерживает сокращения длиной в 2-6 символов.
Следующие правила помещают последовательность трех символов
<code>'xyz'</code> больше в основном уровне, чем <code>'a'</code>:
<pre>
&lt;reset&gt;a&lt;/reset&gt;
&lt;p&gt;xyz&lt;/p&gt;
</pre></li>

<li>Расширения и сокращения могут использоваться вместе. Эти правила помещают
последовательность трех символов <code>'xyz'</code> в основном уровне больше,
чем последовательность трех символов <code>'abc'</code>:
<pre>
&lt;reset&gt;abc&lt;/reset&gt;
&lt;p&gt;xyz&lt;/p&gt;
</pre></li>

<li>Нормальное использование синтаксиса расширения <code>&lt;x&gt;</code>
и элементы <code>&lt;extend&gt;</code>, чтобы определить расширение.
Следующие правила помещают символ <code>'k'</code> больше во вторичном
уровне, чем последовательность <code>'ch'</code>. Таким образом,
<code>'k'</code> ведет себя, как будто это расширяется до символа после
<code>'c'</code>, сопровождаемого <code>'h'</code>:
<pre>
&lt;reset&gt;c&lt;/reset&gt;
&lt;x&gt;&lt;s&gt;k&lt;/s&gt;&lt;extend&gt;h&lt;/extend&gt;&lt;/x&gt;
</pre>

<p>Этот синтаксис разрешает длинные последовательности. Эти правила сортируют
последовательность <code>'ccs'</code> больше в третичном уровне,
чем последовательность <code>'cscs'</code>:
<pre>
&lt;reset&gt;cs&lt;/reset&gt;
&lt;x&gt;&lt;t&gt;ccs&lt;/t&gt;&lt;extend&gt;cs&lt;/extend&gt;&lt;/x&gt;
</pre>
<p>Спецификация LDML описывает нормальный синтаксис
расширения как <span>tricky</span>.</li>

<li>Предыдущее использование синтаксиса контекста <code>&lt;x&gt;</code> и
элементов <code>&lt;context&gt;</code>, чтобы определить, что контекст перед
символом затрагивает, как он сортируется. Следующие правила помещают
<code>'-'</code> больше во вторичном уровне, чем <code>'a'</code>, но только
когда <code>'-'</code> происходит после <code>'b'</code>:
<pre>
&lt;reset&gt;a&lt;/reset&gt;
&lt;x&gt;&lt;context&gt;b&lt;/context&gt;&lt;s&gt;-&lt;/s&gt;&lt;/x&gt;
</pre></li>

<li>Предыдущий синтаксис контекста может включать элемент
<code>&lt;extend&gt;</code>. Эти правила помещают
<code>'def'</code> больше в основном уровне, чем <code>'aghi'</code>,
но только когда <code>'def'</code> после <code>'abc'</code>:
<pre>
&lt;reset&gt;a&lt;/reset&gt;
&lt;x&gt;&lt;context&gt;abc&lt;/context&gt;&lt;p&gt;def&lt;/p&gt;&lt;extend&gt;ghi&lt;/extend&gt;&lt;/x&gt;
</pre></li>

<li>Правила сброса разрешают признак <code>before</code>.
Обычно правила сдвига после правила сброса указывают символы, которые
сортируются после символа сброса. Правила сдвига после правила сброса,
которое имеет атрибут <code>before</code>, указывает на символы, которые
сортируются перед символом сброса. Следующие правила помещают символ
<code>'b'</code> немедленно прежде <code>'a'</code> на основном уровне:
<pre>
&lt;reset before="primary"&gt;a&lt;/reset&gt;
&lt;p&gt;b&lt;/p&gt;
</pre>

<p>Допустимые значения атрибута <code>before</code>
определяют уровень сортировки по имени или эквивалентному числовому значению:
<pre>
&lt;reset before="primary"&gt;
&lt;reset before="1"&gt;

&lt;reset before="secondary"&gt;
&lt;reset before="2"&gt;

&lt;reset before="tertiary"&gt;
&lt;reset before="3"&gt;
</pre></li>

<li>Правило сброса может назвать логическую позицию сброса, а
не буквальный символ:
<pre>
&lt;first_tertiary_ignorable/&gt;
&lt;last_tertiary_ignorable/&gt;
&lt;first_secondary_ignorable/&gt;
&lt;last_secondary_ignorable/&gt;
&lt;first_primary_ignorable/&gt;
&lt;last_primary_ignorable/&gt;
&lt;first_variable/&gt;
&lt;last_variable/&gt;
&lt;first_non_ignorable/&gt;
&lt;last_non_ignorable/&gt;
&lt;first_trailing/&gt;
&lt;last_trailing/&gt;
</pre>

<p>Эти правила помещают <code>'z'</code> в основном уровне больше, чем
неигнорируемые символы, у которых есть запись
Default Unicode Collation Element Table (DUCET) и которые не являются CJK:
<pre>
&lt;reset&gt;&lt;last_non_ignorable/&gt;&lt;/reset&gt;
&lt;p&gt;z&lt;/p&gt;
</pre>

<p>Логические позиции кодовых точек показаны в следующей таблице.</p>
<p><b>Таблица 11.5. Логические кодовые точки позиции сброса</b></p>
<table border="1">
<thead><tr><th scope="col">Логическая позиция</th>
<th scope="col">Кодовая точка Unicode 4.0.0</th>
<th scope="col">Кодовая точка Unicode 5.2.0</th></tr></thead>
<tbody><tr><td scope="row"><code>&lt;first_non_ignorable/&gt;</code></td>
<td>U+02D0</td><td>U+02D0</td></tr>
<tr><td scope="row"><code>&lt;last_non_ignorable/&gt;</code></td>
<td>U+A48C</td><td>U+1342E</td></tr>
<tr><td scope="row"><code>&lt;first_primary_ignorable/&gt;</code></td>
<td>U+0332</td><td>U+0332</td></tr>
<tr><td scope="row"><code>&lt;last_primary_ignorable/&gt;</code></td>
<td>U+20EA</td><td>U+101FD</td></tr>
<tr><td scope="row"><code>&lt;first_secondary_ignorable/&gt;</code></td>
<td>U+0000</td><td>U+0000</td></tr>
<tr><td scope="row"><code>&lt;last_secondary_ignorable/&gt;</code></td>
<td>U+FE73</td><td>U+FE73</td></tr>
<tr><td scope="row"><code>&lt;first_tertiary_ignorable/&gt;</code></td>
<td>U+0000</td><td>U+0000</td></tr>
<tr><td scope="row"><code>&lt;last_tertiary_ignorable/&gt;</code></td>
<td>U+FE73</td><td>U+FE73</td></tr>
<tr><td scope="row"><code>&lt;first_trailing/&gt;</code></td><td>U+0000</td>
<td>U+0000</td></tr>
<tr><td scope="row"><code>&lt;last_trailing/&gt;</code></td><td>U+0000</td>
<td>U+0000</td></tr>
<tr><td scope="row"><code>&lt;first_variable/&gt;</code></td><td>U+0009</td>
<td>U+0009</td></tr>
<tr><td scope="row"><code>&lt;last_variable/&gt;</code></td><td>U+2183</td>
<td>U+1D371</td></tr></tbody></table></li>

<li><p>Элемент <code>&lt;collation&gt;</code> разрешает атрибут
<code>shift-after-method</code>, который затрагивает символьное вычисление
веса для правил сдвига. У признака есть эти разрешенные значения:</p>

<ul><li><p><code>simple</code>: Вычислите символьные веса как для правил
сброса, у которых нет признака <code>before</code>.
Это значение по умолчанию, если признак не дан.</li>
<li><code>expand</code>: Использовать расширения для сдвигов
после правил сброса.</p></li></ul>

<p>Предположите, что <code>'0'</code> и <code>'1'</code> имеют веса
<code>0E29</code> и <code>0E2A</code> и мы хотим поместить все основные
латинские буквы между <code>'0'</code> и <code>'1'</code>:
<pre>
&lt;reset&gt;0&lt;/reset&gt;
&lt;pc&gt;abcdefghijklmnopqrstuvwxyz&lt;/pc&gt;
</pre>

<p>Для простого режима сдвига веса вычислены следующим образом:
<pre>
'a' 0E29+1
'b' 0E29+2
'c' 0E29+3
...
</pre>

<p>Однако, есть недостаточно свободных позиций, чтобы поместить 26 символов
между <code>'0'</code> и <code>'1'</code>.
Результат состоит в том, что цифры и буквы смешаны.</p>

<p>Чтобы решить это, надо использовать
<code>shift-after-method="expand"</code>. Тогда веса вычислены так:
<pre>
'a' [0E29][233D+1]
'b' [0E29][233D+2]
'c' [0E29][233D+3]
...
</pre>

<p><code>233D</code> в UCA 4.0.0 вес для символа <code>0xA48C</code>,
который является последним неигнорируемым символом (своего рода самый большой
символ в сопоставлении, исключая CJK). UCA 5.2.0 подобен, но использует
<code>3ACA</code> для символа <code>0x1342E</code>.</p></li></ul>

<p><span><strong>MySQL-определенные расширения LDML</strong></span></p>
<p>Расширение к правилам LDML разрешает элементу
<code>&lt;collation&gt;</code> включать дополнительный признак
<code>version</code> в тэги <code>&lt;collation&gt;</code>, чтобы указать на
версию UCA, на которой базируется сопоставление. Если параметр
<code>version</code> пропущен, его значение по умолчанию <code>4.0.0</code>.
Например, эта спецификация указывает на сопоставление, которое
основано на UCA 5.2.0:
<pre>
&lt;collation id="<em><code>nnn</code></em>" name="utf8_<em><code>xxx</code></em>_ci" version="5.2.0"&gt;
...
&lt;/collation&gt;
</pre>

<h4><a name="collation-diagnostics"></a>11.4.4.3.
Диагностика во время парсинга Index.xml</h4>
<p>Сервер MySQL производит диагностику, когда находит проблемы, разбирая
файл <code>Index.xml</code>:</p>

<ul><li><p>Неизвестные теги записаны в журнал ошибок. Например, следующее
сообщение запишется, если определение сопоставления
содержит тэг <code>&lt;aaa&gt;</code>:
<pre>
[Warning] Buffered warning: Unknown LDML tag:
'charsets/charset/collation/rules/aaa'
</pre></li>

<li>Если инициализация сопоставления невозможна, сервер сообщает об ошибке
<span>Unknown collation</span> и также производит предупреждения, объясняющие
проблемы, такие, как в предыдущем примере. В других случаях, когда описание
сопоставления вообще правильно, но содержит некоторые неизвестные теги,
сопоставление инициализировано и доступно для использования. Неизвестные
части проигнорированы, но предупреждение произведено в журнале ошибок.</li>

<li>Проблемы с сопоставлениями производят предупреждения, которые клиенты
могут вывести на экран с помощью
<a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a>.
Предположите, что правило сброса содержит расширение длинней, чем
максимально поддержанная длина в 6 символов:
<pre>
&lt;reset&gt;abcdefghi&lt;/reset&gt;
&lt;i&gt;x&lt;/i&gt;
</pre>

<p>Попытка использовать сопоставление производит предупреждения:
<pre>
mysql&gt; SELECT _utf8'test' COLLATE utf8_test_ci;
ERROR 1273 (HY000): Unknown collation: 'utf8_test_ci'
mysql&gt; SHOW WARNINGS;
+---------+------+----------------------------------------+
| Level   | Code | Message                                |
+---------+------+----------------------------------------+
| Error   | 1273 | Unknown collation: 'utf8_test_ci'      |
| Warning | 1273 | Expansion is too long at 'abcdefghi=x' |
+---------+------+----------------------------------------+
</pre></li></ul>

<h2><a name="charset-configuration"></a>11.5.
Конфигурация набора символов</h2>
<p>Вы можете изменить набор символов сервера и сопоставление по умолчанию с
помощью опций <a href="server.htm#option_mysqld_character-set-server"><code>
--character-set-server</code></a> и
<a href="server.htm#option_mysqld_collation-server"><code>
--collation-server</code></a>, когда Вы запускаете сервер. Сопоставление
должно быть допустимым сопоставлением для набора символов значения по
умолчанию. Используйте <a href="sql.htm#show-collation"><code>SHOW
COLLATION</code></a>, чтобы определить, какие сопоставления доступны для
каждого набора символов. См.
<a href="server.htm#server-options">раздел 6.1.4</a>.</p>

<p>Если Вы пытаетесь использовать набор символов, который не скомпилирован
в Ваш двоичный модуль, Вы можете столкнуться со следующими проблемами:</p>
<ul><li><p>Ваша программа использует неправильный путь, чтобы определить, где
сохранены наборы символов (обычно это каталог
<code>share/mysql/charsets</code> или подкаталог
<code>share/charsets</code> каталога установки MySQL).
Это может быть установлено при использовании опции
<code>--character-sets-dir</code>, когда Вы выполняете рассматриваемую
программу. Например, чтобы определить каталог, который будет использоваться
программами клиента MySQL, перечислите это в группе <code>[client]</code>
Вашего файла опций. Примеры, данные здесь, показывают то, на что установка
могла бы быть похожей для Unix или Windows, соответственно:
<pre>
[client]
character-sets-dir=/usr/local/mysql/share/mysql/charsets

[client]
character-sets-dir="C:/Program Files/MySQL/MySQL Server 8.0/share/charsets"
</pre></li>

<li>Набор символов сложный, если не может быть загружен динамически. В этом
случае Вы должны повторно собрать программу с поддержкой набора символов.</p>
<p>Для наборов символов Unicode Вы можете определить сопоставления,
не собирая повторно при использовании нотации LDML. См.
<a href="#adding-collation-unicode-uca">раздел 11.4.4</a>.</li>

<li>Набор символов динамический, но у Вас нет конфигурационного файла для
него. В этом случае Вы должны установить конфигурационный файл для набора
символов от нового дистрибутива MySQL.</li>

<li>Если Ваш индексный файл набора символов не содержит название набора
символов, Ваша программа выводит на экран сообщение об ошибке.
Файл называется <code>Index.xml</code> и сообщение:
<pre>
Character set '<em><code>charset_name</code></em>' is not a compiled character set and is not
specified in the '/usr/share/mysql/charsets/Index.xml' file
</pre>

<p>Чтобы решить эту проблему, Вы должны получить новый индексный файл или
вручную добавить название любых недостающих наборов
символов к текущему файлу.</p></li></ul>

<p>Вы можете вынудить программы клиента использовать определенный набор
символов следующим образом:
<pre>
[client]
default-character-set=<em><code>charset_name</code></em>
</pre>

<p>Это обычно не нужно. Однако, когда
<a href="server.htm#sysvar_character_set_system"><code>character_set_system
</code></a> отличается от <a href="server.htm#sysvar_character_set_server">
<code>character_set_server</code></a> или
<a href="server.htm#sysvar_character_set_client"><code>character_set_client
</code></a>, и Вы вводите символы вручную (как идентификаторы объекта базы
данных, значения столбцов или то и другое), они могут быть выведены на экран
неправильно в выводе клиента, или сам вывод может быть отформатирован
неправильно. В таких случаях, запуская клиент mysql с
<a href="programs.htm#option_mysql_default-character-set"><code>
--default-character-set=<em><code>system_character_set</code></em></code>
</a>, то есть, устанавливая набор символов клиента, чтобы соответствовать
системному набору символу, Вы сможете решить проблему.</p>

<p>Для таблиц <code>MyISAM</code> Вы можете проверить имя и номер набора
символов таблицы с <a href="programs.htm#myisamchk"><span><strong>
myisamchk -dvv <em><code>tbl_name</code></em></strong></span></a>.</p>

<h2><a name="time-zone-support"></a>11.6.
Поддержка часового пояса сервера MySQL</h2>
<p>Сервер MySQL поддерживает несколько установок часового пояса:</p>

<ul><li><p>Системный часовой пояс. Когда сервер запускается, он пытается
определить часовой пояс машины хоста и использует это, чтобы установить
переменную <a href="server.htm#sysvar_system_time_zone"><code>
system_time_zone</code></a>. Значение не изменяется после этого.</p>

<p>Вы можете установить системный часовой пояс для сервера MySQL при запуске
с помощью опции <a href="programs.htm#option_mysqld_safe_timezone"><code>
--timezone=<em><code>timezone_name</code></em></code></a>.
Вы можете также установить это через переменную окружения <code>TZ</code>
прежде, чем Вы запустите <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a>. Допустимые значения для
<a href="programs.htm#option_mysqld_safe_timezone"><code>--timezone</code>
</a> или <code>TZ</code> зависят от системы. Консультируйтесь со своей
документацией на операционную систему, чтобы видеть, какие
значения являются приемлемыми.</li>

<li>Зона текущего времени сервера. Глобальная переменная
<a href="server.htm#sysvar_time_zone"><code>time_zone</code></a>
указывает на часовой пояс, в котором в настоящее время работает сервер.
Начальное значение для <a href="server.htm#sysvar_time_zone"><code>time_zone
</code></a> <code>'SYSTEM'</code>, которое указывает, что часовой пояс
сервера тот же самый, что и системный часовой пояс.</p>

<p>Начальное глобальное значение часового пояса сервера может быть определено
явно при запуске с опцией командной строки
<a href="server.htm#option_mysqld_default-time-zone"><code>
--default-time-zone=<em><code>timezone</code></em></code></a>
или Вы можете использовать следующую строку в файле опций:
<pre>
default-time-zone='<em><code>timezone</code></em>'
</pre>

<p>Если Вы имеете привилегии <a href="security.html#priv_super"><code>SUPER
</code></a>, Вы можете установить глобальное значение часового пояса сервера
во время выполнения этим запросом:
<pre>
mysql&gt; SET GLOBAL time_zone = <em><code>timezone</code></em>;
</pre></li>

<li>Зоны времени уровня соединения. У каждого клиента, который соединяется,
есть его собственная установка часового пояса, данная сеансной переменной
<a href="server.htm#sysvar_time_zone"><code>time_zone</code></a>.
Первоначально, переменная сеанса берет свое значение от глобальной
<a href="server.htm#sysvar_time_zone"><code>time_zone</code></a>, но клиент
может изменить свой собственный часовой пояс этим запросом:
<pre>
mysql&gt; SET time_zone = <em><code>timezone</code></em>;
</pre></li></ul>

<p>Текущая установка часового пояса сеанса затрагивает отображение и хранение
временных значений, которые чувствительны к зоне. Это включает значения,
выведенные на экран такими функциями, как
<a href="funct.htm#function_now"><code>NOW()</code></a> или
<a href="funct.htm#function_curtime"><code>CURTIME()</code></a>,
и значения, сохраненные в и полученные из столбцов
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>. Значения для
столбцов <a href="types.htm#datetime"><code>TIMESTAMP</code></a>
преобразованы из зоны текущего времени в UTC для хранения и из UTC в зону
текущего времени для извлечения.</p>

<p>Установка зоны текущего времени не затрагивает значения, выведенные на
экран такой функцией, как <a href="funct.htm#function_utc-timestamp"><code>
UTC_TIMESTAMP()</code></a> или значения в столбцах
<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a>.
Значения в тех типах данных сохранены в UTC: часовой пояс нужен им только,
преобразовывая из значения <code>TIMESTAMP</code>. Если Вы хотите
определенную для места действия арифметику для значений
<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a>,
преобразуйте их в UTC, выполните арифметику, а затем преобразуйте назад.</p>

<p>Текущие значения глобальных и определенных для клиента часовых поясов
могут быть получены так:
<pre>
mysql&gt; SELECT @@global.time_zone, @@session.time_zone;
</pre>

<p>Значения <em><code>timezone</code></em> могут быть даны в нескольких
форматах, ни один из которых не является чувствительным к регистру:</p>
<ul><li><p>Значение <code>'SYSTEM'</code> указывает, что часовой пояс должен
быть тем же самым, как системный часовой пояс.</li>

<li>Значение может быть дано как строка, указывающая на смещение от UTC,
например, <code>'+10:00'</code> или <code>'-6:00'</code>.</li>
<li>Значение может быть дано как названный часовой пояс, например,
<code>'Europe/Helsinki'</code>, <code>'US/Eastern'</code> или
<code>'MET'</code>. Названные часовые пояса могут использоваться только,
если таблицы информации о часовом поясе в базе данных <code>mysql</code>
были созданы и заполнены.</p></li></ul>

<h3><a name="time-zone-installation"></a>
Заполнение таблиц часового пояса</h3>
<p>Несколько таблиц в системной базе данных <code>mysql</code> существуют,
чтобы поддержать информацию о часовом поясе (см.
<a href="server.htm#system-database">раздел 6.3</a>).
Процесс установки MySQL составляет таблицы часового пояса, но не загружает
их. Вы должны сделать это вручную с использованием следующих инструкций.</p>

<p>Загрузка информации о часовом поясе является не обязательно
одноразовой работой, потому что информация иногда изменяется.
Когда такие изменения происходят, приложения, которые используют старые
правила, становятся устаревшими, и Вы можете счесть необходимым перезагрузить
таблицы часового пояса, чтобы хранить информацию, используемую Вашим
сервером MySQL. См. примечания в конце этого раздела.</p>

<p>Если у Вашей системы есть своя собственная база данных
<span>zoneinfo</span> (набор файлов, описывающих часовые пояса), Вы должны
использовать программу <a href="programs.htm#mysql-tzinfo-to-sql"><span>
<strong>mysql_tzinfo_to_sql</strong></span></a> для того, чтобы заполнить
таблицы часового пояса. Примеры таких систем: Linux, FreeBSD, Solaris и OS X.
Одно вероятное местоположение для этих файлов: каталог
<code>/usr/share/zoneinfo</code>. Если у Вашей системы нет базы данных
zoneinfo, Вы можете использовать загружаемый пакет, описанный
позже в этом разделе.</p>

<p>Программа <a href="programs.htm#mysql-tzinfo-to-sql"><span><strong>
mysql_tzinfo_to_sql</strong></span></a> используется, чтобы загрузить таблицы
часового пояса. В командной строке передайте имя пути к каталогу с zoneinfo
<a href="programs.htm#mysql-tzinfo-to-sql"><span><strong>mysql_tzinfo_to_sql
</strong></span></a> и пошлите вывод в клиент
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>. Пример:
<pre>
shell&gt; mysql_tzinfo_to_sql /usr/share/zoneinfo | mysql -u root mysql
</pre>

<p><a href="programs.htm#mysql-tzinfo-to-sql"><span><strong>
mysql_tzinfo_to_sql</strong></span></a> читает файлы часового пояса Вашей
системы и производит запросы SQL для них. <a href="programs.htm#mysql"><span>
<strong>mysql</strong></span></a> обрабатывает запросы,
чтобы загрузить таблицы часового пояса.</p>

<p><a href="programs.htm#mysql-tzinfo-to-sql"><span><strong>
mysql_tzinfo_to_sql</strong></span></a> также может использоваться, чтобы
загрузить единственный файл часового пояса или произвести информацию:</p>

<ul><li><p>Загрузить единственный файл часового пояса
<em><code>tz_file</code></em>, который соответствует имени часового пояса
<em><code>tz_name</code></em>:
<pre>
shell&gt; mysql_tzinfo_to_sql <em><code>tz_file</code></em> <em><code>tz_name</code></em> | mysql -u root mysql
</pre>
<p>С этим подходом Вы должны выполнить отдельную команду, чтобы загрузить
файл часового пояса для каждой названной зоны, о которой должен знать сервер.
</li>

<li>После выполнения <a href="programs.htm#mysql-tzinfo-to-sql"><span>
<strong>mysql_tzinfo_to_sql</strong></span></a> лучше перезапускать сервер,
чтобы он не продолжил использовать любые кэшируемые данные о часовом поясе.
</p></li></ul>

<p>Если Ваша система не имеет никакой zoneinfo базы данных (например,
Windows), Вы можете использовать пакет, который доступен для скачивания в
MySQL Developer Zone:
<pre>
<a href="../../../dev.mysql.com/downloads/timezones.html" target="_top">http://dev.mysql.com/downloads/timezones.html</a>
</pre>

<p>Загрузите пакет часового пояса, который содержит запросы SQL, и распакуйте
это, затем загрузите содержание файла пакета в таблицы часового пояса:
<pre>
shell&gt; mysql -u root mysql &lt; <em><code>file_name</code></em>
</pre>
<p>Теперь перезапустите сервер.</p>

<p><span><em>НЕ</em></span> используйте загружаемый пакет, который
содержит таблицы <code>MyISAM</code>. MySQL применяет <code>InnoDB</code> для
таблиц часового пояса. Попытка заменить их на
<code>MyISAM</code> вызовет проблемы.</p>

<p>Не используйте загружаемый пакет, если у Вашей системы есть база данных
zoneinfo. Используйте <a href="programs.htm#mysql-tzinfo-to-sql"><span>
<strong>mysql_tzinfo_to_sql</strong></span></a>. Иначе Вы можете вызвать
различие в обработке даты и времени между MySQL и другими
приложениями в Вашей системе.</p>

<h3><a name="time-zone-upgrades"></a>11.6.1. Изменения часового пояса</h3>
<p>Когда часовой пояс изменяется, приложения, которые используют старые
правила, становятся устаревшими. Чтобы остаться актуальным, необходимо
удостовериться, что Ваша системная информация о зоне текущего времени
актуальна. Для MySQL есть два фактора:</p>

<ul><li><p>Время операционной системы затрагивает значение, которое сервер
MySQL использует, если его часовой пояс установлен в <code>SYSTEM</code>.
Удостоверьтесь, что Ваша операционная система использует последнюю
информацию о часовом поясе. Для большинства операционных систем последние
обновления готовят Вашу систему к изменениям времени.</li>

<li>Если Вы заменяете системный файл <code>/etc/localtime</code>
часового пояса версией, которая использует правила, отличающиеся от тех,
которые были при запуске
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>,
 Вы должны перезапустить
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
так, чтобы это использовало обновленные правила. Иначе
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
не может заметить, когда система изменяет свое время.</li>

<li>Если Вы используете названные часовые пояса с MySQL, удостоверьтесь
что таблицы часового пояса в базе данных <code>mysql</code> современны.
Если у Вашей системы есть своя собственная база данных zoneinfo, Вы должны
перезагрузить таблицы часового пояса MySQL всякий раз, когда база данных
zoneinfo обновлена. Для систем у которых нет их собственной базы данных
zoneinfo, проверьте MySQL Developer Zone. Когда новое обновление доступно,
загрузите и используйте его, чтобы заменить контент Ваших таблиц зоны
текущего времени. <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> кэширует информацию о часовом поясе, которую ищет, таким образом,
после обновления таблиц часового пояса, Вы должны перезапустить
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>, чтобы
удостовериться, что это не продолжает использовать устаревшие
данные о часовом поясе.</p></li></ul>

<p>Если Вы не уверены, доступны ли названные часовые пояса для использования
сервером или клиентами, которые устанавливают их собственный часовой пояс,
проверьте, пусты ли Ваши таблицы часового пояса. Следующий запрос определяет,
есть ли у таблицы, которая содержит имена часового пояса, какие-либо строки:
<pre>
mysql&gt; SELECT COUNT(*) FROM mysql.time_zone_name;
+----------+
| COUNT(*) |
+----------+
| 0        |
+----------+
</pre>

<p>Количество 0 указывает, что таблица пуста. В этом случае никто не может
использовать названные часовые пояса, и Вы не должны обновить таблицы.
Количество больше 0 указывает, что таблица не пуста и ее содержание доступно,
чтобы использоваться для названной поддержки часового пояса. В этом случае Вы
должны убедиться, что перезагрузили свои таблицы часового пояса так, чтобы
любой, кто использует названные часовые пояса, получил
правильные результаты запроса.</p>

<p>Чтобы проверить, обновлена ли Ваша установка MySQL должным образом для
разнообразия в правилах летнего времени, используйте тест, как показано ниже.
Пример использует значения, которые являются подходящими для 2007 DST
1-часового изменения, которое происходит в США 11 марта в 2:00.</p>

<p>Тест использует эти два запроса:
<pre>
SELECT CONVERT_TZ('2007-03-11 2:00:00','US/Eastern','US/Central');
SELECT CONVERT_TZ('2007-03-11 3:00:00','US/Eastern','US/Central');
</pre>

<p>Эти два временных значения указывают время, в котором происходит изменение
DST, и использование названных часовых поясов требует, чтобы таблицы часового
пояса использовались. Желаемый результат состоит в том, что оба запроса
возвращают тот же самый результат (входное время, преобразованное в
эквивалентное значение в часовом поясе 'US/Central').</p>

<p>Прежде, чем обновить таблицы часового пояса, Вы видели
бы неправильный результат:
<pre>
mysql&gt; SELECT CONVERT_TZ('2007-03-11 2:00:00','US/Eastern','US/Central');
+------------------------------------------------------------+
| CONVERT_TZ('2007-03-11 2:00:00','US/Eastern','US/Central') |
+------------------------------------------------------------+
| 2007-03-11 01:00:00                                        |
+------------------------------------------------------------+

mysql&gt; SELECT CONVERT_TZ('2007-03-11 3:00:00','US/Eastern','US/Central');
+------------------------------------------------------------+
| CONVERT_TZ('2007-03-11 3:00:00','US/Eastern','US/Central') |
+------------------------------------------------------------+
| 2007-03-11 02:00:00                                        |
+------------------------------------------------------------+
</pre>

<p>После обновления таблиц Вы должны видеть правильный результат:
<pre>
mysql&gt; SELECT CONVERT_TZ('2007-03-11 2:00:00','US/Eastern','US/Central');
+------------------------------------------------------------+
| CONVERT_TZ('2007-03-11 2:00:00','US/Eastern','US/Central') |
+------------------------------------------------------------+
| 2007-03-11 01:00:00|
+------------------------------------------------------------+

mysql&gt; SELECT CONVERT_TZ('2007-03-11 3:00:00','US/Eastern','US/Central');
+------------------------------------------------------------+
| CONVERT_TZ('2007-03-11 3:00:00','US/Eastern','US/Central') |
+------------------------------------------------------------+
| 2007-03-11 01:00:00                                        |
+------------------------------------------------------------+
</pre>

<h3><a name="time-zone-leap-seconds"></a>11.6.2.
Поддержка часового пояса с прыжком секунд</h3>
<p>Значения прыжка секунд возвращены с частью времени, которая заканчивается
<code>:59:59</code>. Это означает, что такая функция, как
<a href="funct.htm#function_now"><code>NOW()</code></a>
может возвратить то же самое значение в течение двух или трех
последовательных секунд во время прыжка. Остается истиной то, что буквальные
временные значения, имеющие часть времени, которая заканчивается
<code>:59:60</code> или <code>:59:61</code> считаются недопустимыми.</p>

<p>Если необходимо искать значения
<a href="types.htm#datetime"><code>TIMESTAMP</code></a> на одну секунду
раньше прыжка, аномальные результаты могут быть получены, если Вы используете
сравнение с <code>'YYYY-MM-DD hh:mm:ss'</code>. Следующий пример
демонстрирует это. Это изменяет зону местного времени на UTC, таким образом,
нет никакого различия между внутренними значениями (которые находятся в UTC)
и выведенными на экран (которые применяют исправление часового пояса).
<pre>
mysql&gt; CREATE TABLE t1 (a INT, ts TIMESTAMP DEFAULT NOW(),
                 PRIMARY KEY (ts));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; -- change to UTC
mysql&gt; SET time_zone = '+00:00';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; -- Simulate NOW() = '2008-12-31 23:59:59'
mysql&gt; SET timestamp = 1230767999;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERT INTO t1 (a) VALUES (1);
Query OK, 1 row affected (0.00 sec)

mysql&gt; -- Simulate NOW() = '2008-12-31 23:59:60'
mysql&gt; SET timestamp = 1230768000;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERT INTO t1 (a) VALUES (2);
Query OK, 1 row affected (0.00 sec)

mysql&gt; -- values differ internally but display the same
mysql&gt; SELECT a, ts, UNIX_TIMESTAMP(ts) FROM t1;
+---+---------------------+--------------------+
| a | ts                  | UNIX_TIMESTAMP(ts) |
+---+---------------------+--------------------+
| 1 | 2008-12-31 23:59:59 | 1230767999         |
| 2 | 2008-12-31 23:59:59 | 1230768000         |
+---+---------------------+--------------------+
2 rows in set (0.00 sec)

mysql&gt; -- only the non-leap value matches
mysql&gt; SELECT * FROM t1 WHERE ts = '2008-12-31 23:59:59';
+---+---------------------+
| a | ts                  |
+---+---------------------+
| 1 | 2008-12-31 23:59:59 |
+---+---------------------+
1 row in set (0.00 sec)

mysql&gt; -- the leap value with seconds=60 is invalid
mysql&gt; SELECT * FROM t1 WHERE ts = '2008-12-31 23:59:60';
Empty set, 2 warnings (0.00 sec)
</pre>

<p>Чтобы обойти это, Вы можете использовать сравнение, основанное на значении
UTC, фактически сохраненном в столбце, у которого
есть примененное исправление:
<pre>
mysql&gt; -- selecting using UNIX_TIMESTAMP value return leap value
mysql&gt; SELECT * FROM t1 WHERE UNIX_TIMESTAMP(ts) = 1230768000;
+---+---------------------+
| a | ts                  |
+---+---------------------+
| 2 | 2008-12-31 23:59:59 |
+---+---------------------+
1 row in set (0.00 sec)
</pre>

<h2><a name="locale-support"></a>11.7.
Поддержка места действия сервера MySQL</h2>
<p>Место действия, обозначенное переменной
<a href="server.htm#sysvar_lc_time_names"><code>lc_time_names</code></a>
управляет языком, используемым, чтобы вывести на экран имена дня и месяца и
сокращения. Эта переменная затрагивает вывод функций
<a href="funct.htm#function_date-format"><code>DATE_FORMAT()</code></a>,
<a href="funct.htm#function_dayname"><code>DAYNAME()</code></a> и
<a href="funct.htm#function_monthname"><code>MONTHNAME()</code></a>.</p>

<p><a href="server.htm#sysvar_lc_time_names"><code>lc_time_names</code></a>
не затрагивает функции <a href="funct.htm#function_str-to-date"><code>
STR_TO_DATE()</code></a> или <a href="funct.htm#function_get-format"><code>
GET_FORMAT()</code></a>.</p>

<p>Значение <a href="server.htm#sysvar_lc_time_names"><code>lc_time_names
</code></a> не затрагивает результат
<a href="funct.htm#function_format"><code>FORMAT()</code></a>,
но эта функция берет дополнительный третий параметр, который позволяет месту
действия быть определенным, чтобы использоваться для десятичной запятой числа
результата, разделителя тысяч и группировки между разделителями. Допустимые
значения места действия те же самое, что и значения переменной
<a href="server.htm#sysvar_lc_time_names"><code>lc_time_names</code></a>.</p>

<p>У имен места действия есть язык и подтеги области, перечисленные IANA
(<a href="../../../www.iana.org/assignments/language-subtag-registry"
target="_top">http://www.iana.org/assignments/language-subtag-registry</a>)
такие, как <code>'ja_JP'</code> или <code>'pt_BR'</code>. Значение по
умолчанию <code>'en_US'</code> независимо от установки места действия Вашей
системы, но Вы можете установить значение при запуске сервера или установить
значение <code>GLOBAL</code>, если Вы имеете привилегию
<a href="security.html#priv_super"><code>SUPER</code></a>.
Любой клиент может исследовать значение
<a href="server.htm#sysvar_lc_time_names"><code>lc_time_names</code></a>
или установить значение <code>SESSION</code>, чтобы затронуть место действия
для его собственного соединения.
<pre>
mysql&gt; SET NAMES 'utf8';
Query OK, 0 rows affected (0.09 sec)

mysql&gt; SELECT @@lc_time_names;
+-----------------+
| @@lc_time_names |
+-----------------+
| en_US           |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; SELECT DAYNAME('2010-01-01'), MONTHNAME('2010-01-01');
+-----------------------+-------------------------+
| DAYNAME('2010-01-01') | MONTHNAME('2010-01-01') |
+-----------------------+-------------------------+
| Friday                | January                 |
+-----------------------+-------------------------+
1 row in set (0.00 sec)

mysql&gt; SELECT DATE_FORMAT('2010-01-01','%W %a %M %b');
+-----------------------------------------+
| DATE_FORMAT('2010-01-01','%W %a %M %b') |
+-----------------------------------------+
| Friday Fri January Jan                  |
+-----------------------------------------+
1 row in set (0.00 sec)

mysql&gt; SET lc_time_names = 'es_MX';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT @@lc_time_names;
+-----------------+
| @@lc_time_names |
+-----------------+
| es_MX           |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; SELECT DAYNAME('2010-01-01'), MONTHNAME('2010-01-01');
+-----------------------+-------------------------+
| DAYNAME('2010-01-01') | MONTHNAME('2010-01-01') |
+-----------------------+-------------------------+
| viernes               | enero                   |
+-----------------------+-------------------------+
1 row in set (0.00 sec)

mysql&gt; SELECT DATE_FORMAT('2010-01-01','%W %a %M %b');
+-----------------------------------------+
| DATE_FORMAT('2010-01-01','%W %a %M %b') |
+-----------------------------------------+
| viernes vie enero ene                   |
+-----------------------------------------+
1 row in set (0.00 sec)
</pre>

<p>Название дня или месяца каждой из затронутых функций преобразовано из
<code>utf8</code> к набору символов, обозначенному переменной
<a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a>.</p>

<p><a href="server.htm#sysvar_lc_time_names"><code>lc_time_names</code></a>
может быть установлена в любое из следующих значений места действия.
Набор мест действия, поддержанных MySQL, может отличаться от поддержанных
Вашей операционной системой.</p>

<table border="1">
<tbody><tr><td scope="row"><code>ar_AE</code>: Arabic - United Arab Emirates
</td><td><code>ar_BH</code>: Arabic - Bahrain</td></tr>
<tr><td scope="row"><code>ar_DZ</code>: Arabic - Algeria</td>
<td><code>ar_EG</code>: Arabic - Egypt</td></tr>
<tr><td scope="row"><code>ar_IN</code>: Arabic - India</td>
<td><code>ar_IQ</code>: Arabic - Iraq</td></tr>
<tr><td scope="row"><code>ar_JO</code>: Arabic - Jordan</td>
<td><code>ar_KW</code>: Arabic - Kuwait</td></tr>
<tr><td scope="row"><code>ar_LB</code>: Arabic - Lebanon</td>
<td><code>ar_LY</code>: Arabic - Libya</td></tr>
<tr><td scope="row"><code>ar_MA</code>: Arabic - Morocco</td>
<td><code>ar_OM</code>: Arabic - Oman</td></tr>
<tr><td scope="row"><code>ar_QA</code>: Arabic - Qatar</td>
<td><code>ar_SA</code>: Arabic - Saudi Arabia</td></tr>
<tr><td scope="row"><code>ar_SD</code>: Arabic - Sudan</td>
<td><code>ar_SY</code>: Arabic - Syria</td></tr>
<tr><td scope="row"><code>ar_TN</code>: Arabic - Tunisia</td>
<td><code>ar_YE</code>: Arabic - Yemen</td></tr>
<tr><td scope="row"><code>be_BY</code>: Belarusian - Belarus</td>
<td><code>bg_BG</code>: Bulgarian - Bulgaria</td></tr>
<tr><td scope="row"><code>ca_ES</code>: Catalan - Spain</td>
<td><code>cs_CZ</code>: Czech - Czech Republic</td></tr>
<tr><td scope="row"><code>da_DK</code>: Danish - Denmark</td>
<td><code>de_AT</code>: German - Austria</td></tr>
<tr><td scope="row"><code>de_BE</code>: German - Belgium</td>
<td><code>de_CH</code>: German - Switzerland</td></tr>
<tr><td scope="row"><code>de_DE</code>: German - Germany</td>
<td><code>de_LU</code>: German - Luxembourg</td></tr>
<tr><td scope="row"><code>el_GR</code>: Greek - Greece</td>
<td><code>en_AU</code>: English - Australia</td></tr>
<tr><td scope="row"><code>en_CA</code>: English - Canada</td>
<td><code>en_GB</code>: English - United Kingdom</td></tr>
<tr><td scope="row"><code>en_IN</code>: English - India</td>
<td><code>en_NZ</code>: English - New Zealand</td></tr>
<tr><td scope="row"><code>en_PH</code>: English - Philippines</td>
<td><code>en_US</code>: English - United States</td></tr>
<tr><td scope="row"><code>en_ZA</code>: English - South Africa</td>
<td><code>en_ZW</code>: English - Zimbabwe</td></tr>
<tr><td scope="row"><code>es_AR</code>: Spanish - Argentina</td>
<td><code>es_BO</code>: Spanish - Bolivia</td></tr>
<tr><td scope="row"><code>es_CL</code>: Spanish - Chile</td>
<td><code>es_CO</code>: Spanish - Columbia</td></tr>
<tr><td scope="row"><code>es_CR</code>: Spanish - Costa Rica</td>
<td><code>es_DO</code>: Spanish - Dominican Republic</td></tr>
<tr><td scope="row"><code>es_EC</code>: Spanish - Ecuador</td>
<td><code>es_ES</code>: Spanish - Spain</td></tr>
<tr><td scope="row"><code>es_GT</code>: Spanish - Guatemala</td>
<td><code>es_HN</code>: Spanish - Honduras</td></tr>
<tr><td scope="row"><code>es_MX</code>: Spanish - Mexico</td>
<td><code>es_NI</code>: Spanish - Nicaragua</td></tr>
<tr><td scope="row"><code>es_PA</code>: Spanish - Panama</td>
<td><code>es_PE</code>: Spanish - Peru</td></tr>
<tr><td scope="row"><code>es_PR</code>: Spanish - Puerto Rico</td>
<td><code>es_PY</code>: Spanish - Paraguay</td></tr>
<tr><td scope="row"><code>es_SV</code>: Spanish - El Salvador</td>
<td><code>es_US</code>: Spanish - United States</td></tr>
<tr><td scope="row"><code>es_UY</code>: Spanish - Uruguay</td>
<td><code>es_VE</code>: Spanish - Venezuela</td></tr>
<tr><td scope="row"><code>et_EE</code>: Estonian - Estonia</td>
<td><code>eu_ES</code>: Basque - Basque</td></tr>
<tr><td scope="row"><code>fi_FI</code>: Finnish - Finland</td>
<td><code>fo_FO</code>: Faroese - Faroe Islands</td></tr>
<tr><td scope="row"><code>fr_BE</code>: French - Belgium</td>
<td><code>fr_CA</code>: French - Canada</td></tr>
<tr><td scope="row"><code>fr_CH</code>: French - Switzerland</td>
<td><code>fr_FR</code>: French - France</td></tr>
<tr><td scope="row"><code>fr_LU</code>: French - Luxembourg</td>
<td><code>gl_ES</code>: Galician - Spain</td></tr>
<tr><td scope="row"><code>gu_IN</code>: Gujarati - India</td>
<td><code>he_IL</code>: Hebrew - Israel</td></tr>
<tr><td scope="row"><code>hi_IN</code>: Hindi - India</td>
<td><code>hr_HR</code>: Croatian - Croatia</td></tr>
<tr><td scope="row"><code>hu_HU</code>: Hungarian - Hungary</td>
<td><code>id_ID</code>: Indonesian - Indonesia</td></tr>
<tr><td scope="row"><code>is_IS</code>: Icelandic - Iceland</td>
<td><code>it_CH</code>: Italian - Switzerland</td></tr>
<tr><td scope="row"><code>it_IT</code>: Italian - Italy</td>
<td><code>ja_JP</code>: Japanese - Japan</td></tr>
<tr><td scope="row"><code>ko_KR</code>: Korean - Republic of Korea</td>
<td><code>lt_LT</code>: Lithuanian - Lithuania</td></tr>
<tr><td scope="row"><code>lv_LV</code>: Latvian - Latvia</td>
<td><code>mk_MK</code>: Macedonian - FYROM</td></tr>
<tr><td scope="row"><code>mn_MN</code>: Mongolia - Mongolian</td>
<td><code>ms_MY</code>: Malay - Malaysia</td></tr>
<tr><td scope="row"><code>nb_NO</code>: Norwegian(Bokmц╔l) - Norway</td>
<td><code>nl_BE</code>: Dutch - Belgium</td></tr>
<tr><td scope="row"><code>nl_NL</code>: Dutch - The Netherlands</td>
<td><code>no_NO</code>: Norwegian - Norway</td></tr>
<tr><td scope="row"><code>pl_PL</code>: Polish - Poland</td>
<td><code>pt_BR</code>: Portugese - Brazil</td></tr>
<tr><td scope="row"><code>pt_PT</code>: Portugese - Portugal</td>
<td><code>rm_CH</code>: Romansh - Switzerland</td></tr>
<tr><td scope="row"><code>ro_RO</code>: Romanian - Romania</td>
<td><code>ru_RU</code>: Russian - Russia</td></tr>
<tr><td scope="row"><code>ru_UA</code>: Russian - Ukraine</td>
<td><code>sk_SK</code>: Slovak - Slovakia</td></tr>
<tr><td scope="row"><code>sl_SI</code>: Slovenian - Slovenia</td>
<td><code>sq_AL</code>: Albanian - Albania</td></tr>
<tr><td scope="row"><code>sr_RS</code>: Serbian - Yugoslavia</td>
<td><code>sv_FI</code>: Swedish - Finland</td></tr>
<tr><td scope="row"><code>sv_SE</code>: Swedish - Sweden</td>
<td><code>ta_IN</code>: Tamil - India</td></tr>
<tr><td scope="row"><code>te_IN</code>: Telugu - India</td>
<td><code>th_TH</code>: Thai - Thailand</td></tr>
<tr><td scope="row"><code>tr_TR</code>: Turkish - Turkey</td>
<td><code>uk_UA</code>: Ukrainian - Ukraine</td></tr>
<tr><td scope="row"><code>ur_PK</code>: Urdu - Pakistan</td>
<td><code>vi_VN</code>: Vietnamese - Viet Nam</td></tr>
<tr><td scope="row"><code>zh_CN</code>: Chinese - China</td>
<td><code>zh_HK</code>: Chinese - Hong Kong</td></tr>
<tr><td scope="row"><code>zh_TW</code>: Chinese - Taiwan Province of China
</td><td> </td></tr></tbody></table>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
