<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глоссарий MySQL</title>
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="glossary"></a>Глоссарий MySQL</h1>
<p>Эти термины обычно используются в информации о сервере базы данных MySQL.
Этот глоссарий порожден как ссылка для терминологии о механизме хранения
InnoDB и большинстве определений в MySQL.</p>

<h3>A</h3>
<dl><dt><a name="glos_arm_file"></a><span>Файл .ARM</span></dt>
<dd><p>Метаданные для таблиц ARCHIVE.
Файлы с этим расширением всегда включаются в резервные копии, произведенные
командой <code>mysqlbackup</code> пакета
<span><strong>MySQL Enterprise Backup</strong></span>.
Не путать с <span><strong>файлами .ARZ</strong></span>.</p>

<p>См. <a href="#glos_arz_file">Файлы .ARZ</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_mysqlbackup_command">mysqlbackup</a>.</dd>

<dt><a name="glos_arz_file"></a><span>Файл .ARZ</span></dt>
<dd><p>Не путать с <span><strong>файлами .ARM</strong></span>.
Данные для таблиц ARCHIVE. Файлы с этим расширением всегда включаются в
резервные копии, произведенные
командой <code>mysqlbackup</code> пакета
<span><strong>MySQL Enterprise Backup</strong></span>.</p>

<p>См. <a href="#glos_arm_file">Файлы .ARM</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_mysqlbackup_command">mysqlbackup</a>.</p>
</dd>

<dt><a name="glos_acid"></a><span>ACID</span></dt>
<dd><p>Сокращение для atomicity, consistency, isolation и durability.
Эти свойства все желательны в системе базы данных и близко связаны с понятием
<span><strong>транзакции</strong></span>. Транзакционые особенности
<code>InnoDB</code> придерживаются принципов ACID.</p>

<p>Транзакции это <span><strong>атомные</strong></span>
единицы работы, которые могут быть <span><strong>переданы</strong></span>
или <span><strong>отменены</strong></span>. Когда транзакция производит
многократные изменения в базе данных, все изменения преуспевают, когда
транзакция передана, или все изменения отменены,
когда транзакция оменена.</p>

<p>База данных остается в последовательном состоянии всегда
после каждой передачи или отмены и в то время, как транзакции происходят.
Если связанные данные обновляются через многократные таблицы, запросы видят
или все старые значения или все новые значения, но не соединение
старых и новых значений.</p>

<p>Транзакции защищены (изолированы) друг от друга в то время, как они
происходят: они не могут вмешаться друг в друга или видеть нейтральные данные
друг друга. Эта изоляция достигнута через механизм
<span><strong>блокировки</strong></span>. Опытные пользователи могут
скорректировать <span><strong>уровень изоляции</strong></span>,
балансируя между меньшим количеством защиты в пользу увеличенной работы и
<span><strong>параллелизма</strong></span>, когда они могут убедиться, что
транзакции действительно не вмешиваются друг в друга.</p>

<p>Результаты транзакций длительны: как только транзакция передана,
произведенные изменения защищены от перебоев в питании, системных
катастрофических отказов или других потенциальных опасностей. Длительность,
как правило, вовлекает запись на диск с определенным количеством
избыточности, чтобы защитить от перебоев в питании или катастрофических
отказов программного обеспечения. В <code>InnoDB</code> этому способствует
<span><strong>буфер doublewrite</strong></span>.</p>

<p>См. <a href="#glos_atomic">atomic</a>,
<a href="#glos_commit">commit</a>,
<a href="#glos_concurrency">concurrency</a>,
<a href="#glos_doublewrite_buffer">doublewrite buffer</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_adaptive_flushing"></a><span>Адаптивный сброс</span></dt>
<dd><p>Алгоритм для <span><strong>InnoDB</strong></span>, который сглаживает
скачки ввода/вывода из-за <span><strong>контрольных точек</strong></span>.
Вместо того, чтобы <span><strong>сбросить</strong></span> все измененные
<span><strong>страницы</strong></span> из
<span><strong>буферного пула</strong></span> в
<span><strong>файлы данных</strong></span> сразу, MySQL
периодически сбрасывает маленькие наборы измененных страниц. Адаптивный
алгоритм расширяет этот процесс, оценивая оптимальный уровень этих
периодических сбросов, основанный на уровне сброса вообще и том, как быстро
произведена информация <span><strong>redo</strong></span>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_checkpoint">checkpoint</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_page">page</a>,
<a href="#glos_redo_log">redo log</a>.</dd>

<dt><a name="glos_adaptive_hash_index"></a><span>
Адаптивный хеш-индекс</span></dt>
<dd><p>Оптимизация для <code>InnoDB</code>, которая может ускорить
использование поисков <code>=</code> и <code>IN</code>, создавая
<span><strong>хеш-индекс</strong></span> в памяти. MySQL отслеживает
индексные поиски для <code>InnoDB</code>
и если запросы могли бы извлечь выгоду из хеш-индекса,
создает его автоматически для индексных страниц,
к которым часто получают доступ. В некотором смысле адаптивный хеш
конфигурирует MySQL во время выполнения, чтобы использовать в своих интересах
вполне достаточную основную память. Этой особенностью управляет опция
<a href="innodb.htm#sysvar_innodb_adaptive_hash_index"><code>
innodb_adaptive_hash_index</code></a>. Поскольку эта особенность приносит
пользу лишь некоторым рабочим нагрузкам, но не другим, а память, используемая
для хеша, индексирует, сохранена в <span><strong>буферном пуле</strong>
</span>, как правило, Вы должны определить эффективность с этой
опцией, включенной и отключенной.</p>

<p>Хеш-индекс всегда создается основанный на существующем
<span><strong>вторичном индексе</strong></span> <code>InnoDB</code>,
который организован как <span><strong>B-tree</strong></span>.
MySQL может создать хеш-индекс на префиксе любой длины ключа, определенного
для B-дерева, в зависимости от образца поисков по индексу. Хеш-индекс может
быть частичным: целое B-дерево не должно кэшироваться в буферном пуле.</p>

<p>В MySQL 5.6 и выше другой способ использовать в своих интересах быстрые
поиски единственного значения с <code>InnoDB</code> это использовать плагин
<code>InnoDB</code> <span><strong>memcached</strong></span>, см.
<a href="innodb.htm#innodb-memcached">раздел 16.19</a>.</p>

<p>См. <a href="#glos_b_tree">B-tree</a>,
<a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_hash_index">hash index</a>,
<a href="#glos_memcached">memcached</a>,
<a href="#glos_page">page</a>,
<a href="#glos_secondary_index">secondary index</a>.</dd>

<dt><a name="glos_ahi"></a><span>AHI</span></dt>
<dd><p>Сокращение от <span><strong>adaptive hash index</strong></span>.</p>
<p>См. <a href="#glos_adaptive_hash_index">adaptive hash index
</a>.</dd>

<dt><a name="glos_aio"></a><span>AIO</span></dt>
<dd><p>Сокращение от <span><strong>asynchronous I/O</strong></span>.
Вы могли бы видеть этот акроним в сообщениях или
ключевых словах <code>InnoDB</code>.</p>
<p>См. <a href="#glos_asynchronous_io">asynchronous I/O</a>.</dd>

<dt><a name="glos_application_programming_interface"></a><span>
application programming interface (API)</span></dt>
<dd><p>Ряд функций или процедур. API обеспечивает устойчивый набор имен и
типов для функций, процедур, параметров и возвращаемых значений.</dd>

<dt><a name="glos_apply"></a><span>Применение</span></dt>
<dd><p>Когда резервное копирование, произведенное <span><strong>MySQL
Enterprise Backup</strong></span>, не включает новые изменения, которые
произошли, в то время как резервное копирование было в стадии реализации,
процесс обновления резервных файлов, чтобы включить те изменения, известен
как <span><strong>применение</strong></span>. Это определено опцией
<code>apply-log</code> команды <code>mysqlbackup</code>.</p>

<p>Прежде, чем изменения применены, мы именуем файлы как
<span><strong>сырое резервное копирование</strong></span>.
После того, как изменения применены, мы именуем файлы как
<span><strong>готовое резервное копирование</strong></span>.
Изменения зарегистрированы в файле <span><strong>ibbackup_logfile</strong>
</span>, как только шаг применения закончен, этот файл
больше не необходим.</p>

<p>См. <a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_ibbackup_logfile">ibbackup_logfile</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_prepared_backup">prepared backup</a>,
<a href="#glos_raw_backup">raw backup</a>.</dd>

<dt><a name="glos_asynchronous_io"></a><span>асинхронный ввод/вывод
</span></dt>
<dd><p>Тип работы ввода/вывода, которая позволяет другой обработке
продолжаться перед завершением ввода/вывода. Также известный как
<span><strong>неблокирующий ввод/вывод</strong></span> и
<span><strong>AIO</strong></span>. <code>InnoDB</code>
использует этот тип ввода/вывода для определенных операций, которые могут
работать параллельно, не затрагивая надежность базы данных, таких как чтение
страниц в <span><strong>буферный пул</strong></span>,
которые фактически не требуются, но могут скоро быть необходимы.</p>

<p>Исторически <code>InnoDB</code> использует
асинхронный ввод/вывод только в системах Windows.
Начиная с InnoDB Plugin 1.1 и MySQL 5.5 <code>InnoDB</code>
использует асинхронный ввод/вывод на системах Linux. Это изменение вводит
зависимость от <code>libaio</code>. Асинхронный ввод/вывод на системах Linux
сконфигурирован, используя опцию
<a href="innodb.htm#sysvar_innodb_use_native_aio"><code>innodb_use_native_aio
</code></a>, которая включена по умолчанию. На других Unix-системах InnoDB
использует только синхронный ввод/вывод.</p>
<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_non_blocking_io">non-blocking I/O</a>.</dd>

<dt><a name="glos_atomic"></a><span>Атомный</span></dt>
<dd><p>В SQL <span><strong>транзакции</strong></span> это
единицы работы, которые сделаны полностью (когда <span><strong>переданы
</strong></span>) или не имеют никакого эффекта вообще (когда
<span><strong>отменены</strong></span>). Неделимое ("атомное") свойство
транзакций это "A" в сокращении <span><strong>ACID</strong></span>.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_commit">commit</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_atomic_instruction"></a><span>Атомная инструкция</span></dt>
<dd><p>Специальные инструкции, обеспеченные центральным процессором, чтобы
гарантировать, что критические низкоуровневые операции не
могут быть прерваны.</dd>

<dt><a name="glos_auto_increment"></a><span>auto-increment</span></dt>
<dd><p>Свойство столбца таблицы (определенное ключевым словом
<code>AUTO_INCREMENT</code>), которое автоматически добавляет
последовательность возрастания значений в столбце. <code>InnoDB</code>
поддерживает auto-increment только для столбцов
<span><strong>primary key</strong></span>.</p>

<p>Это экономит работу разработчика, чтобы не надо было произвести новые
уникальные значения, вставляя новые строки. Это обеспечивает полезную
информацию для оптимизатора запроса, потому что столбец, как известно,
является не нулем и с уникальными значениями. Значения такого столбца могут
использоваться в качестве ключей поиска в различных контекстах, и потому что
они самозарождены нет никакой причины когда-либо изменить их, по этой причине
столбцы первичного ключа часто определяются как auto-increment.</p>

<p>Auto-increment могут быть проблематичными с основанной на запросе
репликацией, потому что переигрывание запросов на ведомом устройстве не могло
бы произвести тот же самый набор значений столбцов, как на ведущем
устройстве, из-за проблем синхронизации. Когда у Вас есть auto-increment
первичный ключ, Вы можете использовать основанную на запросе репликацию
только с установкой <a href="innodb.htm#sysvar_innodb_autoinc_lock_mode">
<code>innodb_autoinc_lock_mode=1</code></a>. Если
<code>innodb_autoinc_lock_mode=2</code>, что позволяет более высокий
параллелизм для операций вставки, используйте
<span><strong>основанную на строке</strong></span> репликацию вместо
<span><strong>основанной на запросе</strong></span>.
<code>innodb_autoinc_lock_mode=0</code> это предыдущая (традиционная)
настройка по умолчанию и не должна использоваться за
исключением целей совместимости.</p>

<p>См. <a href="#glos_auto_increment_locking">auto-increment
locking</a>,
<a href="#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode
</a>, <a href="#glos_primary_key">primary key</a>,
<a href="#glos_row_based_replication">row-based replication</a>,
<a href="#glos_statement_based_replication">
statement-based replication</a>.</dd>

<dt><a name="glos_auto_increment_locking"></a><span>Блокировка auto-increment
</span></dt>
<dd><p>Удобство первичного ключа <span><strong>auto-increment</strong></span>
вовлекает некоторые пргоблемы с параллелизмом. В самом простом случае, если
одна транзакция вставляет значения в таблицу, любые другие транзакции должны
ждать, чтобы сделать их собственные вставки в ту таблицу так, чтобы строки,
вставленные первой транзакцией, получили последовательные значения первичного
ключа. <code>InnoDB</code> включает оптимизацию и опцию
<a href="innodb.htm#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a>, чтобы Вы могли выбрать, как
балансировать между предсказуемыми последовательностями значений
автоинкремента и максимального <span><strong>параллелизма</strong></span>
для операций вставки.</p>

<p>См. <a href="#glos_auto_increment">auto-increment</a>,
<a href="#glos_concurrency">concurrency</a>,
<a href="#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode
</a>.</dd>

<dt><a name="glos_autocommit"></a><span>autocommit</span></dt>
<dd><p>Установка, которая вызывает <span><strong>передачу</strong></span>
после каждого запроса <span><strong>SQL</strong></span>. Этот режим не
рекомендуется для того, чтобы работать с
<code>InnoDB</code> с <span><strong>транзакциями</strong></span> из
нескольких запросов. Это может помочь работе для
<span><strong>транзакций только для чтения</strong></span> в
<code>InnoDB</code>, где это минимизирует издержки
<span><strong>блокировки</strong></span> и производства данных
<span><strong>об отмене</strong></span>, особенно в MySQL 5.6.4 и выше.
Это также подходяще для работы с
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>,
где транзакции неприменимы.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_read_only_transaction">read-only transaction</a>,
<a href="#glos_sql">SQL</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_undo">undo</a>.</dd>

<dt><a name="glos_availability"></a><span>Доступность</span></dt>
<dd><p>Способность справиться и в случае необходимости оправиться от отказа
на узле, включая отказы MySQL, операционной системы или аппаратных средств и
деятельности обслуживания, которая может иначе вызвать время простоя.
Часто соединяемая с <span><strong>масштабируемостью</strong></span>,
как критические аспекты крупномасштабного развертывания.</p>
<p>См. <a href="#glos_scalability">scalability</a>.</p></dd></dl>

<h3>B</h3>
<dl><dt><a name="glos_b_tree"></a><span>B-tree</span></dt>
<dd><p>Структура данных дерева, которая популярна для использования в базе
данных. Структура сохранена сортированной всегда, включая быстрый поиск для
точных совпадений (равняется оператору) и диапазона (например, больше чем,
меньше чем и <code>BETWEEN</code>). Этот тип индекса
доступен для большинства механизмов хранения, например,
<a href="innodb.htm"><code>InnoDB</code></a> и
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>.</p>

<p>Поскольку у узлов B-дерева может быть много дочерних элементов, B-дерево
не то же самое, как двоичное дерево, которое ограничено 2 дочерними
элементами на узел.</p>

<p>Отличается <span><strong>hash index</strong></span>, который доступен
только в <a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>.
Механизм хранения <code>MEMORY</code> может также использовать B-дерево,
и Вы должны выбрать B-дерево для таблицы <code>MEMORY</code>, если некоторые
запросы используют операторы диапазона.</p>

<p>Использование термина B-дерево предназначено как ссылка на общий класс
индексов. B-древовидные-структуры, используемые механизмами хранения MySQL,
могут быть расценены как разновидности из-за изощренности, не существующей в
классическом проекте B-дерева. Для соответствующей информации обратитесь к
разделу <code>InnoDB</code> Page Structure
<a href="../../../https@dev.mysql.com/doc/internals/en/innodb-fil-header.html"
target="_top">Fil Header</a> в
<a href="../../../https@dev.mysql.com/doc/internals/en/index.html" target="_top">
MySQL Internals Manual</a>.</p>
<p>См. <a href="#glos_hash_index">hash index</a>.</dd>

<dt><a name="glos_backticks"></a><span>Обратные кавычки</span></dt>
<dd><p>Идентификаторы в пределах запроса SQL должны быть заключены в кавычки,
используя символ обратной кавычки (<code>`</code>), если они содержат
специальные символы или зарезервированные слова. Например, чтобы обратиться к
таблице <code>FOO#BAR</code> или столбцу <code>SELECT</code>,
Вы определили бы идентификаторы как <code>`FOO#BAR`</code> и
<code>`SELECT`</code>. Так как обратные кавычки обеспечивают дополнительный
уровень безопасности, они используются в произведенных программой запросах
SQL, где имена идентификатора не могли бы быть известны заранее.</p>

<p>Много других систем базы данных используют двойные кавычки
(<code>"</code>) вокруг таких специальных имен. Для мобильности Вы можете
включить режим <code>ANSI_QUOTES</code> в MySQL и использовать двойные
кавычки вместо обратных, чтобы квалифицировать имена идентификатора.</p>
<p>См. <a href="#glos_sql">SQL</a>.</dd>

<dt><a name="glos_backup"></a><span>Резервное копирование</span></dt>
<dd><p>Процесс копирования некоторых или всех табличных данных и
метаданных от экземпляра MySQL для сохранности. Может также обратиться к
набору скопированных файлов. Это решающая задача для DBA.</p>

<p>В MySQL <span><strong>физические резервные копии</strong></span>
выполнены <span><strong>MySQL Enterprise Backup</strong></span> и
<span><strong>логические резервные копии</strong></span> командой
<code>mysqldump</code>. У этих методов есть различные характеристики с точки
зрения размера и представления резервных данных и скорости
(особенно скорости работы восстановления).</p>

<p>Резервные копии далее классифицированы как
<span><strong>горячие</strong></span>,
<span><strong>теплые</strong></span> или
<span><strong>холодные</strong></span> в зависимости от того, насколько они
вмешиваются в нормальную работу базы данных. У горячих резервных копий есть
наименьшее количество вмешательства.</p>

<p>См. <a href="#glos_cold_backup">cold backup</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_logical_backup">logical backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_mysqldump">mysqldump</a>,
<a href="#glos_physical_backup">physical backup</a>,
<a href="#glos_warm_backup">warm backup</a>.</dd>

<dt><a name="glos_base_column"></a><span>Основной столбец</span></dt>
<dd><p>Непроизведенный столбец таблицы, на котором базируется произведенный
сохраненный столбец или произведенный виртуальный столбец. Другими словами,
основной столбец это непроизведенный столбец таблицы, который является частью
определения произведенного столбца.</p>

<p>См. <a href="#glos_generated_column">generated column</a>,
<a href="#glos_generated_stored_column">generated stored column
</a>, <a href="#glos_generated_virtual_column">
generated virtual column</a>.</dd>

<dt><a name="glos_beta"></a><span>beta</span></dt>
<dd><p>Ранняя стадия в жизни программного продукта, когда это доступно только
для оценки, как правило, без определенного номера выпуска или числа меньше 1.
<code>InnoDB</code> не использует бета обозначение, предпочитая фазу
<span><strong>раннего последователя</strong></span>, которая может расширить
более, чем несколько доработанных версий,
приводя к выпуску <span><strong>GA</strong></span>.</p>
<p>См. <a href="#glos_early_adopter">early adopter</a>,
<a href="#glos_ga">GA</a>.</dd>

<dt><a name="glos_binary_log"></a><span>Двоичный журнал</span></dt>
<dd><p>Файл, содержащий отчет всех запросов, которые пытаются изменить
табличные данные. Эти запросы могут быть переиграны, чтобы
осовременить ведомые серверы в <span><strong>репликации</strong></span>
или осовременить базу данных после восстановления табличных данных из
резервной копии. Двоичное журналирование может быть выключено, хотя Oracle
всегда рекомендует включать, если Вы используете репликацию или
выполняете резервные копии.</p>

<p>Вы можете исследовать содержание журнала или переиграть те запросы
при использовании <a href="programs.htm#mysqlbinlog"><span><strong>
mysqlbinlog</strong></span></a>. См. <a href="server.htm#binary-log">раздел
6.4.4</a>. Для полной информации о журнале см.
<a href="replica.htm#replication-options-binary-log">раздел 19.1.6.4</a>.
</p>

<p>Для <span><strong>MySQL Enterprise Backup</strong></span>
имя файла двоичного журнала и текущяя позиция в пределах файла это важные
детали. Чтобы сделать запись этой информации для главного сервера, беря
резервное копирование в контексте репликации, Вы можете определить
опцию <code>--slave-info</code>.</p>

<p>До MySQL 5.0 подобная способность была известна как журнал обновления.
В MySQL 5.0 и выше двоичный журнал заменяет журнал обновления.</p>
<p>См. <a href="#glos_binlog">binlog</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_replication">replication</a>.</dd>

<dt><a name="glos_binlog"></a><span>binlog</span></dt>
<dd><p>Неофициальное название файла <span><strong>двоичного журнала</strong>
</span>. Например, Вы могли бы видеть это сокращение, используемое в
обсуждениях на форуме или электронных письмах.</p>
<p>См. <a href="#glos_binary_log">binary log</a>.</dd>

<dt><a name="glos_blind_query_expansion"></a><span>Расширение запроса
</span></dt>
<dd><p>Специальный режим <span><strong>полнотекстового поиска</strong></span>,
включенного <code>WITH QUERY EXPANSION</code>. Это выполняет поиск дважды,
где фраза поиска для второго поиска это оригинальная фраза поиска, связанная
с немногими наиболее очень соответствующими документами от первого поиска.
Этот метод главным образом применим для коротких фраз поиска, возможно,
только отдельное слово. Это может раскрыть соответствия, где точный критерий
поиска не происходит в документе.</p>
<p>См. <a href="#glos_full_text_search">full-text search</a>.</dd>

<dt><a name="glos_bottleneck"></a><span>Узкое место</span></dt>
<dd><p>Часть системы, которая ограничена в размере или способности, которая
имеет эффект ограничения полной пропускной способности. Например, область
памяти могла бы быть меньшей, чем необходимо, доступ к единственному
необходимому ресурсу мог бы препятствовать тому, чтобы многие ядра
центрального процессора работали одновременно или ожидание дискового
ввода/вывода могло бы препятствовать тому, чтобы центральный процессор
работал на полную мощность. Удаление узких мест имеет тенденцию улучшать
<span><strong>параллелизм</strong></span>. Например, способность иметь много
копий <span><strong>буферного пула</strong></span> в <code>InnoDB</code>
уменьшает проблемы, когда многократные сеансы читают и пишут одновременно.
</p>
<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_concurrency">concurrency</a>.</dd>

<dt><a name="glos_bounce"></a><span>Возврат</span></dt>
<dd><p>Операция <span><strong>shutdown</strong></span> немедленно вызывает
перезапуск. Идеально с относительно коротким периодом
<span><strong>разминки</strong></span> так, чтобы работа и пропускная
способность быстро возвратились к высокому уровню.</p>
<p>См. <a href="#glos_shutdown">shutdown</a>.</dd>

<dt><a name="glos_buddy_allocator"></a><span>Распределитель</span></dt>
<dd><p>Механизм для того, чтобы управлять разного размера
<span><strong>страницами</strong></span> в
<span><strong>буферном пуле</strong></span> InnoDB.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_page">page</a>,
<a href="#glos_page_size">page size</a>.</dd>

<dt><a name="glos_buffer"></a><span>Буфер</span></dt>
<dd><p>Память или дисковая область для временного хранения.
Данные буферизованы в памяти так, чтобы это могло быть написано на диск
эффективно, несколькими большими операциями ввода/вывода, а не многими
маленькими. Данные буферизованы на диске для большей надежности, чтобы это
могло быть восстановлено, даже когда <span><strong>катастрофический отказ
</strong></span> или другой отказ происходят в худшее время. Основные типы
буферов, используемых InnoDB, это <span><strong>буферный пул</strong></span>,
<span><strong>буфер doublewrite</strong>
</span> и <span><strong>буфер изменения</strong></span>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_crash">crash</a>,
<a href="#glos_doublewrite_buffer">doublewrite buffer</a>.</dd>

<dt><a name="glos_buffer_pool"></a><span>Буферный пул</span></dt>
<dd><p>Область памяти, которая хранит кэшируемые <code>InnoDB</code>
данные для таблиц и индексов. Для эффективности большого объема операций
чтения буферный пул разделен на <span><strong>страницы</strong></span>,
которые могут потенциально содержать много строк. Для эффективности
управления кэшем буферный пул осуществлен как связанный список страниц,
данные, которые редко используются, удалены из кэша, используя версию
алгоритма <span><strong>LRU</strong></span>. На системах с большой памятью Вы
можете улучшить параллелизм, деля буферный пул на много экземпляров.</p>

<p>Несколько переменных состояния <code>InnoDB</code>, таблиц
<code>information_schema</code> и <code>performance_schema</code>
помогают контролировать внутренние работы буферного пула. Начиная с MySQL
5.6, Вы можете избежать длинного периода разминки после перезапуска сервера,
особенно для случаев с большими буферными пулами, сохраняя состояние
буферного пула при завершении работы сервера и восстанавливая буферный пул в
то же самое состояние при запуске сервера. См.
<a href="innodb.htm#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</p>

<p>См. <a href="#glos_buffer_pool_instance">buffer pool instance
</a>, <a href="#glos_lru">LRU</a>,
<a href="#glos_page">page</a>,
<a href="#glos_warm_up">warm up</a>.</dd>

<dt><a name="glos_buffer_pool_instance"></a><span>Экземпляр буферного пула
</span></dt>
<dd><p>Любая из многих областей, на которые
<span><strong>буферный пул</strong></span> может быть разделен, управляя
параметром конфигурации <a href="innodb.htm#sysvar_innodb_buffer_pool_instances">
<code>innodb_buffer_pool_instances</code></a>. Полный размер памяти,
определенный <a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> разделен среди всех буферных экземпляров.
Как правило, наличие многократных буферных пулов
является подходящим для систем, которые выделяют много гигабайт для
буферного пула <code>InnoDB</code>. При системной загрузке или поиске больших
объемов данных в буферном бассейне от многих параллельных сеансов, наличие
многократных буферных пулов уменьшает издержки для эксклюзивного доступа к
структурам данных, которые управляют буферным пулом.</p>
<p>См. <a href="#glos_buffer_pool">buffer pool</a>.</dd>

<dt><a name="glos_built_in"></a><span>Встроенный</span></dt>
<dd><p>Встроенный механизм хранения <code>InnoDB</code> в пределах MySQL это
оригинальная форма распределения для механизма хранения. Не путать с
<span><strong>InnoDB Plugin</strong></span>. Начиная с MySQL 5.5, InnoDB
Plugin слит назад в кодовую базу MySQL как встроенный механизм хранения
(известный как InnoDB 1.1).</p>

<p>Это различие важно, главным образом, в MySQL 5.1, где особенность или
исправление ошибки могли бы относиться к InnoDB Plugin, но не к
встроенному <code>InnoDB</code>.</p>
<p>См. <a href="#glos_innodb">InnoDB</a>,
<a href="#glos_plugin">plugin</a>.</dd>

<dt><a name="glos_business_rules"></a><span>Транзакционные правила</span></dt>
<dd><p>Отношения и последовательности действий, которые формируют основание
программного обеспечения для бизнеса, чтобы выполнять коммерческую компанию.
Иногда эти правила диктует закон, другие определены политикой компании.
Осторожное планирование гарантирует, что отношения, закодированные и
проведенные в жизнь базой данных, и действиями, выполненными через логику
приложения, точно отражают реальную политику компании и могут
обработать реальные ситуации.</p>

<p>Например, служащий, покидающий компанию, мог бы вызвать последовательность
действий отдела человеческих ресурсов. Базе данных человеческих ресурсов,
возможно, также понадобилась бы гибкость, чтобы представить данные о
человеке, который был нанят, но еще не начал работу. Закрытие учетной записи
в службе онлайн могло бы привести к данным, удаляемым из базы данных, или
данные могли бы быть перемещены или отмечены так, чтобы это могло быть
восстановлено, если учетная запись вновь открыта. Компания могла бы
установить политику относительно максимумов зарплаты, минимумов и
корректировок, в дополнение к основным проверкам, таким как зарплата, не
являющаяся отрицательным числом. Розничная база данных не могла бы позволить
покупке с тем же самым порядковым номером быть возвращенной не раз, или не
могла бы позволить покупки по кредитной карте выше определенного значения
в то время, как база данных, используемая, чтобы обнаружить мошенничество,
могла бы позволить эти виды вещей.</p>
<p>См. <a href="#glos_relational">relational</a>.</p></dd></dl>

<h3>C</h3>
<dl><dt><a name="glos_cfg_file"></a><span>Файл .cfg</span></dt>
<dd><p>Метафайл с данными, используемый с <code>InnoDB</code>
<span><strong>переносным табличным пространством</strong></span>.
Это произведено командой <code>FLUSH TABLES ... FOR EXPORT</code>,
которая помещает одну или более таблиц в последовательное состояние, которое
может быть скопировано к другому серверу. Файл <code>.cfg</code>
скопирован наряду с соответствующим <span><strong>файлом .ibd</strong></span>
и используется, чтобы скорректировать внутренние значения файла
<code>.ibd</code>, например, <span><strong>space ID</strong></span>, во время
<code>ALTER TABLE ... IMPORT TABLESPACE</code>.</p>

<p>См. <a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_space_id">space ID</a>,
<a href="#glos_transportable_tablespace">transportable tablespace
</a>.</dd>

<dt><a name="glos_cache"></a><span>Кэш</span></dt>
<dd><p>Общий термин для любой области памяти, которая хранит копии данных
для частого или высокоскоростного извлечения. В <code>InnoDB</code> основной
вид структуры кэша это <span><strong>буферный пул</strong></span>.</p>
<p>См. <a href="#glos_buffer">buffer</a>,
<a href="#glos_buffer_pool">buffer pool</a>.</dd>

<dt><a name="glos_cardinality"></a><span>Количество элементов</span></dt>
<dd><p>Число различных значений в столбце таблицы.
Когда запросы обращаются к столбцам, у которых есть связанный
<span><strong>индекс</strong></span>, количество элементов каждого столбца
влияет на то, какой метод доступа является самым эффективным. Например, для
столбца с <span><strong>уникальным ограничением</strong></span>,
число различных значений равно числу строк в таблице. Если у таблицы есть
миллион строк, но только 10 различных значений для особого столбца, каждое
значение происходит (в среднем) 100000 раз. Такой запрос, как
<code>SELECT c1 FROM t1 WHERE c1 = 50;</code>, мог бы возвратить 1 строку или
огромное число строк, и сервер базы данных мог бы обработать запрос
по-другому в зависимости от количества элементов <code>c1</code>.</p>

<p>Если у значений в столбце есть очень неравное распределение, количество
элементов не могло бы быть хорошим способом определить лучший план запроса.
Например, <code>SELECT c1 FROM t1 WHERE c1 = x;</code>
мог бы возвратить 1 строку, когда <code>x=50</code>, и миллион строк, когда
<code>x=30</code>. В таком случае Вы, возможно, должны были бы использовать
<span><strong>индексные подсказки</strong></span>, чтобы провести совет,
который метод поиска более эффективен для особого запроса.</p>

<p>Количество элементов может также относиться к числу отличных значений,
существующих в многих столбцах, как в
<span><strong>сводном индексе</strong></span>.</p>

<p>См. <a href="#glos_column">column</a>,
<a href="#glos_composite_index">composite index</a>,
<a href="#glos_index">index</a>,
<a href="#glos_index_hint">index hint</a>,
<a href="#glos_persistent_statistics">persistent statistics</a>,
<a href="#glos_random_dive">random dive</a>,
<a href="#glos_selectivity">selectivity</a>,
<a href="#glos_unique_constraint">unique constraint</a>.</dd>

<dt><a name="glos_change_buffer"></a><span>Буфер изменения</span></dt>
<dd><p>Специальная структура данных, которая делает запись изменений
<span><strong>страниц</strong></span> во
<span><strong>вторичных индексах</strong></span>.
Эти значения могли следовать из SQL-запросов
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>
(<span><strong>DML</strong></span>). Набор особенностей, вовлекающих буфер
изменения, известен как <span><strong>буферизация изменения</strong></span>,
состоящая из <span><strong>буферизации вставки</strong></span>,
<span><strong>буферизации удаления</strong></span> и
<span><strong>буферизации очистки</strong></span>.</p>

<p>Изменения зарегистрированы в буфере изменения, только когда
соответствующая страница от вторичного индекса не находится в
<span><strong>буферном пуле</strong></span>. Когда соответствующая индексная
страница принесена в буферный пул в то время, как связанные изменения
находятся все еще в буфере изменения, изменения для той страницы применены в
буферном пуле, используя данные от буфера изменения. Периодически работа
<span><strong>очистки</strong></span>, которая работает в течение времени,
когда система главным образом неактивна, или во время медленного завершения
работы, пишет новые индексные страницы на диск. Работа чистки может написать
дисковые блоки для серии индексных значений более эффективно, чем если бы
каждое значение было немедленно написано на диск.</p>

<p>Физически, буфер изменения это часть
<span><strong>системного табличного пространства</strong></span>,
так что индексные изменения остаются буферизованными через перезапуски базы
данных. Изменения применены, только когда страницы принесены в буферный пул
из-за некоторой другой работы чтения.</p>

<p>Видами и объемом данных, сохраненных в буфере изменения, управляют опции
<a href="innodb.htm#sysvar_innodb_change_buffering"><code>
innodb_change_buffering</code></a> и
<a href="innodb.htm#sysvar_innodb_change_buffer_max_size"><code>
innodb_change_buffer_max_size</code></a>.
Чтобы видеть информацию о текущих данных в буфере изменения, используйте
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.</p>

<p>Прежде известен как <span><strong>буфер вставки</strong></span>.</p>
<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_change_buffering">change buffering</a>,
<a href="#glos_delete_buffering">delete buffering</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_insert_buffer">insert buffer</a>,
<a href="#glos_insert_buffering">insert buffering</a>,
<a href="#glos_merge">merge</a>,
<a href="#glos_page">page</a>,
<a href="#glos_purge">purge</a>,
<a href="#glos_purge_buffering">purge buffering</a>,
<a href="#glos_secondary_index">secondary index</a>,
<a href="#glos_system_tablespace">system tablespace</a>.</dd>

<dt><a name="glos_change_buffering"></a><span>Буферизация изменения</span>
</dt><dd><p>Общий термин для особенностей, вовлекающих <span><strong>буфер
изменения</strong></span>, состоящих из
<span><strong>буферизации вставки</strong></span>,
<span><strong>буферизации удаления</strong></span> и
<span><strong>буферизации очистки</strong></span>.
Индексные изменения, следующие из запросов SQL, которые могли обычно
вовлекать случайные операции ввода/вывода, задержаны и периодически
выполняются фоновым <span><strong>потоком</strong></span>. Эта
последовательность операций может написать дисковые блоки для серии
индексных значений более эффективно, чем если бы каждое значение было
немедленно написано. Управляется опциями
<a href="innodb.htm#sysvar_innodb_change_buffering"><code>
innodb_change_buffering</code></a> и
<a href="innodb.htm#sysvar_innodb_change_buffer_max_size"><code>
innodb_change_buffer_max_size</code></a>.</p>

<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_delete_buffering">delete buffering</a>,
<a href="#glos_insert_buffering">insert buffering</a>,
<a href="#glos_purge_buffering">purge buffering</a>.</dd>

<dt><a name="glos_checkpoint"></a><span>Контрольная точка</span></dt>
<dd><p>Поскольку изменения произведены в страницах данных, которые кэшируются
в <span><strong>буферном пуле</strong></span>, те изменения написаны в
<span><strong>файлы данных</strong></span> когда-то позже, выполняется
процесс, известный как <span><strong>сброс</strong></span>.
Контрольная точка это отчет последних изменений (представленный значением
<span><strong>LSN</strong></span>) которые были успешно
записаны в файлы с данными.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_fuzzy_checkpointing">fuzzy checkpointing</a>,
<a href="#glos_lsn">LSN</a>.</dd>

<dt><a name="glos_checksum"></a><span>Контрольная сумма</span></dt>
<dd><p>В <code>InnoDB</code> механизм проверки допустимости, чтобы обнаружить
повреждение, когда <span><strong>страница</strong></span> в
<span><strong>табличном пространстве</strong></span> считана с диска в
<span><strong>буферный пул</strong></span> <code>InnoDB</code>.
Этой особенностью управляет опция
<a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_checksums"
target="_top"><code>innodb_checksums</code></a> в MySQL 5.5.
<a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_checksums"
target="_top"><code>innodb_checksums</code></a> устарела в MySQL 5.6.3 и
заменена <a href="innodb.htm#sysvar_innodb_checksum_algorithm"><code>
innodb_checksum_algorithm</code></a>.</p>

<p><a href="programs.htm#innochecksum"><span><strong>innochecksum</strong>
</span></a> помогает диагностировать проблемы повреждения, проверяя значения
контрольной суммы указанного файла <span><strong>табличного пространства
</strong></span> в то время, как сервер MySQL закрыт.</p>

<p>MySQL также использует контрольные суммы в целях репликации, см. опции
<a href="replica.htm#sysvar_binlog_checksum"><code>binlog_checksum</code>
</a>, <a href="replica.htm#sysvar_master_verify_checksum"><code>
master_verify_checksum</code></a> и
<a href="replica.htm#sysvar_slave_sql_verify_checksum"><code>
slave_sql_verify_checksum</code></a>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_page">page</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_child_table"></a><span>Дочерняя таблица</span></dt>
<dd><p>В отношениях <span><strong>внешнего ключа</strong></span>
дочерняя таблица это та, строки которой относятся к строкам в другой таблице
с идентичным значением для определенного столбца. Это таблица, которая
содержит <code>FOREIGN KEY ... REFERENCES</code> и опционально
<code>ON UPDATE</code> и <code>ON DELETE</code>. Соответствующая строка в
<span><strong>родительской таблице</strong></span>
должна существовать прежде, чем строка может быть создана в дочерней таблице.
Значения в дочерней таблице могут предотвратить операции удаления или
обновления на родительской таблице или может вызвать автоматическое удаление
или обновления в дочерней таблице, основанной на опции
<code>ON CASCADE</code>, создавая внешний ключ.</p>
<p>См. <a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_parent_table">parent table</a>.</dd>

<dt><a name="glos_clean_page"></a><span>Чистая страница</span></dt>
<dd><p><span><strong>Страница</strong></span> в <span><strong>буферном пуле
</strong></span> <code>InnoDB</code>, где все изменения, произведенные в
памяти, были также написаны в <a href="#glos_data_files">файлы
данных</a>. Противоположность <span><strong>грязной страницы</strong></span>.
</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_clean_shutdown"></a><span>Чистое завершение работы
</span></dt>
<dd><p><span><strong>Завершение работы</strong></span>, которое завершается
без ошибок и применяет все изменения таблиц <code>InnoDB</code> перед
окончанием, в противоположность <span><strong>катастрофическому отказу
</strong></span> или <span><strong>быстрому завершению работы</strong>
</span>. Синоним для <span><strong>медленного завершения работы</strong>
</span>.</p>

<p>См. <a href="#glos_crash">crash</a>,
<a href="#glos_fast_shutdown">fast shutdown</a>,
<a href="#glos_shutdown">shutdown</a>,
<a href="#glos_slow_shutdown">slow shutdown</a>.</dd>

<dt><a name="glos_client"></a><span>Клиент</span></dt>
<dd><p>Тип программы, которая посылает запросы в
<span><strong>сервер</strong></span> и интерпретирует или обрабатывает
результаты. Клиентское программное обеспечение могло бы выполняться только
часть времени (например, почта или программа чата) или работать в
интерактивном режиме (например, процессор команд
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>).</p>
<p>См. <a href="#glos_mysql">mysql</a>,
<a href="#glos_server">server</a>.</dd>

<dt><a name="glos_clustered_index"></a><span>Кластеризуемый индекс</span></dt>
<dd><p>Термин <code>InnoDB</code> для индекса <span><strong>primary key
</strong></span>. <code>InnoDB</code> организован на значениях столбцов
первичного ключа, чтобы ускорить запросы и сортировки, вовлекающие столбцы
первичного ключа. Для лучшей работы выберите столбцы первичного ключа,
основанные на самых критических по отношению к работе запросах. Поскольку
изменение столбцов кластеризируемого индекса дорогая работа, выберите
основные столбцы, которые редко или никогда не обновляются.</p>

<p>В Oracle Database этот тип таблицы известен как
<span><strong>index-organized table</strong></span>.</p>
<p>См. <a href="#glos_index">index</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_secondary_index">secondary index</a>.</dd>

<dt><a name="glos_cold_backup"></a><span>Холодное резервное копирование
</span></dt>
<dd><p><span><strong>Резервное копирование</strong></span> в то время, как
база данных закрыта. Для занятых приложений и веб-сайтов это не могло бы быть
практично, и Вы могли бы предпочесть <span><strong>теплое резервное
копирование</strong></span> или <span><strong>горячее резервное копирование
</strong></span>.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_warm_backup">warm backup</a>.</dd>

<dt><a name="glos_column"></a><span>Столбец</span></dt>
<dd><p>Элемент данных в <span><strong>строке</strong></span>, хранение
которого и семантика определены типом данных. Каждая
<span><strong>таблица</strong></span> и <span><strong>индекс</strong></span>
в значительной степени определены набором столбцов, которые это содержит.</p>

<p>У каждого столбца есть значение <span><strong>количества элементов
</strong></span>. Столбец может быть <span><strong>первичным ключом</strong>
</span> для своей таблицы или частью первичного ключа. Столбец может
подвергнуться <span><strong>уникальному ограничению</strong></span>,
<span><strong>ограничению NOT NULL</strong></span> или обоим. Значения в
различных столбцах, даже через различные таблицы, могут быть соединены
отношениями <span><strong>внешнего ключа</strong></span>.</p>

<p>В обсуждениях внутренних операций MySQL иногда <span><strong>область
</strong></span> используется в качестве синонима.</p>
<p>См. <a href="#glos_cardinality">cardinality</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_index">index</a>,
<a href="#glos_not_null_constraint">NOT NULL constraint</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_row">row</a>,
<a href="#glos_table">table</a>,
<a href="#glos_unique_constraint">unique constraint</a>.</dd>

<dt><a name="glos_column_index"></a><span>Столбец индекса</span></dt>
<dd><p><span><strong>Индекс</strong></span> на единственном столбце.</p>
<p>См. <a href="#glos_composite_index">composite index</a>,
<a href="#glos_index">index</a>.</dd>

<dt><a name="glos_column_prefix"></a><span>Префикс столбца</span></dt>
<dd><p>Когда <span><strong>индекс</strong></span> создается со спецификацией
длины, такой как <code>CREATE INDEX idx ON t1 (c1(N))</code>,
только первые N символов значения столбца сохранены в индексе. Хранение
маленького префикса индекса делает индексирование компактным. Хотя создание
слишком маленького префикса может препятствовать оптимизации запроса,
заставляя строки с различными значениями быть дубликатами.</p>

<p>Для столбцов, содержащих двоичные значения или длинные текстовые строки,
где сортировка не главное соображение и хранение всего значения в индексе
потратило бы впустую пространство, индекс автоматически использует первые N
(как правило, 768) символов значения, чтобы сделать поиски и сортировки.</p>
<p>См. <a href="#glos_index">index</a>.</dd>

<dt><a name="glos_commit"></a><span>commit</span></dt>
<dd><p>Команда <span><strong>SQL</strong></span>, которая заканчивает
<span><strong>транзакцию</strong></span>, делая постоянными любые изменения,
произведенные транзакцией. Это противоположность
<span><strong>rollback</strong></span>, которая отменяет любые
изменения, произведенные в транзакции.</p>

<p><code>InnoDB</code> использует <span><strong>оптимистический</strong>
</span> механизм для передачи, чтобы изменения могли быть написаны файлам с
данными прежде, чем передача фактически произойдет. Этот метод делает
передачу быстрее, хотя больше работы требуется в случае отмены.</p>

<p>По умолчанию MySQL использует <span><strong>autocommit</strong></span>,
которая автоматически передает после каждого запроса SQL.</p>
<p>См. <a href="#glos_autocommit">autocommit</a>,
<a href="#glos_optimistic">optimistic</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_sql">SQL</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_compact_row_format"></a><span>Компактный формат строки
</span></dt>
<dd><p><span><strong>Формат строки</strong></span> для InnoDB.
Это был формат строки по умолчанию от MySQL 5.0.3 до MySQL 5.7.8. В MySQL
8.0 формат строки по умолчанию определен опцией
<a href="innodb.htm#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>, у которой есть настройка по умолчанию
<span><strong>DYNAMIC</strong></span>. Формат строки
<span><strong>COMPACT</strong></span> обеспечивает более компактное
представление для нулей и столбцов переменной
длины, чем <span><strong>REDUNDANT</strong></span>.</p>

<p>См. <a href="innodb.htm#innodb-row-format-antelope">раздел 16.10.4</a>.
</p>
<p>См. <a href="#glos_dynamic_row_format">dynamic row format</a>,
<a href="#glos_file_format">file format</a>,
<a href="#glos_redundant_row_format">redundant row format</a>,
<a href="#glos_row_format">row format</a>.</dd>

<dt><a name="glos_composite_index"></a><span>Композитный индекс</span></dt>
<dd><p><span><strong>Индекс</strong></span>, который включает много столбцов.
</p>
<p>См. <a href="#glos_index">index</a>.</dd>

<dt><a name="glos_compressed_backup"></a><span>Сжатое резервное копирование
</span></dt>
<dd><p>Особенность сжатия <span><strong>MySQL Enterprise Backup</strong>
</span> делает сжатую копию каждого табличного пространства, изменяя
расширение с <code>.ibd</code> на <code>.ibz</code>. Сжатие резервных данных
позволяет Вам держать больше резервных копий под рукой и уменьшает время,
чтобы передать резервные копии серверу. Данные несжаты во время работы
восстановления. Когда сжатая резервная работа обрабатывает таблицу, которая
уже сжата, она пропускает шаг сжатия для той таблицы, потому что сжатие снова
привело бы к небольшим или никаким сбережениям пространства.</p>

<p>Ряд файлов, произведенных <span><strong>MySQL Enterprise Backup</strong>
</span>, где каждое <span><strong>табличное пространство</strong></span>
сжато. Сжатые файлы переименованы с расширением файла <code>.ibz</code>.</p>

<p>Применение <span><strong>сжатия</strong></span> в начале резервного
процесса помогает избежать издержек хранения во время процесса сжатия и
передавая резервные файлы другому серверу. Процесс
<span><strong>применения</strong></span> <span><strong>двоичного журнала
</strong></span> занимает больше времени и требует
несжатых резервных файлов.</p>

<p>См. <a href="#glos_apply">apply</a>,
<a href="#glos_binary_log">binary log</a>,
<a href="#glos_compression">compression</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_compressed_row_format"></a><span>Сжатый формат строки
</span></dt>
<dd><p><span><strong>Формат строки</strong></span>, который включает данным и
индексам <span><strong>сжатие</strong></span> для <code>InnoDB</code>.
Большие области хранятся отдельно от страницы, которая содержит остальную
часть данных о строке, как в <span><strong>динамическом формате строки
</strong></span>. Обе индексных страницы и большие области сжаты. См.
<a href="innodb.htm#innodb-compression">раздел 16.9</a>.</p>

<p>См. <a href="innodb.htm#innodb-row-format-dynamic">раздел 16.10.3</a>.</p>
<p>См. <a href="#glos_compression">compression</a>,
<a href="#glos_dynamic_row_format">dynamic row format</a>,
<a href="#glos_row_format">row format</a>.</dd>

<dt><a name="glos_compressed_table"></a><span>Сжатая таблица</span></dt>
<dd><p>Таблица, для которой данные хранятся в сжатой форме. Для
<code>InnoDB</code> это таблица, составленная с
<code>ROW_FORMAT=COMPRESSED</code>. См.
<a href="innodb.htm#innodb-compression">раздел 16.9</a>.</p>
<p>См. <a href="#glos_compressed_row_format">
compressed row format</a>,
<a href="#glos_compression">compression</a>.</dd>

<dt><a name="glos_compression"></a><span>Сжатие</span></dt>
<dd><p>Особенность со всесторонней выгодой от использования меньшего
количества дискового пространства, выполнения меньшего количества
ввода/вывода и использования меньшей памяти для того, чтобы кэшировать.</p>

<p><code>InnoDB</code> допускает сжатие на уровне страницы и на уровне
таблицы. Сжатие страницы <code>InnoDB</code> также упоминается как page
<span><strong>прозрачное сжатие страницы</strong></span>. См.
<a href="innodb.htm#innodb-compression">раздел 16.9</a>.</p>

<p>Другой тип сжатия это <span><strong>сжатая резервная копия</strong></span>
в <span><strong>MySQL Enterprise Backup</strong></span>.</p>
<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_compressed_backup">compressed backup</a>,
<a href="#glos_compressed_row_format">compressed row format</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_transparent_page_compression">
transparent page compression</a>.</dd>

<dt><a name="glos_compression_failure"></a><span>Отказ сжатия</span></dt>
<dd><p>Не ошибка, скорее дорогая работа, которая может произойти, используя
<span><strong>сжатие</strong></span> в комбинации с операциями
<span><strong>DML</strong></span>. Это происходит, когда обновления сжатой
<span><strong>страницы</strong></span> переполняют области на странице,
для того, чтобы сделать запись модификаций, страница сжата снова, со всеми
изменениями, к которым относятся табличные данные, пересжатые данные не
помещаются на оригинальной странице, требуя, чтобы MySQL разделил данные на
две новых страницы и сжал каждую отдельно. Чтобы проверить частоту этого
условия, запросите таблицу <a href="inform.htm#innodb-cmp-table">
<code>INFORMATION_SCHEMA.INNODB_CMP</code></a> и проверьте насколько значение
столбца <code>COMPRESS_OPS</code> превышает значение столбца
<code>COMPRESS_OPS_OK</code>. Идеально отказы сжатия часто не происходят,
когда они есть, Вы можете корректировать опции
<a href="innodb.htm#sysvar_innodb_compression_level"><code>
innodb_compression_level</code></a>,
<a href="innodb.htm#sysvar_innodb_compression_failure_threshold_pct"><code>
innodb_compression_failure_threshold_pct</code></a> и
<a href="innodb.htm#sysvar_innodb_compression_pad_pct_max"><code>
innodb_compression_pad_pct_max</code></a>.</p>

<p>См. <a href="#glos_compression">compression</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_concatenated_index"></a><span>Связанный индекс</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_composite_index">
composite index</a>.</dd>

<dt><a name="glos_concurrency"></a><span>Параллелизм</span></dt>
<dd><p>Способность многократных операций (в терминологии базы данных,
<span><strong>транзакций</strong></span>) работать одновременно, не
вмешиваясь друг в друга. Параллелизм также связан с работой, потому что
идеально защита для многократных одновременных транзакций работает с
минимумом работы, используя эффективные механизмы для
того, чтобы <span><strong>заблокировать</strong></span>.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_configuration_file"></a><span>Конфигурационный файл</span>
</dt>
<dd><p>
Файл, который хранит значения <span><strong>опций</strong></span>,
используемых MySQL при запуске. Традиционно, в Linux и Unix этот файл
называют <code>my.cnf</code>, а в Windows <code>my.ini</code>. Вы можете
установить много опций, связанных с InnoDB, в разделе <code>[mysqld]</code>.
</p>

<p>См. <a href="programs.htm#option-files">раздел 5.2.6</a>.</p>
<p>Когда Вы используете <span><strong>MySQL Enterprise Backup</strong></span>,
Вы как правило используете два конфигурационных файла: тот, который
определяет, куда данные прибывают и как это структурировано (который мог быть
оригинальным конфигурационным файлом для Вашего сервера), и упрощенный,
содержащий только маленький набор опций, которые определяют, куда резервные
данные идут и как это структурировано. Конфигурационные файлы, используемые с
<span><strong>MySQL Enterprise Backup</strong></span>, должны содержать
определенные опции, которые как правило упускаются из регулярных
конфигурационных файлов, таким образом, Вы, возможно, должны были бы добавить
опции к своему существующему конфигурационному файлу для использования с
<span><strong>MySQL Enterprise Backup</strong></span>.</p>

<p>См. <a href="#glos_my_cnf">my.cnf</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_option">option</a>,
<a href="#glos_option_file">option file</a>.</dd>

<dt><a name="glos_consistent_read"></a><span>Последовательное чтение</span>
</dt>
<dd><p>Работа чтения, которая использует информацию
<span><strong>снимка</strong></span>, чтобы представить результаты запроса,
основанные на моменте времени, независимо от изменений, выполненных другими
транзакциями, работающими в то же самое время. Если запрашиваемые данные были
изменены другой транзакцией, оригинальные данные восстановлены, основываясь
на содержании <span><strong>журнала отмены</strong></span>. Этот метод
избегает некоторых из проблем <span><strong>блокировки</strong></span>,
которые могут уменьшить <span><strong>параллелизм</strong></span>, вынуждая
транзакции ждать завершения других транзакций.</p>

<p>С <span><strong>уровнем изоляции</strong></span> <span><strong>REPEATABLE
READ</strong></span> снимок основан на времени, когда первая работа чтения
выполнена. С уровнем изоляции <span><strong>READ COMMITTED</strong></span>
снимок сброшен ко времени каждой последовательной работы чтения.</p>

<p>Последовательное чтение это режим по умолчанию, в котором
<code>InnoDB</code> обрабатывает <code>SELECT</code> в уровне изоляции
<span><strong>READ COMMITTED</strong></span> и
<span><strong>REPEATABLE READ</strong></span>.
Поскольку последовательное чтение не устанавливает никаких блокировок на
таблицы, к которым оно получает доступ, другие сеансы свободны изменить те
таблицы в то время, как последовательное чтение выполняется на таблице.</p>

<p>См. <a href="innodb.htm#innodb-consistent-read">раздел 16.5.2.3</a>.</p>
<p>См. <a href="#glos_concurrency">concurrency</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_read_committed">READ COMMITTED</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_snapshot">snapshot</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_constraint"></a><span>Ограничение</span></dt>
<dd><p>Автоматический тест, который может заблокировать изменения базы
данных, чтобы препятствовать тому, чтобы данные стали непоследовательными. В
терминах информатики, своего рода утверждение, связанное с инвариантным
условием. Ограничения это решающий компонент <span><strong>ACID</strong>
</span>, чтобы поддержать последовательность данных. Ограничения,
поддержанные MySQL, включают
<span><strong>ограничения FOREIGN KEY</strong></span> и
<span><strong>уникальные ограничения</strong></span>.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_unique_constraint">unique constraint</a>.</dd>

<dt><a name="glos_counter"></a><span>Счетчик</span></dt>
<dd><p>Значение, которое постепенно увеличено действием <code>InnoDB</code>.
Полезен для измерения, насколько занят сервер, исследуя источники
исполнительных проблем и проверяя изменения (например, настройки
конфигурации или индекс, используемый запросами) имеют желаемые
низкоуровневые эффекты. Различные виды счетчиков доступны через таблицы
<span><strong>Performance Schema</strong></span> и
<span><strong>INFORMATION_SCHEMA</strong></span>, особенно
<code>INFORMATION_SCHEMA.INNODB_METRICS</code>.</p>

<p>См. <a href="#glos_information_schema">INFORMATION_SCHEMA</a>,
<a href="#glos_metrics_counter">metrics counter</a>,
<a href="#glos_performance_schema">Performance Schema</a>.</dd>

<dt><a name="glos_covering_index"></a><span>Покрывающий индекс</span></dt>
<dd><p><span><strong>Индекс</strong></span>, который включает все столбцы,
полученные запросом. Вместо того, чтобы использовать индексные значения в
качестве указателей, чтобы найти полные строки таблицы, запрос возвращает
значения из индексной структуры, сохраняя дисковый ввод/вывод.
<code>InnoDB</code> может применить этот метод оптимизации к большему
индексу, чем MyISAM, потому что <span><strong>вторичные индексы</strong>
</span> <code>InnoDB</code> также включают столбцы <span><strong>первичного
ключа</strong></span>. <code>InnoDB</code> не может применить этот метод для
запросов для таблиц, измененных транзакцией, пока та
транзакция не заканчивается.</p>

<p>Любой <span><strong>столбец индекса</strong></span> или
<span><strong>сводный индекс</strong></span> может действовать как
покрывающий индекс, учитывая правильный запрос.</p>

<p>См. <a href="#glos_column_index">column index</a>,
<a href="#glos_composite_index">composite index</a>,
<a href="#glos_index">index</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_secondary_index">secondary index</a>.</dd>

<dt><a name="glos_cpu_bound"></a><span>CPU-bound</span></dt>
<dd><p>Тип <span><strong>нагрузки</strong></span>, где основное
<span><strong>узкое место</strong></span> это операции центрального
процессора с памятью. Как правило, вовлекает интенсивные действия чтения, где
все результаты могут кэшироваться в <span><strong>буферном пуле</strong>
</span>.</p>

<p>См. <a href="#glos_bottleneck">bottleneck</a>,
<a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_workload">workload</a>.</dd>

<dt><a name="glos_crash"></a><span>Катастрофический отказ</span></dt>
<dd><p>MySQL использует термин &quot;катастрофический отказ&quot;, чтобы
обратиться вообще к любой неожиданной ситуации <span><strong>завершения
работы</strong></span>, где сервер не может сделать своей нормальной уборки.
Например, катастрофический отказ мог произойти из-за ошибки аппаратных
средств на машине сервера базы данных или устройстве хранения данных, перебоя
в питании, потенциального несоответствия данных, которое заставляет сервер
MySQL останавливаться, <span><strong>быстрого завершения работы</strong>
</span>, начатого DBA, или многих других причин. Автоматическое <span>
<strong>восстановление катастрофического отказа</strong></span> для таблиц
<span><strong>InnoDB</strong></span> гарантирует, что данные сделаны
последовательными, когда сервер перезапущен, без любой
дополнительной работы DBA.</p>

<p>См. <a href="#glos_crash_recovery">crash recovery</a>,
<a href="#glos_fast_shutdown">fast shutdown</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_shutdown">shutdown</a>.</dd>

<dt><a name="glos_crash_recovery"></a><span>
Восстановление катастрофического отказа</span></dt>
<dd><p>Действия уборки, которые происходят, когда MySQL запущен снова после
<span><strong>катастрофического отказа</strong></span>. Для таблиц <span>
<strong>InnoDB</strong></span> изменения от неполных транзакций
переигрываются, используя данные <span><strong>журнала redo</strong></span>.
Изменения, которые были <span><strong>переданы</strong></span> перед
катастрофическим отказом, но еще не написаны в <span><strong>файлы с данными
</strong></span>, восстановлены от <span><strong>буфера doublewrite</strong>
</span>. Когда база данных обычно закрывается, этот тип деятельности выполнен
во время завершения работы <span><strong>чистки</strong></span>.</p>

<p>Во время нормального функционирования переданные данные могут храниться в
<span><strong>буфере изменения</strong></span> прежде, чем быть написанными
в файлы с данными. Всегда есть проблема между хранением современных файлов с
данными, что вводит издежрки во время нормального функционирования, и
буферизации данных, которые могут сделать завершение работы и восстановление
занимающими больше времени.</p>

<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_commit">commit</a>,
<a href="#glos_crash">crash</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_doublewrite_buffer">doublewrite buffer</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_purge">purge</a>,
<a href="#glos_redo_log">redo log</a>.</dd>

<dt><a name="glos_crud"></a><span>CRUD</span></dt>
<dd><p>Сокращение от "create, read, update, delete", общая последовательность
операций в приложениях базы данных. Часто обозначает класс приложений с
относительно простым использованием базы данных (основной
<span><strong>DDL</strong></span>, <span><strong>DML</strong></span> и
<span><strong>запросы</strong></span> <span><strong>SQL</strong></span>),
который может быть осуществлен быстро на любом языке.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_query">query</a>,
<a href="#glos_sql">SQL</a>.</dd>

<dt><a name="glos_cursor"></a><span>Курсор</span></dt>
<dd><p>Внутренняя структура данных, которая используется, чтобы представить
набор результатов <span><strong>запроса</strong></span> или другую работу,
которая выполняет поиск, используя параметр SQL <code>WHERE</code>.
Это работает как итератор на других высокоуровневых языках, производя каждое
значение из набора результатов согласно запросу.</p>

<p>Хотя SQL обычно обрабатывает обработку курсоров для Вас, Вы могли бы
копаться во внутренних работах, имея дело с критическим по
отношению к работе кодом.</p>
<p>См. <a href="#glos_query">query</a>.</p></dd></dl>

<h3>D</h3>
<dl><dt><a name="glos_data_definition_language"></a><span>
Язык определения данных</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_ddl">DDL</a>.</dd>

<dt><a name="glos_data_dictionary"></a><span>Словарь данных</span></dt>
<dd><p>Метаданные, которые отслеживают объекты базы данных, такие как
<span><strong>таблицы</strong></span>,
<span><strong>индексы</strong></span> и
<span><strong>столбцы</strong></span>. Для словаря данных MySQL, введенного в
MySQL 8.0, метаданные физически расположены в
файлах табличного пространства <code>InnoDB</code>
<span><strong>file-per-table</strong></span> в каталоге базы данных
<code>mysql</code>. Для словаря данных <code>InnoDB</code> метаданные
физически расположены в <span><strong>системном табличном пространстве
</strong></span> <code>InnoDB</code>.</p>

<p>Поскольку <span><strong>MySQL Enterprise Backup</strong></span>
всегда поддерживает системное табличное пространство <code>InnoDB</code>,
все резервные копии включают содержание словаря данных <code>InnoDB</code>.
</p>

<p>См. <a href="#glos_column">column</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_frm_file">.frm file</a>,
<a href="#glos_index">index</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_data_directory"></a><span>Каталог данных</span></dt>
<dd><p>Каталог, в соответствии с которым каждый
<span><strong>экземпляр</strong></span> MySQL сохраняет <span><strong>файлы с
данными</strong></span> для  <code>InnoDB</code> и каталоги, представляющие
отдельные базы данных. Управляется опцией
<a href="server.htm#sysvar_datadir"><code>datadir</code></a>.</p>
<p>См. <a href="#glos_data_files">data files</a>,
<a href="#glos_instance">instance</a>.</dd>

<dt><a name="glos_data_files"></a><span>Файлы с данными</span></dt>
<dd><p>Файлы, которые физически содержат данные <span><strong>таблицы
</strong></span> и <span><strong>индекса</strong></span>.</p>

<p><span><strong>Системное табличное пространство</strong></span>
<code>InnoDB</code>, которое содержит
<span><strong>словарь данных</strong></span>
и способно хранить данные для многих таблиц <code>InnoDB</code>,
представлено одним или больше файлами <code>.ibdata</code>.</p>

<p>Табличные пространства File-per-table, которые содержат данные для
одной таблицы <code>InnoDB</code>, представлены файлом <code>.ibd</code>.</p>
<p>Общие табличные пространства (введенные в MySQL 5.7.6), которые могут
содержать данные для многих таблиц <code>InnoDB</code>, также
представлены файлом <code>.ibd</code>.</p>

<p>См. <a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_ibdata_file">ibdata file</a>,
<a href="#glos_index">index</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_table">table</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_data_manipulation_language"></a><span>
Язык манипуляции данных</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_dml">DML</a>.</dd>

<dt><a name="glos_data_warehouse"></a><span>Хранилище данных</span></dt>
<dd><p>Система базы данных или приложение, которое прежде всего выполняет
большие <span><strong>запросы</strong></span>. Данные только для чтения или
для чтения главным образом могли бы быть организованы в форме
<span><strong>denormalized</strong></span> для эффективности запроса. Может
извлечь выгоду из оптимизации для <span><strong>транзакций только для чтения
</strong></span> в MySQL 5.6 или выше.</p>

<p>См. <a href="#glos_denormalized">denormalized</a>,
<a href="#glos_oltp">OLTP</a>,
<a href="#glos_query">query</a>,
<a href="#glos_read_only_transaction">read-only transaction
</a>.</dd>

<dt><a name="glos_database"></a><span>База данных</span></dt>
<dd><p>В пределах <span><strong>каталога данных</strong></span> MySQL каждая
база данных представлена отдельным каталогом.
<span><strong>Системное табличное пространство</strong></span>,
которое может содержать табличные данные многих баз данных в пределах
экземпляра MySQL, сохранено в <span><strong>файлах с данными</strong></span>,
которые находятся за пределами отдельных каталогов базы данных. Когда режим
<span><strong>file-per-table</strong></span> включен, <span><strong>файлы
.ibd</strong></span>, представляющие таблицы InnoDB,
хранятся в каталогах базы данных если не создаются в другом месте
использованием <code>DATA DIRECTORY</code>.
Общие табличные пространства, введенные в MySQL 5.7.6, также содержат
табличные данные в <span><strong>файлах .ibd</strong></span>. В отличие от
file-per-table <span><strong>файлов .ibd</strong></span>,
<span><strong>файлы .ibd</strong></span> общего табличного пространства
могут содержать табличные данные многих баз данных в пределах экземпляра
MySQL и быть назначены на каталоги относительно или независимо от
каталога данных MySQL.</p>

<p>Для давних пользователей MySQL база данных
знакомое понятие. Пользователи, происходящие из среды базы данных Oracle
Database, найдут, что значение базы данных MySQL ближе к тому, что
Oracle Database называет <span><strong>schema</strong></span>.</p>

<p>См. <a href="#glos_data_files">data files</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_instance">instance</a>,
<a href="#glos_schema">schema</a>,
<a href="#glos_system_tablespace">system tablespace</a>.</dd>

<dt><a name="glos_dcl"></a><span>DCL</span></dt>
<dd><p>Язык управления данных, ряд запросов <span><strong>SQL</strong></span>
для руководящих привилегий. В MySQL состоит из
<a href="sql.htm#grant"><code>GRANT</code></a> и
<a href="sql.htm#revoke"><code>REVOKE</code></a>.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_sql">SQL</a>.</dd>

<dt><a name="glos_ddl"></a><span>DDL</span></dt>
<dd><p>Язык определения данных, ряд запросов
<span><strong>SQL</strong></span> для того, чтобы управлять базой данных
непосредственно, а не отдельными строками таблицы. Включает все формы
<code>CREATE</code>, <code>ALTER</code> и <code>DROP</code>.
Также включает <code>TRUNCATE</code>, потому что это работает по-другому, чем
<code>DELETE FROM <em><code>table_name</code></em></code>
даже при том, что окончательный эффект подобен.</p>

<p>DDL автоматически <span><strong>передает</strong></span> текущую
<span><strong>транзакцию</strong></span>, запрос нельзя
<span><strong>отменить</strong></span>.</p>

<p><code>InnoDB</code> <a href="#glos_online_ddl">online DDL</a>
улучшает работу для <a href="sql.htm#create-index"><code>CREATE INDEX</code>
</a>, <a href="sql.htm#drop-index"><code>DROP INDEX</code></a> и многих типов
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, см.
<a href="innodb.htm#innodb-online-ddl">раздел 16.12</a>. Кроме того,
<code>InnoDB</code> <a href="#glos_file_per_table">file-per-table
</a> может затронуть поведение <a href="sql.htm#drop-table"><code>DROP TABLE
</code></a> и <a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code>
</a>.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_dcl">DCL</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_sql">SQL</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_deadlock"></a><span>Тупик</span></dt>
<dd><p>Ситуация, где различные <span><strong>транзакции</strong></span>
неспособны продолжиться, потому что каждая держит <span><strong>блокировку
</strong></span>, нужную другой. Поскольку обе транзакции ждут ресурса, ни
одна никогда не будет выпускать блокировки, которые это держит.</p>

<p>Тупик может произойти, когда транзакции блокируют строки в многократных
таблицах (через запрос вроде <code>UPDATE</code> или
<code>SELECT ... FOR UPDATE</code>), но в противоположном порядке. Тупик
может также произойти, когда такие запросы блокируют диапазоны индексных
записей и <span><strong>промежутки</strong></span>, с каждой транзакцией,
приобретающей некоторые блокировки, но не другие
из-за проблемы синхронизации.</p>

<p>Для вводной информации о том, как тупики автоматически обнаружены и
обработаны см. <a href="innodb.htm#innodb-deadlock-detection">раздел 16.5.5.2
</a>. Для подсказок относительно ухода от тупика и восстановления от условий
тупика см. <a href="innodb.htm#innodb-deadlocks-handling">раздел 16.5.5.3
</a>.</p>

<p>См. <a href="#glos_gap">gap</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_deadlock_detection"></a><span>Обнаружение тупиков
</span></dt>
<dd><p>Механизм, который автоматически обнаруживает, когда <span><strong>
тупик</strong></span> происходит, и автоматически <span><strong>отменяет
</strong></span> одну из вовлеченных <span><strong>транзакций</strong></span>
(<span><strong>жертву</strong></span>). Обнаружение тупика может быть
отключено, используя <a href="innodb.htm#sysvar_innodb_deadlock_detect">
<code>innodb_deadlock_detect</code></a>.</p>

<p>См. <a href="#glos_deadlock">deadlock</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_victim">victim</a>.</dd>

<dt><a name="glos_delete"></a><span>delete</span></dt>
<dd><p>Когда <code>InnoDB</code> выполняет запрос <code>DELETE</code>,
строки были немедленно отмечены для удаления и больше не возвращены
запросами. Хранение исправлено когда-то позже, во время периодической уборки
мусора, известной как <span><strong>очистка</strong></span>.
Для того, чтобы удалить большие количества данных, связанные операции с их
собственными техническими характеристиками являются
<span><strong>TRUNCATE</strong></span> и <span><strong>DROP</strong></span>.
</p>

<p>См. <a href="#glos_drop">drop</a>,
<a href="#glos_purge">purge</a>,
<a href="#glos_truncate">truncate</a>.</dd>

<dt><a name="glos_delete_buffering"></a><span>Буфер удаления</span></dt>
<dd><p>Метод хранения изменений вторичных индексных страниц по результатам
<code>DELETE</code> в <span><strong>буфере изменения</strong></span> вместо
того, чтобы немедленно писать изменения, чтобы физические записи могли
быть выполнены, чтобы минимизировать случайный ввод/вывод. Поскольку операции
удаления это двухступенчатый процесс, эта работа буферизует записи, которые
обычно отмечают индексную запись для удаления. Это один из типов
<span><strong>буферизации изменения</strong></span>, другие это
<span><strong>буферизация insert</strong></span> и
<span><strong>буферизация очистки</strong></span>.</p>

<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_change_buffering">change buffering</a>,
<a href="#glos_insert_buffer">insert buffer</a>,
<a href="#glos_insert_buffering">insert buffering</a>,
<a href="#glos_purge_buffering">purge buffering</a>.</dd>

<dt><a name="glos_denormalized"></a><span>denormalized</span></dt>
<dd><p>Стратегия хранения данных, которая дублирует данные через различные
таблицы, вместо того, чтобы соединить таблицы с запросами
<span><strong>внешними ключами</strong></span>
<span><strong>join</strong></span>. Как правило, используется в приложениях
<span><strong>хранилища данных</strong></span>,
где данные не обновлены после загрузки. В таких приложениях работа запроса
более важна, чем поддержка последовательных данных во время обновлений.</p>

<p>См. <a href="#glos_data_warehouse">data warehouse</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_join">join</a>,
<a href="#glos_normalized">normalized</a>.</dd>

<dt><a name="glos_descending_index"></a><span>Убывание индекса</span></dt>
<dd><p>Тип <span><strong>индекса</strong></span> доступный с некоторыми
системами базы данных, где хранение оптимизировано, чтобы обработать
<code>ORDER BY <em><code>column</code></em> DESC</code>.
В настоящее время, хотя MySQL позволяет ключевое слово <code>DESC</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>, это не
использует специального расположения хранения для получающегося индекса.</p>
<p>См. <a href="#glos_index">index</a>.</dd>

<dt><a name="glos_dictionary_object_cache"></a><span>Кэш объекта словаря
</span></dt>
<dd><p>Кэш объекта словаря хранит объекты <span><strong>словаря данных
</strong></span>, к которым ранее получали доступ, в памяти, чтобы
позволить повторное использование объекта и минимизировать дисковый
ввод/вывод. <span><strong>LRU</strong></span>-стратегия используется, чтобы
вычеркнуть последние использованные объекты из памяти. Кэш состоит из
нескольких разделов, которое хранят различные типы объектов.</p>

<p>См. <a href="data.htm#data-dictionary-object-cache">раздел 15.4</a>.</p>
<p>См. <a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_lru">LRU</a>.</dd>

<dt><a name="glos_dirty_page"></a><span>Грязная страница</span></dt>
<dd><p><span><strong>Страница</strong></span> в <span><strong>буферном пуле
</strong></span> <code>InnoDB</code> которая была обновлена в памяти, но
изменения еще не написаны в <span><strong>файлы данных</strong></span>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_clean_page">clean page</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_dirty_read"></a><span>Грязное чтение</span></dt>
<dd><p>Работа, которая получает ненадежные данные, которые были обновлены
другой транзакцией, но еще не <span><strong>переданы</strong></span>. Это
возможно только с <span><strong>уровнем изоляции</strong></span>, известным
как <span><strong>read uncommitted</strong></span>.</p>

<p>Этот вид работы не придерживается <span><strong>ACID</strong></span>.
Это считают очень опасным, потому что данные могли быть
<span><strong>отменены</strong></span> или обновлены далее прежде, чем быть
переданными, тогда транзакция, делающая грязное чтение, использовала бы
данные, которые никогда не подтверждались как точные.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_commit">commit</a>,
<a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_read_uncommitted">READ UNCOMMITTED</a>,
<a href="#glos_rollback">rollback</a>.</dd>

<dt><a name="glos_disk_based"></a><span>disk-based</span></dt>
<dd><p>Своего рода база данных, которая прежде всего организует данные по
дисковому хранению (жесткие диски или эквивалент). Данные переданы
между диском и памятью, которая будет управляться на. Это противоположность
<span><strong>in-memory database</strong></span>.
Хотя <code>InnoDB</code> основано на диске, это также содержит такие
особенности, как <span><strong>буферный пул</strong></span>, многократные
буферные пулы и <span><strong>адаптивный хеш-индекс</strong></span>,
которые позволяют определенным видам рабочих нагрузок работать
прежде всего в памяти.</p>

<p>См. <a href="#glos_adaptive_hash_index">adaptive hash index
</a>, <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_in_memory_database">in-memory database</a>.</dd>

<dt><a name="glos_disk_bound"></a><span>disk-bound</span></dt>
<dd><p>Тип <span><strong>нагрузки</strong></span>, где основное
<span><strong>узкое место</strong></span> это дисковый ввод/вывод. Также
известный как <span><strong>I/O-bound</strong></span>. Как правило, вовлекает
частые записи на диск или случайные чтения большого количества данных, чем
может вписаться в <span><strong>буферный пул</strong></span>.</p>

<p>См. <a href="#glos_bottleneck">bottleneck</a>,
<a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_workload">workload</a>.</dd>

<dt><a name="glos_dml"></a><span>DML</span></dt>
<dd><p>Язык манипуляции данными, ряд запросов <span><strong>SQL</strong>
</span> для того, чтобы выполнить операторы
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>.
<a href="sql.htm#select"><code>SELECT</code></a>
иногда рассматривают как запрос DML, потому что форма
<code>SELECT ... FOR UPDATE</code>
подвергается тем же самым соображениям для того, чтобы
<span><strong>заблокировать</strong></span>, как
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>.</p>

<p>Запросы DML для таблицы <code>InnoDB</code> работают в контексте
<span><strong>транзакций</strong></span>, таким образом, их эффекты могут
быть <span><strong>переданы</strong></span> или
<span><strong>отменены</strong></span> как единственный модуль.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_dcl">DCL</a>,
<a href="#glos_ddl">DDL</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_sql">SQL</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_document_id"></a><span>document id</span></dt>
<dd><p>В <span><strong>полнотекстовом поиске</strong></span>
<code>InnoDB</code> специальный столбец в таблице, содержащей
<span><strong>индекс FULLTEXT</strong></span>,
чтобы уникально идентифицировать документ, связанный с каждым значением
<span><strong>ilist</strong></span>. Его имя
<code>FTS_DOC_ID</code> (верхний регистр обязателен!).
Сам столбец должен иметь тип <code>BIGINT UNSIGNED NOT NULL</code> с
уникальным индексом <code>FTS_DOC_ID_INDEX</code>.
Предпочтительно, Вы определяете этот столбец, составляя таблицу. Если
<code>InnoDB</code> должен добавить столбец к таблице, создавая индекс
<code>FULLTEXT</code>, работа индексации значительно более дорога.</p>

<p>См. <a href="#glos_full_text_search">full-text search</a>,
<a href="#glos_fulltext_index">FULLTEXT index</a>,
<a href="#glos_ilist">ilist</a>.</dd>

<dt><a name="glos_doublewrite_buffer"></a><span>Буфер doublewrite</span></dt>
<dd><p><code>InnoDB</code> использует метод потока файла, названный
doublewrite. Перед записью <span><strong>страниц</strong></span> в
<span><strong>файлы данных</strong></span> <code>InnoDB</code>
сначала пишет их в непрерывную область, названную буфером doublewrite. Только
после того, как запись и сброс к буферу doublewrite завершились,
<code>InnoDB</code> пишет страницы к их надлежащим позициям в файле с
данными. Если есть катастрофический отказ операционной системы, подсистемы
хранения или процесса <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> в середине записи страницы, <code>InnoDB</code>
может позже найти хорошую копию страницы из буфера doublewrite во время
<span><strong>восстановления катастрофического отказа</strong></span>.</p>

<p>Хотя данные всегда пишутся дважды, буфер doublewrite не требует вдвое
большего количества ввода/вывода. Данные написаны в буфер непосредственно как
большой последовательный кусок одним вызовом <code>fsync()</code>.</p>

<p>Чтобы выключить буфер doublewrite, определите опцию
<a href="innodb.htm#sysvar_innodb_doublewrite"><code>innodb_doublewrite=0
</code></a>.</p>

<p>См. <a href="#glos_crash_recovery">crash recovery</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_page">page</a>,
<a href="#glos_purge">purge</a>.</dd>

<dt><a name="glos_drop"></a><span>drop</span></dt>
<dd><p>Своего рода работа <span><strong>DDL</strong></span>, которая удаляет
объект схемы через такой запрос, как
<a href="sql.htm#drop-table"><code>DROP TABLE</code></a> или
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a>.
Это отображается внутренне на <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a>. Для <code>InnoDB</code> исполнительное рассмотрение таких
операций вовлекает время, когда <span><strong>словарь данных</strong></span>
заблокирован, чтобы гарантировать, что взаимосвязанные объекты все обновлены,
и время, чтобы обновить структуры памяти, такие как
<span><strong>буферный пул</strong></span>. Для
<span><strong>таблицы</strong></span> у задачи drop есть несколько иные
характеристики, чем у <span><strong>truncate</strong></span>
(<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>).</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_ddl">DDL</a>,
<a href="#glos_table">table</a>,
<a href="#glos_truncate">truncate</a>.</dd>

<dt><a name="glos_dynamic_row_format"></a><span>Динамический формат строки
</span></dt>
<dd><p>Формат строки <code>InnoDB</code>. Поскольку длинные значения столбцов
переменной длины сохранены за пределами страницы, которая содержит данные о
строке, это очень эффективно для строк, которые включают большие объекты. Так
как к большим областям, как правило, не получают доступ, чтобы оценить
условия запроса, они не принесены в <span><strong>буферный пул</strong>
</span>, приводя к меньшему количеству операций ввода/вывода и лучшему
использованию кэш-памяти.</p>

<p>С MySQL 5.7.9 формат строки по умолчанию определен опцией
<a href="innodb.htm#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>, у которой есть значение
по умолчанию <code>DYNAMIC</code>.</p>
<p>См. <a href="innodb.htm#innodb-row-format-dynamic">раздел 16.10.3</a>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_file_format">file format</a>,
<a href="#glos_row_format">row format</a>.</p></dd></dl>

<h3>E</h3>
<dl><dt><a name="glos_early_adopter"></a><span>early adopter</span></dt>
<dd><p>Этап, подобный <span><strong>бете</strong></span>, когда программный
продукт оценивается для работы, функциональности и совместимости в установке.
</p>
<p>См. <a href="#glos_beta">beta</a>.</dd>

<dt><a name="glos_error_log"></a><span>Журнал ошибок</span></dt>
<dd><p>Тип <span><strong>журнала</strong></span>
о запуске MySQL и критических ошибках во время выполнения и информации
<span><strong>о катастрофическом отказе</strong></span>. Для деталей см.
<a href="server.htm#error-log">раздел 6.4.2</a>.</p>
<p>См. <a href="#glos_crash">crash</a>,
<a href="#glos_log">log</a>.</dd>

<dt><a name="glos_eviction"></a><span>Вычеркивание</span></dt>
<dd><p>Процесс удаления элемента из кэша или другой временной области
хранения, такой как <span><strong>буферный пул</strong></span>.
Часто, но не всегда, использует алгоритм <span><strong>LRU</strong></span>,
чтобы определить, который элемент удалить. Когда <span><strong>грязная
страница</strong></span> вычеркнута, ее содержание
<span><strong>сброшено</strong></span> на диск, и любые грязные <span>
<strong>соседние страницы</strong></span> могли бы сброситься также.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_lru">LRU</a>,
<a href="#glos_neighbor_page">neighbor page</a>.</dd>

<dt><a name="glos_exclusive_lock"></a><span>Исключительная блокировка</span>
</dt>
<dd><p>Своего рода <span><strong>блокировка</strong></span>, которая
препятствует тому, чтобы любая другая <span><strong>транзакция</strong>
</span> блокировала ту же самую строку. В зависимости от операционного
<span><strong>уровня изоляции</strong></span> этот вид блокировки мог бы
заблокировать другие транзакции на запись той же самой строки или
заблокировать другие транзакции от чтения той же самой строки. Значение по
умолчанию уровень изоляции <code>InnoDB</code>
<span><strong>REPEATABLE READ</strong></span>
включает более высокий <span><strong>параллелизм</strong></span>, позволяя
транзакции считать строки, у которых есть исключительные блокировки, метод,
известный как <span><strong>последовательное чтение</strong></span>.</p>

<p>См. <a href="#glos_concurrency">concurrency</a>,
<a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_shared_lock">shared lock</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_extent"></a><span>Экстент</span></dt>
<dd><p>Группа <span><strong>страниц</strong></span> в пределах
<span><strong>табличного пространства</strong></span>. Для <span><strong>
размера страницы</strong></span> по умолчанию в 16 КБ экстент содержит 64
страницы. В MySQL 5.6 размер страницы для <code>InnoDB</code>
может составить 4 КБ, 8 КБ, или 16 КБ, этим управляет опция
<a href="innodb.htm#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. Для размеров страниц 4KB, 8KB и 16KB размер экстента
всегда 1 МБ (или 1048576 байтов).</p>

<p>Поддержка размеров страниц 32 КБ и 64 КБ была добавлена в MySQL 5.7.6. Для
размера страницы 32 КБ размер экстента составляет 2 МБ. Для размера страницы
64 КБ размер экстента составляет 4 МБ.</p>

<p>Такие особенности <code>InnoDB</code>, как
<span><strong>сегменты</strong></span>, запросы
<span><strong>чтения вперед</strong></span>
и <span><strong>буферные</strong></span> операции ввода/вывода с
использованием <span><strong>буфера doublewrite</strong></span>, которые
читают, пишут, выделяют или освобождают данные, применяют экстент за раз.</p>

<p>См. <a href="#glos_doublewrite_buffer">doublewrite buffer</a>,
<a href="#glos_page">page</a>,
<a href="#glos_page_size">page size</a>,
<a href="#glos_read_ahead">read-ahead</a>,
<a href="#glos_segment">segment</a>,
<a href="#glos_tablespace">tablespace</a>.</p></dd></dl>

<h3>F</h3>
<dl><dt><a name="glos_frm_file"></a><span>Файл .frm</span></dt>
<dd><p>Файл, содержащий метаданные, такие как табличное определение, таблицы
MySQL. Файлы <code>.frm</code> были удалены в MySQL 8.0, но все еще
используются в более ранних выпусках MySQL. В MySQL 8.0 данные, ранее
хранившиеся в файлах <code>.frm</code>,
хранятся в таблицах <span><strong>словаря данных</strong></span>.</p>

<p>См. <a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_system_tablespace">system tablespace</a>.</dd>

<dt><a name="glos_fast_index_creation"></a><span>Fast Index Creation</span>
</dt>
<dd><p>Способность сначала появилась в InnoDB Plugin, теперь это часть MySQL
5.5 и выше, которая ускоряет создание <span><strong>вторичных индексов
</strong></span> <code>InnoDB</code> избегая потребности полностью переписать
связанную таблицу. Ускорение относится также к удалению вторичного индекса.
</p>

<p>Поскольку обслуживание индекса может добавить работу
ко многим операциям передачи данных, выполнение таких операций, как
<code>ALTER TABLE ... ENGINE=INNODB</code> или
<code>INSERT INTO ... SELECT * FROM ...</code> без вторичного индекса
существенно ускоряет процесс.</p>

<p>В MySQL 5.6 эта особенность становится более общей. Вы можете читать
и писать таблицы в то время, как индексирование создается, и делать еще много
видов <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, не копируя
таблицу, не блокируя операции <span><strong>DML</strong></span> или то и
другое. Таким образом в MySQL 5.6 и выше, этот набор особенностей упоминается
как <span><strong>online DDL</strong></span> вместо Fast Index Creation.</p>

<p>См. <a href="../../../dev.mysql.com/doc/refman/5.5/en/innodb-create-index.html"
target="_top">InnoDB Fast Index Creation</a> и
<a href="innodb.htm#innodb-online-ddl">раздел 16.12</a>.</p>

<p>См. <a href="#glos_dml">DML</a>,
<a href="#glos_index">index</a>,
<a href="#glos_online_ddl">online DDL</a>,
<a href="#glos_secondary_index">secondary index</a>.</dd>

<dt><a name="glos_fast_shutdown"></a><span>Быстрое завершение работы
</span></dt>
<dd><p>Процедура <span><strong>завершения работы</strong></span>
по умолчанию для <code>InnoDB</code> основана на установке опции
<a href="innodb.htm#sysvar_innodb_fast_shutdown"><code>innodb_fast_shutdown=1
</code></a>. Чтобы сэкономить время, определенные операции
<span><strong>сброса</strong></span> пропущены. Этот тип завершения работы
безопасен во время нормального использования, потому что операции сброса
выполнены во время следующего запуска, используя тот же самый механизм в
качестве <span><strong>восстановлении катастрофического отказа</strong>
</span>. В случаях, где база данных закрывается для обновления,
сделайте <span><strong>медленное завершение работы</strong></span> вместо
этого, чтобы гарантировать, что все соответствующие изменения применены к
<span><strong>файлам с данными</strong></span> во время завершения работы.
</p>

<p>См. <a href="#glos_crash_recovery">crash recovery</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_shutdown">shutdown</a>,
<a href="#glos_slow_shutdown">slow shutdown</a>.</dd>

<dt><a name="glos_file_format"></a><span>Формат файла</span></dt>
<dd><p>Формат, используемый <code>InnoDB</code> для каждой таблицы, как
правило, с установкой  <span><strong>file-per-table</strong></span>
включенной так, чтобы каждая таблица была сохранена в
отдельном файле <span><strong><code>.ibd</code></strong></span>.</p>

<p>См. <a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_ibdata_file">ibdata file</a>,
<a href="#glos_row_format">row format</a>.</dd>

<dt><a name="glos_file_per_table"></a><span>file-per-table</span></dt>
<dd><p>Общее название установки, которой управляет опция
<a href="innodb.htm#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a>, которая является важным параметром конфигурации, который
затрагивает аспекты хранения файла, доступность особенностей и характеристики
ввода/вывода. С MySQL MySQL 5.6.7
<a href="innodb.htm#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> включена по умолчанию.</p>

<p>При включении <a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> Вы можете составить таблицу в ее собственном
<span><strong>файле .ibd</strong></span> вместо совместно используемых
<span><strong>файлов ibdata</strong></span> <span><strong>системного
табличного пространства</strong></span>. Когда табличные данные хранятся в
отдельном <span><strong>файле .ibd</strong></span>,
у Вас есть больше гибкости, чтобы выбрать
<span><strong>форматы строки</strong></span>, требуемые для таких
особенностей, как <span><strong>сжатие</strong></span>. <code>TRUNCATE TABLE
</code> также быстрее, и пустое пространство, может использоваться
операционной системой вместо того, чтобы остаться
сохраненным для <code>InnoDB</code>.</p>

<p><span><strong>MySQL Enterprise Backup</strong></span>
более гибок для таблиц, которые находятся в их собственных файлах. Например,
таблицы могут быть исключены из резервного копирования, но только если они
находятся в отдельных файлах. Таким образом, эта установка является
подходящей для таблиц, которые поддерживаются менее часто
или в различном графике.</p>

<p>См. <a href="#glos_compressed_row_format">
compressed row format</a>,
<a href="#glos_compression">compression</a>,
<a href="#glos_file_format">file format</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_ibdata_file">ibdata file</a>,
<a href="#glos_innodb_file_per_table">innodb_file_per_table</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_row_format">row format</a>,
<a href="#glos_system_tablespace">system tablespace</a>.</dd>

<dt><a name="glos_fill_factor"></a><span>Коэффициент заполнения</span></dt>
<dd><p>В <span><strong>индексе</strong></span> <code>InnoDB</code>
пропорция <span><strong>страницы</strong></span>, которая заполнена данными
прежде, чем страница будет разделена. Неиспользуемое место, когда индексные
данные разделены между страницами, учитывает строки, которые будут обновлены
с более длинными строковыми значениями, не требуя дорогого обслуживания
индекса. Если коэффициент заполнения слишком низок, индексирование занимает
больше места, чем необходимо, вызывая дополнительный ввод/вывод, читая
индексирование. Если коэффициент заполнения слишком высок, любое обновление,
которое увеличивает длину значений столбцов, может вызвать дополнительный
ввод/вывод для обслуживания индекса, см.
<a href="innodb.htm#innodb-physical-structure">раздел 16.8.10</a>.</p>
<p>См. <a href="#glos_index">index</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_fixed_row_format"></a><span>Фиксированный формат строки
</span></dt>
<dd><p>Этот формат строки используется <code>MyISAM</code>, а не
<code>InnoDB</code>. Если Вы создаете <code>InnoDB</code> с опцией
<code>ROW_FORMAT=FIXED</code> в MySQL 5.7.6 или раньше, <code>InnoDB</code>
использует <span><strong>компактный формат строки</strong></span>,
вместо этого, хотя значение <code>FIXED</code> все еще может быть в выводе
<code>SHOW TABLE STATUS</code>. С MySQL 5.7.7 <code>InnoDB</code>
возвращает ошибку, если определен <code>ROW_FORMAT=FIXED</code>.</p>
<p>См. <a href="#glos_compact_row_format">compact row format</a>,
<a href="#glos_row_format">row format</a>.</dd>

<dt><a name="glos_flush"></a><span>Сброс</span></dt>
<dd><p>Запись изменения файлов базы данных, которые были буферизованы в
области памяти или временной дисковой области хранения.
Структуры хранения <code>InnoDB</code>, которые периодически сбрасываются,
включают <span><strong>журнал redo</strong></span>, <span><strong>журнал
отмены</strong></span> и <span><strong>буферный пул</strong></span>.</p>

<p>Сброс может произойти, потому что область памяти становится полной
и система должна освободить некоторое пространство, потому что
<span><strong>передача</strong></span> означает, что изменения от транзакции
могут быть завершены, или потому что
<span><strong>медленное завершение работы</strong></span>
означает, что вся невыполненная работа должна быть завершена. Когда не важно
сбросить все буферизованные данные сразу, <code>InnoDB</code>
может использовать метод, названный
<span><strong>нечеткой установкой контрольных точек</strong></span>, чтобы
сбросить маленькие пакеты страниц.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_commit">commit</a>,
<a href="#glos_fuzzy_checkpointing">fuzzy checkpointing</a>,
<a href="#glos_redo_log">redo log</a>,
<a href="#glos_slow_shutdown">slow shutdown</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_flush_list"></a><span>Список сброса</span></dt>
<dd><p>Внутренняя структура данных <code>InnoDB</code>, которая отслеживает
<span><strong>грязные страницы</strong></span> в <span><strong>буферном пуле
</strong></span>: то есть, <span><strong>страницы</strong></span>, которые
были изменены и должны быть записаны на диск. Эта структура данных часто
обновляется внутренними <span><strong>минитранзакциями</strong></span>
и защищена собственным <span><strong>mutex</strong></span>, чтобы позволить
параллельный доступ к буферному пулу.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_lru">LRU</a>,
<a href="#glos_mini_transaction">mini-transaction</a>,
<a href="#glos_mutex">mutex</a>,
<a href="#glos_page">page</a>,
<a href="#glos_page_cleaner">page cleaner</a>.</dd>

<dt><a name="glos_foreign_key"></a><span>Внешний ключ</span></dt>
<dd><p>Тип отношений указателя, между строками в отдельных таблицах
<code>InnoDB</code>. Отношения внешнего ключа определены на одном столбце в
<span><strong>родительской таблице</strong></span> и в
<span><strong>дочерней таблице</strong></span>.</p>

<p>В дополнение к включению быстрого поиска соответствующей информации,
внешние ключи помогают провести в жизнь <span><strong>ссылочную целостность
</strong></span>, препятствуя любому из этих указателей стать недопустимым,
когда данные вставлены, обновлены и удалены. Этот механизм осуществления тип
<span><strong>ограничения</strong></span>. Строка, которая указывает на
другую таблицу, не может быть вставлена, если связанное значение внешнего
ключа не существует в другой таблице. Если строка удалена, или ее значение
внешнего ключа изменилось, и строки в другой таблице указывают на то значение
внешнего ключа, внешний ключ может быть настроен, чтобы предотвратить
удаление, заставить соответствующие значения столбцов в другой таблице
становиться <span><strong>null</strong></span>
или автоматически удалять соответствующие строки в другой таблице.</p>

<p>Один из этапов в разработке <span><strong>нормализованной</strong></span>
базы данных должен идентифицировать данные, которые дублированы, выделить те
данные в новую таблицу и настроить отношения внешнего ключа так, чтобы
многократные таблицы могли быть запрошены как единственная таблица,
используя работу <span><strong>соединения</strong></span>.</p>

<p>См. <a href="#glos_child_table">child table</a>,
<a href="#glos_foreign_key_constraint">FOREIGN KEY constraint</a>,
<a href="#glos_join">join</a>,
<a href="#glos_normalized">normalized</a>,
<a href="#glos_null">NULL</a>,
<a href="#glos_parent_table">parent table</a>,
<a href="#glos_referential_integrity">referential integrity</a>,
<a href="#glos_relational">relational</a>.</dd>

<dt><a name="glos_foreign_key_constraint"></a><span>Ограничение FOREIGN KEY
</span></dt>
<dd><p>Тип <span><strong>ограничения</strong></span>, которое поддерживает
последовательность базы данных через отношения <span><strong>внешнего ключа
</strong></span>. Как другие виды ограничений, это может препятствовать тому,
чтобы данные были вставлены или обновлены, если данные стали бы
непоследовательными, в этом случае предотвращается несогласованность между
данными в многократных таблицах. Альтернативно, когда работа
<span><strong>DML</strong></span> выполнена, ограничения <code>FOREIGN KEY
</code> могут удалить данные в <span><strong>дочерних строках</strong>
</span>, изменить на различные значения или установить в
<span><strong>null</strong></span>, исходя из опции <code>ON CASCADE</code>,
которая была определена, создавая внешний ключ.</p>

<p>См. <a href="#glos_child_table">child table</a>,
<a href="#glos_constraint">constraint</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_null">NULL</a>.</dd>

<dt><a name="glos_fts"></a><span>FTS</span></dt>
<dd><p>В большинстве контекстов сокращение от <span><strong>full-text
search</strong></span>. Иногда в исполнительных обсуждениях сокращение для
<span><strong>full table scan</strong></span>.</p>
<p>См. <a href="#glos_full_table_scan">full table scan</a>,
<a href="#glos_full_text_search">full-text search</a>.</dd>

<dt><a name="glos_full_backup"></a><span>Полное резервное копирование</span>
</dt>
<dd><p><span><strong>Резервное копирование</strong></span>, которое включает
все <span><strong>таблицы</strong></span> в каждой
<span><strong>базе данных</strong></span> MySQL и все базы данных в
<span><strong>экземпляре</strong></span> MySQL.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_database">database</a>,
<a href="#glos_instance">instance</a>,
<a href="#glos_partial_backup">partial backup</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_full_table_scan"></a><span>Полное сканирование таблицы
</span></dt>
<dd><p>Работа, которая требует чтения всего содержания таблицы, а не только
выбранных частей, используя <span><strong>индекс</strong></span>.
Как правило, выполняется с маленькими таблицами поиска или в ситуациях со
складированием данных в больших таблицах, где все доступные данные соединены
и проанализированы. Как часто эти операции происходят и размеры таблиц
относительно доступной памяти, имеет значение для алгоритмов, используемых в
оптимизации запроса и управлении <span><strong>буферным пулом</strong>
</span>.</p>

<p>Цель индексов это позволить поиски для определенных значений или
диапазонов значений в пределах большой таблицы, таким образом избегая
полного сканирования таблицы.</p>
<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_index">index</a>.</dd>

<dt><a name="glos_full_text_search"></a><span>Полнотекстовый поиск</span>
</dt>
<dd><p>Возможность для того, чтобы найти слова, фразы, булевы комбинации
слов и так далее в пределах табличных данных более быстрым, удобным и гибким
способом, чем использование SQL <code>LIKE</code>. Это использует функцию SQL
<a href="funct.htm#function_match"><code>MATCH()</code></a> и
<span><strong>индексы FULLTEXT</strong></span>.</p>
<p>См. <a href="#glos_fulltext_index">FULLTEXT index</a>.</dd>

<dt><a name="glos_fulltext_index"></a><span>Индекс FULLTEXT</span></dt>
<dd><p>Спецвид <span><strong>индекса</strong></span>, который хранит
<span><strong>поисковый индекс</strong></span> в механизме
<span><strong>полнотекстового поиска</strong></span> MySQL.
Представляет слова от значений столбца, опуская любые, которые определены как
<span><strong>стоп-слова</strong></span>. Первоначально доступен только для
<code>MyISAM</code>. Начиная с MySQL 5.6.4, это также доступно
для таблиц <span><strong>InnoDB</strong></span>.</p>

<p>См. <a href="#glos_full_text_search">full-text search</a>,
<a href="#glos_index">index</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_search_index">search index</a>,
<a href="#glos_stopword">stopword</a>.</dd>

<dt><a name="glos_fuzzy_checkpointing"></a><span>
Нечеткая установка контрольных точек</span></dt>
<dd><p>Метод, который <span><strong>сбрасывает</strong></span> маленькие
пакеты <span><strong>грязных страниц</strong></span> из
<span><strong>буферного пула</strong></span>, вместо того, чтобы сбросить все
грязные страницы сразу, что разрушило бы обработку базы данных.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_flush">flush</a>.</p></dd></dl>

<h3>G</h3>
<dl><dt><a name="glos_ga"></a><span>GA</span></dt>
<dd><p>"Generally available", этап, когда программный продукт оставляет
статус <span><strong>beta</strong></span> и доступен для продажи, официальной
поддержки и производственного использования.</p>
<p>См. <a href="#glos_beta">beta</a>.</dd>

<dt><a name="glos_gap"></a><span>Промежуток</span></dt>
<dd><p>Место в структуре данных <span><strong>индекса</strong></span>,
где новые значения могли быть вставлены. Когда Вы блокируете ряд строк таким
запросом, как <code>SELECT ... FOR UPDATE</code>, <code>InnoDB</code>
может создать блокировки, которые относятся к промежуткам так же, как к
фактическим значениям в индексировании. Например, если Вы выбираете все
значения, больше 10 для обновления, блокировка промежутка препятствует тому,
чтобы другая транзакция вставила новое значение, которое больше 10.
<span><strong>Запись supremum</strong></span> и <span><strong>запись infimum
</strong></span> представляют промежутки, содержащие все значения, больше или
меньше, чем все текущие значения индекса.</p>

<p>См. <a href="#glos_concurrency">concurrency</a>,
<a href="#glos_gap_lock">gap lock</a>,
<a href="#glos_index">index</a>,
<a href="#glos_infimum_record">infimum record</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_supremum_record">supremum record</a>.</dd>

<dt><a name="glos_gap_lock"></a><span>Блокировка промежутка</span></dt>
<dd><p><span><strong>Блокировка</strong></span> на
<span><strong>промежутке</strong></span> между индексными записями
или блокировка на промежутке перед первой или после последней записи.
Например, <code>SELECT c1 FOR UPDATE FROM t WHERE c1 BETWEEN 10 and 20;
</code> препятствует тому, чтобы другие транзакции вставили значение 15 в
столбец <code>t.c1</code>, неважно, было ли уже какое-либо такое значение в
столбце, потому что промежутки между всеми существующими
значениями в диапазоне заблокированы.</p>

<p>Блокировки промежутка используются в некоторых
операционных <span><strong>уровнях изоляции</strong></span>.</p>
<p>См. <a href="#glos_gap">gap</a>,
<a href="#glos_infimum_record">infimum record</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_next_key_lock">next-key lock</a>,
<a href="#glos_record_lock">record lock</a>,
<a href="#glos_supremum_record">supremum record</a>.</dd>

<dt><a name="glos_general_log"></a><span>Общий журнал</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_general_query_log">
Общий журнал запросов</a>.</dd>

<dt><a name="glos_general_query_log"></a><span>Общий журнал запросов</span>
</dt>
<dd><p>Тип <span><strong>журнала</strong></span>, используемого для
диагностики и поиска неисправностей запросов SQL, обработан сервером MySQL.
Может быть сохранен в файле или в таблице базы данных.
Вы должны активировать это через опцию
<a href="server.htm#sysvar_general_log"><code>general_log</code></a>.
Вы можете отключить это для определенного соединения через
опцию <a href="server.htm#sysvar_sql_log_off"><code>sql_log_off</code></a>.
</p>

<p>Делает запись более широкого диапазона запросов, чем
<span><strong>медленный журнал запроса</strong></span>. В отличие от
<span><strong>двоичного журнала</strong></span>, который используется для
репликации, общий журнал запроса содержит запросы
<a href="sql.htm#select"><code>SELECT</code></a> и не поддерживает строгое
упорядочивание. Для получения дополнительной информации см.
<a href="server.htm#query-log">раздел 6.4.3</a>.</p>

<p>См. <a href="#glos_binary_log">binary log</a>,
<a href="#glos_log">log</a>,
<a href="#glos_slow_query_log">slow query log</a>.</dd>

<dt><a name="glos_general_tablespace"></a><span>Общее табличное пространство
</span></dt>
<dd><p>Совместно используемое <code>InnoDB</code>
<span><strong>табличное пространство</strong></span>, созданное
<a href="sql.htm#create-tablespace"><code>CREATE TABLESPACE</code></a>.
Общие табличные пространства могут быть созданы за пределами каталога данных
MySQL, способны к хранению многих <span><strong>таблиц</strong></span> и
поддерживают таблицы всех форматов строки. Общие табличные пространства
были введены в MySQL 5.7.6.</p>

<p>Таблицы добавлены к общему табличному пространству через
<a href="sql.htm#create-table"><code>CREATE TABLE
<em><code>tbl_name</code></em> ... TABLESPACE [=]
<em><code>tablespace_name</code></em></code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> TABLESPACE [=]
<em><code>tablespace_name</code></em></code></a>.</p>
<p>См. <a href="innodb.htm#general-tablespaces">раздел 16.7.9</a>.</p>

<p>См. <a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_table">table</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_generated_column"></a><span>Произведенный столбец</span>
</dt>
<dd><p>Столбец, значения которого вычислены от выражения, включенного в
определение столбца. Произведенный столбец может быть <span><strong>
виртуальным</strong></span> или <span><strong>сохраненным</strong></span>.
</p>

<p>См. <a href="#glos_base_column">base column</a>,
<a href="#glos_generated_stored_column">generated stored column
</a>, <a href="#glos_generated_virtual_column">
generated virtual column</a>.</dd>

<dt><a name="glos_generated_stored_column"></a><span>
Произведенный сохраненный столбец</span></dt>
<dd><p>Столбец, значения которого вычислены от выражения, включенного в
определение столбца. Значения столбцов оценены и сохранены, когда строки
вставлены или обновлены. Сохраненный столбец требует места для хранения и
может быть индексирован.</p>

<p>См. <a href="#glos_base_column">base column</a>,
<a href="#glos_generated_column">generated column</a>,
<a href="#glos_generated_virtual_column">generated virtual column
</a>.</dd>

<dt><a name="glos_generated_virtual_column"></a><span>
Произведенный виртуальный столбец</span></dt>
<dd><p>Столбец, значения которого вычислены от выражения, включенного в
определение столбца. Значения столбцов не сохранены, но оценены, когда строки
считаны, немедленно после любого триггера <code>BEFORE</code>.
Виртуальный столбец не занимает места. <code>InnoDB</code> допускает
вторичные индексы на произведенных виртуальных столбцах.</p>

<p>См. <a href="#glos_base_column">base column</a>,
<a href="#glos_generated_column">generated column</a>,
<a href="#glos_generated_stored_column">generated stored column
</a>.</dd>

<dt><a name="glos_global_transaction"></a><span>Глобальная транзакция
</span></dt>
<dd><p>Тип <span><strong>транзакции</strong></span>, вовлеченной в операции
<span><strong>XA</strong></span>. Это состоит из нескольких действий, которые
являются транзакционными, но все должны завершиться успешно как группа, или
все быть отменены. В основном, это расширяет свойства
<span><strong>ACID</strong></span> так, чтобы многократные транзакции ACID
могли быть выполнены как компоненты глобальной работы, у которой также
есть свойства ACID.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_xa">XA</a>.</dd>

<dt><a name="glos_group_commit"></a><span>Групповая передача</span></dt>
<dd><p>В оптимизации <code>InnoDB</code>, которая выполняет некоторые
низкоуровневые операции ввода/вывода однажды для ряда
<span><strong>передач</strong></span> вместо того, чтобы
синхронизировать отдельно для каждой.</p>

<p>Когда <span><strong>двоичный журнал</strong></span> включен, Вы, как
правило, также устанавливаете параметр конфигурации
<code>sync_binlog=0</code>, потому что групповая передача для двоичного
журнала, поддержана только, если это установлено в 0.</p>
<p>См. <a href="#glos_binary_log">binary log</a>,
<a href="#glos_commit">commit</a>.</p></dd></dl>

<h3>H</h3>
<dl><dt><a name="glos_hash_index"></a><span>Хэш-индекс</span></dt>
<dd><p>Тип <span><strong>индекса</strong></span>
предназначенный для запросов, которые используют операторы равенства вместо
таких операторов, как больше чем или <code>BETWEEN</code>. Это доступно для
таблиц <a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>.
Хотя хеш-индекс это индекс по умолчанию для
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
по историческим причинам, этот механизм хранения также поддерживает
индексы <span><strong>B-tree</strong></span>, которые часто являются лучшим
выбором для запросов общего назначения.</p>

<p>MySQL включает разновидность этого индекса
<span><strong>адаптивный хеш-индекс</strong></span>,
который создан автоматически для <a href="innodb.htm"><code>InnoDB</code>
</a>, если нужно во время выполнения.</p>

<p>См. <a href="#glos_adaptive_hash_index">adaptive hash index
</a>, <a href="#glos_b_tree">B-tree</a>,
<a href="#glos_index">index</a>,
<a href="#glos_innodb">InnoDB</a>.</dd>

<dt><a name="glos_hdd"></a><span>HDD</span></dt>
<dd><p>Сокращение для "hard disk drive". Относится к жестким дискам
обычно сравниваясь и контрастируя с <span><strong>SSD</strong></span>.
Его технические характеристики могут влиять на пропускную способность.</p>
<p>См. <a href="#glos_disk_based">disk-based</a>,
<a href="#glos_ssd">SSD</a>.</dd>

<dt><a name="glos_heartbeat"></a><span>Биение</span></dt>
<dd><p>Периодическое сообщение, которое посылают, чтобы указать, что система
функционирует должным образом. В контексте
<span><strong>репликации</strong></span>, если
<span><strong>ведущее устройство</strong></span>
прекращает посылать такие сообщения, одно из
<span><strong>ведомых устройств</strong></span> может занять его место.
Подобные методы могут использоваться между серверами в окружающей среде
кластера, чтобы подтвердить, что все они действуют должным образом.</p>
<p>См. <a href="#glos_master_server">master server</a>,
<a href="#glos_replication">replication</a>.</dd>

<dt><a name="glos_high_water_mark"></a><span>Верхняя метка</span></dt>
<dd><p>Значение, представляющее верхний предел или жесткий предел,
который не должен быть превышен во время выполнения, или максимальное
значение, которое было фактически достигнуто.</p>
<p>См. <a href="#glos_low_water_mark">low-water mark</a>.</dd>

<dt><a name="glos_history_list"></a><span>Список истории</span></dt>
<dd><p>Список <span><strong>транзакций</strong></span> с записями,
отмеченными как удаленные, для работы
<code>InnoDB</code> <span><strong>очистки</strong></span>.
Зарегистрирован в <span><strong>журнале отмены</strong></span>. О длине
списка истории сообщает команда <code>SHOW ENGINE INNODB STATUS</code>.
Если список истории становится более длинным, чем значение
<a href="innodb.htm#sysvar_innodb_max_purge_lag"><code>innodb_max_purge_lag
</code></a>, каждый запрос <span><strong>DML</strong></span>
отсрочен немного, чтобы позволить работе чистки заканчивать
<span><strong>сброс</strong></span> удаленных записей.</p>

<p>Также известно как <span><strong>задержка чистки</strong></span>.</p>
<p>См. <a href="#glos_dml">DML</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_purge">purge</a>,
<a href="#glos_purge_lag">purge lag</a>,
<a href="#glos_rollback_segment">rollback segment</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_hole_punching"></a><span>hole punching</span></dt>
<dd><p>Выпуск пустых блоков страницы.
<code>InnoDB</code> <span><strong>прозрачное сжатие страницы</strong></span>
полагается на поддержку hole punching. См.
<a href="innodb.htm#innodb-page-compression">раздел 16.9.2</a>.</p>

<p>См. <a href="#glos_sparse_file">sparse file</a>,
<a href="#glos_transparent_page_compression">
transparent page compression</a>.</dd>

<dt><a name="glos_hot"></a><span>Горячий</span></dt>
<dd><p>Условие, где к строке, таблице или внутренней структуре данных
получают доступ так часто, требуя некоторой формы блокировки или взаимного
исключения, что это приводит к проблеме масштабируемости или работы.</p>

<p>Хотя &quot;горячий&quot; как правило указывает на нежелательное условие,
<span><strong>горячее резервное копирование</strong></span>
это привилегированный тип резервного копирования.</p>
<p>См. <a href="#glos_hot_backup">hot backup</a>.</dd>

<dt><a name="glos_hot_backup"></a><span>Горячее резервное копирование
</span></dt>
<dd><p>Резервное копирование в то время, как база данных работает, и
приложения читают и пишут ее. Резервное копирование вовлекает больше, чем
простое копирование файлов с данными: это должно включать любые данные,
которые были вставлены или обновлены, в то время как резервное копирование
было в процессе, это должно исключить любые данные, которые были удалены, в
то время как резервное копирование было в процессе, и это должно
проигнорировать любые изменения, которые не были переданы.</p>

<p>Продукт Oracle, который выполняет горячие резервные копии, ориентирован на
<code>InnoDB</code>, но также и на таблицы <code>MyISAM</code> и другие
механизмы хранения. Это <span><strong>MySQL Enterprise Backup</strong>
</span>.</p>

<p>Горячий резервный процесс состоит из двух этапов. Копирование
файлов с данными производит <span><strong>сырое резервное копирование
</strong></span>. Шаг <span><strong>применения</strong></span> включает любые
изменения базы данных, которые произошли в то время, как резервное
копирование работало. Применение изменений производит
<span><strong>готовое</strong></span> резервное копирование: эти файлы готовы
быть восстановленными всякий раз, когда необходимо.</p>

<p>См. <a href="#glos_apply">apply</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_prepared_backup">prepared backup</a>,
<a href="#glos_raw_backup">raw backup</a>.</p></dd></dl>

<h3>I</h3>
<dl><dt><a name="glos_ibd_file"></a><span>Файл .ibd</span></dt>
<dd><p>Файл с данными для табличных пространств
<span><strong>file-per-table</strong></span>
и общих табличных пространств. Табличное пространство File-per-table
содержит единственную таблицу и связанный индексные данные.
<span><strong>Общее табличное пространство</strong></span>
может содержать таблицу и индексные данные для многих таблиц.</p>

<p>Файл <code>.ibd</code> не относится к <span><strong>системному табличному
пространству</strong></span>, которое состоит из одного или
более <span><strong>файлов ibdata</strong></span>.</p>

<p>Если табличное пространство file-per-table
или общее табличное пространство создаются с <code>DATA DIRECTORY =</code>,
файл <code>.ibd</code> расположен в указанном пути вне
нормального каталога данных.</p>

<p>Когда файл <code>.ibd</code> включен в сжатое резервное копирование
<span><strong>MySQL Enterprise Backup</strong></span>,
сжатый эквивалент это файл <code>.ibz</code>.</p>

<p>См. <a href="#glos_database">database</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_ibdata_file">ibdata file</a>,
<a href="#glos_ibz_file">.ibz file</a>,
<a href="#glos_innodb_file_per_table">innodb_file_per_table</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>,
<a href="#glos_system_tablespace">system tablespace</a>.</dd>

<dt><a name="glos_ibz_file"></a><span>Файл .ibz</span></dt>
<dd><p>Когда <span><strong>MySQL Enterprise Backup</strong></span>
выполняет <span><strong>сжатое резервное копирование</strong></span>,
он преобразовывает каждый файл <span><strong>табличного пространства</strong>
</span>, который создается, используя <span><strong>file-per-table</strong>
</span> из <code>.ibd</code> в <code>.ibz</code>.</p>

<p>Сжатие, примененное во время резервного копирования, отлично от
<span><strong>сжатого формата строки</strong></span>, который сохраняет
табличные данные сжатыми во время нормального функционирования. Сжатая
резервная работа пропускает шаг сжатия для табличного пространства, которое
уже находится в сжатом формате строки, поскольку сжатие во второй раз
замедлило бы резервное копирование, но произвело бы небольшие или
никакие сбережения пространства.</p>

<p>См. <a href="#glos_compressed_backup">compressed backup</a>,
<a href="#glos_compressed_row_format">compressed row format</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_io_bound"></a><span>I/O-bound</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_disk_bound">disk-bound
</a>.</dd>

<dt><a name="glos_ib_file_set"></a><span>Набор файлов ib</span></dt>
<dd><p>Набор файлов, которыми управляет <code>InnoDB</code>
в пределах базы данных MySQL: <span><strong>системное табличное пространство
</strong></span>, файлы табличного пространства
<span><strong>file-per-table</strong></span> и файлы
<span><strong>журнала redo</strong></span>.
В зависимости от версии MySQL и <code>InnoDB</code> конфигурация, может также
включать <span><strong>общее табличное пространство</strong></span>,
<span><strong>временное табличное пространство</strong></span> и
<span><strong>табличное пространство отмены</strong></span>.
Этот термин иногда используется в детальных обсуждениях структуры файла и
форматов, чтобы обратиться к набору файлов, которыми управляет
<code>InnoDB</code> в пределах базы данных MySQL.</p>

<p>См. <a href="#glos_database">database</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_redo_log">redo log</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_temporary_tablespace">temporary tablespace</a>,
<a href="#glos_undo_tablespace">undo tablespace</a>.</dd>

<dt><a name="glos_ibbackup_logfile"></a><span>ibbackup_logfile</span></dt>
<dd><p>Дополнительный резервный файл создан
<span><strong>MySQL Enterprise Backup</strong></span> во время
<span><strong>горячей резервной копии</strong></span>.
Это содержит информацию о любых изменениях данных, которые произошли в то
время, как резервное копирование работало. Начальные резервные файлы, включая
<code>ibbackup_logfile</code>, известны как
<span><strong>сырое резервное копирование</strong></span>,
потому что изменения, которые произошли во время резервной работы, еще не
включены. После того, как Вы выполняете шаг
<span><strong>применения</strong></span> к сырым резервным файлам,
получающиеся файлы действительно включают те заключительные изменения данных,
и известны как <span><strong>готовое резервное копирование</strong></span>.
На данном этапе файл <code>ibbackup_logfile</code> больше не необходим.</p>

<p>См. <a href="#glos_apply">apply</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_prepared_backup">prepared backup</a>,
<a href="#glos_raw_backup">raw backup</a>.</dd>

<dt><a name="glos_ibdata_file"></a><span>Файл ibdata</span></dt>
<dd><p>Ряд файлов с именами вроде <code>ibdata1</code>,
<code>ibdata2</code> и т.д., которые составляет <span><strong>системное
табличное пространство</strong></span> InnoDB. Эти файлы содержат метаданные
о <code>InnoDB</code> (<span><strong>словарь данных</strong></span>
<code>InnoDB</code>) и области хранения для одного или более
<span><strong>журналов отмены</strong></span>, <span><strong>буфера изменения
</strong></span> и <span><strong>буфера doublewrite</strong></span>. Они
также могут содержать некоторые или все табличные данные (в зависимости от
того, включен ли режим <span><strong>file-per-table</strong></span>, когда
каждая таблица составлена). Когда включена опция
<span><strong>innodb_file_per_table</strong></span>, данные и индексы
для составленных таблиц сохранены в отдельных <span><strong>файлах .ibd
</strong></span>, а не в системном табличном пространстве.</p>

<p>Рост файлов <code>ibdata</code> управляется опцией
<a href="innodb.htm#sysvar_innodb_autoextend_increment"><code>
innodb_autoextend_increment</code></a>.</p>

<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_doublewrite_buffer">doublewrite buffer</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_innodb_file_per_table">innodb_file_per_table</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_ibtmp_file"></a><span>Файл ibtmp</span></dt>
<dd><p>Файл <span><strong>временного табличного пространства</strong></span>
для несжатых <span><strong>временных таблиц</strong></span> <code>InnoDB
</code> и связанных объектов. Опция конфигурационного файла
<a href="innodb.htm#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a> позволяет пользователям определять
относительный путь для временного файла с данными табличного пространства.
Если <a href="innodb.htm#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a> не определена, поведение по умолчанию
должно создать единственный автомасштабируемый файл <code>ibtmp1</code> в
12MB в каталоге данных рядом с <code>ibdata1</code>.</p>

<p>См. <a href="#glos_data_files">data files</a>,
<a href="#glos_temporary_table">temporary table</a>,
<a href="#glos_temporary_tablespace">temporary tablespace</a>.
</dd>

<dt><a name="glos_ib_logfile"></a><span>ib_logfile</span></dt>
<dd><p>Ряд файлов, как правило называемых <code>ib_logfile0</code> и
<code>ib_logfile1</code>, форма <span><strong>журнала redo</strong></span>.
Также иногда называется <span><strong>группой журнала</strong></span>.
Эти файлы делают запись запросов, которые пытаются изменить данные в
<code>InnoDB</code>. Эти запросы переигрываются автоматически, чтобы
исправить данные, написанные неполными транзакциями, при запуске
после катастрофического отказа.</p>

<p>Эти данные не могут использоваться для ручного восстановления, для этого
типа работы, используйте <span><strong>двоичный журнал</strong></span>.</p>
<p>См. <a href="#glos_binary_log">binary log</a>,
<a href="#glos_log_group">log group</a>,
<a href="#glos_redo_log">redo log</a>.</dd>

<dt><a name="glos_ilist"></a><span>ilist</span></dt>
<dd><p>В пределах <span><strong>индекса FULLTEXT</strong></span>
структура данных, состоящая из ID документа и информации о местонахождении
для маркера (то есть, особого слова).</p>
<p>См. <a href="#glos_fulltext_index">FULLTEXT index</a>.</dd>

<dt><a name="glos_implicit_row_lock"></a><span>Неявная блокировка строки
</span></dt>
<dd><p>Блокировка строки, приобретенная <code>InnoDB</code>,
чтобы гарантировать последовательность.</p>
<p>См. <a href="#glos_row_lock">row lock</a>.</dd>

<dt><a name="glos_in_memory_database"></a><span>База данных в памяти
</span></dt>
<dd><p>Тип системы базы данных, которая поддерживает данные в памяти,
чтобы избежать издержек из-за дискового ввода/вывода и перевода между
дисковыми блоками и областями памяти. Некоторые базы данных в памяти жертвуют
длительностью ("D" в <span><strong>ACID</strong></span>)
и уязвимы для аппаратных средств и других типов отказов, делая их более
подходящими для операций только для чтения. Другие базы данных в памяти
действительно используют механизмы длительности, такие как журналирование
изменений диска или использования энергонезависимой памяти.</p>

<p>Особенности MySQL, которые обращаются к тем же самым видам интенсивной
обработки памяти, включают <span><strong>буферный пул</strong></span>,
<span><strong>адаптивный хеш-индекс</strong></span> и оптимизация
<span><strong>только для чтения</strong></span>, механизм хранения
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>,
ключевой кэш <code>MyISAM</code> и кэш запросов MySQL.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_adaptive_hash_index">adaptive hash index</a>,
<a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_disk_based">disk-based</a>,
<a href="#glos_read_only_transaction">read-only transaction</a>.</dd>

<dt><a name="glos_incremental_backup"></a><span>incremental backup</span></dt>
<dd><p>Тип <span><strong>горячего резервного копирования</strong></span>,
выполненного <span><strong>MySQL Enterprise Backup</strong></span>, который
сохраняет только данные, измененные начиная с некоторого момента времени.
Наличие полного резервного копирования и последовательности возрастающих
резервных копий позволяет Вам восстанавливать резервные данные за длительный
период без издержек хранения нескольких полных резервных копий. Вы можете
восстановить полное резервное копирование и затем применить каждую из
возрастающих резервных копий по очереди, или Вы можете сохранить полное
резервное копирование современным, применяя каждое возрастающее резервное
копирование к этому, а затем выполнить единственную работу восстановления.
</p>

<p>Степень детализации измененных данных на уровне <span><strong>страницы
</strong></span>. Страница могла бы фактически покрыть больше, чем одну
строку. Каждая измененная страница включена в резервное копирование.</p>

<p>См. <a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_page">page</a>.</dd>

<dt><a name="glos_index"></a><span>Индекс</span></dt>
<dd><p>Структура данных, которая обеспечивает быструю способность поиска
<span><strong>строк</strong></span> <span><strong>таблицы</strong></span>,
как правило, формируя древовидную структуру (<span><strong>B-дерево)</strong>
</span>, представляющее все значения особого
<span><strong>столбца</strong></span> или набора столбцов.</p>

<p>У таблицы <code>InnoDB</code> всегда есть <span><strong>кластеризируемый
индекс</strong></span>, представление <span><strong>первичного ключа</strong>
</span>. Они могут также иметь один или более <span><strong>вторичных
индексов</strong></span>, определенных на одном или более столбцах. В
зависимости от структуры, вторичный индекс может быть классифицирован как
<span><strong>частичный</strong></span>, <span><strong>столбцовый</strong>
</span> или <span><strong>составной</strong></span>.</p>

<p>Индекс это решающий аспект работы <span><strong>запроса</strong></span>.
Архитекторы базы данных разрабатывают таблицы, запросы и индексы, чтобы
позволить быстрые поиски для данных, необходимых приложениям.
Идеальное проектирование баз данных использует
<span><strong>покрывающий индекс</strong></span>, результаты запроса
вычислены полностью от индекса, не читая фактические табличные данные. Каждое
ограничение <span><strong>внешнего ключа</strong></span> также требует
индексирования, чтобы эффективно проверить, существуют ли значения в
<span><strong>родительских</strong></span> и
<span><strong>дочерних</strong></span> таблицах.</p>

<p>Хотя B-дерево индекса наиболее распространено, иной вид структуры данных
используется для <span><strong>хэш-индексов</strong></span>, как в механизме
хранения <code>MEMORY</code> и <span><strong>адаптивном хэш-индексе</strong>
</span> <code>InnoDB</code>. Индексы <span><strong>R-tree</strong></span>
используются для пространственной индексации многомерной информации.</p>

<p>См. <a href="#glos_adaptive_hash_index">adaptive hash index
</a>, <a href="#glos_b_tree">B-tree</a>,
<a href="#glos_child_table">child table</a>,
<a href="#glos_clustered_index">clustered index</a>,
<a href="#glos_column_index">column index</a>,
<a href="#glos_composite_index">composite index</a>,
<a href="#glos_covering_index">covering index</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_hash_index">hash index</a>,
<a href="#glos_parent_table">parent table</a>,
<a href="#glos_partial_index">partial index</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_query">query</a>,
<a href="#glos_r_tree">R-tree</a>,
<a href="#glos_row">row</a>,
<a href="#glos_secondary_index">secondary index</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_index_cache"></a><span>Кэш индекса</span></dt>
<dd><p>Область памяти, которая содержит маркерные данные для
<span><strong>полнотекстового поиска</strong></span>. Это буферизует данные,
чтобы минимизировать дисковый ввод/вывод, когда данные вставлены или
обновлены в столбцах, которые являются частью <span><strong>индекса FULLTEXT
</strong></span>. Маркерные данные написаны на диск, когда индексный кэш
становится полным. Каждый индекс <code>FULLTEXT</code>
имеет его собственный отдельный индексный кэш, размером которого управляет
параметр конфигурации <a href="innodb.htm#sysvar_innodb_ft_cache_size"><code>
innodb_ft_cache_size</code></a>.</p>
<p>См. <a href="#glos_full_text_search">full-text search</a>,
<a href="#glos_fulltext_index">FULLTEXT index</a>.</dd>

<dt><a name="glos_index_condition_pushdown"></a><span>
index condition pushdown</span></dt>
<dd><p>Index condition pushdown (ICP) это оптимизация, которая продвигает
часть выражения <code>WHERE</code> вниз к механизму хранения, если части
условия могут быть оценены, используя области <span><strong>индекса</strong>
</span>. ICP может уменьшить число раз, которое <span><strong>механизм
хранения</strong></span> должен получить доступ к базовой таблице и число
раз, которое сервер MySQL должен получить доступ к механизму хранения. Для
получения дополнительной информации см.
<a href="optimiz.htm#index-condition-pushdown-optimization">раздел 9.2.1.6
</a>.</p>
<p>См. <a href="#glos_index">index</a>,
<a href="#glos_storage_engine">storage engine</a>.</dd>

<dt><a name="glos_index_hint"></a><span>Индексные подсказки</span></dt>
<dd><p>Расширенный синтаксис SQL для того, чтобы переопределить
<span><strong>индексы</strong></span>, рекомендуемые оптимизатором.
Например, <code>FORCE INDEX</code>, <code>USE INDEX</code> и
<code>IGNORE INDEX</code>. Как правило, использутся, когда индексированные
столбцы неравно распределили значения, приводящие к неточным
оценкам <span><strong>количества элементов</strong></span>.</p>
<p>См. <a href="#glos_cardinality">cardinality</a>,
<a href="#glos_index">index</a>.</dd>

<dt><a name="glos_index_prefix"></a><span>Префикс индекса</span></dt>
<dd><p>В <span><strong>индексе</strong></span>, который относится к многим
столбцам (известен как <span><strong>сводный индекс</strong></span>),
ведущие столбцы индекса. Запрос, который ссылается на первые 1, 2, 3 и т.д.
столбцы сводного индекса, может использовать индексирование, даже если
запрос не ссылается на все столбцы в индексе.</p>
<p>См. <a href="#glos_composite_index">composite index</a>,
<a href="#glos_index">index</a>.</dd>

<dt><a name="glos_index_statistics"></a><span>Индексная статистика</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_statistics">
statistics</a>.</dd>

<dt><a name="glos_infimum_record"></a><span>Запись infimum</span></dt>
<dd><p><span><strong>Псевдозапись</strong></span> в
<span><strong>индексе</strong></span>, представляющая
<span><strong>промежуток</strong></span> ниже самого маленького значения в
этом индексе. Если у транзакции есть такой запрос, как
<code>SELECT ... FOR UPDATE ... WHERE col &lt; 10;</code>,
и самое маленькое значение в столбце 5, это блокировка на infimum, которая
препятствует тому, чтобы другие транзакции вставили еще меньшие значения,
такие как 0, -10 и так далее.</p>

<p>См. <a href="#glos_gap">gap</a>,
<a href="#glos_index">index</a>,
<a href="#glos_pseudo_record">pseudo-record</a>,
<a href="#glos_supremum_record">supremum record</a>.</dd>

<dt><a name="glos_information_schema"></a><span>INFORMATION_SCHEMA</span></dt>
<dd><p>Название <span><strong>базы данных</strong></span>, которая
обеспечивает интерфейс запроса к <span><strong>словарю данных</strong></span>
MySQL. Это имя определено стандартом ANSI SQL. Чтобы исследовать информацию
(метаданные) о базе данных, Вы можете запросить такие таблицы, как
<code>INFORMATION_SCHEMA.TABLES</code> и
<code>INFORMATION_SCHEMA.COLUMNS</code> вместо использования команды
<code>SHOW</code>, которая производит неструктурированный вывод.</p>

<p>Информационная схема содержит некоторые таблицы, которые являются
определенными для <span><strong>InnoDB</strong></span>, например,
<a href="inform.htm#innodb-locks-table"><code>INNODB_LOCKS</code></a> и
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>.
Вы используете эти таблицы, чтобы не видеть, как база данных структурирована,
но получить информацию в реальном времени о работах таблиц InnoDB, чтобы
помочь с исполнительным контролем, настройкой и поиском неисправностей.
В частности, эти таблицы предоставляют информацию об особенностях MySQL,
связанных с <span><strong>сжатием</strong></span>, <span><strong>транзакциями
</strong></span> и их связанными <span><strong>блокировками</strong></span>.
</p>

<p>См. <a href="#glos_compression">compression</a>,
<a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_database">database</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_innodb"></a><span>InnoDB</span></dt>
<dd><p>Компонент MySQL, который комбинирует высокую производительность с
<span><strong>транзакционными</strong></span> возможностями.
Это воплощает <span><strong>ACID</strong></span>. Представлен как
<span><strong>механизм хранения</strong></span>, это обрабатывает таблицы,
создаваемые или измененные с <code>ENGINE=INNODB</code>, см.
<a href="innodb.htm">главу 16</a> и
<a href="optimiz.htm#optimizing-innodb">раздел 9.5</a>.</p>

<p>В MySQL 5.5 и выше InnoDB механизм хранения значения по умолчанию для
новых таблиц и <code>ENGINE=INNODB</code> не требуется. В MySQL 5.1
многие из усовершенствованных особенностей InnoDB требуют включения
компонента InnoDB Plugin. См. <a href="innodb.htm#innodb-introduction">раздел
16.1</a>.</p>

<p>Таблицы InnoDB идеально удовлетворяют требования для
<span><strong>горячих резервных копий</strong></span>. См.
<a href="mysql.htm#mysql-enterprise-backup">раздел 27.2</a>.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_storage_engine">storage engine</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_innodb_autoinc_lock_mode"></a><span>
innodb_autoinc_lock_mode</span></dt>
<dd><p>Опция <a href="innodb.htm#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> управляет алгоритмом, используемым для
<span><strong>блокировки auto-increment</strong></span>.
Когда у Вас есть постепенно увеличивающийся <span><strong>первичный ключ
</strong></span>, Вы можете использовать основанную на запросе репликацию
только с установкой <a href="innodb.htm#sysvar_innodb_autoinc_lock_mode">
<code>innodb_autoinc_lock_mode=1</code></a>. Эта установка известна как
<span><strong>последовательный</strong></span> режим блокировки, потому что
мультистрочная вставка в пределах транзакции, получает последовательные
значения auto-increment. Если Вы имеете
<code>innodb_autoinc_lock_mode=2</code>, который позволяет более высокий
параллелизм для операций вставки, используйте основанную на строке
репликацию, а не основанную на запросе. Эта установка известна как
<span><strong>чередованный</strong></span> режим блокировки, потому что
мультистрочные вставки, работающие в то же самое время, могут получить
значения autoincrement, которые чередованы. Установка
<code>innodb_autoinc_lock_mode=0</code> это предыдущая (традиционная)
настройка по умолчанию и не должна использоваться за
исключением целей совместимости.</p>

<p>См. <a href="#glos_auto_increment_locking">
auto-increment locking</a>,
<a href="#glos_mixed_mode_insert">mixed-mode insert</a>,
<a href="#glos_primary_key">primary key</a>.</dd>

<dt><a name="glos_innodb_file_per_table"></a><span>innodb_file_per_table
</span></dt>
<dd><p>Важный параметр конфигурации, который затрагивает много аспектов
хранения файла InnoDB, доступности особенностей и характеристик ввода/вывода.
В MySQL 5.6.7 и выше это включено по умолчанию. До MySQL 5.6.7 это отключено
по умолчанию. <a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> включает режим
<span><strong>file-per-table</strong></span>.
С этим включенным режимом недавно составленная таблица InnoDB и связанный
индекс могут быть сохранены в отдельном <span><strong>файле .ibd</strong>
</span> вне <span><strong>системного табличного пространства</strong></span>.
</p>

<p>Эта опция затрагивает соображения работы и хранения для многих запросов
SQL, например, <a href="sql.htm#drop-table"><code>DROP TABLE</code></a> и
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>.</p>

<p>Включение <a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> позволяет Вам использовать в своих интересах
другие особенности, такие как табличное
<span><strong>сжатие</strong></span> и резервные копии названных таблиц в
<span><strong>MySQL Enterprise Backup</strong></span>.</p>

<p><a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> была статичной, но теперь может быть
установлена, используя <a href="sql.htm#set-variable"><code>SET GLOBAL</code>
</a>.</p>

<p>Для информации см. <a href="innodb.htm#innodb-multiple-tablespaces">раздел
16.7.4</a>.</p>
<p>См. <a href="#glos_compression">compression</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_system_tablespace">system tablespace</a>.</dd>

<dt><a name="glos_innodb_lock_wait_timeout"></a><span>
innodb_lock_wait_timeout</span></dt>
<dd><p>Опция <a href="innodb.htm#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a> устанавливает баланс между <span><strong>
ожиданием</strong></span> совместно используемых ресурсов или отказом и
обработкой ошибки, повторением или выполнением альтернативы в Вашем
приложении. Отменяет любую транзакцию InnoDB, которая ждет больше, чем
требуемое время, чтобы приобрести <span><strong>блокировку</strong></span>.
Особенно полезно, если <span><strong>тупики</strong></span> вызваны
обновлениями многих таблиц, которыми управляют различные механизмы хранения,
такие тупики не <span><strong>обнаружены</strong></span> автоматически.</p>

<p>См. <a href="#glos_deadlock">deadlock</a>,
<a href="#glos_deadlock_detection">deadlock detection</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_wait">wait</a>.</dd>

<dt><a name="glos_innodb_strict_mode"></a><span>innodb_strict_mode</span></dt>
<dd><p>Опция <a href="innodb.htm#sysvar_innodb_strict_mode"><code>
innodb_strict_mode</code></a> управляет, работает ли InnoDB в
<span><strong>строгом режиме</strong></span>, где условия, которые обычно
обрабатываются как предупреждения, вызывают ошибки вместо этого (и основные
запросы терпят неудачу).</p>
<p>Этот режим настройка по умолчанию в MySQL 5.5.5 и выше.</p>
<p>См. <a href="#glos_strict_mode">strict mode</a>.</dd>

<dt><a name="glos_insert"></a><span>insert</span></dt>
<dd><p>Одна из основных операций <span><strong>DML</strong></span> в
<span><strong>SQL</strong></span>. Исполнение вставок это ключевой фактор в
системах <span><strong>хранилищ данных</strong></span>, которые загружают
миллионы строк в таблицы, и систем <span><strong>OLTP</strong></span>, где
много параллельных соединений могли бы вставить строки в ту же самую таблицу
в произвольном порядке. Если вставка важна для Вас, Вы должны узнать об
особенностях <span><strong>InnoDB</strong></span>, таких как <span><strong>
буфер вставки</strong></span>, используемый в <span><strong>буферизации
изменения</strong></span>, и столбцах
<span><strong>auto-increment</strong></span>.</p>

<p>См. <a href="#glos_auto_increment">auto-increment</a>,
<a href="#glos_change_buffering">change buffering</a>,
<a href="#glos_data_warehouse">data warehouse</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_insert_buffer">insert buffer</a>,
<a href="#glos_oltp">OLTP</a>,
<a href="#glos_sql">SQL</a>.</dd>

<dt><a name="glos_insert_buffer"></a><span>Буфер вставки</span></dt>
<dd><p>Прежнее название <span><strong>буфера изменения</strong></span>. В
MySQL 5.5 была добавлена поддержка, чтобы буферизовать изменения вторичных
индексных страниц для <a href="sql.htm#delete"><code>DELETE</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>.
Ранее только изменения, следующие из <a href="sql.htm#insert"><code>INSERT
</code></a>, были буферизованы. Привилегированный термин теперь
<span><strong>буфер изменения</strong></span>.</p>
<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_change_buffering">change buffering</a>.</dd>

<dt><a name="glos_insert_buffering"></a><span>Буферизация вставки</span></dt>
<dd><p>Метод хранения изменений вторичных индексных страниц из
<a href="sql.htm#insert"><code>INSERT</code></a> в
<span><strong>буфере изменения</strong></span> вместо того, чтобы немедленно
записать изменения, чтобы минимизировать случайный ввод/вывод. Это один из
типов <span><strong>буферизации изменения</strong></span>.</p>

<p>Буферизация не используется, если вторичные индексы
<span><strong>уникальны</strong></span>, потому что уникальность новых
значений не может быть проверена прежде, чем новые записи записаны. Другие
виды буферизации изменения действительно работают на уникальных индексах.</p>

<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_change_buffering">change buffering</a>,
<a href="#glos_delete_buffering">delete buffering</a>,
<a href="#glos_insert_buffer">insert buffer</a>,
<a href="#glos_purge_buffering">purge buffering</a>,
<a href="#glos_unique_index">unique index</a>.</dd>

<dt><a name="glos_insert_intention_lock"></a><span>
Блокировка намерения вставки</span></dt>
<dd><p>Тип блокировки промежутка, которая установлена
<a href="sql.htm#insert"><code>INSERT</code></a> до вставки строки.
Этот тип блокировки сигнализирует намерение вставить таким способом, которым
многократные транзакции, вставляющие в тот же самый индексный промежуток, не
должны ждать друг друга, если они не вставляют в ту же самую позицию в
пределах промежутка. Для получения дополнительной информации см.
<a href="innodb.htm#innodb-locking">раздел 16.5.1</a>.</p>

<p>См. <a href="#glos_gap_lock">gap lock</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_next_key_lock">next-key lock</a>.</dd>

<dt><a name="glos_instance"></a><span>Экземпляр</span></dt>
<dd><p>Один демон <span><strong>mysqld</strong></span> управляющий
<span><strong>каталогом данных</strong></span>, представляющим одну или более
<span><strong>баз данных</strong></span> с рядом <span><strong>таблиц
</strong></span>. Распространено в развитии, тестировании и некоторых
сценариях <span><strong>репликации</strong></span> иметь многократные
экземпляры на той же самой машине, каждый управляющий собственным каталогом
данных и слушающий на собственном порту или сокете. С одним экземпляром,
выполняющим <span><strong>disk-bound</strong></span> нагрузку,
у сервера могли бы все еще быть дополнительные ресурсы центральныого
процессора и объем памяти, чтобы выполнить дополнительные экземпляры.</p>

<p>См. <a href="#glos_data_directory">data directory</a>,
<a href="#glos_database">database</a>,
<a href="#glos_disk_bound">disk-bound</a>,
<a href="#glos_mysqld">mysqld</a>,
<a href="#glos_replication">replication</a>,
<a href="#glos_server">server</a>.</dd>

<dt><a name="glos_instrumentation"></a><span>Инструментовка</span></dt>
<dd><p>Модификации на уровне исходного кода, чтобы собрать характеристики для
настройки и отладки. В MySQL данные, собранные инструментовкой, выставлены
через интерфейс SQL, используя базы данных
<code>INFORMATION_SCHEMA</code> и <code>PERFORMANCE_SCHEMA</code>.</p>
<p>См. <a href="#glos_information_schema">INFORMATION_SCHEMA</a>,
<a href="#glos_performance_schema">Performance Schema</a>.</dd>

<dt><a name="glos_intention_exclusive_lock"></a><span>
Исключительная блокировка намерения</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_intention_lock">
intention lock</a>.</dd>

<dt><a name="glos_intention_lock"></a><span>Блокировка намерения</span></dt>
<dd><p>Подвид <span><strong>блокировки</strong></span>, которая относится к
табличному уровню, чтобы указывать, какую блокировку транзакция намеревается
приобрести на строках в таблице. Различные транзакции могут приобрести
различные виды намерения на ту же самую таблицу, но первая транзакция,
которая приобретет <span><strong>исключительную блокировку намерения</strong>
</span> (IX) препятствует тому, чтобы другие транзакции приобрели любые S или
X блокировки на таблице. Наоборот, первая транзакция, которая приобретет
<span><strong>совместно использованное намерение</strong></span> (IS),
препятствует тому, чтобы другие транзакции приобрели любую блокировку X.
Двухфазовый процесс позволяет запросам блокировки быть решенными в порядке,
не блокируя блокировки и соответствующие операции, которые совместимы. Для
большего количества деталей об этом механизме блокировки см.
<a href="innodb.htm#innodb-locking">раздел 16.5.1</a>.</p>

<p>См. <a href="#glos_lock">lock</a>,
<a href="#glos_lock_mode">lock mode</a>,
<a href="#glos_locking">locking</a>.</dd>

<dt><a name="glos_intention_shared_lock"></a><span>
Совместно использованная блокировка намерения</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_intention_lock">
intention lock</a>.</dd>

<dt><a name="glos_inverted_index"></a><span>Инвертированный индекс</span></dt>
<dd><p>Структура данных, оптимизированная для систем извлечения документа,
используемых в выполнении InnoDB <span><strong>полнотекстового поиска
</strong></span>. InnoDB <span><strong>индекс FULLTEXT</strong></span>,
осуществленный как инвертированный индекс, делает запись позиции каждого
слова в пределах документа, а не местоположения строки таблицы. Единственное
значение столбца (документ, хранимый как текстовая строка), представлено
многими записями в инвертированном индексе.</p>

<p>См. <a href="#glos_full_text_search">full-text search</a>,
<a href="#glos_fulltext_index">FULLTEXT index</a>,
<a href="#glos_ilist">ilist</a>.</dd>

<dt><a name="glos_iops"></a><span>IOPS</span></dt>
<dd><p>Сокращение от <span><strong>I/O operations per second</strong></span>.
Общее измерение для занятых систем, особенно приложений
<span><strong>OLTP</strong></span>. Если это значение около максимума,
который могут обработать устройства хранения данных, приложение может стать
<span><strong>disk-bound</strong></span>,
ограничивая <span><strong>масштабируемость</strong></span>.</p>

<p>См. <a href="#glos_disk_bound">disk-bound</a>,
<a href="#glos_oltp">OLTP</a>,
<a href="#glos_scalability">scalability</a>.</dd>

<dt><a name="glos_isolation_level"></a><span>Уровень изоляции</span></dt>
<dd><p>Один из фондов обработки базы данных. Изоляция это
<span><strong>I</strong></span> в <span><strong>ACID</strong></span>,
уровень изоляции это установка, которая точно настраивает баланс между
работой и надежностью, последовательностью и воспроизводимостью результатов,
когда многократные <span><strong>транзакции</strong></span>
производят изменения и выполняют запросы в то же самое время.</p>

<p>От самого высокого количества последовательности и защиты к наименьшей,
уровни изоляции, поддержанные InnoDB:
<span><strong>SERIALIZABLE</strong></span>,
<span><strong>REPEATABLE READ</strong></span>,
<span><strong>READ COMMITTED</strong></span> и
<span><strong>READ UNCOMMITTED</strong></span>.</p>

<p>С InnoDB много пользователей могут сохранить уровень изоляции по умолчанию
(<span><strong>REPEATABLE READ</strong></span>) для всех операций. Опытные
пользователи могли бы выбрать <span><strong>read committed</strong></span>,
поскольку они продвигают границы масштабируемости с обработкой OLTP, или во
время операций складирования данных, где незначительные несогласованности не
затрагивают совокупные результаты больших объемов данных. Уровни на краях
(<span><strong>SERIALIZABLE</strong></span> и
<span><strong>READ UNCOMMITTED</strong></span>) изменяют поведение обработки
до такой степени, что они редко используются.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_read_committed">READ COMMITTED</a>,
<a href="#glos_read_uncommitted">READ UNCOMMITTED</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_serializable">SERIALIZABLE</a>,
<a href="#glos_transaction">transaction</a>.</p></dd></dl>

<h3>J</h3>
<dl><dt><a name="glos_join"></a><span>join</span></dt>
<dd><p><span><strong>Запрос</strong></span>, который получает данные больше,
чем от одной таблицы, ссылаясь на столбцы в таблицах, которые содержат
идентичные значения. Идеально, эти столбцы часть отношений
<span><strong>внешнего ключа</strong></span> InnoDB, которые гарантируют
<span><strong>ссылочную целостность</strong></span> и что столбцы соединения
<span><strong>индексированы</strong></span>. Часто используется, чтобы
оставить свободное место и улучшить работу запроса, заменяя повторенные
строки числовыми ID в <span><strong>нормализованном</strong>
</span> проекте данных.</p>

<p>См. <a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_index">index</a>,
<a href="#glos_normalized">normalized</a>,
<a href="#glos_query">query</a>,
<a href="#glos_referential_integrity">referential integrity</a>.
</p></dd></dl>

<h3>K</h3>
<dl><dt><a name="glos_key_block_size"></a><span>KEY_BLOCK_SIZE</span></dt>
<dd><p>Опция, чтобы определить размер страниц данных в пределах таблицы
InnoDB, которая использует <span><strong>сжатый формат строки</strong></span>.
Значение по умолчанию составляет 8 килобайт. Нижние значения рискуют поражать
внутренние пределы, которые зависят от комбинации размера
строки и процента сжатия.</p>
<p>См. <a href="#glos_compressed_row_format">
compressed row format</a>.</p></dd></dl>

<h3>L</h3>
<dl><dt><a name="glos_latch"></a><span>latch</span></dt>
<dd><p>Легкая структура, используемая InnoDB, чтобы осуществить
<span><strong>блокировку</strong></span> для ее собственных внутренних
структур памяти, как правило проводимых в течение краткого времени,
измеренного в миллисекундах или микросекундах. Общий термин, который включает
<span><strong>mutexes</strong></span> (для эксклюзивного доступа) и
<span><strong>rw-блокировки</strong></span> (для совместно используемого
доступа). Определенные структуры центр исполнительной настройки InnoDB, такой
как <span><strong>словарь данных</strong></span> mutex. Статистические данные
об использовании доступны через интерфейс <span><strong>Performance Schema
</strong></span>.</p>

<p>См. <a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_mutex">mutex</a>,
<a href="#glos_performance_schema">Performance Schema</a>,
<a href="#glos_rw_lock">rw-lock</a>.</dd>

<dt><a name="glos_list"></a><span>Список</span></dt>
<dd><p><span><strong>Буферный пул</strong></span> представлен как список
<span><strong>страниц</strong></span> в памяти. Список переупорядочен по
мере работы со страницами. Буферный пул фактически разделен на
<span><strong>подсписки</strong></span>, и политика замены это изменение
знакомого метода <span><strong>LRU</strong></span>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_eviction">eviction</a>,
<a href="#glos_lru">LRU</a>,
<a href="#glos_sublist">sublist</a>.</dd>

<dt><a name="glos_lock"></a><span>Блокировка</span></dt>
<dd><p>Высокоуровневое понятие объекта, который управляет доступом к ресурсу,
такому как таблица, строка или внутренняя структура данных, как часть
стратегии <span><strong>блокировки</strong></span>. Для интенсивной
исполнительной настройки Вы могли бы копаться в фактических структурах,
которые осуществляют блокировки, например,
<span><strong>mutexes</strong></span> и
<span><strong>latches</strong></span>.</p>

<p>См. <a href="#glos_latch">latch</a>,
<a href="#glos_lock_mode">lock mode</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_mutex">mutex</a>.</dd>

<dt><a name="glos_lock_escalation"></a><span>Подъем блокировки</span></dt>
<dd><p>Работа в некоторых системах базы данных, которая преобразовывает много
блокировок строки в единственную табличную блокировку, сохраняя место в
памяти, но уменьшая параллельный доступ к таблице. InnoDB использует
эффективное представление для блокировок строки, чтобы подъем блокировки
не был необходим.</p>

<p>См. <a href="#glos_locking">locking</a>,
<a href="#glos_row_lock">row lock</a>,
<a href="#glos_table_lock">table lock</a>.</dd>

<dt><a name="glos_lock_mode"></a><span>Режим блокировки</span></dt>
<dd><p>Совместно используемая блокировка (S)
позволяет транзакции читать строку. Многократные транзакции могут приобрести
блокировку S на ту же самую строку в то же самое время.</p>

<p>Исключительная блокировка (X) позволяет транзакции обновлять или удалять
строку. Никакая другая транзакция не может приобрести такую блокировку
на ту же самую строку в то же самое время.</p>

<p><span><strong>Блокировки намерения</strong></span> относятся к табличному
уровню и используются, чтобы указать, какую блокировку транзакция
намеревается приобрести на строках в таблице. Различные транзакции могут
приобрести различные виды намерения на ту же самую таблицу, но первая
транзакция, которая приобретет исключительное намерение (IX)
препятствует тому, чтобы другие транзакции приобрели любую S или X
на таблице. Наоборот, первая транзакция, которая приобретет совместно
использованное намерение (IS) препятствует тому, чтобы другие транзакции
приобрели любую блокировку X на таблицу. Двухфазовый процесс позволяет
запросам блокировки быть решенными в порядке, не блокируя блокировки и
соответствующие операции, которые совместимы.</p>

<p>См. <a href="#glos_intention_lock">intention lock</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_locking">locking</a>.</dd>

<dt><a name="glos_locking"></a><span>Блокировка</span></dt>
<dd><p>Система защиты <span><strong>транзакции</strong></span> от наблюдения
или изменения данных, которые запрашиваются или изменяются другими
транзакциями. Стратегия блокировки должна сбалансировать надежность и
последовательность операций базы данных (принципы
<span><strong>ACID</strong></span>). Точная настройка стратегии блокировки
часто вовлекает выбор <span><strong>уровня изоляции</strong></span> и
обеспечение того, что все Ваши операции базы данных безопасны и надежны для
этого уровня изоляции.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_concurrency">concurrency</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_latch">latch</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_mutex">mutex</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_locking_read"></a><span>Блокировка чтения</span></dt>
<dd><p><a href="sql.htm#select"><code>SELECT</code></a>, который также
выполняет работу <span><strong>блокировки</strong></span> на таблице
<code>InnoDB</code>. Также <a href="sql.htm#select"><code>SELECT ... FOR
UPDATE</code></a> или <code>SELECT ... LOCK IN SHARE MODE</code>.
У этого есть потенциал, чтобы произвести <span><strong>тупик</strong></span>,
в зависимости от <span><strong>уровня изоляции</strong></span> транзакции.
Противоположность <span><strong>чтения без блокировки</strong></span>. Не
позволяет глобальные таблицы в <span><strong>транзакции только для чтения
</strong></span>.</p>

<p>См. <a href="#glos_deadlock">deadlock</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_non_locking_read">non-locking read</a>,
<a href="#glos_read_only_transaction">
read-only transaction</a>.</dd>

<dt><a name="glos_log"></a><span>Журнал</span></dt>
<dd><p>В контексте InnoDB <span><span>журнал</span></span> или <span><span>
файлы журнала</span></span> как правило обращается к <span><strong>журналу
redo</strong></span> представленному файлами
<span><strong>ib_logfile*</strong></span>.
Другой областью журнала, которая может быть физически частью
<span><strong>системного табличного пространства</strong></span>,
является <span><strong>журнал отмены</strong></span>.</p>

<p>Другие виды журналов, которые важны в MySQL, являются <span><strong>
журналом ошибок</strong></span> (для того, чтобы диагностировать запуск и
проблемы во время выполнения), <span><strong>двоичный журнал</strong></span>
(для того, чтобы работать с репликацией и выполнить восстановления момента
времени), <span><strong>общий журнал запроса</strong></span> (для того, чтобы
диагностировать проблемы приложения) и <span><strong>медленный журнал запроса
</strong></span> (для того, чтобы диагностировать исполнительные проблемы).
</p>

<p>См. <a href="#glos_binary_log">binary log</a>,
<a href="#glos_error_log">error log</a>,
<a href="#glos_general_query_log">general query log</a>,
<a href="#glos_ib_logfile">ib_logfile</a>,
<a href="#glos_redo_log">redo log</a>,
<a href="#glos_slow_query_log">slow query log</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_log_buffer"></a><span>Буфер журнала</span></dt>
<dd><p>Область памяти, которая хранит данные, которые будут написаны
в <span><strong>файлы системного журнала</strong></span>, которые составляют
<span><strong>журнал redo</strong></span>. Этим управляется опцией
<a href="innodb.htm#sysvar_innodb_log_buffer_size"><code>
innodb_log_buffer_size</code></a>.</p>
<p>См. <a href="#glos_log_file">log file</a>,
<a href="#glos_redo_log">redo log</a>.</dd>

<dt><a name="glos_log_file"></a><span>Файл системного журнала</span></dt>
<dd><p>Один из файлов <code>ib_logfile<em><code>N</code></em></code>, которые
составляют <span><strong>журнал redo</strong></span>. Данные записаны в эти
файлам из <span><strong>буферной</strong></span>
области памяти <span><strong>журнала</strong></span>.</p>

<p>См. <a href="#glos_ib_logfile">ib_logfile</a>,
<a href="#glos_log_buffer">log buffer</a>,
<a href="#glos_redo_log">redo log</a>.</dd>

<dt><a name="glos_log_group"></a><span>Группа журнала</span></dt>
<dd><p>Набор файлов, которые составляют <span><strong>журнал redo</strong>
</span>, обычно <code>ib_logfile0</code> и <code>ib_logfile1</code>.
По этой причине иногда упоминаемые все вместе как
<span><strong>ib_logfile</strong></span>.</p>
<p>См. <a href="#glos_ib_logfile">ib_logfile</a>,
<a href="#glos_redo_log">redo log</a>.</dd>

<dt><a name="glos_logical"></a><span>Логический</span></dt>
<dd><p>Тип работы, которая вовлекает высокий уровень, абстрактные аспекты,
такие как таблицы, запросы, индексы и другие понятия SQL. Как правило,
логические аспекты важны, чтобы сделать управление базами данных и разработку
приложений удобными и применимыми.</p>
<p>См. <a href="#glos_logical_backup">logical backup</a>,
<a href="#glos_physical">physical</a>.</dd>

<dt><a name="glos_logical_backup"></a><span>Логическое резервное копирование
</span></dt>
<dd><p><span><strong>Резервное копирование</strong></span>, которое
воспроизводит структуру таблицы и данные, не копируя фактические файлы с
данными. Например, <span><strong><code>mysqldump</code></strong></span>
производит логическое резервное копирование, потому что его вывод содержит
такой запрос, как <code>CREATE TABLE</code> или <code>INSERT</code>,
а это может обновить данные. Логическое резервное копирование предлагает
гибкость (например, Вы могли отредактировать табличные определения или
вставить запрос прежде, чем восстановить), но может занять существенно больше
времени, чтобы <span><strong>восстановить</strong></span>, чем
физическое резервное копирование.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_mysqldump">mysqldump</a>,
<a href="#glos_physical_backup">physical backup</a>,
<a href="#glos_restore">restore</a>.</dd>

<dt><a name="glos_loose_"></a><span>loose_</span></dt>
<dd><p>В MySQL 5.1 префикс, добавленный к параметрам конфигурации InnoDB,
устанавливая <span><strong>Plugin</strong></span> после запуска сервера,
таким образом, любые новые параметры конфигурации, не признанные текущим
уровнем MySQL, не вызывают отказ запуска. MySQL обрабатывает параметры
конфигурации, которые запускаются с этого префикса, но дает предупреждение, а
не отказ, если часть после префикса это не признанная опция.</p>
<p>См. <a href="#glos_plugin">plugin</a>.</dd>

<dt><a name="glos_low_water_mark"></a><span>Нижняя метка</span></dt>
<dd><p>Значение, представляющее низкий предел, как правило, пороговое
значение, в котором некоторое корректирующее действие начинается или
становится более агрессивным.</p>
<p>См. <a href="#glos_high_water_mark">high-water mark</a>.</dd>

<dt><a name="glos_lru"></a><span>LRU</span></dt>
<dd><p>Сокращение от "least recently used", общепринятая методика для того,
чтобы управлять областями хранения. Элементы, которые не использовались
недавно, <span><strong>вычеркнуты</strong></span>, когда пространство
необходимо, чтобы кэшировать более новые элементы. InnoDB использует механизм
LRU по умолчанию, чтобы управлять <span><strong>страницами</strong></span> в
<span><strong>буферном пуле</strong></span>, но делает исключения в случаях,
где страница могла бы быть только для чтения, как во время
<span><strong>полного сканирования таблицы</strong></span>. Это изменение
алгоритма LRU называют <span><strong>стратегией вставки середины</strong>
</span>. Пути, которыми буферное управление пула отличается от традиционного
алгоритма LRU, точно настроены опциями
<a href="innodb.htm#sysvar_innodb_old_blocks_pct"><code>innodb_old_blocks_pct
</code></a>, <a href="innodb.htm#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a> и новыми в MySQL 5.6
<a href="innodb.htm#sysvar_innodb_lru_scan_depth"><code>
innodb_lru_scan_depth</code></a> и
<a href="innodb.htm#sysvar_innodb_flush_neighbors"><code>
innodb_flush_neighbors</code></a>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_eviction">eviction</a>,
<a href="#glos_full_table_scan">full table scan</a>,
<a href="#glos_midpoint_insertion_strategy">
midpoint insertion strategy</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_lsn"></a><span>LSN</span></dt>
<dd><p>Сокращение от "log sequence number". Это произвольное, постоянно
увеличивающееся, значение представляет момент времени, соответствующий
операциям, зарегистрированным в <span><strong>журнале redo</strong></span>.
Этот момент времени независим от <span><strong>операционных</strong></span>
границ, это может упасть в середине одной или более транзакций. Это
используется внутренне InnoDB во время <span><strong>восстановления
катастрофического отказа</strong></span> и для того, чтобы
управлять буферным пулом.</p>

<p>До MySQL 5.6.3 LSN был 4-байтным unsigned integer. LSN стал 8-байтовым
unsigned integer в MySQL 5.6.3, когда предел размера файла системного журнала
увеличился с 4GB до 512GB, поскольку дополнительные байты были обязаны
хранить дополнительную информацию размера. Приложения, основанные на MySQL
5.6.3 или позже, которые используют значения LSN, должны теперь использовать
64-битовые, а не 32-битовые переменные, чтобы сохранить и
сравнить значения LSN.</p>

<p>В <span><strong>MySQL Enterprise Backup</strong></span>
Вы можете определить LSN, чтобы представить момент времени, от которого можно
взять <span><strong>возрастающее резервное копирование</strong></span>.
Соответствующий LSN выведен на экран выводом <code>mysqlbackup</code>.
Как только у Вас есть соответствие LSN времени полного резервного
копирования, Вы можете определить значение, чтобы взять последующее
возрастающее резервное копирование, вывод которого содержит другой LSN для
следующего возрастающего резервного копирования.</p>

<p>См. <a href="#glos_crash_recovery">crash recovery</a>,
<a href="#glos_incremental_backup">incremental backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_redo_log">redo log</a>,
<a href="#glos_transaction">transaction</a>.</p></dd></dl>

<h3>M</h3>
<dl><dt><a name="glos_mrg_file"></a><span>Файл .MRG</span></dt>
<dd><p>Файл, содержащий ссылки на другие таблицы, используемые
механизмом хранения <code>MERGE</code>. Файлы с этим расширением всегда
включаются в резервные копии, произведенные <code>mysqlbackup</code> из
<span><strong>MySQL Enterprise Backup</strong></span>.</p>

<p>См. <a href="#glos_mysql_enterprise_backup">
MySQL Enterprise Backup</a>,
<a href="#glos_mysqlbackup_command">mysqlbackup command</a>.</dd>

<dt><a name="glos_myd_file"></a><span>Файл .MYD</span></dt>
<dd><p>Файл, чтобы хранить данные для таблицы MyISAM.</p>
<p>См. <a href="#glos_myi_file">.MYI file</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>,
<a href="#glos_mysqlbackup_command">mysqlbackup command</a>.</dd>

<dt><a name="glos_myi_file"></a><span>Файл .MYI</span></dt>
<dd><p>Файл, чтобы хранить индексы для таблицы MyISAM.</p>
<p>См. <a href="#glos_myd_file">.MYD file</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup</a>,
<a href="#glos_mysqlbackup_command">mysqlbackup command</a>.</dd>

<dt><a name="glos_master_server"></a><span>Главный сервер</span></dt>
<dd><p>Часто &quot;ведущее устройство&quot;. Машина сервера базы данных в
сценарии <span><strong>репликации</strong></span>, который обрабатывает
начальные запросы вставки, обновления и удаления данных. Эти изменения
размножены и повторены на других серверах, известных
как <span><strong>ведомые серверы</strong></span>.</p>
<p>См. <a href="#glos_replication">replication</a>,
<a href="#glos_slave_server">slave server</a>.</dd>

<dt><a name="glos_master_thread"></a><span>Основной поток</span></dt>
<dd><p><span><strong>Поток</strong></span>, который выполняет различные
задачи в фоне. Большинство этих задач связаны с вводом/выводом, например,
запись <span><strong>буфера изменения</strong></span> в
соответствующие вторичные индексы.</p>

<p>Чтобы улучшить <span><strong>параллелизм</strong></span>, иногда действия
перемещены из основного потока, чтобы отделить фоновые потоки. Например, в
MySQL 5.6 и выше <span><strong>грязные страницы</strong></span>
<span><strong>сбрасываются</strong></span> из
<span><strong>буферного пула</strong></span> потоком
<span><strong>уборщика страницы</strong></span>, а не основным потоком.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_insert_buffer">insert buffer</a>,
<a href="#glos_page_cleaner">page cleaner</a>,
<a href="#glos_thread">thread</a>.</dd>

<dt><a name="glos_mdl"></a><span>MDL</span></dt>
<dd><p>Сокращение от <span><span>metadata lock</span></span>.</p>
<p>См. <a href="#glos_metadata_lock">metadata lock</a>.</dd>

<dt><a name="glos_memcached"></a><span>memcached</span></dt>
<dd><p>Популярный компонент многих стеков программного обеспечения MySQL и
<span><strong>NoSQL</strong></span>, позволяя быстро читать и писать
единственные значения и кэширование результатов полностью в памяти.
Традиционно, приложения требовали, чтобы дополнительная логика писала те же
самые данные в базу данных MySQL для постоянного хранения или читала данные
из базы данных MySQL, когда это еще не кэшировалось в памяти. Теперь
приложения могут использовать простой протокол
<span><strong>memcached</strong></span>, поддержанный библиотеками клиента
для многих языков, чтобы работать непосредственно с использованием серверов
MySQL или MySQL Cluster. Эти интерфейсы NoSQL к таблицам MySQL позволяют
приложениям достигать больших скоростей, чем выпуская запросы SQL
непосредственно, и могут упростить логику приложения и конфигурации
развертывания для систем, которые уже включили
<span><strong>memcached</strong></span> для кэширования в памяти.</p>

<p>Интерфейс <span><strong>memcached</strong></span> к таблицам InnoDB
доступен в MySQL 5.6 и выше, см.
<a href="innodb.htm#innodb-memcached">раздел 16.19</a>. Интерфейс
<span><strong>memcached</strong></span> к MySQL Cluster доступен в
MySQL Cluster 7.2, см.
<a href="../../../dev.mysql.com/doc/ndbapi/en/ndbmemcache.html" target="_top">
http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html</a>.</p>
<p>См. <a href="#glos_innodb">InnoDB</a>,
<a href="#glos_nosql">NoSQL</a>.</dd>

<dt><a name="glos_merge"></a><span>Слияние</span></dt>
<dd><p>Применяет изменения данных в памяти как тогда,
когда страница принесена в <span><strong>буферный пул</strong></span>, и
любые применимые изменения, зарегистрированные в
<span><strong>буфере изменения</strong></span>. Обновленные данные в конечном
счете написаны в <span><strong>табличное пространство</strong></span>
механизмом <span><strong>сброса</strong></span> данных.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_metadata_lock"></a><span>Блокировка метаданных</span></dt>
<dd><p>Тип <span><strong>блокировки</strong></span>, которая
предотвращает операции <span><strong>DDL</strong></span> на таблице, которая
используется в то же самое время другой <span><strong>транзакцией</strong>
</span>. Для деталей см. <a href="optimiz.htm#metadata-locking">раздел 9.11.4
</a>.</p>

<p>Улучшения операций <span><strong>онлайн</strong></span>, особенно в MySQL
5.6 и выше, сосредоточены на сокращении количества блокировки метаданных.
Цель для операций DDL, которые не изменяют структуру таблицы, например,
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a> и
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a> для
<code>InnoDB</code>: продолжиться в то время, как таблица запрашивается,
обновляется и так далее другими транзакциями.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_online">online</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_metrics_counter"></a><span>Счетчик метрик</span></dt>
<dd><p>Опция, реализованная таблицей
<a href="inform.htm#innodb-metrics-table">
<code>innodb_metrics</code></a> в
<span><strong>information_schema</strong></span> в MySQL 5.6 и выше.
Вы можете запросить <span><strong>counts</strong></span>
и общие количества для низкого уровня операции InnoDB, и использовать
результаты для работы, настраивающей комбинацию с данными
от <span><strong>performance_schema</strong></span>.</p>

<p>См. <a href="#glos_counter">counter</a>,
<a href="#glos_information_schema">INFORMATION_SCHEMA</a>,
<a href="#glos_performance_schema">Performance Schema</a>.</dd>

<dt><a name="glos_midpoint_insertion_strategy"></a><span>
Стратегия вставки середины</span></dt>
<dd><p>Метод начального обеспечения <span><strong>страниц</strong></span> в
<span><strong>буферном пуле</strong></span> InnoDB не в &quot;новейшем&quot;
конце списка, а вместо этого где-нибудь в середине. Точное местоположение
этого пункта может измениться, основанное на установке
<a href="innodb.htm#sysvar_innodb_old_blocks_pct"><code>
innodb_old_blocks_pct</code></a>. Намерение состоит в том, чтобы блоки,
которые только считаны, как во время <span><strong>полного сканирования
таблицы</strong></span>, могли быть удалены из буферного пула скорее, чем со
строгим алгоритмом <span><strong>LRU</strong></span>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_full_table_scan">full table scan</a>,
<a href="#glos_lru">LRU</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_mini_transaction"></a><span>Минитранзакция</span></dt>
<dd><p>Внутренняя фаза обработки InnoDB, производящая изменения на
<span><strong>физическом</strong></span> уровне внутренних структур данных во
время операций <span><strong>DML</strong></span>. У минитранзакции (mtr) нет
никакого понятия <span><strong>отмены</strong></span>, многократные
минитранзакции могут произойти в пределах единственной <span><strong>
транзакции</strong></span>. Минитранзакции пишут информацию в
<span><strong>журнал redo</strong></span>, который используется во время
<span><strong>восстановления катастрофического отказа</strong></span>.
Минитранзакция может также произойти вне контекста регулярной транзакции,
например во время обработки
<span><strong>чистки</strong></span> фоновыми потоками.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_crash_recovery">crash recovery</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_physical">physical</a>,
<a href="#glos_purge">purge</a>,
<a href="#glos_redo_log">redo log</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_mixed_mode_insert"></a><span>Смешанный режим вставки
</span></dt>
<dd><p><a href="sql.htm#insert"><code>INSERT</code></a>, где
<span><strong>auto-increment</strong></span> определены для некоторых, но не
всех новых строк. Например, <code>INSERT</code> может определить значение для
столбца auto-increment в некоторых случаях и <code>NULL</code> в других
случаях. <code>InnoDB</code> производит значения auto-increment
для строк, где значение столбца было определено как <code>NULL</code>. Другой
пример <a href="sql.htm#insert-on-duplicate"><code>INSERT ...
ON DUPLICATE KEY UPDATE</code></a>, где значения auto-increment
могли бы быть произведены, но не использоваться, для любых дублирующихся
строк, которые обработаны как <code>UPDATE</code> вместо <code>INSERT</code>.
</p>

<p>Может вызвать проблемы последовательности между
<span><strong>основными</strong></span> и <span><strong>ведомыми</strong>
</span> серверами в конфигурации <span><strong>репликации</strong></span>.
Может потребовать корректировки значения опции
<span><strong>innodb_autoinc_lock_mode</strong></span>.</p>

<p>См. <a href="#glos_auto_increment">auto-increment</a>,
<a href="#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode
</a>, <a href="#glos_master_server">master server</a>,
<a href="#glos_replication">replication</a>,
<a href="#glos_slave_server">slave server</a>.</dd>

<dt><a name="glos_mtr"></a><span>mtr</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_mini_transaction">
mini-transaction</a>.</dd>

<dt><a name="glos_multi_core"></a><span>multi-core</span></dt>
<dd><p>Тип процессора, который может использовать в своих интересах
мультипоточные программы, такие как сервер MySQL.</dd>

<dt><a name="glos_multiversion_concurrency_control"></a><span>
multiversion concurrency control</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_mvcc">MVCC</a>.</dd>

<dt><a name="glos_mutex"></a><span>mutex</span></dt>
<dd><p>Сокращение от "mutex variable". Mutex сам по себе сокращение от
"mutual exclusion". Низкоуровневый объект, используемый InnoDB, чтобы
представить и провести в жизнь <span><strong>блокировки</strong></span>
эксклюзивного доступа к внутренним структурам данных в памяти. Как только
блокировка приобретена, любому другому процессу, потоку и так далее
препятствуют приобрести ту же самую блокировку.
Mutexes и rw-блокировки известны все вместе как
<span><strong>latches</strong></span>.</p>

<p>См. <a href="#glos_latch">latch</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_performance_schema">Performance Schema</a>,
<a href="#glos_pthreads">Pthreads</a>,
<a href="#glos_rw_lock">rw-lock</a>.</dd>

<dt><a name="glos_mvcc"></a><span>MVCC</span></dt>
<dd><p>Сокращение от "multiversion concurrency control". Этот метод позволяет
<span><strong>транзакциям</strong></span> InnoDB с определенными
<span><strong>уровнями изоляции</strong></span> выполнить
<span><strong>последовательные</strong></span> операции
<span><strong>чтения</strong></span>, то есть, чтобы запросить строки,
которые обновляются другими транзакциями, и видеть значения до тех
обновлений. Это сильный метод увеличить <span><strong>параллелизм</strong>
</span>, позволяя запросам продолжиться, не ожидая из-за <span><strong>
блокировок</strong></span>, проводимых другими транзакциями.</p>

<p>Этот метод не универсален в мире баз данных. Некоторые другие продукты
базы данных и некоторые другие механизмы хранения MySQL не поддерживают это.
</p>
<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_concurrency">concurrency</a>,
<a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_my_cnf"></a><span>my.cnf</span></dt>
<dd><p>Имя файла опции MySQL в системах Unix или Linux.</p>
<p>См. <a href="#glos_my_ini">my.ini</a>,
<a href="#glos_option_file">option file</a>.</dd>

<dt><a name="glos_my_ini"></a><span>my.ini</span></dt>
<dd><p>Имя файла опции MySQL в системах Windows.</p>
<p>См. <a href="#glos_my_cnf">my.cnf</a>,
<a href="#glos_option_file">option file</a>.</dd>

<dt><a name="glos_mysql"></a><span>mysql</span></dt>
<dd><p>Интерпретатор командной строки для базы данных MySQL. Это обрабатывает
запросы <span><strong>SQL</strong></span>, а также команды MySQL, например,
<code>SHOW TABLES</code>, передавая запросы к
<span><strong><code>mysqld</code></strong></span>.</p>
<p>См. <a href="#glos_mysqld">mysqld</a>,
<a href="#glos_sql">SQL</a>.</dd>

<dt><a name="glos_mysql_enterprise_backup"></a><span>MySQL Enterprise Backup
</span></dt>
<dd><p>Имеющий лицензию продукт, который выполняет
<span><strong>горячие резервные копии</strong></span> баз данных MySQL.
Это предлагает больше эффективности и гибкости, поддерживая таблицы
<span><strong>InnoDB</strong></span>,
но может также поддержать MyISAM и другие виды таблиц.</p>
<p>См. <a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_innodb">InnoDB</a>.</dd>

<dt><a name="glos_mysqlbackup_command"></a><span>mysqlbackup</span></dt>
<dd><p>Инструмент командной строки <span><strong>MySQL
Enterprise Backup</strong></span>. Это выполняет <span><strong>
горячее резервирование</strong></span> для таблиц InnoDB и
<a href="#glos_warm_backup">теплое резервирование</a> для MyISAM
и других видов таблиц. См. <a href="mysql.htm#mysql-enterprise-backup">
раздел 27.2</a>.</p>

<p>См. <a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_warm_backup">warm backup</a>.</dd>

<dt><a name="glos_mysqld"></a><span>mysqld</span></dt>
<dd><p>Это собственно механизм базы данных MySQL. Это работает как демон Unix
или служба Windows, постоянно ждущая запросов и выполняющая
работу обслуживания в фоне.</p>
<p>См. <a href="#glos_mysql">mysql</a>.</dd>

<dt><a name="glos_mysqldump"></a><span>mysqldump</span></dt>
<dd><p>Команда, которая выполняет <span><strong>логическое резервное
копирование</strong></span> некоторой комбинации баз данных, таблиц и
табличных данных. Результаты это запросы SQL, которые воспроизводят
оригинальные объекты схемы, данные или то и другое. Для значительного
количества данных <span><strong>физическое резервное копирование</strong>
</span>, например, <span><strong>MySQL Enterprise Backup</strong></span>
быстрее, особенно для работы <span><strong>восстановления</strong></span>.
</p>

<p>См. <a href="#glos_logical_backup">logical backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_physical_backup">physical backup</a>,
<a href="#glos_restore">restore</a>.</p></dd></dl>

<h3>N</h3>
<dl><dt><a name="glos_natural_key"></a><span>Естественный ключ</span></dt>
<dd><p>Индексированный столбец, как правило, <span><strong>primary key
</strong></span>, где у значений есть некоторое значение реального мира.</p>

<ul><li><p>Если значение должно когда-либо изменяться, есть потенциально
много индексного обслуживания, чтобы изменить <span><strong>кластеризируемый
индекс</strong></span> и обновить копии значения первичного ключа, которые
повторены в каждом <span><strong>вторичном индексе</strong></span>.</li>

<li>Даже на вид устойчивые значения могут измениться непредсказуемыми
способами, которые трудно представить правильно в базе данных.
Например, одна страна может измениться на две или несколько,
делая оригинальный код страны устаревшим. Или у правил об уникальных
значениях могли бы быть исключения. Например, даже если удостоверения
личности налогоплательщика предназначены, чтобы быть уникальными для
единственного человека, базе данных, возможно, придется обработать отчеты,
которые нарушают это правило, как в случаях хищения личных данных.
Удостоверения личности налогоплательщика и другие чувствительные
идентификационные номера также делают бесполезными первичные ключи, потому
что они, возможно, должны быть обеспечены в зашифрованном виде и обработаны
по-другому, чем другие столбцы.</p></li></ul>

<p>Таким образом, как правило лучше использовать произвольные числовые
значения, чтобы сформировать <span><strong>синтетический ключ</strong>
</span>, например, используя <span><strong>столбец auto-increment</strong>
</span>.</p>

<p>См. <a href="#glos_auto_increment">auto-increment</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_secondary_index">secondary index</a>,
<a href="#glos_synthetic_key">synthetic key</a>.</dd>

<dt><a name="glos_neighbor_page"></a><span>Соседняя страница</span></dt>
<dd><p>Любая <span><strong>страница</strong></span> в том же самом
<span><strong>экстенте</strong></span>, как особая страница. Когда страница
выбрана, чтобы <span><strong>сбросить</strong></span>,
любые соседние страницы, которые <span><strong>грязные</strong></span>,
как правило, также сбрасываются, как оптимизация ввода/вывода для
традиционных жестких дисков. В MySQL 5.6 и выше
этим поведением может управлять переменная конфигурации
<a href="innodb.htm#sysvar_innodb_flush_neighbors"><code>
innodb_flush_neighbors</code></a>: Вы могли бы выключить ту установку для
дисков SSD, у которых нет таких издержек для того, чтобы написать
меньшие пакеты данных.</p>

<p>См. <a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_extent">extent</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_next_key_lock"></a><span>Блокировка следующего ключа</span>
</dt><dd><p>Комбинация <span><strong>блокировки записи</strong></span>
индекса и <a href="#glos_gap_lock">блокировки промежутка</a> на
промежутке перед индексной записью.</p>

<p>См. <a href="#glos_gap_lock">gap lock</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_record_lock">record lock</a>.</dd>

<dt><a name="glos_non_blocking_io"></a><span>Неблокирующий ввод/вывод</span>
</dt><dd><p>Промышленный термин, который означает то же самое, что и
<span><strong>asynchronous I/O</strong></span>.</p>
<p>См. <a href="#glos_asynchronous_io">asynchronous I/O</a>.</dd>

<dt><a name="glos_non_locking_read"></a><span>Чтение без блокировки</span></dt>
<dd><p><span><strong>Запрос</strong></span>, который не использует
<code>SELECT ... FOR UPDATE</code> или <code>SELECT ... LOCK IN SHARE MODE
</code>. Единственный вид запроса, который позволяет глобальные таблицы в
<span><strong>транзакции только для чтения</strong></span>.</p>

<p>См. <a href="#glos_locking_read">locking read</a>,
<a href="#glos_query">query</a>,
<a href="#glos_read_only_transaction">read-only transaction</a>.</dd>

<dt><a name="glos_non_repeatable_read"></a><span>Неповторимое чтение
</span></dt>
<dd><p>Ситуация, когда запрос получает данные, и более поздний запрос в
пределах той же самой <span><strong>транзакции</strong></span> получает то,
что должно быть теми же самыми данными, но запросы возвращают различные
результаты (изменены другой транзакцией, переданной тем временем).</p>

<p>Этот вид работы идет вразрез с <span><strong>ACID</strong></span>.
В пределах транзакции данные должны быть последовательными, с
предсказуемыми и устойчивыми отношениями.</p>

<p>Среди различных <span><strong>уровней изоляции</strong></span>
неповторимые чтения предотвращены уровнями
<span><strong>serializable read</strong></span> и
<span><strong>repeatable read</strong></span>, но разрешены на уровнях
<span><strong>consistent read</strong></span> и
<span><strong>read uncommitted</strong></span>.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_read_uncommitted">READ UNCOMMITTED</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_serializable">SERIALIZABLE</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_normalized"></a><span>normalized</span></dt>
<dd><p>Стратегия проектирования баз данных, где данные разделены на
многократные таблицы и двойные значения, сжатые в единственные строки,
представленные ID, чтобы избежать хранить, запрашивать и обновлять избыточные
или длинные значения. Это как правило
используется в приложениях <span><strong>OLTP</strong></span>.</p>

<p>Например, адресу можно было бы дать уникальный ID, чтобы база
данных переписи могла представить <span><strong>жизни</strong></span>
отношений <span><strong>в этом адресе</strong></span>, связывая
ID с каждым членом семьи, вместо того, чтобы хранить многократные копии
сложного значения, такие как <span><strong>123 Main Street, Anytown, USA
</strong></span>.</p>

<p>Для другого примера, хотя простое приложение адресной книги могло бы
сохранить каждый номер телефона в той же самой таблице как имя человека и
адрес, база данных телефонной компании могла бы дать каждому номеру телефона
специальный ID и сохранить числа и ID в отдельной таблице. Это
нормализованное представление могло упростить крупномасштабные обновления,
когда коды области разделяли обособленно.</p>

<p>Нормализация не всегда рекомендуется. Данные, которые прежде всего
запрошены и только обновлены, часто сохраняются в больших таблицах с
избыточными копиями двойных значений. Это представление данных упоминается
как <span><strong>denormalized</strong></span> и часто находится в
приложениях складирования данных.</p>

<p>См. <a href="#glos_denormalized">denormalized</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_oltp">OLTP</a>,
<a href="#glos_relational">relational</a>.</dd>

<dt><a name="glos_nosql"></a><span>NoSQL</span></dt>
<dd><p>Широкий термин для ряда технологий доступа к данным, которые не
используют язык <span><strong>SQL</strong></span> в качестве их основного
механизма для чтения и записи данных. Некоторый технологический акт NoSQL как
значение ключа хранит только единственное значение, что не требует
предварительно запланированной <span><strong>схемы</strong></span>.
Пользователи MySQL могут объединить обработку NoSQL-стиля для скорости и
простоты с операциями SQL для гибкости и удобства при использовании
<span><strong>memcached</strong></span> API, чтобы непосредственно получить
доступ к некоторым видам таблиц MySQL. Интерфейс <span><strong>memcached
</strong></span> к таблицам InnoDB доступен в MySQL 5.6 и выше, см.
<a href="innodb.htm#innodb-memcached">раздел 16.19</a>. Интерфейс
<span><strong>memcached</strong></span> к MySQL Cluster доступен в
MySQL Cluster 7.2, см.
<a href="../../../dev.mysql.com/doc/ndbapi/en/ndbmemcache.html"
target="_top">http://dev.mysql.com/doc/ndbapi/en/ndbmemcache.html</a>.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_memcached">memcached</a>,
<a href="#glos_schema">schema</a>,
<a href="#glos_sql">SQL</a>.</p></dd>

<dt><a name="glos_not_null_constraint"></a><span>Ограничение NOT NULL</span></dt>
<dd><p>Тип <span><strong>ограничения</strong></span>, которое определяет, что
<span><strong>столбец</strong></span> не может содержать
<span><strong>NULL</strong></span>. Это помогает сохранить
<span><strong>ссылочную целостность</strong></span>, поскольку сервер базы
данных может идентифицировать данные с ошибочными недостающими значениями.
Это также помогает в арифметике, вовлеченной в оптимизацию запроса, позволяя
оптимизатору предсказать число записей в индексе на этом столбце.</p>

<p>См. <a href="#glos_column">column</a>,
<a href="#glos_constraint">constraint</a>,
<a href="#glos_null">NULL</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_referential_integrity">referential integrity</a>.</dd>

<dt><a name="glos_null"></a><span>NULL</span></dt>
<dd><p>Специальное значение в <span><strong>SQL</strong></span> указывает на
отсутствие данных. Любая арифметическая работа или тест равенства,
вовлекающий <code>NULL</code>, вернет <code>NULL</code>.
Таким образом это подобно понятию IEEE с плавающей запятой NaN,
"not a number". Любое совокупное вычисление, такое как <code>AVG()</code>,
игнорирует строки с <code>NULL</code>. Единственный тест, который работает с
<code>NULL</code>, использует идиомы SQL <code>IS NULL</code> или
<code>IS NOT NULL</code>.</p>

<p><code>NULL</code> играют роль в индексе, потому что для работы база данных
должна минимизировать издержки отслеживания недостающих значений данных.
Как правило, <code>NULL</code> не сохранены в индексировании, потому что
запрос, который проверяет индексированный столбец, используя стандартный
оператор сравнения, никогда не мог соответствовать строке с
<code>NULL</code> для того столбца. По той же самой причине уникальный
индекс не предотвращает <code>NULL</code>, эти значения просто не
представлены в индексе. Объявление <code>NOT NULL</code> ограничение
на столбец обеспечивает, что нет никаких строк вне индекса, что упрощает
оптимизацию (точный подсчет строк и оценка того, использовать ли индекс).</p>

<p>Поскольку <span><strong>первичный ключ</strong></span> должен быть в
состоянии уникально идентифицировать каждую строку в таблице, первичный ключ
единственного столбца не может содержать <code>NULL</code>
и многостолбцовый первичный ключ не может содержать строки с
<code>NULL</code> во всех столбцах.</p>

<p>Хотя база данных Oracle позволяет <code>NULL</code>, которое будет связано
со строкой, InnoDB обрабатывает результат такой работы как <code>NULL</code>.
</p>
<p>См. <a href="#glos_index">index</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_sql">SQL</a>.</p></dd></dl>

<h3>O</h3>
<dl><dt><a name="glos_opt_file"></a><span>Файл .OPT</span></dt>
<dd><p>Файл, содержащий информацию о конфигурации базы данных. Файлы с этим
расширением всегда включаются в резервные копии, произведенные
<code>mysqlbackup</code> в <span><strong>MySQL Enterprise Backup</strong>
</span>.</p>

<p>См. <a href="#glos_mysql_enterprise_backup">
MySQL Enterprise Backup</a>,
<a href="#glos_mysqlbackup_command">mysqlbackup command</a>.
</p></dd>

<dt><a name="glos_off_page_column"></a><span>Столбец вне страницы</span></dt>
<dd><p>Столбец, содержащий данные переменной длины (<code>BLOB</code> и
<code>VARCHAR</code>), которые слишком длинные, чтобы разместить на странице
<span><strong>B-tree</strong></span>. Данные хранятся в <span><strong>
страницах переполнения</strong></span>. <code>DYNAMIC</code> формат строки в
формате файла <span><strong>Barracuda</strong></span>
InnoDB более эффективен для такого хранения, чем более старый
формат строки <code>COMPACT</code>.</p>
<p>См. <a href="#glos_b_tree">B-tree</a>,
<a href="#glos_overflow_page">overflow page</a>.</p></dd>

<dt><a name="glos_oltp"></a><span>OLTP</span></dt>
<dd><p>Сокращение для "Online Transaction Processing".
Система базы данных или приложение базы данных, которое выполняет рабочую
нагрузку со многими <span><strong>транзакциями</strong></span>, частыми
чтениями и записями, как правило затрагивая небольшие количества данных за
один раз. Например, система резервирования авиалинии или приложение, которое
обрабатывает вклады в банке. Данные могли бы быть организованы в
<span><strong>нормализованной</strong></span> форме для баланса между
эффективностью <span><strong>DML</strong></span>
(вставки/обновления/удаления) и <span><strong>запросов</strong></span>.</p>

<p>С <span><strong>блокировкой на уровне строки</strong></span> и
<span><strong>транзакционной</strong></span> способностью
<span><strong>InnoDB</strong></span> это идеальный механизм хранения для
таблиц MySQL, используемых в приложениях OLTP.</p>

<p>См. <a href="#glos_data_warehouse">data warehouse</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_query">query</a>,
<a href="#glos_row_lock">row lock</a>,
<a href="#glos_transaction">transaction</a>.</p></dd>

<dt><a name="glos_online"></a><span>online</span></dt>
<dd><p>Тип работы, которая не вовлекает времени простоя, блокирования или
ограниченной работы для базы данных. Как правило, применяется к
<span><strong>DDL</strong></span>. Операции, которые сокращают периоды
ограниченной работы, такие как <span><strong>быстрое создание индекса
</strong></span>, развились в более широкий набор операций <span><strong>
DDL онлайн</strong></span> в MySQL 5.6.</p>

<p>В контексте резервных копий <span><strong>горячее резервное копирование
</strong></span> это работа онлайн, а <span><strong>теплое резервное
копирование</strong></span> частично работа онлайн.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_fast_index_creation">Fast Index Creation</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_online_ddl">online DDL</a>,
<a href="#glos_warm_backup">warm backup</a>.</p></dd>

<dt><a name="glos_online_ddl"></a><span>online DDL</span></dt>
<dd><p>Особенность, которая улучшает работу, параллелизм и доступность
таблиц InnoDB во время <span><strong>DDL</strong></span> (прежде всего
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>), см.
<a href="innodb.htm#innodb-online-ddl">раздел 16.12</a>.</p>

<p>Детали изменяются согласно типу работы. В некоторых случаях таблица
может быть изменена одновременно в то время, как работает
<code>ALTER TABLE</code>. Работа могла быть выполнена, не делая табличную
копию, или используя особенно оптимизированный тип табличной копии.
Использованием места управляет опция
<a href="innodb.htm#sysvar_innodb_online_alter_log_max_size"><code>
innodb_online_alter_log_max_size</code></a>.</p>

<p>Эта особенность улучшение <span><strong>Fast Index Creation</strong>
</span> в MySQL 5.5 и InnoDB Plugin в MySQL 5.1.</p>
<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_fast_index_creation">Fast Index Creation</a>,
<a href="#glos_online">online</a>.</dd>

<dt><a name="glos_optimistic"></a><span>Оптимистичный</span></dt>
<dd><p>Методология, которая ведет низкоуровневые решения выполнения для
системы реляционной базы данных. Требования работы и <span><strong>
параллелизма</strong></span> в реляционной базе данных означают, что операции
должны быть запущены или посланы быстро. Требования последовательности и
<span><strong>ссылочной целостности</strong></span> означают, что любая
работа могла потерпеть неудачу: транзакция могла быть отменена, работа
<span><strong>DML</strong></span> могла нарушить ограничение, запрос о
блокировке мог вызвать тупик, сетевая ошибка могла вызвать тайм-аут.
Оптимистическая стратегия принимает, что большинство запросов преуспеют,
чтобы относительно маленькая работа была сделана, чтобы подготовиться к
случаю отказа. Когда это предположение истина, база данных делает небольшую
ненужную работу, когда запросы действительно терпят неудачу, дополнительная
работа должна быть сделана, чтобы отменить изменения.</p>

<p>InnoDB использует оптимистические стратегии операций, таких как
<span><strong>locking</strong></span> и
<span><strong>commits</strong></span>. Например, данные, измененные
транзакцией, могут быть написаны файлам с данными прежде, чем передача
произойдет, делая передачу очень быстро, но требуя больше работы, чтобы
отменить изменения, если транзакция отменилась</p>

<p>Противоположность оптимистической стратегии это
<span><strong>пессимистическая</strong></span>, где система оптимизирована,
чтобы иметь дело с операциями, которые ненадежны и часто неудачны.
Эта методология редка в системе базы данных, потому что такая большая забота
входит в выбор надежных аппаратных средств, сетей и алгоритмов.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_concurrency">concurrency</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_pessimistic">pessimistic</a>.</dd>

<dt><a name="glos_optimizer"></a><span>Оптимизатор</span></dt>
<dd><p>Компонент MySQL, который определяет лучший порядок использования
<span><strong>индексов</strong></span> и <span><strong>join</strong></span>
для <span><strong>запроса</strong></span>, основанного на характеристиках и
распределении данных соответствующих <span><strong>таблиц</strong></span>.
</p>

<p>См. <a href="#glos_index">index</a>,
<a href="#glos_join">join</a>,
<a href="#glos_query">query</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_option"></a><span>Опция</span></dt>
<dd><p>Параметр конфигурации для MySQL, сохраненный в <span><strong>файле
опций</strong></span> или переданный в командной строке.</p>

<p>Для опций, которые относятся к таблицам <span><strong>InnoDB</strong>
</span>, каждое имя опции начинается с <code>innodb_</code>.</p>
<p>См. <a href="#glos_innodb">InnoDB</a>,
<a href="#glos_option_file">option file</a>.</dd>

<dt><a name="glos_option_file"></a><span>Файл опций</span></dt>
<dd><p>Файл, который содержит параметры конфигурации MySQL.
Традиционно в Linux и Unix этот файл называют
<code>my.cnf</code>, а в Windows <code>my.ini</code>.</p>

<p>См. <a href="#glos_configuration_file">configuration file</a>,
<a href="#glos_my_cnf">my.cnf</a>,
<a href="#glos_option">option</a>.</dd>

<dt><a name="glos_overflow_page"></a><span>Страница переполнения</span></dt>
<dd><p>Отдельно выделенные дисковые <span><strong>страницы</strong></span>,
которые содержат столбцы переменной длины (такие как
<code>BLOB</code> и <code>VARCHAR</code>), которые слишком длинные, чтобы
поместиться на странице <span><strong>B-tree</strong></span>.
Связанные столбцы известны как <span><strong>столбцы вне страницы</strong>
</span>.</p>

<p>См. <a href="#glos_b_tree">B-tree</a>,
<a href="#glos_off_page_column">off-page column</a>,
<a href="#glos_page">page</a>.</p></dd></dl>

<h3>P</h3>
<dl><dt><a name="glos_par_file"></a><span>Файл .PAR</span></dt>
<dd><p>Файл, содержащий определения разделения. Файлы с этим расширением
всегда включаются в резервные копии, произведенные <code>mysqlbackup</code> в
<span><strong>MySQL Enterprise Backup</strong></span>.</p>

<p>С введением родного разделения для <code>InnoDB</code> в MySQL 5.7.6
файлы <code>.PAR</code> больше не создаются для
разделенных таблиц <code>InnoDB</code>.</p>

<p>См. <a href="#glos_mysql_enterprise_backup">
MySQL Enterprise Backup</a>,
<a href="#glos_mysqlbackup_command">mysqlbackup command</a>.</dd>

<dt><a name="glos_page"></a><span>Страница</span></dt>
<dd><p>Представление сколько данных InnoDB переходит в любой момент между
диском (<span><strong>файлы с данными</strong></span>) и памятью
(<span><strong>буферный пул</strong></span>). Страница может содержать одну
или более <span><strong>строк</strong></span>, в зависимости от того, сколько
данных находится в каждой строке. Если строка не соответствует полностью
единственной странице, InnoDB настраивает дополнительные структуры данных
указателя так, чтобы информация о строке могла храниться в одной странице.
</p>

<p>Один способ разместить больше данных на каждой странице состоит в том,
чтобы использовать <span><strong>сжатый формат строки</strong></span>. Для
таблиц, которые используют BLOB или большие текстовые поля, <span><strong>
компактный формат строки</strong></span> позволяет большим столбцам быть
сохраненными отдельно от остальной части строки, уменьшая ввод/вывод
и использование памяти для запросов, которые не ссылаются на те столбцы.</p>

<p>Когда InnoDB читает или пишет наборы страниц как пакет, чтобы увеличить
пропускную способность ввода/вывода, он читает или пишет
<span><strong>экстент</strong></span> за один раз.</p>

<p>
All the InnoDB disk data structures within a MySQL instance
share the same <span><strong>page size</strong></span>.
</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_compact_row_format">compact row format</a>,
<a href="#glos_compressed_row_format">compressed row format</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_extent">extent</a>,
<a href="#glos_page_size">page size</a>,
<a href="#glos_row">row</a>.</dd>

<dt><a name="glos_page_cleaner"></a><span>Уборщик страницы</span></dt>
<dd><p>Фоновый <span><strong>поток</strong></span> InnoDB, который
<span><strong>сбрасывает</strong></span>
<span><strong>грязные страницы</strong></span> из
<span><strong>буферного пула</strong></span>. До MySQL 5.6 эта деятельность
была выполнена <span><strong>основным потоком</strong></span>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_master_thread">master thread</a>,
<a href="#glos_thread">thread</a>.</dd>

<dt><a name="glos_page_size"></a><span>Размер страницы</span></dt>
<dd><p>Для выпусков до и включая MySQL 5.5, размер каждой <span><strong>
страницы</strong></span> InnoDB установлен в 16 килобайт.
Это значение представляет баланс: достаточно большой, чтобы хранить данные
для большинства строк, но все же достаточно маленький, чтобы минимизировать
издержки передачи ненужных данных к памяти. Другие значения не
проверены или поддержаны.</p>

<p>С MySQL 5.6 размер страницы для <span><strong>экземпляра</strong></span>
может составить 4 КБ, 8 КБ или 16 КБ, чем управляет опция
<a href="innodb.htm#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. С MySQL 5.7.6 InnoDB также оказывает поддержку для размеров страницы
32KB и 64KB. Для размеров страницы 32KB и 64KB
<code>ROW_FORMAT=COMPRESSED</code> не поддержан и максимальный размер
записи составляет 16 КБ.</p>

<p>Вы устанавливаете размер, создавая экземпляр MySQL, и это остается
постоянным позже. Тот же самый размер страницы относится ко всем
<span><strong>табличным пространствам</strong></span> InnoDB,
<span><strong>системному табличному пространству</strong></span> и любымм
отдельным табличным пространствам, создаваемым в режиме
<span><strong>file-per-table</strong></span>.</p>

<p>Меньшие размеры страницы могут помочь работе с устройствами хранения
данных, которые используют маленькие размеры блока, особенно для устройств
<span><strong>SSD</strong></span> в рабочих нагрузках
<span><strong>disk-bound</strong></span>, например,
<span><strong>OLTP</strong></span>. Поскольку отдельные строки обновлены,
меньше данных скопировано в память, написано на диск, реорганизовано,
заблокировано и так далее.</p>

<p>См. <a href="#glos_disk_bound">disk-bound</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_instance">instance</a>,
<a href="#glos_oltp">OLTP</a>,
<a href="#glos_page">page</a>,
<a href="#glos_ssd">SSD</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_parent_table"></a><span>Родительская таблица</span></dt>
<dd><p>Таблица в отношениях <span><strong>внешнего ключа</strong></span>,
которые содержат начальные значения столбцов от <span><strong>дочерней
таблицы</strong></span>. Последствия удаления или обновления строк в
родительской таблице зависят от определений <code>ON UPDATE</code> и
<code>ON DELETE</code> в определении внешнего ключа. Строки с
соответствующими значениями в дочерней таблице могли быть автоматически
удалены или обновлены в свою очередь, те столбцы могли быть установлены в
<code>NULL</code>, или работа могла быть предотвращена.</p>
<p>См. <a href="#glos_child_table">child table</a>,
<a href="#glos_foreign_key">foreign key</a>.</dd>

<dt><a name="glos_partial_backup"></a><span>Частичное резервное копирование
</span></dt>
<dd><p><span><strong>Резервное копирование</strong></span>, которое содержит
некоторые из <span><strong>таблиц</strong></span> в базе данных MySQL или
некоторые из баз данных в экземпляре MySQL.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_full_backup">full backup</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_partial_index"></a><span>Частичный индекс</span></dt>
<dd><p><span><strong>Индекс</strong></span>, который представляет только часть
значения столбца, как правило, первые N символов (<span><strong>префикс
</strong></span>) длинного значения <code>VARCHAR</code>.</p>
<p>См. <a href="#glos_index">index</a>,
<a href="#glos_index_prefix">index prefix</a>.</dd>

<dt><a name="glos_performance_schema"></a><span>Performance Schema</span></dt>
<dd><p><code>performance_schema</code> в MySQL 5.5 и выше представляет
ряд таблиц, которые Вы можете запросить, чтобы получить подробную информацию
о технических характеристиках многих внутренних деталей сервера MySQL.</p>

<p>См. <a href="#glos_latch">latch</a>,
<a href="#glos_mutex">mutex</a>,
<a href="#glos_rw_lock">rw-lock</a>.</dd>

<dt><a name="glos_persistent_statistics"></a><span>Постоянная статистика
</span></dt>
<dd><p>В MySQL 5.6 хранит <span><strong>индексную</strong></span> статистику
для <span><strong>таблиц</strong></span> InnoDB на диске, обеспечивая лучший
<span><strong>план</strong></span> для <span><strong>запросов</strong>
</span>, см. <a href="innodb.htm#innodb-persistent-stats">раздел 16.6.10.1
</a>.</p>

<p>См. <a href="#glos_index">index</a>,
<a href="#glos_optimizer">optimizer</a>,
<a href="#glos_plan_stability">plan stability</a>,
<a href="#glos_query">query</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_pessimistic"></a><span>Пессимистичный</span></dt>
<dd><p>Методология, которая жертвует работой или параллелизмом в пользу
безопасности. Уместно, если высокий процент запросов или попыток мог бы
потерпеть неудачу, или если последствия неудавшегося запроса серьезны. InnoDB
использует то, что известно, как пессимистическая стратегия
<span><strong>блокировки</strong></span>, что
минимизирует шанс <span><strong>тупиков</strong></span>. На уровне приложения
Вы могли бы избежать тупиков при использовании пессимистической стратегии
приобретения всех блокировок, необходимых транзакции в самом начале.</p>

<p>Много встроенных механизмов базы данных используют
противоположную <span><strong>оптимистическую</strong></span> методологию.
</p>
<p>См. <a href="#glos_deadlock">deadlock</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_optimistic">optimistic</a>.</dd>

<dt><a name="glos_phantom"></a><span>Фантом</span></dt>
<dd><p>Строка, которая появляется в наборе результатов запроса, но не в
наборе результатов более раннего запроса. Например, если запрос выполнен
дважды в пределах <span><strong>транзакции</strong></span>,
а тем временем другая транзакция передает после вставки новой строки или
обновления строки так, чтобы это соответствовало <code>WHERE</code>.</p>

<p>Это возникновение известно как призрачное чтение. Более трудно принять
меры, чем <span><strong>неповторимое чтение</strong></span>, потому что
блокировка всех строк от первого набора результатов запроса не предотвращает
изменения, которые заставляют фантом появляться.</p>

<p>Среди различных <span><strong>уровней изоляции</strong></span> призрачные
чтения предотвращены уровнем <span><strong>serializable read</strong></span>,
но позволены <span><strong>repeatable read</strong></span>,
<span><strong>consistent read</strong></span> и
<span><strong>read uncommitted</strong></span>.</p>

<p>См. <a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_non_repeatable_read">non-repeatable read</a>,
<a href="#glos_read_uncommitted">READ UNCOMMITTED</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_serializable">SERIALIZABLE</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_physical"></a><span>Физический</span></dt>
<dd><p>Тип работы, которая вовлекает связанные с аппаратными средствами
аспекты такие, как диск, блокировка, страницы памяти, файлы, биты, дисковые
чтения и так далее. Как правило, физические аспекты важны во время
исполнительной настройки на опытном уровне и поиска проблем.</p>
<p>См. <a href="#glos_logical">logical</a>,
<a href="#glos_physical_backup">physical backup</a>.</dd>

<dt><a name="glos_physical_backup"></a><span>Физическое резервное копирование
</span></dt>
<dd><p><span><strong>Резервное копирование</strong></span>, которое копирует
фактические файлы с данными. Например,
<span><strong><code>mysqlbackup</code></strong></span> из
<span><strong>MySQL Enterprise Backup</strong></span>
производит физическое резервное копирование, потому что его вывод содержит
файлы с данными, которые могут использоваться непосредственно
<code>mysqld</code>, приводя к более быстрой работе
<span><strong>восстановления</strong></span>.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_logical_backup">logical backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_restore">restore</a>.</dd>

<dt><a name="glos_pitr"></a><span>PITR</span></dt>
<dd><p>Сокращение от <span><strong>point-in-time recovery</strong></span>.
</p>
<p>См. <a href="#glos_point_in_time_recovery">
point-in-time recovery</a>.</dd>

<dt><a name="glos_plan_stability"></a><span>План стабильности</span></dt>
<dd><p>Свойство <span><strong>плана выполнения запроса</strong></span>, где
оптимизатор делает тот же самый выбор каждый раз для данного <span><strong>
запроса</strong></span>, чтобы работа была последовательна и предсказуема.
</p>
<p>См. <a href="#glos_query">query</a>,
<a href="#glos_query_execution_plan">query execution plan</a>.</dd>

<dt><a name="glos_plugin"></a><span>Плагин</span></dt>
<dd><p>В MySQL 5.1 и ранее отдельно устанавливаемая форма механизма хранения
<span><strong>InnoDB</strong></span>, который включает особенности и
исполнительные улучшения, не включенные
во <span><strong>встроенный</strong></span> InnoDB.</p>

<p>Для MySQL 5.5 и выше дистрибутивы MySQL включают последние особенности
InnoDB и исполнительные улучшения, известные как InnoDB 1.1, и больше нет
отдельного InnoDB Plugin.</p>

<p>Это различие важно, главным образом, в MySQL 5.1, где особенность или
исправление ошибки могли бы относиться к InnoDB Plugin, но не
ко встроенному InnoDB.</p>
<p>См. <a href="#glos_built_in">built-in</a>,
<a href="#glos_innodb">InnoDB</a>.</dd>

<dt><a name="glos_point_in_time_recovery"></a><span>
Восстановление момента времени</span></dt>
<dd><p>Процесс восстановления <span><strong>резервного копирования</strong>
</span>, чтобы обновить состояние базы данных к определенной дате и время.
Обычно обозначается как <span><strong>PITR</strong></span>.
Поскольку маловероятно, что требуемое время соответствует точно времени
резервного копирования, этот метод обычно требует комбинации
<span><strong>физического резервного копирования</strong></span> и
<span><strong>логического резервного копирования</strong></span>. Например, с
<span><strong>MySQL Enterprise Backup</strong></span>
Вы восстанавливаете последнее резервное копирование, которое Вы взяли перед
указанным моментом времени, затем переиграть изменения от
<span><strong>двоичного журнала</strong></span> между временем резервного
копирования и временем PITR.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_logical_backup">logical backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_physical_backup">physical backup</a>,
<a href="#glos_pitr">PITR</a>.</dd>

<dt><a name="glos_prefix"></a><span>Префикс</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_index_prefix">
index prefix</a>.</dd>

<dt><a name="glos_prepared_backup"></a><span>Готовое резервное копирование
</span></dt>
<dd><p>Ряд резервных файлов, произведенных
<span><strong>MySQL Enterprise Backup</strong></span>
после всех этапов применения <span><strong>двоичных журналов</strong></span>
и <span><strong>возрастающих резервных копий</strong></span>.
Получающиеся файлы готовы быть <span><strong>восстановленными</strong></span>.
До шага применения файлы известны как
<span><strong>сырое резервное копирование</strong></span>.</p>

<p>См. <a href="#glos_binary_log">binary log</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_incremental_backup">incremental backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_raw_backup">raw backup</a>,
<a href="#glos_restore">restore</a>.</dd>

<dt><a name="glos_primary_key"></a><span>primary key</span></dt>
<dd><p>Ряд столбцов и косвенно индекс, основанный на этом наборе столбцов,
который может уникально идентифицировать каждую строку в таблице. Также это
должен быть уникальный индекс, который не содержит <code>NULL</code>.</p>

<p>InnoDB требует, чтобы у каждой таблицы был такой индекс
(также названный <span><strong>кластеризируемым индексом</strong></span> или
<span><strong>кластерным индексом</strong></span>) и организует табличное
хранение, основанное на значениях столбцов первичного ключа.</p>

<p>Выбирая значения первичного ключа, рассмотрите использование произвольных
значений (<span><strong>синтетический ключ</strong></span>) вместо того,
чтобы положиться на некоторый другой
источник (<span><strong>естественный ключ</strong></span>).</p>

<p>См. <a href="#glos_clustered_index">clustered index</a>,
<a href="#glos_index">index</a>,
<a href="#glos_natural_key">natural key</a>,
<a href="#glos_synthetic_key">synthetic key</a>.</dd>

<dt><a name="glos_process"></a><span>Процесс</span></dt>
<dd><p>Экземпляр программы выполнения. Операционная система переключается
между многими рабочими процессами, учитывая определенную степень
<span><strong>параллелизма</strong></span>. На большинстве операционных
систем процессы могут содержать многократные <span><strong>потоки</strong>
</span>. Переключение контекста между потоками быстрее чем эквивалентное
переключение между процессами.</p>
<p>См. <a href="#glos_concurrency">concurrency</a>,
<a href="#glos_thread">thread</a>.</dd>

<dt><a name="glos_pseudo_record"></a><span>Псевдоотчет</span></dt>
<dd><p>Искусственный отчет в индексе, используемый для того, чтобы
<span><strong>заблокировать</strong></span> значения ключа или диапазоны,
которые в настоящее время не существуют.</p>

<p>См. <a href="#glos_infimum_record">infimum record</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_supremum_record">supremum record</a>.</dd>

<dt><a name="glos_pthreads"></a><span>Pthreads</span></dt>
<dd><p>Стандарт POSIX threads, который определяет API для поточной обработки
и блокировки операций на системах Unix и Linux. На системах Unix и Linux
InnoDB использует это для <span><strong>mutexes</strong></span>.</p>
<p>См. <a href="#glos_mutex">mutex</a>.</dd>

<dt><a name="glos_purge"></a><span>Чистка</span></dt>
<dd><p>Тип сбора мусора, выполненного одним или более отдельными фоновыми
потоками (управляется <a href="innodb.htm#sysvar_innodb_purge_threads"><code>
innodb_purge_threads</code></a>), это работает в периодическом графике.
Чистка обарабывает страницы <span><strong>журнала отмены</strong></span> из
<span><strong>списка истории</strong></span> с целью удаления
кластеризируемых и вторичных индексных записей, которые были отмечены для
удаления (предыдущим <a href="sql.htm#delete"><code>DELETE</code></a>)
и больше не требуются для <span><strong>MVCC</strong></span> или
<span><strong>отмены</strong></span>. Чистка освобождает страницы журнала
отмены от списка истории после обработки.</p>

<p>См. <a href="#glos_history_list">history list</a>,
<a href="#glos_mvcc">MVCC</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_purge_buffering"></a><span>Буферизация чистки</span></dt>
<dd><p>Метод хранения изменений вторичных индексных страниц после операции
<code>DELETE</code> в <span><strong>буфере изменения</strong></span> вместо
того, чтобы немедленно писать изменения, чтобы минимизировать случайный
ввод/вывод. Поскольку удаления двухступенчатый процесс, эта работа буферизует
запись, которая обычно производит чистку индексного отчета, который был ранее
отмечен для удаления. Это один из типов <span><strong>буферизации изменения
</strong></span>.</p>

<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_change_buffering">change buffering</a>,
<a href="#glos_delete_buffering">delete buffering</a>,
<a href="#glos_insert_buffer">insert buffer</a>,
<a href="#glos_insert_buffering">insert buffering</a>.</dd>

<dt><a name="glos_purge_lag"></a><span>Задержка чистки</span></dt>
<dd><p>Другое название <span><strong>список истории</strong></span>
<code>InnoDB</code>. Связан с опцией
<a href="innodb.htm#sysvar_innodb_max_purge_lag"><code>innodb_max_purge_lag
</code></a>.</p>
<p>См. <a href="#glos_history_list">history list</a>,
<a href="#glos_purge">purge</a>.</dd>

<dt><a name="glos_purge_thread"></a><span>Поток чистки</span></dt>
<dd><p><span><strong>Поток</strong></span> в пределах процесса InnoDB,
который посвящен выполнению периодической работы
<span><strong>чистки</strong></span>. В MySQL 5.6 и выше
многократные потоки чистки включены опцией
<a href="innodb.htm#sysvar_innodb_purge_threads"><code>
innodb_purge_threads</code></a>.</p>
<p>См. <a href="#glos_purge">purge</a>,
<a href="#glos_thread">thread</a>.</p></dd></dl>

<h3>Q</h3>
<dl><dt><a name="glos_query"></a><span>Запрос</span></dt>
<dd><p>В <span><strong>SQL</strong></span> работа, которая читает информацию
из одной или более <span><strong>таблиц</strong></span>. В зависимости от
организации данных и параметров запроса, поиск мог бы быть оптимизирован,
консультируясь с <span><strong>индексом</strong></span>.
Если многократные таблицы вовлечены, запрос известен как
<span><strong>join</strong></span>.</p>

<p>По историческим причинам иногда обсуждения внутренней обработки для
запросов используют понятие &quot;запрос&quot; в более широком смысле,
включая другие типы запросов MySQL, такие как
<span><strong>DDL</strong></span> и <span><strong>DML</strong></span>.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_index">index</a>,
<a href="#glos_join">join</a>,
<a href="#glos_sql">SQL</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_query_execution_plan"></a><span>План выполнения запроса
</span></dt>
<dd><p>Набор решений, принятых оптимизатором относительно того, как выполнить
<span><strong>запрос</strong></span> наиболее эффективно, включая
<span><strong>индекс</strong></span> или индексы
и порядок, в который можно <span><strong>присоединиться</strong></span> к
таблицам. <span><strong>Стабильность плана</strong></span> вовлекает тот же
самый выбор, сделанный последовательно для данного запроса.</p>

<p>См. <a href="#glos_index">index</a>,
<a href="#glos_join">join</a>,
<a href="#glos_plan_stability">plan stability</a>,
<a href="#glos_query">query</a>.</dd>

<dt><a name="glos_query_log"></a><span>Журнал запросов</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_general_query_log">
general query log</a>.</dd>

<dt><a name="glos_quiesce"></a><span>quiesce</span></dt>
<dd><p>Уменьшение количества деятельности базы данных, часто в
подготовке к такой работе, как <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, <span><strong>резервирование</strong></span> или
<span><strong>завершение работы</strong></span>. Может вовлечь выполнение
такого большого <span><strong>сброса</strong></span>, как возможно,
чтобы <span><strong>InnoDB</strong></span> не продолжил делать
фоновый ввод/вывод.</p>

<p>В MySQL 5.6 и выше <code>FLUSH TABLES ... FOR EXPORT</code>
пишет некоторые данные на диск для таблиц <code>InnoDB</code>,
что делает проще поддержку таблиц, копируя файлы с данными.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_shutdown">shutdown</a>.</p></dd></dl>

<h3>R</h3>
<dl><dt><a name="glos_r_tree"></a><span>R-tree</span></dt>
<dd><p>Структура данных дерева для пространственной индексирующей
многомерной информации, такой как географические координаты,
прямоугольники или многоугольники.</p>
<p>См. <a href="#glos_b_tree">B-tree</a>.</dd>

<dt><a name="glos_raid"></a><span>RAID</span></dt>
<dd><p>Сокращение от "Redundant Array of Inexpensive Drives".
Распространение операций ввода/вывода на многие диски включает больший
<span><strong>параллелизму</strong></span> на уровне аппаратных средств и
улучшает эффективность низкого уровня операций, которые иначе были
бы выполнены в последовательности.</p>
<p>См. <a href="#glos_concurrency">concurrency</a>.</dd>

<dt><a name="glos_random_dive"></a><span>Случайное погружение</span></dt>
<dd><p>Метод для того, чтобы быстро оценить число различных значений в
столбце (количество элементов столбца). Эта работа происходит, когда
каждая таблица открыта.</p>
<p>См. <a href="#glos_cardinality">cardinality</a>.</dd>

<dt><a name="glos_raw_backup"></a><span>Сырое резервное копирование
</span></dt>
<dd><p>Начальный набор резервных файлов, произведенных
<span><strong>MySQL Enterprise Backup</strong></span> перед
изменениями, отраженными в <span><strong>двоичном журнале</strong></span> и
любых <span><strong>возрастающих резервных копиях</strong></span>.
На данном этапе файлы не готовы к <span><strong>восстановлению</strong>
</span>. После того, как эти изменения применены, файлы известны как
<span><strong>готовое резервное копирование</strong></span>.</p>

<p>См. <a href="#glos_binary_log">binary log</a>,
<a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_ibbackup_logfile">ibbackup_logfile</a>,
<a href="#glos_incremental_backup">incremental backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_prepared_backup">prepared backup</a>,
<a href="#glos_restore">restore</a>.</dd>

<dt><a name="glos_read_committed"></a><span>READ COMMITTED</span></dt>
<dd><p><span><strong>Уровень изоляции</strong></span>, который использует
стратегию <span><strong>блокировки</strong></span>, которая ослабляет часть
защиты между <span><strong>транзакциями</strong></span> в интересах работы.
Транзакции не могут видеть нейтральные данные от других транзакций, но они
могут видеть данные, которые переданы другой транзакцией после того, как
текущая транзакция запускалась. Таким образом, транзакция никогда не видит
неправильных данных, но данные, которые она действительно видит, могут
зависеть до некоторой степени от синхронизации других транзакций.</p>

<p>Когда транзакция с этим уровнем изоляции запускает
<code>UPDATE ... WHERE</code> или <code>DELETE ... WHERE</code>,
другим транзакциям, возможно, придется ждать. Транзакция может запустить
<code>SELECT ... FOR UPDATE</code> и <code>LOCK IN SHARE MODE</code>, не
заставляя другие транзакции ждать.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_serializable">SERIALIZABLE</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_read_phenomena"></a><span>read phenomena</span></dt>
<dd><p>Явления, такие как <span><strong>грязные чтения</strong></span>,
<span><strong>неповторимые чтения</strong></span> и
<span><strong>призрачные</strong></span> чтения, которые могут произойти,
когда транзакция читает данные, которые изменила другая транзакция.</p>

<p>См. <a href="#glos_dirty_read">dirty read</a>,
<a href="#glos_non_repeatable_read">non-repeatable read</a>,
<a href="#glos_phantom">phantom</a>.</dd>

<dt><a name="glos_read_uncommitted"></a><span>READ UNCOMMITTED</span></dt>
<dd><p><span><strong>Уровень изоляции</strong></span>, который обеспечивает
наименьшее количество защиты между транзакциями. Запросы используют стратегию
<span><strong>блокировки</strong></span>, которая позволяет им продолжаться в
ситуациях, где они обычно ждали бы другой транзакции. Однако, эта
дополнительная работа идет за счет менее надежных результатов, включая
данные, которые были изменены другими транзакциями и не переданы все же
(известны как <span><strong>грязное чтение</strong></span>). Используйте этот
уровень изоляции только очень осторожно и знайте, что результаты не могли бы
быть последовательными или восстанавливаемыми, в зависимости от того, что
другие транзакции делают в то же самое время. Как правило, транзакции с этим
уровнем изоляции делают только запросы, не вставляют, обновляют
или удаляют данные.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_dirty_read">dirty read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_read_view"></a><span>Чтение представления</span></dt>
<dd><p>Внутренний снимок используется механизмом
<span><strong>MVCC</strong></span> InnoDB. Определенные
<span><strong>транзакции</strong></span>, в зависимости от их
<span><strong>уровня изоляции</strong></span> видят значения данных, как они
были в то время, когда транзакция (или в некоторых случаях, запрос)
запускалась. Уровни изоляции, которые используют представление чтения:
<span><strong>REPEATABLE READ</strong></span>,
<span><strong>READ COMMITTED</strong></span> и
<span><strong>READ UNCOMMITTED</strong></span>.</p>

<p>См. <a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_mvcc">MVCC</a>,
<a href="#glos_read_committed">READ COMMITTED</a>,
<a href="#glos_read_uncommitted">READ UNCOMMITTED</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_read_ahead"></a><span>read-ahead</span></dt>
<dd><p>Тип ввода/вывода, чтобы предварительно забрать
группу <span><strong>страниц</strong></span> в <span><strong>буферный пул
</strong></span> асинхронно, в ожидании, что эти страницы скоро будут
необходимы. Линейный метод чтения вперед предварительно приносит все страницы
одного экстента, основываясь на образцах доступа для страниц в предыдущем
экстенте и является частью всех версий MySQL, начиная с InnoDB Plugin в
MySQL 5.1. Случайный метод чтения вперед предварительно приносит все страницы
для экстента, как только определенное число страниц от того же самого
экстента находится в буферном пуле. Случайное чтение вперед не часть MySQL
5.5, но повторно введено в MySQL 5.6 под управлением опции
<code>innodb_random_read_ahead</code>.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_extent">extent</a>,
<a href="#glos_page">page</a>.</dd>

<dt><a name="glos_read_only_transaction"></a><span>
Транзакция только для чтения</span></dt>
<dd><p>Тип транзакции, которая может быть оптимизирована для
таблицы, устраняя часть расчетов, связанных с созданием
<span><strong>чтения представления</strong></span>
для каждой транзакции. Может только выполнить запросы
<span><strong>чтения без блокировки</strong></span>.
Это может быть запущено явно с синтаксисом
<a href="sql.htm#commit"><code>START TRANSACTION READ ONLY</code></a>
или автоматически при определенных условиях. См.
<a href="optimiz.htm#innodb-performance-ro-txn">раздел 9.5.3</a>.</p>

<p>См. <a href="#glos_non_locking_read">non-locking read</a>,
<a href="#glos_read_view">read view</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_record_lock"></a><span>Блокировка записи</span></dt>
<dd><p><a href="#glos_lock">Блокировка</a> на индексной записи.
Например, <code>SELECT c1 FOR UPDATE FROM t WHERE c1 = 10;</code>
препятствует тому, чтобы любая другая транзакция вставила, обновила или
удалила строки, где значение <code>t.c1</code> = 10.</p>

<p>См. <a href="#glos_gap_lock">gap lock</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_next_key_lock">next-key lock</a>.</dd>

<dt><a name="glos_redo"></a><span>redo</span></dt>
<dd><p>Данные, в модулях отчетов, зарегистрированных в
<span><strong>журнале redo</strong></span>, когда запросы
<a href="#glos_dml">DML</a> производят изменения в таблицах
InnoDB. Это используется во время <span><strong>восстановления
катастрофического отказа</strong></span>, чтобы исправить данные, написанные
неполными <span><strong>транзакциями</strong></span>.
Постоянно увеличивающееся значение <span><strong>LSN</strong></span>
представляет совокупное количество данных, которые прошли через журнал.</p>

<p>См. <a href="#glos_crash_recovery">crash recovery</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_lsn">LSN</a>,
<a href="#glos_redo_log">redo log</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_redo_log"></a><span>Журнал redo</span></dt>
<dd><p>Основанная на диске структура данных, используемая во время
<span><strong>восстановления катастрофического отказа</strong></span>, чтобы
исправить данные, написанные неполными <span><strong>транзакциями</strong>
</span>. Во время нормального функционирования это кодирует просьбы изменить
табличные данные InnoDB, которые следуют из запросов SQL или низкого уровня
требования API через интерфейсы NoSQL. Модификации, которые не закончили
обновлять <span><strong>файлы с данными</strong></span> перед неожиданным
<span><strong>завершением работы</strong>
</span>, переигрываются автоматически.</p>

<p>Журнал физически представлен как ряд файлов, как правило, называемых
<code>ib_logfile0</code> и <code>ib_logfile1</code>. Данные в журнале
закодированы с точки зрения затронутых записей, эти данные все вместе
упоминаются как <span><strong>redo</strong></span>. Проход данных через
журналы представлен постоянно увеличивающимся значением <span><strong>LSN
</strong></span>. Оригинальный предел в 4GB на максимальный размер для
журнала redo поднят до 512GB в MySQL 5.6.3.</p>

<p>Дисковое расположение журнала под влиянием параметров конфигурации
<a href="innodb.htm#sysvar_innodb_log_file_size"><code>innodb_log_file_size
</code></a>, <a href="innodb.htm#sysvar_innodb_log_group_home_dir"><code>
innodb_log_group_home_dir</code></a> и (редко)
<a href="innodb.htm#sysvar_innodb_log_files_in_group"><code>
innodb_log_files_in_group</code></a>. Исполнение операций журнала затронуто
<span><strong>буфером журнала</strong></span>, которым управляет опция
<a href="innodb.htm#sysvar_innodb_log_buffer_size">
<code>innodb_log_buffer_size</code></a>.</p>

<p>См. <a href="#glos_crash_recovery">crash recovery</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_ib_logfile">ib_logfile</a>,
<a href="#glos_log_buffer">log buffer</a>,
<a href="#glos_lsn">LSN</a>,
<a href="#glos_redo">redo</a>,
<a href="#glos_shutdown">shutdown</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_redundant_row_format"></a><span>Избыточный формат строки
</span></dt>
<dd><p>Самый старый формат строки. До MySQL 5.0.3 это был единственный формат
строки, доступный в <code>InnoDB</code>. С MySQL 5.0.3 до MySQL 5.7.8
формат строки по умолчанию <span><strong>COMPACT</strong></span>.
С MySQL 5.7.9 формат строки по умолчанию определен опцией
<a href="innodb.htm#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>, у которого есть настройка по умолчанию
<span><strong>DYNAMIC</strong></span>. Вы можете все еще определить
формат строки <span><strong>REDUNDANT</strong></span>
для совместимости с более старым таблицами <code>InnoDB</code>.</p>

<p>См. <a href="innodb.htm#innodb-row-format-antelope">раздел 16.10.4</a>.
</p>
<p>См. <a href="#glos_compact_row_format">compact row format</a>,
<a href="#glos_file_format">file format</a>,
<a href="#glos_row_format">row format</a>.</dd>

<dt><a name="glos_referential_integrity"></a><span>Ссылочная целостность
</span></dt>
<dd><p>Метод поддержания данных всегда в последовательном формате, части
<span><strong>ACID</strong></span>. В частности, данные в различных таблицах
сохранены последовательными с помощью <span><strong>ограничений внешнего
ключа</strong></span>, которые могут предотвратить изменения или
автоматически размножить те изменения на все связанные таблицы. Связанные
механизмы включают <span><strong>уникальное ограничение</strong></span>,
которое препятствует тому, чтобы двойные значения были вставлены по ошибке, и
<span><strong>ограничение NOT NULL</strong></span>, которое препятствует
тому, чтобы пустые значения были вставлены по ошибке.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_foreign_key_constraint">FOREIGN KEY constraint</a>,
<a href="#glos_not_null_constraint">NOT NULL constraint</a>,
<a href="#glos_unique_constraint">unique constraint</a>.</dd>

<dt><a name="glos_relational"></a><span>Относительный</span></dt>
<dd><p>Важный аспект современных систем базы данных. Сервер базы данных
кодирует и проводит в жизнь такие отношения, как непосредственные,
&quot;один ко многим&quot;, &quot;многие к один&quot; и уникальность.
Например, у человека мог бы быть ноль, один или много номеров телефонов в
базе данных адреса, единственный номер телефона мог бы быть связан с
несколькими членами семьи. В финансовой базе данных человек мог бы быть
обязан иметь точно одно удостоверение личности налогоплательщика, и любое
удостоверение личности налогоплательщика могло быть связано
только с одним человеком.</p>

<p>Сервер базы данных может использовать эти отношения, чтобы препятствовать
тому, чтобы неправильные данные были вставлены. Например, если значение, как
объявляют, уникально, сервер может прекратить искать, как только первое
соответствие найдено, и это может отклонить попытки вставить вторую копию
того же самого значения.</p>

<p>На уровне базы данных эти отношения выражены через особенности SQL, такие
как <span><strong>столбцы</strong></span> в пределах таблицы, уникальное и
<code>NOT NULL</code> <span><strong>ограничения</strong></span>,
<span><strong>внешние ключи</strong></span> и различные виды операций
соединения. Сложные отношения, как правило, вовлекают разделение данных
больше, чем между одной таблицей. Часто данные <span><strong>нормализованы
</strong></span>, чтобы двойные значения в отношениях &quot;один ко
многим&quot; были сохранены только однажды.</p>

<p>В математическом контексте отношения в пределах базы данных получены из
теории множеств. Например, операторы <code>OR</code> и <code>AND</code>
в <code>WHERE</code> представляют понятия союза и пересечения.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_constraint">constraint</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_normalized">normalized</a>.</dd>

<dt><a name="glos_relevance"></a><span>Тема</span></dt>
<dd><p>В <span><strong>полнотекстовой</strong></span> функции поиска число,
показывающее подобие между строкой поиска и данными в <span><strong>индексе
FULLTEXT</strong></span>. Например, когда Вы ищете отдельное слово, то слово,
как правило, более важно для строки, где происходит несколько раз в тексте,
чем для строки, где это появляется только однажды.</p>
<p>См. <a href="#glos_full_text_search">full-text search</a>,
<a href="#glos_fulltext_index">FULLTEXT index</a>.</dd>

<dt><a name="glos_repeatable_read"></a><span>REPEATABLE READ</span></dt>
<dd><p><span><strong>Уровень изоляции</strong></span> по умолчанию для
InnoDB. Это предотвращает любые строки, которые запрошены от изменения
другими транзакциями, таким образом блокируя <span><strong>неповторимые
чтения</strong></span>, но не <span><strong>призрачные</strong></span>
чтения. Это использует умеренно строгую стратегию
<span><strong>блокировки</strong></span> так, чтобы все запросы в пределах
транзакции видели данные от того же самого снимка, то есть, данные, как это
было в то время, когда транзакция запускалась.</p>

<p>Когда транзакция с этим уровнем изоляции выполняет
<code>UPDATE ... WHERE</code>, <code>DELETE ... WHERE</code>,
<code>SELECT ... FOR UPDATE</code> и <code>LOCK IN SHARE MODE</code>, другим
транзакциям, возможно, придется ждать.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_phantom">phantom</a>,
<a href="#glos_serializable">SERIALIZABLE</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_replication"></a><span>Репликация</span></dt>
<dd><p>Практика посылки изменений от <span><strong>основной базы данных
</strong></span> одной или более ведомым <span><strong>базам данных</strong>
</span>, чтобы у всех баз данных были те же самые данные. У этого метода есть
широкий диапазон использования, например, балансирование загрузки для лучшей
масштабируемости, аварийное восстановление и обновления программного
обеспечения тестирования и изменения конфигурации.
Изменения могут послать между базой данных методами, названными
<span><strong>основанная на строке</strong></span> и
<span><strong>основанная на запросе</strong></span> репликация.</p>

<p>См. <a href="#glos_row_based_replication">
row-based replication</a>,
<a href="#glos_statement_based_replication">
statement-based replication</a>.</dd>

<dt><a name="glos_restore"></a><span>Восстановление</span></dt>
<dd><p>Процесс помещения ряда резервных файлов от
<span><strong>MySQL Enterprise Backup</strong></span> в место для
использования MySQL. Эта работа может быть выполнена, чтобы установить
поврежденную базу данных, возвратиться к некоторому более раннему моменту
времени или (в контексте <span><strong>репликации</strong></span>),
чтобы настроить новую <span><strong>ведомую базу данных</strong></span>. В
<span><strong>MySQL Enterprise Backup</strong></span> эта работа выполнена
опцией <code>copy-back</code> команды <code>mysqlbackup</code>.</p>

<p>См. <a href="#glos_hot_backup">hot backup</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_mysqlbackup_command">mysqlbackup command</a>,
<a href="#glos_prepared_backup">prepared backup</a>,
<a href="#glos_replication">replication</a>.</dd>

<dt><a name="glos_rollback"></a><span>Отмена</span></dt>
<dd><p>Команда <span><strong>SQL</strong></span>, которая заканчивает
<span><strong>транзакцию</strong></span>, отменяя любые изменения,
произведенные транзакцией. Это противоположность
<span><strong>commit</strong></span>, которая делает постоянными любые
изменения, сделанные в транзакции.</p>

<p>По умолчанию MySQL использует опцию <span><strong>autocommit</strong>
</span>, которая автоматически передает после каждого запроса SQL. Вы должны
изменить эти настройки прежде, чем Вы сможете использовать метод отмены.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_commit">commit</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_rollback_segment"></a><span>Сегмент отмены</span></dt>
<dd><p>Область хранения, содержащая <span><strong>журнал отмены</strong>
</span>, часть <span><strong>системного табличного пространства</strong>
</span>.</p>
<p>См. <a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_row"></a><span>Строка</span></dt>
<dd><p>Логическая структура данных определена рядом <span><strong>столбцов
</strong></span>. Ряд строк составляет <span><strong>таблицу</strong></span>.
В пределах <span><strong>файлов с данными</strong></span> InnoDB каждая
<span><strong>страница</strong></span> может содержать одну или более строк.
</p>

<p>Хотя InnoDB использует <span><strong>формат строки</strong></span>
для последовательности с синтаксисом MySQL, формат строки это
свойство каждой таблицы и относится ко всем строкам в той таблице.</p>

<p>См. <a href="#glos_column">column</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_page">page</a>,
<a href="#glos_row_format">row format</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_row_format"></a><span>Формат строки</span></dt>
<dd><p>Дисковый формат хранения для <span><strong>строк таблицы</strong>
</span> InnoDB. Поскольку InnoDB получает новые способности, такие как
сжатие, новые форматы строки введены, чтобы поддержать получающиеся
усовершенствования эффективности хранения и работы.</p>

<p>Формат строки таблицы InnoDB определен опцией <code>ROW_FORMAT</code> или
<a href="innodb.htm#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a> (с MySQL 5.7.9). Форматы строки включают
<code>REDUNDANT</code>, <code>COMPACT</code>, <code>COMPRESSED</code> и
<code>DYNAMIC</code>. Чтобы просмотреть формат строки таблицы InnoDB, Вы
можете скомандовать <code>SHOW TABLE STATUS</code> или запросить
<a href="inform.htm#innodb-sys-tables-table">
<code>INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a> (в MySQL 5.6 или выше).
</p>

<p>См. <a href="#glos_compact_row_format">compact row format</a>,
<a href="#glos_compressed_row_format">compressed row format</a>,
<a href="#glos_dynamic_row_format">dynamic row format</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_fixed_row_format">fixed row format</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_redundant_row_format">redundant row format</a>,
<a href="#glos_row">row</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_row_lock"></a><span>Блокировка строки</span></dt>
<dd><p><span><strong>Блокировка</strong></span>, которая препятствует тому,
чтобы строка была получена несовместимым способом другой
<span><strong>транзакцией</strong></span>. Другие строки в той же самой
таблице могут быть свободно написаны другими транзакциями. Это тип
<span><strong>блокировки</strong></span> операциями
<span><strong>DML</strong></span> на таблицах
<span><strong>InnoDB</strong></span>.</p>

<p>Контраст с <span><strong>табличными блокировками</strong></span>,
используемыми MyISAM, или во время операций <span><strong>DDL</strong></span>
на таблицах InnoDB, которые не могут быть сделаны с <span><strong>DDL онлайн
</strong></span>: те блокировки блокируют параллельный доступ к таблице.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_online_ddl">online DDL</a>,
<a href="#glos_table_lock">table lock</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_row_based_replication"></a><span>
Основанная на строке репликация</span></dt>
<dd><p>Форма <span><strong>репликации</strong></span>, где события размножены
от <span><strong>главного сервера</strong></span>, определяющего, как
изменить отдельные строки на <span><strong>ведомом</strong></span> сервере.
Безопасно использовать для всех настроек опции
<a href="innodb.htm#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a>.</p>

<p>См. <a href="#glos_auto_increment_locking">
auto-increment locking</a>,
<a href="#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode
</a>, <a href="#glos_master_server">master server</a>,
<a href="#glos_replication">replication</a>,
<a href="#glos_slave_server">slave server</a>,
<a href="#glos_statement_based_replication">
statement-based replication</a>.</dd>

<dt><a name="glos_row_level_locking"></a><span>Блокировка на уровне строки
</span></dt>
<dd><p>Механизм <span><strong>блокировки</strong></span>, используемый для
таблиц <span><strong>InnoDB</strong></span>, полагаясь на
<span><strong>блокировки строки</strong></span>, а не
<span><strong>табличные блокировки</strong></span>. Многократные
<span><strong>транзакции</strong></span> могут изменить ту же самую таблицу
одновременно. Только если две операционных попытки изменить ту же самую
строку предприняты, одна из транзакций ждет завершения другой (и снятия
ее блокировки строки).</p>

<p>См. <a href="#glos_innodb">InnoDB</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_row_lock">row lock</a>,
<a href="#glos_table_lock">table lock</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_rw_lock"></a><span>rw-lock</span></dt>
<dd><p>Низкоуровневый объект, чтобы представить и провести в жизнь
<span><strong>блокировки</strong></span> совместно используемого доступа к
внутренним структурам данных в памяти после определенных правил. Контраст с
<span><strong>mutexes</strong></span>, который нужен, чтобы представить и
провести в жизнь эксклюзивный доступ к внутренним структурам данных в памяти.
Mutexes и rw-блокировки известны все вместе как
<span><strong>latches</strong></span>.</p>

<p>Типы <code>rw-lock</code> включают
<code>s-locks</code> (совместно используемые блокировки),
<code>x-locks</code> (исключительные блокировки) и
<code>sx-locks</code> (совместно используемо-исключительные блокировки).</p>

<ul><li><p><code>s-lock</code> обеспечивает доступ чтения к общему ресурсу.
</li>
<li><code>x-lock</code> обеспечивает доступ на запись к общему ресурсу, не
разрешая непоследовательные чтения другими потоками.</li>

<li><code>sx-lock</code> обеспечивает доступ на запись к общему ресурсу,
разрешая непоследовательные чтения другими потоками. <code>sx-locks</code>
были введены в MySQL 5.7, чтобы оптимизировать
параллелизм и улучшить масштабируемость.</p></li></ul>

<p>Следующая матрица суммирует совместимость типов rw-блокировок.</p>
<table border="1">
<thead><tr><th scope="col"> </th><th scope="col"><em><code>S</code></em>
</th><th scope="col"><em><code>SX</code></em>
</th><th scope="col"><em><code>X</code></em></th></tr></thead>
<tbody><tr><td scope="row"><em><code>S</code></em>
</td><td>Совместимы</td><td>Совместимы</td><td>Конфликтуют</td></tr>
<tr><td scope="row"><em><code>SX</code></em></td><td>Совместимы</td>
<td>Конфликтуют</td><td>Конфликтуют</td></tr>
<tr><td scope="row"><em><code>X</code></em></td><td>Конфликтуют</td>
<td>Конфликтуют</td><td>Конфликтуют</td></tr></tbody></table>

<p>См. <a href="#glos_latch">latch</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_mutex">mutex</a>,
<a href="#glos_performance_schema">Performance Schema</a>.
</p></dd></dl>

<h3>S</h3>
<dl><dt><a name="glos_savepoint"></a><span>savepoint</span></dt>
<dd><p>Savepoint помогают осуществить вложенные <span><strong>транзакции
</strong></span>. Они могут использоваться, чтобы обеспечить контекст
операциям на таблицах, которые являются частью большей транзакции. Например,
планирование поездки в системе резервирования могло бы вовлечь заказ
нескольких различных полетов, если желаемый полет недоступен, Вы могли бы
<span><strong>отменить</strong></span> изменения, вовлеченные в заказ, не
отменяя более ранние полеты, которые были успешно заказаны.</p>
<p>См. <a href="#glos_rollback">rollback</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_scalability"></a><span>Масштабируемость</span></dt>
<dd><p>Способность добавить больше работы и выпустить больше одновременных
запросов к системе, без внезапного понижения работы из-за превышения пределов
системных ресурсов. Архитектура программного обеспечения, конфигурация
аппаратных средств, кодирование приложения и тип рабочей нагрузки играют роль
в масштабируемости. Когда система достигает своей максимальной мощности,
популярные методы для того, чтобы увеличить масштабируемость это
увеличение существующих аппаратных средств или программного обеспечения
и добавить новые серверы и больше экземпляров MySQL. Часто соединяется с
<span><strong>доступностью</strong></span> как критические
аспекты крупномасштабного развертывания.</p>

<p>См. <a href="#glos_availability">availability</a>,
<a href="#glos_scale_out">scale out</a>,
<a href="#glos_scale_up">scale up</a>.</dd>

<dt><a name="glos_scale_out"></a><span>Масштаб</span></dt>
<dd><p>Метод для того, чтобы увеличить <span><strong>масштабируемость
</strong></span>, добавляя новые серверы и больше экземпляров MySQL.
Например, настраивая репликацию, MySQL Cluster, объединение соединения или
другие особенности, которые распространяют работу на группу серверов.</p>

<p>См. <a href="#glos_scalability">scalability</a>,
<a href="#glos_scale_up">scale up</a>.</dd>

<dt><a name="glos_scale_up"></a><span>Расширение</span></dt>
<dd><p>Метод для того, чтобы увеличить <span><strong>масштабируемость
</strong></span>, увеличивая возможности существующих аппаратных средств или
программного обеспечения. Например, увеличивая память на сервере и
корректируя связанные с памятью параметры
<a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> и
<a href="innodb.htm#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>.</p>
<p>См. <a href="#glos_scalability">scalability</a>,
<a href="#glos_scale_out">scale out</a>.</dd>

<dt><a name="glos_schema"></a><span>Схема</span></dt>
<dd><p>Концептуально схема это ряд взаимосвязанных объектов базы данных,
таких как таблицы, столбцы таблицы, типы данных столбцов, индекы, внешние
ключи и так далее. Эти объекты соединены через синтаксис SQL, потому что
столбцы составляют таблицы, внешние ключи обращаются к таблицам и столбцам и
так далее. Идеально они также соединены логически, сотрудничая как часть
объединенного приложения или гибкой структуры. Например, базы данных
<span><strong>information_schema</strong></span> и <span><strong>
performance_schema</strong></span> используют &quot;схему&quot; с их именами,
чтобы подчеркнуть тесные отношения между таблицами и столбцами,
которые они содержат.</p>

<p>В MySQL, физически, <span><strong>схема</strong></span> это синоним
<span><strong>базы данных</strong></span>. Вы можете заменить ключевое слово
<code>SCHEMA</code> на <code>DATABASE</code> в MySQL-синтаксисе SQL,
например, используя <code>CREATE SCHEMA</code> вместо <code>CREATE DATABASE
</code>.</p>

<p>Некоторые другие продукты базы данных проводят различия. Например, в
продукте базы данных Oracle Database <span><strong>schema</strong></span>
представляет только часть базы данных: таблицы и другие объекты
принадлежат единственному пользователю.</p>

<p>См. <a href="#glos_database">database</a>,
<a href="#glos_ib_file_set">ib-file set</a>,
<a href="#glos_information_schema">INFORMATION_SCHEMA</a>,
<a href="#glos_performance_schema">Performance Schema</a>.</dd>

<dt><a name="glos_sdi"></a><span>SDI</span></dt>
<dd><p>Сокращение от <span><span>serialized dictionary information</span>
</span>.</p>
<p>См. <a href="#glos_serialized_dictionary_information">
Serialized Dictionary Information (SDI)</a>.</dd>

<dt><a name="glos_search_index"></a><span>Поисковый индекс</span></dt>
<dd><p>В MySQL запросы <span><strong>полнотекстового поиска</strong></span>
используют специальный индекс <span><strong>FULLTEXT</strong></span>. В
MySQL 5.6.4 и выше <code>InnoDB</code> и <code>MyISAM</code>
поддерживают индексы <code>FULLTEXT</code>, ранее
они были доступны только для таблиц <code>MyISAM</code>.</p>
<p>См. <a href="#glos_full_text_search">full-text search</a>,
<a href="#glos_fulltext_index">FULLTEXT index</a>.</dd>

<dt><a name="glos_secondary_index"></a><span>Вторичный индекс</span></dt>
<dd><p>Тип <span><strong>индекса</strong></span> InnoDB, который
представляет подмножество столбцов таблицы. У таблицы InnoDB может быть ноль,
один или много вторичных индексов. Контраст с <span><strong>кластеризируемым
индексом</strong></span>, который требуется для каждой таблицы InnoDB и
хранит данные для всех столбцов таблицы.</p>

<p>Вторичный индекс может использоваться, чтобы удовлетворить запросы,
которые только требуют значений от индексированных столбцов. Для более
сложных запросов это может использоваться, чтобы идентифицировать
соответствующие строки в таблице, которые тогда получены посредством поисков,
используя кластеризируемый индекс.</p>

<p>Создание и удаление вторичного индекса традиционно вовлекает существенные
издержки от копирования всех данных в таблице InnoDB. <span><strong>fast
index creation</strong></span> в InnoDB Plugin делает
<code>CREATE INDEX</code> и <code>DROP INDEX</code>
намного быстрее для вторичных индексов.</p>

<p>См. <a href="#glos_clustered_index">clustered index</a>,
<a href="#glos_fast_index_creation">Fast Index Creation</a>,
<a href="#glos_index">index</a>.</dd>

<dt><a name="glos_segment"></a><span>Сегмент</span></dt>
<dd><p>Подразделение в пределах <span><strong>табличного пространства
</strong></span> InnoDB. Если табличное пространство походит на каталог,
сегменты походят на файлы в пределах того каталога. Сегмент может вырасти.
Могут быть созданы новые сегменты.</p>

<p>Например, в пределах табличного пространства
<span><strong>file-per-table</strong></span>
табличные данные находятся в одном сегменте, и каждый связанный индекс
находится в его собственном сегменте. <span><strong>Системное табличное
пространство</strong></span> содержит много различных сегментов, потому что
оно может содержать много таблиц и их связанных индексов.
Системное табличное пространство также включает один или более
<span><strong>сегментов отмены</strong></span>, используемых
для <span><strong>журналов отмены</strong></span>.</p>

<p>Сегменты растут и сжимаются, поскольку данные вставлены и удалены.
Когда сегмент нуждается в большем количестве места, он расширен на
<span><strong>экстент</strong></span> (1 мегабайт) за один раз. Точно так же
сегмент освобождает один экстент, когда все данные в том экстенте
больше не необходимы.</p>

<p>См. <a href="#glos_extent">extent</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_rollback_segment">rollback segment</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_tablespace">tablespace</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_selectivity"></a><span>Селективность</span></dt>
<dd><p>Свойство распределения данных, число отличных значений в столбце (его
<span><strong>количество элементов</strong></span>), разделенное на число
записей в таблице. Высокая селективность означает, что значения столбцов
относительно уникальны и могут быть эффективно получены посредством индекса.
Если Вы (или оптимизатор запросов) можете предсказать, что <code>WHERE</code>
соответствует только небольшое число (или пропорция) строк в таблице, полный
<span><strong>запрос</strong></span> имеет тенденцию быть эффективным, если
это оценивает тот тест сначала, используя индекс.</p>
<p>См. <a href="#glos_cardinality">cardinality</a>,
<a href="#glos_query">query</a>.</dd>

<dt><a name="glos_semi_consistent_read"></a><span>Полупоследовательное чтение
</span></dt>
<dd><p>Тип работы чтения, используемой для запроса <code>UPDATE</code>,
который является комбинацией <span><strong>read committed</strong></span> и
<span><strong>consistent read</strong></span>. Когда <code>UPDATE</code>
исследует строку, которая уже заблокирована, InnoDB возвращает последнюю
переданную версию в MySQL так, чтобы MySQL мог определить, соответствует ли
строка <code>WHERE</code> условию <code>UPDATE</code>.
Если строка соответствует (должна быть обновлена), MySQL читает строку снова,
и на сей раз InnoDB или блокирует ее или ждет блокировки на ней. Этот тип
работы чтения может произойти только, когда у транзакции есть
<span><strong>уровень изоляции</strong></span> read committed, или когда
включена опция <a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_locks_unsafe_for_binlog"
target="_top"><code>innodb_locks_unsafe_for_binlog</code></a>, которая
удалена в MySQL 8.0.</p>

<p>См. <a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_read_committed">READ COMMITTED</a>.</dd>

<dt><a name="glos_serializable"></a><span>SERIALIZABLE</span></dt>
<dd><p><span><strong>Уровень изоляции</strong></span>, который использует
самую консервативную стратегию блокировки, чтобы препятствовать тому, чтобы
любые другие транзакции вставили или изменили данные, которые были считаны
этой транзакцией, пока это не закончено. Этим путем тот же самый запрос может
быть выполнен много раз в пределах транзакции и быть уверен, что получил тот
же самый набор результатов каждый раз. Любая попытка изменить данные, которые
были переданы другой транзакцией, начиная с запуска текущей транзакции,
заставляет текущую транзакцию ждать.</p>

<p>Это уровень изоляции по умолчанию, определенный стандартом SQL.
Практически, эта степень строгости редко необходима, таким образом, уровень
изоляции по умолчанию для InnoDB следующее самое строгое
значение, <span><strong>repeatable read</strong></span>.</p>

<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_repeatable_read">REPEATABLE READ</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_serialized_dictionary_information"></a><span>
Serialized Dictionary Information (SDI)</span></dt>
<dd><p>Метаданные об объекте словаря в преобразованном в
последовательную форму <code>BLOB</code>.</p>

<p>См. <a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_server"></a><span>Сервер</span></dt>
<dd><p>Тип программы, которая работает непрерывно, ожидая
запросы из другой программы (клиента). Поскольку часто весь компьютер
посвящен выполнению разных серверов (таких как сервер базы данных,
веб-сервер, сервер приложений или некоторая их комбинация), термин
<span><strong>сервер</strong></span> может также отнестись к компьютеру,
который выполняет программное обеспечение сервера.</p>
<p>См. <a href="#glos_client">client</a>,
<a href="#glos_mysqld">mysqld</a>.</dd>

<dt><a name="glos_shared_lock"></a><span>Совместно используемая блокировка
</span></dt>
<dd><p>Своего рода <span><strong>блокировка</strong></span>, которая
позволяет другим <span><strong>транзакциям</strong></span> читать
заблокированный объект, и также приобретать другие совместно используемые
блокировки, но не писать этот объект.
Противоположность <span><strong>исключительной блокировки</strong></span>.
</p>
<p>См. <a href="#glos_exclusive_lock">exclusive lock</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_shared_tablespace"></a><span>
Совместно используемое табличное пространство</span></dt>
<dd><p>Другой способ обратиться к <span><strong>
системному табличному пространству</strong></span>.</p>
<p>См. <a href="#glos_system_tablespace">system tablespace</a>.</dd>

<dt><a name="glos_sharp_checkpoint"></a><span>Контрольная точка</span></dt>
<dd><p>Процесс <span><strong>сбрасывает</strong></span> на диск все
<span><strong>грязные</strong></span> буферные страницы пула, чьи записи
содержатся в определенной части <span><strong>журнала redo</strong></span>.
Происходит прежде, чем InnoDB снова использует часть файла системного
журнала, файлы системного журнала используются круговым способом. Как
правило, происходит в рабочих нагрузках с интенсивной записью.</p>

<p>См. <a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_redo_log">redo log</a>,
<a href="#glos_workload">workload</a>.</dd>

<dt><a name="glos_shutdown"></a><span>Завершение работы</span></dt>
<dd><p>Процесс остановки сервера MySQL. По умолчанию этот процесс делает
операции уборки для таблиц <span><strong>InnoDB</strong></span>, таким
образом, он может <span><strong>замедлить</strong></span> закрытие, но быстро
запустить позже. Если Вы пропускаете операции уборки, это
<span><strong>быстро</strong></span>, но должно сделать уборку во
время следующего перезапуска.</p>

<p>Режимом завершения работы управляет опция
<a href="innodb.htm#sysvar_innodb_fast_shutdown"><code>innodb_fast_shutdown
</code></a>.</p>

<p>См. <a href="#glos_fast_shutdown">fast shutdown</a>,
<a href="#glos_innodb">InnoDB</a>,
<a href="#glos_slow_shutdown">slow shutdown</a>,
<a href="#glos_startup">startup</a>.</dd>

<dt><a name="glos_slave_server"></a><span>Ведомый сервер</span></dt>
<dd><p>Часто сокращаемый к &quot;ведомому устройству&quot;. Машина
<span><strong>сервера</strong></span> базы данных в сценарии
<span><strong>репликации</strong></span>, который получает изменения от
другого сервера (<span><strong>ведущее устройство</strong></span>) и
применяет те же самые изменения. Таким образом, это поддерживает то же самое
содержание как ведущее устройство, хотя это могло бы несколько отстать.</p>

<p>В MySQL ведомые серверы обычно используются в аварийном восстановлении,
чтобы взять место главного сервера, который терпит неудачу.
Они также обычно используются для того, чтобы проверить обновления
программного обеспечения и новые настройки, чтобы гарантировать, что
изменения конфигурации базы данных не вызывают проблемы с
работой или надежностью.</p>

<p>У ведомых серверов, как правило, есть высокие рабочие нагрузки, потому что
они обрабатывают все операции <span><strong>DML</strong></span>, переданные
от ведущего устройства, так же как пользовательские запросы. Чтобы
гарантировать, что ведомые серверы могут применить изменения от ведущего
устройства достаточно быстро, у них часто есть быстрые устройства
ввода/вывода, достаточный центральный процессор и память, чтобы выполнить
многократные экземпляры базы данных на том же самом ведомом сервере.
Например, главный сервер мог бы использовать жесткий диск в то время, как
ведомые серверы используют <span><strong>SSD</strong></span>.</p>

<p>См. <a href="#glos_dml">DML</a>,
<a href="#glos_replication">replication</a>,
<a href="#glos_server">server</a>,
<a href="#glos_ssd">SSD</a>.</dd>

<dt><a name="glos_slow_query_log"></a><span>Медленный журнал запроса
</span></dt>
<dd><p>Тип <span><strong>журнала</strong></span>, используемого для
исполнительной настройки запросов SQL, обработан сервером MySQL. Информация
журнала хранится в файле. Вы должны активировать эту опцию, чтобы
использовать это. Вы управляете, какие категории медленных запросов SQL
зарегистрированы. Для получения дополнительной информации см.
<a href="server.htm#slow-query-log">раздел 6.4.5</a>.</p>
<p>См. <a href="#glos_general_query_log">general query log</a>,
<a href="#glos_log">log</a>.</dd>

<dt><a name="glos_slow_shutdown"></a><span>Медленное завершение работы
</span></dt>
<dd><p>Тип завершения работы, которое делает дополнительный
сброс <code>InnoDB</code> перед завершением. Также известный как
<span><strong>чистое завершение работы</strong></span>. Определен параметром
конфигурации <a href="innodb.htm#sysvar_innodb_fast_shutdown"><code>
innodb_fast_shutdown=0</code></a> или командой <code>SET GLOBAL
innodb_fast_shutdown=0;</code>. Хотя само завершение работы может занять
больше времени, это время будет сэкономлено при последующем запуске.</p>

<p>См. <a href="#glos_clean_shutdown">clean shutdown</a>,
<a href="#glos_fast_shutdown">fast shutdown</a>,
<a href="#glos_shutdown">shutdown</a>.</dd>

<dt><a name="glos_snapshot"></a><span>Снимок</span></dt>
<dd><p>Представление данных в определённое время, которое остается тем же
самым, когда изменения <span><strong>переданы</strong></span> другими
<span><strong>транзакциями</strong></span>. Используется определенными
<span><strong>уровнями изоляции</strong></span>, чтобы
позволить <span><strong>последовательные чтения</strong></span>.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_sort_buffer"></a><span>Буфер сортировки</span></dt>
<dd><p>Буфер, используемый для того, чтобы сортировать данные во время
создания индекса <code>InnoDB</code>. Размер настроен опцией
<a href="innodb.htm#sysvar_innodb_sort_buffer_size">
<code>innodb_sort_buffer_size</code></a>.</dd>

<dt><a name="glos_space_id"></a><span>ID пространства</span></dt>
<dd><p>Идентификатор, используемый, чтобы уникально идентифицировать
<span><strong>табличное пространство</strong></span> <code>InnoDB</code>
в пределах экземпляра MySQL. ID для <span><strong>системного табличного
пространства</strong></span> всегда ноль, это же самое ID относится ко всем
таблицам в пределах системного табличного пространства или в пределах общего
табличного пространства. У каждого табличного пространства
<span><strong>file-per-table</strong></span>
и общего табличного пространства есть свой собственный ID.</p>

<p>С MySQL 5.6 Вы можете скопировать файлы табличного пространства между
экземплярами при использовании <span><strong>мобильной</strong></span>
особенности табличного пространства, используя <code>FLUSH TABLES ... FOR
EXPORT</code>, <code>ALTER TABLE ... DISCARD TABLESPACE</code> и
<code>ALTER TABLE ... IMPORT TABLESPACE</code>.
Информация должна была корректировать ID в <span><strong>файле .cfg</strong>
</span>, который Вы копируете наряду с табличным пространством. См.
<a href="innodb.htm#tablespace-copying">раздел 16.7.6</a>.</p>

<p>См. <a href="#glos_cfg_file">.cfg file</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_tablespace">tablespace</a>,
<a href="#glos_transportable_tablespace">transportable tablespace</a>.</dd>

<dt><a name="glos_sparse_file"></a><span>Редкий файл</span></dt>
<dd><p>Тип файла, который использует пространство файловой системы более
эффективно при записи метаданных, представляющих пустые блоки вместо того,
чтобы писать фактическое пустое место. <code>InnoDB</code>
прозрачная особенность сжатия страницы полагается на эту поддержку, см.
<a href="innodb.htm#innodb-page-compression">раздел 16.9.2</a>.</p>

<p>См. <a href="#glos_hole_punching">hole punching</a>,
<a href="#glos_transparent_page_compression">
transparent page compression</a>.</dd>

<dt><a name="glos_spin"></a><span>spin</span></dt>
<dd><p>Тип <span><strong>ожидания</strong></span>, которая непрерывно
проверяет, становится ли ресурс доступным. Этот метод используется для
ресурсов, которые, как правило, проводятся только в течение кратких периодов,
где более эффективно ждать, чем поместить поток в спячку и выполнить
переключение контекста. Если ресурс не становится доступным в пределах
короткого времени, цикл прекращается, и используется другой метод ожидания.
</p>

<p>См. <a href="#glos_latch">latch</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_mutex">mutex</a>,
<a href="#glos_wait">wait</a>.</dd>

<dt><a name="glos_sql"></a><span>SQL</span></dt>
<dd><p>Structured Query Language, который является стандартным для того,
чтобы выполнить операции базы данных. Часто разделен на категории
<span><strong>DDL</strong></span>, <span><strong>DML</strong></span> и
<span><strong>запросы</strong></span>. MySQL включает некоторые
дополнительные категории запроса, такие как <span><strong>репликация</strong>
</span>.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_query">query</a>,
<a href="#glos_replication">replication</a>.</dd>

<dt><a name="glos_ssd"></a><span>SSD</span></dt>
<dd><p>Сокращение от "solid-state drive".
Тип устройства хранения данных с различными техническими характеристиками,
чем традиционный жесткий диск (<span><strong>HDD</strong></span>):
меньшая емкость хранения, быстрее для случайных чтений, никаких движущихся
частей. Его технические характеристики могут влиять на пропускную способность
нагрузок <span><strong>disk-bound</strong></span>.</p>
<p>См. <a href="#glos_disk_bound">disk-bound</a>,
<a href="#glos_ssd">SSD</a>.</dd>

<dt><a name="glos_startup"></a><span>Запуск</span></dt>
<dd><p>Процесс запуска сервера MySQL. Как правило,
сделан одной из программ, перечисленных в
<a href="programs.htm#programs-server">разделе 5.3</a>.</p>
<p>См. <a href="#glos_shutdown">shutdown</a>.</dd>

<dt><a name="glos_statement_based_replication"></a><span>
Основанная на запросе репликация</span></dt>
<dd><p>Форма <span><strong>репликации</strong></span>, где запросы SQL
посылают из <span><strong>главного сервера</strong></span> и переиграны на
<span><strong>ведомом</strong></span> сервере. Требуется некоторая работа с
установкой для опции <a href="innodb.htm#sysvar_innodb_autoinc_lock_mode">
<code>innodb_autoinc_lock_mode</code></a>, чтобы избежать потенциальных
проблем синхронизации с <span><strong>блокировкой auto-increment</strong>
</span>.</p>

<p>См. <a href="#glos_auto_increment_locking">
auto-increment locking</a>,
<a href="#glos_innodb_autoinc_lock_mode">innodb_autoinc_lock_mode
</a>, <a href="#glos_master_server">master server</a>,
<a href="#glos_replication">replication</a>,
<a href="#glos_row_based_replication">row-based replication</a>,
<a href="#glos_slave_server">slave server</a>.</dd>

<dt><a name="glos_statistics"></a><span>Статистика</span></dt>
<dd><p>Ориентировочные стоимости, касающиеся каждой
<span><strong>таблицы</strong></span> и <span><strong>индекса</strong></span>
<code>InnoDB</code>, используемые, чтобы создать эффективный
<span><strong>план выполнения запроса</strong></span>. Основные значения это
<span><strong>количество элементов</strong></span> (число отличных значений)
и общее количество строк таблицы или индексных записей. Статистические данные
для таблицы представляют данные в индексе <span><strong>primary key</strong>
</span>. Статистические данные для <span><strong>вторичного индекса</strong>
</span> представляют строки, покрытые этим индексом.</p>

<p>Значения оценены, а не посчитаны точно, потому что в любой момент
различные <span><strong>транзакции</strong></span> могут вставлять и удалять
строки из той же самой таблицы. Чтобы препятствовать частому повторному
вычислению значений, Вы можете включить <span><strong>постоянную статистику
</strong></span>, где значения сохранены в системные таблицы <code>InnoDB
</code> и освежены только, когда Вы командуете
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.</p>

<p>Вы можете управлять, как обработаны <span><strong>NULL</strong></span>,
вычисляя статистику через опцию
<a href="innodb.htm#sysvar_innodb_stats_method">
<code>innodb_stats_method</code></a>.</p>

<p>Другие типы статистики доступны для объектов базы данных и деятельности
базы данных через таблицы <span><strong>INFORMATION_SCHEMA</strong></span> и
<span><strong>PERFORMANCE_SCHEMA</strong></span>.</p>

<p>См. <a href="#glos_cardinality">cardinality</a>,
<a href="#glos_index">index</a>,
<a href="#glos_information_schema">INFORMATION_SCHEMA</a>,
<a href="#glos_null">NULL</a>,
<a href="#glos_performance_schema">Performance Schema</a>,
<a href="#glos_persistent_statistics">persistent statistics</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_query_execution_plan">query execution plan</a>,
<a href="#glos_secondary_index">secondary index</a>,
<a href="#glos_table">table</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_stemming"></a><span>Происхождение</span></dt>
<dd><p>Способность искать различные изменения слова, основанного на общем
слове корня, такие как исключительный, множественный и будущее время глагола.
Эта функция в настоящее время поддерживается в MyISAM с фнукцией
<span><strong>full-text search</strong></span>, но не в
<span><strong>индексах FULLTEXT</strong></span> для InnoDB.</p>
<p>См. <a href="#glos_full_text_search">full-text search</a>,
<a href="#glos_fulltext_index">FULLTEXT index</a>.</dd>

<dt><a name="glos_stopword"></a><span>stopword</span></dt>
<dd><p>В <span><strong>индексе FULLTEXT</strong></span> слово,
которое считают настольуо распространенным или тривиальным, что оно опущено
в <span><strong>поисковом индексе</strong></span> и проигнорировано в
запросах поиска. Различные настройки конфигурации управляют stopword для
таблиц <code>InnoDB</code> и <code>MyISAM</code>, см.
<a href="funct.htm#fulltext-stopwords">раздел 13.9.4</a>.</p>
<p>См. <a href="#glos_fulltext_index">FULLTEXT index</a>,
<a href="#glos_search_index">search index</a>.</dd>

<dt><a name="glos_storage_engine"></a><span>Механизм хранения</span></dt>
<dd><p>Компонент базы данных MySQL, который выполняет низкоуровневую работу
хранения, обновления и запросов данных. В MySQL 5.5 и выше
<span><strong>InnoDB</strong></span> механизм хранения по умолчанию для новых
таблиц вместо MyISAM. Различные механизмы хранения разработаны с различными
факторами. Каждый механизм хранения управляет определенными таблицами, таким
образом, мы обращаемся к таблицам <a href="innodb.htm"><code>InnoDB</code>
</a>, <a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a> и
т.д.</p>

<p><span><strong>MySQL Enterprise Backup</strong></span> оптимизирован
для того, чтобы поддержать таблицы InnoDB. Это может также поддержать
таблицы, обработанные MyISAM и другими механизмами хранения.</p>

<p>См. <a href="#glos_innodb">InnoDB</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_table_type">table type</a>.</dd>

<dt><a name="glos_strict_mode"></a><span>Строгий режим</span></dt>
<dd><p>Общее название установки, которой управляет опция
<a href="innodb.htm#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a>. Включение этой установки вызывает определенные условия, которые
обычно обрабатываются как предупреждения, чтобы считаться ошибками. Например,
определенные недопустимые комбинации опций, связанных с
<span><strong>форматом файла</strong></span> и
<span><strong>форматом строки</strong></span>,
которые обычно производят предупреждение и продолжаются со значениями по
умолчанию, теперь вызывают ошибку в <code>CREATE TABLE</code>.</p>

<p>У MySQL также есть что-то названное строгим режимом.</p>
<p>См. <a href="#glos_file_format">file format</a>,
<a href="#glos_innodb_strict_mode">innodb_strict_mode</a>,
<a href="#glos_row_format">row format</a>.</dd>

<dt><a name="glos_sublist"></a><span>Подсписок</span></dt>
<dd><p>В пределах структуры списка, которая представляет буферный пул,
страницы, которые относительно стары и относительно новые, представлены
различными частями списка. Ряд параметров управляет размером этих частей и
точкой раздела между новыми и старыми страницами.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_eviction">eviction</a>,
<a href="#glos_list">list</a>,
<a href="#glos_lru">LRU</a>.</dd>

<dt><a name="glos_supremum_record"></a><span>supremum</span></dt>
<dd><p><span><strong>Псевдозапись</strong></span> в индексе, представляет
<span><strong>промежуток</strong></span> выше самого большого значения в этом
индексе. Если у транзакции есть такой запрос, как <code>SELECT ... FOR UPDATE
... WHERE col &gt; 10;</code> и самое большое значение в столбце 20,
блокировка на записи supremum препятствует тому, чтобы другие транзакции
вставили еще большие значения, такие как 50, 100 и так далее.</p>

<p>См. <a href="#glos_gap">gap</a>,
<a href="#glos_infimum_record">infimum record</a>,
<a href="#glos_pseudo_record">pseudo-record</a>.</dd>

<dt><a name="glos_surrogate_key"></a><span>Суррогатный ключ</span></dt>
<dd><p>Синоним для <span><strong>synthetic key</strong></span>.</p>
<p>См. <a href="#glos_synthetic_key">synthetic key</a>.</dd>

<dt><a name="glos_synthetic_key"></a><span>Синтетический ключ</span></dt>
<dd><p>Индексированный столбец, как правило <span><strong>первичный ключ
</strong></span>, где значения назначены произвольно. Часто использует
<span><strong>auto-increment</strong></span>. Обрабатывая значение как
абсолютно произвольное, Вы можете избежать чрезмерно рестриктивных правил и
дефектных предположений приложения. Числовые значения также производят более
короткие значения предсказуемой длины. Например, хранить числовые коды,
означающие "Road", "Boulevard", "Expressway" и так далее более эффективно с
точки зрения места, чем повторение тех строк много раз.</p>
<p>Также известный как <span><strong>surrogate key</strong></span>.</p>

<p>См. <a href="#glos_auto_increment">auto-increment</a>,
<a href="#glos_natural_key">natural key</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_surrogate_key">surrogate key</a>.</dd>

<dt><a name="glos_system_tablespace"></a><span>
Системное табличное пространство</span></dt>
<dd><p>Один или более файлов с данными (файлы
<span><strong>ibdata</strong></span>), содержащий метаданные для
InnoDB-связанных объектов, и области хранения для одного или более
<span><strong>журналов отмены</strong></span>, <span><strong>буфера изменения
</strong></span> и <span><strong>буфера doublewrite</strong></span>. Это
может также содержать таблицу и индексные данные для таблиц InnoDB, если
таблицы были составлены в системном табличном пространстве вместо
file-per-table или общих табличных пространствах. Данные и метаданные в
системном табличном пространстве относятся ко всем <span><strong>базам данных
</strong></span> в <span><strong>экземпляре</strong></span> MySQL.</p>

<p>До MySQL 5.6.7 значение по умолчанию должно было сохранить все таблицы
InnoDB и индексы в системном табличном пространстве, часто заставляя этот
файл стать очень большим. Поскольку системное табличное пространство никогда
не сжимается, проблемы хранения могли возникнуть, если бы большое количество
временных данных было загружено и затем удалено. В MySQL 8.0 значение по
умолчанию это режим <span><strong>file-per-table</strong></span>,
где каждая таблица и его связанный индекс сохранены в отдельном
<span><strong>файле .ibd</strong></span>. Это новое значение по умолчанию
облегчает использовать функции InnoDB, которые полагаются на форматы строки
<code>DYNAMIC</code> и <code>COMPRESSED</code>, например,
<span><strong>сжатие</strong></span>, хранение вне страницы длинных значений
столбцов переменной длины и большие индексные ключевые префиксы
(<a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_large_prefix"
target="_top"><code>innodb_large_prefix</code></a>).</p>

<p>Опция <a href="innodb.htm#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> позволяет Вам конфигурировать отдельные
файлы табличного пространства для журналов отмены. Эти файлы все еще
считаются частью системного табличного пространства.</p>

<p>Хранение всех табличных данных в системном табличном пространстве или в
отдельном <code>.ibd</code> имеет значение для управления хранением вообще.
<span><strong>MySQL Enterprise Backup</strong></span>
мог бы поддержать маленький набор больших файлов или много меньших файлов. На
системах с тысячами таблиц, операции файловой системы для
тысяч файлов <code>.ibd</code> могут вызвать узкие места.</p>

<p>InnoDB добавил общие табличные пространства в MySQL 5.7.6, которые также
представлены файлами <code>.ibd</code>. Общие табличные пространства
это совместно используемые табличные пространства, создаваемые
<a href="sql.htm#create-tablespace"><code>CREATE TABLESPACE</code></a>.
Они могут быть созданы за пределами каталога данных MySQL, способны к
хранению многих таблиц и поддерживают таблицы всех форматов строки.</p>

<p>См. <a href="#glos_change_buffer">change buffer</a>,
<a href="#glos_compression">compression</a>,
<a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_database">database</a>,
<a href="#glos_doublewrite_buffer">doublewrite buffer</a>,
<a href="#glos_dynamic_row_format">dynamic row format</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_ibdata_file">ibdata file</a>,
<a href="#glos_innodb_file_per_table">innodb_file_per_table</a>,
<a href="#glos_instance">instance</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_tablespace">tablespace</a>,
<a href="#glos_undo_log">undo log</a>.</p></dd></dl>

<h3>T</h3>
<dl><dt><a name="glos_table"></a><span>Таблица</span></dt>
<dd><p>Каждая таблица MySQL связана с особым <span><strong>механизмом
хранения</strong></span>. У таблиц <span><strong>InnoDB</strong></span> есть
особые <span><strong>физические</strong></span> и <span><strong>логические
</strong></span> характеристики, которые затрагивают работу, <span><strong>
масштабируемость</strong></span>, <span><strong>резервное копирование
</strong></span> и разработку приложений.</p>

<p>С точки зрения хранения файла таблица InnoDB принадлежит к одному из
следующих типов табличного пространства:</p>
<ul><li><p>Совместно используемое <span><strong>системное табличное
пространство</strong></span> InnoDB, которое состоит из одного или
больше файлов <code>.ibdata</code>.</li>

<li>Табличное пространство file-per-table, состоявшее из
отдельных файлов <code>.ibd</code>.</li>
<li>Совместно используемое общее табличное пространство, состоявшее из
отдельных файлов <code>.ibd</code>. Добавлены в MySQL 5.7.6.</p></li></ul>

<p>Файлы с данными <span><strong><code>.ibd</code></strong></span>
содержат таблицу и <span><strong>индексные</strong></span> данные.</p>
<p>Таблицы InnoDB, составленные в табличных пространствах file-per-table,
могут использовать формат строки <span><strong>DYNAMIC</strong></span> или
<span><strong>COMPRESSED</strong></span>.
Эти форматы строки активируют такие опции InnoDB, как
<span><strong>сжатие</strong></span>,
<span><strong>столбцы вне страницы</strong></span> и префиксы индексного
ключа (см. <a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_large_prefix"
target="_top"><code>innodb_large_prefix</code></a>).
Общие табличные пространства поддерживают все форматы строки.</p>

<p>Системное табличное пространство поддерживает таблицы, которые используют
форматы строки <span><strong>REDUNDANT</strong></span>,
<span><strong>COMPACT</strong></span> и
<span><strong>DYNAMIC</strong></span>.
Системная поддержка табличного пространства для формата строки
<span><strong>DYNAMIC</strong></span> была добавлена в MySQL 5.7.6.</p>

<p><span><strong>Строки</strong></span> таблицы InnoDB организованы в
индексированную структуру, известную как
<span><strong>кластеризируемый индекс</strong></span>,
с записями, сортированными основываясь на столбцах
<span><strong>primary key</strong></span>. Доступ к данным оптимизирован для
запросов, которые фильтруют и сортируют на столбцах первичного ключа, и
каждый индекс содержит копию связанных столбцов первичного ключа для каждой
записи. Изменение значений для любого из столбцов первичного ключа является
дорогой работой. Таким образом важный аспект табличного проекта InnoDB это
выбрать первичный ключ со столбцами, которые используются в самых важных
запросах, и хранение короткого первичного ключа с редким изменением значений.
</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_clustered_index">clustered index</a>,
<a href="#glos_compact_row_format">compact row format</a>,
<a href="#glos_compressed_row_format">compressed row format</a>,
<a href="#glos_compression">compression</a>,
<a href="#glos_dynamic_row_format">dynamic row format</a>,
<a href="#glos_fast_index_creation">Fast Index Creation</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_index">index</a>,
<a href="#glos_off_page_column">off-page column</a>,
<a href="#glos_primary_key">primary key</a>,
<a href="#glos_redundant_row_format">redundant row format</a>,
<a href="#glos_row">row</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_table_lock"></a><span>Табличная блокировка</span></dt>
<dd><p>Блокировка, которая препятствует тому, чтобы любая другая
<span><strong>транзакция</strong></span> получила доступ к таблице. InnoDB
прилагает значительное усилие, чтобы сделать такие блокировки ненужными, при
использовании таких методов, как <span><strong>online DDL</strong></span>,
<span><strong>блокировки строки</strong></span> и
<span><strong>последовательные чтения</strong></span>
для того, чтобы обработать запросы и <span><strong>DML</strong></span>.
Вы можете создать такую блокировку через SQL использованием
<code>LOCK TABLE</code>, один из шагов в перемещении от других систем базы
данных или механизмов хранения MySQL должен удалить такие запросы
везде, где можно.</p>

<p>См. <a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_dml">DML</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_locking">locking</a>,
<a href="#glos_online_ddl">online DDL</a>,
<a href="#glos_query">query</a>,
<a href="#glos_row_lock">row lock</a>,
<a href="#glos_table">table</a>,
<a href="#glos_transaction">transaction</a>.</dd>

<dt><a name="glos_table_scan"></a><span>table scan</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_full_table_scan">
full table scan</a>.</dd>

<dt><a name="glos_table_statistics"></a><span>table statistics</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_statistics">
statistics</a>.</dd>

<dt><a name="glos_table_type"></a><span>Табличный тип</span></dt>
<dd><p>Синоним для <span><strong>механизма хранения</strong></span>.
Мы обращаемся к таблицам <a href="innodb.htm"><code>InnoDB</code></a>,
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a> и т.д.
</p>
<p>См. <a href="#glos_innodb">InnoDB</a>,
<a href="#glos_storage_engine">storage engine</a>.</dd>

<dt><a name="glos_tablespace"></a><span>Табличное пространство</span></dt>
<dd><p>Файл с данными, который может содержать данные для одной или более
<span><strong>таблиц</strong></span> с <span><strong>индексами</strong>
</span>.</p>

<p><span><strong>Системное табличное пространство</strong></span> содержит
таблицы, которые составляют <span><strong>словарь данных</strong></span>
и до MySQL 5.6 все другие таблицы InnoDB по умолчанию.</p>

<p>Опция <a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>, которая включена по умолчанию в MySQL 5.6 и
выше, позволяет таблицам создаваться в табличных пространствах file-per-table
с отдельным <span><strong>файлом данных</strong></span> для каждой таблицы.
Включение <a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> делает доступными другие особенности MySQL,
такие как табличное сжатие и мобильные табличные пространства. См.
<a href="innodb.htm#innodb-multiple-tablespaces">раздел 16.7.4</a>.</p>

<p>MySQL Cluster также группирует свои таблицы в табличные пространства. См.
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster-disk-data-objects.html"
target="_top">MySQL Cluster Disk Data Objects</a>.</p>

<p>См. <a href="#glos_compressed_row_format">
compressed row format</a>,
<a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_data_files">data files</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_index">index</a>,
<a href="#glos_innodb_file_per_table">innodb_file_per_table</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_table">table</a>.</dd>

<dt><a name="glos_tablespace_dictionary"></a><span>
Словарь табличного пространства</span></dt>
<dd><p>Словарь табличного пространства существует в постоянном
табличном пространстве <code>InnoDB</code>. Это хранит Serialized Dictionary
Information (SDI) для объектов в пределах табличного пространства.</p>

<p>См. <a href="#glos_data_dictionary">data dictionary</a>,
<a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_frm_file">.frm file</a>,
<a href="#glos_general_tablespace">general tablespace</a>,
<a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_temporary_table"></a><span>Временная таблица</span></dt>
<dd><p>Таблица, данные которой не должны быть действительно постоянными.
Например, временные таблицы могли бы использоваться в качестве областей
хранения для промежуточных результатов в сложных вычислениях или
преобразованиях, эти промежуточные данные не должны быть восстановлены после
катастрофического отказа. Продукты базы данных могут взять различные ярлыки,
чтобы улучшить исполнение операций на временных таблицах, будучи менее
скрупулезными в плане записи данных на диск и других мер, чтобы защитить
данные через перезапуски.</p>

<p>Иногда сами данные удалены автоматически в установленное время, например,
когда транзакция или сеанс заканчивается. С некоторыми продуктами базы данных
сама таблица удалена автоматически также.</p>
<p>См. <a href="#glos_table">table</a>.</dd>

<dt><a name="glos_temporary_tablespace"></a><span>
Временное табличное пространство</span></dt>
<dd><p>Табличное пространство для несжатых временных таблиц и связанных
объектов <code>InnoDB</code>, введенное в MySQL 5.7.1.
Опция конфигурационного файла
<a href="innodb.htm#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a> позволяет пользователям определять
относительный путь для временного файла с данными табличного пространства.
Если <a href="innodb.htm#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a> не определена, поведение по умолчанию
должно создать единственный автомасштабируемый файл в 12MB с именем
<code>ibtmp1</code> в каталоге данных, рядом с системными файлами табличного
пространства <code>ibdata</code>. Временное табличное пространство обновлено
при каждом запуске сервере и получает динамически произведенное ID,
которое помогает избежать конфликтов с существующими ID.
Временное табличное пространство не может находиться на сыром устройстве.
В запуске отказывают, если временное табличное пространство не
может быть создано.</p>

<p>Временное табличное пространство удалено при нормальном завершении работы
или прерванной инициализации. Временное табличное пространство не удалено,
когда катастрофический отказ происходит. В этом случае администратор базы
данных может удалить временное табличное пространство вручную или
перезапустить сервер с той же самой конфигурацией, которая удаляет и
обновляет временное табличное пространство.</p>
<p>См. <a href="#glos_ibtmp_file">ibtmp file</a>.</dd>

<dt><a name="glos_text_collection"></a><span>Текстовый набор</span></dt>
<dd><p>Набор столбцов, включенных в <span><strong>индекс FULLTEXT</strong>
</span>.</p>
<p>См. <a href="#glos_fulltext_index">FULLTEXT index</a>.</dd>

<dt><a name="glos_thread"></a><span>Поток</span></dt>
<dd><p>Модуль обработки, которая, как правило, более легка, чем
<span><strong>процесс</strong></span>, учитывая больший <span><strong>
параллелизм</strong></span>.</p>

<p>См. <a href="#glos_concurrency">concurrency</a>,
<a href="#glos_master_thread">master thread</a>,
<a href="#glos_process">process</a>,
<a href="#glos_pthreads">Pthreads</a>.</dd>

<dt><a name="glos_torn_page"></a><span>Порванная страница</span></dt>
<dd><p>Состояние ошибки, которое может произойти из-за комбинации
конфигурации устройства ввода/вывода и отказа аппаратных средств. Если
данные выписаны в кусках, меньших чем <span><strong>размер страницы</strong>
</span> InnoDB (по умолчанию 16KB), отказ аппаратных средств в момент записи
мог привести к только части страницы, сохраненной на диск.
<span><strong>Буфер doublewrite</strong></span> принимает меры
против этой возможности.</p>
<p>См. <a href="#glos_doublewrite_buffer">doublewrite buffer</a>.</dd>

<dt><a name="glos_tps"></a><span>TPS</span></dt>
<dd><p>Сокращение от "<span><strong>transactions</strong></span> per
second", модуль измерения, иногда используется в точках отсчета. Его значение
зависит от <span><strong>рабочей нагрузки</strong></span>, представленной
особым оценочным испытанием, объединенным с факторами, которыми Вы
управляете, такие как пропускная способность аппаратных средств и
конфигурация базы данных.</p>
<p>См. <a href="#glos_transaction">transaction</a>,
<a href="#glos_workload">workload</a>.</dd>

<dt><a name="glos_transaction"></a><span>Транзакция</span></dt>
<dd><p>Транзакции это атомные единицы работы, которые могут быть переданы или
отменены. Когда транзакция производит многократные изменения в базе данных,
или все изменения преуспевают, когда транзакция передана, или все изменения
отменены, когда транзакция отменена.</p>

<p>У транзакций базы данных, как осуществлено InnoDB, есть свойства, которые
все вместе известны как <span><strong>ACID</strong></span>.</p>
<p>См. <a href="#glos_acid">ACID</a>,
<a href="#glos_commit">commit</a>,
<a href="#glos_isolation_level">isolation level</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_rollback">rollback</a>.</dd>

<dt><a name="glos_transaction_id"></a><span>ID транзакции</span></dt>
<dd><p>Внутренняя область, связанная с каждой строкой. Эта область физически
изменена INSERT, UPDATE и DELETE, чтобы сделать запись, какая
транзакция заблокировала строку.</p>
<p>См. <a href="#glos_implicit_row_lock">implicit row lock</a>.
</dd>

<dt><a name="glos_transparent_page_compression"></a><span>
Прозрачное сжатие страницы</span></dt>
<dd><p>Особенность в MySQL 5.7.8 и выше, которая разрешает сжатие на уровне
страницы для таблиц <code>InnoDB</code>, которые находятся в табличных
пространствах file-per-table. Сжатие страницы включено, определяя признак
<code>COMPRESSION</code> в <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a> или <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
См. <a href="innodb.htm#innodb-page-compression">раздел 16.9.2</a>.</p>

<p>См. <a href="#glos_file_per_table">file-per-table</a>,
<a href="#glos_hole_punching">hole punching</a>,
<a href="#glos_sparse_file">sparse file</a>.</dd>

<dt><a name="glos_transportable_tablespace"></a><span>
Мобильное табличное пространство</span></dt>
<dd><p>Особенность, которая позволяет <span><strong>табличному пространству
</strong></span> быть перемещенным от одного экземпляра в другой.
Традиционно это не было возможно для табличных пространств InnoDB, потому
что все табличные данные были частью
<span><strong>системного табличного пространства</strong></span>. В MySQL
5.6 и выше <a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code>
</a> готовит таблицу InnoDB к тому, что она будет скопирована на другой
сервер, выполнение <a href="sql.htm#alter-table"><code>ALTER TABLE ...
DISCARD TABLESPACE</code></a> и <a href="sql.htm#alter-table"><code>ALTER
TABLE ... IMPORT TABLESPACE</code></a> на другом сервере
приносит скопированный файл с данными. Отдельный файл <code>.cfg</code>,
скопированный наряду с <span><strong>файлом .ibd</strong></span>,
используется, чтобы обновить табличные метаданные (например,
<span><strong>space ID</strong></span>), см.
<a href="innodb.htm#tablespace-copying">раздел 16.7.6</a>.</p>

<p>См. <a href="#glos_ibd_file">.ibd file</a>,
<a href="#glos_space_id">space ID</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_tablespace">tablespace</a>.</dd>

<dt><a name="glos_troubleshooting"></a><span>Поиск неисправностей</span></dt>
<dd><p>Ресурсы для того, чтобы расследовать надежность InnoDB и
исполнительные проблемы включают таблицы Information Schema.</dd>

<dt><a name="glos_truncate"></a><span>truncate</span></dt>
<dd><p>Операция <span><strong>DDL</strong></span>, которая удаляет все
содержание таблицы и связанный индекс.
Хотя концептуально у этого есть тот же самый результат, как у
<code>DELETE</code> без <code>WHERE</code>, это работает по-другому негласно:
InnoDB составляет новую пустую таблицу, удаляет старую таблицу, затем
переименовывает новую таблицу. Поскольку это работа DDL, это не
может быть <span><strong>отменено</strong></span>.</p>

<p>Если таблица, являющаяся усеченной, содержит внешние ключи, которые
ссылаются на другую таблицу, работа усечения использует более медленный метод
работы, удаляя одну строку за один раз так, чтобы соответствующие строки в
таблице, на которую ссылаются, могли быть удалены как необходимо любым
параметром <code>ON DELETE CASCADE</code>. MySQL 5.5 и выше не позволяют
эту более медленную форму и возвращают ошибку вместо этого, если внешние
ключи вовлечены. В этом случае используйте <code>DELETE</code>.</p>

<p>См. <a href="#glos_ddl">DDL</a>,
<a href="#glos_drop">drop</a>,
<a href="#glos_foreign_key">foreign key</a>,
<a href="#glos_rollback">rollback</a>.</dd>

<dt><a name="glos_tuple"></a><span>tuple</span></dt>
<dd><p>Технический термин, определяющий упорядоченный набор элементов. Это
абстрактное понятие, используемое в формальных обсуждениях теории базы
данных. В области базы данных кортежи обычно представляются столбцами строки
таблицы. Они могли также быть представлены наборами результатов запросов,
например, запросы, которые получали только некоторые столбцы таблицы, или
столбцы от таблиц, к которым присоединяются.</p>
<p>См. <a href="#glos_cursor">cursor</a>.</dd>

<dt><a name="glos_two_phase_commit"></a><span>Двухфазовая передача
</span></dt>
<dd><p>Работа, которая является частью распределенной
<span><strong>транзакции</strong></span> под спецификацией <span><strong>XA
</strong></span>. Иногда сокращаемая как 2PC. Когда многократные базы данных
участвуют в транзакции, или все базы данных
<span><strong>передают</strong></span> изменения, или все базы
данных <span><strong>отменяют</strong></span> изменения.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_rollback">rollback</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_xa">XA</a>.</p></dd></dl>

<h3>U</h3>
<dl><dt><a name="glos_undo"></a><span>Отмена</span></dt>
<dd><p>Данные, которые поддержаны в течение жизни <span><strong>транзакции
</strong></span>, делая запись всех изменений так, чтобы они могли быть
отменены в случае работы операции <span><strong>отмены</strong></span>.
Это сохранено в <span><strong>журнале отмены</strong></span> в пределах
<span><strong>системного табличного пространства</strong></span> или в
отдельных <span><strong>табличных пространствах отмены</strong></span>.</p>

<p>См. <a href="#glos_rollback">rollback</a>,
<a href="#glos_rollback_segment">rollback segment</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_undo_log">undo log</a>,
<a href="#glos_undo_tablespace">undo tablespace</a>.</dd>

<dt><a name="glos_undo_buffer"></a><span>Буфер отмены</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_undo_log">undo log
</a>.</dd>

<dt><a name="glos_undo_log"></a><span>Журнал отмены</span></dt>
<dd><p>Область хранения, которая хранит копии данных, измененные активными
<span><strong>транзакциями</strong></span>. Если другая транзакция должна
видеть оригинальные данные (как часть <span><strong>последовательной</strong>
</span> работы <span><strong>чтения</strong></span>), неизмененные данные
получены от этой области хранения.</p>

<p>По умолчанию эта область физически часть <span><strong>системного
табличного пространства</strong></span>. В MySQL 5.6 и выше Вы можете
использовать опции <a href="innodb.htm#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> и
<a href="innodb.htm#sysvar_innodb_undo_directory"><code>innodb_undo_directory
</code></a>, чтобы разделить это на один или более отдельных файлов
<span><strong>табличного пространства</strong></span>, <span><strong>
табличные пространства отмены</strong></span> произвольно сохранены на другом
устройстве хранения данных, таком как <span><strong>SSD</strong></span>.</p>

<p>Журнал отмены разделен на отдельные части:
<span><strong>буфер отмены вставки</strong></span> и
<span><strong>буфер отмены обновления</strong></span>.</p>

<p>См. <a href="#glos_consistent_read">consistent read</a>,
<a href="#glos_rollback_segment">rollback segment</a>,
<a href="#glos_ssd">SSD</a>,
<a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_undo_tablespace">undo tablespace</a>.</dd>

<dt><a name="glos_undo_tablespace"></a><span>Табличное пространство отмены
</span></dt>
<dd><p>Один из ряда файлов, содержащих <span><strong>журнал отмены</strong>
</span>, когда журнал отмены отделен от <span><strong>системного табличного
пространства</strong></span>, используя опции
<a href="innodb.htm#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> и
<a href="innodb.htm#sysvar_innodb_undo_directory"><code>
innodb_undo_directory</code></a>. Только для MySQL 5.6 и выше.</p>
<p>См. <a href="#glos_system_tablespace">system tablespace</a>,
<a href="#glos_undo_log">undo log</a>.</dd>

<dt><a name="glos_unique_constraint"></a><span>Уникальное ограничение
</span></dt>
<dd><p>Своего рода <span><strong>ограничение</strong></span>, которое
утверждает, что столбец не может содержать двойные значения. С точки зрения
<span><strong>относительной</strong></span> алгебры это используется, чтобы
определить отношения 1 к 1. Для эффективности в проверке, может ли значение
быть вставлено (то есть, значение не существует в столбце),
уникальное ограничение поддержано основным <span><strong>уникальным индексом
</strong></span>.</p>

<p>См. <a href="#glos_constraint">constraint</a>,
<a href="#glos_relational">relational</a>,
<a href="#glos_unique_index">unique index</a>.</dd>

<dt><a name="glos_unique_index"></a><span>Уникальный индекс</span></dt>
<dd><p>Индекс на столбце или наборе столбцов, у которых есть
<span><strong>уникальное ограничение</strong></span>. Поскольку
индексирование, как известно, не содержит любые двойные значения,
определенные виды поисков и операций более эффективны, чем в нормальном
индексе. Большинство поисков для этого типа индекса должны просто определить,
существует ли определенное значение или нет. Число значений в индексе
является тем же самым, как число строк в таблице, или по крайней мере число
строк с ненулевыми значениями для связанных столбцов.</p>

<p>Оптимизация <span><strong>буферизации изменения</strong></span> не
относится к уникальному индексу. Как обходное решение, Вы можете временно
установить <code>unique_checks=0</code> в то время, как выполняется оптовая
загрузка данных в таблицу InnoDB.</p>

<p>См. <a href="#glos_cardinality">cardinality</a>,
<a href="#glos_change_buffering">change buffering</a>,
<a href="#glos_unique_constraint">unique constraint</a>,
<a href="#glos_unique_key">unique key</a>.</dd>

<dt><a name="glos_unique_key"></a><span>Уникальный ключ</span></dt>
<dd><p>Набор столбцов (один или больше)
<span><strong>уникального индекса</strong></span>. Когда Вы можете определить
<code>WHERE</code>, которое соответствует точно одной строке, и запрос может
использовать связанный уникальный индекс, поиск и обработка ошибок могут быть
выполнены очень эффективно.</p>

<p>См. <a href="#glos_cardinality">cardinality</a>,
<a href="#glos_unique_constraint">unique constraint</a>,
<a href="#glos_unique_index">unique index</a>.</p></dd></dl>

<h3>V</h3>
<dl><dt><a name="glos_variable_length_type"></a><span>Тип переменной длины
</span></dt>
<dd><p>Тип данных переменной длины. Типы
<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a> переменной длины. См.
<a href="types.htm#storage-requirements">раздел 12.8</a>.</p>

<p><code>InnoDB</code> рассматривает
<a href="types.htm#char"><code>CHAR</code></a>
как тип переменной длины, если таблица составлена, используя
формат строки <code>COMPACT</code>, <code>DYNAMIC</code> или
<code>COMPRESSED</code>, и значение столбца <a href="types.htm#char"><code>
CHAR</code></a> больше чем или равно 768 байтам, которые могут произойти,
если максимальная длина байта набора символов больше 3, как
это с обстоит с <code>utf8mb4</code>.</p>
<p>См. <a href="#glos_row_format">row format</a>.</dd>

<dt><a name="glos_victim"></a><span>Жертва</span></dt>
<dd><p>Транзакция, которая автоматически выбрана, чтобы быть отмененной,
когда <span><strong>тупик</strong></span> обнаружен. InnoDB отменяет
транзакцию, которая обновила наименьшее количество строк.</p>

<p>См. <a href="#glos_deadlock">deadlock</a>,
<a href="#glos_deadlock_detection">deadlock detection</a>,
<a href="#glos_innodb_lock_wait_timeout">
innodb_lock_wait_timeout</a>.</dd>

<dt><a name="glos_virtual_column"></a><span>Виртуальный столбец</span></dt>
<dd><p>См. <a class="glosssee" href="#glos_generated_virtual_column">
generated virtual column</a>.</dd>

<dt><a name="glos_virtual_index"></a><span>Виртуальный индекс</span></dt>
<dd><p>Виртуальный индекс, вторичный индекс на одном или более произведенных
виртуальных столбцов или на комбинации произведенных виртуальных столбцов и
непроизведенных виртуальных столбцов. Для получения дополнительной информации
см. <a href="sql.htm#create-table-secondary-indexes-virtual-columns">раздел
14.1.15.6</a>.</p>

<p>См. <a href="#glos_base_column">base column</a>,
<a href="#glos_generated_stored_column">generated stored column
</a>, <a href="#glos_generated_virtual_column">
generated virtual column</a>.</p></dd></dl>

<h3>W</h3>
<dl><dt><a name="glos_wait"></a><span>Ожидание</span></dt>
<dd><p>Когда работа, такая как приобретение <span><strong>блокировки</strong>
</span>, <span><strong>mutex</strong></span> или <span><strong>latch</strong>
</span>, не может быть немедленно завершена, InnoDB ждет и пробует снова.
Механизм для того, чтобы сделать паузу достаточно тщательно продуман, так что
у этой работы есть свое собственное имя, <span><strong>wait</strong></span>.
Отдельные потоки делают паузу, используя комбинацию внутреннего планирования
InnoDB, вызова операционной системы <code>wait()</code>,
и короткой продолжительности циклов <span><strong>spin</strong></span>.</p>

<p>На системах с тяжелой нагрузкой и многими транзакциями, Вы могли бы
использовать вывод <code>SHOW INNODB STATUS</code>, чтобы определить,
проводят ли потоки слишком много времени ожидая, и если это так, как Вы
можете улучшить <span><strong>параллелизм</strong></span>.</p>

<p>См. <a href="#glos_concurrency">concurrency</a>,
<a href="#glos_latch">latch</a>,
<a href="#glos_lock">lock</a>,
<a href="#glos_mutex">mutex</a>,
<a href="#glos_spin">spin</a>.</dd>

<dt><a name="glos_warm_backup"></a><span>Теплое резервное копирование
</span></dt>
<dd><p><span><strong>Резервное копирование</strong></span> в то время, как
база данных работает, но это ограничивает некоторые операции базы данных во
время резервного процесса. Например, таблицы могли бы стать только для
чтения. Для занятых приложений и веб-сайтов, Вы могли бы предпочесть
<span><strong>горячее резервное копирование</strong></span>.</p>

<p>См. <a href="#glos_backup">backup</a>,
<a href="#glos_cold_backup">cold backup</a>,
<a href="#glos_hot_backup">hot backup</a>.</dd>

<dt><a name="glos_warm_up"></a><span>Разогрев</span></dt>
<dd><p>Выполнение системы при типичной <span><strong>рабочей нагрузке
</strong></span> в течение некоторого времени после запуска, чтобы
<span><strong>буферный пул</strong></span> и другие области памяти были
заполнены, поскольку они находились бы в нормальнымх условиях.</p>

<p>Этот процесс происходит естественно в течение долгого времени, когда
сервер MySQL перезапущен или подвергнут новой рабочей нагрузке. Начиная с
MySQL 5.6, Вы можете ускорить процесс разминки, устанавливая переменные
конфигурации <a href="innodb.htm#sysvar_innodb_buffer_pool_dump_at_shutdown">
<code>innodb_buffer_pool_dump_at_shutdown=ON</code></a> и
<a href="innodb.htm#sysvar_innodb_buffer_pool_load_at_startup"><code>
innodb_buffer_pool_load_at_startup=ON</code></a>, чтобы
возвращать содержание буферного пула в память после перезапуска. Как правило,
Вы выполняете рабочую нагрузку в течение некоторого времени, чтобы нагреть
буферный пул прежде, чем выполнить тесты производительности и гарантировать
последовательные результаты, иначе работа могла бы быть искусственно низкой
во время первого показа.</p>
<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_workload">workload</a>.</dd>

<dt><a name="glos_windows"></a><span>Windows</span></dt>
<dd><p>Встроенный механизм хранения <span><strong>InnoDB</strong></span> и
InnoDB <span><strong>Plugin</strong></span> поддержаны на всех версиях
Microsoft Windows как сервер MySQL. У <span><strong>MySQL Enterprise
Backup</strong></span> есть более всесторонняя поддержка систем Windows, чем
у <span><strong>InnoDB Hot Backup</strong></span>, который это заменяет.</p>

<p>См. <a href="#glos_innodb">InnoDB</a>,
<a href="#glos_mysql_enterprise_backup">MySQL Enterprise Backup
</a>, <a href="#glos_plugin">plugin</a>.</p></dd>

<dt><a name="glos_workload"></a><span>Рабочая нагрузка</span></dt>
<dd><p>Комбинация и объем <span><strong>SQL</strong></span> и других операций
базы данных, выполненных приложением базы данных во время типичного или
пикового использования. Вы можете подвергнуть базу данных особой рабочей
нагрузке во время исполнительного тестирования, чтобы идентифицировать
<span><strong>узкие места</strong></span> или во время планирования мощностей.
</p>

<p>См. <a href="#glos_bottleneck">bottleneck</a>,
<a href="#glos_cpu_bound">CPU-bound</a>,
<a href="#glos_disk_bound">disk-bound</a>,
<a href="#glos_sql">SQL</a>.</dd>

<dt><a name="glos_write_combining"></a><span>Объединение записи</span></dt>
<dd><p>Метод оптимизации, который уменьшает операции записи, когда
<span><strong>грязные страницы</strong></span> сбрасываются из
<span><strong>буферного пула</strong></span> InnoDB.
Если строка в странице обновлена многократно или многие строки на той же
самой странице обновлены, все те изменения сохранены к файлам с данными в
одном запросе на запись, а не для каждого изменения.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_dirty_page">dirty page</a>,
<a href="#glos_flush">flush</a>.</p></dd></dl>

<h3>X</h3>
<dl><dt><a name="glos_xa"></a><span>XA</span></dt>
<dd><p>Стандартный интерфейс для того, чтобы скоординировать распределенные
<span><strong>транзакции</strong></span>, позволяя многократным базам данных
участвовать в транзакции, поддерживая <span><strong>ACID</strong></span>. См.
<a href="sql.htm#xa">раздел 14.3.7</a>.</p>

<p>XA Distributed Transaction support включена по умолчанию. Если Вы не
используете эту функцию, Вы можете отключить опцию
<a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_support_xa"
target="_top"><code>innodb_support_xa</code></a>,
избегая исполнения дополнительного fsync для каждой транзакции.</p>

<p>См. <a href="#glos_commit">commit</a>,
<a href="#glos_transaction">transaction</a>,
<a href="#glos_two_phase_commit">two-phase commit</a>.
</p></dd></dl>

<h3>Y</h3>
<dl><dt><a name="glos_young"></a><span>Свежие</span></dt>
<dd><p>Характеристика <span><strong>страницы</strong></span> в
<span><strong>буферном пуле</strong></span> <code>InnoDB</code>, имеющяя в
виду, что к это недавно был получен доступ, и страница перемещена в пределах
буферной структуры данных пула, чтобы это скоро <span><strong>не сбросилось
</strong></span> алгоритмом <span><strong>LRU</strong></span>. Этот термин
использован в некоторых <span><strong>информационных</strong></span> именах
столбцов <span><strong>схемы</strong></span> таблиц,
связанных с буферным пулом.</p>

<p>См. <a href="#glos_buffer_pool">buffer pool</a>,
<a href="#glos_flush">flush</a>,
<a href="#glos_information_schema">INFORMATION_SCHEMA</a>,
<a href="#glos_lru">LRU</a>,
<a href="#glos_page">page</a>.</p></dd></dl>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
