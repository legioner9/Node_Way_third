<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 18. Высокая доступность и масштабируемость</title>
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="ha-overview"></a>Глава 18. Высокая доступность и масштабируемость
</h1>
<p>Данные валюта сегодняшней сети, мобильной, социальной, предприятий и
облачных приложений. Обеспечение данных всегда доступными это высший
приоритет для любой организации. Минуты простоя могут привести к существенной
потере дохода и репутации.</p>

<p>Нет никакого <span>универсального</span> подхода к высокой
доступности (High Availability, HA). Уникальные признаки приложения, деловые
требования, операционные способности и инфраструктура наследства могут все
влиять на технологический выбор. И технология только один элемент в поставке
HA люди и процессы столь же критичны, как технология.</p>

<p>MySQL предлагает диапазон гарантированных и поддержанных решений,
поставляя соответствующие уровни высокой доступности и масштабируемости,
чтобы ответить требованиям уровня обслуживания. Такие решения простираются от
репликации и виртуализации до географической избыточности и решений
мультиинформационного центра, предоставляющих надежность работы на 99.999%.
</p>

<p>Выбор правильного высоконадежного решения для приложения в значительной
степени зависит от:</p>
<ul><li><p>Уровень доступности.</li>
<li>Тип развертываемого приложения.</li>
<li>Принятые методы в пределах Вашей собственной среды.</p></li></ul>

<p>Основные решения, поддержанные MySQL, включают:</p>
<ul><li><p>Репликация: <a href="replica.htm">глава 19</a>.</li>
<li>MySQL Fabric:
<a href="../../../dev.mysql.com/doc/mysql-utilities/1.5/en/fabric.html"
target="_top">MySQL Fabric</a>.</li>
<li>MySQL Cluster:
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top">MySQL Cluster NDB 7.5</a>.</li>
<li>Oracle MySQL Cloud Service:
<a href="../../../docs.oracle.com/cloud/latest/mysql-cloud/index.html"
target="_top">MySQL Cloud Service</a>.</li>
<li>Oracle Clusterware Agent for MySQL:
<a href="../../../www.oracle.com/technetwork/database/database-technologies/clusterware/overview/index.html"
target="_top">Oracle Clusterware</a>.</li>
<li>MySQL with Solaris Cluster:
<a href="../../../www.oracle.com/technetwork/server-storage/solaris-cluster/overview/index.html"
target="_top">MySQL with Solaris Cluster</a>.</p></li></ul>

<p>Дальнейшие опции доступные решения третьей стороны.</p>
<p>Каждая архитектура, используемая, чтобы достигнуть высоконадежных служб
базы данных, дифференцирована уровнями продолжительности работы, которую
она предлагает. Эта архитектура может быть сгруппирована в
три основных категории:</p>

<ul><li><p>Репликация.</li>
<li>Кластеры и виртуализация.</li>
<li>Географически копируемые кластеры.</p></li></ul>

<p>Как иллюстрировано на следующем рисунке, каждая архитектура предлагает
прогрессивно более высокие уровни продолжительности работы, которая должна
быть сбалансирована относительно потенциально больших уровней стоимости и
сложности. Просто развертывание высоконадежной архитектуры не является
гарантией фактического предоставления HA. Фактически, плохо осуществленный и
поддержанный кластер не может легко поставить более низкие уровни
доступности, чем простое решение для репликации данных.</p>

<a name="figure_ha-cost-vs-nines"></a><p><b>Рис. 18.1.
Стоимость и сложность против доступности</b></p>
<img src="ha-cost.png" width="555" height="467">

<p>Следующая таблица сравнивает HA и способности масштабируемости
различных решений MySQL:</p>
<a name="ha-availability-comparison"></a><p><b>Таблица 18.1.
Сравнение особенностей решений MySQL HA</b></p>

<table border="1">
<thead><tr><th scope="col">Требование</th><th scope="col">Репликация MySQL
</th><th scope="col">MySQL Cluster</th></tr></thead>
<tbody><tr><td scope="row"><span><strong>Доступность</strong></span></td>
<td> </td><td> </td></tr>
<tr><td scope="row">Поддержка платформ</td><td>Все поддержанные сервером MySQL
(<a href="../../../www.mysql.com/support/supportedplatforms/database.html"
target="_top">http://www.mysql.com/support/supportedplatforms/database.html
</a>)</td><td>Все поддержанные MySQL Cluster
(<a href="../../../www.mysql.com/support/supportedplatforms/cluster.html"
target="_top">http://www.mysql.com/support/supportedplatforms/cluster.html
</a>)</td></tr>
<tr><td scope="row">Автоматизированный IP Failover</td><td>Нет</td><td>
Зависит от соединителя и конфигурации</td></tr>
<tr><td scope="row">Автоматизированный Failover базы данных</td><td>Нет</td>
<td>Да</td></tr>
<tr><td scope="row">Автоматическая пересинхронизация данных</td><td>Нет</td>
<td>Да</td></tr>
<tr><td scope="row">Типичное время Failover</td><td>Зависит от пользователя
или скрипта</td><td>Секунда или меньше</td></tr>
<tr><td scope="row">Синхронная репликация</td><td>Нет, асинхронная и
полусинхронная</td><td>Да</td></tr>
<tr><td scope="row">Совместно используемое хранение</td><td>Нет,
распределенное</td><td>Нет, распределенное</td></tr>
<tr><td scope="row">Географическая поддержка избыточности</td><td>Да</td>
<td>Yes, через репликацию MySQL</td></tr>
<tr><td scope="row">Схема обновления онлайн</td><td>Нет</td><td>Да</td></tr>
<tr><td scope="row"><span><strong>Масштабируемость</strong></span></td>
<td> </td><td> </td></tr>
<tr><td scope="row">Число узлов</td><td>Одно ведущее устройство, много
ведомых</td><td>255</td></tr>
<tr><td scope="row">Встроенное балансирование нагрузки</td>
<td>Чтение, через репликацию MySQL</td><td>Да, чтение и запись</td></tr>
<tr><td scope="row">Поддерживает интенсивные рабочие нагрузки чтения</td>
<td>Да</td><td>Да</td></tr>
<tr><td scope="row">Поддерживает интенсивные рабочие нагрузки</td>
<td>Да, через уровень приложения</td><td>Да, автоматически</td></tr>
<tr><td scope="row">Масштабирование онлайн (добавление узлов,
перераспределение и т. д.)</td><td>Нет</td><td>Да</td></tr></tbody></table>

<h2><a name="ha-zfs-replication"></a>18.1. Использование репликации ZFS</h2>
<p>Поддерживать высоконадежную окружающую среду, обеспечивая мгновенную копию
информации в настоящее время активной машины и горячее резервное копирование
это критическая часть HA. Есть много решений этой проблемы, таких как
<a href="replica.htm"><i>репликация</i></a>.</p>

<p>Файловая система ZFS обеспечивает функциональность, чтобы создать
снимок содержания файловой системы, передать снимок другой машине и извлечь
из снимка данные, чтобы обновить файловую систему. В любое время Вы можете
создать снимок, и Вы можете создать так много снимков, как Вам нравится.
Непрерывно создавая, передавая и восстанавливая снимки, Вы можете обеспечить
синхронизацию между одной или более машинами способом, подобным DRBD.</p>

<p>Следующий пример показывает простую систему Solaris, работающую с
единственным бассейном ZFS, установленным в <code>/scratchpool</code>:
<pre>
Filesystem        size  used  avail capacity  Mounted on
/dev/dsk/c0d0s0   4.6G  3.7G   886M      82%  /
/devices            0K    0K     0K       0%  /devices
ctfs                0K    0K     0K       0%  /system/contract
proc                0K    0K     0K       0%  /proc
mnttab              0K    0K     0K       0%  /etc/mnttab
swap              1.4G  892K   1.4G       1%  /etc/svc/volatile
objfs               0K    0K     0K       0%  /system/object
swap              1.4G   40K   1.4G       1%  /tmp
swap              1.4G   28K   1.4G       1%  /var/run
/dev/dsk/c0d0s7    26G  913M    25G       4%  /export/home
scratchpool        16G   24K    16G       1%  /scratchpool
/usr/lib/libc/libc_hwcap1.so.1
                  4.6G  3.7G   886M      82%  /lib/libc.so.1
fd                  0K    0K     0K       0%  /dev/fd
</pre>

<p>Данные MySQL хранятся в каталоге на <code>/scratchpool</code>.
Чтобы помочь продемонстрировать часть основной функциональности
репликации, есть также другие элементы,
сохраненные в <code>/scratchpool</code>, а именно:
<pre>
total 17
drwxr-xr-x  31 root bin   50 Jul 21 07:32 DTT/
drwxr-xr-x   4 root bin    5 Jul 21 07:32 SUNWmlib/
drwxr-xr-x  14 root sys   16 Nov  5 09:56 SUNWspro/
drwxrwxrwx  19 1000 1000  40 Nov  6 19:16 emacs-22.1/
</pre>

<p>Чтобы создать снимок файловой системы, Вы используете <code>zfs
snapshot</code>, определяя бассейн и имя снимка:
<pre>
root-shell&gt; zfs snapshot scratchpool@snap1
</pre>

<p>Перечислять уже взятые снимки можно так:
<pre>
root-shell&gt; zfs list -t snapshot
NAME             USED AVAIL  REFER  MOUNTPOINT
scratchpool@snap   10   -    24.5K  -
scratchpool@snap   20   -    24.5K  -
</pre>

<p>Сами снимки сохранены в пределах метаданных о файловой системе,
пространство, требуемое, чтобы сохранить их, изменяется со временем из-за
способа, которым создаются снимки. Начальное создание снимка очень быстро,
потому что вместо того, чтобы делать всю копию данных и метаданных, ZFS
делает запись только момента времени и метаданных того,
когда снимок создавался.</p>

<p>Когда больше изменений оригинальной файловой системы произведено,
размер снимка растет, потому что больше пространства обязано вести учет
старых блоков. Если Вы создаете много снимков, например, по одному в день, а
затем удаляете снимки, сделанные ранее на неделе, размер более новых снимков
мог бы также увеличиться, поскольку изменения, которые составляют более новое
состояние, должны быть включены в более свежие снимки, вместо того, чтобы
быть распространенными по семи снимкам, которые составляют неделю.</p>

<p>Вы не можете непосредственно поддержать снимки, потому что они существуют
в пределах метаданных о файловой системе, а не как регулярные файлы. Чтобы
получить снимок в формат, который Вы можете скопировать в другую файловую
систему, ленту и так далее, Вы используете команду <code>zfs send</code>,
чтобы создать потоковую версию снимка.</p>

<p>Например, чтобы записать снимок в файл:
<pre>
root-shell&gt; zfs send scratchpool@snap1 &gt;/backup/scratchpool-snap1
</pre>

<p>Или на ленту:
<pre>
root-shell&gt; zfs send scratchpool@snap1 &gt;/dev/rmt/0
</pre>

<p>Вы можете также записать возрастающие изменения между двумя снимками с
помощью <code>zfs send</code>:
<pre>
root-shell&gt; zfs send scratchpool@snap1 scratchpool@snap2 &gt;/backup/scratchpool-changes
</pre>
<p>Чтобы возвратить снимок, Вы используете <code>zfs recv</code>, которая
применяет информацию о снимке к новой файловой системе или к существующей.
</p>

<h3><a name="ha-zfs-config"></a>18.1.1. Использование ZFS для
репликации файловой системы</h3>
<p>Поскольку <code>zfs send</code> и <code>zfs recv</code>
используют потоки, чтобы обменяться информациями, Вы можете использовать их,
чтобы копировать информацию с одной системы в другую, объединяя
<code>zfs send</code>, <code>ssh</code> и <code>zfs recv</code>.</p>

<p>Например, чтобы скопировать снимок файловой системы
<code>scratchpool</code> к новой файловой системе
<code>slavepool</code> на новом сервере Вы использовали бы следующую команду.
Эта последовательность комбинирует снимок <code>scratchpool</code>,
передачу к ведомой машине (используя <span><strong>ssh</strong></span> с
параметрами входа в систему) и восстановление снимка на ведомом устройстве,
используя <span><strong>zfs recv</strong></span>:
<pre>
root-shell&gt; zfs send scratchpool@snap1 |ssh <em><code>id</code></em>@<em><code>host</code></em> pfexec zfs recv -F slavepool
</pre>

<p>Первая часть трубопровода, <code>zfs send scratchpool@snap1</code>,
передает снимок потоком. Команда <code>ssh</code> и команда, которую это
выполняет на другом сервере, <code>pfexec zfs recv -F slavepool</code>,
получает переданные потоком данные о снимке и пишет это в slavepool.
В этом случае я определил опцию <code>-F</code>, которая вынуждает данные о
снимке быть примененными в любом случае и является поэтому разрушительной.
Это прекрасно, поскольку я создаю первую версию копируемой файловой системы.
</p>

<p>На ведомой машине копируемая файловая система содержит тот
же самый контент:
<pre>
root-shell&gt; ls -al /slavepool/
total 23
drwxr-xr-x   6 root root   7 Nov  8 09:13 ./
drwxr-xr-x  29 root root  34 Nov  9 07:06 ../
drwxr-xr-x  31 root bin   50 Jul 21 07:32 DTT/
drwxr-xr-x   4 root bin    5 Jul 21 07:32 SUNWmlib/
drwxr-xr-x  14 root sys   16 Nov  5 09:56 SUNWspro/
drwxrwxrwx  19 1000 1000  40 Nov  6 19:16 emacs-22.1/
</pre>

<p>Как только снимок был создан, чтобы синхронизировать файловую систему
снова, Вы создаете новый снимок и затем используете возрастающую функцию
снимка <code>zfs send</code>, чтобы послать изменения между этими двумя
снимками к ведомой машине снова:
<pre>
root-shell&gt; zfs send -i scratchpool@snapshot1 scratchpool@snapshot2 |ssh <em><code>id</code></em>@<em><code>host</code></em> pfexec zfs recv slavepool
</pre>

<p>Эта работа преуспевает, если файловая система на ведомой машине не была
изменена вообще. Вы не можете применить возрастающие изменения целевой
файловой системы, которая изменилась. В примере выше команда <code>ls</code>
вызвала бы проблемы, изменяя метаданные, такие как время доступа для
файлов или каталогов.</p>

<p>Чтобы предотвратить изменения на ведомой файловой системе, установите
файловую систему на ведомом устройстве только для чтения:
<pre>
root-shell&gt; zfs set readonly=on slavepool
</pre>

<p>Установка <code>readonly</code> означает, что Вы не можете изменить
файловую систему на ведомом устройстве нормальными средствами, включая
метаданные о файловой системе. Операции, которые обычно обновляли бы
метаданные (как <code>ls</code>) тихо выполнят их функцию, не пытаясь
обновить состояние файловой системы.</p>

<p>В основном, ведомая файловая система только статическая копия оригинальной
файловой системы. Однако, даже когда конфигурована только для чтения,
файловая система может принимать снимки. На установленной только для чтения
файловой системе запускаем повторно начальную копию:
<pre>
root-shell&gt; zfs send scratchpool@snap1 |ssh <em><code>id</code></em>@<em><code>host</code></em> pfexec zfs recv -F slavepool
</pre>
<p>Теперь Вы можете произвести изменения в оригинальной файловой системе
и скопировать их к ведомому устройству.</p>

<h3><a name="ha-zfs-mysql"></a>18.1.2.
Конфигурирование MySQL для репликации ZFS</h3>
<p>Конфигурирование MySQL является созданием данных по файловой системе,
которую Вы намереваетесь копировать. Конфигурационный файл в примере ниже был
обновлен, чтобы использовать <code>/scratchpool/mysql-data</code> как каталог
данных, и теперь Вы можете инициализировать таблицы:
<pre>
root-shell&gt; mysql_install_db --defaults-file=/etc/mysql/5.5/my.cnf --user=mysql
</pre>

<p>Чтобы синхронизировать начальную информацию, выполните новый снимок и
затем посылайте новые снимки на ведомое устройство с использованием
команды <code>zfs send</code>:
<pre>
root-shell&gt; zfs snapshot scratchpool@snap2
root-shell&gt; zfs send -i scratchpool@snap1 scratchpool@snap2|ssh <em><code>id</code></em>@<em><code>host</code></em> pfexec zfs recv slavepool
</pre>

<p>Перепроверьте, что у ведомого устройства есть данные, просмотрев каталог
данных MySQL на <code>slavepool</code>:
<pre>
root-shell&gt; ls -al /slavepool/mysql-data/
</pre>

<p>Теперь Вы можете запустить MySQL, создать некоторые данные, а затем
копировать изменения с использованием <code>zfs send</code>/<code>zfs
recv</code> на ведомое устройство, чтобы синхронизировать изменения.</p>

<p>Уровень, на котором Вы выполняете синхронизацию, зависит от Вашего
приложения и окружающей среды. Ограничением будет скорость, требуемая,
чтобы выполнить снимок и затем послать изменения по сети.</p>

<p>Чтобы автоматизировать процесс, создайте скрипт, который выполняет снимок,
посылает и принимает его. Используйте <code>cron</code>, чтобы
синхронизировать изменения во времени.</p>

<h3><a name="ha-zfs-mysql-recovery"></a>18.1.3.
Обработка восстановления MySQL с ZFS</h3>
<p>Используя репликацию ZFS, чтобы обеспечить постоянную копию Ваших данных,
гарантируйте, что Вы можете восстановить свои таблицы вручную или
автоматически в случае отказа оригинальной системы.</p>

<p>В случае отказа следуйте этой последовательности:</p>
<ol type="1"><li><p>Остановите скрипт на ведущем устройстве, если он
все еще в порядке.</li>

<li>Установите ведомую файловую систему на чтение и запись:
<pre>
root-shell&gt; zfs set readonly=off slavepool
</pre></li>

<li>Запустите <a href="programs.htm#mysqld">
<span><strong>mysqld</strong></span></a> на ведомом устройстве. Если Вы
используете <code>InnoDB</code>, Вы получаете автовосстановление, если оно
необходимо, чтобы удостовериться, что табличные данные правильны,
как показано здесь:
<pre>
InnoDB: The log sequence number in ibdata files does not match
InnoDB: the log sequence number in the ib_logfiles!
081109 15:59:59  InnoDB: Database was not shut down normally!
InnoDB: Starting crash recovery.
InnoDB: Reading tablespace information from the .ibd files...
InnoDB: Restoring possible half-written data pages from the doublewrite
InnoDB: buffer...
081109 16:00:03  InnoDB: Started; log sequence number 0 1142807951
081109 16:00:03 [Note] /slavepool/mysql-5.0.67-solaris10-i386/bin/mysqld: ready for connections.
Version: '5.0.67'  socket: '/tmp/mysql.sock'  port: 3306  MySQL Community Server (GPL)
</pre></li></ol>

<p>Используйте таблицы <a href="innodb.htm"><code>InnoDB</code></a>
и регулярную синхронизацию, чтобы уменьшить риск существенной потери данных.
На таблицах MyISAM Вы, возможно, должны были бы выполнить
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>.</p>

<h2><a name="ha-memcached"></a>18.2.
Использование MySQL с <span><strong>memcached</strong></span></h2>
<p><span><strong>memcached</strong></span>
простой, хорошо масштабируемый основанный на ключе кэш, который хранит данные
и объекты везде, где свободная RAM доступна для быстрого доступа приложений,
не проходя уровни дискового I/O или парсинга. Чтобы использовать, Вы
выполняете команду <span><strong>memcached</strong></span> на одном или более
хостах и затем применяете совместно используемый кэш, чтобы хранить объекты.
Для большего количества инструкций см.
<a href="#ha-memcached-using">раздел 18.2.2</a>.</p>

<p>Выгода от использования <span><strong>memcached</strong></span> включает:
</p>
<ul><li><p>Поскольку вся информация хранится в RAM, скорость доступа быстрее,
чем загрузка информации каждый раз с диска.</li>
<li>Поскольку у части <span>значения</span> пары
"ключ-значение" нет никаких ограничений типа данных, Вы можете кэшировать
данные, такие как сложные структуры, документы, изображения или
смесь таких вещей.</li>

<li>Если Вы используете кэш-памяти, чтобы считать переходную информацию или
как кэш только для чтения для информации, сохраненной в базе данных, отказ
любого сервера <span><strong>memcached</strong></span> не важен. Для
постоянных данных Вы можете отступить к альтернативному методу поиска,
используя запросы базы данных, и перезагрузить данные в RAM на ином сервере.
</p></li></ul>

<p>Типичная окружающая среда использования должна изменить Ваше приложение
так, чтобы информация была считана из кэша, обеспеченного
<span><strong>memcached</strong></span>. Если информация не находится в
<span><strong>memcached</strong></span>, то данные загружены из базы данных
MySQL и записаны в кэш так, чтобы будущие запросы для того же самого объекта
обращались к кэшируемым данным.</p>

<a name="ha-memcached-fig-overview"></a><p><b>Рис. 18.2.
Обзор архитектуры <span>memcached</span></b></p>
<img src="overview.png" width="540" height="296">

<p>В структуре в качестве примера любой из клиентов может связаться с одним
из <span><strong>memcached</strong></span> серверов, чтобы просить данный
ключ. Каждый клиент сконфигурирован, чтобы говорить со всеми серверами,
показанными на иллюстрации. В пределах клиента, когда запрос сделан, чтобы
хранить информацию, ключ, используемый, чтобы сослаться на данные, хеширован,
и этот хеш тогда используется, чтобы выбрать один из серверов
<span><strong>memcached</strong></span>. Выбор сервера
<span><strong>memcached</strong></span> имеет место на клиенте прежде,
чем с сервером свяжутся.</p>

<p>Тот же самый алгоритм используется снова, когда клиент запрашивает тот же
самый ключ. Тот же самый ключ производит тот же самый хеш, и тот же самый
<span><strong>memcached</strong></span> сервер выбран как источник для
данных. Используя этот метод, кэшируемые данные распространены среди всех
серверов <span><strong>memcached</strong></span>, а кэшируемая информация
доступна с любого клиента.</p>

<p>Данные, проводимые в пределах традиционного сервера
<span><strong>memcached</strong></span> никогда не хранятся на диске (только
в RAM, что означает, что нет никакого постоянства данных),
и кэш RAM всегда заполняется из внешней памяти (базы данных MySQL). Если
сервер <span><strong>memcached</strong></span> рухнул,
данные могут всегда восстанавливаться из базы данных MySQL.</p>

<h3><a name="ha-memcached-install"></a>18.2.1. Установка
<span><strong>memcached</strong></span></h3>
<p>Вы можете создать и установить <span><strong>memcached</strong></span>
из исходного кода непосредственно, или Вы можете использовать существующий
пакет операционной системы.</p>

<p><span><strong>Установка <span><strong>memcached</strong></span> из
двочного дистрибутива</strong></span>.</p>
<p>Чтобы установить <span><strong>memcached</strong></span> на Red Hat или
Fedora, используйте <span><strong>yum</strong></span>:
<pre>
root-shell&gt; yum install memcached
</pre>
<p>На CentOS Вы можете быть в состоянии получить подходящий RPM
из другого источника, или использовать tar-архив.</p>

<p>Чтобы установить <span><strong>memcached</strong></span> на Debian или
Ubuntu, используйте <span><strong>apt-get</strong></span>:
<pre>
root-shell&gt; apt-get install memcached
</pre>

<p>Чтобы установить <span><strong>memcached</strong></span> на Gentoo,
используйте <span><strong>emerge</strong></span>:
<pre>
root-shell&gt; emerge install memcached
</pre>

<p><span><strong>Построение <span><strong>memcached</strong></span>
из исходных текстов</strong></span></p>
<p>На других основанных на Unix платформах, включая Solaris, AIX, HP-UX,
OS X и Linux Вы должны установить из пакет из исходных текстов. Для Linux
удостоверьтесь, что у Вас есть ядро на основе 2.6, которое включает
улучшенный интерфейс <code>epoll</code>. Для всех платформ гарантируйте, что
Вы имеете <code>libevent</code> 1.1 или выше. Вы можете получить
<code>libevent</code> с <a href="../../../www.monkey.org/~provos/libevent/default.htm"
target="_top"><code>libevent</code> web page</a>.</p>

<p>Вы можете получить исходные тексты для
<span><strong>memcached</strong></span> с
<a href="../../../www.danga.com/memcached" target="_top"><span><strong>
memcached</strong></span> Web site</a>.</p>

<p>Чтобы собрать <span><strong>memcached</strong></span>, надо:</p>
<ol type="1"><li><p>Извлеките исходный пакет <span><strong>memcached</strong>
</span>:
<pre>
shell&gt; gunzip -c memcached-<em><code>1.2.5</code></em>.tar.gz | tar xf -
</pre></li>

<li>Перейдите в каталог <span><strong>memcached-<em><code>1.2.5</code></em>:
</strong></span>
<pre>
shell&gt; cd memcached-<em><code>1.2.5</code></em>
</pre></li>

<li>Запустите <span><strong>configure</strong></span>:
<pre>
shell&gt; ./configure
</pre>

<p>Некоторые дополнительные опции Вы
можете определить к <span><strong>configure</strong></span>:</p>
<ul><li><p><code>--prefix</code></p>
<p>Чтобы определить иной каталог установки,
используйте опцию <code>--prefix</code>:
<pre>
shell&gt; ./configure --prefix=/opt
</pre>
<p>Значение по умолчанию должно использовать каталог <code>/usr/local</code>.
</li>

<li><code>--with-libevent</code></p>
<p>Если Вы установили <code>libevent</code> <code>libevent</code> и
<span><strong>configure</strong></span> не может найти библиотеку, надо
использовать опцию <code>--with-libevent</code>, чтобы определить
местоположение установленной библиотеки.</li>

<li><code>--enable-64bit</code></p>
<p>Чтобы создать 64-битовую версию <span><strong>memcached</strong></span>
(которая позволяет Вам использовать большой объем RAM), надо использовать
<code>--enable-64bit</code>.</li>

<li><code>--enable-threads</code></p>
<p>Чтобы включить поддержку многопоточности в
<span><strong>memcached</strong></span>, которая улучшает время отклика
относительно серверов с тяжелым контентом, используйте опцию
<code>--enable-threads</code>. У Вас должна быть поддержка потоков POSIX в
пределах Вашей операционной системы, чтобы включить поддержку потока.
Для получения дополнительной информации о поддержке поточной обработки см.
<a href="#ha-memcached-using-threads">раздел 18.2.2.8</a>.</li>

<li><code>--enable-dtrace</code></p>
<p><span><strong>memcached</strong></span>
включает диапазон потоков DTrace, которые могут использоваться, чтобы
контролировать и определять эффективность
<span><strong>memcached</strong></span>.</p></li></ul></li>

<li><p>Запустите <span><strong>make</strong></span> для построения
<span><strong>memcached</strong></span>:
<pre>
shell&gt; make
</pre></li>

<li>Запустите <span><strong>make install</strong></span> для установки
<span><strong>memcached</strong></span>:
<pre>
shell&gt; make install
</pre></li></ol>

<h3><a name="ha-memcached-using"></a>18.2.2. Применение
<span><strong>memcached</strong></span></h3>
<p>Чтобы начать использовать <span><strong>memcached</strong></span>,
запустите службу <span><strong>memcached</strong></span> на одном или более
серверов. Выполнение <span><strong>memcached</strong></span> настраивает
сервер, выделяет память и начинает слушать соединения от клиентов.</p>

<p>Вы не должны быть привилегированным пользователем (<code>root</code>),
чтобы выполнить <span><strong>memcached</strong></span>, кроме работы на
одном из привилегированных портов TCP/IP (ниже 1024). Вы должны, однако,
использовать пользователя, у которого не было ограниченного использования
пределов памяти <span><strong>setrlimit</strong></span> или подобного.</p>

<p>Чтобы запустить сервер, выполните <span><strong>memcached</strong></span>
как непривилегированный (то есть, не-<code>root</code>) пользователь:
<pre>
shell&gt; memcached
</pre>

<p>По умолчанию <span><strong>memcached</strong></span>
использует следующие настройки:</p>
<ul><li><p>Распределение памяти 64 МБ.</li>
<li>Слушать соединения на всех сетевых интерфейсах, используя порт 11211.
</li>
<li>Поддерживает максимум 1024 одновременных соединений.</p></li></ul>

<p>Как правило, Вы определили бы полную комбинацию опций, которые
Вы хотите, запуская <span><strong>memcached</strong></span>,
и обычно обеспечиваете скрипт запуска, чтобы обработать инициализацию
<span><strong>memcached</strong></span>. Например, следующая строка запускает
<span><strong>memcached</strong></span> с максимумом RAM 1024 МБ для кэша,
слушающего на порту 11211 на IP-адресе 192.168.0.110, работая
как фоновый демон:
<pre>
shell&gt; memcached -d -m 1024 -p 11211 -l 192.168.0.110
</pre>
<p>Чтобы гарантировать, что <span><strong>memcached</strong></span> запущен в
начальной загрузке, проверьте скрипт init и параметры конфигурации.</p>

<h4><a name="ha-memcached-cmdline-options"></a>18.2.2.1.
Параметры командной строки <span><strong>memcached</strong></span></h4>
<p><span><strong>memcached</strong></span> поддерживает следующие опции:</p>

<ul><li><p><code>-u user</code></p>
<p>Если Вы запускаете <span><strong>memcached</strong></span> как
<code>root</code>, используйте опцию <code>-u</code>, чтобы определить
пользователя для того, чтобы выполнить <span><strong>memcached</strong>
</span>:
<pre>
shell&gt; memcached -u memcache
</pre></li>

<li><code>-m memory</code></p>
<p>Установите объем памяти, выделенный <span><strong>memcached</strong>
</span> для хранения объекта. Значение по умолчанию составляет 64 МБ.
Чтобы увеличить объем памяти, выделенный для кэша, используйте опцию
<code>-m</code>, чтобы определить количество RAM, которая будет выделена (в
мегабайтах). Чем больше RAM, которую Вы выделяете, тем больше данных Вы
можете сохранить и поэтому более эффективен Ваш кэш.</p>

<p>Не определяйте памяти, больше чем Ваша доступная RAM. Если Вы определяете
слишком большое значение, то некоторая RAM, выделенная для <span><strong>
memcached</strong></span>, использует область подкачки, а не физическую RAM.
Это может привести к задержкам, потому что данные сохранены на диск, вместо
того, чтобы хранить данные непосредственно в RAM.</p>

<p>Вы можете использовать вывод команды <span><strong>vmstat</strong></span>,
чтобы получить свободную память, как показано в столбце <code>free</code>:
<pre>
shell&gt; vmstat
k thr memory  page   disk faults                                             cpu
r b w   swap  free    re  mf pi po fr de sr s1 s2 -- --   in   sy   cs us sy id
0 0 0 5170504 3450392 2    7  2  0  0  0  4  0  0  0  0  296   54  199  0  0 100
</pre>

<p>Например, чтобы выделить 3GB RAM:
<pre>
shell&gt; memcached -m 3072
</pre>

<p>На 32-битовых x86 системах, где Вы используете PAE, чтобы получить доступ
к памяти выше 4GB, Вы не можете выделить RAM вне максимального размера
процесса. Вы можете обойти это, выполняя много копий
<span><strong>memcached</strong></span>, каждая на своем порте:
<pre>
shell&gt; memcached -m 1024 -p11211
shell&gt; memcached -m 1024 -p11212
shell&gt; memcached -m 1024 -p11213
</pre>

<p>На всех системах, особенно 32-битовых, гарантируйте, что Вы оставляете
достаточно места для <span><strong>memcached</strong></span> в дополнение к
буферу памяти. Например, если у Вас есть специализированный хост
<span><strong>memcached</strong></span> с 4GB RAM, не устанавливайте размер
памяти выше 3500 МБ. Отказ сделать это может вызвать или катастрофический
отказ или серьезные исполнительные проблемы.</p>

</li><li><p><code>-l interface</code></p>
<p>Определите сетевой интерфейс/адрес, чтобы слушать соединения.
Значение по умолчанию: на всех доступных адресах (<code>INADDR_ANY</code>).
<pre>
shell&gt; memcached -l 192.168.0.110
</pre>
<p>Поддержка IPv6 была добавлена в
<span><strong>memcached</strong></span> 1.2.5.</li>

<li><code>-p port</code></p>
<p>Определите порт TCP, чтобы использовать для соединений.
Значение по умолчанию 18080.
<pre>
shell&gt; memcached -p 18080
</pre></li>

<li><code>-U port</code></p>
<p>Определите порт UDP, чтобы использовать для соединений.
Значение по умолчанию 11211, 0 выключает UDP.
<pre>
shell&gt; memcached -U 18080
</pre></li>

<li><code>-s socket</code></p>
<p>Определите сокет Unix.</p>
<p>Если Вы выполняете <span><strong>memcached</strong></span> на том же самом
сервере, где работает клиент, Вы можете отключить сетевой интерфейс и
использовать сокет Unix через опцию <code>-s</code>:
<pre>
shell&gt; memcached -s /tmp/memcached
</pre>

<p>Использование сокета Unix автоматически отключает сетевую поддержку и
сохраняет сетевые порты (позволяя использовать больше портов
Вашим веб-сервером или другим процессом).</li>

<li><code>-a mask</code></p>
<p>Определите маску доступа, которая будет использоваться для сокета Unix
в октальном формате. Значение по умолчанию 0700.</li>

<li><code>-c connections</code></p>
<p>Определите максимальное количество одновременных соединений с сервисом
<span><strong>memcached</strong></span>. Значение по умолчанию 1024.
<pre>
shell&gt; memcached -c 2048
</pre>

<p>Используйте эту опцию, чтобы сократить количество соединений (чтобы
предотвратить перегрузку сервиса <span><strong>memcached</strong></span>)
или увеличьте число, чтобы сделать более эффективным использование сервера,
работающего с сервисом <span><strong>memcached</strong></span>.</li>

<li><code>-t threads</code></p>
<p>Определите число потоков, чтобы использовать,
обрабатывая входящие запросы.</p>

<p>По умолчанию <span><strong>memcached</strong></span> сконфигурирован,
чтобы использовать 4 параллельных потока. Поточная обработка улучшает
исполнение хранения и получения данных в кэше, использование блокировок,
чтобы предотвратить перезапись потоков или обновление тех же самых значений.
Чтобы увеличить или сократить число потоков, используйте опцию
<code>-t</code> option:
<pre>
shell&gt; memcached -t 8
</pre></li>

<li><code>-d</code></p>
<p>Запустить <span><strong>memcached</strong></span> как
демон (фоновый) процесс:
<pre>
shell&gt; memcached -d
</pre></li>

<li>
<code>-r</code>
</p>

<p>Максимум размер файла ядра. В случае отказа сервер пытается сбросить все
из памяти на диск как файл ядра до любых пределов, наложенных
<span><strong>setrlimit</strong></span>.</li>

<li><code>-M</code></p>
<p>Возвратить ошибку клиенту, когда память была исчерпана.
Это заменяет нормальное поведение удаления более старых элементов из кэша,
чтобы освободить место для новых элементов.</li>

<li><code>-k</code></p>
<p>Заблокировать все страницы памяты. Это резервирует память перед
использованием, вместо того, чтобы выделить новые блоки, когда
новые элементы сохранены в кэше.</p>

<p>Есть предел на уровне пользователя, сколько памяти Вы можете
заблокировать. Попытка выделить больше, чем доступная память терпит неудачу.
Вы можете установить предел для пользователя, с которого Вы запустили демона
(не для пользователя <code>-u user</code>) в пределах оболочки при
использовании <span><strong>ulimit -S -l NUM_KB</strong></span>.</p></li>

<li><p><code>-v</code></p>
<p>Многословный режим. Ошибки и предупреждения выводятся.</li>
<li><code>-vv</code></p>
<p>Очень многословный режим. В дополнение к информации, напечатанной
<code>-v</code>, также печатает каждую команду клиента и ответ.</li>

<li><code>-vvv</code></p>
<p>Чрезвычайно многословный режим. В дополнение к информации, напечатанной
<code>-vv</code>, также покажет переходы внутреннего состояния.</li>

<li><code>-h</code></p>
<p>Напечатает сообщение справки.</li>
<li><code>-i</code></p>
<p>Напечатает лицензии <span><strong>memcached</strong></span> и
<code>libevent</code>.</li>

<li><code>-I mem</code></p>
<p>Определить максимальный размер, разрешенный для того, чтобы хранить объект
в пределах <span><strong>memcached</strong></span>.
Размер поддерживает единицы postfix (<code>k</code> для килобайт,
<code>m</code> для мегабайт). Например, чтобы увеличить максимальный
поддержанный размер объекта до 32 МБ:
<pre>
shell&gt; memcached -I 32m
</pre>
<p>Максимальный размер объекта, который Вы можете определить, составляет
128 MB, значение по умолчанию 1MB. Эта опция была добавлена в 1.4.2.</li>

<li><code>-b</code></p>
<p>Установите неудовлетворенный предел очереди. Неудовлетворенная очередь
конфигурирует, сколько сетевых соединений может ждать обработки
<span><strong>memcached</strong></span>. Увеличение этого предела может
уменьшить ошибки, полученные клиентом, которого это не в состоянии соединить
с <span><strong>memcached</strong></span>, но не улучшает исполнение сервера.
Значение по умолчанию 1024.</li>

<li><code>-P pidfile</code></p>
<p>Сохранить ID <span><strong>memcached</strong></span> в <code>file</code>.
</li>

<li><code>-f</code></p>
<p>Установите фактор роста размера блока. Когда выделяются новые блоки
памяти, выделенный размер новых блоков определен, умножая размер блока
памяти по умолчанию на этот параметр.</p>

<p>Чтобы видеть эффекты этой опции без обширного тестирования, используйте
параметр командной строки <code>-vv</code>, чтобы показать расчетные размеры
блоков. Для получения дополнительной информации см.
<a href="#ha-memcached-using-logs">раздел 18.2.2.9</a>.</li>

<li><code>-n bytes</code></p>
<p>Минимальное пространство, выделенное для информации key+value+flags.
Значение по умолчанию составляет 48 байтов.</li>

<li><code>-L</code></p>
<p>На системах, которые поддерживают большие страницы памяти, их применять.
Использование больших страниц памяти позволяет
<span><strong>memcached</strong></span> выделить кэш элемента в одном большом
куске, который может улучшить работу, уменьшая число промахов,
получая доступ к памяти.</li>

<li><code>-C</code></p>
<p>Отключить использование операций сравнения и свопа (CAS). Эта опция была
добавлена в <span><strong>memcached</strong></span> 1.3.x.</li>

<li><code>-D char</code></p>
<p>Установить символ значения по умолчанию, который будет использоваться в
качестве разделителя между префиксами ключа и ID. Это используется для
сообщения статистики по префиксам (см. <a href="#ha-memcached-stats">
раздел 18.2.4</a>). Значение по умолчанию двоеточие (<code>:</code>). Если
эта опция используется, набор статистики включен автоматически. Если не
используется, Вы можете включить статистику, посылая серверу команду
<code>stats detail on</code>. Эта опция была добавлена в
<span><strong>memcached</strong></span> 1.3.x.</li>

<li><code>-R num</code></p>
<p>Устанавливает максимальное количество запросов на процесс событий.
Значение по умолчанию 20.</li>

<li><code>-B protocol</code></p>
<p>Установить обязательный протокол, то есть значение по умолчанию
протокола <span><strong>memcached</strong></span> соединений клиента. Опции:
<code>ascii</code>, <code>binary</code> или <code>auto</code>. Автоматический
(<code>auto</code>) по умолчанию. Эта опция была добавлена в
<span><strong>memcached</strong></span> 1.4.0.</p></li></ul>

<h4><a name="ha-memcached-using-deployment"></a>18.2.2.2.
Развертывание <span><strong>memcached</strong></span></h4>
<p>Вы можете использовать много различных потенциальных стратегий
развертывания и топологии <span><strong>memcached</strong></span>. Точная
стратегия использовать зависит от Вашего приложения и окружающей среды.
Развивая систему для того, чтобы развернуть <span><strong>memcached</strong>
</span> в пределах Вашей системы, имейте в виду следующие моменты:</p>

<ul><li><p><span><strong>memcached</strong></span> только кэширующий
механизм. Это не должно использоваться, чтобы хранить информацию, которую Вы
не можете позволить себе потерять и затем загрузить из иного места.</li>

<li>Нет никакой безопасности, встроенной в протокол
<span><strong>memcached</strong></span>. Как минимум, удостоверьтесь, что
серверы, работающие с <span><strong>memcached</strong></span>, доступны
только изнутри Вашей сети, и что используемые сетевые порты заблокированы
(используя брандмауэр, например). Если информация, которая хранится
на серверах <span><strong>memcached</strong></span>, является чувствительной,
то зашифруйте информацию прежде, чем сохранить ее в
<span><strong>memcached</strong></span>.</li>

<li><span><strong>memcached</strong></span> не обеспечивает никакого
аварийного переключения. Поскольку нет никакой связи между различными копиями
<span><strong>memcached</strong></span>, то когда сервер терпит неудачу, Ваше
приложение должно быть способно удалить его из списка, обеспечить
перезагрузку данных и затем начать запись данных в другой экземпляр
<span><strong>memcached</strong></span>.</li>

<li>Время ожидания между клиентами и <span><strong>memcached</strong></span>
может быть проблемой, если Вы используете различные физические машины для
этих задач. Если Вы находите, что время ожидания проблема, переместите
<span><strong>memcached</strong></span> на клиента.</li>

<li>Длина ключа определена сервером <span><strong>memcached</strong></span>.
Максимум размера ключа по умолчанию составляет 250 байт.</li>
<li>Попытайтесь использовать по крайней мере два сервера
<span><strong>memcached</strong></span>, специально для многих клиентов,
чтобы избежать получить единственный пункт отказа. Идеально, создайте так
много хостов <span><strong>memcached</strong></span>, насколько возможно.
При добавлении и удалении <span><strong>memcached</strong></span> из
бассейна, хеширование и распределение пар "ключ/значение" могут быть
затронуты. Для информации о том, как избежать проблем см.
<a href="#ha-memcached-using-hashtypes">раздел 18.2.2.5</a>.
</p></li></ul>

<h4><a name="ha-memcached-using-namespaces"></a>18.2.2.3.
Использование пространства имен</h4>
<p><span><strong>memcached</strong></span>
очень простая массивная система хранения ключа/значения, и
нет никакого способа разделить данные автоматически в различные разделы.
Например, если Вы сохраните информацию об уникальных ID, возвращенных
из базы данных MySQL, а затем данные от двух различных таблиц, можете
столкнуться с проблемами, потому что те же самые ID могут
быть допустимы в обеих таблицах.</p>

<p>Некоторые интерфейсы обеспечивают автоматизированный механизм для того,
чтобы создать <span><em>пространства имен</em></span>, храня информацию в
кэше. Практически, эти пространства имен просто приставка перед данным ID,
которая применена каждый раз, когда значение сохранено или получено из кэша.
</p>

<p>Вы можете осуществить тот же самый основной принцип при использовании
ключей, которые описывают объект и уникальный идентификатор в пределах ключа,
который Вы поставляете, когда объект сохраняется. Например, храня
пользовательские данные, добавьте ID пользователя с
<code>user:</code> или <code>user-</code>.</p>

<p>Использование пространства имен или префиксов только управляет ключами.
Нет никакой безопасности в пределах <span><strong>memcached</strong></span>,
и поэтому никакого способа провести в жизнь, что особый клиент имеет доступ к
особому пространству имен. Пространства имен полезны только как метод
идентификации данных и предотвращения повреждения пар "ключ/значение".</p>

<h4><a name="ha-memcached-using-expiry"></a>18.2.2.4. Истечение данных</h4>
<p>Есть два типа истечения данных в <span><strong>memcached</strong></span>.
Первый тип применен, когда Вы сохраняете новую пару ключ/значения в
<span><strong>memcached</strong></span>. Если недостаточно места в пределах
подходящего блока, чтобы сохранить значение, то существующий объект,
использованный последним (LRU) удален из кэша, чтобы создать место
для нового элемента.</p>

<p>Алгоритм LRU гарантирует, что объект, который удален, больше не
используется или это использовалось так давно, что его данные потенциально
устаревшие. Однако, в системе, где память, выделенная
<span><strong>memcached</strong></span> меньше числа регулярно используемых
объектов в кэше, много элементов с истекшим сроком может быть удалено из кэша
даже при том, что они еще в активном употреблении. Вы используете механизм
статистики, чтобы получить лучшее представление об уровне удалений. Для
получения дополнительной информации см.
<a href="#ha-memcached-stats">раздел 18.2.4</a>.</p>

<p>Вы можете изменить это поведение, устанавливая параметр командной строки
<code>-M</code>, запуская <span><strong>memcached</strong></span>. Эта опция
вынуждает вернуть ошибку, когда память была исчерпана, вместо того, чтобы
автоматически удалить наиболее старые данные.</p>

<p>Второй тип системы истечения: явный механизм, который Вы можете
установить, когда пара ключ/значение введена в кэш, или удаляя элемент из
кэша. Использование врмения истечения срока может быть полезным способом
гарантировать, что данные в кэше современны и пребывают в соответствии с
Вашими потребностями и требованиями приложения.</p>

<p>Типичный сценарий для того, чтобы явно установить время истечения
мог бы включать данные о сеансе кэширования для пользователя, получая доступ
к Веб-сайту. <span><strong>memcached</strong></span> использует ленивый
механизм истечения, где явное время истечения, которое было установлено,
сравнивается с текущим временем, когда объект требуют. Только объекты,
которые не истекли, возвращены.</p>

<p>Вы можете также установить время истечения, явно удаляя объект из кэша.
В этом случае время истечения действительно тайм-аут и указывает на период,
когда любые попытки установить значение для данного ключа отклонены.</p>

<h4><a name="ha-memcached-using-hashtypes"></a>18.2.2.5.
Типы хэширования и распределения в
<span><strong>memcached</strong></span></h4>
<p>Интерфейс клиента поддерживает много различных алгоритмов распределения,
которые используются в конфигурациях сервера, чтобы определить, какой хост
должен использоваться, устанавливая или получая данные от экземпляра
<span><strong>memcached</strong></span>. Когда Вы получаете или
устанавливаете значение, хеш создан из поставляемого ключа и затем
используется, чтобы выбрать узел из списка сконфигурированных серверов.
Поскольку хеширующий механизм использует поставляемый ключ в качестве
основания для хеша, тот же самый сервер выбран во время
сохранения и операции получения.</p>

<p>Вы можете думать об этом процессе следующим образом. Учитывая массив
серверов (a, b и c), клиент использует хеширующий алгоритм, который
возвращает целое число, основанное на ключе, сохраненном или полученном.
Получающееся значение используется, чтобы выбрать сервер из списка серверов,
сконфигурированных в клиенте. Самый стандартный клиент,
хеширующий в <span><strong>memcache</strong></span>, использует простое
вычисление модуля на значении числа сконфигурированных
<span><strong>memcached</strong></span> серверов. Вы можете суммировать
процесс в псевдокоде как:
<pre>
@memcservers = ['a.memc','b.memc','c.memc'];
$value = hash($key);
$chosen = $value % length(@memcservers);
</pre>

<p>Замените вышеупомянутое со значениями:
Replacing the above with values:
<pre>
@memcservers = ['a.memc','b.memc','c.memc'];
$value = hash('myid');
$chosen = 7009 % 3;
</pre>

<p>В вышеупомянутом примере клиентский хеширующий алгоритм выбирает сервер
с индексом (<code>7009 % 3 = 1</code>), сохраняет или получаете ключ и
значение с его помощью.</p>

<p>Этот выбор и хеширующий процесс обработан автоматически клиентом
<span><strong>memcached</strong></span>, которого Вы используете: Вы должны
только обеспечить список серверов <span><strong>memcached</strong></span>.
</p>

<p><a name="ha-memcached-using-hashtypes-fig-selection"></a><p><b>Рис. 18.3.
Выбор хеша <span>memcached</span></b>.</p>
<img src="select.png" width="513" height="228">

<p>То же самое хеширование и процесс выбора имеет место во время любой работы
на указанном ключе в пределах клиента <span><strong>memcached</strong>
</span>.</p>

<p>Использование этого метода обеспечивает много преимуществ:</p>
<ul><li><p>Хеширование и выбор сервера обработаны полностью в пределах
клиента. Это избавляет от необходимости выполнять сетевые коммуникации, чтобы
определить правильную машину.</li>

<li>Поскольку определение сервера <span><strong>memcached</strong></span>
происходит полностью в пределах клиента, сервер может быть выбран
автоматически, независимо от выполняемой работы.</li>

<li>Поскольку определение обработано в пределах клиента, хеширующий алгоритм
возвращает то же самое значение для данного ключа, значения не затронуты или
сброшены различиями в окружающей среде сервера.</li>

<li>Выбор очень быстр. Хеширующий алгоритм на значении ключа быстр, как
и получающийся выбор сервера из простого массива доступных машин.</li>
<li>Использование хеширование на стороне клиента упрощает распределение
данных по каждому серверу <span><strong>memcached</strong></span>.
Естественное распределение значений, возвращенных хеширующим алгоритмом,
означает, что ключи автоматически распространены по доступным серверам.
</p></li></ul>

<p>Список серверов, сконфигурированных в пределах клиента, остается тем же
самым, тот же самый сохраненный ключ возвращает то же самое значение, поэтому
выбирается тот же самый сервер.</p>

<p>Однако, если Вы не используете тот же самый хеширующий механизм,
те же самые данные могут быть зарегистрированы на различных серверах
различными интерфейсами, тратящими впустую пространство на Вашем
<span><strong>memcached</strong></span> и приводящими к разнобою.</p>

<p>Один способ использовать многоинтерфейсный совместимый хеширующий механизм
состоит в том, чтобы использовать библиотеку <code>libmemcached</code> и
и связанные интерфейсы. Поскольку интерфейсы для различных языков (включая
C, Ruby, Perl и Python) используют тот же самый интерфейс библиотеки клиента,
они всегда производят тот же самый код хеша из ID.</p>

<p>Проблема с клиентским выбором сервера состоит в том, что список серверов
(включая их последовательный порядок) <span><em>должен</em></span>
остаться последовательным на каждом клиенте, использующем и серверы должны
быть доступными. Если Вы пытаетесь выполнить работу на ключе, когда:</p>

<ul><li><p>Новый сервер <span><strong>memcached</strong></span>
был добавлен к списку доступных хостов.</li>
<li>Сервер <span><strong>memcached</strong></span> был удален из
списка доступных машин.</li>
<li>Порядок серверов поменялся.</p></li></ul>

<p>Когда хеширующий алгоритм используется на данном ключе, но с различным
списком серверов, вычисление хеша может выбрать иной сервер из списка.</p>
<p>Если новый сервер добавлен в список серверов, как <code>new.memc</code>
как в примере ниже, то операция GET используя тот же самый ключ
<code>myid</code>, может привести к сбою кэша. Это потому, что то же самое
значение вычислено от ключа, который выбирает тот же самый индекс в массиве
серверов, но индекс теперь указывает на другую машину, а не на
<code>c.memc</code>, где данные первоначально хранились. Это привело бы к
сбою даже при том, что ключ существует в пределах кэша на другом сервере.</p>

<a name="ha-memcached-using-hashtypes-fig-addselect"></a><p><b>Рис. 18.4.
Выбор хеша с новым сервером <span>memcached</span></b></p>
<img src="addsel.png" width="626" height="228">

<p>Это означает, что серверы <code>c.memc</code> и <code>new.memc </code>
содержат информацию для ключа <code>myid</code>, но информация на каждой
машине может отличаться в каждом случае. Более существенная проблема: намного
более высокое число промахов кэша, получая данные, поскольку добавление
нового сервера изменяет распределение ключей, а это в свою очередь требует
восстановления кэшируемых данных, вызывая увеличение чтений базы данных.</p>

<p>Тот же самый эффект может произойти, если Вы активно управляете
списком серверов, сконфигурированных в Ваших клиентах, добавляя и удаляя
сконфигурированные <span><strong>memcached</strong></span> машины, поскольку
каждый сервер идентифицирован как доступный. Например, удаление хоста,
когда клиент замечает, что с ним больше нельзя связаться, может заставить
выбор сервера потерпеть неудачу как описано здесь.</p>

<p>Чтобы предотвратить эти существенные проблемы и лишение законной силы
Вашего кэша, Вы можете выбрать хеширующий алгоритм, используемый, чтобы
выбрать сервер. Есть два общих типа алгоритма хеширования,
<span><em>последовательный</em></span> и <span><em>modula</em></span>.</p>

<p>С <span class="emphasis"><em>последовательными</em></span> хеширующими
алгоритмами тот же самый ключ, когда применяется к списку серверов всегда
использует тот же самый сервер, чтобы сохранить или получить ключи, даже если
список сконфигурированных серверов изменяется. Это означает, что Вы можете
добавить и удалить серверы из списка и всегда использовать тот же самый
сервер для данного ключа. Есть два типа последовательных хеширующих доступных
алгоритмов Ketama и Wheel. Оба типа поддержаны
<code>libmemcached</code> и выполнение доступно для PHP и Java.</p>

<p>У любого последовательного хеширующего алгоритма есть некоторые
ограничения. Когда Вы добавляете серверы к существующему списку
сконфигурированных серверов, ключи распределены новым серверам как часть
нормального распределения. Когда Вы удаляете серверы из списка, ключи
перераспределены к другому серверу в пределах списка, означая, что кэш
должен быть повторно заполнен информацией. Кроме того, последовательный
хеширующий алгоритм не решает вопрос, когда Вы хотите последовательный
выбор сервера для многих клиентов, но каждый клиент содержит различный список
серверов. Последовательность проведена в жизнь только в
пределах единственного клиента.</p>

<p>С хеширующим алгоритмом <span><em>modula</em></span> клиент выбирает
сервер первыми вычислениями хеша, а затем выбором сервера из списка
сконфигурированных серверов. Если список серверов изменен, выбранный сервер,
используя хеширующий алгоритм modula, также изменяется. Результат: поведение,
описанное выше. Изменения списка серверов означают, что различные серверы
выбраны при получении данных, приводя к промахам кэша и увеличению нагрузки
базы данных, поскольку кэш повторно наполняется информацией.</p>

<p>Если Вы используете только единственный сервер <span><strong>memcached
</strong></span> для каждого клиента, или Ваш список серверов,
сконфигурированных для клиента, никогда не изменяется, то выбор хеширующего
алгоритма не важен, поскольку это не имеет никакого значимого эффекта.</p>

<p>Если Вы регулярно изменяете свои серверы или используете единый набор
серверов, которые совместно использованы среди большого количества клиентов,
то использование последовательного хеширующего алгоритма должно помочь
гарантировать, что Ваши данные в кэше не
дублированы и равномерно распределены.</p>

<h4><a name="ha-memcached-using-dtrace"></a>18.2.2.6.
Применение <span><strong>memcached</strong></span> и DTrace</h4>
<p><span><strong>memcached</strong></span> включает много различных
исследований DTrace, которые могут использоваться, чтобы контролировать
работу сервера. Включенные исследования могут контролировать отдельные
соединения, распределения памяти и модификации хэш-таблицы, когда пара
ключа/значения добавлена, обновлена или удалена.</p>

<p>Для получения дополнительной информации о DTrace и написании скриптов
DTrace читайте <a href="../../../docs.oracle.com/cd/E19253-01/819-5488/default.htm"
target="_top">DTrace User Guide</a>.</p>

<p>Поддержка исследований DTrace была добавлена к
<span><strong>memcached</strong></span> 1.2.6, включая много исследований
DTrace, которые могут использоваться, чтобы помочь контролировать Ваше
приложение. DTrace поддержан на Solaris 10, OpenSolaris, OS X 10.5 и FreeBSD.
Чтобы включить исследования DTrace в <span><strong>memcached</strong></span>,
создайте из пакет из исходных текстов и используйте
опцию <code>--enable-dtrace</code>.</p>

<p>Исследования, поддержанные <span><strong>memcached</strong></span>:</p>
<ul><li><p><code>conn-allocate(connid)</code></p>
<p>Запущено, когда объект соединения выделен из бассейна соединения.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</p></li></ul></li>

<li><p><code>conn-release(connid)</code></p>
<p>Запущен, когда объект соединения выпущен назад в бассейн соединения.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</p></li></ul></li>

<li><p><code>conn-create(ptr)</code></p>
<p>Запущен, когда новый объект соединения создается (то есть, нет никаких
свободных объектов подключения в бассейне соединения).</p>

<p>Параметры:</p>
<ul><li><p><code>ptr</code>: Указатель на объект соединения.
</p></li></ul></li>

<li><p><code>conn-destroy(ptr)</code></p>
<p>Запущен, когда объект соединения разрушается.</p>
<p>Параметры:</p>
<ul><li><p><code>ptr</code>: Указатель на объект соединения.
</p></li></ul></li>

<li><p><code>conn-dispatch(connid, threadid)</code></p>
<p>Запущен, когда соединение послано от основного потока или потока
управления соединения рабочему потоку.</p>

<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>threadid</code>: ID потока.</p></li></ul></li>

<li><p><code>slabs-allocate(size, slabclass, slabsize, ptr)</code></p>
<p>Выделить память от имени распределителя памяти.</p>
<p>Параметры:</p>
<ul><li><p><code>size</code>: Требуемый размер.</li>
<li><code>slabclass</code>: Распределение выполнено в этом классе.</li>
<li><code>slabsize</code>: Размер каждого элемента в этом классе.</li>
<li><code>ptr</code>: Указатель на выделенную память.</p></li></ul></li>

<li><p><code>slabs-allocate-failed(size, slabclass)</code></p>
<p>Сбой выделения памяти (мало памяти).</p>
<p>Параметры:</p>
<ul><li><p><code>size</code>: Требуемый размер.</li>
<li><code>slabclass</code>: Класс, который был не в
состоянии выполнить запрос.</p></li></ul></li>

<li><p><code>slabs-slabclass-allocate(slabclass)</code></p>
<p>Запущен, когда класс памяти нуждается в большем количестве места.</p>
<p>Параметры:</p>
<ul><li><p><code>slabclass</code>: Класс, который нуждается в большей памяти.
</p></li></ul></li>

<li><p><code>slabs-slabclass-allocate-failed(slabclass)</code></p>
<p>Ошибка выделения памяти (out of memory).</p>
<p>Параметры:</p>
<ul><li><p><code>slabclass</code>: Класс, который был не в состоянии
получить больше памяти.</p></li></ul></li>

<li><p><code>slabs-free(size, slabclass, ptr)</code></p>
<p>Память освобождена.</p>
<p>Параметры:</p>

<ul><li><p><code>size</code>: Объем памяти в байтах.</li>
<li><code>slabclass</code>: Класс, которому память принадлежит.</li>
<li><code>ptr</code>: Указатель на память.</p></li></ul></li>

<li><p><code>assoc-find(key, depth)</code></p>
<p>Запущен при поиске в хэш-таблице ключа. Эти два элемента обеспечивают
понимание, как хорошо функция хеша работает. Пересечения знак менее
оптимальной функции, тратящей впустую способность центрального процессора.
</p>
<p>Параметры:</p>
<ul><li><p><code>key</code>: Искомый ключ.</li>
<li><code>depth</code>: Глубина в списке хэш-таблицы.</p></li></ul></li>

<li><p><code>assoc-insert(key, nokeys)</code></p>
<p>Запущен, когда новый элемент был вставлен.</p>
<p>Параметры:</p>
<ul><li><p><code>key</code>: Ключ, который вставили.</li>
<li><code>nokeys</code>: Общее количество ключей, в настоящее время
сохраненных, включая ключ, для которого вызвали вставку.</p></li></ul></li>

<li><p><code>assoc-delete(key, nokeys)</code></p>
<p>Запущен, когда новый элемент был удален.</p>
<p>Параметры:</p>
<ul><li><p><code>key</code>: Ключ, который удален.</li>
<li><code>nokeys</code>: Общее количество ключей, в настоящее время
сохраненных, исключая ключ, для которого удаление вызвано.</p></li></ul></li>

<li><p><code>item-link(key, size)</code></p>
<p>Запущен, когда элемент соединяется в кэше.</p>
<p>Параметры:</p>
<ul><li><p><code>key</code>: Ключ элемента.</li>
<li><code>size</code>: Размер данных.</p></li></ul></li>

<li><p><code>item-unlink(key, size)</code></p>
<p>Запущен, когда элемент удаляется.</p>
<p>Параметры:</p>
<ul><li><p><code>key</code>: Ключ элемента.</li>
<li><code>size</code>: Размер данных.</p></li></ul></li>

<li><p><code>item-remove(key, size)</code></p>
<p>Запущен, когда refcount для элемента уменьшен.</p>
<p>Параметры:</p>
<ul><li><p><code>key</code>: Ключ элемента.</li>
<li><code>size</code>: Размер данных.</p></li></ul></li>

<li><p><code>item-update(key, size)</code></p>
<p>Запущенный, когда время последней ссылки обновлено.</p>
<p>Параметры:</p>
<ul><li><p><code>key</code>: Ключ элемента.</li>
<li><code>size</code>: Размер данных.</p></li></ul></li>

<li><p><code>item-replace(oldkey, oldsize, newkey, newsize)</code></p>
<p>Запущен, когда элемент заменяется другим элементом.</p>
<p>Параметры:</p>
<ul><li><p><code>oldkey</code>: Ключ старого элемента.</li>
<li><code>oldsize</code>: Размер старого элемента.</li>
<li><code>newkey</code>: Ключ нового элемента.</li>
<li><code>newsize</code>: Размер нового элемента.</p></li></ul></li>

<li><p><code>process-command-start(connid, request, size)</code></p>
<p>Запущен, когда обработка команды запускается.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>request</code>: Входящий запрос.</li>
<li><code>size</code>: Размер запроса.</p></li></ul></li>

<li><p><code>process-command-end(connid, response, size)</code></p>
<p>Запущен, когда обработка команды сделана.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>response</code>: Ответ, чтобы отослать назад клиенту.</li>
<li><code>size</code>: Размер ответа.</p></li></ul></li>

<li><p><code>command-get(connid, key, size)</code></p>
<p>Запущен для команды <code>get</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Размер данных ключа (или -1, если не найден).
</p></li></ul></li>

<li><p><code>command-gets(connid, key, size, casid)</code></p>
<p>Запущен для команды <code>gets</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Размер данных ключа (или -1, если не найден).</li>
<li><code>casid</code>: casid для элемента.</p></li></ul></li>

<li><p><code>command-add(connid, key, size)</code></p>
<p>Запущен для команды <code>add</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Новый размер данных ключа (или -1, если не найден).
</p></li></ul></li>

<li><p><code>command-set(connid, key, size)</code></p>
<p>Запущен для команды <code>set</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Новый размер данных ключа (или -1, если не найден).
</p></li></ul></li>

<li><p><code>command-replace(connid, key, size)</code></p>
<p>Запущен для команды <code>replace</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Новый размер данных ключа (или -1, если не найден).
</p></li></ul></li>

<li><p><code>command-prepend(connid, key, size)</code></p>
<p>Запущен для команды <code>prepend</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Новый размер данных ключа (или -1, если не найден).
</p></li></ul></li>

<li><p><code>command-append(connid, key, size)</code></p>
<p>Запущен для команды <code>append</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Новый размер данных ключа (или -1, если не найден).
</p></li></ul></li>

<li><p><code>command-cas(connid, key, size, casid)</code></p>
<p>Запущен для команды <code>cas</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>size</code>: Новый размер данных ключа (или -1, если не найден).
</li>
<li><code>casid</code>: cas ID.</p></li></ul></li>

<li><p><code>command-incr(connid, key, val)</code></p>
<p>Запущен для команды <code>incr</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>val</code>: Новое значение.</p></li></ul>

</li><li><p><code>command-decr(connid, key, val)</code></p>
<p>Запущен для команды <code>decr</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>val</code>: Новое значение.</p></li></ul></li>

<li><p><code>command-delete(connid, key, exptime)</code></p>
<p>Запущен для команды <code>delete</code>.</p>
<p>Параметры:</p>
<ul><li><p><code>connid</code>: ID соединения.</li>
<li><code>key</code>: Требуемый ключ.</li>
<li><code>exptime</code>: Время истечения.</p></li></ul></li></ul>

<h4><a name="ha-memcached-using-memory"></a>18.2.2.7.
Распределение памяти в <span><strong>memcached</strong></span></h4>
<p>Когда Вы сначала запускаете <span><strong>memcached</strong></span>,
память, которую Вы сконфигурировали, автоматически не выделена. Вместо этого
<span><strong>memcached</strong></span> начинает выделять и резервировать
физическую память, как только Вы начинаете сохранять информацию в кэш.</p>

<p>Когда Вы начинаете хранить данные в кэше,
<span><strong>memcached</strong></span> не выделяет памяти для данных на
основе элемента. Вместо этого распределение плиты используется, чтобы
оптимизировать использование памяти и предотвратить фрагментацию памяти,
когда информация удаляется из кэша.</p>

<p>С распределением куска память сохранена в блоках по 1 МБ. Кусок
разделен на много блоков равного размера. Когда Вы пытаетесь сохранить
значение в кэш, <span><strong>memcached</strong></span> проверяет размер
значения, которое Вы добавляете к кэшу, и определяет, какой кусок
содержит распределение правильного размера для элемента. Если кусок с
размером элемента уже существует, элемент записан в блок в его пределах.</p>

<p>Если новый элемент больше чем размер каких-либо существующих блоков, то
новый кусок создается и делится на блоки подходящего размера. Если
существующий кусок с правильным размером блока уже существует, но нет никаких
свободных блоков, новый кусок создается. Если Вы обновляете существующий
элемент с данными, которые больше чем существующее распределение блока для
ключа, то ключ перераспределен в подходящий кусок памяти.</p>

<p>Например, размер значения по умолчанию для самого маленького блока
составляет 88 байтов (40 байт значение и по умолчанию 48 байт для ключа и
данных о флаге). Если размер первого элемента, который Вы храните в кэше,
составляет меньше 40 байтов, то кусок с размером блока 88 байтов
создается, и значение сохранено.</p>

<p>Если размер данных, которые Вы намереваетесь хранить, больше чем это
значение, то размер блока увеличен фактором размера куска, пока размер блока
не станет достаточно большим, чтобы содержать значение.
Размер блока всегда функция масштабного коэффициента, округленная
к размеру блока, который является точно кратным размеру куска.</p>

<a name="ha-memcached-fig-slabs"></a><p><b>Рис. 18.5.
Распределение памяти в <span>memcached</span></b></p>
<img src="memalloc.png" width="406" height="232">

<p>Результат состоит в том, что Вам выделили много страниц в пределах
диапазона памяти, выделенной <span><strong>memcached</strong></span>.
Каждая страница составляет 1 МБ (по умолчанию) и разделена на различное
число кусков, согласно размеру куска, требуемому, чтобы сохранить пары
ключа/значения. Каждому экземпляру выделили много страниц, и страница всегда
создается, когда новый элемент должен быть создан, требуя куска особого
размера. Кусок может состоять из многих страниц, и каждая страница в пределах
куска содержит равное количество блоков.</p>

<p>Размер куска определен основным размером куска, объединенным с фактором
роста размера куска. Например, если начальные куски составляют 104 байта в
размере, и фактор роста размера куска по умолчанию используется (1.25), то
следующий выделенный размер куска был бы 104*1.25 или 136 байт.</p>

<p>Выделение страниц таким образом гарантирует, что память не становится
фрагментированной. Однако, в зависимости от распределения объектов, которые
Вы храните, это может привести к неэффективному распределению
кусков, если у Вас есть существенно отличающиеся размером элементы. Например,
имея относительно небольшое количество элементов в пределах каждого размера
куска можно потратить впустую большую память только с немногими кусками в
каждой выделенной странице.</p>

<p>Вы можете настроить фактор роста, чтобы уменьшить этот эффект при
использовании параметра командной строки <code>-f</code>, который
приспосабливает фактор роста, чтобы сделать более эффективное использование
кусков. Для информации о том, как определить текущую статистику распределения
см. <a href="#ha-memcached-stats-slabs">раздел 18.2.4.2</a>.</p>

<p>Если Ваша операционная система поддерживает это, Вы можете также запустить
<span><strong>memcached</strong></span> с параметром командной строки
<code>-L</code>. Эта опция предварительно выделяет всю память во время
запуска, используя большие страницы памяти. Это может улучшить работу,
сокращая количество промахов в кэш-памяти центрального процессора.</p>

<h4><a name="ha-memcached-using-threads"></a>18.2.2.8.
Поддержка потоков в <span><strong>memcached</strong></span></h4>
<p>Если Вы включаете выполнение потока, создавая
<span><strong>memcached</strong></span> из исходных текстов,
<span><strong>memcached</strong></span>
использует многократные потоки в дополнение к системе
<code>libevent</code>, чтобы обработать запросы.</p>

<p>Когда включено, выполнение поточной обработки работает следующим образом:
</p>
<ul><li><p>Поток обработан, обертывая функции в пределах кода, чтобы
обеспечить основную защиту от обновления тех же самых глобальных структур
в то же самое время.</li>
<li>Каждый поток использует свой собственный экземпляр
<code>libevent</code>, чтобы помочь улучшить работу.</li>

<li>Соединения TCP/IP обработаны единственным потоком, слушающим на сокете
TCP/IP. Каждое соединение распределено одному из активных потоков на простой
круговой основе. Каждое соединение работает исключительно в пределах этого
потока, в то время как соединение остается открытым.</li>

<li>Для соединений UDP все потоки слушают единственный сокет UDP
для входящих запросов. Потоки, которые в настоящее время не имеют дело с
другим запросом, игнорируют поступающий пакет. Один из остающихся, незанятых,
потоков читает запрос и посылает ответ. Это выполнение может привести к
увеличенной загрузке центрального процессора, поскольку потоки просыпаются от
сна, чтобы потенциально обработать запрос.</p></li></ul>

<p>Использование потоков может увеличить нагрузку на серверах, которые имеют
много ядер центрального процессора в наличии, поскольку просьбы обновить
хэш-таблицу могут быть распространены между отдельными потоками.
Чтобы минимизировать накладные расходы от используемого механизма блокировки,
экспериментируйте с различными значениями потока, чтобы достигнуть лучшей
работы, основанной на числе и типе запросов в пределах Вашей
данной рабочей нагрузки.</p>

<h4><a name="ha-memcached-using-logs"></a>18.2.2.9.
Журналы <span><strong>memcached</strong></span></h4>
<p>Если Вы включаете многословный режим, используя опции <code>-v</code>,
<code>-vv</code> или <code>-vvv</code>, вывод информации
<span><strong>memcached</strong></span> включает детали выполняемых операций.
</p>

<p>Без многословных опций <span><strong>memcached</strong></span>
обычно не производит вывода во время нормального действия.</p>
<ul><li><p>
<span><strong>Вывод, используя <code>-v</code></strong></span>.</p>
<p>Самый низкий уровень многословия показывает Вам:</p>
<ul><li><p>Ошибки и предупреждения</li>
<li>Переходные ошибки</li>
<li>Ошибки протокола и сокета, включая истощение доступных соединений</li>
<li>Каждое зарегистрированное соединение клиента, включая дескрипторное
число сокета и используемый протокол.</p>

<p>Например:
<pre>
32: Client using the ascii protocol
33: Client using the ascii protocol
</pre>
<p>Описатель сокета допустим только в то время, как клиент остается
соединенным. Нестойкие соединения не могут быть эффективно представлены.
</p></li></ul>

<p>Примеры вывода сообщений об ошибках на этом уровне:
<pre>
&lt;%d send buffer was %d, now %d
Can't listen for events on fd %d
Can't read from libevent pipe
Catastrophic: event fd doesn't match conn fd!
Couldn't build response
Couldn't realloc input buffer
Couldn't update event
Failed to build UDP headers
Failed to read, and not due to blocking
Too many open connections
Unexpected state %d
</pre></li>

<li><span><strong>Вывод, используя <code>-vv</code></strong></span></p>
<p>Используя второй уровень многословия, Вы получаете более подробную
информацию об операциях протокола, обновленные ключи и детали.</p>

<p>Во время начального запуска <span><strong>memcached</strong></span> с этим
уровнем Вам показывают размеры отдельных классов, размеры куска и число
записей. Они не показывают распределение кусков, только куски, которые были
бы созданы, когда данные добавлены. Вам также дают информацию о сетевых
очередях. Образец вывода, произведенного для TCP/IP-системы с памятью по
умолчанию дан ниже:
<pre>
shell&gt; memcached -vv
slab class   1: chunk size 80 perslab 13107
slab class   2: chunk size104 perslab 10082
slab class   3: chunk size136 perslab  7710
slab class   4: chunk size176 perslab  5957
slab class   5: chunk size224 perslab  4681
slab class   6: chunk size280 perslab  3744
slab class   7: chunk size352 perslab  2978
slab class   8: chunk size440 perslab  2383
slab class   9: chunk size552 perslab  1899
slab class  10: chunk size696 perslab  1506
slab class  11: chunk size872 perslab  1202
slab class  12: chunk size   1096 perslab   956
slab class  13: chunk size   1376 perslab   762
slab class  14: chunk size   1720 perslab   609
slab class  15: chunk size   2152 perslab   487
slab class  16: chunk size   2696 perslab   388
slab class  17: chunk size   3376 perslab   310
slab class  18: chunk size   4224 perslab   248
slab class  19: chunk size   5280 perslab   198
slab class  20: chunk size   6600 perslab   158
slab class  21: chunk size   8256 perslab   127
slab class  22: chunk size  10320 perslab   101
slab class  23: chunk size  12904 perslab81
slab class  24: chunk size  16136 perslab64
slab class  25: chunk size  20176 perslab51
slab class  26: chunk size  25224 perslab41
slab class  27: chunk size  31536 perslab33
slab class  28: chunk size  39424 perslab26
slab class  29: chunk size  49280 perslab21
slab class  30: chunk size  61600 perslab17
slab class  31: chunk size  77000 perslab13
slab class  32: chunk size  96256 perslab10
slab class  33: chunk size 120320 perslab 8
slab class  34: chunk size 150400 perslab 6
slab class  35: chunk size 188000 perslab 5
slab class  36: chunk size 235000 perslab 4
slab class  37: chunk size 293752 perslab 3
slab class  38: chunk size 367192 perslab 2
slab class  39: chunk size 458992 perslab 2
&lt;26 server listening (auto-negotiate)
&lt;29 server listening (auto-negotiate)
&lt;30 send buffer was 57344, now 2097152
&lt;31 send buffer was 57344, now 2097152
&lt;30 server listening (udp)
&lt;30 server listening (udp)
&lt;31 server listening (udp)
&lt;30 server listening (udp)
&lt;30 server listening (udp)
&lt;31 server listening (udp)
&lt;31 server listening (udp)
&lt;31 server listening (udp)
</pre>

<p>Использование этого уровня может быть полезным способом проверить эффекты
фактора роста, используемого на кусках с различными распределениями памяти,
которые в свою очередь могут использоваться, чтобы лучше настроить фактор
роста, чтобы удовлетворить данным, которые Вы храните в кэше. Например, если
Вы устанавливаете фактор роста в 4 (увеличение вчетверо
размера каждого куска):
<pre>
shell&gt; memcached -f 4 -m 1g -vv
slab class   1: chunk size 80 perslab 13107
slab class   2: chunk size320 perslab  3276
slab class   3: chunk size   1280 perslab   819
slab class   4: chunk size   5120 perslab   204
slab class   5: chunk size  20480 perslab51
slab class   6: chunk size  81920 perslab12
slab class   7: chunk size 327680 perslab 3
...
</pre>

<p>Во время использования кэша этот уровень также распечатывает подробную
информацию о хранении и восстановлении ключей и другой информации.
Пример вывода во время типичных действий показан ниже.
<pre>
32: Client using the ascii protocol
&lt;32 set my_key 0 0 10
&gt;32 STORED
&lt;32 set object_key 1 0 36
&gt;32 STORED
&lt;32 get my_key
&gt;32 sending key my_key
&gt;32 END
&lt;32 get object_key
&gt;32 sending key object_key
&gt;32 END
&lt;32 set key 0 0 6
&gt;32 STORED
&lt;32 incr key 1
&gt;32 789544
&lt;32 decr key 1
&gt;32 789543
&lt;32 incr key 2
&gt;32 789545
&lt;32 set my_key 0 0 10
&gt;32 STORED
&lt;32 set object_key 1 0 36
&gt;32 STORED
&lt;32 get my_key
&gt;32 sending key my_key
&gt;32 END
&lt;32 get object_key
&gt;32 sending key object_key1 1 36
&gt;32 END
&lt;32 set key 0 0 6
&gt;32 STORED
&lt;32 incr key 1
&gt;32 789544
&lt;32 decr key 1
&gt;32 789543
&lt;32 incr key 2
&gt;32 789545
</pre>

<p>Во время коммуникации клиента, для каждой строки, начальный символ
показывает направление  потока информации. &lt;Для коммуникации от клиента к
<span><strong>memcached</strong></span> серверу и &gt; для коммуникации назад
клиенту. Число это числовой описатель сокета для соединения.</li>

<li><span><strong>Вывод, используя <code>-vvv</code></strong></span></p>
<p>Этот уровень многословия включает переходы соединений между различными
статусами в библиотеке событий. Это должно использоваться, чтобы
диагностировать и идентифицировать проблемы в коммуникации клиента. Например,
Вы можете использовать эту информацию, чтобы определить, занимает ли
<span><strong>memcached</strong></span> много времени, чтобы возвратить
информацию клиенту, во время чтения или прежде, чем возвратить и завершить
работу. Пример типичной последовательности для работы обеспечен ниже:
<pre>
&lt;32 new auto-negotiating client connection
32: going from conn_new_cmd to conn_waiting
32: going from conn_waiting to conn_read
32: going from conn_read to conn_parse_cmd
32: Client using the ascii protocol
&lt;32 set my_key 0 0 10
32: going from conn_parse_cmd to conn_nread
&gt; NOT FOUND my_key
&gt;32 STORED
32: going from conn_nread to conn_write
32: going from conn_write to conn_new_cmd
32: going from conn_new_cmd to conn_waiting
32: going from conn_waiting to conn_read
32: going from conn_read to conn_closing
&lt;32 connection closed.
</pre></li></ul>

<p>Все уровни в <span><strong>memcached</strong></span> разработаны, чтобы
использоваться во время отладки или экспертизы проблем. Количество
произведенной информации, особенно используя <code>-vvv</code>, является
существенным, особенно на занятом сервере. Также знайте, что запись
информации об ошибке, особенно на диск, может сильно снизить прирост
производительности, которого Вы достигаете при использовании
<span><strong>memcached</strong></span>. Поэтому, использование в рабочей
среде не рекомендуется.</p>

<h3><a name="ha-memcached-interfaces"></a>18.2.3.
Разработка приложений <span><strong>memcached</strong></span></h3>
<p>Много языковых интерфейсов позволяют приложениям хранить и получать
информацию с <span><strong>memcached</strong></span>. Вы можете написать
приложения для <span><strong>memcached</strong></span>
на популярных языках, таких как Perl, PHP, Python, Ruby, C и Java.</p>

<p>Данные, хранимые сервером <span><strong>memcached</strong></span>,
упомянуты единственной строкой (ключом) с хранением в кэше и извлечением из
кэша, используя ключ в качестве ссылки. Кэш поэтому работает как
многочисленный ассоциативный массив или хэш-таблица. Невозможно
структурировать или иначе организовать информацию, хранимую в кэше.
Чтобы подражать понятиям базы данных, таким как многие таблицы или сложные
значения ключа, Вы должны закодировать дополнительную информацию в строки,
используемые в качестве ключей. Например, чтобы сохранить или искать адрес,
соответствующий определенной широте и долготе, Вы могли бы превратить те два
числовых значения в единственную разделенную запятыми строку,
чтобы использовать в качестве ключа.</p>

<h4><a name="ha-memcached-operations"></a>18.2.3.1.
Основные действия <span><strong>memcached</strong></span></h4>
<p>Интерфейс к <span><strong>memcached</strong></span> поддерживает следующие
методы для хранения и получения информации в кэше, и они одинаковы для всех
API, хотя специфика языка отличается:</p>

<ul><li><p><code>get(<em><code>key</code></em>)</code>:
Получает информацию из кэша. Возвращает значение, связанное с ключом, если
указанный ключ существует. Возвращает
<code>NULL</code>, <code>nil</code>, <code>undefined</code> или самый близкий
эквивалент на соответствующем языке, если указанный ключ не существует.</li>

<li><code>set(<em><code>key</code></em>,
<em><code>value</code></em> [, <em><code>expiry</code></em>])</code>:
Устанавливает элемент, связанный с ключом в кэше к указанному значению.
Это обновляет существующий элемент, если ключ уже существует, или добавляет
новую пару ключа/значения, если ключ не существует. Если время истечения
определено, то элемент истекает (и будет удален), когда время истечения
достигнуто. Время определено в секундах и учтено в качестве относительного
времени, если значение составляет меньше 30 дней (30*24*60*60), или
абсолютного времени (epoch), если больше, чем это значение.</li>

<li><code>add(<em><code>key</code></em>,
<em><code>value</code></em> [, <em><code>expiry</code></em>])</code>:
Добавляет ключ и связанное значение к кэшу, если указанный
ключ не существует.</li>

<li><code>replace(<em><code>key</code></em>,
<em><code>value</code></em> [, <em><code>expiry</code></em>])</code>:
Заменяет элемент, связанный с указанным <code>key</code>, только если ключ
уже существует. Новое значение дано параметром <code>value</code>.</li>

<li><code>delete(<em><code>key</code></em> [,
<em><code>time</code></em>])</code>: Удаляет <code>key</code>
и его связанный элемент из кэша. Если Вы указали <code>time</code>,
тогда добавление другого элемента с указанным <code>key</code> заблокировано
в течение установленного периода.</li>

<li><code>incr(<em><code>key</code></em>,
<em><code>value</code></em>)</code>: Увеличивает элемент, связанный с
<code>key</code> на указанное <code>value</code>.</li>

<li><code>decr(<em><code>key</code></em>,
<em><code>value</code></em>)</code>: Уменьшает элемент, связанный с
<code>key</code> на указанное <code>value</code>.</li>

<li><code>flush_all</code>: Лишает законной силы (или истекает), все текущие
элементы в кэше. Технически они все еще существуют (они не удалены), но будут
тихо разрушены в следующий раз, когда Вы попытаетесь получить доступ к ним.
</p></li></ul>

<p>Во всех реализациях большая часть или все эти функции дублированы через
соответствующий интерфейс языка.</p>

<p>Сложные структуры данных не могут быть сохранены непосредственно.
Большинство интерфейсов преобразовывает в последовательную форму данные для
Вас, то есть, поместите их в текстовую форму, которая может восстановить
оригинальные указатели и вложение. Использование Perl <code>Storable</code>,
PHP <code>serialize</code>, Python <code>cPickle</code> (или
<code>Pickle</code>), Java <code>Serializable</code> интерфейсов
предназначено как раз для этого. В большинстве случаев используемый интерфейс
преобразования в последовательную форму настраиваем. Чтобы совместно
использовать данные, хранимые в <span><strong>memcached</strong></span>
между различными языковыми интерфейсами, рассмотрите использование общего
решения для преобразования в последовательную форму, такого как JSON
(Javascript Object Notation).</p>

<h4><a name="ha-memcached-mysql-frontend"></a>18.2.3.2.
Применение <span><strong>memcached</strong></span>
как кэширующего уровня MySQL</h4>
<p>Когда <span><strong>memcached</strong></span> используется, чтобы
кэшировать данные MySQL, Ваше приложение должно получить данные от базы
данных и загрузить соответствующие пары значения ключа в кэш.
Тогда последующие поиски могут быть сделаны непосредственно в кэш.</p>

<p>Поскольку у MySQL есть свои собственные механизмы кэширования в памяти
для запрашиваемых данных, такие как <code>InnoDB</code> и кэш запроса MySQL,
ищите возможности вне загрузки отдельных значений столбцов или строк в кэш.
Предпочтите кэшировать сложные значения, такие как полученные от многих
таблиц до запроса соединения или наборов результатов, собранных
из многих строк.</p>

<p>Ограничьте информацию в кэше несекретными данными, потому что нет никакой
безопасности, требуемой, чтобы получить доступ или обновить информацию в
пределах <span><strong>memcached</strong></span>. У любого с доступом к
машине есть способность считать, рассмотреть и потенциально обновить
информацию. Чтобы сохранить данные безопасными, зашифруйте информацию прежде,
чем кэшировать. Чтобы ограничить пользователей, способных к соединению с
сервером, отключите сетевой доступ или используйте IPTables или подобные
методы, чтобы ограничить доступ к портам <span><strong>memcached</strong>
</span> избранным набором хостов.</p>

<p>Вы можете ввести <code>memcached</code> в существующее приложение, даже
если кэширование не было частью оригинального проекта. На многих языках
изменения приложения будут только несколькими строками, чтобы попытаться
сначала читать из кэша, загружая данные, и отступить к старому методу, если
информация не будет кэшироваться, и обновить кэш с информацией, как только
данные были считаны.</p>

<p>Общая последовательность для того, чтобы использовать
<span><strong>memcached</strong></span>
на любом языке как кэширующее решение для MySQL следующяя:</p>

<ol type="1"><li><p>Запросите элемент от кэша.</li>
<li>Если он там есть, используйте данные.</li>
<li>Если его там нет, загрузите данные из MySQL и сохраните значение в кэше.
Это означает, что значение доступно следующему клиенту, который запросит
это из кэша.</p></li></ol>

<a name="ha-memcached-fig-basicflow"></a><p><b>Рис. 18.6.
Типичная блок-схема приложения <span>memcached</span></b></p>
<img src="flow.png" width="288" height="437">

<h5><a name="idm139965311578352"></a>Лучшие методы приспосабливания
базы данных к <span><strong>memcached</strong></span></h5>
<p>Самый прямой способ кэшировать данные MySQL состоит в том, чтобы
использовать таблицу на 2 столбца, где первый столбец
<a href="glossary.htm#glos_primary_key">первичный ключ</a>.
Из-за требований уникальности для ключей <span><strong>memcached</strong>
</span> удостоверьтесь, что Ваша схема базы данных делает соответствующее
использование первичных ключей и
<a href="glossary.htm#glos_unique_constraint">уникальных ограничений</a>.
</p>

<p>Если Вы комбинируете многократные значения столбцов в единственное
значение элемента <span><strong>memcached</strong></span>,
выбирайте типы данных так, чтобы облегчить разбор значения назад на его
компоненты, например, при использовании символа разделителя
между числовыми значениями.</p>

<p>Запросы, которые отображаются наиболее легко на
<span><strong>memcached</strong></span> это поиски с одним
<code>WHERE</code>, использующие оператор <code>=</code> или <code>IN</code>.
Для сложного <code>WHERE</code> или запросов, которые используют такой
оператор, как <code>&lt;</code>, <code>&gt;</code>, <code>BETWEEN</code> или
<code>LIKE</code>, <span><strong>memcached</strong></span> не обеспечивает
простой или эффективный способ фильтровать ключи или связанные значения, так
что, как правило, Вы выполняете те операции как запросы SQL в
основной базе данных.</p>

<h4><a name="ha-memcached-interfaces-libmemcached"></a>18.2.3.3.
Использование <code>libmemcached</code> с C и C++</h4>
<p>Библиотека <code>libmemcached</code> обеспечивает интерфейсы C и C++ к
<span><strong>memcached</strong></span> и является также основанием для
различных дополнительных API, включая Perl, Python и Ruby. Понимание ядра
<code>libmemcached</code> может помочь, используя эти другие интерфейсы.</p>

<p>Библиотека C самая всесторонняя библиотека интерфейса для
<span><strong>memcached</strong></span> обеспечивает функции и операционные
системы, не всегда выставляемые в интерфейсах, не основанных
на библиотеке <code>libmemcached</code>.</p>

<p>Различные функции могут быть разделены согласно их основной работе. В
дополнение к функциям, которые взаимодействуют через интерфейс к основному
API, много служебных функций обеспечивают расширенную функциональность, такую
как добавление и предвыборка данных.</p>

<p>Чтобы собрать и установить <code>libmemcached</code>, скачайте пакет
<code>libmemcached</code>, запустите <span><strong>configure</strong></span>,
соберите и затем поставьте:
<pre>
shell&gt; tar xjf libmemcached-0.21.tar.gz
shell&gt; cd libmemcached-0.21
shell&gt; ./configure
shell&gt; make
shell&gt; make install
</pre>

<p>На многих операционных системах Linux Вы можете установить пакет
<code>libmemcached</code> через обычный менеджер пакетов
<span><strong>yum</strong></span>, <span><strong>apt-get</strong></span>
или подобное приложение.</p>

<p>Чтобы создать приложение, которое пользуется библиотекой, сначала
устанавливается список серверов. Любое непосредственно управление
сконфигурированными серверами выполняется в пределах основной структуры
<code>memcached_st</code> или отдельно заполняется список серверов, а затем
этот список добавляется к структуре <code>memcached_st</code>.
Последний метод используется в следующем примере. Как только список серверов
был установлен, Вы можете вызвать функции, чтобы сохранить или получить
данные. Простое приложение для того, чтобы установить заданное значение в
<code>localhost</code> обеспечено здесь:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;libmemcached/memcached.h&gt;

int main(int argc, char *argv[])
{
  memcached_server_st *servers = NULL;
  memcached_st *memc;
  memcached_return rc;
  char *key= "keystring";
  char *value= "keyvalue";

  memcached_server_st *memcached_servers_parse (char *server_strings);
  memc= memcached_create(NULL);
  servers= memcached_server_list_append(servers, "localhost", 11211, &amp;rc);
  rc= memcached_server_push(memc, servers);
  if (rc == MEMCACHED_SUCCESS)
     fprintf(stderr,"Added server successfully\n");
  else fprintf(stderr,"Couldn't add server: %s\n",
               memcached_strerror(memc, rc));
  rc= memcached_set(memc, key, strlen(key), value, strlen(value), (time_t)0,
                    (uint32_t)0);
  if (rc == MEMCACHED_SUCCESS) fprintf(stderr,"Key stored successfully\n");
  else fprintf(stderr,"Couldn't store key: %s\n",memcached_strerror(memc,
               rc));
  return 0;
}
</pre>

<p>Чтобы проверить успех работы, используйте возвращаемое значение
или заполненный код результата для данной функции. Значение всегда
устанавливается в <code>MEMCACHED_SUCCESS</code>, если работа успешна.
В случае отказа используйте функцию <code>memcached_strerror()</code>,
чтобы преобразовать код результата в пригодную для печати строку.</p>

<p>Чтобы создать приложение, определите библиотеку <code>memcached</code>:
<pre>
shell&gt; gcc -o memc_basic memc_basic.c -lmemcached
</pre>

<p>Выполнение вышеупомянутого примера приложения, после запуска сервера
<span><strong>memcached</strong></span> должно возвратить сообщение успеха:
<pre>
shell&gt; memc_basic
Added server successfully
Key stored successfully
</pre>

<h5><a name="ha-memcached-interfaces-libmemcached-base"></a>18.2.3.3.1.
Основные функции <code>libmemcached</code></h5>
<p>Основные функции позволяют Вам создавать, разрушать и клонировать
основную структуру <code>memcached_st</code>, которая используется, чтобы
взаимодействовать через интерфейс с серверами <code>memcached</code>.
Основные функции определены ниже:

<pre>
memcached_st *memcached_create (memcached_st *ptr);
</pre>
<p>Создает новую структуру <code>memcached_st</code> для использования с
другими функциями API <code>libmemcached</code>.
Вы можете поставлять существующую, статическую, структуру
<code>memcached_st</code> или <code>NULL</code>, чтобы иметь новую структуру.
Возвращает указатель на создаваемую структуру или <code>NULL</code>
при отказе или сбое.

<pre>
void memcached_free (memcached_st *ptr);
</pre>
<p>Освобождает структуру и память, выделенную ранее создаваемой
структурой <code>memcached_st</code>.

<pre>
memcached_st *memcached_clone(memcached_st *clone, memcached_st *source);
</pre>
<p>Клонирует существующую структуру <code>memcached_st</code> из
указанной <code>source</code>, копируя значения по умолчанию и список
серверов, определенные в структуре.</p>

<h5><a name="ha-memcached-interfaces-libmemcached-servers"></a>18.2.3.3.2.
Функции сервера <code>libmemcached</code></h5>
<p>API <code>libmemcached</code> использует список серверов, сохраненный в
пределах структуры <code>memcached_server_st</code>, чтобы действовать как
список серверов, используемых остальной частью функций. Используя
<code>memcached</code>, Вы сначала создаете список серверов и затем
применяете его к допустимому объекту <code>libmemcached</code>.</p>

<p>Поскольку список серверов и список серверов в пределах активного
объекта <code>libmemcached</code> могут управляться отдельно,
Вы можете обновить и управлять списками в то время, как активный
интерфейс <code>libmemcached</code> работает.</p>

<p>Функции для того, чтобы управлять списком серверов в
структуре <code>memcached_st</code>:
<pre>
memcached_return memcached_server_add(memcached_st *ptr,
                                      char *hostname, unsigned int port);
</pre>
<p>Добавляет сервер, используя данные <code>hostname</code> и
<code>port</code> в структуру <code>memcached_st</code>,
указанную через <code>ptr</code>.

<pre>
memcached_return memcached_server_add_unix_socket(memcached_st *ptr,
                                                  char *socket);
</pre>
<p>Добавляет Unix-сокет к списку серверов, сконфигурированных в
структуре <code>memcached_st</code>.

<pre>
unsigned int memcached_server_count (memcached_st *ptr);
</pre>
<p>Возвращает количество сконфигурированных серверов в пределах
структуры <code>memcached_st</code>.

<pre>
memcached_server_st * memcached_server_list (memcached_st *ptr);
</pre>
<p>Возвращает массив всех определенных узлов в <code>memcached_st</code>.

<pre>
memcached_return memcached_server_push(memcached_st *ptr,
                                       memcached_server_st *list);
</pre>
<p>Продвигает существующий список серверов в список серверов,
сконфигурированных для текущей структуры <code>memcached_st</code>. Это
добавляет серверы в конец существующего списка и дубликаты не проверяет.</p>

<p>Структура <code>memcached_server_st</code> может использоваться, чтобы
создать список серверов <code>memcached</code>, которые могут быть применены
индивидуально к разным копиям <code>memcached_st</code>.

<pre>
memcached_server_st * memcached_server_list_append(memcached_server_st *ptr,
                      char *hostname, unsigned int port,
                      memcached_return *error);
</pre>

<p>Добавляет сервер с <code>hostname</code> и <code>port</code>
в список серверов в <code>ptr</code>. Код результата обработан параметром
<code>error</code>, который должен указать на существующую переменную
<code>memcached_return</code>. Функция возвращает указатель
на возвращенный список.

<pre>
unsigned int memcached_server_list_count (memcached_server_st *ptr);
</pre>
<p>Возвращает число серверов в списке.

<pre>
void memcached_server_list_free (memcached_server_st *ptr);
</pre>
<p>Освобождает память, связанную со списком серверов.

<pre>
memcached_server_st *memcached_servers_parse (char *server_strings);
</pre>
<p>Разбирает строку, содержащую список серверов, где отдельные серверы
отделены запятой, пробелом или тем и другим сразу, и где отдельные серверы
имеют форму <code><em><code>server</code></em>[:<em><code>port</code></em>]
</code>. Возвращаемое значение структура списка серверов.</p>

<h5><a name="ha-memcached-interfaces-libmemcached-set"></a>18.2.3.3.3.
Функции множества <code>libmemcached</code></h5>
<p>Связанные с набором функции <code>libmemcached</code>
обеспечивают ту же самую функциональность как основные функции, поддержанные
протоколом <code>memcached</code>. Полное определение
то же самое для всех основных функций (<code>add</code>,
<code>replace</code>, <code>prepend</code>, <code>append</code>).
Например, функциональное определение для <code>memcached_set()</code>:
<pre>
memcached_return memcached_set(memcached_st *ptr, const char *key,
                               size_t key_length, const char *value,
                               size_t value_length, time_t expiration,
                               uint32_t flags);
</pre>

<p><code>ptr</code> структура <code>memcached_st</code>. <code>key</code> и
<code>key_length</code> определяют ключевое имя и длину, а
<code>value</code> и <code>value_length</code> соответствующее значение и его
длину. Вы можете также установить время истечения и дополнительные флаги. Для
получения дополнительной информации см.
<a href="#ha-memcached-interfaces-libmemcached-behaviors">раздел
18.2.3.3.5</a>.</p>

<p>Эта таблица обрисовывает в общих чертах функции <code>libmemcached</code>
и эквивалентные функции, поддержанные протоколом <span><strong>memcached
</strong></span>.</p>

<table border="1">
<thead><tr><th scope="col">Функция <code>libmemcached</code></th>
<th scope="col">EЭквивалентная основная функция</th></tr></thead>
<tbody><tr><td scope="row"><code>memcached_set(memc, key, key_length, value,
value_length, expiration, flags)</code></td>
<td><code>set()</code>.</td></tr>
<tr><td scope="row"><code>memcached_add(memc, key, key_length, value,
value_length, expiration, flags)</code></td>
<td><code>add()</code>.</td></tr>
<tr><td scope="row"><code>memcached_replace(memc, key, key_length, value,
value_length, expiration, flags)</code></td>
<td><code>replace()</code>.</td></tr>
<tr><td scope="row"><code>memcached_prepend(memc, key, key_length, value,
value_length, expiration, flags)</code></td>
<td>Предварительно выбирает указанное <code>value</code>
перед текущим значением указанного <code>key</code>.</td></tr>
<tr><td scope="row"><code>memcached_append(memc, key, key_length, value,
value_length, expiration, flags)</code></td>
<td>Добавляет указанное <code>value</code> после
текущего значения <code>key</code>.</td></tr>
<tr><td scope="row"><code>memcached_cas(memc, key, key_length, value,
value_length, expiration, flags, cas)</code></td>
<td>Перезаписывает данные для данного ключа, пока <code>cas</code>
все еще то же самое в пределах сервера.</td></tr>
<tr><td scope="row"><code>memcached_set_by_key(memc, master_key,
master_key_length, key, key_length, value, value_length, expiration, flags)
</code></td><td>Подобно <code>set()</code>, но имеет опцию дополнительного
главного ключа, который может использоваться, чтобы идентифицировать сервер.
</td></tr>
<tr><td scope="row"><code>memcached_add_by_key(memc, master_key,
master_key_length, key, key_length, value, value_length, expiration, flags)
</code></td><td>Подобно <code>add()</code>, но имеет опцию дополнительного
главного ключа, который может использоваться, чтобы идентифицировать сервер.
</td></tr>
<tr><td scope="row"><code>memcached_replace_by_key(memc, master_key,
master_key_length, key, key_length, value, value_length, expiration, flags)
</code></td><td>Подобно <code>replace()</code>, но имеет опцию
дополнительного главного ключа, который может использоваться,
чтобы идентифицировать сервер.</td></tr>
<tr><td scope="row"><code>memcached_prepend_by_key(memc, master_key,
master_key_length, key, key_length, value, value_length, expiration, flags)
</code></td><td>Подобно <code>memcached_prepend()</code>, но имеет опцию
дополнительного главного ключа, который может использоваться,
чтобы идентифицировать сервер.</td></tr>
<tr><td scope="row"><code>memcached_append_by_key(memc, master_key,
master_key_length, key, key_length, value, value_length, expiration, flags)
</code></td><td>Подобно <code>memcached_append()</code>, но имеет опцию
дополнительного главного ключа, который может использоваться,
чтобы идентифицировать сервер.</td></tr>
<tr><td scope="row"><code>memcached_cas_by_key(memc, master_key,
master_key_length, key, key_length, value, value_length, expiration, flags)
</code></td><td>Подобно <code>memcached_cas()</code>, но имеет опцию
дополнительного главного ключа, который может использоваться,
чтобы идентифицировать сервер.</td></tr></tbody></table>

<p>Методы <code>by_key</code> добавляют два параметра, которые определяют
главный ключ, чтобы использовать во время хеширующего этапа для того, чтобы
выбрать серверы. Вы можете видеть это в следующем определении:
<pre>
memcached_return memcached_set_by_key(memcached_st *ptr,
                 const char *master_key, size_t master_key_length,
                 const char *key, size_t key_length, const char *value,
                 size_t value_length, time_t expiration, uint32_t flags);
</pre>
<p>Все функции возвращают значение типа <code>memcached_return</code>,
которое Вы можете сравнить с постоянной <code>MEMCACHED_SUCCESS</code>.</p>

<h5><a name="ha-memcached-interfaces-libmemcached-get"></a>18.2.3.3.4.
Функции Get <code>libmemcached</code></h5>
<p>Функции <code>libmemcached</code> обеспечивают прямой доступ к
единственному элементу и многоключевой механизм запроса, который обеспечивает
намного более быстрые ответы, принося большое количество ключей одновременно.
</p>

<p>Основная функция get-стиля, которая эквивалентна <code>get()</code>,
<code>memcached_get()</code>. Эта функция возвращает указатель строки,
указывая на значение, связанное с указанным ключом.
<pre>
char *memcached_get(memcached_st *ptr, const char *key, size_t key_length,
                    size_t *value_length, uint32_t *flags,
                    memcached_return *error);
</pre>

<p>Мультиключевое получение, <code>memcached_mget()</code>, тоже есть.
Используя многоключевое получение, работа намного более быстра.
Чтобы запустить этот вариант, вызовите <code>memcached_mget()</code>:
<pre>
memcached_return memcached_mget(memcached_st *ptr,
                                char **keys, size_t *key_length,
                                unsigned int number_of_keys);
</pre>

<p>Возвращаемое значение успех работы. Параметр <code>keys</code> должен быть
массивом строк, содержащих ключи, а <code>key_length</code> массив,
содержащий длину каждого соответствующего ключа. <code>number_of_keys</code>
число ключей, поставляемых в массиве.</p>

<p>Чтобы принести отдельные значения, надо использовать
<code>memcached_fetch()</code>, чтобы получить
каждое соответствующее значение.
<pre>
char *memcached_fetch(memcached_st *ptr, const char *key,
                      size_t *key_length, size_t *value_length,
                      uint32_t *flags, memcached_return *error);
</pre>

<p>Функция возвращает значение ключа с параметрами
<code>key</code>, <code>key_length</code> и <code>value_length</code>
заполняемыми соответствующим ключом и информацией о длине. Функция вернет
<code>NULL</code>, когда нет больше значений, которые будут возвращены.
Полный пример, включая заполнение ключевых данных и возвращение
информации обеспечен здесь.
<pre>
#include &lt;stdio.h&gt;
#include &lt;sstring.h&gt;
#include &lt;unistd.h&gt;
#include &lt;libmemcached/memcached.h&gt;

int main(int argc, char *argv[])
{
  memcached_server_st *servers = NULL;
  memcached_st *memc;
  memcached_return rc;
  char *keys[]= {"huey", "dewey", "louie"};
  size_t key_length[3];
  char *values[]= {"red", "blue", "green"};
  size_t value_length[3];
  unsigned int x;
  uint32_t flags;

  char return_key[MEMCACHED_MAX_KEY];
  size_t return_key_length;
  char *return_value;
  size_t return_value_length;
  memc= memcached_create(NULL);
  servers= memcached_server_list_append(servers, "localhost", 11211, &amp;rc);
  rc= memcached_server_push(memc, servers);
  if (rc == MEMCACHED_SUCCESS) fprintf(stderr,"Added server successfully\n");
  else fprintf(stderr,"Couldn't add server: %s\n",memcached_strerror(memc, rc));
  for (x= 0; x &lt; 3; x++) {
    key_length[x] = strlen(keys[x]);
    value_length[x] = strlen(values[x]);
    rc= memcached_set(memc, keys[x], key_length[x], values[x],
    value_length[x], (time_t)0, (uint32_t)0);
    if (rc == MEMCACHED_SUCCESS)
       fprintf(stderr,"Key %s stored successfully\n",keys[x]);
    else fprintf(stderr,"Couldn't store key: %s\n",
                 memcached_strerror(memc, rc));
  }
  rc= memcached_mget(memc, keys, key_length, 3);
  if (rc == MEMCACHED_SUCCESS) {
     while ((return_value= memcached_fetch(memc, return_key,
             &amp;return_key_length, &amp;return_value_length, &amp;flags,
             &amp;rc)) != NULL) {
       if (rc == MEMCACHED_SUCCESS) {
          fprintf(stderr,"Key %s returned %s\n",return_key, return_value);
       }
     }
  }
  return 0;
}
</pre>

<p>Выполнение вышеупомянутого приложения производит следующий вывод:
<pre>
shell&gt; memc_multi_fetch
Added server successfully
Key huey stored successfully
Key dewey stored successfully
Key louie stored successfully
Key huey returned red
Key dewey returned blue
Key louie returned green
</pre>

<h5><a name="ha-memcached-interfaces-libmemcached-behaviors"></a>18.2.3.3.5.
Управление поведением <code>libmemcached</code></h5>
<p>Поведение <code>libmemcached</code> может быть изменено, устанавливая один
или более флагов поведения. Они могут быть установлены глобально или
применены во время вызова отдельных функций. Некоторые параметры поведения
также принимают дополнительную установку, такую как хеширующий механизм,
используемый для выбора серверов.</p>

<p>Установить глобальные настройки поведения:
<pre>
memcached_return memcached_behavior_set(memcached_st *ptr,
                                        memcached_behavior flag,
                                        uint64_t data);
</pre>

<p>Получить текущую установку поведения:
<pre>
uint64_t memcached_behavior_get(memcached_st *ptr, memcached_behavior flag);
</pre>

<p>Следующая таблица описывает флаги поведения <code>libmemcached</code>.</p>
<table border="1">
<thead><tr><th scope="col">Поведение</th><th scope="col">Описание</th></tr>
</thead>
<tbody><tr><td scope="row"><code>MEMCACHED_BEHAVIOR_NO_BLOCK</code></td>
<td>Предписывает <code>libmemcached</code> использовать
асинхронный ввод/вывод.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_TCP_NODELAY</code></td>
<td>Включает режим без задержек для сетевых сокетов.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_HASH</code></td>
<td>Без значения устанавливает алгоритм хеширования по умолчанию для ключей в
MD5. Другие допустимые значения включают
<code>MEMCACHED_HASH_DEFAULT</code>, <code>MEMCACHED_HASH_MD5</code>,
<code>MEMCACHED_HASH_CRC</code>, <code>MEMCACHED_HASH_FNV1_64</code>,
<code>MEMCACHED_HASH_FNV1A_64</code>, <code>MEMCACHED_HASH_FNV1_32</code>
и <code>MEMCACHED_HASH_FNV1A_32</code>.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_DISTRIBUTION</code></td>
<td>Изменяет метод выбора сервера, чтобы хранить данное значение. Метод по
умолчанию <code>MEMCACHED_DISTRIBUTION_MODULA</code>. Вы можете включить
последовательное хеширование, устанавливая
<code>MEMCACHED_DISTRIBUTION_CONSISTENT</code>.
<code>MEMCACHED_DISTRIBUTION_CONSISTENT</code> псевдоним для
<code>MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA</code>.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_CACHE_LOOKUPS</code></td>
<td>Кэшировать поиски, сделанные службой DNS. Это может улучшить работу, если
Вы используете имена вместо IP-адресов для отдельных узлов.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_SUPPORT_CAS</code></td>
<td>Операции CAS. По умолчанию это отключено, потому что
имеет накладные расходы.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_KETAMA</code></td>
<td>Устанавливает распределение по умолчанию в
<code>MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA</code> и хеш в
<code>MEMCACHED_HASH_MD5</code>.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_POLL_TIMEOUT</code></td>
<td>Изменяет значение тайм-аута, используемое <code>poll()</code>.
Задает <code>signed int</code> указатель для значения тайм-аута.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_BUFFER_REQUESTS</code></td>
<td>Буферизация запросов IO. Действие get или закрытие соединения
заставляет сбросить данные.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_VERIFY_KEY</code></td>
<td>Предписывает <code>libmemcached</code> проверить, что
указанный ключ допустим.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_SORT_HOSTS</code></td>
<td>Если установлено, узлы, добавленные к списку сконфигурированных узлов
структуры <code>memcached_st</code> помещены в список узла в сортированном
порядке. Это ломает последовательное хеширование, если то
поведение было включено.</td></tr>
<tr><td scope="row"><code>MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT</code></td>
<td>В неблокированном режиме это изменяет значение тайм-аута во
время сокетного соединения.</td></tr></tbody></table>

<h5><a name="ha-memcached-interfaces-libmemcached-utilities"></a>18.2.3.3.6.
Утилиты командной строки <span><strong>libmemcached</strong></span></h5>
<p>В дополнение к основному интерфейсу библиотеки C,
<code>libmemcached</code> также включает много утилит командной строки,
которые могут быть полезными, работая с приложениями <span><strong>memcached
</strong></span>.</p>

<p>Все инструменты командной строки принимают много параметров, самый
критический из которых <code>servers</code>,
определяет список серверов, с которыми соединиться, возвращая информацию.</p>

<p>Основные инструменты:</p>
<ul><li><p><span><strong>memcat</strong></span>:
Вывести на экран значение для каждого ID, данного в командной строке:
<pre>
shell&gt; memcat --servers=localhost hwkey
Hello world
</pre></li>

<li><span><strong>memcp</strong></span>:
Скопирует содержание файла в кэш, используя имя файла в качестве ключа:
<pre>
shell&gt; echo "Hello World" &gt; hwkey
shell&gt; memcp --servers=localhost hwkey
shell&gt; memcat --servers=localhost hwkey
Hello world
</pre></li>

<li><span><strong>memrm</strong></span>: Удалит элемент из кэша:
<pre>
shell&gt; memcat --servers=localhost hwkey
Hello world
shell&gt; memrm --servers=localhost hwkey
shell&gt; memcat --servers=localhost hwkey
</pre></li>

<li><span><strong>memslap</strong></span>:
Проверит загрузку на одном или более серверов
<span><strong>memcached</strong></span>, моделируя get/set и многократные
операции клиента. Например, Вы можете моделировать загрузку 100 клиентов:
<pre>
shell&gt; memslap --servers=localhost --concurrency=100 --flush --test=get
memslap --servers=localhost --concurrency=100 --flush --test=get
Threads connecting to servers 100
Took 13.571 seconds to read data
</pre></li>

<li><span><strong>memflush</strong></span>: Сбрасывает содержание кэша.
<pre>
shell&gt; memflush --servers=localhost
</pre></li></ul>

<h4><a name="ha-memcached-interfaces-perl"></a>18.2.3.4.
Применение MySQL и <span><strong>memcached</strong></span> с Perl</h4>
<p>Модуль <code>Cache::Memcached</code> обеспечивает интерфейс к протоколу
Memcache и оказывает поддержку для основных функций, предлагаемых
<span><strong>memcached</strong></span>. Установите модуль, используя систему
управления пакетами Вашей операционной системы или <code>CPAN</code>:
<pre>
root-shell&gt; perl -MCPAN -e 'install Cache::Memcached'
</pre>

<p>Для использования <span><strong>memcached</strong></span> из Perl
через модуль <code>Cache::Memcached</code>, сначала создайте новый объект
<code>Cache::Memcached</code>, который определяет список серверов и других
параметров для соединения. Единственный параметр хеш, содержащий опции для
интерфейса кэша. Например, чтобы создать новый экземпляр, который использует
три сервера <span><strong>memcached</strong></span>:
<pre>
use Cache::Memcached;

my $cache = new Cache::Memcached {
   'servers' =&gt; [
   '192.168.0.100:11211',
   '192.168.0.101:11211',
   '192.168.0.102:11211',],};
</pre>

<p>Используя интерфейс <code>Cache::Memcached</code> с многими серверами, API
автоматически выполняет определенные операции через все серверы в группе.
Например, получая статистическую информацию через
<code>Cache::Memcached</code> возвращает хеш, который содержит данные по всем
хостам, так же как и обобщенную статистику для всех серверов в группе.</p>

<p>Вы можете установить дополнительные свойства
объекта кэша, когда он создается, определяя опцию как часть хеша опции.
Альтернативно, Вы можете использовать соответствующий метод:</p>





2507
<ul><li><p><code>servers</code> или метод
<code>set_servers()</code>: Определяет список серверов, которые будут
использоваться. Список серверов должен быть ссылкой на массив серверов,
каждый элемент которого комбинация адреса и номера порта (отделенные
двоеточием). Вы можете также определить местное соединение через сокет Unix
(например, <code>/tmp/sock/memcached</code>). Чтобы определить сервер с весом
(указание, сколь часто сервер должен использоваться во время хеширования),
определите ссылку массива с экземпляром сервера и числом веса. Более высокие
числа дают более высокий приоритет.</li>

<li><code>compress_threshold</code> или метод
<code>set_compress_threshold()</code>:
Определяет порог, когда значения сжаты. Значения больше, чем это
количество, автоматически сжаты (используя <code>zlib</code>)
во время сохранения.</li>

<li><code>no_rehash</code> или метод <code>set_norehash()</code>:
Отключает обнаружение нового сервера, если оригинальный недоступен.</li>
<li><code>readonly</code> или метод <code>set_readonly()</code>:
Отключает запись на серверы <span><strong>memcached</strong></span>.
</p></li></ul>

<p>Когда объект <code>Cache::Memcached</code> был сконфигурирован, Вы можете
использовать методы <code>set()</code> и <code>get()</code>, чтобы сохранить
и получить информацию от серверов <span><strong>memcached</strong></span>.
Объекты, хранящиеся в кэше, автоматически преобразованы в последовательную
форму силами модуля <code>Storable</code>.</p>

<p>Интерфейс <code>Cache::Memcached</code> поддерживает следующие методы для
того, чтобы сохранить/получить данные:</p>
<table border="1">
<thead><tr><th scope="col">Функция <code>Cache::Memcached</code></th>
<th scope="col">Эквивалентный нативный метод</th></tr></thead>
<tbody><tr><td scope="row"><code>get()</code></td><td><code>get()</code>.
</td></tr>
<tr><td scope="row"><code>get_multi(keys)</code></td>
<td>Получает несколько <code>keys</code> из memcache, используя
только один запрос. Возвращает ссылку хеша пар ключа/значения.</td></tr>
<tr><td scope="row"><code>set()</code></td><td><code>set()</code>.</td></tr>
<tr><td scope="row"><code>add()</code></td><td><code>add()</code>.</td></tr>
<tr><td scope="row"><code>replace()</code></td><td><code>replace()</code>.
</td></tr>
<tr><td scope="row"><code>delete()</code></td><td><code>delete()</code>.</td>
</tr>
<tr><td scope="row"><code>incr()</code></td><td><code>incr()</code>.
</td></tr>
<tr><td scope="row"><code>decr()</code></td><td><code>decr()</code>.</td>
</tr></tbody></table>

<p>Ниже приведен полный пример для того, чтобы
использовать <span><strong>memcached</strong></span> с Perl и
модулем <code>Cache::Memcached</code>
<pre>
#!/usr/bin/perl

use Cache::Memcached;
use DBI;
use Data::Dumper;

# Configure the memcached server

my $cache = new Cache::Memcached {
   'servers' =&gt; ['localhost:11211',],};

# Get the film name from the command line
# memcached keys must not contain spaces, so create
# a key name by replacing spaces with underscores

my $filmname = shift or die "Must specify the film name\n";
my $filmkey = $filmname;
$filmkey =~ s/ /_/;

# Load the data from the cache
my $filmdata = $cache-&gt;get($filmkey);

# If the data wasn't in the cache, then we load it from the database
if (!defined($filmdata)) {
   $filmdata = load_filmdata($filmname);
   if (defined($filmdata)) {
      # Set the data into the cache, using the key
      if ($cache-&gt;set($filmkey,$filmdata)) {
         print STDERR "Film data loaded from database and cached\n";
      }
      else {
        print STDERR "Couldn't store to cache\n";
      }
   }
   else {
     die "Couldn't find $filmname\n";
   }
}
else {
  print STDERR "Film data loaded from Memcached\n";
}

sub load_filmdata
{
  my ($filmname) = @_;
  my $dsn = "DBI:mysql:database=sakila;host=localhost;port=3306";
  $dbh = DBI-&gt;connect($dsn, 'sakila','password');
  my ($filmbase) = $dbh-&gt;selectrow_hashref(sprintf('select * from
                                              film where title = %s',
                                              $dbh-&gt;quote($filmname)));
  if (!defined($filmname)) {
     return (undef);
  }
  $filmbase-&gt;{stars} = $dbh-&gt;selectall_arrayref(sprintf(
                          'select concat(first_name," ",last_name) ' .
                          'from film_actor left join (actor) ' .
                          'on (film_actor.actor_id = actor.actor_id) ' .
                          ' where film_id=%s',
                          $dbh-&gt;quote($filmbase-&gt;{film_id})));
  return($filmbase);
}
</pre>

<p>Пример использует базу данных Sakila, получая данные о фильме из базы
данных и помещая сложный отчет о фильме и актерах в
<span><strong>memcached</strong></span>.
Когда запрашиваемых данных для фильма не существует,
Вы получаете этот результат:
<pre>
shell&gt; memcached-sakila.pl "ROCK INSTINCT"
Film data loaded from database and cached
</pre>

<p>Получая доступ к фильму, который был уже добавлен в кэш:
<pre>
shell&gt; memcached-sakila.pl "ROCK INSTINCT"
Film data loaded from Memcached
</pre>

<h4><a name="ha-memcached-interfaces-python"></a>18.2.3.5. Использование
MySQL и <span><strong>memcached</strong></span> с Python</h4>
<p>Модуль Python <span><strong>memcache</strong></span> взаимодействует через
интерфейс с серверами <span><strong>memcached</strong></span> и написан на
чистом Python (то есть, не используя C API). Вы можете загрузить и установить
копию с <a href="../../../www.tummy.com/Community/software/python-memcached/default.htm"
target="_top">Python Memcached</a>.</p>

<p>Чтобы установить, загрузите пакет и затем выполните установщик Python:
<pre>
python setup.py install
running install
running bdist_egg
running egg_info
creating python_memcached.egg-info
...
removing 'build/bdist.linux-x86_64/egg' (and everything under it)
Processing python_memcached-1.43-py2.4.egg
creating /usr/lib64/python2.4/site-packages/python_memcached-1.43-py2.4.egg
Extracting python_memcached-1.43-py2.4.egg to /usr/lib64/python2.4/site-packages
Adding python-memcached 1.43 to easy-install.pth file

Installed /usr/lib64/python2.4/site-packages/python_memcached-1.43-py2.4.egg
Processing dependencies for python-memcached==1.43
Finished processing dependencies for python-memcached==1.43
</pre>

<p>После того, как установлен, модуль <code>memcache</code>
обеспечивает основанный на классе интерфейс к серверам
<span><strong>memcached</strong></span>. Когда Вы храните структуры данных
Python как элементы <span><strong>memcached</strong></span>, они
автоматически преобразованы в последовательную форму (превратились в
строковые значения) с помощью модулей Python
<code>cPickle</code> или <code>pickle</code>.</p>

<p>Чтобы создать новый интерфейс <code>memcache</code>, импортируйте модуль
<code>memcache</code> и создайте новый экземпляр класса
<code>memcache.Client</code>. Например, если демон
<span><strong>memcached</strong></span> выполняется на localhost с
использованием порта по умолчанию:
<pre>
import memcache
memc = memcache.Client(['127.0.0.1:11211'])
</pre>

<p>Первый параметр массив строк, содержащих сервер и номер порта для каждого
используемого экземпляра <span><strong>memcached</strong></span>. Чтобы
позволить отладку, установите дополнительный параметр <code>debug</code> в 1.
</p>

<p>По умолчанию, хеширующий механизм делит элементы среди многих серверов.
Чтобы изменить используемую функцию, установите значение
<code>memcache.serverHashFunction</code> к дополнительной функции,
которую использовать. Например:
<pre>
from zlib import adler32
memcache.serverHashFunction = adler32
</pre>

<p>Как только Вы определили серверы, чтобы использовать в пределах
<code>memcache</code>, основные функции обеспечивают ту же самую
функциональность как в исходной спецификации интерфейса.
Следующая таблица обеспечивает обзор поддержанных функций:</p>

<table border="1">
<thead><tr><th scope="col">Функция Python <code>memcache</code></th>
<th scope="col">Эквивалентная нативная функция</th></tr></thead>
<tbody><tr><td scope="row"><code>get()</code></td><td><code>get()</code>.
</td></tr>
<tr><td scope="row"><code>get_multi(keys)</code></td><td>
Получает много значений из массива <code>keys</code>.
Возвращает ссылку хеша пар ключа/значения.</td></tr>
<tr><td scope="row"><code>set()</code></td><td><code>set()</code>.</td></tr>
<tr><td scope="row"><code>set_multi(dict [, expiry [, key_prefix]])</code>
</td><td>Устанавливает много пар ключа/значения из
<code>dict</code>.</td></tr>
<tr><td scope="row"><code>add()</code></td><td><code>add()</code>.</td></tr>
<tr><td scope="row"><code>replace()</code></td><td><code>replace()</code>.
</td></tr>
<tr><td scope="row"><code>prepend(key, value [, expiry])</code></td>
<td>Предварительно ожидает заданное <code>value</code>
к значению существующего <code>key</code>.</td></tr>
<tr><td scope="row"><code>append(key, value [, expiry[)</code></td>
<td>Добавляет <code>value</code> к значению существующего
<code>key</code>.</td></tr>
<tr><td scope="row"><code>delete()</code></td><td><code>delete()</code>.
</td></tr>
<tr><td scope="row"><code>delete_multi(keys [, expiry [, key_prefix]] )
</code></td>
<td>Удаляет все ключи из хеша, соответствующего каждой строке в массиве
<code>keys</code>.</td></tr>
<tr><td scope="row"><code>incr()</code></td><td><code>incr()</code>.
</td></tr>
<tr><td scope="row"><code>decr()</code></td><td><code>decr()</code>.
</td></tr></tbody></table>

<p>В пределах модуля Python <code>memcache</code> все функции
<code>*_multi()</code> поддерживают дополнительный параметр
<code>key_prefix</code>. Если задан, то строка используется в качестве
префикса ко всем ключевым поискам. Например, если Вы вызываете:
<pre>
memc.get_multi(['a','b'], key_prefix='users:')
</pre>

<p>Функция получает ключи <code>users:a</code> и
<code>users:b</code> с серверов.</p>
<p>Вот пример, показывающий сохранение и извлечение информации с
<code>memcache</code>, загружая необработанные данные из MySQL:
<pre>
import sys
import MySQLdb
import memcache

memc = memcache.Client(['127.0.0.1:11211'], debug=1);
try:
  conn = MySQLdb.connect (host = "localhost",
  user = "sakila",
  passwd = "password",
  db = "sakila")
except MySQLdb.Error, e:
  print "Error %d: %s" % (e.args[0], e.args[1])
  sys.exit (1)
popularfilms = memc.get('top5films')
if not popularfilms:
   cursor = conn.cursor()
   cursor.execute('select film_id,title from film order by rental_rate desc limit 5')
   rows = cursor.fetchall()
   memc.set('top5films',rows,60)
   print "Updated memcached with MySQL data"
else:
  print "Loaded data from memcached"
for row in popularfilms:
  print "%s, %s" % (row[0], row[1])
</pre>

<p>Когда выполнено впервые, данные загружены из базы данных MySQL и хранятся
в <span><strong>memcached</strong></span>.
<pre>
shell&gt; python memc_python.py
Updated memcached with MySQL data
</pre>

<p>Поскольку данные автоматически преобразованы в последовательную форму,
используя <code>cPickle</code>/<code>pickle</code>,
когда Вы загружаете данные назад из <span><strong>memcached</strong></span>,
Вы можете использовать объект непосредственно. В примере выше информация,
сохраненная в <code>memcached</code>, находится в форме строк курсора Python
DB. При получении доступа к информации (в пределах 60 секунд),
данные загружены из <code>memcached</code>:
<pre>
shell&gt; python memc_python.py
Loaded data from memcached
2, ACE GOLDFINGER
7, AIRPLANE SIERRA
8, AIRPORT POLLOCK
10, ALADDIN CALENDAR
13, ALI FOREVER
</pre>

<p>Преобразование в последовательную форму и наоборот происходят
автоматически. Поскольку преобразование в последовательную форму данных
Python может быть несовместимым с другими интерфейсами и языками, Вы можете
изменить модуль преобразования в последовательную форму, используемый во
время инициализации. Например, Вы могли бы использовать формат JSON, когда Вы
храните сложные структуры данных, используя скрипт, написанный на одном
языке, и получаете доступ к ним в скрипте, написанном на ином языке.</p>

<h4><a name="ha-memcached-interfaces-php"></a>18.2.3.6. Использование MySQL и
<span><strong>memcached</strong></span> с PHP</h4>
<p>PHP оказывает поддержку для функций Memcache посредством расширения PECL.
Чтобы включить расширение PHP <code>memcache</code>, соберите PHP с опцией
<code>--enable-memcache</code> для <span><strong>configure</strong></span>,
собирая из исходных текстов.</p>

<p>Если Вы устанавливаете сервере Red Hat, Вы можете установить
<code>php-pecl-memcache</code> RPM:
<pre>
root-shell&gt; yum --install php-pecl-memcache
</pre>

<p>На Debian используйте пакет <code>php-memcache</code>.</p>
<p>Чтобы установить глобальные параметры конфигурации во время выполнения,
определите значения параметра конфигурации в пределах Вашего файла
<code>php.ini</code>. Следующая таблица обеспечивает имя, значение по
умолчанию и описание для каждого глобального параметра конфигурации
во время выполнения.</p>

<table border="1">
<thead><tr><th scope="col">Параметр конфигурации</th><th scope="col">
Значение по умолчанию</th><th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><code>memcache.allow_failover</code></td><td>1
</td><td>Определяет, должен ли другой сервер в списке быть запрошен, если
первый выбранный сервер терпит неудачу.</td></tr>
<tr><td scope="row"><code>memcache.max_failover_attempts</code></td><td>20
</td><td>Определяет число серверов, которые попробовать прежде,
чем возвратить отказ.</td></tr>
<tr><td scope="row"><code>memcache.chunk_size</code></td><td>8192</td>
<td>Определяет размер сетевых пакетов, используемых, чтобы обменяться
информациями с сервером <span><strong>memcached</strong></span>.</td></tr>
<tr><td scope="row"><code>memcache.default_port</code></td><td>11211</td>
<td>Определяет порт по умолчанию, чтобы использовать, общаясь с серверами
<span><strong>memcached</strong></span>.</td></tr>
<tr><td scope="row"><code>memcache.hash_strategy</code></td><td>standard</td>
<td>Определяет, которую стратегию хеша использовать. Установите в
<code>consistent</code>, чтобы позволить серверам быть добавленными или
удаленными из объединения, не заставляя ключи быть повторно отображенными на
другие серверы. Когда установлено в <code>standard</code>, используется
более старая стратегия (modula), которая потенциально использует различные
серверы для хранения.</td></tr>
<tr><td scope="row"><code>memcache.hash_function</code></td><td>crc32</td>
<td>Определяет, которую функцию использовать, отображая ключи на серверы.
<code>crc32</code> использует стандартный хеш CRC32.
<code>fnv</code> использует хеш FNV-1a.</td></tr></tbody></table>

<p>Чтобы создать соединение с сервером <span><strong>memcached</strong>
</span>, создайте новый объект <code>Memcache</code> и затем определите
опции соединения. Например:
<pre>
&lt;?php
   $cache = new Memcache;
   $cache-&gt;connect('localhost',11211);
?&gt;
</pre>

<p>Это открывает непосредственное соединение с указанным сервером.</p>
<p>Чтобы использовать много серверов <span><strong>memcached</strong></span>,
Вы должны добавить серверы к объекту с использованием
<code>addServer()</code>:
<pre>
bool Memcache::addServer ( string $host [, int $port [, bool $persistent
     [, int $weight [, int $timeout [, int $retry_interval
     [, bool $status [, callback $failure_callback]]]]]]] )
</pre>

<p>Управленческий механизм сервера в пределах модуля
<code>php-memcache</code> это критическая часть интерфейса, поскольку это
управляет основным интерфейсом к <span><strong>memcached</strong></span>
и тем, как различные варианты выбраны через хеширующий механизм.</p>

<p>Создать простое соединение с двумя экземплярами
<span><strong>memcached</strong></span> можно так:
<pre>
&lt;?php
   $cache = new Memcache;
   $cache-&gt;addServer('192.168.0.100',11211);
   $cache-&gt;addServer('192.168.0.101',11211);
?&gt;
</pre>

<p>В этом сценарии соединение открыто только, когда Вы попытаетесь сохранить
или получить значение. Чтобы включить постоянное соединение с
<span><strong>memcached</strong></span>, установите <code>$persistent</code>
в true. Это настройка по умолчанию, заставляет
соединения оставаться открытыми.</p>

<p>Чтобы помочь управлять распределением ключей к различным серверам,
используйте глобальную настройку <code>memcache.hash_strategy</code>.
Это устанавливает хеширующий механизм, используемый, чтобы выбрать сервер.
Вы можете также добавить другой вес к каждому серверу, который эффективно
увеличивает число раз, которое запись о сервере появляется в списке,
увеличивая вероятность его выбора. Чтобы установить вес, установите значение
параметра <code>$weight</code> больше 1.</p>

<p>Функции для установки и получения информации идентичны базовому
функциональному интерфейсу, предлагаемому <code>memcached</code>,
как показано в этой таблице:</p>

<table border="1">
<thead><tr><th scope="col">Функция PECL <code>memcache</code></th>
<th scope="col">Базовая функция</th></tr></thead>
<tbody><tr><td scope="row"><code>get()</code></td><td><code>get()</code>.
</td></tr>
<tr><td scope="row"><code>set()</code></td><td><code>set()</code>.</td></tr>
<tr><td scope="row"><code>add()</code></td><td><code>add()</code>.</td></tr>
<tr><td scope="row"><code>replace()</code></td><td><code>replace()</code>.
</td></tr>
<tr><td scope="row"><code>delete()</code></td><td><code>delete()</code>.</td>
</tr>
<tr><td scope="row"><code>increment()</code></td><td><code>incr()</code>.
</td></tr>
<tr><td scope="row"><code>decrement()</code></td><td><code>decr()</code>.
</td></tr></tbody></table>

<p>Полный пример интерфейса PECL <code>memcache</code>
обеспечен ниже. Код загружает данные о фильме из базы данных Sakila, когда
пользователь обеспечивает имя фильма. Данные, хранимые в <code>memcached
</code>, записаны как строка результата <code>mysqli</code>, API
автоматически преобразовывает в последовательную форму информацию для Вас.
<pre>
&lt;?php
$memc = new Memcache;
$memc-&gt;addServer('localhost','11211');
if (empty($_POST['film'])) {
   ?&gt;
   &lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
   &lt;head&gt;
   &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
   &lt;title&gt;Simple Memcache Lookup&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;
   &lt;form method="post"&gt;
   &lt;p&gt;&lt;b&gt;Film&lt;/b&gt;: &lt;input type="text" size="20" name="film"&gt;&lt;/p&gt;
   &lt;input type="submit"&gt;
   &lt;/form&gt;
   &lt;hr/&gt;
   &lt;?php
} else {
  echo "Loading data...\n";
  $film   = htmlspecialchars($_POST['film'], ENT_QUOTES, 'UTF-8');
  $mfilms = $memc-&gt;get($film);
  if ($mfilms) {
     printf("&lt;p&gt;Film data for %s loaded from memcache&lt;/p&gt;", $mfilms['title']);
     foreach (array_keys($mfilms) as $key) {
       printf("&lt;p&gt;&lt;b&gt;%s&lt;/b&gt;: %s&lt;/p&gt;",
              $key, $mfilms[$key]);
     }
  } else {
    $mysqli = mysqli('localhost','sakila','password','sakila');
    if (mysqli_connect_error()) {
       sprintf("Database error: (%d) %s", mysqli_connect_errno(),
               mysqli_connect_error());
       exit;
    }
    $sql = sprintf('SELECT * FROM film WHERE title="%s"',
                   $mysqli-&gt;real_escape_string($film));
    $result = $mysqli-&gt;query($sql);
    if (!$result) {
       sprintf("Database error: (%d) %s", $mysqli-&gt;errno, $mysqli-&gt;error);
       exit;
    }
    $row = $result-&gt;fetch_assoc();
    $memc-&gt;set($row['title'], $row);
    printf("&lt;p&gt;Loaded (%s) from MySQL&lt;/p&gt;",
           htmlspecialchars($row['title'], ENT_QUOTES, 'UTF-8');
  }
}
?&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>С PHP соединения с <span><strong>memcached</strong></span>
сохранены открытыми пока PHP и связанная копия Apache остаются работать.
Добавляя или удаляя серверы из списка в рабочем экземпляре
(например, запуская другой скрипт, который упоминает дополнительные серверы),
соединения совместно использованы, но скрипт выбирает только среди серверов,
явно сконфигурированных в своих пределах.</p>

<p>Чтобы гарантировать, что изменения списка серверов в пределах скрипта
не вызывают проблемы, удостоверьтесь, что использовали
последовательный хеширующий механизм.</p>

<h4><a name="ha-memcached-interfaces-ruby"></a>18.2.3.7. Использование
MySQL и <span><strong>memcached</strong></span> с Ruby</h4>
<p>Есть много различных модулей для того, чтобы взаимодействовать через
интерфейс <span><strong>memcached</strong></span> с Ruby. Библиотека клиента
<code>Ruby-MemCache</code> обеспечивает нативный интерфейс
<span><strong>memcached</strong></span>, который не требует никаких внешних
библиотек таких, как <code>libmemcached</code>. Вы можете получить пакет
установщика с <a href="../../../www.deveiate.org/projects/RMemCache"
target="_top">http://www.deveiate.org/projects/RMemCache</a>.</p>

<p>Чтобы установить, извлеките пакет и затем выполните
<span><strong>install.rb</strong></span>:
<pre>
shell&gt; install.rb
</pre>

<p>Если у Вас есть RubyGems, Вы можете установить
<code>Ruby-MemCache</code> gem:
<pre>
shell&gt; gem install Ruby-MemCache
Bulk updating Gem source index for: http://gems.rubyforge.org
Install required dependency io-reactor? [Yn]  y
Successfully installed Ruby-MemCache-0.0.1
Successfully installed io-reactor-0.05
Installing ri documentation for io-reactor-0.05...
Installing RDoc documentation for io-reactor-0.05...
</pre>

<p>Чтобы использовать <span><strong>memcached</strong></span> в Ruby,
создайте новый экземпляр объекта <code>MemCache</code>.
<pre>
require 'memcache'
memc = MemCache::new '192.168.0.100:11211'
</pre>

<p>Вы можете добавить вес к каждому серверу, чтобы увеличить вероятность
выбора этого сервера, прилагая количество веса к строке имени хоста
сервера/номеру порта:
<pre>
require 'memcache'
memc = MemCache::new '192.168.0.100:11211:3'
</pre>

<p>Чтобы добавить серверы к существующему списку, Вы можете добавить их
непосредственно в объект <code>MemCache</code>:
<pre>
memc += ["192.168.0.101:11211"]
</pre>

<p>Чтобы установить данные в кэш, Вы можете только назначить значение ключу
в пределах нового объекта кэша, который работает точно так же как стандартный
объект хеша Ruby:
<pre>
memc["key"] = "value"
</pre>

<p>Или получить значение:
<pre>
print memc["key"]
</pre>

<p>Для более явных действий Вы можете использовать интерфейс метода, который
подражает основному API <span><strong>memcached</strong></span>, как
показано в следующей таблице:</p>

<table border="1">
<thead><tr><th scope="col">Метод Ruby <code>MemCache</code></th>
<th scope="col">Эквивалентная функция API
<span><strong>memcached</strong></span></th></tr></thead>
<tbody><tr><td scope="row"><code>get()</code></td><td><code>get()</code>.
</td></tr>
<tr><td scope="row"><code>get_hash(keys)</code></td>
<td>Получает значения многих <code>keys</code>, возвращая информацию как хеш
ключей и их значений.</td></tr>
<tr><td scope="row"><code>set()</code></td><td><code>set()</code>.</td></tr>
<tr><td scope="row"><code>set_many(pairs)</code></td><td>Устанавливает
ключи и значения в хеше <code>pairs</code>.</td></tr>
<tr><td scope="row"><code>add()</code></td><td><code>add()</code>.</td></tr>
<tr><td scope="row"><code>replace()</code></td><td><code>replace()</code>.
</td></tr>
<tr><td scope="row"><code>delete()</code></td><td><code>delete()</code>.</td>
</tr>
<tr><td scope="row"><code>incr()</code></td><td><code>incr()</code>.</td>
</tr>
<tr><td scope="row"><code>decr()</code></td><td><code>decr()</code>.</td>
</tr></tbody></table>

<h4><a name="ha-memcached-interfaces-java"></a>18.2.3.8. Использование MySQL
и <span><strong>memcached</strong></span> с Java</h4>
<p>Класс <code>com.danga.MemCached</code> в Java обеспечивает
интерфейс <span><strong>memcached</strong></span>. Вы можете получить клиент
с <a href="../../../https@github.com/gwhalin/Memcached-Java-Client/downloads"
target="_top">https://github.com/gwhalin/Memcached-Java-Client/downloads</a>.
Класс Java использует хеши, которые совместимы с
<code>libmemcached</code>, таким образом, Вы можете смешивать приложения Java
и <code>libmemcached</code>, получающие доступ к тем же самым экземплярам
<span><strong>memcached</strong></span>. Преобразование в последовательную
форму между Java и другими интерфейсами не совместимо. Если это проблема,
используйте JSON или подобный недвоичный формат
преобразования в последовательную форму.</p>

<p>На большинстве систем Вы можете загрузить пакет и
использовать непосредственно <code>jar</code>.</p>
<p>Чтобы использовать интерфейс <code>com.danga.MemCached</code>, Вы создаете
экземпляр <code>MemCachedClient</code> и затем конфигурируете список
серверов, настраивая <code>SockIOPool</code>. Через спецификацию бассейна Вы
настраиваете список сервера, веса и параметры соединения между Вашим клиентом
и экземпляром <span><strong>memcached</strong></span>,
которые Вы конфигурируете.</p>

<p>Вообще, Вы можете сконфигурировать интерфейс
<span><strong>memcached</strong></span> однажды в пределах единого класса, а
затем использовать этот интерфейс всюду по остальной части Вашего приложения.
</p>

<p>Например, чтобы создать основной интерфейс, сначала сконфигурируйте
<code>MemCachedClient</code> и основные настройки <code>SockIOPool</code>:
<pre>
public class MyClass {protected static MemCachedClient mcc = new MemCachedClient();
static {String[] servers = {"localhost:11211",};
Integer[] weights = { 1 };
SockIOPool pool = SockIOPool.getInstance();
pool.setServers( servers );
pool.setWeights( weights );
</pre>

<p>В вышеупомянутом образце список серверов сконфигурирован, создавая массив
<span><strong>memcached</strong></span>. Вы можете тогда же сконфигурировать
и отдельные веса для каждого сервера.</p>

<p>Остаток свойств для соединения является дополнительным, но Вы можете
определить соединения (начальные соединения, минимальные соединения,
максимальные соединения и тайм-аут), устанавливая параметры бассейна:
<pre>
pool.setInitConn( 5 );
pool.setMinConn( 5 );
pool.setMaxConn( 250 );
pool.setMaxIdle( 1000 * 60 * 60 * 6
</pre>

<p>Как только параметры были сконфигурированы,
инициализируйте бассейн соединения:
<pre>
pool.initialize();
</pre>

<p>Бассейн и соединение с Вашими серверами
<span><strong>memcached</strong></span> должны теперь быть готовы.</p>
<p>Установить хеширующий алгоритм можно через
<code>pool.setHashingAlg()</code>:
<pre>
pool.setHashingAlg( SockIOPool.NEW_COMPAT_HASH );
</pre>

<p>Допустимые значения <code>NEW_COMPAT_HASH</code>,
<code>OLD_COMPAT_HASH</code> и <code>NATIVE_HASH</code>,
основной хеширующий алгоритм modula. Для последовательного хеширующего
алгоритма надо использовать <code>CONSISTENT_HASH</code>. Эти константы
эквивалентны соответствующим настройкам хеша в <code>libmemcached</code>.</p>

<p>Следующая таблица обрисовывает в общих чертах методы Java
<code>com.danga.MemCached</code> и эквивалентные методы в
спецификации интерфейса <span><strong>memcached</strong></span>.</p>

<table border="1">
<thead><tr><th scope="col">Метод Java <code>com.danga.MemCached</code></th>
<th scope="col">Эквивалентный нативный метод</th></tr></thead>
<tbody><tr><td scope="row"><code>get()</code></td><td><code>get()</code>.
</td></tr>
<tr><td scope="row"><code>getMulti(keys)</code></td>
<td>Получает значения многих <code>keys</code>, возвращая информацию,
используя отображение хэша через <code>java.lang.String</code> для ключей и
<code>java.lang.Object</code> для соответствующих значений.</td></tr>
<tr><td scope="row"><code>set()</code></td><td><code>set()</code>.</td></tr>
<tr><td scope="row"><code>add()</code></td><td><code>add()</code>.</td></tr>
<tr><td scope="row"><code>replace()</code></td><td><code>replace()</code>.
</td></tr>
<tr><td scope="row"><code>delete()</code></td><td><code>delete()</code>.</td>
</tr>
<tr><td scope="row"><code>incr()</code></td><td><code>incr()</code>.</td>
</tr>
<tr><td scope="row"><code>decr()</code></td><td><code>decr()</code>.</td>
</tr></tbody></table>

<h4><a name="ha-memcached-interfaces-protocol"></a>18.2.3.9. Использование
<span><strong>memcached</strong></span> TCP Text Protocol</h4>
<p>Сообщение с сервером <span><strong>memcached</strong></span> может быть
достигнуто через TCP или через протоколы UDP. Используя протокол TCP, Вы
можете использовать простой текстовый интерфейс для обмена информацией.</p>

<p>Общаясь с <span><strong>memcached</strong></span>, Вы можете соединиться с
сервером, используя порт, сконфигурированный для сервера. Вы можете открыть
соединение с сервером, не требуя разрешения или входа в систему. Как только
Вы соединились, Вы можете начать посылать команды серверу. Когда Вы
закончили, Вы можете закончить соединение, не посылая определенной команды
разъединения. Клиенты спроектированы сохранить свои соединения открытыми,
чтобы уменьшить время ожидания и улучшить работу.</p>

<p>Данные посылают на сервер <code>memcached</code> в двух формах:</p>
<ul><li><p>Текстовые строки, которые используются, чтобы послать команды
серверу и получить ответы от сервера.</li>

<li>Неструктурированные данные, которые используются, чтобы получить
или послать информацию о значении данного ключа. Данные возвращены клиенту
точно в том формате, в каком переданы.</p></li></ul>

<p>Текстовые строки (команды и ответы) и неструктурированные данные всегда
заканчиваются строкой <code>\r\n</code>. Поскольку данные могут
содержать эту последовательность, длина данных (возвращенная клиентом прежде,
чем неструктурированные данные будут переданы) должна использоваться, чтобы
определить конец данных.</p>

<p>Команды к серверу структурированы согласно их работе:</p>
<ul><li><p><span><strong>Команды хранения</strong></span>:
<code>set</code>, <code>add</code>,
<code>replace</code>, <code>append</code>,
<code>prepend</code>, <code>cas</code>.</p>

<p>Команды хранения серверу принимают форму:
<pre>
command key [flags] [exptime] length [noreply]
</pre>

<p>Или когда использование сравнивает и переставляет (cas):
<pre>
cas key [flags] [exptime] length [casunique] [noreply]
</pre>

<p>Где:</p>
<ul><li><p><code>command</code>: Название команды.</p>
<ul><li><p><code>set</code>: Сохранить значение для ключа.</li>
<li><code>add</code>: Сохранить это значение для ключа, если ключ
еще не существует.</li>

<li><code>replace</code>: Сохранить это значение для ключа,
если ключ существует.</li>
<li><code>append</code>: Добавить поставляемое значение в конец
значения для указанного ключа. Параметры <code>flags</code> и
<code>exptime</code> не должны использоваться.</li>

<li><code>prepend</code>: Добавить значение, которое в настоящее время в
кэше, в конец поставляемого значения для указанного ключа. Параметры
<code>flags</code> и <code>exptime</code> не должны использоваться.</li>

<li><code>cas</code>: Установить указанный ключ к поставляемому значению,
только если поставляемый <code>casunique</code> совпадает.
Это эффективный эквивалент изменения информация, если никто ее не обновил.
</p></li></ul></li>

<li><p><code>key</code>: Ключ. Все данные хранятся, используя определенный
ключ. Ключ не может содержать символы управления или пробелы
и может быть до 250 символов в размере.</li>

<li><code>flags</code>: Флаги для работы (как целое число). Флаги в
<span><strong>memcached</strong></span> прозрачны. Сервер игнорирует
содержание флагов. Они могут использоваться клиентом, чтобы указать на любой
тип информации. В <span><strong>memcached</strong></span> 1.2.0 и ниже
значение 16-битовое целочисленное. В <span><strong>memcached</strong></span>
1.2.1 и выше значение 32-битовое целое число.</li>

<li><code>exptime</code>: Время истечения или ноль для отсутствия истечения.
</li>
<li><code>length</code>: Длина поставляемого значения блока
в байтах, исключая завершение <code>\r\n</code>.</li>

<li><code>casunique</code>: Уникальное 64-битовое значение существующего
входа. Это используется, чтобы сравнить с существующим значением. Используйте
значение, возвращенное командой <code>gets</code>
для обновления <code>cas</code>.</li>
<li><code>noreply</code>: Говорит серверу не отвечать на команду.
</p></li></ul>

<p>Например, чтобы сохранить значение <code>abcdef</code> в ключе
<code>xyzkey</code>, Вы использовали бы:
<pre>
set xyzkey 0 0 6\r\nabcdef\r\n
</pre>

<p>Возвращаемое значение от сервера одна строка, определяющая информацию о
состоянии или ошибке. Для получения дополнительной информации см.
<a href="#ha-memcached-interfaces-protocol-responses">таблицу 18.3</a>.
</li>

<li><span><strong>Команды извлечения</strong></span>:
<code>get</code>, <code>gets</code></p>
<p>Команды извлечения принимают форму:
<pre>
get key1 [key2 .... keyn]
gets key1 [key2 ... keyn]
</pre>

<p>Вы можете поставлять много ключи командам, каждый требуемый
ключ отделен пробелом.</p>
<p>Сервер отвечает информационной строкой формы:
<pre>
VALUE key flags bytes [casunique]
</pre>

<p>Где:</p>
<ul><li><p><code>key</code>: Имя ключа.</li>
<li><code>flags</code>: Значение целого числа флага, поставляемого
<span><strong>memcached</strong></span> серверу, когда
значение было сохранено.</li>

<li><code>bytes</code>: Размер (исключая завершение <code>\r\n</code>)
хранимого значения.</li>
<li><code>casunique</code>: Уникальное 64-битовое целое число,
которое идентифицирует элемент.</p></li></ul>

<p>Информационная строка немедленно сопровождается блоком
данных значения. Например:
<pre>
get xyzkey\r\n
VALUE xyzkey 0 6\r\n
abcdef\r\n
</pre>

<p>Если Вы просили много ключей, информационная строка и блок данных
возвращены для каждого найденного ключа. Если требуемый ключ не существует в
кэше, никакая информация не возвращена.</li>

<li><span><strong>Команда удаления</strong></span>: <code>delete</code></p>
<p>Команда удаления имеет такой вид:
<pre>
delete key [time] [noreply]
</pre>

<p>Где:</p>
<ul><li><p><code>key</code>: Имя ключа.</li>
<li><code>time</code>: Время в секундах (или определенное время Unix), после
которого клиент хочет, чтобы сервер отказался от команд <code>add</code> или
<code>replace</code> на этом ключе. Все команды <code>add</code>,
<code>replace</code>, <code>get</code> и <code>gets</code>
терпят неудачу во время этого периода. <code>set</code> работает успешно.
После этого периода ключ удален и все команды приняты.</p>
<p>Если не задано, значение, как предполагается, является
нолем (удалить сейчас).</li>

<li><code>noreply</code>: Говорит серверу не отвечать на команду.
</p></li></ul>
<p>Ответы на команду <code>DELETED</code>, чтобы указать, что ключ был
успешно удален, или <code>NOT_FOUND</code>, чтобы указать, что указанный ключ
не мог быть найден.</li>

<li><span><strong>Increment/Decrement</strong></span>:
<code>incr</code>, <code>decr</code></p>
<p>Эти команды изменяют значение ключа в пределах сервера, не выполняя
отдельную последовательность get/set. Операции предполагают, что в настоящее
время хранимое значение 64-битовое целое число. Если хранимое значение не
64-bit integer, то значение, как предполагается, является нолем.</p>

<p>Команды принимают форму:
<pre>
incr key value [noreply]
decr key value [noreply]
</pre>

<p>Где:</p>
<ul><li><p><code>key</code>: Имя ключа.</li>
<li><code>value</code>: Целое число, которое будет использоваться в качестве
значения инкремента или декремента.</li>
<li><code>noreply</code>: Говорит серверу не отвечать на команду.
</p></li></ul>

<p>Ответ:</p>
<ul><li><p><code>NOT_FOUND</code>: Указанный ключ не мог быть найден.</li>
<li><code>value</code>: Новое значение связалось с указанным ключом.
</p></li></ul>

<p>Значения, как предполагается, без знака. Для операции
<code>decr</code> значение никогда не уменьшается ниже 0. Для операции
<code>incr</code> значение имеет макусимум 64-bit.</li>

<li><span><strong>Команды статистики</strong></span>:
<code>stats</code></p>
<p>Команда <code>stats</code> предоставляет детализированную статистическую
информацию о текущем статусе <span><strong>memcached</strong></span>
и данных, которые это хранит.</p>

<p>Команды статистики принимают форму:
<pre>
STAT [name] [value]
</pre>

<p>Где:</p>
<ul><li><p><code>name</code>: Дополнительное название статистики для
возврата. Если не определено, общие статистические данные возвращены.</li>
<li><code>value</code>: Определенное значение, которое будет использоваться,
выполняя определенные операции статистики.</p></li></ul>

<p>Возвращаемое значение список данных статистики,
отформатированных следующим образом:
<pre>
STAT name value
</pre>
<p>Статистические данные закончены строкой <code>END</code>.</p>
</p></li></ul>

<a name="idm139965310899312"></a><p><b>Таблица 18.2. Команды
<span>memcached</span></b></p>
<table border="1">
<thead><tr><th scope="col">Command</th><th scope="col">Формат команды</th>
</tr></thead>
<tbody><tr><td scope="row"><code>set</code></td>
<td><code>set key flags exptime length</code>, <code>set key flags
exptime length noreply</code></td></tr>
<tr><td scope="row"><code>add</code></td>
<td><code>add key flags exptime length</code>, <code>add key flags
exptime length noreply</code></td></tr>
<tr><td scope="row"><code>replace</code></td>
<td><code>replace key flags exptime length</code>,
<code>replace key flags exptime length noreply</code></td></tr>
<tr><td scope="row"><code>append</code></td>
<td><code>append key length</code>, <code>append key length noreply
</code></td></tr>
<tr><td scope="row"><code>prepend</code></td><td><code>prepend key length
</code>, <code>prepend key length noreply</code></td></tr>
<tr><td scope="row"><code>cas</code></td>
<td><code>cas key flags exptime length casunique</code>,
<code>cas key flags exptime length casunique noreply</code></td></tr>
<tr><td scope="row"><code>get</code></td><td><code>get key1 [key2 ... keyn]
</code></td></tr>
<tr><td scope="row"><code>gets</code></td><td><code></code></td></tr>
<tr><td scope="row"><code>delete</code></td><td><code>delete key</code>,
<code>delete key noreply</code>,
<code>delete key expiry</code>,
<code>delete key expiry noreply</code></td></tr>
<tr><td scope="row"><code>incr</code></td><td><code>incr key</code>,
<code>incr key noreply</code>, <code>incr key value</code>, <code>incr key
value noreply</code></td></tr>
<tr><td scope="row"><code>decr</code></td><td><code>decr key</code>,
<code>decr key noreply</code>,
<code>decr key value</code>, <code>decr key value noreply</code></td></tr>
<tr><td scope="row"><code>stat</code></td><td><code>stat</code>,
<code>stat name</code>, <code>stat name value</code></td>
</tr></tbody></table>

Посылая команду серверу, Вы получите ответ от сервера: одно из значений в
следующей таблице. Все значения ответа сервера закончены <code>\r\n</code>:
</p>

<a name="ha-memcached-interfaces-protocol-responses"></a><p><b>
Таблица 18.3. Ответы протокола <span>memcached</span></b></p>
<table border="1">
<thead><tr><th scope="col">Строка</th><th scope="col">Описание
</th></tr></thead>
<tbody><tr><td scope="row"><code>STORED</code></td>
<td>Значение было успешно сохранено.</td></tr>
<tr><td scope="row"><code>NOT_STORED</code></td>
<td>Значение не было сохранено, но не из-за ошибки. Для команд, где Вы
добавляете или обновляете значение, если оно существует
(<code>add</code> и <code>replace</code>), или где элемент удален,
если он уже был установлен.</td></tr>
<tr><td scope="row"><code>EXISTS</code></td><td>
Используя команду <code>cas</code>, элемент, который Вы пытаетесь сохранить,
уже существует и был изменен.</td></tr>
<tr><td scope="row"><code>NOT_FOUND</code></td><td>
Элемент, который Вы пытаетесь сохранить, обновить или удалить, не существует
или был уже удален.</td></tr>
<tr><td scope="row"><code>ERROR</code></td>
<td>Вы представили несуществующее название команды.</td></tr>
<tr><td scope="row"><code>CLIENT_ERROR errorstring</code></td>
<td>Была ошибка во входной строке, детали содержатся в
<code>errorstring</code>.</td></tr>
<tr><td scope="row"><code>SERVER_ERROR errorstring</code></td>
<td>Была ошибка в сервере, которая препятствует тому, чтобы он возвратил
информацию. В экстремальных условиях сервер может отсоединить клиента после
того, как эта ошибка происходит.</td></tr>
<tr><td scope="row"><code>VALUE keys flags length</code></td>
<td>Требуемый ключ был найден, и сохраненные <code>key</code>,
<code>flags</code> и блок данных возвращены с указанной длиной
<code>length</code>.</td></tr>
<tr><td scope="row"><code>DELETED</code></td><
td>Требуемый ключ был удален с сервера.</td></tr>
<tr><td scope="row"><code>STAT name value</code></td>
<td>Строка данных о статистике.</td></tr>
<tr><td scope="row"><code>END</code></td><td>Конец данных о статистике.
</td></tr></tbody></table>

<h3><a name="ha-memcached-stats"></a>18.2.4. Получение статистики
<span><strong>memcached</strong></span></h3>
<p>У <span><strong>memcached</strong></span> есть встроенная система
статистики, которая собирает информацию о данных, сохраненных в кэше,
коэффициент совпадения кэша и подробную информацию об использовании памяти и
распределении информации. Статистические данные обеспечены на базовом уровне,
который обеспечивает основную статистику, и более определенную статистику для
определенных областей <span><strong>memcached</strong></span>.</p>

<p>Эта информация может быть полезной, чтобы гарантировать, что Вы получаете
правильный уровень кэша и использования памяти, и что Ваши
свойства конфигурации установлены на оптимальном уровне.</p>

<p>Интерфейс stats доступен через стандартный протокол
<span><strong>memcached</strong></span>, таким образом, к отчетам можно
получить доступ при использовании <span><strong>telnet</strong></span>.
Пакет <span><strong>memcached-tool</strong></span> включает поддержку
получения статистическоой информации (см. разделы
<a href="#ha-memcached-stats-slabs">18.2.4.2</a> и
<a href="#ha-memcached-stats-general">18.2.4.1</a>).</p>

<p>Альтернативно, большая часть интерфейсов API обеспечивают функцию для
того, чтобы она получила статистику с сервера.</p>
<p>Например, чтобы получить основную статистику через
<span><strong>telnet</strong></span>:
<pre>
shell&gt; telnet localhost 11211
Trying ::1...
Connected to localhost.
Escape character is '^]'.
stats
STAT pid 23599
STAT uptime 675
STAT time 1211439587
STAT version 1.2.5
STAT pointer_size 32
STAT rusage_user 1.404992
STAT rusage_system 4.694685
STAT curr_items 32
STAT total_items 56361
STAT bytes 2642
STAT curr_connections 53
STAT total_connections 438
STAT connection_structures 55
STAT cmd_get 113482
STAT cmd_set 80519
STAT get_hits 78926
STAT get_misses 34556
STAT evictions 0
STAT bytes_read 6379783
STAT bytes_written 4860179
STAT limit_maxbytes 67108864
STAT threads 1
END
</pre>

<p>Используя Perl и модуль <code>Cache::Memcached</code>, функция
<code>stats()</code> предоставит информацию обо всех серверах, в настоящее
время сконфигурированных в объекте соединения, и полную статистику для всех
серверов <span><strong>memcached</strong></span> в целом.</p>

<p>Например, следующий скрипт на Perl получает статистику
и выводит ссылку хеша, которая возвращена:
<pre>
use Cache::Memcached;
use Data::Dumper;

my $memc = new Cache::Memcached;
$memc-&gt;set_servers(\@ARGV);
print Dumper($memc-&gt;stats());
</pre>

<p>Когда выполнено на том же самом <span><strong>memcached</strong></span>,
который использовался в примере с <span><strong>Telnet</strong></span> выше,
мы получаем ссылку хеша с хостами и полной статистикой:
<pre>
$VAR1 = {
  'hosts' =&gt; {
    'localhost:11211' =&gt; {
      'misc' =&gt; {
        'bytes' =&gt; '2421', 'curr_connections' =&gt; '3',
        'connection_structures' =&gt; '56', 'pointer_size' =&gt; '32',
        'time' =&gt; '1211440166', 'total_items' =&gt; '410956',
        'cmd_set' =&gt; '588167', 'bytes_written' =&gt; '35715151',
        'evictions' =&gt; '0', 'curr_items' =&gt; '31', 'pid' =&gt; '23599',
        'limit_maxbytes' =&gt; '67108864', 'uptime' =&gt; '1254',
        'rusage_user' =&gt; '9.857805', 'cmd_get' =&gt; '838451',
        'rusage_system' =&gt; '34.096988', 'version' =&gt; '1.2.5',
        'get_hits' =&gt; '581511', 'bytes_read' =&gt; '46665716',
        'threads' =&gt; '1', 'total_connections' =&gt; '3104',
        'get_misses' =&gt; '256940'},
      'sizes' =&gt; {
        '128' =&gt; '16', '64' =&gt; '15'}}
  },
  'self' =&gt; {},
  'total' =&gt; {'cmd_get' =&gt; 838451, 'bytes' =&gt; 2421,
    'get_hits' =&gt; 581511, 'connection_structures' =&gt; 56,
    'bytes_read' =&gt; 46665716, 'total_items' =&gt; 410956,
    'total_connections' =&gt; 3104, 'cmd_set' =&gt; 588167,
    'bytes_written' =&gt; 35715151, 'curr_items' =&gt; 31,
    'get_misses' =&gt; 256940}
};
</pre>

<p>Статистические данные разделены на многие разделы, и потому может
требоваться добавить тип к команде <code>stats</code>. Каждый вывод
статистики рассмотрен более подробно в следующих разделах.</p>

<h4><a name="ha-memcached-stats-general"></a>18.2.4.1. Основная статистика
<span><strong>memcached</strong></span></h4>
<p>Вывод общей статистики обеспечивает краткий обзор работы и использования
<span><strong>memcached</strong></span>. Статистику, возвращенную командой и
ее значения, показывают в следующей таблице.</p>

<p>Следующие термины использованы, чтобы определить тип для
каждого значения статистики:</p>
<ul><li><p><code>32u</code>: 32-bit unsigned integer.</li>
<li><code>64u</code>: 64-bit unsigned integer.</li>
<li><code>32u:32u</code>: Два числа 32-bit unsigned
integer, разделенных двоеточием.</li>
<li><code>String</code>: Строка символов.</p></li></ul>

<table border="1">
<thead><tr><th scope="col">Стаистика</th><th scope="col">Тип данных</th>
<th scope="col">Описание</th><th scope="col">Версия</th></tr></thead>
<tbody><tr><td scope="row"><code>pid</code></td><td>32u</td>
<td>ID процесса <span><strong>memcached</strong></span>.</td><td> </td></tr>
<tr><td scope="row"><code>uptime</code></td><td>32u</td>
<td>Продолжительность работы (в секундах) для этого экземпляра
<span><strong>memcached</strong></span>.</td><td> </td></tr>
<tr><td scope="row"><code>time</code></td><td>32u</td>
<td>Текущее время (как epoch).</td><td> </td></tr>
<tr><td scope="row"><code>version</code></td><td>string</td>
<td>Строка версии.</td><td> </td></tr>
<tr><td scope="row"><code>pointer_size</code></td><td>string</td>
<td>Размер указателей для этого узла в битах (32 или 64).</td><td> </td></tr>
<tr><td scope="row"><code>rusage_user</code></td><td>32u:32u</td>
<td>Полное пользовательское время (seconds:microseconds).</td><td> </td></tr>
<tr><td scope="row"><code>rusage_system</code></td><td>32u:32u</td>
<td>Полное системное время (seconds:microseconds).</td><td> </td></tr>
<tr><td scope="row"><code>curr_items</code></td><td>32u</td>
<td>Текущее число элементов сохраненных сервером</td><td> </td></tr>
<tr><td scope="row"><code>total_items</code></td><td>32u</td>
<td>Общее количество элементов, сохраненных за время жизни этого экземпляра.
</td><td> </td></tr>
<tr><td scope="row"><code>bytes</code></td><td>64u</td>
<td>Текущее число байтов, используемых этим сервером,
чтобы сохранить элементы.</td><td> </td></tr>
<tr><td scope="row"><code>curr_connections</code></td><td>32u</td>
<td>Текущее число открытых соединений.</td><td> </td></tr>
<tr><td scope="row"><code>total_connections</code></td><td>32u</td>
<td>Общее количество соединений, открытых начиная с начала работы сервера.
</td><td> </td></tr>
<tr><td scope="row"><code>connection_structures</code></td>
<td>32u</td><td>Число структур соединения, выделенных сервером.</td>
<td> </td></tr>
<tr><td scope="row"><code>cmd_get</code></td><td>64u</td>
<td>Общее количество запросов извлечения (<code>get</code>).
</td><td> </td></tr>
<tr><td scope="row"><code>cmd_set</code></td><td>64u</td>
<td>Общее количество запросов хранения (<code>set</code>).
</td><td> </td></tr>
<tr><td scope="row"><code>get_hits</code></td><td>64u</td>
<td>Число ключей, которые запрошены и найдены.</td><td> </td></tr>
<tr><td scope="row"><code>get_misses</code></td><td>64u</td>
<td>Число элементов, которые запрошены и не найдены.</td><td> </td></tr>
<tr><td scope="row"><code>delete_hits</code></td><td>64u</td>
<td>Число ключей, которые были удалены.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>delete_misses</code></td><td>64u</td>
<td>Число элементов, которые надо было удалить, но не нашли.</td>
<td>1.3.x</td></tr>
<tr><td scope="row"><code>incr_hits</code></td><td>64u</td>
<td>Число ключей, которые были постепенно увеличены и сочтены существующими.
<td>1.3.x</td></tr>
<tr><td scope="row"><code>incr_misses</code></td><td>64u</td>
<td>Число элементов, которые были постепенно увеличены и не найдены.</td>
<td>1.3.x</td></tr>
<tr><td scope="row"><code>decr_hits</code></td><td>64u</td>
<td>Число ключей, которые были уменьшены.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>decr_misses</code></td><td>64u</td>
<td>Число элементов, которые были уменьшены.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>cas_hits</code></td><td>64u</td>
<td>Число ключей, которые были сравнены и сочтены существующими.</td>
<td>1.3.x</td></tr>
<tr><td scope="row"><code>cas_misses</code></td><td>64u</td>
<td>Число элементов, которые были сравнены и не найдены.
</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>cas_badvalue</code></td><td>64u</td>
<td>Число ключей, которые были сравнены, но сравниваемое (оригинальное)
значение не соответствовало поставляемому значению.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>evictions</code></td><td>64u</td>
<td>Число допустимых элементов, удаленных из кэша для новых элементов.</td>
<td> </td></tr>
<tr><td scope="row"><code>bytes_read</code></td><td>64u</td>
<td>Общее количество байтов, прочитанных этим сервером из сети.</td>
<td> </td></tr>
<tr><td scope="row"><code>bytes_written</code></td><td>64u</td>
<td>Общее количество байтов, посланных этим сервером в сеть.</td>
<td> </td></tr>
<tr><td scope="row"><code>limit_maxbytes</code></td><td>32u</td>
<td>Число байтов, которое этот сервер разрешает использовать для хранения.
</td><td> </td></tr>
<tr><td scope="row"><code>threads</code></td><td>32u</td>
<td>Число рабочих потоков.</td><td> </td></tr>
<tr><td scope="row"><code>conn_yields</code></td><td>64u</td>
<td>Число соединений (связано с опцией <code>-R</code>).</td><td>1.4.0</td>
</tr></tbody></table>

<p>Самыми полезными статистическими данными
здесь являются число хитов кэша, промахов и очищений</p>

<p>Большое количество <code>get_misses</code> может быть только
признаком, что кэш все еще заполняется информацией. Число должно в течение
долгого времени уменьшиться по сравнению с числом <code>get_hits</code>.
Если у Вас есть большое количество промахов по кэшу по сравнению
с хитами кэша после длительного периода выполнения, это может быть признаком,
что размер кэша является слишком маленьким и Вы должны увеличить полный
размер памяти или число серверов <span><strong>memcached</strong></span>,
чтобы улучшить коэффициент совпадения.</p>

<p>Большое количество <code>evictions</code>, особенно по сравнению с числом
сохраненных элементов, знак того, что Ваш кэш является слишком маленьким,
чтобы держать количество информации, которую Вы регулярно хотите хранить
кэшированной. Вместо элементов, сохраняемых в кэше, элементы сбрасываются,
чтобы пробиться новым элементам, сохраняющих оборот элементов в кэше высоким
и уменьшая эффективность кэша.</p>

<h4><a name="ha-memcached-stats-slabs"></a>18.2.4.2.
Статистика <span><strong>memcached</strong></span> Slabs</h4>
<p>Чтобы получить эту статистику, используйте команду
<code>stats slabs</code> или эквивалент API.</p>

<p>Статистические данные предоставляют Вам информацию о кусках, которые
создали и выделили для того, чтобы хранить информацию в пределах кэша. Вы
получаете информацию и о каждом отдельном классе и о полной статистике
для целого куска.
<pre>
STAT 1:chunk_size 104
STAT 1:chunks_per_page 10082
STAT 1:total_pages 1
STAT 1:total_chunks 10082
STAT 1:used_chunks 10081
STAT 1:free_chunks 1
STAT 1:free_chunks_end 10079
STAT 9:chunk_size 696
STAT 9:chunks_per_page 1506
STAT 9:total_pages 63
STAT 9:total_chunks 94878
STAT 9:used_chunks 94878
STAT 9:free_chunks 0
STAT 9:free_chunks_end 0
STAT active_slabs 2
STAT total_malloced 67083616
END
</pre>

3527
<p>Отдельные отчеты для каждого класса имеют префикс ID куска. Уникальный
ID дан каждому выделенному куску от самого маленького размера до самого
большого. Число в префиксе указывает на классификационный индекс
относительно расчетного куска от указанного фактора роста. Следовательно, в
примере, 1 размер первого куска, и 9 выделенный размер девятого куска.</p>

<p>Параметры возвращены для каждого размера куска, описание каждого параметра
обеспечено в следующей таблице.</p>
<table border="1">
<thead><tr><th scope="col">Статистическая величина</th><th scope="col">
Описание</th><th scope="col">Версия</th></tr></thead>
<tbody><tr><td scope="row"><code>chunk_size</code></td>
<td>Место, выделенное каждому куску в пределах этого класса.</td><td> </td>
</tr>
<tr><td scope="row"><code>chunks_per_page</code></td>
<td>Число кусков в пределах единственной страницы для этого класса.</td>
<td> </td></tr>
<tr><td scope="row"><code>total_pages</code></td><td>
Число страниц, выделенных этому классу.</td><td> </td></tr>
<tr><td scope="row"><code>total_chunks</code></td><td>
Число кусков, выделенных классу.</td><td> </td></tr>
<tr><td scope="row"><code>used_chunks</code></td><td>
Число кусков, выделенных элементу.</td><td> </td></tr>
<tr><td scope="row"><code>free_chunks</code></td><td>
Число кусков, еще выделенных элементам.</td><td> </td></tr>
<tr><td scope="row"><code>free_chunks_end</code></td><td>
Число свободных кусков в конце последней выделенной страницы.</td>
<td> </td></tr>
<tr><td scope="row"><code>get_hits</code></td><td>
Число хитов get к этому куску.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>cmd_set</code></td><td>
Число команд set на этом куске.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>delete_hits</code></td><td>
Число хитов удаления на этом куске.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>incr_hits</code></td><td>
Число хитов increment на этом куске.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>decr_hits</code></td><td>
Число хитов decrement на этом куске.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>cas_hits</code></td><td>
Число хитов CAS на этом куске.</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>cas_badval</code></td><td>
Число хитов CAS на этом куске, где существующее значение не соответствовало.
</td><td>1.3.x</td></tr>
<tr><td scope="row"><code>mem_requested</code></td><td>
Истинный объем памяти памяти, запрошенный в пределах этого куска.</td>
<td>1.4.1</td></tr></tbody></table>

<p>Следующие дополнительные статистические данные покрывают информацию для
всего сервера, а не на основании куска:</p>
<table border="1">
<thead><tr><th scope="col">Статистическая величина</th><th scope="col">
Описание</th><th scope="col">Версия</th></tr></thead>
<tbody><tr><td scope="row"><code>active_slabs</code></td><td>
Общее количество классов, которое выделено.</td><td> </td></tr>
<tr><td scope="row"><code>total_malloced</code></td>
<td>Общая сумма памяти, выделенной страницам.</td><td> </td>
</tr></tbody></table>

<p>Ключевые значения в статистике параметры <code>chunk_size</code>,
<code>total_chunks</code> и <code>used_chunks</code>. Они дают признаки
использования размера кусков в пределах системы. Помните, что одна пара
ключ/значения размещена в кусок подходящего размера.</p>

<p>От этих данных Вы можете понять размер и распределение куска.
Если Вы храните много элементов в значительной степени различного размера,
возможно, что корректировка фактора роста размера куска для увеличения
большими шагами, чтобы предотвратить убыток памяти, полезна. Хороший признак
плохого фактора роста: высокое число различных классов, но с относительно
немногими кусками фактически в использовании. Увеличение фактора роста
создает меньше классов и поэтому лучше использует выделенные страницы.</p>

<h4><a name="ha-memcached-stats-items"></a>18.2.4.3.
Статистика элемента <span><strong>memcached</strong></span></h4>
<p>Чтобы получить статистику, используйте команду
<code>stats items</code> или эквивалент API.</p>

<p>Статистические данные дают информацию об отдельных элементах, выделенных в
пределах данного класса.
<pre>
STAT items:2:number 1
STAT items:2:age 452
STAT items:2:evicted 0
STAT items:2:evicted_nonzero 0
STAT items:2:evicted_time 2
STAT items:2:outofmemory 0
STAT items:2:tailrepairs 0
...
STAT items:27:number 1
STAT items:27:age 452
STAT items:27:evicted 0
STAT items:27:evicted_nonzero 0
STAT items:27:evicted_time 2
STAT items:27:outofmemory 0
STAT items:27:tailrepairs 0
</pre>

<p>Число префикса против каждой статистики касается соответствующего размера
куска, как возвращено <code>stats slabs</code>. Результат отображает числа
элементов, сохраненных в пределах каждого куска каждого размера и
определенную статистику об их возрасте, количестве удалений и памяти.
Резюме статистики дано в следующей таблице.</p>

<table border="1">
<thead><tr><th scope="col">Статистическая величина</th><th scope="col">
Описание</th><td>Версия</td></tr></thead><tbody>
<tr><td scope="row"><code>number</code></td>
<td>Число элементов, в настоящее время сохраненных в этом классе.
</td><td> </td></tr>
<tr><td scope="row"><code>age</code></td>
<td>Возраст самого старого элемента в пределах класса в секундах.
</td><td> </td></tr>
<tr><td scope="row"><code>evicted</code></td><td>
Число элементов, удаленных для новых записей.</td><td> </td></tr>
<tr><td scope="row"><code>evicted_time</code></td><td>
Время последней удаленной записи.</td><td> </td></tr>
<tr><td scope="row"><code>evicted_nonzero</code></td><td>
Время последней удаленной записи, отличной от нуля.</td><td>1.4.0</td></tr>
<tr><td scope="row"><code>outofmemory</code></td><td>
Число элементов для этого класса, которые вызвали из ошибки памяти (значение
имеет смысл, только когда параметр командной строки <code>-M</code> указан).
</td><td> </td></tr>
<tr><td scope="row"><code>tailrepairs</code></td>
<td>Число раз записи для особого восстановления ID.</td><td> </td>
</tr></tbody></table>

<p>Статистика уровня элемента может использоваться, чтобы определить, сколько
элементов сохранено в пределах данного куска, их свежести и уровня обработки.
Вы можете использовать это, чтобы помочь идентифицировать, есть ли
определенные классы, которые вызывают много большее число
удалений, чем другие.</p>

<h4><a name="ha-memcached-stats-sizes"></a>18.2.4.4. Статистика размера
<span><strong>memcached</strong></span></h4>
<p>Чтобы получить этот вид статистики, используйте команду
<code>stats sizes</code> или эквивалент API.</p>

<p>Статистические данные размера предоставляют информацию о размерах и числе
элементов каждого размера в пределах кэша. Информация возвращена как два
столбца, первый столбец передает размер элемента (округленный к самой близкой
32-байтовой границе), второй столбец показывает количество числа элементов
этого размера в пределах кэша:
<pre>
96 35
128 38
160 807
192 804
224 410
256 222
288 83
320 39
352 53
384 33
416 64
448 51
480 30
512 54
544 39
576 10065
</pre>

<p>Выполнение этой статистики блокирует Ваш кэш, поскольку каждый элемент
считан из кэша для вычисления его размера. На большом кэше это может занять
время и предотвратить любые операции set или get, пока
процесс не завершится.</p>

<p>Статистические данные размера элемента полезны только, чтобы определить
размеры объектов, которые Вы храните. Так как фактическое распределение
памяти релевантно только с точки зрения размера куска и размера страницы,
информация полезна только во время осторожной отладки
или диагностического сеанса.</p>

<h4><a name="ha-memcached-stats-detail"></a>18.2.4.5. Статистика
<code>memcached</code> детали</h4>
<p>Для <span><strong>memcached</strong></span> 1.3.x и выше Вы можете
включить и получить детализированную статистику об операциях get, set и del
на отдельных ключах, сохраненных в кэше, и определить, нашли ли ключ. Эти
операции зарегистрированы только в то время, как подробный анализ включен.
</p>

<p>Чтобы включить детализированную статистику, Вы должны послать серверу
<span><strong>memcached</strong></span> команду <code>stats detail on</code>:
<pre>
$ telnet localhost 11211
Trying 127.0.0.1...
Connected to tiger.
Escape character is '^]'.
<strong><code>stats detail on</code></strong>
OK
</pre>

<p>Отдельные статистические данные зарегистрированы для каждой операции
<code>get</code>, <code>set</code> и <code>del</code>, включая ключи,
которые в настоящее время не сохранены в сервере. Например, если
предпринята попытка получить значение ключа <code>abckey</code>, и это не
существует, <code>get</code> на указанном ключе зарегистрирована, даже
если ключ в настоящее время не сохранен. <code>hits</code>, то есть, число
<code>get</code> или <code>del</code> для ключа, который существует на
сервере, также посчитаны.</p>

<p>Чтобы выключить детализированную статистику, пошлите серверу команду
<code>stats detail off</code>:
<pre>
$ telnet localhost 11211
Trying 127.0.0.1...
Connected to tiger.
Escape character is '^]'.
<strong><code>stats detail on</code></strong>
OK
</pre>

<p>Чтобы получить подробную статистику, зарегистрированную во время процесса,
пошлите команду <code>stats detail dump</code>:
<pre>
stats detail dump
PREFIX hykkey get 0 hit 0 set 1 del 0
PREFIX xyzkey get 0 hit 0 set 1 del 0
PREFIX yukkey get 1 hit 0 set 0 del 0
PREFIX abckey get 3 hit 3 set 1 del 0
END
</pre>

<p>Вы можете использовать подробную информацию о статистике, чтобы
определить, используют ли Ваши клиенты большое количество ключей, которые не
существуют на сервере, сравнивая количество
<code>hit</code> и <code>get</code> и <code>del</code>.
Поскольку информация зарегистрирована ключом, Вы можете также определить,
кластеризируются ли отказы или операции вокруг определенных ключей.</p>

<h4><a name="ha-memcached-stats-memcached-tool"></a>18.2.4.6. Использование
<span><strong>memcached-tool</strong></span></h4>
<p><span><strong>memcached-tool</strong></span> расположен в подкаталоге
<code>scripts</code> каталога исходных текстов
<span><strong>memcached</strong></span>.
Инструмент обеспечивает удобный доступ к некоторым отчетам и статистике от
любого сервера <span><strong>memcached</strong></span>.</p>

<p>Основной формат команды:
<pre>
shell&gt; ./memcached-tool hostname:port [command]
</pre>

<p>Вывод по умолчанию производит список распределений
кусков и использования. Например:
<pre>
shell&gt; memcached-tool localhost:11211 display
  #  Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM
  1     80B       93s       1       20      no       0      0        0
  2    104B       93s       1       16      no       0      0        0
  3    136B     1335s       1       28      no       0      0        0
  4    176B     1335s       1       24      no       0      0        0
  5    224B     1335s       1       32      no       0      0        0
  6    280B     1335s       1       34      no       0      0        0
  7    352B     1335s       1       36      no       0      0        0
  8    440B     1335s       1       46      no       0      0        0
  9    552B     1335s       1       58      no       0      0        0
 10    696B     1335s       1       66      no       0      0        0
 11    872B     1335s       1       89      no       0      0        0
 12    1.1K     1335s       1      112      no       0      0        0
 13    1.3K     1335s       1      145      no       0      0        0
 14    1.7K     1335s       1      123      no       0      0        0
 15    2.1K     1335s       1      198      no       0      0        0
 16    2.6K     1335s       1      199      no       0      0        0
 17    3.3K     1335s       1      229      no       0      0        0
 18    4.1K     1335s       1      248     yes      36      2        0
 19    5.2K     1335s       2      328      no       0      0        0
 20    6.4K     1335s       2      316     yes     387      1        0
 21    8.1K     1335s       3      381     yes     492      1        0
 22   10.1K     1335s       3      303     yes     598      2        0
 23   12.6K     1335s       5      405     yes     605      1        0
 24   15.8K     1335s       6      384     yes     766      2        0
 25   19.7K     1335s       7      357     yes     908    170        0
 26   24.6K     1336s       7      287     yes    1012      1        0
 27   30.8K     1336s       7      231     yes    1193    169        0
 28   38.5K     1336s       4      104     yes    1323    169        0
 29   48.1K     1336s       1       21     yes    1287      1        0
 30   60.2K     1336s       1       17     yes    1093    169        0
 31   75.2K     1337s       1       13     yes     713    168        0
 32   94.0K     1337s       1       10     yes     278    168        0
 33  117.5K     1336s       1        3      no       0      0        0
</pre>

<p>Этот вывод то же самое, если Вы определяете
<code>command</code> как <code>display</code>:
<pre>
shell&gt; memcached-tool localhost:11211 display
  #  Item_Size  Max_age   Pages   Count   Full?  Evicted Evict_Time OOM
  1     80B       93s       1       20      no      0       0        0
  2    104B       93s       1       16      no      0       0        0
...
</pre>

<p>Вывод показывает полученную в итоге версию вывода статистики.
Столбцы, обеспеченные в выводе, показывают:</p>
<ul><li><p><code>#</code>: Номер куска.</li>
<li><code>Item_Size</code>: Размер куска.</li>
<li><code>Max_age</code>: Возраст самого старого элемента.</li>
<li><code>Pages</code>: Число страниц, выделенных куску.</li>
<li><code>Count</code>: Число элементов в этом куске.</li>
<li><code>Full?</code>: Заполнен ли кусок полностью.</li>
<li><code>Evicted</code>: Число объектов, удаленных из этого куска.</li>
<li><code>Evict_Time</code>: Время (в секундах),
начиная с последнего удаления.</li>
<li><code>OOM</code>: Число элементов, которые вызвали ошибки памяти.
</p></li></ul>

<p>Вы можете также получить дамп общей статистики для сервера,
используя команду <code>stats</code>:
<pre>
shell&gt; memcached-tool localhost:11211 stats
#localhost:11211   Field Value
         accepting_conns   1
                   bytes 162
              bytes_read 485
           bytes_written 6820
              cas_badval   0
                cas_hits   0
              cas_misses   0
               cmd_flush   0
                 cmd_get   4
                 cmd_set   2
             conn_yields   0
   connection_structures  11
        curr_connections  10
              curr_items   2
               decr_hits   0
             decr_misses   1
             delete_hits   0
           delete_misses   0
               evictions   0
                get_hits   4
              get_misses   0
               incr_hits   0
             incr_misses   2
          limit_maxbytes 67108864
     listen_disabled_num   0
                     pid 12981
            pointer_size  32
           rusage_system 0.013911
             rusage_user 0.011876
                 threads   4
                    time 1255518565
       total_connections  20
             total_items   2
                  uptime 880
                 version 1.4.2
</pre>

<h3><a name="ha-memcached-faq"></a>18.2.5.
<span><strong>memcached</strong></span> FAQ</h3>
<table border="0">
<tbody><tr><td align="left" valign="top">
<a name="faq-memcached-memcached-can-os-windows"></a>
<a name="idm139965310547248"></a><p><b>18.2.5.1.</b></p></td>
<td align="left" valign="top"><p>memcached может быть выполнен в Windows?
</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Нет. В настоящее время <span><strong>memcached</strong></span> доступен
только на платформе Unix/Linux. Есть неофициальный доступный порт, см.
<a href="../../../www.codeplex.com/memcachedproviders" target="_top">
http://www.codeplex.com/memcachedproviders</a>.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-max-object-size"></a>
<a name="idm139965310543808"></a><p><b>18.2.5.2.</b></p></td>
<td align="left" valign="top"><p>Каков максимальный размер объекта, который
Вы можете хранить в memcached? Это конфигурируемо?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Максимум размера объекта по умолчанию составляет 1 МБ. В
<span><strong>memcached</strong></span> 1.4.2 и позже Вы можете изменить
максимальный размер объекта, используя параметр командной строки
<code>-I</code>.</p>

<p>Для версий перед этой, чтобы увеличить этот размер, Вы должны повторно
собрать <span><strong>memcached</strong></span>. Вы можете изменить значение
<code>POWER_BLOCK</code> в файле <code>slabs.c</code>.</p>

<p>В <span><strong>memcached</strong></span> 1.4.2 Вы можете сконфигурировать
максимальный поддержанный размер объекта при использовании параметра
командной строки <code>-I</code>. Например, чтобы увеличить максимальный
размер объекта до 5 МБ:
<pre>
$ memcached -I 5m
</pre>

<p>Если объект больше, чем максимальный размер объекта, Вы должны вручную
разделить его. <span><strong>memcached</strong></span> очень прост:
Вы даете ключ и некоторые данные, он пытается кэшировать это в RAM. Если Вы
пытаетесь сохранить больше, чем максимальный размер, значение усекается
по причинам скорости.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-write-vs-read"></a>
<a name="idm139965310533680"></a><p><b>18.2.5.3.</b></p></td>
<td align="left" valign="top"><p>Правда ли, что
<code>memcached</code> более полезен с базами данных с интенсивным чтением,
чем с интенсивной записью?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Да. <span><strong>memcached</strong></span> не играет роли в записи в базу
данных, это метод кэширования прочитанных данных в RAM.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-why-persistent"></a>
<a name="idm139965310530144"></a><p><b>18.2.5.4.</b></p></td>
<td align="left" valign="top"><p>
Есть ли накладные расходы от неиспользования постоянных соединений? Если
постоянные всегда рекомендуются, каковы
проблемы (например, блокировки)?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Если Вы не используете постоянные соединения, общаясь с
<span><strong>memcached</strong></span>, будет маленькое увеличение во
времени ожидания открытия соединения каждый раз. Эффект сопоставим с
использованием нестойких соединений с MySQL.</p>

<p>Вообще, шанс блокировки или других проблем с постоянными соединениями
минимален, потому что есть очень небольшая блокировка в пределах
<span><strong>memcached</strong></span>.
Если будет проблема, то в конечном счете Ваш запрос получит тайм-аут и не
вернет никакого результата, таким образом, Ваше
приложение должно будет загрузить данные из MySQL снова.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-how-handle-crash"></a>
<a name="idm139965310525584"></a><p><b>18.2.5.5.</b></p></td>
<td align="left" valign="top"><p>Как падение одного из серверов
<span><strong>memcached</strong></span> обрабатывается клиентом?
</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Нет никакой автоматической обработки этого. Если Ваш клиент не в состоянии
получить ответ от сервера, сделайте механизм отступления,
чтобы загрузить данные из базы данных MySQL.</p>

<p>Все API обеспечивают способность добавить и удалить серверы
<span><strong>memcached</strong></span> на лету. Если в пределах Вашего
приложения Вы замечаете, что сервер <span><strong>memcached</strong></span>
больше не отвечает, Вы можете удалить сервер из списка серверов, и ключи
будут автоматически перераспределены к другому серверу в списке. Если
сохранение контента кэша на всех Ваших серверах важно, удостоверьтесь,
что Вы используете API, который поддерживает последовательный хеширующий
алгоритм. Для получения дополнительной информации см.
<a href="#ha-memcached-using-hashtypes">раздел 18.2.2.5</a>.
</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-what-hardware"></a><p><b>18.2.5.6.</b></p>
</td>
<td align="left" valign="top"><p>Какова рекомендуемая конфигурация аппаратных
средств для memcached сервера?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
У <span><strong>memcached</strong></span> очень низкие накладные расходы.
Все, что требуется, это побольше свободной RAM. Сервер
<span><strong>memcached</strong></span> не требует специализированной машины.
Если у Вас есть сеть, приложение или серверы базы данных, у которых есть
запасная RAM, то используйте их с <span><strong>memcached</strong></span>.
</p>

<p>Чтобы создать и развернуть специализированный сервер
<span><strong>memcached</strong></span>, используйте относительно слабый
центральный процессор, много RAM и один или больше
интерфейсов Gigabit Ethernet.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-compare-data-types"></a>
<a name="idm139965310512464"></a><p><b>18.2.5.7.</b></p></td>
<td align="left" valign="top"><p>Действительно ли memcached более эффективен
для видео и аудио в противоположность текстовым данным?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
<span><strong>memcached</strong></span> работает одинаково хорошо на всех
видах данных. Любое значение, которое Вы храните, является только потоком
данных. Помните, тем не менее, что максимальный размер объекта, который Вы
можете хранить в <span><strong>memcached</strong></span>, составляет
1 МБ, но может быть сконфигурирован, чтобы размер был больше при
использовании опции <code>-I</code> в <span><strong>memcached</strong></span>
1.4.2 и позже, или изменяя исходный текст в версиях до 1.4.2.
Если Вы запланируете использование <span><strong>memcached</strong></span>
с аудио и видеоконтентом, то Вы будете, вероятно, хотеть увеличить
максимальный размер объекта. Также помните, что <span><strong>memcached
</strong></span> решение для того, чтобы кэшировать информацию для того,
чтобы читать. Это не должно использоваться для записи, кроме тех случаев,
когда, обновляется информация в кэше.</p></td></tr>
<tr><td align="left" valign="top"><a name="faq-memcached-memcached-how-aspx">
</a><a name="idm139965310505136"></a><p><b>18.2.5.8.</b></p></td>
<td align="left" valign="top"><p>
Может <span><strong>memcached</strong></span> работать с ASPX?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Есть порты и интерфейсы для многих языков. ASPX полагается на основной язык,
такой как C# или VisualBasic, и если Вы используете ASP.NET, есть библиотека
C# <span><strong>memcached</strong></span>. Для получения дополнительной
информации см. <a href="../../../https@sourceforge.net/projects/memcacheddotnet/default.htm"
target="_top"> https://sourceforge.net/projects/memcacheddotnet/</a>.
</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-how-expensive"></a>
<a name="idm139965310500944"></a><p><b>18.2.5.9.</b></p></td>
<td align="left" valign="top"><p>Как накладно установить соединение memcache?
Соединения должны быть объединены?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Открытие соединения относительно недорого, потому что нет никакой
безопасности, аутентификации или другого квитирования, имеющего место прежде,
чем Вы сможете начать посылать запросы и получать результаты. Большинство
API поддерживает постоянное соединение с <span><strong>memcached</strong>
</span>, чтобы уменьшить время ожидания. Объединение соединений зависит от
API, который Вы используете, но если Вы общаетесь непосредственно по TCP/IP,
тогда объединение соединений обеспечило бы некоторую
небольшую исполнительную выгоду.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-how-handle-down"></a>
<a name="idm139965310497728"></a><p><b>18.2.5.10.</b></p></td>
<td align="left" valign="top"><p>Как данные обработаны, когда сервер
<span><strong>memcached</strong></span> падает?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Поведение полностью зависит от приложения. Большинство приложений переходят к
загрузке из базы данных (так же, как если бы они обновляли данные в
<span><strong>memcached</strong></span>). Если Вы используете много копий
<span><strong>memcached</strong></span>, Вы могли бы также удалить именно
этот сервер из списка, чтобы это не затронуло работу. Иначе клиент все еще
попытается общаться с сервером <span><strong>memcached</strong></span>,
который соответствует ключу, который Вы пытаетесь загрузить.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-how-auto-increment-handled"></a>
<a name="idm139965310492320"></a><p><b>18.2.5.11.</b></p></td>
<td align="left" valign="top"><p>Как столбцы auto-increment в базе данных
MySQL, скоординированы с учетом нескольких серверов memcached?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Никак. Нет никаких отношений между MySQL и <span><strong>memcached</strong>
</span>, если Ваше приложение не создает их.</p>

<p>Если Вы храните информацию, основанную на ключе auto-increment на
нескольких серверах <span><strong>memcached</strong></span>, информация
хранится только на одном из экземпляров <span><strong>memcached</strong>
</span>. Клиент использует значение ключа, чтобы определить, который сервер
хранит информацию. Это не хранит ту же самую информацию на всех серверах, это
было бы тратой кэш-памяти.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-have-compression"></a>
<a name="idm139965310485648"></a><p><b>18.2.5.12.</b></p></td>
<td align="left" valign="top"><p>Действительно ли сжатие доступно?
</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Да. Большая часть API клиента поддерживает своего рода сжатие, и некоторые
даже позволяют Вам определять порог, в котором значение считают подходящим
для сжатия во время хранения.</p></td></tr>
<tr><td align="left" valign="top">
<a name="faq-memcached-memcached-can-multiple-nodes"></a>
<a name="idm139965310483456"></a><p><b>18.2.5.13.</b></p></td>
<td align="left" valign="top"><p>
Мы можем осуществить различные типы <span><strong>memcached</strong></span>
как различные узлы в том же самом сервере?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Да. Вы можете выполнить много копий <span><strong>memcached</strong></span>
на единственном сервере, и в Вашей конфигурации клиента Вы выбираете список
серверов, которые Вы хотите использовать.</p></td></tr>
<tr><td align="left" valign="top"><a name="faq-memcached-memcached-how-test">
</a><p><b>18.2.5.14.</b></p></td><td align="left" valign="top"><p>
Каковы лучшие методы для того, чтобы проверить выполнение, гарантировать, что
это улучшает работу, и измерить воздействие изменений конфигурации
<span><strong>memcached</strong></span>? Вы рекомендовали бы сохранить
конфигурацию очень простой?</p></td></tr>
<tr><td align="left" valign="top"></td><td align="left" valign="top"><p>
Лучший способ проверить работу состоит в том, чтобы запустить
<span><strong>memcached</strong></span>. Во-первых, измените свое приложение
так, чтобы оно сохранило данные непосредственно перед тем, как данные
собираются использоваться. Начиная с дескриптора API и преобразования
в последовательную форму данных, это должна быть только короткая модификация
Вашего кода. Измените процесс, который обычно загружал бы эту информацию из
MySQL, чтобы он запрашивал данные из <span><strong>memcached</strong></span>.
Если данные не могут быть загружены из <span><strong>memcached</strong>
</span>, должен произойти возврат к MySQL.</p>

<p>Все требуемые изменения, вероятно, составят только несколько строк кода.
Чтобы извлечь лучшую пользу, удостоверьтесь, что Вы кэшируете все объекты
(например, все компоненты веб-страницы, сообщения в блоге и так далее),
вместо того, чтобы использовать <span><strong>memcached</strong></span>
в качестве простого кэша отдельных строк таблиц MySQL.</p>

<p>Как только у Вас есть базовая структура, часто единственное изменение,
которое Вы должны потом сделать, это добавить больше серверов в список
серверов, используемых Вашими приложениями. Вы не должны управлять серверами
<span><strong>memcached</strong></span> и нет никакой сложной конфигурации.
Только добавьте больше серверов к списку и позвольте клиенту, API и
<span><strong>memcached</strong></span> принимать решения.
</p></td></tr></tbody></table>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
