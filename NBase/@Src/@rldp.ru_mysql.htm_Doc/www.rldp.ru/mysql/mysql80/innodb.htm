<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 16. Механизм хранения InnoDB</title>
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="innodb-storage-engine"></a>Глава 16. Механизм хранения InnoDB
</h1>
<h2><a name="innodb-introduction"></a>16.1. Введение в InnoDB</h2>
<p><code>InnoDB</code> механизм хранения общего назначения, который
балансирует высокую надежность и высокую производительность. В MySQL 8.0
механизм хранения по умолчанию. Если Вы не сконфигурировали иной механизм
хранения значения по умолчанию, <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> без предложения <code>ENGINE=</code> создает
таблицу <code>InnoDB</code>.</p>

<h3><a name="innodb-key-advantages"></a>Главные преимущества InnoDB</h3>
<p>Главные преимущества <code>InnoDB</code>:</p>
<ul><li><p>Его операции <a href="glossary.htm#glos_dml">DML</a> следуют
модели <a href="glossary.htm#glos_acid">ACID</a> с
<a href="glossary.htm#glos_transaction">транзакционными</a> возможностями
<a href="glossary.htm#glos_commit">commit</a>,
<a href="glossary.htm#glos_rollback">rollback</a> и
<a href="glossary.htm#glos_crash_recovery">crash-recovery</a>, чтобы
защитить пользовательские данные. См.
<a href="#mysql-acid">раздел 16.2</a>.</li>

<li><a href="glossary.htm#glos_locking">Блокировка</a> на уровне строки и
Oracle-стиль <a href="glossary.htm#glos_consistent_read">последовательного
чтения</a> увеличивают многопользовательский параллелизм и скорость. См.
<a href="#innodb-locking-transaction-model">раздел 16.5</a>.</li>

<li><code>InnoDB</code>-таблицы располагают Ваши данные по диску, чтобы
оптимизировать запросы, основанные на
<a href="glossary.htm#glos_primary_key">первичных ключах</a>. Каждая таблица
<code>InnoDB</code> индекс по первичному ключу, известный как
<a href="glossary.htm#glos_clustered_index">кластеризируемый индекс</a>,
который организует данные, чтобы минимизировать ввод/вывод для поисков
первичного ключа. См. <a href="#innodb-index-types">раздел 16.8.8
</a>.</li>

<li>Для <a href="glossary.htm#glos_referential_integrity">целостности</a>
данных <code>InnoDB</code> реализует ограничения
<a href="glossary.htm#glos_foreign_key"><code>FOREIGN KEY</code></a>.
С внешними ключами вставки, обновления и удаления проверены, чтобы
гарантировать, что они не приводят к несогласованностям в различных таблицах.
См. <a href="#innodb-foreign-key-constraints">раздел 16.8.6</a>.
</p></li></ul>

<a name="idm139965330980256"></a><p><b>Table 16.1.
Особенности механизма хранения InnoDB</b></p>
<table border="1">
<tbody><tr><td><span><strong>Пределы хранения</strong></span></td>
<td>64TB</td><td><span><strong>Транзакции</strong></span></td><td>Да</td>
<td><span><strong>Блокировка степени детализации</strong></span></td>
<td>Строка</td></tr>
<tr><td><span><strong>MVCC</strong></span></td><td>Да</td>
<td><span><strong>Поддержка геоданных</strong></span></td><td>Да</td>
<td><span><strong>Индексирование геоданных</strong></span></td><td>Да</td>
</tr>
<tr><td><span><strong>Индексы B-tree</strong></span></td><td>Да</td>
<td><span><strong>Индексы T-tree</strong></span></td><td>Нет</td>
<td><span><strong>Индексы Hash</strong></span></td><td>Нет</td></tr>
<tr><td><span><strong>Полнотекстовый поиск</strong></span></td>
<td>Да</td><td><span><strong>Кластеризируемый индекс</strong></span></td>
<td>Да</td><td><span><strong>Кэширование данных</strong></span></td>
<td>Да</td></tr>
<tr><td><span><strong>Кэширование индексов</strong></span></td><td>Да</td>
<td><span><strong>Сжатие данных</strong></span></td><td>Да</td>
<td><span><strong>Шифрование</td><td>Да</td></tr>
<tr><td><span><strong>Поддержка базы данных кластера</strong></span></td>
<td>Нет</td><td><span><strong>Репликация</strong></span></td><td>Да</td>
<td><span><strong>Внешние ключи</strong></span></td><td>Да</td></tr>
<tr><td><span><strong>Резервное копирование/восстановление момента времени
</strong></span></td><td>Да</td><td><span><strong>Кэш запросов</strong>
</span></td><td>Да</td><td><span><strong>Статистика обновления словаря данных
</strong></span></td><td>Да</td></tr></tbody></table>

<p>Чтобы сравнить особенности <code>InnoDB</code> с другими механизмами
хранения, предоставленными MySQL, см.
<a href="storage.htm">главу 17</a>.</p>

<h3><a name="innodb-enhancements"></a>Улучшения InnoDB и новые особенности
</h3>
<p>Для информации об улучшениях <code>InnoDB</code>
и новых особенностях в MySQL 8.0 обратитесь к:</p>

<ul><li><p>Перечень улучшений <code>InnoDB</code> в
<a href="intro.htm#mysql-nutshell">разделе 1.4</a>.</li>
<li><a href="../../../dev.mysql.com/doc/relnotes/mysql/8.0/en/default.htm"
target="_top">Release Notes</a>.</p></li></ul>

<h3><a name="idm139965330936720"></a>
Дополнительная информация о InnoDB и ресурсы</h3>
<ul><li><p>Термины <code>InnoDB</code> перечислены в
<a href="glossary.htm">глоссарии</a>.</li>

<li>Для форума, посвященного механизму хранения <code>InnoDB</code>, см.
<a href="../../../forums.mysql.com/list.php@22" target="_top">
MySQL Forums::InnoDB</a>.</li>

<li><code>InnoDB</code> is published under the same GNU GPL
License Version 2 (of June 1991) as MySQL. Подробности лицензирования MySQL
см. на <a href="../../../www.mysql.com/company/legal/licensing/default.htm" target="_top">
http://www.mysql.com/company/legal/licensing/</a>.</p></li></ul>

<h3><a name="innodb-benefits"></a>16.1.1. Выгода от использования
таблиц InnoDB</h3>
<p>Если Вы используете таблицы <a href="storage.htm#myisam-storage-engine">
<code>MyISAM</code></a>, Вы можете счесть <code>InnoDB</code>
выгодными по следующим причинам:</p>

<ul><li><p>Если Ваш сервер отказывает из-за аппаратных средств или проблемы
программного обеспечения, независимо от того, что происходило в базе данных в
то время, Вы не должны сделать ничего специального после перезапуска базы
данных. <code>InnoDB</code> автоматически завершает любые изменения, которые
были переданы перед временем катастрофического отказа, и отменяет любые
изменения, которые были в процессе, но не завершены. Только перезапустите
сервер и продолжите работу.</li>

<li>Механизм хранения <code>InnoDB</code> поддерживает свой собственный
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>, так что хранит
таблица кэшей и индексирлванные данные в основной памяти, пока к данным
получают доступ. Часто используемые данные обработаны непосредственно в
памяти. Этот кэш относится ко многим типам информации и ускоряет обработку.
На специализированных серверах базы данных до 80% физической памяти часто
назначаются на буферный пул <code>InnoDB</code>.</li>

<li>Если Вы разделяете связанные данные на различные таблицы, Вы можете
настроить <a href="glossary.htm#glos_foreign_key">внешние ключи</a>,
которые проводят в жизнь <a href="glossary.htm#glos_referential_integrity">
ссылочную целостность</a>. Обновите или удалите данные, и связанные данные в
других таблицах обновлены или удалены автоматически. Попытайтесь вставить
данные во вторичную таблицу без соответствующих данных в основной таблице, и
неправильные данные будут блокированы автоматически.</li>

<li>Если данные становятся поврежденными на диске или в памяти, механизм
<a href="glossary.htm#glos_checksum">контрольной суммы</a>
предупреждает Вас прежде, чем Вы будете использовать это.</li>

<li>Когда Вы разрабатываете свою базу данных с соответствующими столбцами
<a href="glossary.htm#glos_primary_key">первичного ключа</a>
для каждой таблицы, операции, вовлекающие те столбцы, автоматически
оптимизированы. Это очень быстро, чтобы сослаться на столбцы первичного ключа
в <a href="sql.htm#select"><code>WHERE</code></a>,
<a href="sql.htm#select"><code>ORDER BY</code></a>,
<a href="sql.htm#select"><code>GROUP BY</code></a> и
<a href="glossary.htm#glos_join">join</a>.</li>

<li>Вставки, обновления и удаления оптимизированы автоматическим механизмом,
названным <a href="glossary.htm#glos_change_buffering">буферизацией
изменения</a>. <code>InnoDB</code> не только позволяет параллельное чтение и
запись к той же самой таблице, это кэширует измененные данные, чтобы
упростить дисковый ввод/вывод.</li>

<li>Исполнительная выгода не ограничена гигантскими таблицами с
продолжительными запросами. То, когда к тем же самым строкам получают доступ
много раз из таблицы, особенность, названная
<a href="glossary.htm#glos_adaptive_hash_index">адаптивным хеш-индексом</a>,
предназначенная, чтобы сделать эти поиски еще быстрее, как будто они вышли
из хэш-таблицы.</li>

<li>Вы можете сжать таблицы и связанный индекс.</li>
<li>Вы можете создать и удалить индексы
с намного меньшим воздействием на работу и доступность.</li>

<li>Усечение табличного пространства
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
очень быстро, и может освободить дисковое пространство для операционной
системы к повторному использованию, вместо того, чтобы освободить
пространство в пределах <a href="glossary.htm#glos_system_tablespace">system
tablespace</a>, которое только <code>InnoDB</code> может снова использовать.
</li>

<li>Расположение хранения для табличных данных более эффективно для
<a href="types.htm#blob"><code>BLOB</code></a> и длинных текстовых полей с
форматом строки <a href="glossary.htm#glos_dynamic_row_format">DYNAMIC</a>.
</li>

<li>Вы можете контролировать внутренние работы механизма хранения, запрашивая
таблицы <a href="glossary.htm#glos_information_schema">INFORMATION_SCHEMA
</a>.</li>

<li>Вы можете контролировать исполнительные детали механизма
хранения, запрашивая таблицы
<a href="glossary.htm#glos_performance_schema">Performance Schema</a>.</li>

<li>Вы можете свободно смешать <code>InnoDB</code> с таблицами других
механизмов хранения MySQL, даже в пределах того же самого запроса. Например,
Вы можете использовать <a href="glossary.htm#glos_join">join</a>, чтобы
объединить данные от <code>InnoDB</code> и
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>.</li>

<li><code>InnoDB</code> был разработан для эффективности
центрального процессора и максимальной производительности, обрабатывая
большие объемы данных.</li>

<li>Таблицы <code>InnoDB</code> могут обработать большие количества данных,
даже на операционных системах, где размер файла ограничен 2GB.</p></li></ul>
<p>Для <code>InnoDB</code>-специфичных методов тюнинга, которые Вы можете
применить в своем коде программы, см.
<a href="optimiz.htm#optimizing-innodb">раздел 9.5</a>.</p>

<h3><a name="innodb-best-practices"></a>16.1.2.
Лучшие методы для таблиц InnoDB</h3>
<p>Этот раздел описывает лучшие методы использования
таблиц <code>InnoDB</code>.
</p>

<ul><li><p>Определение <a href="glossary.htm#glos_primary_key">первичного
ключа</a> для каждой таблицы, используя наиболее часто запрашиваемый столбец
или столбцы, или значения <a href="glossary.htm#glos_auto_increment">
auto-increment</a>, если нет никакого очевидного первичного ключа.</li>

<li>Использование <a href="glossary.htm#glos_join">join</a>
везде, где данные вытягивают из многих таблиц, основанных на идентичных
значениях идентификаторов. Для быстрой работы объединения определите
<a href="glossary.htm#glos_foreign_key">внешние ключи</a> на столбцах
соединения и объявите те столбцы с тем же самым типом данных в каждой
таблице. Добавление внешних ключей гарантирует, что столбцы, на которые
ссылаются, индексированы, что может улучшить работу. Внешние ключи также
размножаются, удаляются или обновляются ко всем затронутым таблицам, и
предотвращают вставку данных в дочерней таблице, если соответствующие ID
не присутствуют в родительской таблице.</li>

<li>Выключение <a href="glossary.htm#glos_autocommit">autocommit</a>.</li>
<li>Группировка наборов связанных операций
<a href="glossary.htm#glos_dml">DML</a> в
<a href="glossary.htm#glos_transaction">транзакции</a>, заключая их в
скобки с <code>START TRANSACTION</code> и <code>COMMIT</code>.
В то время как Вы не хотите передавать транзакции слишком часто, Вы также не
хотите выпускать огромные пакеты
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>, которые работают в
течение многих часов.</li>

<li>Не использование <a href="sql.htm#lock-tables"><code>LOCK TABLES</code>
</a>. <code>InnoDB</code> может обработать многократные сеансы чтения и
записи той же самой таблицы сразу, не жертвуя надежностью или высокой
производительностью. Чтобы получить исключительный доступ на запись
к ряду строк, используют
<a href="#innodb-locking-reads"><code>SELECT ... FOR UPDATE</code>
</a>, чтобы заблокировать только строки, которые Вы намереваетесь обновить.
</li>

<li>Включение опции <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>, чтобы поместить данные и индексы для
отдельных таблиц в отдельные файлы, вместо единственного гигантского
<a href="glossary.htm#glos_system_tablespace">system tablespace</a>.
Эта установка позволяет использовать некоторые из других функций, такие как
табличное <a href="glossary.htm#glos_compression">сжатие</a> и быструю
<a href="glossary.htm#glos_truncate">обрезку</a>.</p>

<p>Опция <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> включена по умолчанию в MySQL 5.6.6.</li>
<li>Оценка, извлекают ли Ваши данные и образцы доступа выгоду из
<a href="glossary.htm#glos_compression">сжатых</a> таблиц
<code>InnoDB</code> (<code>ROW_FORMAT=COMPRESSED</code> в запросе
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>).
Вы можете сжать таблицы <code>InnoDB</code>, не жертвуя
способностью чтения-записи.</li>

<li>Выполнение Вашего сервера с опцией
<a href="server.htm#sysvar_sql_mode"><code>--sql_mode=NO_ENGINE_SUBSTITUTION
</code></a>, если есть проблема с механизмом, определенным в параметре
<code>ENGINE=</code> запроса <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a>.</p></li></ul>

<h3><a name="innodb-check-availability"></a>16.1.3. Проверка, что InnoDB
механизм хранения по умолчанию</h3>
<p>Чтобы проверить, что <code>InnoDB</code> механизм хранения по умолчанию,
используйте команду <a href="sql.htm#show-engines"><code>SHOW ENGINES</code>
</a>, чтобы рассмотреть различные механизмы хранения MySQL. Ищите
<code>DEFAULT</code> в строке <code>InnoDB</code>. Альтернативно, запросите
из <code>INFORMATION_SCHEMA</code> таблицу
<a href="inform.htm#engines-table"><code>ENGINES</code></a>.</p>

<h3><a name="innodb-benchmarking"></a>16.1.4.
Тестирование и сопоставительный анализ с InnoDB</h3>
<p>Если <code>InnoDB</code> не механизм хранения по умолчанию, Вы можете
определить, работают ли Ваш сервер базы данных или приложения правильно с
<code>InnoDB</code> перезапуская сервер с опцией
<a href="server.htm#sysvar_default_storage_engine"><code>
--default-storage-engine=InnoDB</code></a>, определенной в командной строке
или с <a href="server.htm#sysvar_default_storage_engine"><code>
default-storage-engine=innodb</code></a> в разделе <code>[mysqld]</code>
конфигурационного файла <code>my.cnf</code>.</p>

<p>Если Вы не принимали преднамеренное решение относительно механизма
хранения, и Вы только хотите посмотреть, как определенные таблицы работают,
когда они создаются под <code>InnoDB</code>, скомандуйте
<a href="sql.htm#alter-table"><code>ALTER TABLE table_name ENGINE=InnoDB;
</code></a> для каждой таблицы. Или, чтобы выполнить испытательные запросы,
не нарушая оригинальную таблицу, сделайте копию:
<pre>
CREATE TABLE InnoDB_Table (...) ENGINE=InnoDB AS SELECT * FROM MyISAM_Table;
</pre>

<p>Проверьте полный жизненный цикл приложения от установки, посредством
тяжелого использования и перезапуска сервера. Уничтожьте процесс сервера в то
время, как база данных занята, чтобы моделировать перебой в питании и
проверить, что данные восстановлены успешно, когда Вы перезапускаете сервер.
</p>

<p>Проверьте любые конфигурации репликации, особенно если Вы используете
различные версии MySQL и опции на ведущем устройстве и ведомых устройствах.
</p>

<h2><a name="mysql-acid"></a>16.2. InnoDB и модель ACID</h2>
<p>Модель <a href="glossary.htm#glos_acid">ACID</a> ряд принципов
проектирования баз данных, которые подчеркивают аспекты надежности, которые
важны для коммерческой информации и приложений критического назначения. MySQL
включает такие компоненты, как механизм хранения <code>InnoDB</code>, которые
придерживаются близко к ACID, чтобы данные не были повреждены и результаты
не искажены исключительными условиями, такими как катастрофические отказы
программного обеспечения и сбои аппаратных средств. Когда Вы полагаетесь на
ACID, Вы не должны повторно изобрести колесо проверки последовательности и
механизмы восстановления катастрофического отказа. В случаях, где у Вас есть
дополнительные гарантии программного обеспечения, ультранадежные аппаратные
средства или приложение, которое может терпеть небольшое количество потерь
данных, Вы можете скорректировать настройки MySQL, чтобы обменять часть
надежности ACID для большей работы или пропускной способности.</p>

<p>Следующие разделы обсуждают, как MySQL, в особенности механизм хранения
<code>InnoDB</code>, взаимодействует с категориями ACID:</p>
<ul><li><p><span><strong>A</strong></span>: атомность.</li>
<li><span><strong>C</strong></span>: последовательность.</li>
<li><span><strong>I:</strong></span>: изоляция.</li>
<li><span><strong>D</strong></span>: длительность.</p></li></ul>

<h3><a name="idm139965330807152"></a>Атомность</h3>
<p><span><strong>Атомность</strong></span> аспект ACID, главным образом,
вовлекает <code>InnoDB</code> <a href="glossary.htm#glos_transaction">
транзакции</a>. Связанные особенности MySQL включают:</p>

<ul><li><p>Autocommit.</li>
<li>Команду <a href="sql.htm#commit"><code>COMMIT</code></a>.</li>
<li>Команду <a href="sql.htm#commit"><code>ROLLBACK</code></a>.</li>
<li>Рабочие данные от таблиц <code>INFORMATION_SCHEMA</code>.</p></li></ul>

<h3><a name="idm139965330796992"></a>Последовательность</h3>
<p><span><strong>Последовательность</strong></span> аспект ACID, главным
образом, вовлекает внутреннюю обработку <code>InnoDB</code>, чтобы защитить
данные от катастрофических отказов. Связанные особенности MySQL включают:</p>

<ul><li><p><code>InnoDB</code>
<a href="glossary.htm#glos_doublewrite_buffer">буфер doublewrite</a>.</li>
<li><code>InnoDB</code><a href="glossary.htm#glos_crash_recovery">
восстановление катастрофического отказа</a>.</p></li></ul>

<h3><a name="idm139965330789376"></a>Изоляция</h3>
<p><span><strong>Изоляция</strong></span> аспект ACID, главным образом,
вовлекает <code>InnoDB</code> <a href="glossary.htm#glos_transaction">
транзакции</a>, в особенности <a href="glossary.htm#glos_isolation_level">
уровень изоляции</a>, который относится к каждой транзакции.
Связанные особенности MySQL включают:</p>

<ul><li><p><a href="glossary.htm#glos_autocommit">Autocommit</a>.</li>
<li>Команду <code>SET ISOLATION LEVEL</code>.</li>
<li>Низкоуровневые детали <code>InnoDB</code>
<a href="glossary.htm#glos_locking">блокировки</a>. Во время исполнительной
настройки Вы смотрите эти детали через таблицы <code>INFORMATION_SCHEMA
</code>.</p></li></ul>

<h3><a name="idm139965330778496"></a>Длительность</h3>
<p><span><strong>Длительность</strong></span> аспект ACID вовлекает
характеристики программного обеспечения MySQL, взаимодействующие с Вашей
особой конфигурацией аппаратных средств. Из-за многих возможностей в
зависимости от способностей Вашего центрального процессора, сети и устройств
хранения данных, этот аспект наиболее сложен, чтобы обеспечить конкретные
советы. Связанные особенности MySQL включают:</p>

<ul><li><p><code>InnoDB</code>
<a href="glossary.htm#glos_doublewrite_buffer">буфер doublewrite</a>,
управляемый параметром <a href="#sysvar_innodb_doublewrite"><code>
innodb_doublewrite</code></a>.</li>

<li>Опция <a href="#sysvar_innodb_flush_log_at_trx_commit"><code>
innodb_flush_log_at_trx_commit</code></a>.</li>
<li>Опция <a href="replica.htm#sysvar_sync_binlog"><code>sync_binlog</code>
</a>.</li>

<li>Опция <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>.</li>
<li>Буфер записи в устройстве хранения данных, таком как дисковод,
SSD или RAID.</li>

<li>Поддержанный батареей кэш в устройстве хранения данных.</li>
<li>Операционная система, под которой работает MySQL,
в особенности поддержка системного вызова <code>fsync()</code>.</li>

<li>Защита по питанию ко всем компьютерным серверам и устройствам хранения
данных, которые выполняют серверы MySQL и хранят данные MySQL.</li>
<li>Ваша стратегия резервирования, такая как частота и типы резервных копий.
</li>

<li>Для распределенных приложений особые характеристики информационных
центров, где аппаратные средства для серверов MySQL расположены, и сетевые
соединения между информационными центрами.</p></li></ul>

<h2><a name="innodb-multi-versioning"></a>16.3. Мультиверсии InnoDB</h2>
<p><code>InnoDB</code> <a href="glossary.htm#glos_mvcc">мультиверсионный
механизм хранения</a>: это хранит информацию о старых версиях измененных
строк, чтобы поддерживать транзакционные функции, такие как параллелизм и
<a href="glossary.htm#glos_rollback">отмену</a>.
Эта информация хранится в табличном пространстве в структуре данных,
названной <a href="glossary.htm#glos_rollback_segment">сегмент отмены</a>
(после аналогичной структуры данных в Oracle). <code>InnoDB</code>
использует информацию в сегменте отмены, чтобы выполнить операции отмены,
необходимые в работе. Это также использует информацию, чтобы создать более
ранние версии строки для <a href="glossary.htm#glos_consistent_read">
последовательного чтения</a>.</p>

<p>Внутренне <code>InnoDB</code> добавляют три поля к каждой строке,
сохраненной в базе данных. Поле 6-byte <code>DB_TRX_ID</code> указывает на
операционный идентификатор для последней транзакции, которая вставила или
обновила строку. Кроме того, удаление обработано внутренне как обновление,
где специальный бит в строке установлен, чтобы отметить ее как удаленную.
Каждая строка также содержит 7 байтов <code>DB_ROLL_PTR</code> указателя
пересчета. Он указывает на запись журнала отмены, записанную в сегмент
отмены. Если строка была обновлена, запись журнала отмены содержит
информацию, необходимую, чтобы восстановить контент строки прежде, чем это
было обновлено. 6 байтов <code>DB_ROW_ID</code> содержит ID строки,
который увеличивается монотонно, по мере вставки новых строк. Если
<code>InnoDB</code> производит кластеризируемый индекс автоматически,
индексирование содержит значения идентификаторов строки. Иначе столбец
<code>DB_ROW_ID</code> не появляется ни в каком индексе.</p>

<p>Отмена входит в систему, сегмент отмены разделен на журналы отмены
вставки и обновления. Журналы отмены вставки необходимы только в операционной
отмене и могут быть стерты, как только транзакция передана. Журналы отмены
обновления используются также в последовательных чтениях, но от них можно
отказаться только после того, как нет никакой транзакции, к которой
<code>InnoDB</code> назначил снимок, который в последовательном чтении мог
нуждаться в информации в журнале отмены обновления, чтобы создать более
раннюю версию строки базы данных.</p>

<p>Передавайте свои транзакции регулярно, включая те транзакции, которые
используют только последовательные чтения. Иначе <code>InnoDB</code>
не сможет отказаться от данных журналов отмены обновления, и сегмент отмены
может стать слишком большим, заполняя Ваше табличное пространство.</p>

<p>Физический размер записи журнала отмены в сегменте отмены как правило
меньше чем соответствующая вставленная или обновленная строка.
Вы можете использовать эту информацию, чтобы вычислить пространство,
необходимое для Вашего сегмента отмены.</p>

<p>В мультиверсионной схеме <code>InnoDB</code>
строка физически немедленно не удалена из базы данных, когда Вы удаляете это
запросом SQL. <code>InnoDB</code> физически удаляет соответствующую строку и
индексные записи только когда отказывается от записи журнала отмены
обновления, записанной для удаления. Эту работу удаления называют
<a href="glossary.htm#glos_purge">чисткой</a> и она довольно быстра, обычно
берет тот же самый порядок времени, как запрос SQL, который сделал удаление.
</p>

<p>Если Вы вставляете и удаляете строки в небольших пакетах на приблизительно
том же самом уровне в таблице, поток чистки может начать отставать, и таблица
может стать больше и больше из-за
<span><span>стертых</span></span> строк, делая работу с диском очень
медленной. В таком случае приостановите новые операции строк и выделите
больше ресурсов потоку чистки, настраивая переменную
<a href="#sysvar_innodb_max_purge_lag"><code>innodb_max_purge_lag
</code></a>. См. <a href="#innodb-parameters">раздел 16.13</a>.</p>

<h3><a name="innodb-multi-versioning-secondary-indexes"></a>
Мультиверсии и вторичный индекс</h3>
<p><code>InnoDB</code> multiversion concurrency control (MVCC)
обрабатывает вторичный индекс по-другому, чем кластеризируемый. Записи в
кластеризируемом индексе обновлены оперативнее, и их скрытые системные записи
журнала отмены указывают на столбцы, от которых могут быть восстановлены
более ранние версии записи. В отличие от кластеризируемого индекса,
записи вторичного индекса не содержат скрытые системные столбцы.</p>

<p>Когда столбец вторичного индекса обновлен, старые записи вторичного
индекса, отмеченные как удаленные, удаляются, новые вставлены и отмеченные
как удаленные в конечном счете очищены. Когда запись вторичного индекса
отмечена как удаленная или индексная страница обновлена более новой
транзакцией, <code>InnoDB</code> ищет запись базы данных в кластеризируемом
индексе. Там запись <code>DB_TRX_ID</code> проверена и правильная версия
получена от журнала отмены, если запись была изменена после того, как
транзакция чтения была начата.</p>

<p>Если запись вторичного индекса помечена для удаления или индексная
страница обновлена более новой транзакцией, метод
<a href="glossary.htm#glos_covering_index">индексного покрытия</a>
не используется. Вместо этого, чтобы возвратить значения из индекса структуры
<code>InnoDB</code> ищет запись в кластеризируемом индексе.</p>

<p>Однако, если оптимизация
<a href="optimiz.htm#index-condition-pushdown-optimization">index
condition pushdown (ICP)</a> разрешена, и часть выражения <code>WHERE</code>
может быть оценена, используя только поля индекса, сервер MySQL передает
эту часть <code>WHERE</code> механизму хранения, где это оценено, используя
индексирование. Если никакие записи соответствия не найдены, поиск по
кластеризируемому индексу не проводится. Если соответствие найдено, даже
среди отмеченных для удаления, <code>InnoDB</code> ищет
запись в кластеризируемом индексе.</p>

<h2><a name="innodb-concepts"></a>16.4. Архитектура InnoDB</h2>
<p>Этот раздел обеспечивает введение в главные компоненты архитектуры
механизма хранения <a href="innodb.htm"><code>InnoDB</code></a>.</p>

<h3><a name="innodb-buffer-pool-intro"></a>16.4.1. Буферный пул</h3>
<p>Буферный пул область в основной памяти, где <code>InnoDB</code> кэширует
таблицы и индексы, с которыми работает. Буферный пул позволяет часто
используемым данным быть обработанными непосредственно в памяти, что ускоряет
обработку. На специализированных серверах базы данных до 80% физической
памяти часто назначаются буфрному пулу <code>InnoDB</code>.</p>

<p>Для эффективности большого объема операций чтения буферный пул разделен на
<a href="glossary.htm#glos_page">страницы</a>, которые могут потенциально
содержать много строк. Для эффективности управления кэшем буферный пул
осуществлен как связанный список страниц, данные, которые редко используются,
удаляются из кэша, используя вариант алгоритма
<a href="glossary.htm#glos_lru">LRU</a>.</p>
<p>Подробности в <a href="#innodb-performance-buffer-pool">
разделе 16.6.3</a>.</p>

<h3><a name="innodb-insert-buffering"></a>16.4.2. Буфер изменения</h3>
<p>Буфер изменения специальная структура данных, которая кэширует изменения в
страницах <a href="glossary.htm#glos_secondary_index">вторичного индекса</a>,
когда затронутые страницы не находятся в
<a href="glossary.htm#glos_buffer_pool">буферному пуле</a>.
Буферизованные изменения, которые могут следовать из операций
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a> (DML), слиты позже, когда
страницы загружены в буферный пул другими операциями чтения.</p>

<p>В отличие от <a href="glossary.htm#glos_clustered_index">
кластеризируемого индекса</a>, вторичный индекс обычно групповой, и вставки
во вторичный индекс происходят в относительно случайном порядке. Точно так же
удаления и обновления могут затронуть вторичные индексные страницы, которые
рядом не расположены в индексном дереве. Слияние кэшируемых изменений идет в
более позднее время, когда затронутые страницы считаны в буферный пул другими
операциями, это позволяет избегать существенного ввода/вывода произвольного
доступа, который был бы обязан читать вторичные индексные страницы с диска.
</p>

<p>Периодически чистка, которая работает, когда система главным образом
неактивна, или во время медленного завершения работы, пишет обновленные
индексные страницы на диск. Работа чистки может записать дисковые блоки для
серии индексируемых значений более эффективно, чем если бы каждое значение
было немедленно написано на диск.</p>

<p>Буферное слияние изменения может занять несколько часов, когда есть много
вторичных индексов, чтобы обновить, и много затронутых строк. В это время
дисковый ввод/вывод увеличен, что может вызвать существенное замедление для
запросов к диску. Слияние буферных изменений может также продолжить
происходить после того, как транзакция передана. Фактически, слияние буферных
изменений может продолжить происходить после завершения работы сервера и
перезапуска (см. <a href="#forcing-innodb-recovery">раздел 16.20.2
</a>).</p>

<p>В памяти буфер изменения занимает часть буферного пула <code>InnoDB</code>.
На диске буфер изменения часть системного табличного пространства, так что
индексные изменения остаются буферизованными между перезапусками базы данных.
</p>

<p>Типом данных, кэшируемых в буфере изменения, управляет параметр
конфигурации <a href="#sysvar_innodb_change_buffering"><code>
innodb_change_buffering</code></a>. Плдробности в
<a href="#innodb-performance-change_buffering">разделе 16.6.4</a>.
Вы можете также сконфигурировать максимальный размер буфера изменения. Для
получения дополнительной информации см.
<a href="#innodb-change-buffer-maximum-size">раздел 16.6.4.1</a>.
</p>

<h4><a name="idm139965330693488"></a>Контроль буфера изменения</h4>
<p>Следующие опции доступны для контроля буфера изменения:</p>
<ul><li><p><code>InnoDB</code> Standard Monitor включает информацию о статусе
для буфера изменения. Чтобы смотреть данные монитора, скомандуйте
<code>SHOW ENGINE INNODB STATUS</code>.
<pre>
mysql&gt; SHOW ENGINE INNODB STATUS\G
</pre>

<p>Буферная информация о статусе изменения расположена под заголовком
<code>INSERT BUFFER AND ADAPTIVE HASH INDEX</code> и выглядит так:
<pre>
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
13577.57 hash searches/s, 202.47 non-hash searches/s
</pre>
<p>Подробности в <a href="#innodb-standard-monitor">разделе
16.16.3</a>.</li>

<li>Таблица <a href="inform.htm#innodb-metrics-table"><code>
INFORMATION_SCHEMA.INNODB_METRICS</code></a> обеспечивает большинство точек
данных, найденных в <code>InnoDB</code> Standard Monitor плюс другие точки
данных. Чтобы рассмотреть буферные метрики изменения и описание каждой,
дайте следующий запрос:
<pre>
mysql&gt; SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS
                 WHERE NAME LIKE '%ibuf%'\G
</pre>

<p>Подробности об использовании таблицы
<a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS</code></a>
см. в <a href="#innodb-information-schema-metrics-table">разделе
16.14.6</a>.</li>

<li>Таблица <a href="inform.htm#innodb-buffer-page-table"><code>
INFORMATION_SCHEMA.INNODB_BUFFER_PAGE</code></a>
обеспечивает метаданные о каждой странице в буферном пуле,
включая индекс буфера изменений и бит-карту страниц буфера изменений.
Буферные страницы изменения идентифицированы
<code>PAGE_TYPE</code>. <code>IBUF_INDEX</code> тип страницы для
буферных индексных страниц и <code>IBUF_BITMAP</code>
бит-карты страниц буфера изменений.</p>

<p>Запрос таблицы <a href="inform.htm#innodb-buffer-page-table"><code>
INNODB_BUFFER_PAGE</code></a> может потребовать существенной работы.
Чтобы избежать воздействовать на работу, воспроизведите проблему, которую Вы
хотите исследовать, и выполните Ваши запросы на испытательном экземпляре.</p>

<p>Например, Вы можете запросить таблицу
<a href="inform.htm#innodb-buffer-page-table"><code>INNODB_BUFFER_PAGE</code>
</a>, чтобы определить приблизительное количество страниц
<code>IBUF_INDEX</code> и <code>IBUF_BITMAP</code>
как процент полных буферных страниц пула.
<pre>
SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
        WHERE PAGE_TYPE LIKE 'IBUF%') AS change_buffer_pages,
        (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS
         total_pages,
        (SELECT ((change_buffer_pages/total_pages)*100)) AS
         change_buffer_page_percentage;
+---------------------+-------------+-------------------------------+
| change_buffer_pages | total_pages | change_buffer_page_percentage |
+---------------------+-------------+-------------------------------+
| 25                  | 8192        | 0.3052                        |
+---------------------+-------------+-------------------------------+
</pre>

<p>Для информации о других данных, обеспеченных таблицей
<a href="inform.htm#innodb-buffer-page-table"><code>INNODB_BUFFER_PAGE</code>
</a>, см. <a href="inform.htm#innodb-buffer-page-table">раздел 22.30.1</a>.
Для связанной информации об использовании см.
<a href="#innodb-information-schema-buffer-pool-tables">раздел
16.14.5</a>.</li>

<li><a href="perfor.htm">Performance Schema</a> предоставляет инструментовку
ожидания mutex для буфера изменений усовершенствованного исполнительного
контроля. Чтобы рассмотреть инструментовку буфера изменения,
примените следующий запрос:
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_instruments
                   WHERE NAME LIKE '%wait/synch/mutex/innodb/ibuf%';
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/ibuf_bitmap_mutex             | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_mutex                    | YES     | YES   |
| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex | YES     | YES   |
+-------------------------------------------------------+---------+-------+
</pre>

<p>Для информации о контроле ожиданий <code>InnoDB</code> mutex см.
<a href="#monitor-innodb-mutex-waits-performance-schema">раздел
16.15.2</a>.</p></li></ul>

<h3><a name="innodb-adaptive-hash"></a>16.4.3. Адаптивный хеш-индекс</h3>
<p><a href="glossary.htm#glos_adaptive_hash_index">Адаптивный хеш-индекс</a>
(AHI) позволяет <code>InnoDB</code> выступить больше как база данных в памяти
на системах с соответствующими комбинациями рабочей нагрузки и вполне
достаточной памяти для <a href="glossary.htm#glos_buffer_pool">буферного
пула</a>, не жертвуя никакими особенностями или надежностью. Эта опция
активирована опцией <a href="#sysvar_innodb_adaptive_hash_index">
<code>innodb_adaptive_hash_index</code></a> или выключена при старте сервера
параметром <code>--skip-innodb_adaptive_hash_index</code>.</p>

<p>Основанный на наблюдаемом образце поисков, MySQL создает хеш, индексиря
использование префикса ключа индекса. Префикс ключа может быть любой длины, и
может случиться так, что только некоторые из значений в B-дереве появляются в
хеш-индексе. Хеш-индекс создан по требованию для тех страниц индекса, к
которым часто получают доступ.</p>

<p>Если таблица почти полностью расположена в основной памяти, хеш-индекс
может ускорить запросы, включая прямой поиск любого элемента, разворачивая
значение в своего рода указатель. <code>InnoDB</code>
имеет механизм, который отслеживает поиски в индексе. Если
<code>InnoDB</code> находит, которые запросы могли получить пользу из
создания хеш-индекса, это делается автоматически.</p>

<p>С некоторыми <a href="glossary.htm#glos_workload">рабочими нагрузками</a>
ускорение от хеш-индекса очень перевешивает дополнительную работу, чтобы
контролировать индекные поиски и поддерживать структуру. Иногда блокировка
чтения-записи, которая контролирует доступ к адаптивному хешу
может стать источником проблем при тяжелых рабочих нагрузках, таких как
многократные параллельные соединения. Запросы с операторами
<code>LIKE</code> и подстановочными знаками <code>%</code>
также имеют тенденцию не извлекать выгоду из AHI. Для рабочих нагрузок, где
адаптивный хеш не нужен, выключение его уменьшает ненужную работу. Поскольку
трудно предсказать заранее, является ли эта особенность подходящей для особой
системы, считайте рабочие точки отсчета с включенным и отключенным хэшем,
используя реалистическую рабочую нагрузку. Архитектурные изменения в MySQL
5.6 и выше делают больше рабочих нагрузок подходящими для того, чтобы
запретить адаптивный хеш, чем в более ранних выпусках, хотя это все еще
включено по умолчанию.</p>

<p>Адаптивный хеш индекс разделен. Каждый индекс связан с определенным
разделением, и каждое разделение защищено отдельным замком. Разделением
управляет опция <a href="#sysvar_innodb_adaptive_hash_index_parts">
<code>innodb_adaptive_hash_index_parts</code></a>.
По умолчанию это 8. Максимум 512.</p>

<p>Хеш-индекс всегда создается основанный на существующем индексе
<a href="glossary.htm#glos_b_tree">B-tree</a> для таблицы.
<code>InnoDB</code> может создать хеш-индекс на префиксе любой длины ключа,
определенного для B-дерева, в зависимости от образца поисков, который
<code>InnoDB</code> наблюдает для индекса B-дерева. Хеш-индекс
может быть частичным, покрывая только те страницы индексирования, к которым
часто получают доступ.</p>

<p>Вы можете контролировать использование адаптивного хеш-индекса
и утверждение для его использования в разделе <code>SEMAPHORES</code>
вывода команды <a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS
</code></a>. Если Вы видите, что много потоков ждут на RW-замке, создаваемом
в <code>btr0sea.c</code>, тогда могло бы быть полезно отключить
адаптивную хеш-индексацию.</p>
<p>Подробности в <a href="optimiz.htm#index-btree-hash">разделе 9.3.8</a>.
</p>

<h3><a name="innodb-redo-log-buffer"></a>16.4.4. Буфер журнала Redo</h3>
<p>Буфер журнала Redo область памяти, которая хранит данные, которые записаны
в <a href="glossary.htm#glos_redo_log">журнал redo</a>. Размер буфера
журнала, определен опцией <a href="#sysvar_innodb_log_buffer_size">
<code>innodb_log_buffer_size</code></a>. Буфер журнала периодически
сбрасывается к файлу системного журнала на диске. Большой буфер
позволяет большим транзакциям работать без потребности записать
журнал на диск прежде, чем транзакции передадут. Таким образом, если у Вас
есть транзакции, которые обновляют, вставляют или удаляют много строк,
увеличение буфера экономит дисковый ввод/вывод.</p>

<p>Опция <a href="#sysvar_innodb_flush_log_at_trx_commit"><code>
innodb_flush_log_at_trx_commit</code></a> управляет, как содержание
буфера журнала записано в файл системного журнала. Опция
<a href="#sysvar_innodb_flush_log_at_timeout"><code>
innodb_flush_log_at_timeout</code></a> управляет тем, как часто
буфер сбрасывается на диск.</p>

<h3><a name="innodb-system-tablespace"></a>16.4.5.
Системное табличное пространство</h3>
<p>Системное табличное пространство <code>InnoDB</code> содержит
словарь данных (метаданные для объектов <code>InnoDB</code>),
область хранения для буфера doublewrite, буфер изменения
и журнал отмены. Системное табличное пространство также содержит таблицу и
индексные данные для любых создаваемых пользователем таблиц,
которые составлены в системном табличном пространстве. Системное табличное
пространство считают совместно используемым табличным пространством, так как
оно совместно использовано многими таблицами.</p>

<p>Системное табличное пространство представлено одним или более файлами с
данными. По умолчанию, один системный файл с данными, названный
<code>ibdata1</code>, создается в каталоге MySQL <code>data</code>.
Размером и числом системных файлов с данными управляет опция
<a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a>.</p>

<p>Подробности в разделах <a href="#innodb-init-startup-configuration">
16.6.1</a> и <a href="#innodb-resize-system-tablespace">16.7.1</a>.
</p>

<h3><a name="innodb-doublewrite-buffer"></a>16.4.6. Буфер Doublewrite</h3>
<p>Буфер doublewrite это область хранения, расположенная в системном
табличном пространстве, где <code>InnoDB</code> пишет страницы, которые
сбрасываются из буферного пула <code>InnoDB</code> прежде, чем страницы будут
записаны их надлежащим позициям в файле с данными. Только после сброса и
записи в буфер doublewrite, <code>InnoDB</code> запишет страницы на их
надлежащие позиции. Если есть катастрофический отказ операционной системы,
подсистемы хранения или процесса <a href="programs.htm#mysqld"><span><strong>
mysqld</strong></span></a> в середине записи страницы, <code>InnoDB</code>
может позже найти хорошую копию страницы в буфере doublewrite
во время восстановления катастрофического отказа.</p>

<p>Хотя данные всегда пишутся дважды, буфер doublewrite не требует вдвое
большего количества ввода/вывода или вдвое большего количества операций
ввода/вывода. Данные записаны в буфер doublewrite непосредственно как большой
последовательный кусок одним вызовом <code>fsync()</code>.</p>

<p>Буфер doublewrite включен по умолчанию в большинстве случаев. Чтобы
отключить буфер doublewrite, надо установить опцию
<a href="#sysvar_innodb_doublewrite"><code>innodb_doublewrite
</code></a> в 0.</p>

<p>Если системные файлы табличного пространства (<span><span>файлы ibdata
</span></span>) расположены на устройствах Fusion-io, которые поддерживают
атомную запись буфер doublewrite автоматически отключен, и атомная запись
Fusion-io используются для всех файлов с данными. Поскольку буферная
установка doublewrite глобальна, буферизация doublewrite также отключена для
файлов с данными, находящихся на не Fusion-io аппаратных средствах.
Эта функция поддерживается только на аппаратных средствах Fusion-io
и включена только для Fusion-io NVMFS в Linux.
Чтобы в полной мере воспользоваться этой особенностью рекомендуется установка
<a href="#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a> в <code>O_DIRECT</code>.</p>

<h3><a name="innodb-undo-logs"></a>16.4.7. Журнал отмены</h3>
<p>Журнал отмены (или сегмент отмены) является областью хранения, которая
хранит копии данных, измененных активными транзакциями. Если другая
транзакция должна видеть оригинальные данные (как часть последовательной
работы чтения), неизмененные данные получены от этой области хранения. По
умолчанию эта область физически часть системного табличного пространства.
Однако, журналы отмены могут также находиться в отдельных табличных
пространствах отмены.  Для получения дополнительной информации см. разделы
<a href="#innodb-undo-tablespace">16.7.7</a> и
<a href="#innodb-multi-versioning">16.3</a>.</p>

<p>InnoDB поддерживает 128 журналов отмены. Однако, 32 из 128 журналов отмены
зарезервированы для временных табличных транзакций. Каждой транзакции,
которая обновляет временную таблицу (исключая транзакции только для чтения)
назначают два журнала отмены, один просто отмены, второй с поддержкой redo.
Транзакции только для чтения получают один журнал отмены, поскольку
транзакциям только для чтения разрешают изменить только временные таблицы.
</p>

<p>Это оставляет 96 доступных журналов отмены, каждый из которых поддерживает
до 1023 параллельных изменяющих данные транзакций, для полного предела
приблизительно 96k параллельных изменяющих данные транзакций. 96K предела
предполагает, что транзакции не изменяют временные таблицы. Если все
изменяющие данные транзакции также изменяют временные таблицы, полный предел
составляет приблизительно 32k параллельных транзакций изменения данных.
Для получения дополнительной информации о журналах отмены, которые сохранены
для временных табличных транзакций, см.
<a href="#innodb-temporary-table-undo-logs">раздел 16.4.11.1</a>.
</p>

<p>Опция <a href="#sysvar_innodb_undo_logs">
<code>innodb_undo_logs</code></a> определяет число журналов
отмены, используемых <code>InnoDB</code>.</p>

<h3><a name="innodb-file-per-table-intro"></a>16.4.8.
Табличные пространства File-Per-Table</h3>
<p>Табличное пространство File-Per-Table однотабличное пространство, которое
создается в его собственном файле с данными, а не в системном табличном
пространстве. Таблицы составлены в табличных пространствах file-per-table,
когда включена опция <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>. Иначе таблицы <code>InnoDB</code>
составлены в системном табличном пространстве. Каждое табличное пространство
file-per-table представлено файлом данных <code>.ibd</code>,
который создается в каталоге базы данных по умолчанию.</p>

<p>Табличные пространства per-table допускают форматы строк
<code>DYNAMIC</code> и <code>COMPRESSED</code>, которые поддерживают функции,
такие как хранение вне страницы для данных переменной длины и табличное
сжатие. Для информации об этих особенностях и о других преимуществах
табличных пространств file-per-table см.
<a href="#innodb-multiple-tablespaces">раздел 16.7.4</a>.</p>

<h3><a name="innodb-general-tablespace-intro"></a>16.4.9.
Общие табличные пространства</h3>
<p>Совместно используемое <code>InnoDB</code> табличное пространство
создано с помощью <a href="sql.htm#create-tablespace"><code>CREATE TABLESPACE
</code></a>. Общие табличные пространства могут быть созданы за пределами
каталога данных MySQL, способны к хранению многих таблиц и поддерживают
таблицы всех форматов строк.</p>

<p>Таблицы добавлены к общему табличному пространству через
<a href="sql.htm#create-table"><code>CREATE TABLE
<em><code>tbl_name</code></em> ... TABLESPACE [=]
<em><code>tablespace_name</code></em></code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> TABLESPACE [=]
<em><code>tablespace_name</code></em></code></a>.</p>

<h3><a name="innodb-undo-tablespace-intro"></a>16.4.10.
Табличное пространство отмены</h3>
<p>Табличное пространство отмены состоит из одного или более файлов,
содержащих <span><strong>журнал отмены</strong></span>.
Табличное пространство отмены создается только когда журнал отмены отделен от
<span><strong>системного табличного пространства</strong></span>, используя
опции <a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> и
<a href="#sysvar_innodb_undo_directory"><code>innodb_undo_directory
</code></a>.</p>

<h3><a name="innodb-temporary-tablespace"></a>16.4.11.
Временное табличное пространство</h3>
<p>Временное табличное пространство это табличное пространство для несжатых
временных таблиц и связанных объектов. Параметр конфигурации
<a href="#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a> определяет относительный путь для
временного файла с данными табличного пространства. Если
<a href="#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a> не задан, в каталоге данных создается
единственный авторасширяемый файл с данными в 12 МБ и именем
<code>ibtmp1</code>. Временное табличное пространство обновлено при каждом
старте сервера и получает динамически произведенный ID пространства, который
помогает избежать конфликтов с существующими ID. Временное табличное
пространство не может находиться на сыром устройстве. Сервер не стартует,
если временное табличное пространство не может быть создано.</p>

<p>Временное табличное пространство удалено при нормальном завершении работы
или прерванной инициализации. Временное табличное пространство не удалено,
когда катастрофический отказ происходит. В этом случае администратор базы
данных может удалить временное табличное пространство вручную или
перезапустить сервер с той же самой конфигурацией, которая удаляет и
обновляет временное табличное пространство.</p>

<h4><a name="innodb-temporary-table-undo-logs"></a>16.4.11.1.
Временные табличные журналы отмены InnoDB</h4>
<p>Временные табличные журналы отмены используются для временных таблиц и
связанных объектов. Этот тип <a href="glossary.htm#glos_undo_log">журнала
отмены</a> не redo-журнал, поскольку временные таблицы не восстановлены во
время восстановления катастрофического отказа и не требуют такого журнала.
Временные табличные журналы отмены, однако, используются для отмены, в то
время как сервер работает. Этот специальный тип журнала позволяет обойтись
без redo-протоколов ввода/вывода для временных таблиц и связанных объектов.
Временные табличные журналы отмены находятся во временном табличном
пространстве. Значение по умолчанию: временный файл табличного пространства,
<code>ibtmp1</code>, расположенный в каталоге данных по умолчанию и всегда
обновляется при запуске сервера. Определяемое пользователем местоположение
для временного файла табличного пространства может быть определено,
устанавливая опцию конфигурации
<a href="#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a>.</p>

<p>32 <a href="glossary.htm#glos_rollback_segment">сегмента отмены</a>
отведены для временных табличных
<a href="glossary.htm#glos_undo_log">журналов отмены</a>
для транзакций, которые изменяют временные таблицы и связанные объекты, что
означает, что максимальное количество сегментов отмены, доступных для
изменяющих данные транзакций, которые производят отчеты отмены, 96.
С 96 доступными сегментами отмены предел параллельных изменяющих данные
транзакциях составляет 96K. Для получения дополнительной информации см.
разделы <a href="#innodb-multi-versioning">16.3</a> и
<a href="#innodb-restrictions">16.8.7</a>.</p>

<h3><a name="innodb-redo-log"></a>16.4.12. Журнал redo</h3>
<p>Журнал redo это основанная на диске структура данных, используемая во
время восстановления катастрофического отказа, чтобы исправить данные,
написанные неполными транзакциями. Во время нормального функционирования
журнал кодирует просьбы изменить табличные данные, которые следуют из
запросов SQL или вызовов низкого уровня API.
Модификации, которые не закончили обновлять файлы с данными перед неожиданным
завершением работы, переигрываются автоматически во время инициализации,
прежде, чем соединения будут приняты.
Для информации о роли журналов redo в восстановлении после катастрофического
отказа см. <a href="#innodb-recovery">раздел 16.17.1</a>.</p>

<p>По умолчанию журнал физически представлен на диске как ряд файлов,
названных <code>ib_logfile0</code> и <code>ib_logfile1</code>. MySQL
пишет файлы системного журнала круговым способом. Данные в журнале
закодированы с точки зрения затронутых записей,
эти данные все вместе упоминаются как redo.
Проход данных через журнал представлен постоянно увеличивающимся значением
<a href="glossary.htm#glos_lsn">LSN</a>.</p>

<p>Для соответствующей информации см.:</p>
<ul><li><p><a href="#innodb-init-startup-configuration">раздел
16.6.1</a></li>

<li><a href="optimiz.htm#optimizing-innodb-logging">раздел 9.5.4</a></li>
<li><a href="#innodb-data-log-reconfiguration">раздел 16.7.2</a>
</p></li></ul>

<h4><a name="innodb-performance-group_commit"></a>16.4.12.1.
Групповой Commit для сброса Redo-журнала</h4>
<p><code>InnoDB</code>, как <a href="glossary.htm#glos_acid">
ACID</a>-совместимый механизм базы данных, сбрасывает
<a href="glossary.htm#glos_redo_log">redo-журнал</a>
транзакций прежде, чем это будет передано. <code>InnoDB</code> использует
<a href="glossary.htm#glos_group_commit">групповой commit</a>, чтобы
сгруппировать много таких запросов вместе. Из-за этого
<code>InnoDB</code> делает одну запись в файл журнала, чтобы выполнить
действие для многих транзакций, которые идут приблизительно в то же самое
время, значительно улучшая пропускную способность.</p>

<p>Для получения дополнительной информации об исполнении
<code>COMMIT</code> и других действий с транзакциями см.
see <a href="optimiz.htm#optimizing-innodb-transaction-management">раздел
9.5.2</a>.</p>

<h2><a name="innodb-locking-transaction-model"></a>16.5.
Блокировка InnoDB и операционная модель</h2>
<p>Чтобы осуществить крупномасштабное или очень надежное приложение базы
данных или настроить работу MySQL, важно понять блокировку и
операционную модель <code>InnoDB</code>.</p>
<p>Этот раздел обсуждает несколько тем, связанных с блокировкой и
операционной моделью, с которой Вы должны быть знакомы.</p>

<ul><li><p><a href="#innodb-locking">раздел 16.5.1</a>
описывает типы блокировки, используемые <code>InnoDB</code>.</li>
<li><a href="#innodb-transaction-model">раздел 16.5.2</a>
описывает операционные уровни изоляции и стратегии блокировки.
Это также обсуждает использование
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>,
последовательные чтения без блокировки и блокирующие чтения.</li>

<li><a href="#innodb-locks-set">раздел 16.5.3</a>
обсуждает определенные типы блокировок
<code>InnoDB</code> для различных запросов.</li>

<li><a href="#innodb-next-key-locking">раздел 16.5.4</a>
описывает как <code>InnoDB</code> применяет блокировку следующего ключа,
чтобы избежать призрачных строк.</li>

<li><a href="#innodb-deadlocks">раздел 16.5.5</a>
обеспечивает пример тупика, обсуждает обнаружение тупика и обеспечивает
подсказки для уменьшения и обработки тупиков в <code>InnoDB</code>.
</p></li></ul>

<h3><a name="innodb-locking"></a>16.5.1. Блокировка InnoDB</h3>
<p>Этот раздел описывает типы блокировки, используемые <code>InnoDB</code>.
</p>
<ul><li><p><a href="#innodb-shared-exclusive-locks">
Совместно использованные и исключительные блокировки</a></li>

<li><a href="#innodb-intention-locks">Блокировки намерения</a></li>
<li><a href="#innodb-record-locks">Блокировки записи</a></li>
<li><a href="#innodb-gap-locks">Блокировки промежутка</a></li>

<li><a href="#innodb-next-key-locks">Блокировки следующего ключа
</a></li>
<li><a href="#innodb-insert-intention-locks">
Блокировки намерения вставки</a></li>
<li><a href="#innodb-auto-inc-locks">Блокировки AUTO-INC</a></li>
<li><a href="#innodb-predicate-locks">
Блокировки предиката для пространственного индекса</a></p></li></ul>

<h4><a name="innodb-shared-exclusive-locks"></a>
Совместно использованные и исключительные блокировки</h4>
<p><code>InnoDB</code> реализует стандартные блокировки уровня строки,
где есть два типа блокировок,
<a href="glossary.htm#glos_shared_lock">совместно использованные
(<em><code>S</code></em>)</a> и
<a href="glossary.htm#glos_exclusive_lock">исключительные
(<em><code>X</code></em>)</a>.</p>

<ul><li><p><a href="glossary.htm#glos_shared_lock">Совместно использованные
(<em><code>S</code></em>)</a> позволяют транзакции, которые держат
блокировку для чтения строки.</li>

<li><a href="glossary.htm#glos_exclusive_lock">Исключительные
(<em><code>X</code></em>)</a> позволяют транзакции, которые держат
блокировку для обновления или удаления строки.</p></li></ul>

<p>Если транзакция <code>T1</code> держит совместно используемую
(<em><code>S</code></em>) блокировку на строке <code>r</code>,
тогда запросы от некоторой отличной транзакции <code>T2</code>
для блокировки на строке <code>r</code> обработаны следующим образом:</p>

<ul><li><p>Запрос <code>T2</code> для <em><code>S</code></em> можно
немедленно предоставить. В результате оба запроса
<code>T1</code> и <code>T2</code> держат <em><code>S</code></em> на
<code>r</code>.</li>
<li>Запрос <code>T2</code> для <em><code>X</code></em>
нельзя немедленно предоставить.</p></li></ul>

<p>Если транзакция <code>T1</code> держит исключительную
(<em><code>X</code></em>) блокировку строки <code>r</code>,
запрос от некоторой отличной транзакции <code>T2</code>
для блокировки любого типа на <code>r</code> не может быть немедленно
предоставлен. Вместо этого транзакция <code>T2</code>
должна ждать, пока транзакция <code>T1</code> выпустит
блокировку на строке <code>r</code>.</p>

<h4><a name="innodb-intention-locks"></a>Блокировки намерения</h4>
<p><code>InnoDB</code> допускает <span><em>многократные блокировки степени
детализации</em></span>, которые разрешают сосуществование блокировок на
уровне строки и соединяет все таблицы. Чтобы сделать блокировку на многих
уровнях степени детализации дополнительные типы блокировок, названных
<a href="glossary.htm#glos_intention_lock">блокировками намерения</a>,
используются. Блокировки намерения это блокировки на уровне таблицы в
<code>InnoDB</code>, которые указывают, какого типа блокировки (совместно
используемые или исключительные) транзакция потребует позже для строки в той
таблице. Есть два типа блокировок намерения, используемых в
<code>InnoDB</code> (предположим, что транзакция <code>T</code> требует
блокировку обозначенного типа на таблице <code>t</code>):</p>

<ul><li><p><a href="glossary.htm#glos_intention_shared_lock">
Совместно использованное намерение</a> (<em><code>IS</code></em>): транзакция
<code>T</code> намеревается установить блокировку
<em><code>S</code></em> на отдельные строки в таблице <code>t</code>.</li>

<li><a href="glossary.htm#glos_intention_exclusive_lock">
Исключительное намерение</a> (<em><code>IX</code></em>): транзакция
<code>T</code> намеревается установить блокировку <em><code>X</code></em>
на какие-то строки.</p></li></ul>

<p>Например, <a href="sql.htm#select"><code>SELECT ... LOCK IN SHARE MODE
</code></a> поставит <em><code>IS</code></em>, а <a href="sql.htm#select">
<code>SELECT ... FOR UPDATE</code></a> поставит <em><code>IX</code></em>.</p>

<p>Протокол блокировки намерения:</p>
<ul><li><p>Прежде, чем транзакция может приобрести
<em><code>S</code></em> на строку в таблице <code>t</code>,
это должно сначала приобрести <em><code>IS</code></em>
или более сильную блокировку на <code>t</code>.</li>

<li>Прежде, чем транзакция может приобрести <em><code>X</code></em>
на строку, это должно сначала приобрести <em><code>IX</code></em> на
<code>t</code>.</p></li></ul>

<p>Эти правила могут быть удобно получены в итоге посредством следующей
<span><em>матрицы совместимости типа блокировки</em></span>.</p>
<table border="1">
<thead><tr><th> </th><th><em><code>X</code></em></th>
<th><em><code>IX</code></em></th><th><em><code>S</code></em></th>
<th><em><code>IS</code></em></th></tr></thead>
<tbody><tr><td><em><code>X</code></em></td><td>Конфликтуют</td>
<td>Конфликтуют</td><td>Конфликтуют</td><td>Конфликтуют</td></tr>
<tr><td><em><code>IX</code></em></td><td>Конфликтуют</td><td>Совместимы</td>
<td>Конфликтуют</td><td>Совместимы</td></tr>
<tr><td><em><code>S</code></em></td><td>Конфликтуют</td><td>Конфликтуют</td>
<td>Совместимы</td><td>Совместимы</td></tr>
<tr><td><em><code>IS</code></em></td><td>Конфликтуют</td><td>Совместимы</td>
<td>Совместимы</td><td>Совместимы</td></tr></tbody></table>

<p>Блокировку предоставляют транзакции требования, если это совместимо с
существующими блокировками, но не предоставляют, если это находится в
противоречии с существующими блокировками. Тогда транзакция ждет, пока
противоречивая существующая блокировка не будет выпущена. Если запрос
блокировки находится в противоречии с существующей блокировкой и не может
быть предоставлен, потому что он вызвал бы
<a href="glossary.htm#glos_deadlock">тупик</a>, происходит ошибка.</p>

<p>Таким образом, блокировки намерения не блокируют ничего кроме полных
табличных запросов (например, <code>LOCK TABLES ... WRITE</code>). Основная
цель <em><code>IX</code></em> и <em><code>IS</code></em> показать, что кто-то
блокирует строку или собирается заблокировать строку в таблице.</p>

<h4><a name="innodb-record-locks"></a>Блокировка записей</h4>
<p>Блокировка записей это блокировка на индексной записи. Например,
<code>SELECT c1 FOR UPDATE FROM t WHERE c1 = 10;</code>
препятствует тому, чтобы любая другая транзакция вставила, обновила или
удалила строки, где значение <code>t.c1</code> = <code>10</code>.</p>

<p>Такие блокировки всегда блокируют индексные записи, даже если таблица
определена без индекса. Для таких случаев <code>InnoDB</code>
создает кластеризируемый скрытый индекс и использует его. См.
<a href="#innodb-index-types">раздел 16.8.8</a>.</p>

<h4><a name="innodb-gap-locks"></a>Блокировки промежутка</h4>
<p>Блокировки промежутка это блокировка на промежутке между индексными
записями или блокировка на промежутке перед первой или после последней
индексной записью. Например, <code>SELECT c1 FOR UPDATE FROM t WHERE c1
BETWEEN 10 and 20;</code> препятствует тому, чтобы другие транзакции вставили
значение <code>15</code> в столбец <code>t.c1</code> независимо от того,
было ли уже какое-либо такое значение в столбце, потому что промежутки между
всеми существующими значениями в диапазоне заблокированы.</p>

<p>Промежуток может охватить одно значение, несколько значений
или даже быть пустым.</p>
<p>Блокировки промежутка это часть компромисса между производительностью и
параллелизмом и используются в некоторых операционных уровнях изоляции.</p>

<p>Блокировка промежутка не необходима для запросов, которые блокируют
строки, используя уникальный индекс, чтобы искать уникальную строку. Это не
включает случай, что условие поиска включает только некоторые столбцы
уникального многостолбцового индекса, в этом случае блокировка промежутка
действительно происходит. Например, если столбец <code>id</code> имеет
уникальный индекс, следующий запрос использует только блокировку записи
индекса для строки с <code>id</code> 100, и не имеет значения, вставляют ли
другие сеансы строки в предыдущий промежуток:
<pre>
SELECT * FROM child WHERE id = 100;
</pre>
<p>Если <code>id</code> не индексирован или имеет неуникальный индекс, запрос
действительно блокирует предыдущий промежуток.</p>

<p>Также стоит отметить здесь, что противоречивые блокировки могут быть
проведены на промежутке различными транзакциями. Например, транзакция A может
держать совместно используемую блокировку промежутка (S-блокировка
промежутка) на промежутке, в то время как транзакция B держит исключительную
блокировку промежутка (X-блокировка промежутка) на том же самом промежутке.
Причина, по которой позволены противоречивые блокировки промежутка, состоит в
том, что если запись очищена из индекса, блокировки промежутка для записи,
которые держат разные транзакции, должны быть слиты.</p>

<p>Блокировки промежутка в <code>InnoDB</code>
только мешают другим транзакциям вставить в промежуток. Они не препятствуют
тому, чтобы различные транзакции работали с ним как-то иначе. Таким образом,
X-блокировка промежутка имеет тот же самый эффект как S-блокировка.</p>

<p>Блокировка промежутка может быть отключена явно. Это происходит, если Вы
изменяете операционный уровень изоляции на
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>.
При этих обстоятельствах блокировка промежутка отключена для поисков и
сканирований индексов и используется только для проверки ограничения внешнего
ключа и дублирования ключей.</p>

<p>Есть также другие эффекты использования уровня изоляции
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>.
Блокировки записи для того, чтобы несоответствующие строки были
выпущены после того, как MySQL оценил <code>WHERE</code>. Для
<code>UPDATE</code> <code>InnoDB</code> делает такое чтение, что это
возвращает последнюю переданную версию в MySQL так, чтобы MySQL мог
определить, соответствует ли строка <code>WHERE</code> выражению в
<a href="sql.htm#update"><code>UPDATE</code></a>.</p>

<h4><a name="innodb-next-key-locks"></a>Блокировки следующего ключа</h4>
<p>Это комбинация блокировки записи на записи индекса и блокировки промежутка
перед этой записью.</p>

<p><code>InnoDB</code> выполняет блокировку на уровне строки таким способом,
что когда это ищет или просматривает индекс таблицы, то устанавливает
совместно использованные или исключительные блокировки на индексных записях.
Таким образом, блокировки на уровне строки фактически блокировки индекса.
Блокировка следующего ключа также затрагивает
<span><span>промежуток</span></span> перед этой записью.
Если у одного сеанса есть совместно используемая или исключительная
блокировка на записи <code>R</code> в индексе, другой сеанс не может вставить
новую индексную запись в промежутке сразу
перед <code>R</code> в порядке индекса.</p>

<p>Предположите, что индекс содержит значения 10, 11, 13 и 20.
Возможные блокировки для этого индекса покрывают следующие интервалы, где
круглая скобка обозначает исключение конечной точки интервала, а квадратная
скобка обозначает включение конечной точки:
<pre>
(минус бесконечность, 10]
(10, 11]
(11, 13]
(13, 20]
(20, бесконечность)
</pre>

<p>Для последнего интервала это блокирует промежуток выше самого большого
значения в индексе и виртуальную запись, имеющую значение выше, чем любое
значение фактически в индексе. Такой записи на самом деле нет, таким образом,
в действительности, это блокировка только промежутка после самого
большого значения индекса.</p>

<p>По умолчанию <code>InnoDB</code> работает на уровне изоляции
<a href="#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a>. В этом случае <code>InnoDB</code> использует такую блокировку
для поисков и индексных просмотров, что предотвращает появление призрачных
строк (см. <a href="#innodb-next-key-locking">раздел 16.5.4</a>).
</p>

<h4><a name="innodb-insert-intention-locks"></a>Блокировки намерения вставки
</h4>
<p>Блокировки намерения вставки это тип блокировки промежутка, установленной
операцией <a href="sql.htm#insert"><code>INSERT</code></a> до вставки строки.
Эта блокировка сигнализирует намерение вставить таким способом, что
многие транзакции, вставляющие в то же самый промежуток, не должны ждать друг
друга, если они не вставляют в ту же самую позицию в пределах промежутка.
Предположите, что есть индексные записи со значениями 4 и 7. Отдельные
транзакции, которые пытаются вставить значения 5 и 6, соответственно, каждая
блокировка промежуток между 4 и 7 с блокировками намерения вставки до
получения исключительной блокировки на вставленной строке, но не блокируют
друг друга, потому что строки не находятся в противоречии.</p>

<p>Следующий пример демонстрирует транзакцию, берущую блокировку намерения
вставки до получения исключительной блокировки на вставленной записи.
Пример вовлекает двух клиентов A и B.</p>

<p>Клиент А составляет таблицу, содержащую две записи в индексе (90 и 102) и
затем запускает транзакцию, которая помещает исключительную блокировку на
записи индекса с ID больше 100.
Исключительная блокировка включает блокировку промежутка перед записью 102:
<pre>
mysql&gt; CREATE TABLE child (id int(11) NOT NULL, PRIMARY KEY(id))
                 ENGINE=InnoDB;
mysql&gt; INSERT INTO child (id) values (90),(102);
mysql&gt; START TRANSACTION;
mysql&gt; SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
+-----+
| id  |
+-----+
| 102 |
+-----+
</pre>

<p>Клиент B начинает транзакцию, чтобы вставить отчет в промежуток.
Транзакция берет блокировку намерения вставки, в то время как она ждет, чтобы
получить исключительную блокировку.
<pre>
mysql&gt; START TRANSACTION;
mysql&gt; INSERT INTO child (id) VALUES (101);
</pre>

<p>Чтобы рассмотреть данные о блокировке намерения вставки, выполните
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.
Данные, подобные следующим, появляются под заголовком
<code>TRANSACTIONS</code>:
<pre>
mysql&gt; SHOW ENGINE INNODB STATUS\G
...
SHOW ENGINE INNODB STATUS
---TRANSACTION 8731, ACTIVE 7 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s)
MySQL thread id 3, OS thread handle 0x7f996beac700, query id 30 localhost root update
INSERT INTO child (id) VALUES (101)
------- TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 31 page no 3 n bits 72 index `PRIMARY` of table `test`.`child`
trx id 8731 lock_mode X locks gap before rec <span><strong>insert intention</strong></span> waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000066; ascf;;
 1: len 6; hex 000000002215; asc " ;;
 2: len 7; hex 9000000172011c; asc r  ;;...
</pre>

<h4><a name="innodb-auto-inc-locks"></a>Блокировка AUTO-INC</h4>
<p>Блокировка <code>AUTO-INC</code> это специальная блокировка на уровне
таблицы, взятая транзакциями, вставляющими в таблицы со столбцами
<code>AUTO_INCREMENT</code>. В самом простом случае, если
одна транзакция вставляет значения в таблицу, любые другие транзакции должны
ждать, чтобы сделать их собственные вставки в эту таблицу так, чтобы строки,
вставленные первой транзакцией, получили последовательные
значения первичного ключа.</p>

<p>Параметр конфигурации <a href="#sysvar_innodb_autoinc_lock_mode">
<code>innodb_autoinc_lock_mode</code></a> управляет алгоритмом, используемым
для блокировки автоинкремента. Это позволяет Вам выбирать, как балансировать
между предсказуемыми последовательностями значений автоинкремента и
максимальным параллелизмом для операций вставки.</p>
<p>Подробности в <a href="#innodb-auto-increment-handling">разделе
16.8.5</a>.</p>

<h4><a name="innodb-predicate-locks"></a>
Блокировка предиката для пространственного индекса</h4>
<p><code>InnoDB</code> поддерживает индексацию столбцов с пространственными
данными (см. <a href="types.htm#optimizing-spatial-analysis">раздел 12.5.3.5
</a>).</p>

<p>Чтобы обработать блокировку для вовлечения операций с индексами
<code>SPATIAL</code>, блокировка следующего ключа не работает хорошо, чтобы
поддержать уровни изоляции <a href="#isolevel_repeatable-read">
<code>REPEATABLE READ</code></a> или
<a href="#isolevel_serializable"><code>SERIALIZABLE</code></a>.
В многомерных данных нет никакого абсолютного понятия упорядочивания, таким
образом, не ясно, что является <span><span>следующим</span></span> ключом.
</p>

<p>Чтобы обеспечить поддержку уровней изоляции для таблиц с индексами
<code>SPATIAL</code>, <code>InnoDB</code> применяет блокировки предиката.
Индекс <code>SPATIAL</code> содержит минимальный ограничительный
прямоугольник (MBR) значения, таким образом, <code>InnoDB</code>
проводит в жизнь последовательное чтение на индексе, устанавливая предикат,
на значении MBR, используемом для запроса. Другие транзакции не могут
вставить или изменить строку, которая соответствовала бы условию запроса.</p>

<h3><a name="innodb-transaction-model"></a>16.5.2. Транзакционная модель
InnoDB</h3>
<p>В транзакционной модели <code>InnoDB</code>
цель состоит в том, чтобы объединить лучшие свойства
<a href="glossary.htm#glos_mvcc">мультиверсионной</a> базы данных с
традиционной двухфазовой блокировкой. <code>InnoDB</code>
выполняет блокировку на уровне строки и выполняет запросы как
<a href="glossary.htm#glos_consistent_read">последовательные чтения</a>
без блокировки по умолчанию в стиле Oracle. Информация о блокировке в
<code>InnoDB</code> сохранена пространственно-эффективно так, чтобы
эскалация блокировки не была необходима. Как правило, нескольким
пользователям разрешают блокировать каждую строку таблицы
<code>InnoDB</code> или любое случайное подмножество строк
без истощения памяти <code>InnoDB</code>.</p>

<h4><a name="innodb-transaction-isolation-levels"></a>16.5.2.1.
Операционные уровни изоляции</h4>
<p>Операционная изоляция это одна из основ обработки базы данных. Изоляция
это I в <a href="glossary.htm#glos_acid">ACID</a>,
уровень изоляции это установка, которая точно настраивает баланс между
работой и надежностью, последовательностью и воспроизводимостью результатов,
когда многократные транзакции производят изменения и выполняют запросы в то
же самое время.</p>

<p><code>InnoDB</code> реализует все четыре операционных уровня изоляции,
которые описаны стандартом SQL:1992:
<a href="#isolevel_read-uncommitted"><code>READ UNCOMMITTED</code>
</a>, <a href="#isolevel_read-committed"><code>READ COMMITTED
</code></a>, <a href="#isolevel_repeatable-read"><code>REPEATABLE
READ</code></a> и <a href="#isolevel_serializable"><code>
SERIALIZABLE</code></a>. По умолчанию используется
<a href="#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a>.</p>

<p>Пользователь может изменить уровень изоляции для единственного сеанса или
для всех последующих соединений командой
<a href="sql.htm#set-transaction"><code>SET TRANSACTION</code></a>.
Чтобы установить уровень изоляции по умолчанию сервера для всех соединений,
используйте параметр <a href="server.htm#option_mysqld_transaction-isolation">
<code>--transaction-isolation</code></a>. Для получения дальнейшей информации
об уровнях изоляции и устанавливающем уровень синтаксисе см.
<a href="sql.htm#set-transaction">раздел 14.3.6</a>.</p>

<p><code>InnoDB</code> реализует каждый из операционных уровней изоляции,
описанных здесь, используя различные стратегии
<a href="glossary.htm#glos_locking">блокировки</a>. Вы можете провести в
жизнь высокую степень последовательности с уровнем по умолчанию
<a href="#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a>, для операций на решающих данных, где совместимость с
<a href="glossary.htm#glos_acid">ACID</a> принципиальна.
Или Вы можете расслабить правила последовательности с
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>
или <a href="#isolevel_read-uncommitted"><code>READ UNCOMMITTED
</code></a> в ситуациях, где точная последовательность и повторимые
результаты менее важны, чем уменьшение количества издержек блокировки.
<a href="#isolevel_serializable"><code>SERIALIZABLE</code></a>
проводит в жизнь еще более строгие правила, чем
<a href="#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a>, и используется, главным образом, в специализированных ситуациях, таких
как транзакции <a href="glossary.htm#glos_xa">XA</a> и для того, чтобы
расследовать проблемы с параллелизмом и
<a href="glossary.htm#glos_deadlock">тупиками</a>.</p>

<p>Следующий список описывает, как MySQL поддерживает различные операционные
уровни. Список идет от обычно используемого уровня до наименее используемого.
</p>
<ul><li><p><a name="isolevel_repeatable-read"></a><code>REPEATABLE READ
</code></p>
<p>Это уровень изоляции значения по умолчанию для <code>InnoDB</code>. Для
<a href="glossary.htm#glos_consistent_read">последовательных чтений</a>
есть важное отличие от <a href="#isolevel_read-committed"><code>
READ COMMITTED</code></a>: все последовательные чтения в пределах той же
самой транзакции читают снимок, установленный первым чтением. Это соглашение
означает это, если Вы выпускаете несколько простых (без блокировки) запросов
<a href="sql.htm#select"><code>SELECT</code></a> в пределах той же самой
транзакции, то эти <a href="sql.htm#select"><code>SELECT</code></a>
последовательны также друг относительно друга. См.
<a href="#innodb-consistent-read">раздел 16.5.2.3</a>.</p>

<p>Чтобы <a href="glossary.htm#glos_locking_read">заблокировать чтения</a>
(<a href="sql.htm#select"><code>SELECT</code></a> с <code>FOR UPDATE</code>
или <code>LOCK IN SHARE MODE</code>), <a href="sql.htm#update"><code>UPDATE
</code></a> и <a href="sql.htm#delete"><code>DELETE</code></a>,
блокировка зависит от того, использует ли запрос уникальный индекс с
уникальным условием поиска или условием поиска типа диапазона.
Если уникальный индекс с уникальным условием поиска, <code>InnoDB</code>
блокирует только найденные индексные записи, но не
<a href="glossary.htm#glos_gap">промежуток</a> перед этим. Для других
условий поиска <code>InnoDB</code> блокирует индексный диапазон, используя
<a href="glossary.htm#glos_gap_lock">блокировки промежутка</a> или
<a href="glossary.htm#glos_next_key_lock">блокировки следующего ключа</a>,
чтобы заблокировать вставки другими сеансами в
промежутки, покрытые диапазоном.</li>

<li><a name="isolevel_read-committed"></a><code>READ COMMITTED</code></p>
<p>Несколько подобный Oracle уровень изоляции относительно последовательных
чтений (без блокировки): каждое
<a href="glossary.htm#glos_consistent_read">последовательное чтение</a>,
даже в пределах той же самой транзакции, устанавливает и читает свой
собственный новый <a href="glossary.htm#glos_snapshot">снимок</a>. См.
<a href="#innodb-consistent-read">раздел 16.5.2.3</a>.</p>

<p>Для того, чтобы <a href="glossary.htm#glos_locking_read">заблокировать
чтения</a> (<a href="sql.htm#select"><code>SELECT</code></a> с <code>FOR
UPDATE</code> или <code>LOCK IN SHARE MODE</code>),
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>, <code>InnoDB</code>
блокирует только индексные записи, но не <a href="glossary.htm#glos_gap">
промежутки</a> перед ними, и таким образом разрешает свободную вставку новых
записей рядом с заблокированными.</p>

<p>В MySQL 8.0 при использовании <code>READ COMMITTED</code>
не применяется блокировка промежутка за исключением проверки ограничения
внешнего ключа и дубликата ключа. Кроме того, блокировки записи используются
для того, чтобы несоответствовующие строки были выпущены после того, как
MySQL оценил <code>WHERE</code>.</p>

<p>Если Вы используете <code>READ COMMITTED</code>, Вы
<span><em>должны</em></span> использовать основанное на
строке двоичное журналирование.</p></li>

<li><p><a name="isolevel_read-uncommitted"></a><code>READ UNCOMMITTED</code>
</p>
<p>Запросы <a href="sql.htm#select"><code>SELECT</code></a>
выполнены способом без блокировки, но возможная более ранняя версия строки
могла бы использоваться. Таким образом, используя этот уровень изоляции,
такие чтения не последовательны. Это также называют
<a href="glossary.htm#glos_dirty_read">грязным чтением</a>. Иначе этот
уровень изоляции работает как <a href="#isolevel_read-committed">
<code>READ COMMITTED</code></a>.</li>

<li><a name="isolevel_serializable"></a><code>SERIALIZABLE</code></p>
<p>Похоже на <a href="#isolevel_repeatable-read"><code>REPEATABLE
READ</code></a>, но <code>InnoDB</code> неявно конвертируется все простые
<a href="sql.htm#select"><code>SELECT</code></a> в
<a href="sql.htm#select"><code>SELECT ... LOCK IN SHARE MODE</code></a>,
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a> выключен.
Если же <a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>
включен, <a href="sql.htm#select"><code>SELECT</code></a> выполняется в
собственной транзакции. Это только для чтения и может быть преобразовано в
последовательную форму, если выполнено как последовательное чтение (без
блокировки) и не должно заблокировать другие транзакции. Чтобы простой
<a href="sql.htm#select"><code>SELECT</code></a> заблокировать, если другие
транзакции изменили выбранные строки, отключите
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>.
</p></li></ul>

<h4><a name="innodb-autocommit-commit-rollback"></a>16.5.2.2.
autocommit, Commit и Rollback</h4>
<p>В <code>InnoDB</code> вся пользовательская деятельность происходит в
транзакции. Если режим <a href="server.htm#sysvar_autocommit"><code>
autocommit</code></a> включен, каждый запрос SQL формирует единственную
транзакцию самостоятельно. По умолчанию MySQL запускает сеанс для каждого
нового соединения с включенным <a href="server.htm#sysvar_autocommit"><code>
autocommit</code></a>, таким образом, MySQL делает передачу после каждого
запроса SQL, если запрос не возвращал ошибку. См.
<a href="#innodb-error-handling">раздел 16.20.4</a>.</p>

<p>Сеанс, который имеет включенную опцию
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>,
может выполнить транзакцию из многих запросов, запуская это с явной
командой <a href="sql.htm#commit"><code>START TRANSACTION</code></a> или
<a href="sql.htm#commit"><code>BEGIN</code></a> и завершая
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>. См.
<a href="sql.htm#commit">раздел 14.3.1</a>.</p>

<p>Если <a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>
выключен в пределах сеанса с помощью <code>SET autocommit = 0</code>,
у сеанса всегда есть открытая транзакция.
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>
заканчивает текущую транзакцию, и новая запускается.</p>

<p>Если сеанс, который имеет выключенный
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>
завершается, явно не передавая заключительную транзакцию, MySQL отменяет эту
транзакцию до прежнего состояния.</p>

<p>Некоторые запросы неявно заканчивают транзакцию, как будто Вы сделали
a <a href="sql.htm#commit"><code>COMMIT</code></a>. См.
<a href="sql.htm#implicit-commit">раздел 14.3.3</a>.</p>

<p><a href="sql.htm#commit"><code>COMMIT</code></a> означает, что изменения,
сделанные в текущей транзакции, делаются постоянными и становятся видимыми
другим сеансам. <a href="sql.htm#commit"><code>ROLLBACK</code></a>
отменяет все модификации, сделанные текущей транзакцией.
<a href="sql.htm#commit"><code>COMMIT</code></a> и
<a href="sql.htm#commit"><code>ROLLBACK</code></a> снимают все
блокировки, которые были установлены во время текущей транзакции.</p>

<h5><a name="innodb-transactions-with-different-apis"></a>
Группировка операций DML с транзакциями</h5>
<p>По умолчанию соединение с сервером MySQL начинается с включенным режимом
<a href="glossary.htm#glos_autocommit">autocommit</a>, который автоматически
передает каждый запрос SQL, когда Вы выполняете это. Этот режим работы мог бы
быть незнакомым, если у Вас есть опыт работы с другими системами базы данных,
где общепринятой практикой является последовательность запросов
<a href="glossary.htm#glos_dml">DML</a> и передача или отмена
их все вместе.</p>

<p>Чтобы использовать <a href="glossary.htm#glos_transaction">транзакцию</a>
из многих запросов, выключите режим командой <code>SET autocommit = 0</code>
и заканчивайте каждую транзакцию командой
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.
Чтобы это сделать при включенном autocommit, начинайте каждую транзакцию с
<a href="sql.htm#commit"><code>START TRANSACTION</code></a> и заканчивайте
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>. Следующий пример
показывает две транзакции. Первая передана, вторая отменена.
<pre>
shell&gt; mysql test
mysql&gt; CREATE TABLE customer (a INT, b CHAR (20), INDEX (a));
Query OK, 0 rows affected (0.00 sec)
mysql&gt; -- Do a transaction with autocommit turned on.
mysql&gt; START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; INSERT INTO customer VALUES (10, 'Heikki');
Query OK, 1 row affected (0.00 sec)
mysql&gt; COMMIT;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; -- Do another transaction with autocommit turned off.
mysql&gt; SET autocommit=0;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; INSERT INTO customer VALUES (15, 'John');
Query OK, 1 row affected (0.00 sec)
mysql&gt; INSERT INTO customer VALUES (20, 'Paul');
Query OK, 1 row affected (0.00 sec)
mysql&gt; DELETE FROM customer WHERE b = 'Heikki';
Query OK, 1 row affected (0.00 sec)
mysql&gt; -- Now we undo those last 2 inserts and the delete.
mysql&gt; ROLLBACK;
Query OK, 0 rows affected (0.00 sec)
mysql&gt; SELECT * FROM customer;
+----+--------+
| a  | b      |
+----+--------+
| 10 | Heikki |
+----+--------+
1 row in set (0.00 sec)
mysql&gt;
</pre>

<h6><a name="idm139965330152016"></a>Транзакции на клиентских языках</h6>
<p>В таких API, как PHP, Perl DBI, JDBC, ODBC или обычный интерфейс C
Вы можете послать команду управления транзакцией серверу
как строку точно так же, как любые другие запросы SQL, такие как
<a href="sql.htm#select"><code>SELECT</code></a> или
<a href="sql.htm#insert"><code>INSERT</code></a>. Некоторые API
также предлагает отдельные специальные функции или методы.</p>

<h4><a name="innodb-consistent-read"></a>16.5.2.3.
Последовательные чтения без блокировки</h4>
<p><a href="glossary.htm#glos_consistent_read">Последовательное чтение</a>
означает, что <code>InnoDB</code> использует мультиверсии, чтобы представить
запросу снимок базы данных в момент времени. Запрос видит изменения,
произведенные транзакциями, которые передали перед тем моментом времени, но
никаких изменений, произведенных позже или нейтральными транзакциями.
Исключение: запрос видит изменения, произведенные более ранними запросами в
пределах той же самой транзакции. Это исключение вызывает следующую аномалию:
если Вы обновляете некоторые строки в таблице,
<a href="sql.htm#select"><code>SELECT</code></a>
видит последнюю версию обновленных строк, но мог бы также видеть более старые
версии любых строк. Если другие сеансы одновременно обновляют ту же самую
таблицу, аномалия означает, что Вы могли бы видеть таблицу в статусе, который
никогда не существовал в базе данных.</p>

<p>Если операционный <a href="glossary.htm#glos_isolation_level">уровень
изоляции</a> <a href="#isolevel_repeatable-read"><code>REPEATABLE
READ</code></a> (по умолчанию), все последовательные чтения в пределах той же
самой транзакции читают снимок, установленный первым таким чтением в этой
транзакции. Вы можете получить более новый снимок для своих запросов,
передавая текущую транзакцию и выдавая новые запросы.</p>

<p>На уровне <a href="#isolevel_read-committed"><code>READ
COMMITTED</code></a> каждое последовательное чтение в пределах транзакции
устанавливает и читает свой собственный новый снимок.</p>

<p>Последовательное чтение это режим по умолчанию, в котором
<code>InnoDB</code> обрабатывает запросы
<a href="sql.htm#select"><code>SELECT</code></a> на уровнях
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>
и <a href="#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a>. Последовательное чтение не устанавливает блокировок на
таблицы, к которым оно получает доступ, и поэтому другие сеансы свободны
изменить те таблицы в то же самое время, когда последовательное чтение
выполняется на таблице.</p>

<p>Предположите, что Вы работаете на уровне
<a href="#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a>. Когда Вы выпускаете последовательное чтение (то есть, одиночный
<a href="sql.htm#select"><code>SELECT</code></a>), <code>InnoDB</code>
дает Вашей транзакции точку времени, согласно которой Ваш запрос видит базу
данных. Если другая транзакция удаляет строку и передает после того, как Ваша
точка была назначена, Вы не видите строку как удаленную. Вставки и обновления
обработаны так же.</p>

<p>Снимок базы данных относится к
<a href="sql.htm#select"><code>SELECT</code></a>
в пределах транзакции, не обязательно к запросам
<a href="glossary.htm#glos_dml">DML</a>. Если Вы вставляете или изменяете
некоторые строки и затем передаете транзакцию, запросы
<a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a> от другой параллельной
транзакции <code>REPEATABLE READ</code>
могут затронуть те переданные строки, даже при том, что сеанс не мог
запросить их. Если транзакция действительно обновляет или удаляет строки,
переданные иной транзакцией, те изменения действительно становятся видимыми к
текущей транзакции. Например, Вы могли бы столкнуться с такой ситуацией:
<pre>
SELECT COUNT(c1) FROM t1 WHERE c1 = 'xyz';
-- Returns 0: no rows match.
DELETE FROM t1 WHERE c1 = 'xyz';
-- Deletes several rows recently committed by other transaction.

SELECT COUNT(c2) FROM t1 WHERE c2 = 'abc';
-- Returns 0: no rows match.
UPDATE t1 SET c2 = 'cba' WHERE c2 = 'abc';
-- Affects 10 rows: another txn just committed 10 rows with 'abc' values.
SELECT COUNT(c2) FROM t1 WHERE c2 = 'cba';
-- Returns 10: this txn can now see the rows it just updated.
</pre>

<p>Вы можете обновить точку времени, передавая Вашу транзакцию и затем делая
другой запрос <a href="sql.htm#select"><code>SELECT</code></a> или
<a href="sql.htm#commit"><code>START TRANSACTION WITH CONSISTENT SNAPSHOT
</code></a>.</p>

<p>В следующем примере сеанс A видит строку, вставленную B, только когда B
передал вставку, а A передал также, чтобы точка времени обновилась.
<pre>
      Сеанс A            Сеанс B

 SET autocommit=0;  SET autocommit=0;
time
| SELECT * FROM t;
| empty set
|   INSERT INTO t VALUES (1, 2);
|
v SELECT * FROM t;
  empty set
COMMIT;

  SELECT * FROM t;
  empty set

  COMMIT;

  SELECT * FROM t;
  ---------------------
  | 1    | 2          |
  ---------------------
</pre>

<p>Если Вы хотите видеть <span><span>свежее</span></span> состояние
базы данных, используйте любой уровень изоляции
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>
или <a href="glossary.htm#glos_locking_read">блокировку чтения</a>:
<pre>
SELECT * FROM t LOCK IN SHARE MODE;
</pre>

<p>На уровне <a href="#isolevel_read-committed"><code>READ
COMMITTED</code></a> каждое последовательное чтение в пределах транзакции
устанавливает и читает свой собственный новый снимок. С <code>LOCK IN SHARE
MODE</code> блокировка чтения происходит вместо этого: <code>SELECT</code>
блокирует до транзакции, содержащей самые новые концы строк (см.
<a href="#innodb-locking-reads">раздел 16.5.2.4</a>).</p>

<p>Последовательное чтение не работает по определенным запросам DDL:</p>
<ul><li><p>Последовательное чтение не работает через
<a href="sql.htm#drop-table"><code>DROP TABLE</code></a>, поскольку MySQL
не может использовать таблицу, которая была удалена, а <code>InnoDB</code>
разрушает эту таблицу.</li>

<li>Последовательное чтение не работает через
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, так как
запрос делает временную копию оригинальной таблицы и удаляет оригинальную
таблицу, когда временная копия создана. Когда Вы используете последовательное
чтение в пределах транзакции, строки в новой таблице невидимы, потому что те
строки не существовали, когда снимок транзакции был взят.
В этом случае транзакция возвращает ошибку:
<a href="error.htm#error_er_table_def_changed"><code>ER_TABLE_DEF_CHANGED
</code></a>, <span><span>Table definition has changed,
please retry transaction</span></span>.</p></li></ul>

<p>Тип чтения изменяется для выбора в запросах
<a href="sql.htm#insert"><code>INSERT INTO ... SELECT</code></a>,
<a href="sql.htm#update"><code>UPDATE ... (SELECT)</code></a> и
<a href="sql.htm#create-table"><code>CREATE TABLE ... SELECT</code></a>,
которые не определяют <code>FOR UPDATE</code> или
<code>LOCK IN SHARE MODE</code>:</p>

<ul><li><p>По умолчанию <code>InnoDB</code> использует более сильные
блокировки и <a href="sql.htm#select"><code>SELECT</code></a> действует как
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>,
где каждое последовательное чтение, даже в пределах той же самой транзакции,
устанавливает и читает свой собственный новый снимок.</li>

<li>Чтобы использовать последовательное чтение в таких случаях, установите
уровень изоляции транзакции <a href="#isolevel_read-uncommitted">
<code>READ UNCOMMITTED</code></a>,
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>
или <a href="#isolevel_repeatable-read"><code>REPEATABLE READ
</code></a> (то есть, что-либо кроме
<a href="#isolevel_serializable"><code>SERIALIZABLE</code></a>).
В этом случае никакие блокировки не установлены на строках, считанных
из выбранной таблицы.</p></li></ul>

<h4><a name="innodb-locking-reads"></a>16.5.2.4. Блокировка чтений</h4>
<p>Если Вы запрашиваете данные и затем вставляете или обновляете связанные
данные в пределах той же самой транзакции, запрос <code>SELECT</code>
не дает достаточную защиту. Другие транзакции могут обновить или удалить те
же самые строки, которые Вы только что запросили.
<code>InnoDB</code> понимает два типа
<a href="glossary.htm#glos_locking_read">блокировки чтений</a>, которые
предлагают дополнительную безопасность:</p>

<ul><li><p><a href="sql.htm#select"><code>SELECT ... LOCK IN SHARE MODE
</code></a> задает совместно используемый режим блокировки на
любые строки, которые считаны. Другие сеансы могут считать строки, но не
могут изменить их, пока Ваша транзакция не передается. Если какая-либо из
этих строк была изменена другой транзакцией, которая еще не передалась, Ваш
запрос ждет ее завершения и затем использует последние значения.</li>

<li>Для индексных записей поиска
<a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a> блокирует
строки и любые связанные записи в индексе, как будто была команда
<code>UPDATE</code> для тех строк. Другие транзакции заблокированы на
обновление тех строк из <a href="sql.htm#select"><code>SELECT ...
LOCK IN SHARE MODE</code></a> или от чтения данных в определенных
операционных уровнях изоляции. Последовательные чтения игнорируют любой набор
блокировок на записях, которые существуют в представлении чтения. Старые
версии записи не могут быть заблокированы: они восстановлены, применяя
<a href="glossary.htm#glos_undo_log">журнал отмены</a>
к копии записи в памяти.</p></li></ul>

<p>Эти пункты прежде всего полезны, имея дело со структурированными деревом
или структурированными данными графика в единственной таблице или в
разделении на несколько таблиц. Вы пересекаете края или ответвления дерева от
одного места до другого, резервируя право возвратиться и изменить любой
из этих <span><span>указателей</span></span>.</p>

<p>Все блокировки, установленные <code>LOCK IN SHARE MODE</code> и
<code>FOR UPDATE</code> выпущены, когда транзакция передана или отменена.</p>
<p>Блокировка строк для использования обновления <code>SELECT FOR UPDATE
</code> применяется, когда autocommit отключен любым способом
(<a href="sql.htm#commit"><code>START TRANSACTION</code></a> или установкой
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a> в 0). Если
autocommit включен, строки, соответствующие спецификации, не заблокированы.
</p>

<h5><a name="idm139965330058192"></a>Примеры использования</h5>
<p>Предположите, что Вы хотите вставить новую строку в таблицу
<code>child</code> и удостоверьтесь, что дочерняя строка имеет родительскую
строку в таблице <code>parent</code>. Ваш код программы может гарантировать
ссылочную целостность всюду по этой последовательности операций.</p>

<p>Во-первых, используйте последовательное чтение, чтобы запросить таблицу
<code>PARENT</code> и проверьте, что родительская строка существует. Можете
Вы безопасно вставлять дочернюю строку в таблицу <code>CHILD</code>?
Нет, потому что некоторый другой сеанс мог удалить родительскую строку в
момент между Вашими <code>SELECT</code> и <code>INSERT</code>.</p>

<p>Чтобы избежать этой потенциальной проблемы, используйте
<a href="sql.htm#select"><code>SELECT</code></a> с
<code>LOCK IN SHARE MODE</code>:
<pre>
SELECT * FROM parent WHERE NAME = 'Jones' LOCK IN SHARE MODE;
</pre>

<p>После <code>LOCK IN SHARE MODE</code> запрос возвращает
<code>'Jones'</code>, который Вы можете безопасно добавить в дочернюю
запись в таблице <code>CHILD</code> и передать транзакцию. Любая транзакция,
которая пытается приобрести исключительную блокировку в применимой строке в
таблице <code>PARENT</code> ждет, пока Вы не закончите, то есть, пока данные
во всех таблицах не находятся в последовательном статусе.</p>

<p>Для другого примера, рассмотрите область счетчика целого числа в таблице
таблице <code>CHILD_CODES</code>, используемую, чтобы назначить уникальный
идентификатор каждому дочернему элементу в таблице <code>CHILD</code>.
Не используйте последовательное чтение или совместно используемое чтение,
чтобы считать текущее значение счетчика, потому что два пользователя базы
данных могли видеть то же самое значение счетчика, и происходит ошибка
дублирования ключа, если две транзакции пытаются добавить строки с тем же
самым идентификатором к <code>CHILD</code>.</p>

<p>Здесь <code>LOCK IN SHARE MODE</code> плохое решение, потому что, если два
пользователя читают счетчик в то же самое время, по крайней мере один из них
заканчивает в тупике, когда пытается обновить счетчик.</p>

<p>Чтобы осуществить чтение и постепенное увеличение счетчика, сначала
выполните блокировку чтения счетчика через <code>FOR UPDATE</code>,
а затем увеличьте счетчик. Например:
<pre>
SELECT counter_field FROM child_codes FOR UPDATE;
UPDATE child_codes SET counter_field = counter_field + 1;
</pre>

<p><a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a> читает
последние доступные данные, устанавливая исключительные блокировки на каждой
строке, которую читает. Таким образом, это устанавливает те же самые
блокировки, какие ищущий <a href="sql.htm#update"><code>UPDATE</code></a>
установил бы на строках.</p>

<p>Предыдущее описание просто пример того, как работает
<a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a>. В MySQL
определенная задача производства уникального идентификатора фактически может
быть выполнена, используя только единственный доступ к таблице:
<pre>
UPDATE child_codes SET counter_field = LAST_INSERT_ID(counter_field + 1);
SELECT LAST_INSERT_ID();
</pre>

<p><a href="sql.htm#select"><code>SELECT</code></a> просто получает
информацию об идентификаторе (определенном для текущего соединения).
Это не получает доступ ни к какой таблице.</p>

<h3><a name="innodb-locks-set"></a>16.5.3.
Установка блокировок различными запросами SQL в InnoDB</h3>
<p><a href="glossary.htm#glos_locking_read">Блокировка чтения</a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>
вообще устанавливают блокировки записи на каждой записи индекса, которая
просмотрена в обработке запроса SQL. Не имеет значения, есть ли условие
<code>WHERE</code> в запросе, которое исключило бы строку.
<code>InnoDB</code> не помнит точное выражение <code>WHERE</code>, а только
знает, которые индексные диапазоны, были просмотрены. Блокировки обычно
<a href="glossary.htm#glos_next_key_lock">следующего ключа</a>, которые
также блокируют <span><span>промежуток</span></span> сразу перед записью.
Однако, <a href="glossary.htm#glos_gap_lock">блокировка промежутка</a>
может быть отключена явно, что заставляет блокировку следующего ключа не
использоваться. Подробности в <a href="#innodb-locking">разделе
16.5.1</a>. Операционный уровень изоляции также может затронуть, какие
блокировки установлены, см.
<a href="sql.htm#set-transaction">раздел 14.3.6</a>.</p>

<p>Если вторичный индекс используется в поиске, и блокировки индексной
записи, которые будут установлены, исключительны, <code>InnoDB</code>
также получает соответствующие записи кластеризируемого индекса и ставит
на них блокировки.</p>

<p>Различия между совместно используемыми и исключительными блокировками
описаны в <a href="#innodb-locking">разделе 16.5.1</a>.</p>
<p>Если Вы не имеете индекса, подходящего для Вашего запроса, и MySQL должен
просмотреть всю таблицу, чтобы обработать запрос, каждая строка таблицы
становится заблокированной, что в свою очередь блокирует все вставки другими
пользователями в таблицу. Важно создать хороший индекс
так, чтобы Ваши запросы не просматривали слишком много строк.</p>

<p>Для <a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a> или
<a href="sql.htm#select"><code>SELECT ... LOCK IN SHARE MODE</code></a>
блокировки приобретены для просмотренные строки и, как ожидают, будут
выпущены для строк, которые не имеют право на включение в набор результатов
(например, если они не соответствуют критериям, поданным в
<code>WHERE</code>). Однако, в некоторых случаях, строки нельзя было бы
немедленно разблокировать, потому что отношения между строкой результата и ее
первоисточником потеряны во время выполнения запроса. Например, в
<a href="sql.htm#union"><code>UNION</code></a> просмотренные (и
заблокированные) строки могли бы быть вставлены во временную таблицу перед
оценкой, имеют ли они право на набор результатов. При этом потеряны отношения
строк во временной таблице к строкам в оригинальной таблице, и последние
строки не разблокируют до конца выполнения запроса.</p>

<p><code>InnoDB</code> устанавливает типы блокировок следующим образом.</p>
<ul><li><p><a href="sql.htm#select"><code>SELECT ... FROM</code></a>
последовательное чтение, читая снимок базы данных и не устанавливая
блокировок, если операционный уровень изоляции не установлен в
<a href="#isolevel_serializable"><code>SERIALIZABLE</code></a>.
Для уровня <a href="#isolevel_serializable"><code>SERIALIZABLE
</code></a> поиск ставит совместно использованные блокировки следующего
ключа на индексные записи.</li>

<li><a href="sql.htm#select"><code>SELECT ... FROM ... LOCK IN SHARE MODE
</code></a> ставит совместно использованные блокировки следующего ключа на
все индексные записи, используемые поиском.</li>

<li>Для индексных записей поиска
<a href="sql.htm#select"><code>SELECT ... FROM ... FOR UPDATE</code></a>
блокирует другие сеансы от выполнения
<a href="sql.htm#select"><code>SELECT ... FROM ... LOCK IN SHARE MODE</code>
</a> или чтения в определенных операционных уровнях изоляции.
Последовательные чтения проигнорируют любой набор блокировок на записях,
которые существуют в представлении чтения.</li>

<li><a href="sql.htm#update"><code>UPDATE ... WHERE ...</code></a> ставит
исключительную блокировку следующего ключа на каждой
записи столкновения поиска.</li>

<li>Когда <a href="sql.htm#update"><code>UPDATE</code></a> меняет
запись в кластеризируемом индексе, неявные блокировки взяты на
затронутых записях вторичного индекса.
<a href="sql.htm#update"><code>UPDATE</code></a> также ставит
совместно использованные блокировки на затронутые записи вторичного индекса,
когда выполняется проверка на дубликаты до вставки новых записей вторичного
индекса и когда происходит собственно вставка новых
записей вторичного индекса.</li>

<li><a href="sql.htm#delete"><code>DELETE FROM ... WHERE ...</code></a>
ставит исключительную блокировку следующего ключа на каждую запись поиска.
</li>

<li><a href="sql.htm#insert"><code>INSERT</code></a> ставит исключительную
блокировку на вставленной строке. Эта блокировка на самом деле блокирует
запись индекса, а не следующий ключ (то есть, нет никакой блокировки
промежутка), и не препятствует тому, чтобы другие сеансы вставили в
промежуток перед вставленной строкой.</p>

<p>До вставки строки блокировка промежутка вызывает установку
блокировки промежутка намерения вставки. Эта блокировка сигнализирует
намерение вставить таким способом, что многократные транзакции, вставляющие в
тот же самый промежуток, не должен ждать друг друга, если они не вставляют в
той же самой позиции в пределах промежутка. Предположите, что есть индексные
записи со значениями 4 и 7. Отдельные транзакции, которые пытаются вставить
значения 5 и 6 блокируют промежуток между 4 и 7 с блокировками намерения
вставки до получения исключительной блокировки на вставленной строке, но не
заблокируют друг друга, потому что строки не находятся в противоречии.</p>

<p>Если происходит ошибка дублирования ключа, совместно используемая
блокировка на дубликате индексной записи установлена. Это использование
совместно используемой блокировки может привести к тупику, когда есть
многократные сеансы, пытающиеся вставить ту же самую строку, если у другого
сеанса уже есть исключительная блокировка. Это может произойти, если другой
сеанс удаляет строку. Предположите, что таблица <code>InnoDB</code>
<code>t1</code> имеет следующую структуру:
<pre>
CREATE TABLE t1 (i INT, PRIMARY KEY (i)) ENGINE = InnoDB;
</pre>

<p>Теперь предположите, что три сеанса выполняют
следующие операции в порядке:</p>
<p>Сеанс 1:
<pre>
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre>

<p>Сеанс 2:
<pre>
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre>

<p>Сеанс 3:
<pre>
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre>

<p>Сеанс 1:
<pre>
ROLLBACK;
</pre>

<p>Сначала сеанс 1 приобретает исключительную блокировку на строку. Сеансы
2 и 3 получают ошибку дубликата ключа и они оба просят совместно используемую
блокировку для строки. Когда сеанс 1 откатывается, он выпускает свою
исключительную блокировку на строке, и запросы совместно используемой
блокировки сеансами 2 и 3 удовлетворены. Вот здесь 2 и 3 в тупике:
ни один не может приобрести исключительную блокировку на строке из-за
совместно используемой блокировки, проводимой другим.</p>

<p>Подобная ситуация происходит, если таблица уже содержит строку со
значением ключа 1, и три сеанса выполняют следующие операции в порядке:</p>
<p>Сеанс 1:
<pre>
START TRANSACTION;
DELETE FROM t1 WHERE i = 1;
</pre>

<p>Сеанс 2:
<pre>
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre>

<p>Сеанс 3:
<pre>
START TRANSACTION;
INSERT INTO t1 VALUES(1);
</pre>

<p>Сеанс 1:
<pre>
COMMIT;
</pre>

<p>Сеанс 1 приобретает исключительную блокировку на строке. Сеансы 2 и 3
получают ошибку дубликата ключа и оба требуют совместно используемую
блокировку для строки. Когда сеанс 1 передает транзакцию,
он выпускает свою исключительную блокировку на строке, и совместно
используемые запросы блокировки 2 и 3 удволетворены. В итоге 2 и 3 в тупике:
ни один не может приобрести исключительную блокировку на строку из-за
совместно используемой блокировки, проводимой другим.</li>

<li><a href="sql.htm#insert-on-duplicate"><code>INSERT ... ON DUPLICATE KEY
UPDATE</code></a> отличается от простого
<a href="sql.htm#insert"><code>INSERT</code></a>
использованием исключительной блокировки следующего ключа вместо
совместно используемой блокировки на строке, которая будет обновлена, когда
происходит ошибка дубликата ключа.</li>

<li><a href="sql.htm#replace"><code>REPLACE</code></a> сделан как
<a href="sql.htm#insert"><code>INSERT</code></a>,
если нет никакого столкновения на уникальном ключе. Иначе исключительная
блокировка следующего ключа помещена на строку, которая будет заменена.</li>

<li><code>INSERT INTO T SELECT ... FROM S WHERE ...</code> ставит
исключительную блокировку индексной записи (без блокировки промежутка) на
каждой строке, вставленной в <code>T</code>. Если операционный уровень
изоляции <a href="#isolevel_read-committed">
<code>READ COMMITTED</code></a>, <code>InnoDB</code> делает поиск на
<code>S</code> как последовательное чтение (никакие блокировки не
применяются). Иначе <code>InnoDB</code> ставит совместно используемую
блокировку следующего ключа на строках из <code>S</code>. <code>InnoDB</code>
должен установить блокировки в последнем случае: в восстановлении
после резервного копирования каждый запрос SQL должен быть выполнен точно
таким же образом, как это было сделано первоначально.</p>

<p><a href="sql.htm#create-table"><code>CREATE TABLE ... SELECT ...</code>
</a> выступает как <a href="sql.htm#select"><code>SELECT</code></a> с
с совместно используемыми блокировками следующего ключа или как
последовательное чтение при
<a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>.</p>

<p>Когда <code>SELECT</code> учавствует в
<code>REPLACE INTO t SELECT ... FROM s WHERE ...</code>
или <code>UPDATE t ... WHERE col IN (SELECT ... FROM s ...)</code>,
<code>InnoDB</code> ставит совместно используемую блокировку следующего
ключа на строках из таблицы <code>s</code>.</li>

<li>Инициализируя ранее указанный столбец <code>AUTO_INCREMENT</code> в
таблице, <code>InnoDB</code> ставит исключительную блокировку на конце
индекса, связанного со столбцом <code>AUTO_INCREMENT</code>.
При доступе к счетчику автоинкремента <code>InnoDB</code> использует режим
блокировки <code>AUTO-INC</code>, где блокировка длится только до конца
текущего запроса SQL, но не до конца всей транзакции.
Другие сеансы не могут вставить в таблицу в то время, как
проводится табличная блокировка <code>AUTO-INC</code>, см.
<a href="#innodb-transaction-model">раздел 16.5.2</a>.</p>

<p><code>InnoDB</code> приносит значение ранее инициализированного столбца
<code>AUTO_INCREMENT</code>, не устанавливая блокировок.</li>
<li>Если ограничение <code>FOREIGN KEY</code> определено на таблице, любые
вставки, обновления или удаления, которые требуют, чтобы условие ограничения
было проверено, ставят совместно используемую блокировку на уровне записи,
которые проверяются на ограничение. <code>InnoDB</code> ставит эти блокировки
в случае, где ограничение терпит неудачу.</li>

<li><a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a> ставит
табличные блокировки, но это более высокий уровень MySQL, выше слоя
<code>InnoDB</code>, который устанавливает эти блокировки.
<code>InnoDB</code> знает о табличных блокировках, если
<code>innodb_table_locks = 1</code> (по умолчанию) и
<a href="server.htm#sysvar_autocommit"><code>autocommit = 0</code></a>
и уровень MySQL выше <code>InnoDB</code> знает о блокировках
на уровне строки.</p>

<p>Иначе автоматическое обнаружение тупика <code>InnoDB</code>
не может обнаружить тупики, где такие табличные блокировки вовлечены.
Кроме того, потому что в этом случае более высокий уровень MySQL не знает о
блокировках на уровне строки, можно получить табличную блокировку на таблице,
где у другого сеанса в настоящее время есть блокировки на уровне строки.
Однако, это не подвергает опасности операционную целостность, как обсуждено в
<a href="#innodb-deadlock-detection">разделе 16.5.5.2</a>. См.
также <a href="#innodb-restrictions">раздел 16.8.7</a>.
</p></li></ul>

<h3><a name="innodb-next-key-locking"></a>16.5.4. Строки-призраки</h3>
<p>Так называемая <span class="firstterm">призрачная</span> проблема
происходит в пределах транзакции, когда тот же самый запрос производит
различные наборы строк в разное время. Например, если
<a href="sql.htm#select"><code>SELECT</code></a>
выполнен дважды, но возвращает строку во второй раз, которая не была
возвращена в первый раз, строка призрачная.</p>

<p>Предположите, что есть индекс на столбце <code>id</code> таблицы
<code>child</code> и что Вы хотите считать и заблокировать все строки из
таблицы, имеющей значение идентификатора, больше 100, с намерением обновить
некоторый столбец в выбранных строках позже:
<pre>
SELECT * FROM child WHERE id &gt; 100 FOR UPDATE;
</pre>

<p>Запрос просматривает индекс с первой записи, где <code>id</code> больше
100. Пусть в таблице строки с <code>id</code> 90 и 102.
Если блокировки на записях индекса в просмотренном диапазоне не запрещают
вставки в промежутки (в этом случае, промежуток между 90 и 102), другой сеанс
может вставить новую строку в таблицу с <code>id</code> 101.
Если Вы должны были выполнить тот же самый
<a href="sql.htm#select"><code>SELECT</code></a>
в пределах той же самой транзакции Вы видели бы новую строку с
<code>id</code> 101 (<span><span>призрак</span></span>)
в наборе результатов, возвращенном запросом. Если мы расцениваем ряд строк
как элемент данных, новый призрачный дочерний элемент нарушил бы принцип
изоляции транзакций, что транзакция должна быть в состоянии работать так,
чтобы данные, которые она прочитала, не изменились во время транзакции.</p>

<p>Чтобы избегать таких ситуаций <code>InnoDB</code>
использует алгоритм, названный <span class="firstterm">блокировка следующего
ключа</span>, который комбинирует блокировку индекса строки с блокировкой
промежутка. <code>InnoDB</code> выполняет блокировку на уровне строки таким
способом, что когда это ищет или просматривает индекс таблицы, это
устанавливает совместно использованные или исключительные блокировки на
индексных записях, с которыми сталкивается. Таким образом, блокировки на
уровне строки фактически блокировки индексных записей. Кроме того,
блокировка следующего ключа на записи индекса также затрагивает
<span><span>промежуток</span></span> перед этой записью.
Таким образом, блокировка следующего ключа это блокировка индексной записи и
промежутка, предшествующего ей. Если у одного сеанса есть совместно
используемая или исключительная блокировка на записи <code>R</code> в
индексе, другой сеанс не может вставить новую запись в промежутке немедленно
перед <code>R</code> в порядке индекса.</p>

<p>Когда <code>InnoDB</code> просматривает индекс, это может также
заблокировать промежуток после последней записи в индексе. Это происходит в
предыдущем примере: чтобы предотвратить любую вставку в таблицу, где
<code>id</code> больше 100, блокировки, установленные <code>InnoDB</code>,
включают блокировку на промежутке после <code>id</code> 102.</p>

<p>Вы можете использовать блокировку следующего ключа, чтобы осуществить
проверку уникальности в Вашем приложении: если Вы читаете свои данные в
режиме совместного доступа и не видите дубликат строки, которую собираетесь
вставить, то можете безопасно вставить свою строку и знать, что блокировка
следующего ключа, установленная на преемнике Вашей строки во время чтения,
предотвращает вставку дубликата для Вашей строки.
Таким образом, блокировка следующего ключа позволяет Вам
<span><span>блокировать</span></span> небытие чего-то в Вашей таблице.</p>

<p>Блокировка промежутка может быть отключена как обсуждено в
<a href="#innodb-locking">разделе 16.5.1</a>. Это может вызвать
призрачные проблемы, потому что другие сеансы могут вставить новые строки в
промежутки, когда блокировка промежутка отключена.</p>

<h3><a name="innodb-deadlocks"></a>16.5.5. Тупики в InnoDB</h3>
<p>Тупик это ситуация, где различные транзакции не способны продолжить работу
потому, что каждый держит блокировку, нужную другой. Поскольку обе транзакции
ждут ресурса, ни одна никогда не будет выпускать блокировки, которые держит.
</p>

<p>Тупик может произойти, когда транзакции блокируют строки в многих таблицах
(через такие запросы, как <a href="sql.htm#update"><code>UPDATE</code></a>
или <a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a>),
но в противоположном порядке. Тупик может также произойти, когда такие
запросы блокируют диапазоны, индексных записей и промежутки с каждой
транзакцией, приобретающей некоторые блокировки, но не другие из-за проблемы
синхронизацией. Для примера тупика см.
<a href="#innodb-deadlock-example">раздел 16.5.5.1</a>.</p>

<p>Чтобы уменьшить возможность тупиков, используйте транзакции, а не
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a>,
сохраните транзакции, которые вставляют или обновляют данные, достаточно
маленькими, чтобы они не оставались открытыми в течение долгих промежутков
времени, когда различные транзакции обновляют многие таблицы или большие
спектры строк, используйте тот же самый порядок операций (таких, как
<a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a>)
в каждой транзакции, создайте индексы на столбцах, используемых в
<a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a> и
<a href="sql.htm#update"><code>UPDATE ... WHERE</code></a>.
Возможность тупиков не затронута уровнем изоляции, потому что уровень
изоляции изменяет поведение операций чтения, в то время как тупики происходят
из-за записи. Для получения дополнительной информации об уходе от условий
тупика см. <a href="#innodb-deadlocks-handling">раздел 16.5.5.3
</a>.</p>

<p>Когда обнаружение тупика включено (значение по умолчанию), и тупик
действительно происходит, <code>InnoDB</code> обнаруживает условие и
откатывает одну из транзакций до прежнего уровня. Если обнаружение тупика
отключено, используя опцию <a href="#sysvar_innodb_deadlock_detect">
<code>innodb_deadlock_detect</code></a>, <code>InnoDB</code> полагается на
настройку <a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a>, чтобы откатить транзакции до прежнего
уровня в случае тупика. Таким образом, даже если Ваша логика приложения
правильна, Вы должны все еще обработать случай, где транзакция должна быть
повторена. Чтобы увидеть последний тупик в пользовательской транзакции
<code>InnoDB</code>, используйте
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.
Если частые тупики выделяют проблему с операционной структурой или обработкой
ошибки приложения, работайте с опцией
<a href="#sysvar_innodb_print_all_deadlocks"><code>
innodb_print_all_deadlocks</code></a>, чтобы напечатать информацию обо всех
тупиках в журнал ошибок <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a>. Для получения дополнительной информации о том, как
тупики автоматически обнаружены и обработаны см.
<a href="#innodb-deadlock-detection">раздел 16.5.5.2</a>.</p>

<h4><a name="innodb-deadlock-example"></a>16.5.5.1. Пример тупика в InnoDB
</h4>
<p>Следующий пример иллюстрирует, как ошибка может произойти, когда запрос
блокировки вызвал бы тупик. Пример вовлекает двух клиентов A и B.</p>

<p>Клиент А составляет таблицу, содержащую одну строку, а затем начинает
транзакцию. В пределах транзакции A получает блокировку
<em><code>S</code></em> на строке, выбирая это в режиме общего доступа:
<pre>
mysql&gt; CREATE TABLE t (i INT) ENGINE = InnoDB;
Query OK, 0 rows affected (1.07 sec)

mysql&gt; INSERT INTO t (i) VALUES(1);
Query OK, 1 row affected (0.09 sec)

mysql&gt; START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;
+---+
| i |
+---+
| 1 |
+---+
</pre>

<p>Затем клиент Б начинает транзакцию и пытается удалить строку из таблицы:
<pre>
mysql&gt; START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; DELETE FROM t WHERE i = 1;
</pre>

<p>Удаление требует блокировки <em><code>X</code></em>.
Блокировку нельзя предоставить, потому что это является несовместимым с
<em><code>S</code></em>, которую держит клиент А, таким образом, запрос идет
в очередь запросов блокировки для строки, что блокирует клиента B.</p>

<p>Наконец, клиент также пытается удалить строку из таблицы:
<pre>
mysql&gt; DELETE FROM t WHERE i = 1;
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre>

<p>Тупик происходит здесь потому, что клиент A требует блокировку
<em><code>X</code></em>, чтобы удалить строку. Однако, тот запрос блокировки
нельзя предоставить, потому что у клиента B уже есть запрос на
<em><code>X</code></em>, и он ждет, пока клиент A выпустит блокировку
<em><code>S</code></em>. Так они будут ждать друг друга вечно.
В результате <code>InnoDB</code> производит ошибку для одного из клиентов и
выпускает все его блокировки. Клиент возвращает эту ошибку:
<pre>
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction
</pre>
<p>Здесь можно предоставить запрос блокировки для
другого клиента, и это удаляет строку из таблицы.</p>

<h4><a name="innodb-deadlock-detection"></a>16.5.5.2.
Обнаружение тупика и отмена</h4>
<p>Когда <a href="glossary.htm#glos_deadlock_detection">обнаружение тупика
</a> включено (по умолчанию), <code>InnoDB</code> автоматически обнаруживает
транзакционные <a href="glossary.htm#glos_deadlock">тупики</a> и откатывает
до прежнего уровня транзакцию или транзакции, чтобы найти выход из тупика.
<code>InnoDB</code> старается выбрать маленькие транзакции, чтобы откатить,
где размер транзакции определен числом затронутых ей строк.</p>

<p><code>InnoDB</code> знает о табличных блокировках, если
<code>innodb_table_locks = 1</code> (по умолчанию) и
<a href="server.htm#sysvar_autocommit"><code>autocommit = 0</code></a>,
и уровень MySQL выше этого знает о блокировках на уровне строки. Иначе
<code>InnoDB</code> не может обнаружить тупики, где табличная блокировка,
установленная MySQL <a href="sql.htm#lock-tables"><code>LOCK TABLES</code>
</a> или блокировка, установленная механизмом хранения кроме
<code>InnoDB</code>, вовлечена. Решите эти ситуации, устанавливая значение
<a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a>.</p>

<p>Когда <code>InnoDB</code> выполняет полную отмену транзакции, все
блокировки, установленные транзакцией, выпущены. Однако, если только
единственный запрос SQL откатывается до прежнего уровня в результате ошибки,
некоторые из блокировок, установленных запросом, могут быть сохранены. Это
происходит потому, что <code>InnoDB</code> хранит блокировки строк
таким образом, что не может знать, какая блокировка была
установлена которым запросом.</p>

<p>Если <a href="sql.htm#select"><code>SELECT</code></a> вызывает сохраненную
функцию в транзакции, и запрос в пределах функции терпит неудачу, то запрос
откатывается. Кроме того, если <a href="sql.htm#commit"><code>ROLLBACK</code>
</a> выполнен после этого, откатывается вся транзакция.</p>

<p>Если раздел <code>LATEST DETECTED DEADLOCK</code> в
<code>InnoDB</code> Monitor включает сообщение <span><span><span>TOO DEEP OR
LONG SEARCH IN THE LOCK TABLE WAITS-FOR GRAPH, WE WILL ROLL BACK FOLLOWING
TRANSACTION</span></span></span>, это указывает, что число транзакций в
ожидании достигло предела 200. Это обработано как тупик и транзакция,
пытающаяся встать в очередь откатывается до прежнего уровня. Та же самая
ошибка может также произойти, если поток блокировки должен смотреть больше,
чем на 1000000 блокировок, принадлежавших транзакциям в списке ожидания.</p>
<p>Для методов, чтобы организовать операции базы данных, чтобы избежать
тупиков, см. <a href="#innodb-deadlocks">раздел 16.5.5</a>.</p>

<h5><a name="innodb-disable-deadlock-detection"></a>
Отключение обнаружения тупика</h5>
<p>На высоконагруженных системах обнаружение тупика может вызвать замедление,
когда многочисленные потоки ждут той же самой блокировки. Время от времени
может быть более эффективно отключить обнаружение тупика и положиться на
опцию <a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a> для операционной отмены, когда тупик
происходит. Обнаружение тупика может быть отключено, используя опцию
<a href="#sysvar_innodb_deadlock_detect">
<code>innodb_deadlock_detect</code></a>.</p>

<h4><a name="innodb-deadlocks-handling"></a>16.5.5.3.
Как минимизировать и обработать тупики</h4>
<p>Этот раздел основывается на концептуальной информации о тупиках в
<a href="#innodb-deadlock-detection">разделе 16.5.5.2</a>.
Это объясняет, как организовать операции базы данных, чтобы минимизировать
тупики и последующую обработку ошибок, требуемую в приложениях.</p>

<p><a href="glossary.htm#glos_deadlock">Тупики</a> это классическая проблема
в транзакционных базах данных, но они не опасны, если не являются настолько
частыми, что Вы не можете выполнить определенные транзакции вообще. Обычно Вы
должны написать свои приложения так, чтобы они были всегда подготовлены
перезапустить транзакцию, если она отменена из-за тупика.</p>

<p><code>InnoDB</code> использует автоматическую блокировку на уровне строки.
Вы можете получить тупики даже в случае транзакций, которые только вставляют
или удаляют единственную строку. Это так, потому что эти операции не
действительно <span><span>атомарные</span></span>, они автоматически
устанавливают блокировки (возможно, несколько) индексных записей
строки, вставленной или удаленной.</p>

<p>Вы можете справиться с тупиками и уменьшить вероятность их
возникновения следующими методами:</p>
<ul><li><p>В любое время скомандуйте <a href="sql.htm#show-engine"><code>SHOW
ENGINE INNODB STATUS</code></a>, чтобы определить причину нового тупика. Это
может помочь Вам настроить свое приложение, чтобы избежать тупиков.</li>

<li>Если часты предупреждения о тупике, соберите более обширную информацию
отладки, включая опцию <a href="#sysvar_innodb_print_all_deadlocks">
<code>innodb_print_all_deadlocks</code></a>. Информация о каждом тупике, не
только последнем, зарегистрирована в <a href="glossary.htm#glos_error_log">
журнале ошибок</a> MySQL. Отключите эту опцию, когда Вы закончите отладку.
</li>

<li>Всегда готовьтесь перезапустить транзакцию, если это терпит неудачу.
Тупики не опасны. Только попробуйте еще раз.</li>
<li>Сохраните транзакции маленькими и короткими по продолжительности, чтобы
сделать их менее склонными к столкновению.</li>

<li>Передайте транзакции немедленно после создания ряда связанных изменений,
чтобы сделать их менее склонными к столкновению. В частности не оставляйте
интерактивную сессию <a href="programs.htm#mysql"><span><strong>mysql
</strong></span></a> открытой в течение долгого
времени с нейтральной транзакцией.</li>

<li>Если Вы используете <a href="glossary.htm#glos_locking_read">блокировку
чтения</a> (<a href="sql.htm#select"><code>SELECT ... FOR UPDATE</code></a>
или <code>SELECT ... LOCK IN SHARE MODE</code>),
попытайтесь использовать более низкий уровень изоляции, такой как
<a href="#isolevel_read-committed"><code>READ COMMITTED</code></a>.
</li>

<li>Когда изменение многих таблиц в пределах транзакции или различных наборов
строк в той же самой таблице, делает те операции в последовательном порядке
каждый раз, транзакции формируют четкие очереди и не заходят в тупик.
Например, организуйте операции базы данных в функции в пределах Вашего
приложения или вызывайте хранимые подпрограммы вместо того, чтобы кодировать
многократные подобные последовательности <code>INSERT</code>,
<code>UPDATE</code> и <code>DELETE</code> в различных местах.</li>

<li>Добавьте хорошо подобранный индекс к Вашим таблицам. Тогда Ваши запросы
должны просмотреть меньше индексных записей
и следовательно устанавливают меньше блокировок. Хорошо использовать
<a href="sql.htm#explain"><code>EXPLAIN SELECT</code></a>, чтобы
определить, которые индекс сервер MySQL использует как самый подходящий
для Ваших запросов.</li>

<li>Применяйте меньше блокировок. Если Вы можете позволить себе разрешить
<a href="sql.htm#select"><code>SELECT</code></a>,
чтобы возвратить данные из старого снимка, не добавляйте
<code>FOR UPDATE</code> или <code>LOCK IN SHARE MODE</code>. Используя
уровня изоляции <a href="#isolevel_read-committed"><code>READ
COMMITTED</code></a> хорошо здесь, потому что каждое последовательное чтение
в пределах той же самой транзакции читает из ее собственного нового снимка.
</li>

<li>Если ничто иное не помогает, преобразуйте в последовательную форму свои
транзакции с блокировками на уровне таблицы. Правильный способ использовать
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a> с
<code>InnoDB</code>: начать с <code>SET autocommit = 0</code> (но не
<a href="sql.htm#commit"><code>START TRANSACTION</code></a>) сопровождаемый
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a> и не вызывать
<a href="sql.htm#lock-tables"><code>UNLOCK TABLES</code></a>
пока Вы не передаете транзакцию явно. Например, если Вы должны записать в
таблицу <code>t1</code> и читать из таблицы <code>t2</code>,
Вы можете сделать это:
<pre>
SET autocommit=0;
LOCK TABLES t1 WRITE, t2 READ, ...;
<em><code>... do something with tables t1 and t2 here ...</code></em>
COMMIT;
UNLOCK TABLES;
</pre>
<p>Блокировки на уровне таблицы предотвращают параллельные обновления
таблицы, избегая тупиков за счет менее быстрого отклика для занятой системы.
</li>

<li>Другой способ преобразовать в последовательную форму транзакции состоит в
том, чтобы создать вспомогательную таблицу, которая содержит только
единственную строку. Каждое операция обновляет эту строку прежде, чем
получить доступ к другим таблицам. Таким образом, все транзакции происходят
последовательным способом. Отметьте, что мгновенный алгоритм обнаружения
тупика <code>InnoDB</code> также работает в этом случае, потому что
блокировка преобразования в последовательную форму это
блокировка на уровне строки. С MySQL блокировки на уровне таблицы метод
тайм-аута должен использоваться, чтобы решить тупики.</p></li></ul>

<h2><a name="innodb-configuration"></a>16.6. Конфигурация InnoDB</h2>
<p>Этот раздел предоставляет информацию о конфигурации и процедуры для
инициализации и запуска <code>InnoDB</code>, а также
различные компоненты и особенности механизма хранения <code>InnoDB</code>.
Для информации об оптимизации операций базы данных для таблиц
<code>InnoDB</code> см. <a href="optimiz.htm#optimizing-innodb">раздел 9.5
</a>.</p>

<h3><a name="innodb-init-startup-configuration"></a>16.6.1.
Конфигурация запуска InnoDB</h3>
<p>Первые решения о настройке <code>InnoDB</code>
вовлекают конфигурацию файлов с данными, файлов системного журнала, размера
страницы и буферов памяти. Рекомендуется, чтобы Вы определили файл с данными,
файл системного журнала и конфигурацию размера страницы прежде, чем создать
экземпляр <code>InnoDB</code>. Изменение файла с данными или конфигурации
файла системного журнала после запуска <code>InnoDB</code>
может вовлечь нетривиальную процедуру, и размер страницы может быть определен
только когда <code>InnoDB</code> начально инициализирован.</p>

<p>В дополнение к этим темам этот раздел предоставляет информацию об
опциях в конфигурационном файле, рассматривая
информацию об инициализации и важные соображения о хранении.</p>

<ul><li><p><a href="#innodb-startup-mysql-configuration-file">
Определение опций в конфигурационном файле MySQL</a></li>
<li><a href="#innodb-startup-initialization-information">
Просмотр информации об инициализации InnoDB</a></li>

<li><a href="#innodb-startup-storage-considerations">
Важные соображения о хранении</a></li>
<li><a href="#innodb-startup-data-file-configuration">
Системная конфигурация файла с данными табличного пространства</a></li>

<li><a href="#innodb-startup-log-file-configuration">
Конфигурация файла системного журнала</a></li>
<li><a href="#innodb-startup-page-size">
Конфигурация размера страницы InnoDB</a></li>

<li><a href="#innodb-startup-undo-tablespace">
Конфигурация табличного пространства отмены InnoDB</a></li>
<li><a href="#innodb-startup-temporary-tablespace">
Конфигурация временного табличного пространства InnoDB</a></li>
<li><a href="#innodb-startup-memory-configuration">
Конфигурация памяти InnoDB</a></p></li></ul>

<h4><a name="innodb-startup-mysql-configuration-file"></a>
Определение опций в конфигурационном файле MySQL</h4>
<p>Поскольку MySQL использует файл с данными, файл системного журнала и
настройки конфигурации размера страницы, чтобы инициализировать
<code>InnoDB</code>, рекомендуется, чтобы Вы определили эти настройки в
конфигурационном файле, который MySQL читает при запуске, до инициализации
<code>InnoDB</code> впервые. <code>InnoDB</code> инициализирован, когда
сервер MySQL запущен, и первая инициализация <code>InnoDB</code>
обычно происходит в первый раз, когда Вы запускаете сервер MySQL.</p>

<p>Вы можете поместить опции <code>InnoDB</code> в группу
<code>[mysqld]</code> любого файла опции, который читает Ваш сервер, когда
запускается. Местоположения файлов опции MySQL описаны в
<a href="programs.htm#option-files">разделе 5.2.6</a>.</p>

<p>Чтобы удостовериться, что <a href="programs.htm#mysqld"><span><strong>
mysqld</strong></span></a> читает опции только из определенного файла (и
<code>mysqld-auto.cnf</code>), используйте
<a href="programs.htm#option_general_defaults-file"><code>--defaults-file
</code></a> как первую опцию в командной строке, запуская сервер:
<pre>
mysqld --defaults-file=<em><code>path_to_configuration_file</code></em>
</pre>

<h4><a name="innodb-startup-initialization-information"></a>
Просмотр информации об инициализации InnoDB</h4>
<p>Чтобы видеть сведения об инициализации <code>InnoDB</code> во время
запуска, запустите <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> из командной строки. Когда
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
запущен из командной строки, информация об инициализации выведена на консоль.
</p>

<p>Например, в Windows, если <a href="programs.htm#mysqld"><span><strong>
mysqld</strong></span></a> расположен в
<code>C:\Program Files\MySQL\MySQL Server 8.0\bin</code>,
запустите MySQL так:
<pre>
C:\&gt; "C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld" --console
</pre>

<p>В Unix-системах <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> расположен в подкаталоге
<code>bin</code> установки MySQL:
<pre>
sell&gt; bin/mysqld --user=mysql &amp;
</pre>

<p>Если Вы не посылаете вывод сервера на консоль, проверьте журнал ошибок
после запуска, чтобы видеть информацию об инициализации <code>InnoDB</code>,
напечатанную во время процесса запуска.</p>
<p>Для информации о запуске MySQL, используя другие методы, см.
<a href="install.htm#automatic-start">раздел 2.9.5</a>.</p>

<h4><a name="innodb-startup-storage-considerations"></a>
Важные соображения о хранении</h4>
<p>Рассмотрите следующие связанные с хранением соображения перед
продолжением Вашей конфигурации.</p>

<ul><li><p>В некоторых случаях работа базы данных улучшается, если все данные
не помещены на тот же самый физический диск. Помещение файлов системного
журнала на различном диске от данных очень часто выгодно для работы.
Например, Вы можете поместить системные файлы с данными табличного
пространства и файлы системного журнала на различных дисках. Вы можете также
использовать сырые дисковые разделы (сырые устройства) для файлов с данными
<code>InnoDB</code>, что может ускорить ввод/вывод. См.
<a href="#innodb-raw-devices">раздел 16.7.3</a>.</li>
<li>В Linux желательно отключить <span><strong>кэширование записи
</strong></span>.</p>

<p>На дисководах ATA/SATA команда <code>hdparm -W0 /dev/hda</code>
может работать, чтобы отключить кэширование записи.
<span><strong>Остерегайтесь того, что некоторые диски или дисковые
контроллеры могут быть неспособны отключить кэширование записи.
</strong></span></li>

<li>Относительно способностей восстановления <code>InnoDB</code>, которые
защищают пользовательские данные, <code>InnoDB</code>
использует метод потока файла, вовлекающий структуру, названную
<a href="glossary.htm#glos_doublewrite_buffer">буфер doublewrite</a>,
который включен по умолчанию
(<a href="#sysvar_innodb_doublewrite"><code>innodb_doublewrite=ON
</code></a>). Буфер doublewrite добавляет безопасность восстановления после
катастрофического отказа и улучшает работу относительно большинства вариантов
Unix, уменьшая потребность в <code>fsync()</code>. Рекомендуется держать
опцию <a href="#sysvar_innodb_doublewrite"><code>innodb_doublewrite
</code></a> включенной, если Вы обеспокоены целостностью данных или
возможными отказами. Для дополнительной информации о буфере
doublewrite см. <a href="#innodb-disk-io">раздел 16.11.1</a>.</li>

<li>Если надежность критично важна для Ваших данных, не надо конфигурировать
<code>InnoDB</code> использовать файлы с данными или файлы системного журнала
на томах NFS. Потенциальные проблемы изменяются в зависимости от OS и версии
NFS, и включают такие проблемы, как нехватка защиты от конфликтов записи
и ограничения на максимальные размеры файла.</p></li></ul>

<h4><a name="innodb-startup-data-file-configuration"></a>
Системная конфигурация файла с данными табличного пространства</h4>
<p>Системные файлы с данными табличного пространства сконфигурированы,
используя опции <a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a> и
<a href="#sysvar_innodb_data_home_dir"><code>innodb_data_home_dir
</code></a>.</p>

<p><a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a> используется, чтобы сконфигурировать
системные файлы с данными табличного пространства. Значение
<a href="#sysvar_innodb_data_file_path"><code>innodb_data_file_path
</code></a> должно быть списком из одной или более спецификаций файла с
данными. Если Вы называете больше чем один файл с данными, отделяете
их точкой с запятой (<code>;</code>):
<pre>
innodb_data_file_path=<em><code>datafile_spec1</code></em>[;<em><code>datafile_spec2</code></em>]...
</pre>

<p>Например, следующая установка явно создает минимальное
системное табличное пространство:
<pre>
[mysqld]
innodb_data_file_path=ibdata1:12M:autoextend
</pre>

<p>Эта установка конфигурирует единственный файл с данными 12 МБ
<code>ibdata1</code>. Никакое местоположение для файла не задано, так что по
умолчанию, <code>InnoDB</code> создает это в каталоге данных MySQL.</p>
<p>Размеры определены, используя буквы суффикса <code>K</code>,
<code>M</code> или <code>G</code>, чтобы указать на KB, MB или GB.</p>

<p>Табличное пространство, содержащее файл с данными 50 МБ фиксированного
размера с именем <code>ibdata1</code> и 50MB автомасштабируемый файл с именем
<code>ibdata2</code> в каталоге данных может быть сконфигурирован как это:
<pre>
[mysqld]
innodb_data_file_path=ibdata1:50M;ibdata2:50M:autoextend
</pre>

<p>Полный синтаксис для спецификации файла с данными включает имя файла, его
размер и несколько дополнительных признаков:
<pre>
<em><code>file_name</code></em>:<em><code>file_size</code></em>[:autoextend[:max:<em><code>max_file_size</code></em>]]
</pre>

<p><code>autoextend</code> и <code>max</code>
могут использоваться только для последнего файла с данными в строке
<a href="#sysvar_innodb_data_file_path"><code>innodb_data_file_path
</code></a>.</p>

<p>Если Вы определяете <code>autoextend</code> для последнего файла с
данными, <code>InnoDB</code> расширяет файл с данными, если он исчерпывает
свободное пространство в табличном пространстве. Инкремент составляет 64 МБ
за один раз по умолчанию. Чтобы изменить инкремент, измените значение
<a href="#sysvar_innodb_autoextend_increment"><code>
innodb_autoextend_increment</code></a>.</p>

<p>Если диск становится полным, Вы могли бы добавить другой файл с данными на
другом диске. Для инструкций реконфигурирования табличного пространства см.
<a href="#innodb-resize-system-tablespace">раздел 16.7.1</a>.</p>

<p><code>InnoDB</code> не знает о максимальном размере файла в файловой
системе, так что следует быть осторожным на файловых системах, где
максимальный размер файла маленькое значение, такое как 2GB.
Чтобы определить максимальный размер для файла с данными, используйте
параметр <code>max</code> после <code>autoextend</code>. Используйте
<code>max</code> только в случаях, где ограничение дискового использования
имеет жизненную важность, потому что превышение максимального размера
вызывает фатальную ошибку, возможно, включая катастрофический отказ.
Следующяя конфигурация позволяет <code>ibdata1</code> расти до 500MB:
<pre>
[mysqld]
innodb_data_file_path=ibdata1:12M:autoextend:max:500M
</pre>

<p><code>InnoDB</code> создает файлы табличного пространства в каталоге
данных MySQL по умолчанию (<a href="server.htm#sysvar_datadir"><code>datadir
</code></a>). Чтобы определить местоположение явно, используйте опцию
<a href="#sysvar_innodb_data_home_dir"><code>innodb_data_home_dir
</code></a>. Например, чтобы создать два файла
<code>ibdata1</code> и <code>ibdata2</code> в <code>/myibdata</code>:
<pre>
[mysqld]
innodb_data_home_dir = /myibdata
innodb_data_file_path=ibdata1:50M;ibdata2:50M:autoextend
</pre>

<p><code>InnoDB</code> не создает каталоги, так что удостоверьтесь, что
каталог <code>/myibdata</code> существует прежде, чем Вы запустите сервер.
Используйте Unix или DOS <code>mkdir</code>, чтобы создать
любые необходимые каталоги.</p>

<p>Удостоверьтесь, что у сервера MySQL есть надлежащие права доступа, чтобы
создать файлы в каталоге данных. Более широко, у сервера должны быть права
доступа в любом каталоге, где это должно создать файлы с данными.</p>

<p><code>InnoDB</code> формирует путь к каталогу для каждого файла с данными,
дословно добавляя значение
<a href="#sysvar_innodb_data_home_dir"><code>innodb_data_home_dir
</code></a> к имени файла с данными, добавляя разделитель пути (наклонная
черта или наклонная черта влево) между значениями в случае необходимости.
Если опция <a href="#sysvar_innodb_data_home_dir"><code>
innodb_data_home_dir</code></a> не определена в <code>my.cnf</code>
вообще, значение по умолчанию <code>./</code>, что означает каталог данных
MySQL. Сервер MySQL изменяет свой текущий рабочий каталог на свой каталог
данных, когда он начинает выполняться.</p>

<p>Если Вы определяете <a href="#sysvar_innodb_data_home_dir">
<code>innodb_data_home_dir</code></a> как пустую строку, Вы можете определить
абсолютные пути для файлов с данными, перечисленных в
<a href="#sysvar_innodb_data_file_path"><code>innodb_data_file_path
</code></a>. Следующий пример эквивалентен предыдущему:
<pre>
[mysqld]
innodb_data_home_dir =
innodb_data_file_path=/ibdata/ibdata1:50M;/ibdata/ibdata2:50M:autoextend
</pre>

<h4><a name="innodb-startup-log-file-configuration"></a>
Конфигурация файла системного журнала InnoDB</h4>
<p>По умолчанию <code>InnoDB</code> создает два файла системного журнала по
48 МБ в каталоге данных MySQL
(<a href="server.htm#sysvar_datadir"><code>datadir</code></a>) с именами
<code>ib_logfile0</code> и <code>ib_logfile1</code>.</p>

<p>Следующие опции могут использоваться, чтобы изменить
конфигурацию по умолчанию:</p>
<ul><li><p><a href="#sysvar_innodb_log_group_home_dir">
<code>innodb_log_group_home_dir</code></a>
определяет путь к каталогу с файлами системного журнала (redo logs).
Если эта опция не сконфигурирована, файлы создаются в каталоге данных MySQL
(<a href="server.htm#sysvar_datadir"><code>datadir</code></a>).</p>

<p>Вы могли бы использовать эту опцию, чтобы поместить
файлы системного журнала в ином физическом местоположении хранения, чем
файлы с данными, чтобы избежать потенциальных конфликтов ресурса
ввода/вывода. Например:
<pre>
[mysqld]
innodb_log_group_home_dir = /dr3/iblogs
</pre></li>

<li><p><a href="#sysvar_innodb_log_files_in_group"><code>
innodb_log_files_in_group</code></a> определяет число файлов системного
журнала в группе журналов. Значение по умолчанию и рекомендуемое значение 2.
</li>

<li><a href="#sysvar_innodb_log_file_size"><code>
innodb_log_file_size</code></a> определяет размер в байтах каждого файла
системного журнала в группе журналлв. Объединенный размер файлов системного
журнала (<a href="#sysvar_innodb_log_file_size"><code>
innodb_log_file_size</code></a> *
<a href="#sysvar_innodb_log_files_in_group"><code>
innodb_log_files_in_group</code></a>) не может превысить максимальное
значение, которое является немного меньше чем 512GB.
Пара файлов системного журнала по 255 GB, например, приближается к пределу,
но не превышает его. Размер файла системного журнала по умолчанию составляет
48 МБ. Заметные значения колеблются от 4 МБ до
1/<em><code>N</code></em> размера буферного пула, где <em><code>N</code></em>
число файлов системного журнала в группе. Чем больше значение, тем меньше
деятельности потока контрольной точки необходимо в буферном пуле, сохраняя
дисковый ввод/вывод. Для дополнительной информации см.
<a href="optimiz.htm#optimizing-innodb-logging">раздел 9.5.4</a>.
</p></li></ul>

<h4><a name="innodb-startup-undo-tablespace"></a>
Конфигурация табличного пространства отмены InnoDB</h4>
<p>По умолчанию журналы отмены это часть системного табличного пространства.
Однако, Вы можете хотеть хранить их в одном или более отдельных табличных
пространств отмены, как правило, на ином устройстве хранения данных.</p>

<p>Опция <a href="#sysvar_innodb_undo_directory"><code>
innodb_undo_directory</code></a> определяет путь, где <code>InnoDB</code>
создает отдельные табличные пространства для журналов отмены. Эта опция как
правило используется в соединении с
<a href="#sysvar_innodb_undo_logs"><code>
innodb_undo_logs</code></a> и
<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a>, которые определяют дисковое расположение
журналов отмены вне системного табличного пространства.</p>
<p>Подробности в <a href="#innodb-undo-tablespace">разделе 16.7.7
</a>.</p>

<h4><a name="innodb-startup-temporary-tablespace"></a>
Конфигурация временного табличного пространства InnoDB</h4>
<p>По умолчанию <code>InnoDB</code> создает единственный автомасштабируемый
временный файл с данными табличного пространства <code>ibtmp1</code> в
каталоге данных MySQL (<a href="server.htm#sysvar_datadir"><code>datadir
</code></a>) это немного больше, чем 12 МБ. Конфигурация по умолчанию
может быть изменена при запуске, используя
<a href="#sysvar_innodb_temp_data_file_path">
<code>innodb_temp_data_file_path</code></a>.</p>

<p><a href="#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a>
определяет путь, имя файла и размер файла для
временных файлов с данными табличного пространства.
Полный путь к каталогу для файла сформирован, связывая
<a href="#sysvar_innodb_data_home_dir"><code>innodb_data_home_dir
</code></a> с путем, определенным
<a href="#sysvar_innodb_temp_data_file_path"><code>
innodb_temp_data_file_path</code></a>. Размер файла определен в
KB, MB или GB (1024MB), добавляя K, M или G к значению размера.
Сумма размеров файлов должна быть немного больше, чем 12 МБ.</p>

<h4><a name="innodb-startup-page-size"></a>
Конфигурация размера страницы InnoDB</h4>
<p><a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> определяет размер страницы для всех табличных пространств
<code>InnoDB</code>. Это значение установлено, когда экземпляр
создается и остается постоянным позже. Допустимые значения составляют
64k, 32k, 16k (по умолчанию), 8k и 4k. Альтернативно, Вы можете определить
размер страницы в байтах (65536, 32768, 16384, 8192, 4096).</p>

<p>Размер страницы по умолчанию 16k является подходящим для широкого
диапазона рабочих нагрузок, особенно для запросов, вовлекающих сканирование
таблицы и операции DML, вовлекающие оптовые обновления. Меньшие размеры
страницы могли бы быть более эффективными для рабочих нагрузок OLTP,
вовлекающих, многие маленькие записи, где может быть проблемой, когда
единственная страница содержит много строк. Меньшие страницы могли бы также
быть эффективными с устройствами хранения данных SSD, которые, как правило,
используют маленькие размеры блока. Задание размера страницы близким к
размеру блока устройства хранения данных минимизирует количество неизменных
данных, которые переписаны на диск.</p>

<h4><a name="innodb-startup-memory-configuration"></a>
Конфигурация памяти InnoDB</h4>
<p>MySQL выделяет память различным кэшам и буферам, чтобы улучшить исполнение
операций базы данных. Выделяя память для <code>InnoDB</code>,
всегда считайте память требуемую операционной системой, память, выделенную
другим приложениям, и память для других буферов MySQL и кэшей.
Например, если Вы используете таблицы <code>MyISAM</code>,
считайте объем памяти, выделенный для ключевого буфера
(<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code>
</a>). Для краткого обзора буферов MySQL и кэшей см.
<a href="optimiz.htm#memory-use">раздел 9.12.3.1</a>.</p>

<p>Буферы для <code>InnoDB</code>
сконфигурированы, используя следующие параметры:</p>
<ul><li><p><a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> определяет размер буферного пула, который
является областью памяти, которая содержит кэшируемые данные для таблиц
<code>InnoDB</code>, индексов и других вспомогательных буферов. Размер
буферного пула важен для системной работы, и рекомендуют выделить под
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> от 50 до 75 процентов системной памяти.
Буферный размер пула по умолчанию составляет 128MB. Подробности в
<a href="optimiz.htm#memory-use">разделе 9.12.3.1</a>.
Для информации о том, как сконфигурировать размер пула буферного см.
<a href="#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.
Размер пула может быть сконфигурирован при запуске или динамически.</p>

<p>На системах с большим объемом памяти Вы можете улучшить параллелизм, деля
буферный пул на несколько экземпляров. Числом экземпляров пула управляет
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>.
По умолчанию <code>InnoDB</code> создает один буферный экземпляр.
Число экземпляров пула может быть сконфигурировано при запуске. Для получения
дополнительной информации см.
<a href="#innodb-multiple-buffer-pools">раздел 16.6.3.3</a>.</li>

<li><a href="#sysvar_innodb_log_buffer_size"><code>
innodb_log_buffer_size</code></a> определяет размер в байтах буфера,
который <code>InnoDB</code> применяет для записи файлов системного журнала на
диск. Размер по умолчанию составляет 16 МБ. Большой буфер журнала позволяет
большим транзакциям работать без потребности записать журнал на диск прежде,
чем транзакции передадут. Если у Вас есть транзакции, которые обновляют,
вставляют или удаляют много строк, Вы могли бы полагать, что увеличение
размера буфера журнала уменьшит дисковый ввод/вывод.
<a href="#sysvar_innodb_log_buffer_size"><code>
innodb_log_buffer_size</code></a> может быть сконфигурирован при запуске.
Для соответствующей информации см.
<a href="optimiz.htm#optimizing-innodb-logging">раздел 9.5.4</a>.
</p></li></ul>

<p>В 32-bit GNU/Linux x86 не стоит устанавливать использование памяти слишком
большим. <code>glibc</code> может разрешить куче процесса расти по стекам
потока, который разрушает Ваш сервер. Это рискованно, если память, выделенная
процессу <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span>
</a> для глобальных и поточных буферов и кэшей, близка к или превышает 2GB.
</p>

<p>Формула, подобная следующей, которая вычисляет глобальное и поточное
распределение памяти для MySQL, может использоваться, чтобы оценить
использование памяти MySQL. Вы, возможно, должны изменить формулу, чтобы
составлять буферы и кэши в Вашей версии MySQL и конфигурации. Для краткого
обзора буферов MySQL и кэшей см.
<a href="optimiz.htm#memory-use">раздел 9.12.3.1</a>.
<pre>
innodb_buffer_pool_size + key_buffer_size +
   max_connections*(sort_buffer_size+read_buffer_size+binlog_cache_size) +
   max_connections*2MB
</pre>

<p>Каждый поток использует стек (часто 2 МБ, но только 256 КБ в двоичных
модулях MySQL от Oracle Corporation) и в худшем случае также использует
еще <code>sort_buffer_size + read_buffer_size</code> памяти.</p>

<p>В Linux, если ядро настроено для поддержки большой страницы,
<code>InnoDB</code> может использовать большие страницы, чтобы выделить
память для буферного пула. См. <a href="optimiz.htm#large-page-support">
раздел 9.12.3.2</a>.</p>

<h3><a name="innodb-read-only-instance"></a>16.6.2.
Конфигурирование InnoDB для работы только для чтения</h3>
<p>Вы можете теперь запросить таблицы, где каталог данных MySQL находится на
носителе только для чтения, включая опцию
<a href="#sysvar_innodb_read_only"><code>--innodb-read-only</code>
</a> при запуске сервера.</p>

<h4><a name="idm139965329538448"></a>Как это включить</h4>
<p>Чтобы подготовить систему к работе только для чтения, удостоверьтесь, что
вся необходимая информация <a href="glossary.htm#glos_flush">сброшена</a> в
файлы с данными прежде, чем сохранить ее на носителе только для чтения.
Выполните сервер с отключенной буферизацией изменения
(<a href="#sysvar_innodb_change_buffering"><code>
innodb_change_buffering=0</code></a>) и сделайте
<a href="glossary.htm#glos_slow_shutdown">медленную парковку</a>.</p>

<p>Чтобы включить режим только для чтения для всего MySQL,
определите следующие параметры конфигурации при запуске сервера:</p>
<ul><li><p><a href="#sysvar_innodb_read_only"><code>
--innodb-read-only=1</code></a></li>
<li>Если данные на носителе только для чтения, таком как DVD, или каталог
<code>/var</code> недоступен на запись:
<code>--pid-file=<em><code>path_on_writeable_media</code></em></code>
и <code>--event-scheduler=disabled</code>.</p></li></ul>

<p>С MySQL 8.0 включение <a href="#sysvar_innodb_read_only"><code>
innodb_read_only</code></a> блокирует табличные операции создания и удаления
для всех механизмов хранения. Эти операции изменяют таблицы словаря данных в
системной базе данных <code>mysql</code>, но те таблицы использует
механизм хранения <code>InnoDB</code> и не может изменить, когда включена
<a href="#sysvar_innodb_read_only"><code>innodb_read_only</code>
</a>. То же самое ограничение относится к любой работе, которая изменяет
таблицы словаря данных, такой как <a href="sql.htm#analyze-table"><code>
ANALYZE TABLE</code></a> и <a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> ENGINE=<em><code>engine_name</code></em>
</code></a>.</p>

<p>Кроме того, другие таблицы в базе данных <code>mysql</code>
используют механизм хранения <code>InnoDB</code> в MySQL 8.0. Например,
<a href="sql.htm#create-user"><code>CREATE USER</code></a>,
<a href="sql.htm#grant"><code>GRANT</code></a>,
<a href="sql.htm#revoke"><code>REVOKE</code></a> и
<a href="sql.htm#install-plugin"><code>INSTALL PLUGIN</code></a> не
работают в режиме только для чтения.</p>

<h4><a name="idm139965329512960"></a>Сценарии использования</h4>
<p>Этот режим работы является подходящим в таких ситуациях:</p>
<ul><li><p>Распределение приложения MySQL или ряда данных MySQL на носителе
данных только для чтения, таком как DVD или CD.</li>

<li>Многие экземпляры MySQL, запрашивающие тот же самый каталог данных
одновременно, как правило в конфигурации складирования данных.
Вы могли бы использовать этот метод, чтобы избежать
<a href="glossary.htm#glos_bottleneck">бутылочного горлышка</a>, которое
может произойти с в большой степени загруженным сервером MySQL, или Вы могли
бы использовать различные параметры конфигурации для различных случаев, чтобы
настроить каждого для особых видов запросов.</li>

<li>Запросы данных, которые были помещены в статус только для чтения для
безопасности или по причине целостности данных, таких как
заархивированные резервные данные.</p></li></ul>

<p>Эта особенность, главным образом, предназначена для гибкости в
распределении и развертывании, а не сырой работе, основанной на аспекте
только для чтения. См.
<a href="optimiz.htm#innodb-performance-ro-txn">раздел 9.5.3</a>
для способов настроить исполнение запросов только для чтения, которые не
требуют создания всего сервера только для чтения.</p>

<h4><a name="idm139965329505680"></a>Как это работает</h4>
<p>Когда сервер выполнен в режиме только для чтения через
<a href="#sysvar_innodb_read_only"><code>--innodb-read-only</code>
</a>, многие особенности и компоненты <code>InnoDB</code> уменьшены
или выключены полностью:</p>

<ul><li><p><a href="glossary.htm#glos_change_buffering">Буферизация
изменений</a> не сделана, в особенности никакие слияния от буфера изменения.
Чтобы удостовериться, что буфер изменения пуст, когда Вы готовите систему к
работе только для чтения, выключите его
(<a href="#sysvar_innodb_change_buffering"><code>
innodb_change_buffering=0</code></a>) и сделайте
<a href="glossary.htm#glos_slow_shutdown">медленную парковку</a>.</li>

<li>Нет никакой фазы <a href="glossary.htm#glos_crash_recovery">
восстановления катастрофического отказа</a> при запуске.</li>
<li>Поскольку <a href="glossary.htm#glos_redo_log">redo log</a> не
используется в работе только для чтения, Вы можете установить
<a href="#sysvar_innodb_log_file_size"><code>innodb_log_file_size
</code></a> к самому маленькому возможному размеру (1 MB).</li>

<li>Все фоновые потоки кроме потоков чтения ввода/вывода выключены. Как
следствие, случай только для чтения не может столкнуться ни с каким
<a href="glossary.htm#glos_deadlock">тупиком</a>.</li>

<li>Информация о тупиках, вывод монитора и так далее не написана во временные
файлы. Как следствие, <a href="sql.htm#show-engine"><code>SHOW ENGINE
INNODB STATUS</code></a> ничего не покажет.</li>

<li>Изменения настроек параметра конфигурации, которые обычно изменяли бы
поведение операций записи, не имеют никакого эффекта, когда сервер находится
в режиме только для чтения.</li>

<li><a href="glossary.htm#glos_mvcc">MVCC</a> обрабатываемый, чтобы провести
в жизнь <a href="glossary.htm#glos_isolation_level">уровни изоляции</a>
выключен. Все запросы читают последнюю версию записи, потому что
обновление и удаление невозможны.</li>

<li><a href="glossary.htm#glos_undo_log">Журнал отмены</a> не используется.
Отключите любые настройки для опций
<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> и
<a href="#sysvar_innodb_undo_directory"><code>
innodb_undo_directory</code></a>.</p></li></ul>

<h3><a name="innodb-performance-buffer-pool"></a>16.6.3.
Конфигурация буферного пула InnoDB</h3>
<p>Этот раздел обеспечивает конфигурацию буферного
пула <code>InnoDB</code>.</p>

<h4><a name="innodb-buffer-pool"></a>16.6.3.1. Буферный пул InnoDB</h4>
<p><a href="innodb.htm"><code>InnoDB</code></a> поддерживает область
хранения, названную <a href="glossary.htm#glos_buffer_pool">буферным пулом
</a> для того, чтобы кэшировать данные и индексы в памяти. Знание, как
буфер работает и использование в своих интересах его, чтобы сохранить данные,
к которым часто получают доступ, в памяти, важный аспект настройки MySQL.</p>

<p>Вы можете сконфигурировать различные аспекты буферного пула
<code>InnoDB</code>, чтобы улучшить работу.</p>
<ul><li><p>Идеально Вы устанавливаете размер буферного пула к столь большому
значению как возможно, оставляя достаточную память для других процессов на
сервере, чтобы работать без чрезмерных проблем. Чем больше буферный пул, тем
больше <code>InnoDB</code> работает как база данных в памяти, читая данные с
диска однажды и затем получая доступ к данным в памяти во время последующих
чтений. См. <a href="#innodb-buffer-pool-resize">раздел 16.6.3.2
</a>.</li>

<li>С 64-битовыми системами с большими размерами памяти Вы можете разделить
буферный пул на многие части, чтобы минимизировать содержимое
для структур памяти среди параллельных операций. Для деталей см.
<a href="#innodb-multiple-buffer-pools">раздел 16.6.3.3</a>.</li>

<li>Вы можете сохранить данные, к которым часто получают доступ, в памяти,
несмотря на пики деятельности для операций, таких как резервные копии или
сообщение. Для деталей см.
<a href="#innodb-performance-midpoint_insertion">раздел 16.6.3.4
</a>.</li>

<li>Вы можете управлять когда и как <code>InnoDB</code> выполняет
предвыборки и предварительно принести страницы в буферный пул асинхронно, в
ожидании, что страницы скоро будут необходимы. Для деталей см.
<a href="#innodb-performance-read_ahead">раздел 16.6.3.5</a>.</li>

<li>Вы можете управлять, когда фоновый сброс грязных страниц происходит и
действительно ли <code>InnoDB</code> динамически корректирует уровень сброса,
исходя из рабочей нагрузки. Для деталей см.
<a href="#innodb-performance-adaptive_flushing">раздел 16.6.3.6
</a>.</li>

<li>Вы можете точно настроить аспекты <code>InnoDB</code>, чтобы улучшить
работу. Для деталей см. <a href="#innodb-lru-background-flushing">
раздел 16.6.3.7</a>.</li>

<li>Вы можете сконфигурировать как <code>InnoDB</code> сохраняет текущее
состояние буферного пула, чтобы избежать длинного периода разминки после
перезапуска сервера. Вы можете также сохранить текущее состояние
пула, в то время как сервер работает. Для деталей см.
<a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.
</p></li></ul>

<h5><a name="innodb-buffer-pool-lru"></a>Алгоритм InnoDB LRU</h5>
<p><code>InnoDB</code> управляет буферным пулом как списком, используя
вариант последнего использованного алгоритма (LRU). Когда нужно место, чтобы
добавить новую страницу к пулу, <code>InnoDB</code> вычеркивает последнюю
использованную страницу и добавляет новую страницу к середине списка. Эта
<span><span>вставка в середину</span></span> обрабатывает список
как два подсписка:</p>

<ul><li><p>В начальном подсписке <span><span>новые</span></span> (или
<span><span>молодые</span></span>) страницы, к которым
недавно получили доступ.</li>
<li>В хвостовом подсписке <span><span>старые</span></span>, к которым
получили доступ достаточно давно.</p></li></ul>

<p>Этот алгоритм сохраняет страницы, которые в большой степени используются
запросами в новом подсписке. Старый подсписок содержит менее используемые
страницы, эти страницы кандидаты на
<a href="glossary.htm#glos_eviction">вычеркивание</a>.</p>

<p>Алгоритм LRU работает следующим образом по умолчанию:</p>
<ul><li><p>3/8 буферного пула посвящены старому подсписку.</li>
<li>Середина списка это граница, где хвост нового подсписка
встречает голову старого.</li>

<li>Когда <code>InnoDB</code> читает страницу в буферный пул, это
первоначально вставляет это в середину (голова старого подсписка).
Страница может быть считана потому, что она требуется для определенной
пользователем работы, такой как запрос SQL, или как часть работы
<a href="glossary.htm#glos_read_ahead">предвыборки</a>,
выполненной автоматически <code>InnoDB</code>.</li>

<li>Доступ к странице в старом подсписке делает ее
<span><span>новой</span></span>, перемещая ее к началу буферного пула (голова
нового подсписка). Если страница была считана потому, что она требовалась,
первый доступ происходит немедленно, и страница становится молодой сразу.
Если страница была считана в порядке предвыборки, первый доступ немедленно не
происходит (и мог бы не произойти вообще).</li>

<li>Поскольку база данных работает, страницы в буферном пуле, к которым не
получают доступ <span><span>устаревают</span></span>, перемещаясь к хвосту
списка. Страницы в новом и в старом подсписках могут быть сделаны новыми.
Страницы в старом подсписке также стареют, как страницы, вставленные в
середине. В конечном счете, страница, которая остается неиспользованной
довольно долго, достигает хвоста старого подсписка и вычеркивается.
</p></li></ul>

<p>По умолчанию, страницы, считанные запросами немедленно, перемещаются в
новый подсписок, означая, что они будут оставаться в буферном пуле в течение
долгого времени. Сканирование таблицы (такое, как выполнено для
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
или <code>SELECT</code> без <code>WHERE</code>)
может принести большой объем данных в буферный пул и выдавить эквивалентное
количество более старых данных, даже если новые данные никогда не
используются снова. Точно так же страницы, которые загружены фоновым потоком
предвыборки, к которым затем получен доступ только однажды, перемещены в
начало нового списка. Эти ситуации могут продвинуть часто используемые
страницы к старому подсписку, где они становятся кандидатами на вычеркивание.
Для информации об оптимизации этого поведения см. разделы
<a href="#innodb-performance-midpoint_insertion">16.6.3.4</a> и
<a href="#innodb-performance-read_ahead">16.6.3.5</a>.</p>

<p><code>InnoDB</code> Standard Monitor выводит содержимое нескольких полей
в разделе <code>BUFFER POOL AND MEMORY</code>, которые принадлежат работе
алгоритма LRU буферного пула. Для деталей см.
<a href="#innodb-buffer-pool-monitoring">раздел 16.6.3.9</a>.</p>

<h5><a name="innodb-buffer-pool-config-options"></a>
Параметры конфигурации буферов InnoDB</h5>
<p>Несколько параметров конфигурации затрагивают различные аспекты
буферного пула <code>InnoDB</code>.</p>

<ul><li><p><a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a></p>
<p>Определяет размер буферного пула. Если буферный пул является небольшим, и
у Вас есть достаточная память, пул большего размера может улучшить работу,
уменьшая количество дискового ввода/вывода, необходимого для доступа запросов
к таблицам <a href="innodb.htm"><code>InnoDB</code></a>. Опция
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> является динамической, что позволяет Вам
сконфигурировать размер, не перезапуская сервер. См.
<a href="#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.</li>

<li><code>innodb_buffer_pool_chunk_size</code></p>
<p>Определяет размер куска для изменения размера пула. См.
<a href="#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a></p>
<p>Делит буферный пул на пользовательское конкретное количество отдельных
областей, каждая с его собственным списком LRU и связанными структурами
данных, чтобы уменьшить издержки во время параллельного чтения памяти.
Эта опция вступает в силу только, когда Вы устанавливаете
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> к значению 1GB или больше. Полный размер,
который Вы определяете, разделен среди всех буферных пулов. Для лучшей
эффективности, определите комбинацию
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> и
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> так, чтобы каждый экземпляр буферного пула
составил по крайней мере 1 гигабайт. См.
<a href="#innodb-multiple-buffer-pools">раздел 16.6.3.3</a>.</li>

<li><a href="#sysvar_innodb_old_blocks_pct"><code>
innodb_old_blocks_pct</code></a></p>
<p>Определяет приблизительный процент буферного пула, который
<code>InnoDB</code> использует для старого подсписка блока. Диапазон значений
от 5 до 95. Значение по умолчанию 37 (то есть, 3/8 пула). См.
<a href="#innodb-performance-midpoint_insertion">раздел 16.6.3.4
</a>.</li>

<li><a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a></p>
<p>Определяет, сколько времени в миллисекундах (ms) страница, вставленная в
старый <a href="glossary.htm#glos_sublist">подсписок</a>, должна остаться
там после первого доступа к ней прежде, чем сможет быть перемещена в новый
подсписок. Если значение 0, страница, вставленная в старый подсписок,
немедленно перемещается в новый подсписок в первый раз, когда к ней получают
доступ, независимо от того, как быстро после вставки доступ происходит.
Если значение больше 0, страницы остаются в старом подсписке, пока доступ не
происходит, по крайней мере, столько миллисекунд после первого доступа.
Например, значение 1000 предписывает страницам остаться в старом подсписке
в течение 1 секунды после первого доступа прежде, чем они смогут
переместиться в новый подсписок.</p>

<p>Установка <a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a> больше 0
препятствует тому, чтобы одноразовое сканирование таблицы затопило новый
подсписок страницами, используемыми только для просмотра.
К строкам страницы для просмотра получают доступ много раз в быстрой
последовательности, но страница не использована после этого. Если
<a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a> установлен в значение больше, чем время
обработки страницы, эта страница остается в <span><span>старом</span></span>
и сдвигается к хвосту списка, который будет выселен быстро. Этим путем
страницы, используемые только для одноразового просмотра, не действуют в
ущерб в большой степени используемым страницам в новом подсписке.</p>

<p><a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a> может быть установлен во время выполнения,
таким образом, Вы можете изменить его временно, выполняя такие операции, как
сканирование таблицы и дампы:
<pre>
SET GLOBAL innodb_old_blocks_time = 1000;
<em><code>... perform queries that scan tables ...</code></em>
SET GLOBAL innodb_old_blocks_time = 0;
</pre>

<p>Эта стратегия не применяется, если Ваше намерение
<span><span>нагреть</span></span> буферный пул, заполняя его контентом
таблицы. Например, оценочные испытания часто выполняют сканирование
таблицу или индекса при запуске сервера, потому что те данные обычно были бы
в буферном пуле после периода нормальной эксплуатации. В этом случае
установите <a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a> в 0, по крайней мере пока
идет фаза разминки.</p>
<p>См. <a href="#innodb-performance-midpoint_insertion">раздел
16.6.3.4</a>.</li>

<li><a href="#sysvar_innodb_read_ahead_threshold"><code>
innodb_read_ahead_threshold</code></a></p>
<p>Управляет чувствительностью линейной
<a href="glossary.htm#glos_read_ahead">предвыборки</a>, чтобы предварительно
принести страницы в <a href="glossary.htm#glos_buffer_pool">буферный пул
</a>.</p>
<p>См. <a href="#innodb-performance-read_ahead">раздел 16.6.3.5
</a>.</li>

<li><a href="#sysvar_innodb_random_read_ahead"><code>
innodb_random_read_ahead</code></a></p>
<p>Включает случайный метод <a href="glossary.htm#glos_read_ahead">
предвыборки</a> страниц в буферный пул. Случайное чтение это
метод, который предсказывает, какие страницы могли бы скоро быть необходимы,
основываясь на страницах, которые уже в буферном пуле, независимо от порядка,
в котором были считаны те страницы.
<a href="#sysvar_innodb_random_read_ahead"><code>
innodb_random_read_ahead</code></a> отключен по умолчанию. См.
<a href="#innodb-performance-read_ahead">раздел 16.6.3.5</a>.</li>

<li><a href="#sysvar_innodb_adaptive_flushing"><code>
innodb_adaptive_flushing</code></a></p>
<p>Определяет, скорректировать ли динамически уровень сброса
flushing <a href="glossary.htm#glos_dirty_page">грязных страниц</a>
в буферном пуле, основываясь на рабочей нагрузке. Корректировка уровня потока
динамически предназначена, чтобы избежать взрывов деятельности ввода/вывода.
Эта установка включена по умолчанию. См.
<a href="#innodb-performance-adaptive_flushing">раздел 16.6.3.6
</a>.</li>

<li><a href="#sysvar_innodb_adaptive_flushing_lwm"><code>
innodb_adaptive_flushing_lwm</code></a></p>
<p>Нижний процент <a href="glossary.htm#glos_redo_log">redo log</a>,
при котором <a href="glossary.htm#glos_adaptive_flushing">адаптивный сброс
</a> включен. См. <a href="#innodb-lru-background-flushing">раздел
16.6.3.7</a>.</li>

<li><a href="#sysvar_innodb_flush_neighbors"><code>
innodb_flush_neighbors</code></a></p>
<p>Определяет, сбрасывают ли страницы из буферного пула другие
<a href="glossary.htm#glos_dirty_page">грязные страницы</a> в том
же самом <a href="glossary.htm#glos_extent">экстенте</a>. См.
<a href="#innodb-lru-background-flushing">раздел 16.6.3.7</a>.</li>

<li><a href="#sysvar_innodb_flushing_avg_loops"><code>
innodb_flushing_avg_loops</code></a></p>
<p>Число итераций, для которых InnoDB сохраняет ранее сделанный снимок
состояния сброса, управляя, как быстро
<a href="glossary.htm#glos_adaptive_flushing">адаптивный сброс</a> отвечает
на изменяющиеся <a href="glossary.htm#glos_workload">рабочие нагрузки</a>.
См. <a href="#innodb-lru-background-flushing">раздел 16.6.3.7</a>.
</li>

<li><a href="#sysvar_innodb_lru_scan_depth"><code>
innodb_lru_scan_depth</code></a></p>
<p>Параметр, который влияет на алгоритмы и эвристику для работы
<a href="glossary.htm#glos_flush">сброса</a> для буферного пула. Прежде
всего интересен для исполнительных экспертов, настраивающих рабочие нагрузки
I/O. Это определяет как далеко вниз поток <code>page_cleaner</code> сканирует
буферный пул LRU в поисках <a href="glossary.htm#glos_dirty_page">грязных
страниц</a> для сброса. См.
<a href="#innodb-lru-background-flushing">раздел 16.6.3.7</a>.</li>

<li><a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a></p>
<p><code>InnoDB</code> старается <a href="glossary.htm#glos_flush">сбросить
</a> данные из буферного пула так, чтобы процент
<a href="glossary.htm#glos_dirty_page">грязных страниц</a>
не превысил это значение. Определите целое число в диапазоне от 0 до 99.
Значение по умолчанию 75. См.
<a href="#innodb-performance-adaptive_flushing">раздел 16.6.3.6
</a>.</li>

<li><a href="#sysvar_innodb_max_dirty_pages_pct_lwm"><code>
innodb_max_dirty_pages_pct_lwm</code></a></p>
<p>Нижний уровень (в процентах)
<a href="glossary.htm#glos_dirty_page">грязных страниц</a>, где
предварительному сбросу позволяют управлять отношением грязных страниц.
Значение по умолчанию 0 отключает предварительно это поведение полностью.</p>
<p>См. <a href="#innodb-lru-background-flushing">раздел 16.6.3.7
</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_filename"><code>
innodb_buffer_pool_filename</code></a></p>
<p>Определяет название файла, который хранит список ID табличного
пространства и страницы, произведенный
<a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a> или
<a href="#sysvar_innodb_buffer_pool_dump_now"><code>
innodb_buffer_pool_dump_now</code></a>. См.
<a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a></p>
<p>Определяет, сделать ли запись страниц, кэшируемых в буферном пуле, когда
сервер MySQL закрыт, чтобы сократить процесс следующего перезапуска.
См. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_load_at_startup"><code>
innodb_buffer_pool_load_at_startup</code></a></p>
<p>Определяет, что на запуске сервера MySQL буферный пул автоматически
<a href="glossary.htm#glos_warm_up">подогревается</a>, загружая те же самые
страницы, которые это содержало в более раннее время.
Как правило, используется в комбинации с
<a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a>. См.
<a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_dump_now"><code>
innodb_buffer_pool_dump_now</code></a></p>
<p>Немедленно делает запись страниц, кэшируемых в буферном пуле. См.
<a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_load_now"><code>
innodb_buffer_pool_load_now</code></a></p>
<p>Немедленно <a href="glossary.htm#glos_warm_up">нагревает</a>
буферный пул, загружая ряд страниц данных, не ожидая перезапуска сервера.
Может быть полезно, чтобы возвратить кэш-память к известному статусу
во время сопоставительного анализа или к готовому серверу MySQL, чтобы
возобновить его нормальную рабочую нагрузку после выполнения запросов для
отчетов или обслуживания. Как правило используется с
<a href="#sysvar_innodb_buffer_pool_dump_now"><code>
innodb_buffer_pool_dump_now</code></a>. См.
<a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_dump_pct">
<code>innodb_buffer_pool_dump_pct</code></a></p>
<p>Определяет процент последний раз используемых страниц для каждого
буферного пула для сброса. Диапазон от 1 до 100. См.
<a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</li>

<li><a href="#sysvar_innodb_buffer_pool_load_abort"><code>
innodb_buffer_pool_load_abort</code></a></p>
<p>Прерывает процесс восстановления
<a href="glossary.htm#glos_buffer_pool">буферного</a> содержимого, вызванный
<a href="#sysvar_innodb_buffer_pool_load_at_startup"><code>
innodb_buffer_pool_load_at_startup</code></a> или
<a href="#sysvar_innodb_buffer_pool_load_now"><code>
innodb_buffer_pool_load_now</code></a>. См.
<a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.
</p></li></ul>

<h4><a name="innodb-buffer-pool-resize"></a>16.6.3.2.
Конфигурирование размера буферного пула InnoDB</h4>
<p>Вы можете сконфигурировать размер буферного пула офлайн (при запуске) или
онлайн в то время, как сервер работает. Поведение, описанное в этом разделе,
относится к обоим методам.</p>

<p>Увеличивая или уменьшая
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> работа выполняется кусками. Размер куска
определен параметром конфигурации
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>, у которого есть
значение по умолчанию <code>128M</code>.</p>

<p>Размер пула должен всегда быть равным или кратным числу
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> *
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>. Если Вы конфигурируете
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> к значению, которое не равно или кратно
числу <a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> *
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>, размер пула автоматически
скорректирован к значению, которое равно или кратно этому числу, но
не меньше чем указанный буферный размер пула.</p>

<p>В следующем примере <a href="#sysvar_innodb_buffer_pool_size">
<code>innodb_buffer_pool_size</code></a> установлен в <code>8G</code>, и
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> установлен в <code>16</code>.
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> <code>128M</code>,
что является значением по умолчанию.</p>

<p><code>8G</code> допустимое значение
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>, потому что <code>8G</code> кратно
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances=16</code></a> *
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size=128M</code></a>, которое <code>2G</code>.
<pre>
shell&gt; mysqld --innodb_buffer_pool_size=8G
                 --innodb_buffer_pool_instances=16
mysql&gt; SELECT @@innodb_buffer_pool_size/1024/1024/1024;
+------------------------------------------+
| @@innodb_buffer_pool_size/1024/1024/1024 |
+------------------------------------------+
|   8.000000000000                         |
+------------------------------------------+
</pre>

<p>В этом примере <a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> установлен в <code>9G</code> и
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> установлен в <code>16</code>.
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> <code>128M</code>, что является
значением по умолчанию. В этом случае <code>9G</code> не кратно
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances=16</code></a> *
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size=128M</code></a>, так что
<a href="#sysvar_innodb_buffer_pool_size">
<code>innodb_buffer_pool_size</code></a> скорректирован к <code>10G</code>,
что является следующим числом, кратным
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> *
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>, но не меньше чем
указанный размер пула.
<pre>
shell&gt; mysqld --innodb_buffer_pool_size=9G
                 --innodb_buffer_pool_instances=16
mysql&gt; SELECT @@innodb_buffer_pool_size/1024/1024/1024;
+------------------------------------------+
| @@innodb_buffer_pool_size/1024/1024/1024 |
+------------------------------------------+
|  10.000000000000                         |
+------------------------------------------+
</pre>

<h5><a name="innodb-buffer-pool-chunk-size"></a>
Конфигурирование размера куска буфера InnoDB</h5>
<p><a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> может быть увеличен или уменьшен с
шагом в 1MB (1048576 байт), но может быть изменен только при запуске в
командной строки или в конфигурационном файле MySQL.</p>

<p>Командная строка:
<pre>
shell&gt; mysqld --innodb_buffer_pool_chunk_size=134217728
</pre>

<p>Конфигурационный файл:
<pre>
[mysqld]
innodb_buffer_pool_chunk_size=134217728
</pre>

<p>Следующие условия применяются, изменяя
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>:</p>

<ul><li><p>Если новое значение
If the new <a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> *
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> больше, чем текущий буферный размер
пула, когда буферный пул инициализирован,
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> является усеченным к
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> /
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>.</p>

<p>Например, если буферный пул инициализирован с размером
<code>2GB</code> (2147483648 байт), <code>4</code> экземплярами
пула и размером куска <code>1GB</code> (1073741824 байт),
размер куска является усеченным к значению, равному
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> /
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>, как показано ниже:
<pre>
shell&gt; mysqld --innodb_buffer_pool_size=2147483648
                 --innodb_buffer_pool_instances=4
                 --innodb_buffer_pool_chunk_size=1073741824;

mysql&gt; SELECT @@innodb_buffer_pool_size;
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|  2147483648               |
+---------------------------+

mysql&gt; SELECT @@innodb_buffer_pool_instances;
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
| 4                              |
+--------------------------------+

# Chunk size was set to 1GB (1073741824 bytes) on startup but was
# truncated to innodb_buffer_pool_size / innodb_buffer_pool_instances

mysql&gt; SELECT @@innodb_buffer_pool_chunk_size;
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|   536870912                     |
+---------------------------------+
</pre></li>

<li>Буферный размер пула должен всегда быть равным или кратным
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> *
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>. Если Вы изменяете
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>,
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> автоматически скорректирован к значению,
которое равно или кратно
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> *
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>
не меньше, чем текущий буферный размер пула. Корректировка происходит, когда
буферный пул инициализирован. Это поведение
продемонстрировано в следующем примере:
<pre>
# The buffer pool has a default size of 128MB (134217728 bytes)

mysql&gt; SELECT @@innodb_buffer_pool_size;
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|   134217728               |
+---------------------------+

# The chunk size is also 128MB (134217728 bytes)

mysql&gt; SELECT @@innodb_buffer_pool_chunk_size;
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|   134217728                     |
+---------------------------------+

# There is a single buffer pool instance

mysql&gt; SELECT @@innodb_buffer_pool_instances;
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
| 1                              |
+--------------------------------+

# Chunk size is decreased by 1MB (1048576 bytes) at startup
# (134217728 - 1048576 = 133169152):

shell&gt; mysqld --innodb_buffer_pool_chunk_size=133169152
mysql&gt; SELECT @@innodb_buffer_pool_chunk_size;
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|   133169152                     |
+---------------------------------+

# Buffer pool size increases from 134217728 to 266338304
# Buffer pool size is automatically adjusted to a value that is equal to
# or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances
# that is not less than current buffer pool size

mysql&gt; SELECT @@innodb_buffer_pool_size;
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|   266338304               |
+---------------------------+
</pre>

<p>Этот пример демонстрирует то же самое поведение, но с несколькими
экземплярами буферного пула:
<pre>
# The buffer pool has a default size of 2GB (2147483648 bytes)

mysql&gt; SELECT @@innodb_buffer_pool_size;
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|  2147483648               |
+---------------------------+

# The chunk size is .5 GB (536870912 bytes)

mysql&gt; SELECT @@innodb_buffer_pool_chunk_size;
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|   536870912                     |
+---------------------------------+

# There are 4 buffer pool instances

mysql&gt; SELECT @@innodb_buffer_pool_instances;
+--------------------------------+
| @@innodb_buffer_pool_instances |
+--------------------------------+
| 4                              |
+--------------------------------+

# Chunk size is decreased by 1MB (1048576 bytes) at startup
# (536870912 - 1048576 = 535822336):

shell&gt; mysqld --innodb_buffer_pool_chunk_size=535822336
mysql&gt; SELECT @@innodb_buffer_pool_chunk_size;
+---------------------------------+
| @@innodb_buffer_pool_chunk_size |
+---------------------------------+
|   535822336                     |
+---------------------------------+

# Buffer pool size increases from 2147483648 to 4286578688
# Buffer pool size is automatically adjusted to a value that is equal to
# or a multiple of innodb_buffer_pool_chunk_size * innodb_buffer_pool_instances
# that is not less than current buffer pool size of 2147483648

mysql&gt; SELECT @@innodb_buffer_pool_size;
+---------------------------+
| @@innodb_buffer_pool_size |
+---------------------------+
|  4286578688               |
+---------------------------+
</pre>

<p>Забота должна быть проявлена, изменяя
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>, поскольку это значение может
увеличить размер буферного пула, как показано в примерах выше. Прежде чем Вы
измените <a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>, вычислите эффект, который это будет
иметь на <a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>, чтобы гарантировать, что получающийся
размер пула является приемлемым.</p></li></ul>

<p>Чтобы избежать потенциальных исполнительных проблем, число кусков
(<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> /
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>) не должно превышать 1000.</p>

<h5><a name="innodb-buffer-pool-online-resize"></a>
Конфигурирование буфера InnoDB Online</h5>
<p>Опция <a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> может быть установлена динамически,
используя командой <a href="types.htm#set"><code>SET</code></a>, разрешая Вам
изменить размеры буферного пула, не перезапуская сервер. Например:
<pre>
mysql&gt; SET GLOBAL innodb_buffer_pool_size=402653184;
</pre>

<p>Активные транзакции и операции через <code>InnoDB</code> API
должны быть завершены прежде, чем изменить размеры буферного пула. Начиная
изменение размера, работа не запускается, пока все активные транзакции не
завершены. Как только работа по изменению размеров началась, новые
транзакции и операции, которые требуют доступа к буферному пулу, ждут, пока
работа не закончится. Исключение: параллельный доступ к буферному пулу
разрешен в то время, когда буферный пул дефрагментируется.
Недостаток разрешения параллельного доступа состоит в том, что это может
привести к временной нехватке доступных страниц, в то время
как страницы удаляются.</p>
<p>Вложенные транзакции могут отвалиться, если начаты после того, как
началась работа по изменению размера буфера.</p>

<h5><a name="innodb-buffer-pool-online-resize-monitoring"></a>
Контроль изменения размера пула</h5>
<p><a href="server.htm#statvar_Innodb_buffer_pool_resize_status"><code>
Innodb_buffer_pool_resize_status</code></a> сообщает о ходе изменения
размеров буферного пула:
<pre>
mysql&gt; SHOW STATUS WHERE Variable_name='InnoDB_buffer_pool_resize_status';
+----------------------------------+----------------------------------+
| Variable_name                    | Value                            |
+----------------------------------+----------------------------------+
| Innodb_buffer_pool_resize_status | Resizing also other hash tables. |
+----------------------------------+----------------------------------+
</pre>

<p>Это также зарегистрировано в файле журнала ошибок сервера. Этот пример
показывает записи, которые зарегистрированы, увеличивая
размер буферного пула:
<pre>
[Note] InnoDB: Resizing buffer pool from 134217728 to 4294967296. (unit=134217728)
[Note] InnoDB: disabled adaptive hash index.
[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was added.
[Note] InnoDB: buffer pool 0 : hash tables were resized.
[Note] InnoDB: Resized hash tables at lock_sys, dictionary.
[Note] InnoDB: completed to resize buffer pool from 134217728 to 4294967296.
[Note] InnoDB: re-enabled adaptive hash index.
</pre>

<p>Этот пример показывает записи, которые зарегистрированы, уменьшая
размер буферного пула:
<pre>
[Note] InnoDB: Resizing buffer pool from 4294967296 to 134217728. (unit=134217728)
[Note] InnoDB: disabled adaptive hash index.
[Note] InnoDB: buffer pool 0 : start to withdraw the last 253952 blocks.
[Note] InnoDB: buffer pool 0 : withdrew 253952 blocks from free list. tried to relocate 0 pages.
(253952/253952)
[Note] InnoDB: buffer pool 0 : withdrawn target 253952 blocks.
[Note] InnoDB: buffer pool 0 : 31 chunks (253952 blocks) was freed.
[Note] InnoDB: buffer pool 0 : hash tables were resized.
[Note] InnoDB: Resized hash tables at lock_sys, dictionary.
[Note] InnoDB: completed to resize buffer pool from 4294967296 to 134217728.
[Note] InnoDB: re-enabled adaptive hash index.
</pre>

<h5><a name="innodb-buffer-pool-online-resize-internals"></a>
Как происходит изменение</h5>
<p>Работа изменения размеров выполнена фоновым потоком.
Увеличивая размер буферного пула:</p>

<ul><li><p>Добавляются страницы в <code>кусок</code> (размер куска определен
<a href="#sysvar_innodb_buffer_pool_chunk_size">
<code>innodb_buffer_pool_chunk_size</code></a>).</li>

<li>Хэш-таблицы, списки и указатели преобразованы, чтобы использовать
новые адреса в памяти.</li>
<li>Добавляются новые страницы к свободному списку.</p></li></ul>

<p>В то время как эти операции происходят, другие потоки заблокированы на
доступ к буферному пулу.</p>
<p>Уменьшение размера буферного пула:</p>
<ul><li><p>Дефрагментация пула и освобождение страниц.</li>

<li>Удаление страниц в <code>куске</code> (размер куска определен
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>).</li>
<li>Хэш-таблицы, списки и указатели преобразованы, чтобы использовать
новые адреса в памяти.</p></li></ul>
<p>Из этих операций только дефрагментация и удаление
страниц позволяют другим потокам доступ к буферному пулу одновременно.</p>

<h4><a name="innodb-multiple-buffer-pools"></a>16.6.3.3.
Конфигурирование многих буферных экземпляров</h4>
<p>Для систем с буферными пулами в диапазоне нескольких гигабайт
деление буферного пула на отдельные экземпляры может улучшить параллелизм,
уменьшая столкновения потоков при доступе к кэшируемым страницам.
Эта особенность как правило предназначается для систем с
многогигабайтным <a href="glossary.htm#glos_buffer_pool">буфером</a>.
Многократные буферные экземпляры сконфигурированы, используя опцию
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>, и Вы могли бы также корректировать
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>.</p>

<p>Когда буферный пул является большим, много запросов данных могут быть
удовлетворены, получая из памяти. Вы могли бы столкнуться с узкими местами от
многократных потоков, пытающихся получить доступ к буферному пулу сразу. Вы
можете позволить многим буферным пулам минимизировать это.
Каждая страница, которая сохранена в (или считана из) буферного пула,
назначена на один из буферных пулов беспорядочно, используя хеширующую
функцию. Каждый буферный пул управляет своими собственными свободными
списками, списками потока, LRU и всеми другими структурами данных,
соединенными с буферным пулом. До MySQL 8.0 каждый буферный пул был защищен
его собственным mutex. В MySQL 8.0 и позже mutex был заменен несколькими
списками и хешем, чтобы уменьшить накладные расходы.</p>

<p>Чтобы включить многократные буферы, установите опцию
<code>innodb_buffer_pool_instances</code> к значению больше 1 (значение по
умолчанию), но до 64 (максимум).
Эта опция вступает в силу только, когда Вы устанавливаете
<code>innodb_buffer_pool_size</code> к размеру 1GB или больше.
Полный размер, который Вы определяете, разделен среди всех буферных пулов.
Для лучшей эффективности, определите комбинацию
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>
и <a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> так, чтобы каждый экземпляр буфера
был по крайней мере в 1GB.</p>
<p>Для информации об изменении размера буфера <code>InnoDB</code> см.
<a href="#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.</p>

<h4><a name="innodb-performance-midpoint_insertion"></a>16.6.3.4.
Создание стойкого к сканированию буферного пула</h4>
<p>Вместо того, чтобы использовать строгий алгоритм
<a href="glossary.htm#glos_lru">LRU</a> <code>InnoDB</code>
использует метод, чтобы минимизировать объем данных, который принесен в
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>, но не используется
никогда больше. Цель состоит в том, чтобы удостовериться, что часто
используемые (<span><span>горячие</span></span>) страницы
остаются в буферном пуле, как раз когда
<a href="glossary.htm#glos_read_ahead">предвыборка</a> и
<a href="glossary.htm#glos_full_table_scan">полное сканирование таблицы</a>
вводят новые блоки, которые не факт, что будут использованы позже.</p>

<p>Недавно считанные блоки вставлены в середину списка LRU. Все недавно
прочитанные страницы вставлены в место, которое по умолчанию занимает место в
<code>3/8</code> от хвоста списка LRU. Страницы перемещены в начало списка,
когда к ним получают доступ в буферном пуле впервые.
Таким образом, страницы, к которым никогда не получают доступ, никогда не
добираются до передней части списка LRU и вычеркиваются
скорее, чем со строгим подходом LRU. Это расположение делит список LRU на два
сегмента, где страницы сдвигаются вниз от точки вставки.</p>

<p>Для объяснения внутренних работ буферного пула <code>InnoDB</code>
и специфических особенностей алгоритма LRU см.
<a href="#innodb-buffer-pool">раздел 16.6.3.1</a>.</p>

<p>Вы можете управлять точкой вставки в списке LRU и выбрать
применяет ли <code>InnoDB</code> ту же самую оптимизацию к блокам,
принесенным в буферный пул просмотром таблицы или индекса. Параметр
конфигурации <a href="#sysvar_innodb_old_blocks_pct"><code>
innodb_old_blocks_pct</code></a> управляет процентом
<span><span>старых</span></span> блоков в списке LRU. Значение по умолчанию
<a href="#sysvar_innodb_old_blocks_pct"><code>innodb_old_blocks_pct
</code></a> <code>37</code> соответствует оригинальному отношению 3/8.
Диапазон значения от <code>5</code> (новые страницы в буфере стареют очень
быстро) до <code>95</code> (только 5% буферного пула сохранены для горячих
страниц, делая алгоритм близким к знакомой стратегии LRU).</p>

<p>Оптимизация, которая препятствует буферному пулу взбалтываться
предвыборкой, может избежать подобных проблем из-за просмотров таблицы или
индекса. В этих просмотрах к странице данных как правило получают доступ
несколько раз в быстрой последовательности и никогда не затрагивают ее снова.
Параметр конфигурации <a href="#sysvar_innodb_old_blocks_time">
<code>innodb_old_blocks_time</code></a> определяет окно времени (в
миллисекундах) после первого доступа к странице, во время которого к ней
можно получить доступ, не перемещая ее в начало списка LRU.
Значение по умолчанию <a href="#sysvar_innodb_old_blocks_time">
<code>innodb_old_blocks_time</code></a> <code>1000</code>. Увеличение этого
значения делает все больше блоков стареющими быстро.</p>

<p><a href="#sysvar_innodb_old_blocks_pct"><code>
innodb_old_blocks_pct</code></a> и
<a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a>
являются динамическими, глобальными и может быть определены в файле опции
MySQL (<code>my.cnf</code> или <code>my.ini</code>)
или изменены во время выполнения через <code>SET GLOBAL</code>.
Изменение настроек требует привилегии <code>SUPER</code>.</p>

<p>Помочь Вам измерить эффект этих параметров может отчет команды
<code>SHOW ENGINE INNODB STATUS</code> о буферной статистике пула.
Для деталей см. <a href="#innodb-buffer-pool-monitoring">раздел
16.6.3.9</a>.</p>

<p>Поскольку эффекты этих параметров могут значительно различаться в
зависимости от Вашей конфигурации аппаратных средств, Ваших данных и деталей
Вашей рабочей нагрузки, всегда определяйте эффективность, чтобы проверить
что получилось прежде, чем изменить эти настройки в любой критической по
отношению к работе или производственной среде.</p>

<p>В смешанных рабочих нагрузках, где большая часть деятельности OLTP с
с периодическими запросами сообщения пакета, которые приводят к большим
просмотрам, установка значения
<a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a> во время пакетных выполнений может помочь
сохранить рабочий набор нормальной рабочей нагрузки в буферном пуле.</p>

<p>Просматривая большие таблицы, которые не могут поместиться полностью в
буферном пуле, установите
<a href="#sysvar_innodb_old_blocks_pct"><code>innodb_old_blocks_pct
</code></a> к маленькому значению, чтобы не дать данным, которые только
считаны однажды, заполнить весь буфер. Например, установка
<code>innodb_old_blocks_pct=5</code> ограничивает эти данные 5%
размера буферного пула.</p>

<p>Когда просматриваете маленькие таблицы, которые действительно вписываются
в память, уменьшите накладные расходы на перемещение страниц в буфере,
установив <a href="#sysvar_innodb_old_blocks_pct"><code>
innodb_old_blocks_pct</code></a> в его значение по умолчанию или еще выше,
например, <code>innodb_old_blocks_pct=50</code>.</p>

<p>Эффект изменения <a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a> предсказать трудней, чем
<a href="#sysvar_innodb_old_blocks_pct"><code>
innodb_old_blocks_pct</code></a>, так как он
изменяется больше с рабочей нагрузкой. Чтобы достигнуть оптимального
значения, проведите свои собственные точки отсчета, если изменение
производительности от корректировки
<a href="#sysvar_innodb_old_blocks_pct"><code>
innodb_old_blocks_pct</code></a> недостаточно.</p>

<h4><a name="innodb-performance-read_ahead"></a>16.6.3.5.
Конфигурирование предвыборки InnoDB</h4>
<p><a href="glossary.htm#glos_read_ahead">Предвыборка</a> это запрос
ввода/вывода предварительно принести страницы в
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>
асинхронно, в ожидании, что эти страницы скоро будут необходимы. Запросы
получают все страницы в одном <a href="glossary.htm#glos_extent">экстенте
</a>. <code>InnoDB</code> использует два алгоритма предвыборки, чтобы
улучшить работу ввода/вывода:</p>

<p><span class="strong"><strong>Линейная</strong></span> предвыборка
метод, который предсказывает, какие страницы могли бы скоро быть необходимы,
основываясь на страницах в буферном пуле. Вы управляете, когда
<code>InnoDB</code> выполняет работу предвыборки, корректируя число
последовательных доступов к странице, требуемых, чтобы вызвать асинхронный
запрос чтения, используя параметр конфигурации
<a href="#sysvar_innodb_read_ahead_threshold"><code>
innodb_read_ahead_threshold</code></a>.</p>

<p>Параметр конфигурации <a href="#sysvar_innodb_read_ahead_threshold">
<code>innodb_read_ahead_threshold</code></a> контролирует, насколько
чувствителен <code>InnoDB</code> в обнаружении образцов последовательного
доступа страницы. Если число чтения страниц последовательно из экстента
больше чем или равно <a href="#sysvar_innodb_read_ahead_threshold">
<code>innodb_read_ahead_threshold</code></a>, <code>InnoDB</code>
начинает асинхронную работу чтения следующего экстента целиком.
<a href="#sysvar_innodb_read_ahead_threshold"><code>
innodb_read_ahead_threshold</code></a> может быть установлен в любое значение
от 0 до 64. По умолчанию 56. Чем выше значение, тем более строгая проверка
образца доступа. Например, если Вы устанавливаете значение в 48,
<code>InnoDB</code> вызывает линейный запрос предвыборки только когда к 48
страницам в текущем экстенте получили доступ последовательно.
Если значение 8, <code>InnoDB</code> вызывает линейный запрос предвыборки
даже если только к 8 страницам в экстенте получают доступ последовательно.
Вы можете установить значение этого параметра в
<a href="glossary.htm#glos_configuration_file">файле конфигурации</a> MySQL
или изменить это динамически с помощью <code>SET GLOBAL</code>, но для этого
надо иметь привилегию<code>SUPER</code>.</p>

<p><span class="strong"><strong>Случайная</strong></span> это метод,
который предсказывает, когда страницы могли бы скоро быть необходимы,
основываясь на страницах, которые уже в буферном пуле, независимо от порядка,
в котором были считаны те страницы. Если 13 последовательных страниц из
того же самого экстента найдены в буферном пуле, <code>InnoDB</code>
делает запрос предварительно загрузить остающиеся страницы экстента.
Чтобы активировать эту опцию, установите переменную конфигурации
<a href="#sysvar_innodb_random_read_ahead"><code>
innodb_random_read_ahead</code></a> в <code>ON</code>.</p>

<p>Команда <code>SHOW ENGINE INNODB STATUS</code> показывает статистику,
чтобы помочь Вам оценить эффективность алгоритма чтения. Статистические
данные включают счетчики для следующих глобальных переменных состояния:</p>

<ul><li><p><a href="server.htm#statvar_Innodb_buffer_pool_read_ahead">
<code>Innodb_buffer_pool_read_ahead</code></a></li>
<li><a href="server.htm#statvar_Innodb_buffer_pool_read_ahead_evicted">
<code>Innodb_buffer_pool_read_ahead_evicted</code></a></li>
<li><a href="server.htm#statvar_Innodb_buffer_pool_read_ahead_rnd">
<code>Innodb_buffer_pool_read_ahead_rnd</code></a></p></li></ul>

<p>Эта информация может быть полезной, точно настраивая
<a href="#sysvar_innodb_random_read_ahead">
<code>innodb_random_read_ahead</code></a>.</p>

<p>Для получения дополнительной информации о работе ввода/вывода см.
разделы <a href="optimiz.htm#optimizing-innodb-diskio">9.5.8</a> и
<a href="optimiz.htm#disk-issues">9.12.1</a>.</p>

<h4><a name="innodb-performance-adaptive_flushing"></a>16.6.3.6.
Конфигурирование сброса буфера InnoDB</h4>
<p><code>InnoDB</code> выполняет определенные задачи в фоне, включая
<a href="glossary.htm#glos_flush">сброс</a>
of <a href="glossary.htm#glos_dirty_page">грязных страниц</a> (те страницы,
которые были изменены, но еще не записаны в файлы базы данных) из
<a href="glossary.htm#glos_buffer_pool">буферного пула</a>.</p>

<p><code>InnoDB</code> начинает сбрасывать страницы пула, когда процент
грязных страниц в буферном пуле достигает нижнего предела, определенного
<a href="#sysvar_innodb_max_dirty_pages_pct_lwm"><code>
innodb_max_dirty_pages_pct_lwm</code></a>. Эта опция предназначена, чтобы
управлять отношением грязных страниц в буферном пуле и идеально
препятствовать тому, чтобы процент грязных страниц достиг
<a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a>. Если процент грязных страниц в
буферном пуле превышает
<a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a>, <code>InnoDB</code>
начинает сброс буферных страниц немедленно.</p>

<p><code>InnoDB</code> использует алгоритм, чтобы оценить
необходимый уровень сброса, основанный на скорости генерации журнала redo
и действующего коэффициента сброса. Намерение состоит в том, чтобы пригладить
эффективность работы, гарантируя, что буферная деятельность потока не отстает
от потребности сохранить буферный пул <span><span>чистым</span></span>.
Автоматическая корректировка уровня сброса может помочь избежать внезапных
падений пропускной способности, когда сброс буферного пула начинает мешать
обычному вводу-выводу.</p>

<p><code>InnoDB</code> использует файлы системного журнала круговым способом.
Прежде, чем снова использовать часть файла системного журнала,
<code>InnoDB</code> сбрасывает на диск все грязные буферные страницы, чьи
записи содержатся в этой части файла системного журнала, это процесс
<a href="glossary.htm#glos_sharp_checkpoint">острой контрольной точки</a>.
Если рабочая нагрузка записи интенсивная, она производит много информации в
журнале redo. Если все свободное место в файлах системного журнала
израсходовано, острая контрольная точка происходит, вызывая временное
сокращение пропускной способности. Эта ситуация может произойти, даже если
<a href="#sysvar_innodb_max_dirty_pages_pct">
<code>innodb_max_dirty_pages_pct</code></a> не достигнут.</p>

<p><code>InnoDB</code> использует эвристический алгоритм, чтобы избежать
такого сценария, измеряя число грязных страниц в буферном пуле и уровень
прироста журнала redo. Основываясь на этих числах, <code>InnoDB</code>
решает, сколько грязных страниц сбросить из буферного пула каждую секунду.
Этот адаптивный алгоритм в состоянии иметь дело с внезапными
изменениями в рабочей нагрузке.</p>

<p>Внутренний сопоставительный анализ показал, что этот алгоритм не только
поддерживает пропускную способность в течение долгого времени, но и может
также значительно улучшить полную пропускную способность.</p>

<p>Поскольку адаптивный сброс может значительно затронуть образец
ввода/вывода рабочей нагрузки, параметр
<a href="#sysvar_innodb_adaptive_flushing"><code>
innodb_adaptive_flushing</code></a> позволяет Вам выключать эту особенность.
Значение по умолчанию для
<a href="#sysvar_innodb_adaptive_flushing">
<code>innodb_adaptive_flushing</code></a> <code>TRUE</code>,
адаптивный алгоритм включен. Вы можете установить значение этого параметра в
файле опции MySQL (<code>my.cnf</code> или <code>my.ini</code>)
или изменить это динамически с помощью
<code>SET GLOBAL</code>, имея привилегию <code>SUPER</code>.</p>

<p>Для информации о точной настройке сброса пула в <code>InnoDB</code>
см. <a href="#innodb-lru-background-flushing">раздел 16.6.3.7</a>.
Для получения дополнительной информации о работе ввода/вывода
<code>InnoDB</code> см. <a href="optimiz.htm#optimizing-innodb-diskio">раздел
9.5.8</a>.</p>

<h4><a name="innodb-lru-background-flushing"></a>16.6.3.7.
Точная настройка сброса буферного пула InnoDB</h4>
<p>Опции <a href="#sysvar_innodb_flush_neighbors"><code>
innodb_flush_neighbors</code></a> и
<a href="#sysvar_innodb_lru_scan_depth"><code>
innodb_lru_scan_depth</code></a>
позволяют Вам точно настраивать определенные аспекты процесса
<a href="glossary.htm#glos_flush">сброса</a> для
<a href="glossary.htm#glos_buffer_pool">буферного пула</a>
<code>InnoDB</code>. Эти опции прежде всего помогают
<a href="glossary.htm#glos_workload">рабочим нагрузкам</a> с интенсивной
записью. С большой активностью <a href="glossary.htm#glos_dml">DML</a>
сброс может отстать, если это недостаточно агрессивно, приводя к чрезмерному
использованию памяти в буферном пуле. С другой стороны сброс
может перегрузить Вашу систему ввода/вывода, если этот механизм слишком
агрессивен. Идеальные настройки зависят от Вашей рабочей нагрузки, образцов
доступа к данным и конфигурации хранения (например, хранятся ли данные на
<a href="glossary.htm#glos_hdd">HDD</a> или
<a href="glossary.htm#glos_ssd">SSD</a>).</p>

<p>Для систем с постоянными тяжелыми
<a href="glossary.htm#glos_workload">рабочими нагрузками</a>
или рабочими нагрузками, которые широко колеблются, несколько параметров
конфигурации позволяют Вам точно настраивать поведение
<a href="glossary.htm#glos_flush">сброса</a> для таблиц:</p>

<ul><li><p><a href="#sysvar_innodb_adaptive_flushing_lwm"><code>
innodb_adaptive_flushing_lwm</code></a></li>
<li><a href="#sysvar_innodb_max_dirty_pages_pct_lwm"><code>
innodb_max_dirty_pages_pct_lwm</code></a></li>
<li><a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a></li>
<li><a href="#sysvar_innodb_flushing_avg_loops"><code>
innodb_flushing_avg_loops</code></a></p></li></ul>

<p>Эти опции подпитывают формулу, используемую параметром
<a href="#sysvar_innodb_adaptive_flushing"><code>
innodb_adaptive_flushing</code></a>.</p>

<p>Опции <a href="#sysvar_innodb_adaptive_flushing"><code>
innodb_adaptive_flushing</code></a>,
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> и <a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a>
ограничены или расширены следующими опциями:</p>

<ul><li><p><a href="#sysvar_innodb_adaptive_flushing_lwm"><code>
innodb_adaptive_flushing_lwm</code></a></li>
<li><a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a></li>
<li><a href="#sysvar_innodb_max_dirty_pages_pct_lwm"><code>
innodb_max_dirty_pages_pct_lwm</code></a></p></li></ul>

<p>Механизм <a href="glossary.htm#glos_adaptive_flushing">адаптивного сброса
</a> <code>InnoDB</code> не является подходящим во всех случаях. Это приносит
большинство пользы, когда <a href="glossary.htm#glos_redo_log">журнал redo
</a> рискует заполниться. Опция
<a href="#sysvar_innodb_adaptive_flushing_lwm"><code>
innodb_adaptive_flushing_lwm</code></a> определяет процент
<span><span>нижнего предела</span></span> заполнения журнала redo,
когда этот порог пересечен, <code>InnoDB</code>
включает адаптивный сброс даже если не определена опция
<a href="#sysvar_innodb_adaptive_flushing"><code>
innodb_adaptive_flushing</code></a>.</p>

<p>Если активность сброса слишком мала, <code>InnoDB</code>
может сбрасывать более настойчиво, чем указано в
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>. <a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a> представляет верхний предел нагрузки
ввода/вывода, используемой в таких чрезвычайных ситуациях, чтобы пик
ввода/вывода не потреблял всю пропускную способность сервера.</p>

<p><code>InnoDB</code> старается сбросить данные из буферного пула так, чтобы
процент грязных страниц не превысил значение
<a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a>. Значение по умолчанию для
<a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a> 75.</p>

<p><a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a> устанавливает цель для активности
сброса. Это не затрагивает уровень сброса. Для информации об управлении
уровнем сброса см. <a href="#innodb-performance-adaptive_flushing">
раздел 16.6.3.6</a>.</p>

<p>Опция <a href="#sysvar_innodb_max_dirty_pages_pct_lwm"><code>
innodb_max_dirty_pages_pct_lwm</code></a> определяет значение, которое
представляет процент грязных страниц, при котором предварительному сбросу
позволяют управлять отношением грязных страниц и идеально препятствовать
тому, чтобы процент грязных страниц достиг
<a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a>. Значение
<a href="#sysvar_innodb_max_dirty_pages_pct_lwm"><code>
innodb_max_dirty_pages_pct_lwm=0</code></a> отключает
<span><span>предсброс</span></span>.</p>

<p>Большинство опций, на которые ссылаются выше, наиболее применимы к
серверам, которые работают с большими рабочими нагрузками по записи в течение
долгих промежутков времени.</p>

<p><a href="#sysvar_innodb_flushing_avg_loops"><code>
innodb_flushing_avg_loops</code></a> определяет число итераций для которого
<code>InnoDB</code> сохраняет ранее расчитанный снимок состояния сброса,
который управляет, как быстро адаптивный сброс отвечает на изменения
загрузки. Указание большого значения для
<a href="#sysvar_innodb_flushing_avg_loops"><code>
innodb_flushing_avg_loops</code></a> предписывает хранить
расчитанный снимок дольше, таким образом, адаптивный сброс
отвечает более медленно. Высокое значение также уменьшает позитивные отклики
между передним планом и фоновой работой, но задание большого значения очень
важно, чтобы гарантировать, что использование <code>InnoDB</code> журнала
redo не достигает 75% (предел, при котором запускается сброс), и что
<a href="#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a> сохраняет число грязных страниц на
уровне, который является подходящим для рабочей нагрузки.</p>

<p>Системы с последовательными рабочими нагрузками, большим
<a href="#sysvar_innodb_log_file_size"><code>innodb_log_file_size
</code></a> и маленькими пиками, которые не достигают 75% использования места
в журнале redo, должны использовать верхний уровень
<a href="#sysvar_innodb_flushing_avg_loops"><code>
innodb_flushing_avg_loops</code></a>, чтобы продолжить сбрасывать
столь гладко, насколько возможно. Для систем с экстремальными пиками
загрузки или файлами системного журнала, которые не обеспечивают много
пространства, должны использовать меньшее значение
<a href="#sysvar_innodb_flushing_avg_loops"><code>
innodb_flushing_avg_loops</code></a>.
Меньшее значение позволяет сбрасывать так, чтобы точно отследить загрузку и
помогает избежать использования 75% пространства журнала redo.</p>

<h4><a name="innodb-preload-buffer-pool"></a>16.6.3.8.
Сохранение и восстановление состоояния буферного пула</h4>
<p>Чтобы уменьшить период <a href="glossary.htm#glos_warm_up">загрузки</a>
после перезапуска сервера, <code>InnoDB</code> сохраняет процент последний
раз используемых страниц для каждого буферного пула при завершении работы
сервера и восстанавливает эти страницы при запуске сервера. Процент недавно
используемых страниц, который сохранен, определен параметром
<a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a>.</p>

<p>После перезапуска занятого сервера как правило есть период разминки с
устойчиво увеличивающейся пропускной способностью, поскольку дисковые
страницы, которые были в буферном пуле, возвращены в память (поскольку те же
самые данные запрошены, обновлены и так далее). Способность восстановить
буферный пул при запуске сокращает период разминки, перезагружая дисковые
страницы, которые были в буферном пуле перед перезапуском вместо того, чтобы
ждать операций DML, чтобы получить доступ к соответствующим строкам. Кроме
того, запросы ввода/вывода могут быть выполнены в больших пакетах, делая
полный ввод/вывод быстрее. Загрузка страниц происходит в фоне и не
задерживает запуск базы данных.</p>

<p>В дополнение к сохранению состояния буферного пула при завершении работы и
восстановлении его при запуске, Вы можете сохранить и восстановить состояние
буферного пула в любое время, в то время как сервер работает. Например, Вы
можете сохранить состояние после достижения устойчивой пропускной способности
при устойчивой рабочей нагрузке. Вы можете также восстановить предыдущее
состояние буферного пула после выполнения отчетов или заданий обслуживания,
которые приносят страницы данных в буферный пул, которые нужны только для тех
операций, или после выполнения некоторой другой нетипичной рабочей нагрузки.
</p>

<p>Даже при том, что буферный пул может быть много
гигабайт в размере, данные пула, которые <code>InnoDB</code> сохраняет на
диск являются крошечными. Только ID табличного пространства и ID страницы,
необходимые, чтобы определить местонахождение соответствующих страниц,
сохранены на диск. Эта информация получена из таблицы
<a href="inform.htm#innodb-buffer-page-lru-table"><code>
INNODB_BUFFER_PAGE_LRU</code></a> <code>INFORMATION_SCHEMA</code>.
По умолчанию ID табличного пространства и страницы сохранены в файле
<code>ib_buffer_pool</code>, в кталоге данных <code>InnoDB</code>.
Имя файла и местоположение могут быть изменены, используя параметр
<a href="#sysvar_innodb_buffer_pool_filename"><code>
innodb_buffer_pool_filename</code></a>.</p>

<p>Поскольку данные кэшируются и устаревают в пуле, нет никакой проблемы,
если дисковые страницы были недавно обновлены, или если работа DML вовлекает
данные, которые еще не были загружены. Механизм загрузки пропускает требуемые
страницы, которые больше не существуют.</p>

<p>Основной механизм вовлекает фоновый поток,
чтобы выполнить операции загрузки и дамп.</p>
<p>Дисковые страницы от сжатых таблиц загружены в буферный пул в их сжатой
форме. Страницы разсжаты, когда к содержанию страницы получают доступ во
время операций DML. Поскольку разсжатие страниц является процессом,
серьезно нагружающим центральный процессор, более эффективно для параллелизма
выполнить работу в потоке соединения, а не в единственном потоке, который
выполняет работу восстановления пула.</p>

<h5><a name="innodb-preload-buffer-pool-dump-pct"></a>
Конфигурирование процента дампа для страниц буферного пула</h5>
<p>Прежде, чем вывести страницы из буферного пула, Вы можете сконфигурировать
процент используемых буферных страниц, которые Вы хотите вывести,
устанавливая опцию <a href="#sysvar_innodb_buffer_pool_dump_pct">
<code>innodb_buffer_pool_dump_pct</code></a>.
Если Вы планируете вывести буферные страницы в то время, как сервер работает,
Вы можете сконфигурировать опцию динамически:
<pre>
SET GLOBAL innodb_buffer_pool_dump_pct=40;
</pre>

<p>Если Вы планируете вывести буферные страницы при
завершении работы сервера, надо установить
<a href="#sysvar_innodb_buffer_pool_dump_pct"><code>
innodb_buffer_pool_dump_pct</code></a> в Вашем конфигурационном файле.
<pre>
[mysqld]
innodb_buffer_pool_dump_pct=40
</pre>

<p>Значение <a href="#sysvar_innodb_buffer_pool_dump_pct">
<code>innodb_buffer_pool_dump_pct</code></a> по умолчанию 25 (дамп 25%
используемых последний раз страниц).</p>

<h5><a name="innodb-preload-buffer-pool-offline"></a>
Сохранение статуса буферного пула при завершении работы и
восстановление при запуске</h5>
<p>Чтобы сохранить статус буферного пула при
завершении работы сервера, сделайте следующее запрос до закрытия сервера:
<pre>
SET GLOBAL innodb_buffer_pool_dump_at_shutdown=ON;
</pre>

<p><a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a>
включена по умолчанию.</p>

<p>Чтобы восстановить статус пула при запуске сервера, определите
опцию <code>--innodb_buffer_pool_load_at_startup</code>, запуская сервер:
<pre>
mysqld --innodb_buffer_pool_load_at_startup=ON;
</pre>
<p><a href="#sysvar_innodb_buffer_pool_load_at_startup"><code>
innodb_buffer_pool_load_at_startup</code></a> включен по умолчанию.</p>

<h5><a name="innodb-preload-buffer-pool-online"></a>
Сохранение и восстановление статуса буферного пула онлайн</h5>
<p>Чтобы сохранить состояние буферного пула в то время, как сервер MySQL
работает, сделайте следующее:
<pre>
SET GLOBAL innodb_buffer_pool_dump_now=ON;
</pre>

<p>Чтобы восстановить состояние буферного пула в то время, как сервер MySQL
работает, сделайте следующее:
<pre>
SET GLOBAL innodb_buffer_pool_load_now=ON;
</pre>

<h5><a name="innodb-preload-buffer-pool-dump-progress"></a>
Отображение процесса дампа буферного пула</h5>
<p>Чтобы вывести на экран процесс сохранения пула на
диск, сделайте следующее:
<pre>
SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status';
</pre>

<p>Если работа еще не запустилась, вернется <span><span>not started</span>
</span>. Если работа завершена, время завершения напечатано (например,
Finished at 110505 12:18:02). Если работа происходит, информация о статусе
обеспечена (например, Dumping buffer pool 5/7, page 237/2873).</p>

<h5><a name="innodb-preload-buffer-pool-load-progress"></a>
Отображение процесса загрузки буферного пула</h5>
<p>Чтобы вывести на экран процесс загрузки пула, сделайте следующее:
<pre>
SHOW STATUS LIKE 'Innodb_buffer_pool_load_status';
</pre>

<p>Если работа еще не запустилась, вернется <span><span>not started</span>
</span>. Если работа завершена, время завершения напечатано (например,
Finished at 110505 12:18:02). Если работа происходит, информация о статусе
обеспечена (например, Loaded 123/22300 pages).</p>

<h5><a name="innodb-preload-buffer-pool-abort-load"></a>
Прерывание загрузки пула</h5>
<p>Чтобы прервать работу загрузки пула, сделайте следующее:
<pre>
SET GLOBAL innodb_buffer_pool_load_abort=ON;
</pre>

<h5><a name="monitor-buffer-pool-load-performance-schema"></a>
Контроль загрузки пула, используя Performance Schema</h5>
<p>Вы можете контролировать ход загрузки пула, используя
<a href="perfor.htm">Performance Schema</a>.</p>

<p>Следующий пример демонстрирует, как включить инструмент этапа событий
<code>stage/innodb/buffer pool load</code> и связанные потребительские
таблицы, чтобы контролировать продвижение загрузки.</p>

<p>Для информации о дампе пула и процедурах загрузки, используемых в этом
примере, см. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8
</a>. Для информации об инструментах этапа Performance
Schema и связанных потребителях, см.
<a href="perfor.htm#performance-schema-stage-tables">раздел 23.9.5</a>.</p>

<ol type="1"><li><p>Включите инструмент <code>stage/innodb/buffer pool load
</code>:
<pre>
mysql&gt; UPDATE performance_schema.setup_instruments SET ENABLED = 'YES'
                 WHERE NAME LIKE 'stage/innodb/buffer%';
</pre></li>

<li>Включите потребительские таблицы этапа событий, которые включают
<a href="perfor.htm#events-stages-current-table"><code>events_stages_current
</code></a>,
<a href="perfor.htm#events-stages-history-table"><code>events_stages_history
</code></a> и
<a href="perfor.htm#events-stages-history-long-table"><code>
events_stages_history_long</code></a>.
<pre>
mysql&gt; UPDATE performance_schema.setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%stages%';
</pre></li>

<li>Выведите текущее буферное состояние с помощью
<a href="#sysvar_innodb_buffer_pool_dump_now"><code>
innodb_buffer_pool_dump_now</code></a>.
<pre>
mysql&gt; SET GLOBAL innodb_buffer_pool_dump_now=ON;
</pre></li>

<li>Проверьте состояние дампа пула, чтобы гарантировать,
что работа завершилась.
<pre>
mysql&gt; SHOW STATUS LIKE 'Innodb_buffer_pool_dump_status'\G
*************************** 1. row ***************************
Variable_name: Innodb_buffer_pool_dump_status
Value: Buffer pool(s) dump completed at 150202 16:38:58
</pre></li>

<li>Загрузите буферный пул с помощью
<a href="#sysvar_innodb_buffer_pool_load_now"><code>
innodb_buffer_pool_load_now</code></a>:
<pre>
mysql&gt; SET GLOBAL innodb_buffer_pool_load_now=ON;
</pre></li>

<li>Проверьте текущий статус загрузки пула, запрашивая таблицу Performance
Schema <a href="perfor.htm#events-stages-current-table"><code>
events_stages_current</code></a>. Столбец <code>WORK_COMPLETED</code>
показывает число загруженных страниц пула. <code>WORK_ESTIMATED</code>
обеспечивает оценку остающейся работы в страницах.
<pre>
mysql&gt; SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED
                 FROM performance_schema.events_stages_current;
+-------------------------------+----------------+----------------+
| EVENT_NAME                    | WORK_COMPLETED | WORK_ESTIMATED |
+-------------------------------+----------------+----------------+
| stage/innodb/buffer pool load | 5353           | 7167           |
+-------------------------------+----------------+----------------+
</pre>

<p>Таблица <a href="perfor.htm#events-stages-current-table"><code>
events_stages_current</code></a> возвращает пустой набор, если работа
загрузки пула завершилась. В этом случае Вы можете проверить таблицу
<a href="perfor.htm#events-stages-history-table"><code>events_stages_history
</code></a>, чтобы рассмотреть данные для завершенного случая. Например:
<pre>
mysql&gt; SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED
                 FROM performance_schema.events_stages_history;
+-------------------------------+----------------+----------------+
| EVENT_NAME                    | WORK_COMPLETED | WORK_ESTIMATED |
+-------------------------------+----------------+----------------+
| stage/innodb/buffer pool load | 7167           | 7167           |
+-------------------------------+----------------+----------------+
</pre></li></ol>

<p>Вы можете также контролировать ход загрузки пула, используя Performance
Schema, загружая буферный пул при запуске с использованием
<a href="#sysvar_innodb_buffer_pool_load_at_startup"><code>
innodb_buffer_pool_load_at_startup</code></a>. В этом случае инструмент
<code>stage/innodb/buffer pool load</code>
и связанные потребители должны быть включены при запуске. Для получения
дополнительной информации см.
<a href="perfor.htm#performance-schema-startup-configuration">раздел 23.2.2
</a>.</p>

<h4><a name="innodb-buffer-pool-monitoring"></a>16.6.3.9.
Контроль буферного пула, используя стандартный монитор InnoDB</h4>
<p>Вывод <code>InnoDB</code> Standard Monitor,
к которому можно получить доступ, используя
<a href="#innodb-standard-monitor"><code>SHOW ENGINE INNODB STATUS
</code></a>, обеспечивает метрики, которые принадлежат работе с пулом
<code>InnoDB</code>. Буферные метрики пула расположены в разделе
<code>BUFFER POOL AND MEMORY</code> вывода <code>InnoDB</code> Standard
Monitor и подобны следующему:
<pre>
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers   124908
Database pages 5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
</pre>

<p>Следующая таблица описывает метрики пула, о которых сообщает
<code>InnoDB</code> Standard Monitor.</p>
<p>Средние числа в секунду в выводе <code>InnoDB</code> Standard Monitor
основаны на прошедшем времени с последнего вывода
<code>InnoDB</code> Standard Monitor.</p>

<a name="innodb-buffer-pool-metrics"></a><p><b>Таблица 16.2. Метрики пула</b>
</p>
<table border="1">
<thead><tr><th>Имя</th><th>Описание</th></tr></thead>
<tbody><tr><td>Total memory allocated</td><td>Полная память, которая выделена
для буферного пула в байтах.</td></tr>
<tr><td>Dictionary memory allocated</td><td>Полная память, выделенная для
словаря данных <code>InnoDB</code> в байтах.</td></tr>
<tr><td>Buffer pool size</td><td>Полный размер в страницах буферного пула.
</td></tr>
<tr><td>Free buffers</td><td>Полный размер в страницах свободного списка.
</td></tr>
<tr><td>Database pages</td><td>Полный размер в страницах списка LRU.</td>
</tr>
<tr><td>Old database pages</td><td>Полный размер в страницах
старого подсписка LRU.</td></tr>
<tr><td>Modified db pages</td><td>Текущее число страниц,
измененных в буферном пуле.</td></tr>
<tr><td>Pending reads</td><td>Число страниц, ждущих считывания в пул.
</td></tr>
<tr><td>Pending writes LRU</td><td>Число старых грязных страниц в буферном
пуле, которые будут записаны от конца списка LRU.</td></tr>
<tr><td>Pending writes flush list</td><td>Число страниц пула, которые
будут сброшены во время установки контрольных точек.</td></tr>
<tr><td>Pending writes single page</td><td>Число независимых страниц в
ожидании записи в буферном пуле.</td></tr>
<tr><td>Pages made young</td><td>Общее количество молодых страниц в списке
LRU (перемещенных к началу подсписка <span><span>новых</span></span> страниц).
</td></tr>
<tr><td>Pages made not young</td><td>Общее количество страниц, не сделанных
молодыми в списке LRU (страницы, которые остались в подсписке
<span><span>старых</span></span>, не будучи сделанным молодыми).</td></tr>
<tr><td>youngs/s</td><td>Среднее число доступов в секунду к старым страницам
в списке LRU, которые привели к созданию молодых страниц. См. примечания,
которые следуют за этой таблицей для получения дополнительной информации.
</td></tr>
<tr><td>non-youngs/s</td><td>Среднее число доступов в секунду к старым
страницам в списке LRU, которые не привели к созданию молодых страниц.</td>
</tr>
<tr><td>Pages read</td><td>Общее количество страниц, прочитанных
из буферного пула.</td></tr>
<tr><td>Pages created</td><td>Общее количество страниц,
созданных в буферном пуле.</td></tr>
<tr><td>Pages written</td><td>Общее количество страниц, записанных
из буферного пула.</td></tr>
<tr><td>reads/s</td><td>Среднее число в секунду прочитанных страниц.</td>
</tr>
<tr><td>creates/s</td><td>Среднее число в секунду
создаваемых буферных страниц.</td></tr>
<tr><td>writes/s</td><td>Среднее число записываемых
буферных страниц в секунду.</td></tr>
<tr><td>Buffer pool hit rate</td><td>Частота успешных обращений к странице
для страниц из буферной памяти, а не с диска.</td></tr>
<tr><td>young-making rate</td><td>Средняя частота успешных обращений, в
которых доступ к странице привел к созданию молодых страниц.</td></tr>
<tr><td>not (young-making rate)</td><td>Средняя частота успешных обращений, в
которых доступ к странице не привел к созданию молодых страниц.</td></tr>
<tr><td>Pages read ahead</td>
<td>Среднее число операций предвыборки в секунду.</td></tr>
<tr><td>Pages evicted without access</td><td>Среднее число вычеркнутых
страниц в секунду, к которым не получен доступ из буферного пула.</td></tr>
<tr><td>Random read ahead</td><td>Среднее число операций
случайного чтения в секунду.</td></tr>
<tr><td>LRU len</td><td>Полный размер в страницах списка LRU.</td></tr>
<tr><td>unzip_LRU len</td><td>Полный размер в страницах списка unzip_LRU.
</td></tr>
<tr><td>I/O sum</td><td>Общее количество страниц списка LRU, к которым был
доступ в течение прошлых 50 секунд.</td></tr>
<tr><td>I/O cur</td><td>Общее количество страниц списка LRU, к которым
получают доступ сейчас.</td></tr>
<tr><td>I/O unzip sum</td><td>Общее количество страниц списка unzip_LRU, к
которым получали доступ.</td></tr>
<tr><td>I/O unzip cur</td><td>Общее количество страниц списка unzip_LRU, к
которым получают доступ сейчас.</td></tr></tbody></table>

<p><span><strong>Примечания</strong></span>:</p>
<ul><li><p>Метрика <code>youngs/s</code> касается только
старых страниц. Это основано на числе доступов к страницам, а не числе
страниц. Могут быть многократные доступы к данной странице, которые все
посчитаны. Если Вы видите очень низкое значение <code>youngs/s</code>, когда
нет никакого большого появления просмотров, Вы, возможно, должны были бы
уменьшить время задержки или увеличить процент буферного пула, используемого
для старого подсписка. Увеличение процента делает старый подсписок больше,
таким образом, у страниц в этом подсписке уходит больше времени, чтобы
переместиться в хвост и быть вычеркнутыми. Это увеличивает вероятность, что к
страницам получат доступ снова и сделают их молодыми.</li>

<li>Метрика <code>non-youngs/s</code> касается только
старых страниц. Это основано на числе доступов к страницам, а не числе
страниц. Могут быть многократные доступы к данной странице, которые все
посчитаны. Если Вы не видите много <code>non-youngs/s</code>, когда Вы
делаете большое сканирование таблицы (и много <code>youngs/s</code>),
увеличьте значение задержки.</li>

<li>Коэффициент <code>young-making</code> учитывает доступы ко всем страницам
пула, не только доступы к страницам в старом подсписке. Коэффициенты
<code>young-making</code> и <code>not</code> обычно не составляют в сумме
полную частоту успешных обращений к пулу.</li>

<li><code>not (young-making rate)</code> средняя частота успешных обращений,
в которой доступы к страницам не привели к созданию молодых страниц из-за
задержки, определенной <a href="#sysvar_innodb_old_blocks_time">
<code>innodb_old_blocks_time</code></a>, или из-за попаданий на страницы
в новом подсписке, которые не приводили к страницам, перемещаемым к началу.
Этот уровень составляет доступы ко всем страницам пула, не только доступы к
страницам в старом подсписке.</p></li></ul>

<p><a href="server.htm#server-status-variables">Переменные статуса сервера
</a> пула <code>InnoDB</code> и таблица
<a href="inform.htm#innodb-buffer-pool-stats-table"><code>
INNODB_BUFFER_POOL_STATS</code></a> обеспечивает многие из тех же самых
метрик пула, найденных в таблице
<a href="inform.htm#innodb-buffer-pool-stats-table"><code>
INNODB_BUFFER_POOL_STATS</code></a>, см.
<a href="#innodb-information-schema-buffer-pool-stats-example">
пример 16.19</a>.</p>

<h3><a name="innodb-performance-change_buffering"></a>16.6.4.
Конфигурирование изменения буферизации InnoDB</h3>
<p>Когда <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>
выполнены на таблице, значения индексированных столбцов (особенно значения
вторичных ключей) часто находятся в несортированном порядке,
требуя существенного ввода/вывода, чтобы принести вторичный индекс.
<code>InnoDB</code> имеет <a href="glossary.htm#glos_change_buffer">буфер
изменений</a>, который кэширует изменения вторичного индекса, когда
соответствующая <a href="glossary.htm#glos_page">страница</a> не находится в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>, таким образом
избегая дорогих операций ввода/вывода, не читая немедленно страницу с диска.
Буферизованные изменения слиты, когда страница загружена в буферный пул, и
обновленная страница позже сбрасывается на диск. Основной поток
<code>InnoDB</code> объединяет изменения, когда сервер почти неактивен, и во
время <a href="glossary.htm#glos_slow_shutdown">медленной парковки</a>.</p>

<p>Поскольку это может привести к меньшему количеству обращений к диску,
эта особенность является самой ценной для рабочих нагрузок, которые имеют
большой ввод-вывод, например приложения с большим объемом операций DML, таких
как большой объем вставок.</p>

<p>Однако, буфер изменения занимает часть буферного пула, уменьшая память,
доступную страницам данных о кэше. Если рабочий набор данных почти помещается
в буферный пул, или если Ваши таблицы имеют, относительно немногие вторичные
индексы, может быть полезно отключить буферизацию изменения. Если работа
помещается в буфере полностью, буферизация изменения не налагает
дополнительных издержек, потому что это только относится к страницам, которые
не находятся в буферном пуле.</p>

<p>Вы можете управлять степенью, в которой <code>InnoDB</code>
выполняет буферизацию изменения, используя параметр
<a href="#sysvar_innodb_change_buffering"><code>
innodb_change_buffering</code></a>. Вы можете включить или отключить
буферизацию для вставок и удалений (когда индексные записи
первоначально отмечены для удаления) и операций чистки (когда индексные
записи физически удалены). Обновления это комбинация вставки и удаления.
Значение по умолчанию для
<a href="#sysvar_innodb_change_buffering"><code>
innodb_change_buffering</code></a> <code>all</code>.</p>

<p>Разрешенные значения <a href="#sysvar_innodb_change_buffering">
<code>innodb_change_buffering</code></a>:</p>
<ul><li><p><span>all</span></p>
<p>Значение по умолчанию: вставки в буфер, операции удаления и чистки.</li>

<li><span>none</span></p>
<p>Не буферизировать ничего.</li>
<li><span>inserts</span></p>
<p>Буферизировать только вставки.</li>

<li><span>deletes</span></p>
<p>Буферизировать только удаления.</li>
<li><span>changes</span></p>
<p>Буферизировать только удаления и вставки.</li>

<li><span>purges</span></p>
<p>Буферизировать физические операции удаления, которые происходят в фоне.
</p></li></ul>

<p>Вы можете установить <a href="#sysvar_innodb_change_buffering">
<code>innodb_change_buffering</code></a> в файле опций MySQL
(<code>my.cnf</code> или <code>my.ini</code>) или измените это динамически с
помощью <a href="sql.htm#set-variable"><code>SET GLOBAL</code></a>
(нужна привилегия <code>SUPER</code>). Изменение установки затрагивает
буферизацию новых операций, слияние существующих буферизованных
записей не затронуто.</p>

<p>Подробности в <a href="#innodb-insert-buffering">разделе 16.4.2
</a>. Для информации о конфигурировании размера буфера изменения см.
<a href="#innodb-change-buffer-maximum-size">раздел 16.6.4.1</a>.
</p>

<h4><a name="innodb-change-buffer-maximum-size"></a>16.6.4.1.
Конфигурирование максимального размера буфера изменений</h4>
<p>Опция <a href="#sysvar_innodb_change_buffer_max_size"><code>
innodb_change_buffer_max_size</code></a> позволяет Вам конфигурировать
максимальный размер буфера изменения как процент полного размера буферного
пула. По умолчанию <a href="#sysvar_innodb_change_buffer_max_size">
<code>innodb_change_buffer_max_size</code></a> установлена в 25. Максимум 50.
</p>

<p>Вы могли бы рассмотреть увеличение
<a href="#sysvar_innodb_change_buffer_max_size"><code>
innodb_change_buffer_max_size</code></a> на сервере MySQL с тяжелой вставкой,
обновлением и удалением, где буферное слияние изменения не идет в ногу с
новыми буферными записями изменения, заставляя буфер изменения достичь его
максимального предела размера.</p>

<p>Вы могли бы рассмотреть уменьшение
<a href="#sysvar_innodb_change_buffer_max_size"><code>
innodb_change_buffer_max_size</code></a>
на сервере MySQL со статическими данными, используемыми для отчетов,
или если буфер изменения потребляет слишком много места в памяти, которое
совместно использовано с буферным пулом, заставляя страницы стареть
скорее, чем надо.</p>

<p>Проверьте различные настройки с представительной рабочей нагрузкой, чтобы
определить оптимальную конфигурацию. Настройка
<a href="#sysvar_innodb_change_buffer_max_size"><code>
innodb_change_buffer_max_size</code></a> является динамической, что позволяет
Вам изменять ее, не перезапуская сервер.</p>

<h3><a name="innodb-performance-thread_concurrency"></a>16.6.5.
Конфигурирование параллелизма потока для InnoDB</h3>
<p><code>InnoDB</code> использует <a href="glossary.htm#glos_thread">потоки
</a> операционной системы, чтобы обработать запросы от пользовательских
транзакций. Транзакции могут выпустить много запросов к
<code>InnoDB</code> перед завершением. На современных операционных системах и
серверах с мультиядерными процессорами, где переключение контекста
эффективно, большинство рабочих нагрузок, выполнены хорошо без особого
предела на число параллельных потоков.</p>

<p>В ситуациях, где полезно минимизировать контекст, переключающийся между
потоками, <code>InnoDB</code> может использовать много методов, чтобы
ограничить число параллельного выполнения потоков операционной системы
(и таким образом число запросов, которые обработаны в любой момент). Когда
<code>InnoDB</code> получает новый запрос от пользовательского сеанса, если
число одновременно выполняющихся потоков дошло до предопределенного предела,
запрос спит в течение короткого времени прежде, чем попробует еще раз.
Запрос, который не может быть запланирован после сна, помещен в очередь
first-in/first-out и в конечном счете обработан. Потоки, ждущие блокировок,
не посчитаны в числе параллельного выполнения потоков.</p>

<p>Вы можете ограничить число параллельных потоков, устанавливая параметры
конфигурации <a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a>. Как только число выполняемых потоков
достигает этого предела, дополнительные потоки спят
в течение числа микросекунд, установленного параметром конфигурации
<a href="#sysvar_innodb_thread_sleep_delay"><code>
innodb_thread_sleep_delay</code></a>,
прежде, чем быть помещенными в очередь.</p>

<p>Вы можете установить параметр конфигурации
<a href="#sysvar_innodb_adaptive_max_sleep_delay"><code>
innodb_adaptive_max_sleep_delay</code></a> к самому высокому значению,
которое Вы разрешаете для
<a href="#sysvar_innodb_thread_sleep_delay"><code>
innodb_thread_sleep_delay</code></a>, и <code>InnoDB</code> автоматически
корректирует <a href="#sysvar_innodb_thread_sleep_delay"><code>
innodb_thread_sleep_delay</code></a> в зависимости от текущей и планируемой
активности потоков. Эта динамическая корректировка помогает механизму
планирования потока работать гладко в течение времен, когда система слегка
загружена и когда она занята максимально.</p>

<p>Значение по умолчанию для
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a> и подразумеваемый предел значения по
умолчанию числа параллельных потоков был изменен в различных выпусках MySQL и
<code>InnoDB</code>. Значение по умолчанию для
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a> <code>0</code>,
чтобы по умолчанию не было никакого предела числа
параллельного выполнения потоков.</p>

<p><code>InnoDB</code> отправляет потоки в спячку только, когда число
параллельных потоков ограничено. Когда нет никакого предела числа потоков,
все работают одинаково. Таким образом, если
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a> <code>0</code>, значение
<a href="#sysvar_innodb_thread_sleep_delay"><code>
innodb_thread_sleep_delay</code></a> проигнорировано.</p>

<p>Когда есть предел числа потоков (когда
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a> &gt; 0), <code>InnoDB</code>
уменьшает издержки переключения контекста, разрешая многократные запросы
во время выполнения <span><em>одного запроса SQL</em></span>, не
проверяя предела, установленного
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a>. Так как запрос SQL
может включить многострочные операции в пределах <code>InnoDB</code>,
<code>InnoDB</code> назначает конкретное количество
<span><span>тикетов</span></span>, которые позволяют потоку неоднократно
планироваться с минимальными издержками.</p>

<p>Когда новый запрос SQL запускается, у потока нет никаких тикетов, и это
должно работать согласно
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a>. Как только поток входит в
<code>InnoDB</code>, этому назначают много тикетов, которые это может
использовать для того, чтобы впоследствии выполнить операции со строками.
Если тикеты заканчиваются, поток вычеркивается, и
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a> снова отслеживается, чтобы
поместить поток назад в очередь first-in/first-out потоков ожидания.
Когда поток еще раз попадает туда, тикеты назначены снова. Число назначенных
тикетов определено глобальной опцией
<a href="#sysvar_innodb_concurrency_tickets"><code>
innodb_concurrency_tickets</code></a>, 5000 по умолчанию. Потоку, который
ждет блокировки, дают один тикет, как только блокировка становится доступной.
</p>

<p>Правильные значения этих переменных зависят от Вашей среды и рабочей
нагрузки. Попробуйте диапазон различных значений, чтобы определить, какое
значение работает на Ваших приложениях. Прежде, чем ограничить число
параллельного выполнения потоков, рассмотрите параметры конфигурации, которые
могут улучшить исполнение <code>InnoDB</code>, например,
<a href="#sysvar_innodb_adaptive_hash_index"><code>
innodb_adaptive_hash_index</code></a>.</p>
<p>Для общей информации об обработке потока MySQL см.
<a href="optimiz.htm#connection-threads">раздел 9.12.4.1</a>.</p>

<h3><a name="innodb-performance-multiple_io_threads"></a>16.6.6.
Конфигурирование числа фоновых потоков ввода/вывода InnoDB</h3>
<p>InnoDB применяет фоновые <a href="glossary.htm#glos_thread">потоки</a>
, чтобы обслужить различные типы запросов ввода/вывода. Вы можете
сконфигурировать число фоновых потоков, используя параметры конфигурации
<a href="#sysvar_innodb_read_io_threads"><code>
innodb_read_io_threads</code></a> и
<a href="#sysvar_innodb_write_io_threads"><code>
innodb_write_io_threads</code></a>. Эти параметры показывают число фоновых
потоков, используемых для чтения и записи, соответственно. Они эффективны на
всех поддержанных платформах. Вы можете установить значение этих параметров в
файле опции MySQL (<code>my.cnf</code> или <code>my.ini</code>),
Вы не можете изменить их динамически. Значение по умолчанию для этих
параметров <code>4</code> допустимые значения <code>1-64</code>.</p>

<p>Цель этого изменения состоит в том, чтобы сделать InnoDB более
масштабируемым на системах высокого класса. Каждый фоновый поток может
обработать до 256 запросов ввода/вывода. Основной источник фонового
ввода/вывода это запросы
<a href="glossary.htm#glos_read_ahead">предвыборки</a>. InnoDB
пытается сбалансировать загрузку входящих запросов таким способом, которым
большая часть фоновой доли потоков работает одинаково. InnoDB также пытается
выделить запросы чтения от того же самого экстента к тому же самому потоку,
чтобы увеличить возможности соединения запросов вместе.
Если у Вас есть подсистема ввода/вывода высокого класса, и Вы видите больше,
чем 64 ждущих чтения запросов в <code>SHOW ENGINE INNODB STATUS</code>, Вы
могли бы извлечь пользу, увеличивая значение
<a href="#sysvar_innodb_read_io_threads"><code>
innodb_read_io_threads</code></a>.</p>
<p>Для получения дополнительной информации о работе ввода/вывода InnoDB см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</p>

<h3><a name="innodb-performance-thread_io_rate"></a>16.6.7.
Конфигурирование ведущего уровня ввода/вывода потока InnoDB</h3>
<p><a href="glossary.htm#glos_master_thread">Мастер-поток</a> в InnoDB это
поток, который выполняет различные задачи в фоне. Большинство этих задач
связаны с вводом/выводом, такие, как сброс грязных страниц из буферного пула
или запись изменений из буфера вставки в соответствующий вторичный индекс.
Основной поток пытается выполнить эти задачи способом, который не оказывает
негативное влияние на нормальную работу сервера. Это пытается оценить
свободную доступную пропускную способность ввода/вывода и настроить свои
действия, чтобы использовать в своих интересах эту свободную способность.
Исторически InnoDB использовал твердое кодированное значение 100 IOPs
(операций ввода/вывода в секунду) как полная способность
ввода/вывода сервера.</p>

<p>Параметр <a href="#sysvar_innodb_io_capacity"><code>
innodb_io_capacity</code></a> указывает на полную способность ввода/вывода,
доступную InnoDB. Эти параметры должны быть установлены к приблизительному
числу операций ввода/вывода, которые система может выполнить в секунду.
Значение зависит от Вашей системной конфигурации. Когда
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> задано, основной поток оценивает пропускную способность
ввода/вывода, доступную для фоновых задач, исходя из этого значения.
Установка значения в <code>100</code> возвращает к старому поведению.</p>

<p>Вы можете установить значение
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> к числу 100 или больше. Значение по умолчанию <code>200</code>,
отражает, что производительность типичных современных устройств ввода/вывода
выше, чем в первые годы MySQL. Как правило, значения около предыдущего
значения по умолчанию 100 являются подходящими для устройств хранения данных
потребительского уровня, таких как жесткие диски до 7200 RPM.
Более быстрые жесткие диски, конфигурации RAID и SSD
извлекают выгоду из более высоких значений.</p>

<p><a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> задает полный предел для всех экземпляров буферного пула. Когда
грязные страницы сбрасываются, предел
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> разделен одинаково среди экземпляров буферного пула.
Для получения дополнительной информации см. описание переменной
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>.</p>

<p>Вы можете установить значение этого параметра в файле опций MySQL
или изменить динамически с помощью <code>SET GLOBAL</code>, при
наличии привилегии <code>SUPER</code>.</p>

<p>Опция <a href="#sysvar_innodb_flush_sync"><code>
innodb_flush_sync</code></a> предписывает игнорировать
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> во время взрывов деятельности ввода/вывода, которые происходят в
контрольных точках. <a href="#sysvar_innodb_flush_sync"><code>
innodb_flush_sync</code></a> включена по умолчанию.</p>

<p>В более ранних выпусках MySQL основной поток <code>InnoDB</code> также
выполнял любые необходимые операции <a href="glossary.htm#glos_purge">чистки
</a>. Те операции ввода/вывода теперь выполнены другими фоновыми потоками,
числом которых управляет опция
<a href="#sysvar_innodb_purge_threads"><code>innodb_purge_threads
</code></a>.</p>
<p>Для получения дополнительной информации о работе ввода/вывода InnoDB см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</p>

<h3><a name="innodb-performance-spin_lock_polling"></a>16.6.8.
Конфигурирование опроса спин-блокировки</h3>
<p>Много InnoDB <a href="glossary.htm#glos_mutex">mutex</a> и
<a href="glossary.htm#glos_rw_lock">rw-блокировок</a>
сохранены в течение короткого времени. На мультиядерной системе может быть
более эффективно для потока непрерывно проверять, может ли это приобрести
mutex или rw-блокировку некоторое время перед сном. Если mutex или
rw-блокировка становятся доступными во время этого периода, поток может
немедленно продолжиться в том же самом интервале времени. Однако, также
частый опрос многократными потоками совместно используемого объекта может
вызвать <span><span>перегрузку кэша</span></span>. InnoDB
минимизирует эту проблему при ожидании случайное время между последующими
опросами. Задержка осуществлена как цикл.</p>

<p>Вы можете управлять максимальной задержкой между тестированием mutex или
rw-блокировки, используя параметр
<a href="#sysvar_innodb_spin_wait_delay"><code>
innodb_spin_wait_delay</code></a>. Продолжительность цикла задержки зависит
от компилятора C и целевого процессора. В эру Pentium на 100 МГц задержка
была одной микросекундой. На системе, где все ядра процессора совместно
используют быструю кэш-память, Вы могли бы уменьшить максимальную задержку
или отключить цикл, устанавливая
<code>innodb_spin_wait_delay=0</code>. На многопроцессорной системе
эффект аннулирования кэша может быть более существенным, и Вы могли бы
увеличить максимальную задержку.</p>

<p>Значение по умолчанию
<a href="#sysvar_innodb_spin_wait_delay"><code>
innodb_spin_wait_delay</code></a> <code>6</code>.
Задержка это динамический глобальный параметр, который Вы можете определить в
файле опции MySQL или командой <code>SET GLOBAL
innodb_spin_wait_delay=<em><code>delay</code></em></code>, где
<code><em><code>delay</code></em></code> желаемая максимальная задержка.
Изменение настроек требует привилегии <code>SUPER</code>.</p>
<p>Для исполнительных соображений операций блокировки в InnoDB см.
<a href="optimiz.htm#locking-issues">раздел 9.11</a>.</p>

<h3><a name="innodb-improved-purge-scheduling"></a>16.6.9.
Конфигурирование планирования чистки InnoDB</h3>
<p><a href="glossary.htm#glos_purge">Чистка</a> (тип сбора мусора), которую
InnoDB выполняет автоматически, теперь сделана в одном или более отдельных
потоках, а не как часть <a href="glossary.htm#glos_master_thread">
мастер-потока</a>. Это изменение улучшает масштабируемость, потому что
основные операции базы данных работают независимо от работы
обслуживания, происходящей в фоне.</p>

<p>Чтобы управлять этой особенностью, увеличьте значение параметра
конфигурации <a href="#sysvar_innodb_purge_threads"><code>
innodb_purge_threads</code></a>. Если действие DML сконцентрировано на
единственной таблице или нескольких таблицах, сохраните установку низкой так,
чтобы потоки не боролись друг с другом за доступ к занятым таблицам. Если
операции DML распространены на многие таблицы,
увеличивайте установку. Ее максимум 32.</p>

<p>Есть другой связанный параметр конфигурации
<a href="#sysvar_innodb_purge_batch_size"><code>
innodb_purge_batch_size</code></a> со значением по умолчанию 300 и
максимальным значением 5000. Эта опция, главным образом, предназначена для
экспериментирования и настройки операций чистки и не должна быть
интересной типичным пользователям.</p>
<p>Для получения дополнительной информации о работе ввода/вывода InnoDB см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</p>

<h3><a name="innodb-performance-optimizer-statistics"></a>16.6.10.
Настройка оптимизатора статистики для InnoDB</h3>
<p>Этот раздел описывает, как сконфигурировать постоянную статистику для
таблиц <code>InnoDB</code>.</p>

<p>Статистические данные сохранены через перезапуски сервера, учитывая
большую <a href="glossary.htm#glos_plan_stability">стабильность плана</a> и
и более последовательную работу запроса. Постоянные статистические данные
также обеспечивают управление и гибкость с этими дополнительными выгодами:
</p>

<ul><li><p>Вы можете использовать параметр конфигурации
<a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a>, чтобы управлять, обновлены ли
статистические данные автоматически после существенных изменений в таблице.
</li>

<li>Вы можете использовать параметры <code>STATS_PERSISTENT</code>,
<code>STATS_AUTO_RECALC</code> и <code>STATS_SAMPLE_PAGES</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, чтобы
сконфигурировать статистику для отдельных таблиц.</li>

<li>Вы можете запросить данные о статистике в таблицах
<code>mysql.innodb_table_stats</code> и
<code>mysql.innodb_index_stats</code>.</li>

<li>Вы можете рассмотреть столбец <code>last_update</code> таблиц
<code>mysql.innodb_table_stats</code> и
<code>mysql.innodb_index_stats</code>, чтобы видеть, когда
статистические данные обновлялись.</li>

<li>Вы можете вручную изменить таблицы
<code>mysql.innodb_table_stats</code> и
<code>mysql.innodb_index_stats</code>, чтобы вызвать определенный план
оптимизации запроса или проверить альтернативные планы,
не изменяя базу данных.</p></li></ul>

<p>Постоянная опция статистики активирована по умолчанию
(<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent=ON</code></a>).</p>

<p>Нестойкие статистические данные очищены на каждом перезапуске сервера и
после некоторых других операций, и повторно вычислены при следующем доступе
к таблице. В результате различные оценки могли быть произведены при
перевычислении статистики, приводя к различному выбору в планах выполнения и
изменениям в работе запроса.</p>

<p>Этот раздел также предоставляет информацию об оценке сложности
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>, которая может
быть полезной, пытаясь достигнуть баланса между точной статистикой и
временем выполнения <a href="sql.htm#analyze-table"><code>ANALYZE TABLE
</code></a>.</p>

<h4><a name="innodb-persistent-stats"></a>16.6.10.1.
Конфигурирование постоянных параметров статистики</h4>
<p>Постоянная статистика улучшает
<a href="glossary.htm#glos_plan_stability">стабильность плана</a>, храня
статистику на диске и делая ее постоянной через перезапуски сервера так,
чтобы <a href="glossary.htm#glos_optimizer">оптимизатор</a>, более вероятно,
сделал последовательный выбор каждый раз для данного запроса.</p>

<p>Статистические данные сохранены на диск, когда
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent=ON</code></a> или когда отдельные таблицы составлены
или изменены с <a href="sql.htm#create-table"><code>STATS_PERSISTENT=1</code>
</a>. <a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a> включен по умолчанию.</p>

<p>Прежде статистика была очищена при каждом перезапуске сервера и после
некоторых других операций и повторно вычислена при следующем доступе к
таблице. Следовательно, различные оценки могли быть произведены, повторно
вычисляя статистику, приводя к различному выбору в планах выполнения запроса
и таким образом изменениям в работе запроса.</p>

<p>Постоянные статистические данные сохранены в таблицах
<code>mysql.innodb_table_stats</code> и
<code>mysql.innodb_index_stats</code>, как описано в
<a href="#innodb-persistent-stats-tables">разделе 16.6.10.1.5</a>.
</p>

<p>Чтобы вернуться к использованию нестойкой
статистики, Вы можете изменить таблицы, используя
<code>ALTER TABLE <em><code>tbl_name</code></em> STATS_PERSISTENT=0</code>.
Для соответствующей информации см.
<a href="#innodb-statistics-estimation">раздел 16.6.10.2</a>.</p>

<h5><a name="innodb-persistent-stats-auto-recalc"></a>
16.6.10.1.1. Конфигурирование автоматического вычисления
для постоянной статистики</h5>
<p>Опция <a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a>, которая включена по умолчанию,
определяет, вычислены ли статистические данные автоматически всякий раз,
когда таблица подвергается существенным изменениям (больше, чем 10% строк).
Вы можете также сконфигурировать автоматический перерасчет статистики для
отдельных таблиц, используя параметр <code>STATS_AUTO_RECALC</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
<a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a> включен по умолчанию.</p>

<p>Из-за асинхронной природы автоматического перерасчета статистики
(который происходит в фоне), статистика не может быть повторно вычислена
немедленно после выполнения работы DML, которая затрагивает больше, чем
10% таблицы, даже когда включен
<a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a>.
В некоторых случаях перерасчет статистики может быть отсрочен на несколько
секунд. Если современные статистические данные требуются немедленно после
изменения существенных частей таблицы, выполните
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>, чтобы
начать синхронный перерасчет статистики.</p>

<p>Если <a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a> отключен, гарантируйте точность
статистики через <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code>
</a> для каждой применимой таблицы после существенных изменений
индексированных столбцов. Вы могли бы выполнить этот запрос в своих скриптах
после того, как представительные данные были загружены в таблицу, и
периодически после того, как операции DML значительно изменяют содержание
индексированных столбцов, или по графику во время низкой активности.
Когда новый индекс добавлен к существующей таблице,
статистика вычисленыа и добавлена к таблице <code>innodb_index_stats</code>
независимо от значения <a href="#sysvar_innodb_stats_auto_recalc">
<code>innodb_stats_auto_recalc</code></a>.</p>

<p>Чтобы гарантировать сбор статистики, когда новый индекс создается,
включите <a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a> или выполните
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> после создания
каждого нового индекса, когда постоянный режим статистики включен.</p>

<h5><a name="innodb-persistent-stats-table-configuration"></a>16.6.10.1.2.
Параметры статистики для отдельных таблиц</h5>
<p><a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a>,
<a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a> и
<a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a>
глобальные параметры конфигурации. Чтобы переопределить эти настройки в
масштабе всей системы и сконфигурировать параметры статистики для отдельных
таблиц, Вы можете определить параметры <code>STATS_PERSISTENT</code>,
<code>STATS_AUTO_RECALC</code> и <code>STATS_SAMPLE_PAGES</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<ul><li><p><code>STATS_PERSISTENT</code> определяет, включить ли
<a href="glossary.htm#glos_persistent_statistics">постоянную статистику
</a> для таблицы <code>InnoDB</code>. Значение <code>DEFAULT</code>
заставляет постоянную установку статистики для таблицы быть определенной
опцией <a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a>. Значение <code>1</code>
включает постоянную статистику для таблицы, в то время как значение
<code>0</code> выключает эту особенность. После включения постоянной
статистики через <code>CREATE TABLE</code> или <code>ALTER TABLE</code>
скомандуйте <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>,
чтобы вычислить статистику, после загрузки представительных данных в таблицу.
</li>

<li><code>STATS_AUTO_RECALC</code> определяет, вычислить ли повторно
автоматически <a href="glossary.htm#glos_persistent_statistics">постоянную
статистику</a> для таблицы <code>InnoDB</code>. Значение <code>DEFAULT</code>
предписывает взять значение опции
<a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a>. Значение <code>1</code> указывает, что
статистика будет повторно вычислена, когда 10% данных в таблице изменились.
Значение <code>0</code> предотвращает автоматический пересчет для этой
таблицы, с этой установкой скомандуйте <a href="sql.htm#analyze-table"><code>
ANALYZE TABLE</code></a>, чтобы повторно вычислить статистику после
существенных изменений в таблице.</li>

<li><code>STATS_SAMPLE_PAGES</code> определяет число индексных страниц в
образце, оценивая количество элементов и другую статистику для
индексированного столбца, таких как вычисленные
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.</p></li></ul>

<p>Все три пункта определены в следующем примере
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE `t1` (`id` int(8) NOT NULL auto_increment,
                   `data` varchar(255), `date` datetime, PRIMARY KEY (`id`),
                   INDEX `DATE_IX` (`date`)) ENGINE=InnoDB,
                   STATS_PERSISTENT=1, STATS_AUTO_RECALC=1,
                   STATS_SAMPLE_PAGES=25;
</pre>

<h5><a name="innodb-persistent-stats-pages-sampled"></a>16.6.10.1.3.
Конфигурирование числа выбранных страниц для статистики InnoDB</h5>
<p>MySQL запрашивают оцененную
<a href="glossary.htm#glos_statistics">статистику</a> использования
ключевых распределений, чтобы выбрать индексирование для плана выполнения,
основанное на относительной
<a href="glossary.htm#glos_selectivity">селективности</a> индексирования.
Такие операции, как <a href="sql.htm#analyze-table"><code>ANALYZE TABLE
</code></a> просят <code>InnoDB</code> пробовать случайные страницы каждого
индекса таблицы, чтобы оценить
<a href="glossary.htm#glos_cardinality">количество элементов</a>
индексирования. Этот метод известен как
<a href="glossary.htm#glos_random_dive">случайные погружения</a>.</p>

<p>Чтобы дать Вам контроль над качеством оценки статистики (и таким образом
лучшую информацию для запроса), Вы можете изменить число выбранных страниц,
используя параметр
<a href="#sysvar_innodb_stats_persistent_sample_pages">
<code>innodb_stats_persistent_sample_pages</code></a>,
который может быть установлен во время выполнения.</p>

<p><a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a>
имеет значение по умолчанию 20. Как общее руководство, рассмотрите изменение
этого параметра, сталкиваясь со следующими проблемами:</p>

<ol type="1"><li><p><span><em>Statistics are not accurate enough and the
optimizer chooses suboptimal plans</em></span> в выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a>.
Точность статистики может быть проверена, сравнивая фактическое количество
элементов индексирования (как возвращено
<a href="sql.htm#select"><code>SELECT DISTINCT</code></a>
на столбцах индекса с оценками, обеспеченными таблице
<code>mysql.innodb_index_stats</code>.</p>

<p>Если решено, что статистические данные недостаточно точны, значение
<a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a>
должно быть увеличено, пока оценки статистики не станут достаточно точными.
Увеличение <a href="#sysvar_innodb_stats_persistent_sample_pages">
<code>innodb_stats_persistent_sample_pages</code></a>, однако, может вызвать
замедление <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
</li>

<li><span><em><a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
работает медленно</em></span>. В этом случае
<a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a> надо уменьшить до приемлемой
скорости <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
Уменьшение значения, однако, могло привести к первой проблеме неточной
статистики и подоптимальных планов выполнения запроса.</p>

<p>Если баланс не может быть достигнут между точной статистикой и скоростью
statistics and <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
помните, что сокращение числа индексированных столбцов в таблице или
ограничение числа разделов уменьшает сложность
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
Число столбцов в первичном ключе таблицы также важно, поскольку столбцы
первичного ключа добавлены к каждому групповому индексу.</p>

<p>Для соответствующей информации см.
<a href="#innodb-analyze-table-complexity">раздел 16.6.10.3</a>.
</p></li></ol>

<h5><a name="innodb-persistent-stats-delete-marked"></a>16.6.10.1.4.
Включение помеченных для удаления записей в вычисления статистики</h5>
<p>По умолчанию <code>InnoDB</code> читает нейтральные данные, вычисляя
статистику. В случае нейтральной транзакции, которая удаляет строки из
таблицы, <code>InnoDB</code> исключает записи, которые отмечены как
удаленные, вычисляя оценки строки и индексную статистику, которая может
привести к неоптимальным планам выполнения относительно других транзакций,
которые воздействуют на таблицу, одновременно используя операционный уровень
изоляции, кроме <a href="#isolevel_read-uncommitted"><code>READ
UNCOMMITTED</code></a>. Чтобы обойти эту ситуацию, опция
<a href="#sysvar_innodb_stats_include_delete_marked"><code>
innodb_stats_include_delete_marked</code></a> может быть включена, чтобы
гарантировать, что <code>InnoDB</code> добавляет записи, которые отмечены как
удаленные, вычисляя постоянную статистику.</p>

<p>При включении <a href="#sysvar_innodb_stats_include_delete_marked">
<code>innodb_stats_include_delete_marked</code></a>
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
рассматривает помеченные как удаленные записи, повторно вычисляя статистику.
</p>

<p><a href="#sysvar_innodb_stats_include_delete_marked"><code>
innodb_stats_include_delete_marked</code></a> глобальная установка, которая
затрагивает все таблицы. Это применимо только к постоянной статистике.
<a href="#sysvar_innodb_stats_include_delete_marked"><code>
innodb_stats_include_delete_marked</code></a> была введена в MySQL 8.0.1.</p>

<h5><a name="innodb-persistent-stats-tables"></a>16.6.10.1.5.
Постоянные таблицы статистики InnoDB</h5>
<p>Постоянная статистика полагается на таблицы
<code>innodb_table_stats</code> и
<code>innodb_index_stats</code> в базе данных <code>mysql</code>.
Эти таблицы настроены автоматически в ходе установки и обновления.</p>

<a name="innodb-table-stats-table"></a><p><b>Таблица 16.3.
Столбцы innodb_table_stats</b></p>
<table border="1">
<thead><tr><th>Имя столбца</th><th>Описание</th></tr></thead>
<tbody><tr><td><code>database_name</code></td><td>Имя базы данных</td></tr>
<tr><td><code>table_name</code></td><td>Имя таблицы, имя
раздела или подраздела</td></tr>
<tr><td><code>last_update</code></td><td>timestamp, указывающий последнее
время обновления этой строки</td></tr>
<tr><td><code>n_rows</code></td><td>Число строк в таблице</td></tr>
<tr><td><code>clustered_index_size</code></td><td>
Размер первичного индекса в страницах</td></tr>
<tr><td><code>sum_of_other_index_sizes</code></td><td>
Полный размер других (не первичных) индексов в страницах
</td></tr></tbody></table>

<a name="innodb-index-stats-table"></a><p><b>
Таблица 16.4. Столбцы innodb_index_stats</b></p>
<table border="1">
<thead><tr><th>Столбец</th><th>Описание</th></tr></thead>
<tbody><tr><td><code>database_name</code></td><td>Имя базы данных</td></tr>
<tr><td><code>table_name</code></td><td>Имя таблицы, имя
раздела или подраздела</td></tr>
<tr><td><code>index_name</code></td><td>Имя индекса</td></tr>
<tr><td><code>last_update</code></td><td>timestamp, указывающий последнее
время обновления этой строки</td></tr>
<tr><td><code>stat_name</code></td><td>Название статистической величины, о
значении которой сообщают в столбце <code>stat_value</code></td></tr>
<tr><td><code>stat_value</code></td><td>Значение статистической величины,
которая названа в столбце <code>stat_name</code></td></tr>
<tr><td><code>sample_size</code></td><td>Число страниц, выбранных для оценки
величины в столбце <code>stat_value</code></td></tr>
<tr><td><code>stat_description</code></td><td>
Описание статистической величины, которую называют в столбце
<code>stat_name</code></td></tr></tbody></table>

<p>Таблицы <code>innodb_table_stats</code> и
<code>innodb_index_stats</code> включают столбец
<code>last_update</code>, показывающий, когда <code>InnoDB</code> в последний
раз обновлени индексную статистику, как показано в следующем примере:
<pre>
mysql&gt; select * from innodb_table_stats \G
*************************** 1. row ***************************
 database_name: sakila
table_name: actor
   last_update: 2014-05-28 16:16:44
n_rows: 200
clustered_index_size: 1
sum_of_other_index_sizes: 1
...

mysql&gt; select * from innodb_index_stats \G
*************************** 1. row ***************************
   database_name: sakila
  table_name: actor
  index_name: PRIMARY
 last_update: 2014-05-28 16:16:44
   stat_name: n_diff_pfx01
  stat_value: 200
 sample_size: 1
 ...
</pre>

<p>Таблицы <code>innodb_table_stats</code> и
<code>innodb_index_stats</code> это обычные таблицы и могут быть обновлены
вручную. Способность обновить статистику вручную позволяет вызвать
определенный план оптимизации запроса или проверить альтернативные планы, не
изменяя базу данных. Если Вы вручную обновляете статистику, скомандуйте
<code>FLUSH TABLE <em><code>tbl_name</code></em></code>, чтобы заставить
MySQL перезагрузить обновленную статистику.</p>

<h5><a name="innodb-persistent-stats-tables-example"></a>16.6.10.1.6.
Пример постоянной табличной статистики InnoDB</h5>
<p>Таблица <code>innodb_table_stats</code> содержит одну строку на таблицу.
Собранные данные продемонстрированы в следующем примере.</p>

<p>Таблица <code>t1</code> содержит первичный индекс (столбцы
<code>a</code>, <code>b</code>), вторичный индекс
(столбцы <code>c</code>, <code>d</code>) и уникальный индекс
(столбцы <code>e</code>,<code> f</code>):
<pre>
CREATE TABLE t1 (a INT, b INT, c INT, d INT, e INT, f INT,
       PRIMARY KEY (a, b), KEY i1 (c, d),
       UNIQUE KEY i2uniq (e, f)) ENGINE=INNODB;
</pre>

<p>После вставки пяти строк типовых данных таблица выглядит так:
<pre>
mysql&gt; SELECT * FROM t1;
+---+---+----+----+-----+-----+
| a | b | c  | d  | e   | f   |
+---+---+----+----+-----+-----+
| 1 | 1 | 10 | 11 | 100 | 101 |
| 1 | 2 | 10 | 11 | 200 | 102 |
| 1 | 3 | 10 | 11 | 100 | 103 |
| 1 | 4 | 10 | 12 | 200 | 104 |
| 1 | 5 | 10 | 12 | 100 | 105 |
+---+---+----+----+-----+-----+
</pre>

<p>Чтобы немедленно обновить статистику, скомандуйте
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> (если включена
<a href="#sysvar_innodb_stats_auto_recalc"><code>
innodb_stats_auto_recalc</code></a>, статистические данные обновлены
автоматически в течение нескольких секунд, предполагая, что порог 10%
для измененных строк таблицы достигнут):
<pre>
mysql&gt; ANALYZE TABLE t1;
+---------+---------+----------+----------+
| Table   | Op      | Msg_type | Msg_text |
+---------+---------+----------+----------+
| test.t1 | analyze | status   | OK       |
+---------+---------+----------+----------+
</pre>

<p>Табличная статистика для таблицы показывает: обновлена в последний раз
<code>2014-03-14 14:36:34</code>, число строк в таблице (<code>5</code>),
размер кластеризируемого индекса (<code>1</code> страница)
и объединенный размер других индексов (<code>2</code> страницы).
<pre>
mysql&gt; SELECT * FROM mysql.innodb_table_stats WHERE table_name like 't1'\G
*************************** 1. row ***************************
 database_name: test
table_name: t1
   last_update: 2014-03-14 14:36:34
n_rows: 5
clustered_index_size: 1
sum_of_other_index_sizes: 2
</pre>

<p>Таблица <code>innodb_index_stats</code> содержит многократные строки для
каждого индекса. Каждая строка в таблице <code>innodb_index_stats</code>
обеспечивает, данные, связанные с индексируемой статистической величиной,
которую называют в столбце <code>stat_name</code> и описывают в
<code>stat_description</code>, например:
<pre>
mysql&gt; SELECT index_name, stat_name, stat_value, stat_description
    -&gt;        FROM mysql.innodb_index_stats WHERE table_name like 't1';
+------------+--------------+------------+-----------------------------------+
| index_name | stat_name    | stat_value | stat_description                  |
+------------+--------------+------------+-----------------------------------+
| PRIMARY    | n_diff_pfx01 | 1          | a                                 |
| PRIMARY    | n_diff_pfx02 | 5          | a,b                               |
| PRIMARY    | n_leaf_pages | 1          | Number of leaf pages in the index |
| PRIMARY    | size         | 1          | Number of pages in the index      |
| i1         | n_diff_pfx01 | 1          | c                                 |
| i1         | n_diff_pfx02 | 2          | c,d                               |
| i1         | n_diff_pfx03 | 2          | c,d,a                             |
| i1         | n_diff_pfx04 | 5          | c,d,a,b                           |
| i1         | n_leaf_pages | 1          | Number of leaf pages in the index |
| i1         | size         | 1          | Number of pages in the index      |
| i2uniq     | n_diff_pfx01 | 2          | e                                 |
| i2uniq     | n_diff_pfx02 | 5          | e,f                               |
| i2uniq     | n_leaf_pages | 1          | Number of leaf pages in the index |
| i2uniq     | size         | 1          | Number of pages in the index      |
+------------+--------------+------------+-----------------------------------+
</pre>

<p>Столбец <code>stat_name</code> показывает следующие типы статистики:</p>
<ul><li><p><code>size</code>: Где <code>stat_name</code>=<code>size</code>,
столбец <code>stat_value</code> выводит на экран общее
количество страниц в индексе.</li>

<li><code>n_leaf_pages</code>: Где <code>stat_name</code>=<code>n_leaf_pages
</code>, столбец <code>stat_value</code> выводит на экран
число страниц в индексе.</li>

<li><code>n_diff_pfx<em><code>NN</code></em></code>: Где
<code>stat_name</code>=<code>n_diff_pfx01</code>, столбец
<code>stat_value</code> выводит на экран число отличных значений в первом
столбце индексирования. Где <code>stat_name</code>=<code>n_diff_pfx02</code>,
столбец <code>stat_value</code> столбец выводит на экран число отличных
значений в первых двух столбцах индексирования и так далее. Дополнительно где
<code>stat_name</code>=<code>n_diff_pfx<em><code>NN</code></em></code>,
столбец <code>stat_description</code> показывает список разделенных запятой
значений индексированных столбцов, которые посчитаны.</p></li></ul>

<p>Далее <code>n_diff_pfx<em><code>NN</code></em></code> это
статистическая величина, которая обеспечивает данные о количестве элементов,
рассматриваемых в примере таблицы <code>t1</code>. Как показано ниже,
таблица <code>t1</code> составлена с первичным индексом
(столбцы <code>a</code>, <code>b</code>), вторичным индексом (столбцы
<code>c</code>, <code>d</code>) и уникальным индексом (столбцы
<code>e</code>, <code>f</code>):
<pre>
CREATE TABLE t1 (a INT, b INT, c INT, d INT, e INT, f INT,
       PRIMARY KEY (a, b), KEY i1 (c, d),
       UNIQUE KEY i2uniq (e, f)) ENGINE=INNODB;
</pre>

<p>После вставки пяти строк типовых данных таблица выглядит так:
<pre>
mysql&gt; SELECT * FROM t1;
+---+---+----+----+-----+-----+
| a | b | c  | d  | e   | f   |
+---+---+----+----+-----+-----+
| 1 | 1 | 10 | 11 | 100 | 101 |
| 1 | 2 | 10 | 11 | 200 | 102 |
| 1 | 3 | 10 | 11 | 100 | 103 |
| 1 | 4 | 10 | 12 | 200 | 104 |
| 1 | 5 | 10 | 12 | 100 | 105 |
+---+---+----+----+-----+-----+
</pre>

<p>Когда Вы запрашиваете <code>index_name</code>,
<code>stat_name</code>, <code>stat_value</code> и
<code>stat_description</code>, где <code>stat_name LIKE 'n_diff%'</code>,
следующий набор результатов возвращен:
<pre>
mysql&gt; SELECT index_name, stat_name, stat_value, stat_description
    -&gt;        FROM mysql.innodb_index_stats
    -&gt;        WHERE table_name like 't1' AND stat_name LIKE 'n_diff%';
+------------+--------------+------------+------------------+
| index_name | stat_name    | stat_value | stat_description |
+------------+--------------+------------+------------------+
| PRIMARY    | n_diff_pfx01 | 1          | a                |
| PRIMARY    | n_diff_pfx02 | 5          | a,b              |
| i1         | n_diff_pfx01 | 1          | c                |
| i1         | n_diff_pfx02 | 2          | c,d              |
| i1         | n_diff_pfx03 | 2          | c,d,a            |
| i1         | n_diff_pfx04 | 5          | c,d,a,b          |
| i2uniq     | n_diff_pfx01 | 2          | e                |
| i2uniq     | n_diff_pfx02 | 5          | e,f              |
+------------+--------------+------------+------------------+
</pre>

<p>Для индекса <code>PRIMARY</code> есть две строки <code>n_diff%</code>.
Число строк равно числу столбцов в индексировании.</p>
<p>Для группового индекса <code>InnoDB</code> добавляет
столбцы первичного ключа.</p>

<ul><li><p>Где <code>index_name</code>=<code>PRIMARY</code> и
<code>stat_name</code>=<code>n_diff_pfx01</code>,
<code>stat_value</code> <code>1</code>,
который указывает, что есть единственное отличное значение в первом столбце
индексирования (столбец <code>a</code>). Число отличных значений в столбце
<code>a</code> подтверждено, рассматривая данные в столбце
<code>a</code> таблицы <code>t1</code>, в котором есть единственное отличное
значение (<code>1</code>). Посчитанный столбец (<code>a</code>) показан в
столбце <code>stat_description</code> набора результатов.</li>

<li>Где <code>index_name</code>=<code>PRIMARY</code> и
<code>stat_name</code>=<code>n_diff_pfx02</code>,
<code>stat_value</code> <code>5</code>,
который указывает, что есть пять отличных значений в двух столбцах
индексирования (<code>a,b</code>). Число отличных значений в столбцах
<code>a</code> и <code>b</code> подтверждено, рассматривая данные в столбцах
<code>a</code> и <code>b</code> таблицы <code>t1</code>,
в которых есть пять отличных значений: (<code>1,1</code>),
(<code>1,2</code>), (<code>1,3</code>), (<code>1,4</code>) и
(<code>1,5</code>). Посчитанные столбцы (<code>a,b</code>) показаны в
столбце <code>stat_description</code> набора результатов.</p></li></ul>

<p>Для вторичного индекса (<code>i1</code>) есть четыре строки
<code>n_diff%</code>. Только два столбца определены для вторичного индекса
(<code>c,d</code>), но есть четыре строки <code>n_diff%</code> для него,
потому что <code>InnoDB</code> соединяет все групповые индексы с первичным
ключом. В результате есть четыре строки <code>n_diff%</code> вместо двух,
чтобы сосчитать оба столбца вторичного индекса (<code>c,d</code>)
и столбцы первичного ключа (<code>a,b</code>).</p>

<ul><li><p>Где <code>index_name</code>=<code>i1</code> и
<code>stat_name</code>=<code>n_diff_pfx01</code>,
<code>stat_value</code> <code>1</code>, который указывает, что есть
единственное отличное значение в первом столбце индексирования (столбец
<code>c</code>). Число отличных значений в столбце <code>c</code>
подтверждено, рассматривая данные в столбце <code>c</code> в таблице
<code>t1</code>, в котором есть единственное отличное значение:
(<code>10</code>). Посчитанный столбец (<code>c</code>) показан в столбце
<code>stat_description</code> набора результатов.</li>

<li>Где <code>index_name</code>=<code>i1</code> и
<code>stat_name</code>=<code>n_diff_pfx02</code>,
<code>stat_value</code> <code>2</code>,
который указывает, что есть два отличных значения в первых двух столбцах
индексирования (<code>c,d</code>). Число отличных значений в столбцах
<code>c</code> и <code>d</code> подтверждено, рассматривая данные в столбцах
<code>c</code> и <code>d</code> в таблице <code>t1</code>, в которых есть два
отличных значения: (<code>10,11</code>) и (<code>10,12</code>).
Посчитанные столбцы (<code>c,d</code>) показаны в столбце
<code>stat_description</code> набора результатов.</li>

<li>Где <code>index_name</code>=<code>i1</code> и
<code>stat_name</code>=<code>n_diff_pfx03</code>,
<code>stat_value</code> <code>2</code>,
который указывает, что есть два отличных значения в первых трех столбцах
индексирования (<code>c,d,a</code>). Число отличных значений в столбцах
<code>c</code>, <code>d</code> и <code>a</code>
подтверждено, рассматривая данные в столбцах
<code>c</code>, <code>d</code> и <code>a</code> таблицы <code>t1</code>,
в которых есть два отличных значения: (<code>10,11,1</code>) и
(<code>10,12,1</code>). Посчитанные столбцы (<code>c,d,a</code>) показаны в
столбце <code>stat_description</code> набора результатов.</li>

<li>Где <code>index_name</code>=<code>i1</code> и
<code>stat_name</code>=<code>n_diff_pfx04</code>,
<code>stat_value</code> <code>5</code>,
который указывает, что есть пять отличных значений в четырех столбцах
индексирования (<code>c,d,a,b</code>). Число отличных значений в столбцах
<code>c</code>, <code>d</code>, <code>a</code> и <code>b</code>
подтверждено, рассматривая данные в столбцах <code>c</code>,
<code>d</code>, <code>a</code> и <code>b</code> в таблице <code>t1</code>,
в которых есть пять отличных значений:
(<code>10,11,1,1</code>), (<code>10,11,1,2</code>), (<code>10,11,1,3</code>),
(<code>10,12,1,4</code>) и (<code>10,12,1,5</code>). Посчитанные столбцы
(<code>c,d,a,b</code>) показаны в столбце <code>stat_description</code>
набора результатов.</p></li></ul>

<p>Для уникального индекса (<code>i2uniq</code>) есть
две строки <code>n_diff%</code>.</p>
<ul><li><p>Где <code>index_name</code>=<code>i2uniq</code> и
<code>stat_name</code>=<code>n_diff_pfx01</code>,
<code>stat_value</code> <code>2</code>,
который указывает, что есть два отличных значения в первом столбце индекса
(столбец <code>e</code>). Число отличных значений в столбце <code>e</code>
подтверждено, рассматривая данные в столбце <code>e</code> в таблице
<code>t1</code>, в котором есть два отличных значения: (<code>100</code>) и
(<code>200</code>). Посчитанный столбец (<code>e</code>) показан в столбце
<code>stat_description</code> набора результатов.</li>

<li>Где <code>index_name</code>=<code>i2uniq</code> и
<code>stat_name</code>=<code>n_diff_pfx02</code>,
<code>stat_value</code> is <code>5</code>,
который указывает, что есть пять отличных значений в двух столбцах индекса
(<code>e,f</code>). Число отличных значений в столбцах <code>e</code>
и <code>f</code> подтверждено, рассматривая данные в столбцах
<code>e</code> и <code>f</code> в таблице <code>t1</code>,
в котором есть пять отличных значений:
(<code>100,101</code>), (<code>200,102</code>), (<code>100,103</code>),
(<code>200,104</code>) и (<code>100,105</code>). Посчитанные столбцы
(<code>e,f</code>) показаны в столбце
<code>stat_description</code> набора результатов.</p></li></ul>

<h5><a name="innodb-persistent-stats-tables-index-size"></a>16.6.10.1.7.
Получение размера индекса, используя таблицу innodb_index_stats</h5>
<p>Размер индекса для таблицы, раздела или подраздела
может быть получен, используя таблицу <code>innodb_index_stats</code>.
В следующем примере размеры индексов получены для таблицы <code>t1</code>.
Для определения таблицы <code>t1</code> и соответствующей статистики см.
<a href="#innodb-persistent-stats-tables-example">раздел
16.6.10.1.6</a>.
<pre>
mysql&gt; SELECT SUM(stat_value) pages, index_name,
    -&gt;        SUM(stat_value)*@@innodb_page_size size
    -&gt;        FROM mysql.innodb_index_stats WHERE table_name='t1' AND
    -&gt;        stat_name = 'size' GROUP BY index_name;
+-------+------------+-------+
| pages | index_name | size  |
+-------+------------+-------+
| 1     | PRIMARY    | 16384 |
| 1     | i1         | 16384 |
| 1     | i2uniq     | 16384 |
+-------+------------+-------+
</pre>

<p>Для раздела или подраздела подойдет тот же запрос, но с измененным
<code>WHERE</code>. Например, следующий запрос получает размеры индексов
для раздела таблицы <code>t1</code>:
<pre>
mysql&gt; SELECT SUM(stat_value) pages, index_name,
    -&gt;        SUM(stat_value)*@@innodb_page_size size
    -&gt;        FROM mysql.innodb_index_stats
                 WHERE table_name like 't1#P%' AND
    -&gt;        stat_name = 'size' GROUP BY index_name;
</pre>

<h4><a name="innodb-statistics-estimation"></a>16.6.10.2.
Конфигурирование нестойких параметров статистики</h4>
<p>Этот раздел описывает, как сконфигурировать нестойкую статистику.
Статистические данные не сохранены на диске, когда
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent=OFF</code></a> или когда отдельные таблицы составлены
или изменены с <a href="sql.htm#create-table"><code>STATS_PERSISTENT=0</code>
</a>. Вместо этого статистические данные сохранены в памяти и потеряны,
когда сервер закрыт. Статистические данные также периодически обновляются
определенными операциями и при определенных условиях.</p>

<p>Статистические данные сохранены на диск по умолчанию при включении опции
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a>. Для информации о постоянной
статистике см. <a href="#innodb-persistent-stats">раздел 16.6.10.1
</a>.</p>

<h5><a name="innodb-statistics-estimation-update"></a>Обновления статистики
</h5>
<p>Статистические данные обновлены когда:</p>
<ul><li><p>Выполнена <a href="sql.htm#analyze-table"><code>ANALYZE TABLE
</code></a>.</li>

<li>Выполнена <a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS
</code></a>, <a href="sql.htm#show-index"><code>SHOW INDEX</code></a> или
запросы к таблице <a href="inform.htm#tables-table"><code>
INFORMATION_SCHEMA.TABLES</code></a> или
<a href="inform.htm#statistics-table"><code>INFORMATION_SCHEMA.STATISTICS
</code></a> с включенной опцией
<a href="#sysvar_innodb_stats_on_metadata">
<code>innodb_stats_on_metadata</code></a>.</p>

<p>Настройка по умолчанию для
<a href="#sysvar_innodb_stats_on_metadata"><code>
innodb_stats_on_metadata</code></a> <code>OFF</code>. Включение
<a href="#sysvar_innodb_stats_on_metadata"><code>
innodb_stats_on_metadata</code></a> может уменьшить скорость доступа для
схем, у которых есть большое количество таблиц или индексов, и уменьшить
стабильность планов выполнения относительно запросов, которые вовлекают
таблицы <code>InnoDB</code>.
<a href="#sysvar_innodb_stats_on_metadata"><code>
innodb_stats_on_metadata</code></a> сконфигурирована глобально, используя
<a href="types.htm#set"><code>SET</code></a>.
<pre>
SET GLOBAL innodb_stats_on_metadata=ON
</pre></li>

<li>Запуск <a href="programs.htm#mysql"><span><strong>mysql</strong></span>
</a> с опцией <a href="programs.htm#option_mysql_auto-rehash"><code>
--auto-rehash</code></a>, что является значением по умолчанию. Опция
<a href="programs.htm#option_mysql_auto-rehash"><code>auto-rehash</code></a>
предписывает повторно вычислить статистику.</p>

<p>Чтобы улучшить время запуска <a href="programs.htm#mysql"><span><strong>
mysql</strong></span></a> и обновления статистики, Вы можете выключить
<a href="programs.htm#option_mysql_auto-rehash"><code>auto-rehash</code></a>,
используя опцию <a href="programs.htm#option_mysql_auto-rehash"><code>
--disable-auto-rehash</code></a>.
<a href="programs.htm#option_mysql_auto-rehash"><code>auto-rehash</code></a>
позволяет автоматическое завершение имени базы данных, таблицы и столбцов
для интерактивных пользователей.</li>

<li>Таблица открыта первой.</li>
<li><code>InnoDB</code> обнаруживает, что 1/16 таблицы была изменены с
прошлого обновления статистических данных.</p></li></ul>

<h5><a name="idm139965328135968"></a>Конфигурирование числа выбранных страниц
</h5>
<p>Оптимизатор MySQL запрашивают оцененную
<a href="glossary.htm#glos_statistics">статистику</a> о ключевых
распределениях, чтобы выбрать индексирование для плана выполнения,
основанного на относительной
<a href="glossary.htm#glos_selectivity">селективности</a> индекса.
Когда <code>InnoDB</code> обновляет статистику, это пробует случайные
страницы от каждого индекса в таблицы, чтобы оценить
<a href="glossary.htm#glos_cardinality">количество элементов</a> индекса.
Этот метод известен как
<a href="glossary.htm#glos_random_dive">случайные погружения</a>.</p>

<p>Чтобы дать Вам контроль над качеством оценки статистики (и таким образом
лучшую информацию для запроса), Вы можете изменить число выбранных страниц,
используя параметр <a href="#sysvar_innodb_stats_transient_sample_pages">
<code>innodb_stats_transient_sample_pages</code></a>.
Число значения по умолчанию выбранных страниц 8 может быть недостаточным,
чтобы произвести точную оценку. Этот метод особенно важен для больших таблиц
и таблиц, используемых в
<a href="glossary.htm#glos_join">joins</a>. Ненужное
<a href="glossary.htm#glos_full_table_scan">полное сканирование таблицы</a>
для таких таблиц может быть существенной исполнительной проблемой. См.
<a href="optimiz.htm#how-to-avoid-table-scan">раздел 9.2.1.21</a>
для подсказок относительно настройки таких запросов.
<a href="#sysvar_innodb_stats_transient_sample_pages"><code>
innodb_stats_transient_sample_pages</code></a>
глобальный параметр, который может быть установлен во время выполнения.</p>

<p>Значение <a href="#sysvar_innodb_stats_transient_sample_pages">
<code>innodb_stats_transient_sample_pages</code></a> влияет на осуществление
выборки для всех таблиц и нидексов <code>InnoDB</code>, когда
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent=0</code></a>. Знайте о следующем потенциально
существенном влиянии, когда Вы изменяете объем выборки:</p>

<ul><li><p>Маленькие значения как 1 или 2 могут привести к неточным
оценкам количества элементов.</li>
<li>Увеличение <a href="#sysvar_innodb_stats_transient_sample_pages">
<code>innodb_stats_transient_sample_pages</code></a>
могло бы потребовать большего количества дисковых чтений.
Значения, намного больше 8 (например, 100), могут вызвать существенное
замедление во время открытия таблицы или выполнения
<code>SHOW TABLE STATUS</code>.</li>
<li>Оптимизатор мог бы выбрать совсем другие планы запроса, основанные на
различных оценках селективности индекса.</p></li></ul>

<p>Выберите значение, которое приводит к разумно точным оценкам для всех
таблиц в Вашей базе данных, не требуя чрезмерного ввода/вывода. Поскольку
статистические данные автоматически повторно вычислены неоднократно кроме
выполнения <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>,
не имеет смысла увеличивать объем выборки, запуская
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>,
уменьшите объем выборки.</p>

<p>Меньшие таблицы вообще требуют меньшие образцы индекса,
чем большие таблицы. Если у Вашей базы данных есть много больших таблиц,
рассмотрите использование более высокого значения для
<a href="#sysvar_innodb_stats_transient_sample_pages"><code>
innodb_stats_transient_sample_pages</code></a>,
чем если бы у Вас есть главным образом маленькие таблицы.</p>

<h4><a name="innodb-analyze-table-complexity"></a>16.6.10.3.
Оценка сложности ANALYZE TABLE для таблиц InnoDB</h4>
<p>Сложность <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
для таблицы <code>InnoDB</code> зависит от:</p>

<ul><li><p>Числа выбранных страниц, как определено
<a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a>.</li>

<li>Числа индексированных столбцов в таблице.</li>
<li>Числа разделов. Если у таблицы нет никакого
разделения, число разделов 1.</p></li></ul>

<p>Используя эти параметры, приблизительная формула для того, чтобы оценить
сложность <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>:
</p>
<p>Значение <a href="#sysvar_innodb_stats_persistent_sample_pages">
<code>innodb_stats_persistent_sample_pages</code></a>
* число индексированных столбцов в таблице * число разделов.</p>

<p>Как правило, чем больше получающееся значение, тем больше время выполнения
для <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.</p>
<p><a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a> определяет число страниц,
выбранных на глобальном уровне. Чтобы определить число страниц, выбранных для
отдельной таблицы, используйте опцию <code>STATS_SAMPLE_PAGES</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Подробности в
<a href="#innodb-persistent-stats">разделе 16.6.10.1</a>.</p>

<p>Если <a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent=OFF</code></a>, число выбранных страниц определено
<a href="#sysvar_innodb_stats_transient_sample_pages"><code>
innodb_stats_transient_sample_pages</code></a>. См.
<a href="#innodb-statistics-estimation">раздел 16.6.10.2</a>.</p>

<p>Для более всестороннего подхода к оценке сложности <code>ANALYZE
TABLE</code> рассмотрите следующий пример.</p>
<p>В записи <a href="../../../en.wikipedia.org/wiki/Big_O_notation"
target="_top">Big O</a> сложность <a href="sql.htm#analyze-table"><code>
ANALYZE TABLE</code></a> описана как:
<pre>
O(n_sample * (n_cols_in_uniq_i + n_cols_in_non_uniq_i + n_cols_in_pk *
 (1 + n_non_uniq_i)) * n_part)
</pre>

<p>Здесь:</p>
<ul><li><p><code>n_sample</code> число выбранных страниц (определено
<a href="#sysvar_innodb_stats_persistent_sample_pages">
<code>innodb_stats_persistent_sample_pages</code></a>).</li>

<li><code>n_cols_in_uniq_i</code> общее количество всех столбцов всех
уникальных индексов (не считая столбцы первичного ключа).</li>
<li><code>n_cols_in_non_uniq_i</code> общее количество всех столбцов
всех неуникальных индексов.</li>

<li><code>n_cols_in_pk</code> число столбцов в первичном ключе (если
первичный ключ не определен, <code>InnoDB</code>
создает единственный первичный ключ столбца внутренне).</li>

<li><code>n_non_uniq_i</code> число групповых индексов в таблице.</li>
<li><code>n_part</code> число разделов. Если никакое разделение не
определено, таблица является единственным разделом.</p></li></ul>

<p>Теперь, рассмотрите следующую таблицу (таблица <code>t</code>),
у которой есть первичный ключ (2 столбца), уникальный индекс
(2 столбца) и два групповых индекса (по два столбца каждый):
<pre>
CREATE TABLE t (a INT, b INT, c INT, d INT, e INT, f INT, g INT, h INT,
                PRIMARY KEY (a, b), UNIQUE KEY i1uniq (c, d),
                KEY i2nonuniq (e, f), KEY i3nonuniq (g, h));
</pre>

<p>Для данных столбца и индекса, требуемых алгоритмом, описанным выше,
запрашивают постоянный индекс статистики из
<code>mysql.innodb_index_stats</code> для таблицы <code>t</code>.
Статистические данные <code>n_diff_pfx%</code> показывают столбцы, которые
посчитаны для каждого индекса. Например, столбцы
<code>a</code> и <code>b</code> посчитаны для индекса первичного ключа.
Для неуникальных индексов столбцы первичного ключа (a,b)
посчитаны в дополнение к определяемым пользователем столбцам.</p>

<p>Для дополнительной информации о постоянных таблицах статистики
<code>InnoDB</code> см. <a href="#innodb-persistent-stats">раздел
16.6.10.1</a>.</p>
<pre>
SELECT index_name, stat_name, stat_description FROM mysql.innodb_index_stats
       WHERE database_name='test' AND table_name='t' AND
       stat_name like 'n_diff_pfx%';
+------------+--------------+------------------+
| index_name | stat_name    | stat_description |
+------------+--------------+------------------+
| PRIMARY    | n_diff_pfx01 | a                |
| PRIMARY    | n_diff_pfx02 | a,b              |
| i1uniq     | n_diff_pfx01 | c                |
| i1uniq     | n_diff_pfx02 | c,d              |
| i2nonuniq  | n_diff_pfx01 | e                |
| i2nonuniq  | n_diff_pfx02 | e,f              |
| i2nonuniq  | n_diff_pfx03 | e,f,a            |
| i2nonuniq  | n_diff_pfx04 | e,f,a,b          |
| i3nonuniq  | n_diff_pfx01 | g                |
| i3nonuniq  | n_diff_pfx02 | g,h              |
| i3nonuniq  | n_diff_pfx03 | g,h,a            |
| i3nonuniq  | n_diff_pfx04 | g,h,a,b          |
+------------+--------------+------------------+
</pre>

<p>Основываясь на индексных данных о статистике, показанных выше, и табличном
определении, следующие значения могут быть определены:</p>
<ul><li><p><code>n_cols_in_uniq_i</code>,
общее количество всех столбцов во всех уникальных индексах, не считая
столбцов первичного ключа, 2 (<code>c</code> и <code>d</code>).</li>

<li><code>n_cols_in_non_uniq_i</code>, общее количество всех столбцов
во всех неуникальных индексах 4 (<code>e</code>, <code>f</code>,
<code>g</code> и <code>h</code>).</li>

<li><code>n_cols_in_pk</code>, число столбцов в первичном ключе
2 (<code>a</code> и <code>b</code>).</li>
<li><code>n_non_uniq_i</code>, число групповых индексов в таблице 2
(<code>i2nonuniq</code> и <code>i3nonuniq</code>)).</li>
<li><code>n_part</code>, число разделов 1.</p></li></ul>

<p>Вы можете теперь вычислить
<code>innodb_stats_persistent_sample_pages</code> * (2 + 4
+ 2 * (1 + 2)) * 1, чтобы определить число страниц, которые отсканированы. С
установкой <code>innodb_stats_persistent_sample_pages</code> в
значение по умолчанию <code>20</code> и с размером страницы по умолчанию
16 <code>KiB</code> (<a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a>=16384) Вы можете тогда оценить, что
20 * 12 * 16384 <code>байт</code> считаны из таблицы <code>t</code>
или приблизительно 4 <code>MiB</code>.</p>
<p>Все 4 <code>MiB</code> возможно, не будут считаны с диска, поскольку
некоторые страницы могут уже кэшироваться в буферном пуле.</p>

<h3><a name="index-page-merge-threshold"></a>16.6.11.
Конфигурирование порога слияния для индексных страниц</h3>
<p>Вы можете сконфигурировать значение <code>MERGE_THRESHOLD</code> для
индексных страниц. Если процент <span><span>полных страниц</span></span>
для индексной страницы падает ниже <code>MERGE_THRESHOLD</code>, когда строка
удалена или сокращена через <a href="sql.htm#update"><code>UPDATE</code></a>,
<code>InnoDB</code> пробует слить индексную страницу с соседней индексной
страницей. Значение по умолчанию <code>MERGE_THRESHOLD</code> 50, что
является ранее неизменным значением.
Минимум <code>MERGE_THRESHOLD</code> 1 и максимальное значение 50.</p>

<p>Когда процент <span><span>полных страниц</span></span>
для индексной страницы падает ниже 50%, что является значением по умолчанию
для <code>MERGE_THRESHOLD</code>, <code>InnoDB</code> пробует
слить индексную страницу с соседней страницей. Если обе страницы близки к
полным 50%, разделение страницы может произойти вскоре после того, как
страницы слиты. Если это происходит часто, у него может быть неблагоприятное
влияние на производительность. Чтобы избежать частых разделений слияния, Вы
можете понизить <code>MERGE_THRESHOLD</code> так, чтобы <code>InnoDB</code>
сливал страницы при более низком проценте
<span><span>полных страниц</span></span>. Слияние страниц в более низком
проценте полной страницы освобождает больше места в индексных страницах и
помогает уменьшить разделение после слияния.</p>

<p><code>MERGE_THRESHOLD</code> для индексных страниц может быть определен
для таблицы или индекса. <code>MERGE_THRESHOLD</code> для отдельного индекса
берет приоритет над <code>MERGE_THRESHOLD</code> для таблицы. Если не
определен, значение <code>MERGE_THRESHOLD</code> по умолчанию 50.</p>

<h4><a name="idm139965328018000"></a>Установка MERGE_THRESHOLD для таблицы
</h4>
<p>Вы можете установить значение <code>MERGE_THRESHOLD</code>
для таблицы, используя предложение параметр <code>COMMENT</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE t1 (id INT, KEY id_index (id)) COMMENT='MERGE_THRESHOLD=45';
</pre>

<p>Вы можете также установить значение <code>MERGE_THRESHOLD</code>
для существующей таблицы, используя параметр <code>COMMENT</code> в
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>:
<pre>
CREATE TABLE t1 (id INT, KEY id_index (id));
ALTER TABLE t1 COMMENT='MERGE_THRESHOLD=40';
</pre>

<h4><a name="idm139965328008672"></a>Задание MERGE_THRESHOLD для индекса</h4>
<p>Установить значение <code>MERGE_THRESHOLD</code> для индекса можно через
параметр <code>COMMENT</code> в запросах <a href="sql.htm#create-table">
<code>CREATE TABLE</code></a>,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> или
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a>:</p>
<pre>
CREATE TABLE t1 (id INT, KEY id_index (id) COMMENT 'MERGE_THRESHOLD=40');
</pre>

<p>Или:
<pre>
CREATE TABLE t1 (id INT, KEY id_index (id));
ALTER TABLE t1 DROP KEY id_index;
ALTER TABLE t1 ADD KEY id_index (id) COMMENT 'MERGE_THRESHOLD=40';
</pre>

<p>Или:
<pre>
CREATE TABLE t1 (id INT);
CREATE INDEX id_index ON t1 (id) COMMENT 'MERGE_THRESHOLD=40';
</pre>

<p>Вы не можете изменить <code>MERGE_THRESHOLD</code> на уровне индекса
для <code>GEN_CLUST_INDEX</code>, который является кластеризируемым индексом,
создаваемым <code>InnoDB</code>, когда таблица составлена без первичного
ключа или индекса уникального ключа. Вы можете только изменить
<code>MERGE_THRESHOLD</code> для <code>GEN_CLUST_INDEX</code> установкой
<code>MERGE_THRESHOLD</code> для таблицы.</p>

<h4><a name="idm139965327984800"></a>
Запрос значения MERGE_THRESHOLD для индекса</h4>
<p>Текущее значение <code>MERGE_THRESHOLD</code> для индекса может быть
получено, запрашивая таблицу <a href="inform.htm#innodb-sys-indexes-table">
<code>INNODB_SYS_INDEXES</code></a>:
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES
                   WHERE NAME='id_index' \G
*************************** 1. row ***************************
   INDEX_ID: 91
 NAME: id_index
   TABLE_ID: 68
 TYPE: 0
   N_FIELDS: 1
PAGE_NO: 4
SPACE: 57
MERGE_THRESHOLD: 40
</pre>

<p>Вы можете использовать <a href="sql.htm#show-create-table"><code>SHOW
CREATE TABLE</code></a>, чтобы посмотреть значение
<code>MERGE_THRESHOLD</code> для таблицы, если явно определено, используя
предложение <em><code>table_option</code></em> <code>COMMENT</code>:
<pre>
mysql&gt; SHOW CREATE TABLE t2 \G
*************************** 1. row ***************************
   Table: t2
Create Table: CREATE TABLE `t2` (
  `id` int(11) DEFAULT NULL,
  KEY `id_index` (`id`) COMMENT 'MERGE_THRESHOLD=40'
) ENGINE=InnoDB DEFAULT CHARSET=latin1
</pre>

<p><code>MERGE_THRESHOLD</code> для индексного уровня берет приоритет над
<code>MERGE_THRESHOLD</code> уровня таблицы. Если не определено, то 50%
(<code>MERGE_THRESHOLD=50</code>).</p>

<p>Аналогично, Вы можете использовать <a href="sql.htm#show-index"><code>SHOW
INDEX</code></a> для просмотра <code>MERGE_THRESHOLD</code>
для индексирования, если явно определено, используя <code>COMMENT</code>:
<pre>
mysql&gt; SHOW INDEX FROM t2 \G
*************************** 1. row ***************************
Table: t2
   Non_unique: 1
 Key_name: id_index
 Seq_in_index: 1
  Column_name: id
Collation: A
  Cardinality: 0
 Sub_part: NULL
   Packed: NULL
 Null: YES
   Index_type: BTREE
  Comment:
Index_comment: MERGE_THRESHOLD=40
</pre>

<h4><a name="idm139965327966544"></a>Измерение эффекта MERGE_THRESHOLD</h4>
<p>Таблица <a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS
</code></a> обеспечивает два счетчика, которые могут использоваться, чтобы
измерить эффект <code>MERGE_THRESHOLD</code> на слияниях индексной страницы.
<pre>
mysql&gt; SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS
                 WHERE NAME like '%index_page_merge%';
+-----------------------------+----------------------------------------+
| NAME                        | COMMENT                                |
+-----------------------------+----------------------------------------+
| index_page_merge_attempts   | Number of index page merge attempts    |
| index_page_merge_successful | Number of successful index page merges |
+-----------------------------+----------------------------------------+
</pre>

<p>Понижение значения <code>MERGE_THRESHOLD</code> дает:</p>
<ul><li><p>Меньшее число попыток и успешные слияния страниц.</li>
<li>Подобное число попыток и успешных слияний страниц.</p></li></ul>

<p>Установка <code>MERGE_THRESHOLD</code>, которая является слишком
маленькой, могла привести к большим файлам с данными из-за чрезмерного
количества пустого пространства страницы.</p>

<p>Для информации об использовании счетчиков
<a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS</code></a> см.
<a href="#innodb-information-schema-metrics-table">раздел 16.14.6
</a>.</p>

<h2><a name="innodb-tablespace"></a>16.7. Табличные пространства InnoDB</h2>
<h3><a name="innodb-resize-system-tablespace"></a>
16.7.1. Изменение размеров системного табличного пространства InnoDB</h3>
<p>Этот раздел описывает, как увеличить или уменьшить
системное табличное пространство <code>InnoDB</code>.</p>

<h4><a name="idm139965327949360"></a>Увеличение размера системного
табличного пространства InnoDB</h4>
<p>Самый легкий способ увеличить размер системного табличного пространства
это сконфигурировать его сначала на авторасширение. Определите атрибут
<code>autoextend</code> для последнего файла с данными в определении
табличного пространства. Тогда <code>InnoDB</code> увеличивает размер этого
файла автоматически порциями по 64MB, когда это исчерпывает пространство.
Размер порции может быть изменен, устанавливая значение
<a href="#sysvar_innodb_autoextend_increment"><code>
innodb_autoextend_increment</code></a>, которая измерена в мегабайтах.</p>

<p>Вы можете расширить системное табличное пространство определенным
количеством, добавляя другой файл с данными:</p>
<ol type="1"><li><p>Закройте сервер MySQL.</li>

<li>Если предыдущий последний файл с данными определен с ключевым словом
<code>autoextend</code>, измените его определение, чтобы использовать
фиксированный размер, основанный на том, как это фактически выросло.
Проверьте размер файла с данными, округлите это в меньшую сторону к самому
близкому числу, кратному 1024*1024 байт (=1MB),
и определите этот округленный размер явно в
<a href="#sysvar_innodb_data_file_path"><code>innodb_data_file_path
</code></a>.</li>

<li>Добавьте новый файл с данными в конец
<a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a>, произвольно делая автомасштабирование
файла. Только последний файл с данными в
<a href="#sysvar_innodb_data_file_path"><code>innodb_data_file_path
</code></a> может быть определен как автомасштабируемый.</li>
<li>Запустите сервер MySQL снова.</p></li></ol>

<p>Например, у этого табличного пространства есть только один
автомасштабируемый файл с данными <code>ibdata1</code>:
<pre>
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:10M:autoextend
</pre>

<p>Предположите, что этот файл с данными в течение долгого времени вырос до
988MB. Вот строка конфигурации после изменения оригинального файла с данными,
чтобы использовать фиксированный размер и добавления нового файла:
<pre>
innodb_data_home_dir =
innodb_data_file_path = /ibdata/ibdata1:988M;/disk2/ibdata2:50M:autoextend
</pre>

<p>Когда Вы добавляете новый файл с данными к системной конфигурации
табличного пространства, удостоверьтесь, что имя файла не обращается к
существующему файлу. <code>InnoDB</code> создает и инициализирует файл, когда
Вы перезапускаете сервер.</p>

<h4><a name="idm139965327929648"></a>
Уменьшение размера системного табличного пространства InnoDB</h4>
<p>Вы не можете удалить файл с данными из системного табличного пространства.
Чтобы уменьшить размер табличного пространства, используйте эту процедуру:
</p>

<ol type="1"><li><p>Используйте <a href="programs.htm#mysqldump"><span>
<strong>mysqldump</strong></span></a>, чтобы вывести в дамп все Ваши таблицы
<code>InnoDB</code>, включая таблицы <code>InnoDB</code>,
расположенные в базе данных MySQL.
<pre>
mysql&gt; select table_name from information_schema.tables
                 where table_schema='mysql' and engine='InnoDB';
+---------------------------+
| table_name                |
+---------------------------+
| columns_priv              |
| db                        |
| engine_cost               |
| gtid_executed             |
| help_category             |
| help_keyword              |
| help_relation             |
| help_topic                |
| innodb_index_stats        |
| innodb_table_stats        |
| plugin                    |
| procs_priv                |
| proxies_priv              |
| server_cost               |
| servers                   |
| slave_master_info         |
| slave_relay_log_info      |
| slave_worker_info         |
| tables_priv               |
| time_zone                 |
| time_zone_leap_second     |
| time_zone_name            |
| time_zone_transition      |
| time_zone_transition_type |
| user                      |
+---------------------------+
</pre></li>

<li>Остановите сервер.</li>
<li>Удалите все существующие файлы табличного пространства
(<code>*.ibd</code>), включая <code>ibdata</code> и <code>ib_log</code>.
Не забывайте удалять <code>*.ibd</code> для таблиц, расположенных в
базе данных MySQL.</li>

<li>Сконфигурируйте новое табличное пространство.</li>
<li>Перезапустите сервер.</li>
<li>Импортируйте файлы дампа.</p></li></ol>

<p>Если Ваши базы данных используют только механизм <code>InnoDB</code>,
может быть более просто вывести в дамп <span><strong>все</strong></span>
базы данных, остановить сервер, удалить все базы данных и файлы системного
журнала <code>InnoDB</code>, перезапустить сервер и
импортировать файлы дампа.</p>

<h3><a name="innodb-data-log-reconfiguration"></a>16.7.2. Изменение числа или
размера файлов системного журнала Redo</h3>
<p>Изменить число или размер файлов журнала
<a href="glossary.htm#glos_redo_log">redo</a> можно так:</p>

<ol type="1"><li><p>Остановите сервер MySQL и удостоверьтесь, что он
закрывается без ошибок.</li>

<li>Отредактируйте <code>my.cnf</code>, чтобы изменить конфигурацию
файла системного журнала. Чтобы изменить размер файла системного журнала,
надо сконфигурировать <a href="#sysvar_innodb_log_file_size"><code>
innodb_log_file_size</code></a>. Чтобы увеличить число файлов системного
журнала, надо сконфигурировать
<a href="#sysvar_innodb_log_files_in_group"><code>
innodb_log_files_in_group</code></a>.</li>
<li>Запустите сервер MySQL снова.</p></li></ol>

<p>Если <code>InnoDB</code> обнаруживает, что
<a href="#sysvar_innodb_log_file_size"><code>innodb_log_file_size
</code></a> отличается от размера файла системного журнала, это напишет
контрольную точку журнала, закроет и удалит старые файлы, создаст новые файлы
в требуемом размере и откроет их.</p>

<h3><a name="innodb-raw-devices"></a>16.7.3. Использование сырого дискового
раздела для системного табличного пространства</h3>
<p>Вы можете использовать сырой раздел в качестве файлов с данными в
<a href="glossary.htm#glos_system_tablespace">системном табличном
пространстве</a> <code>InnoDB</code>. Этот метод включает небуферизованный
вводу/выводу в Windows и некоторых системах Linux и Unix без издержек
файловой системы. Выполните тесты с и без сырого разделения, чтобы проверить,
улучшает ли это изменение фактически работу относительно Вашей системы.</p>

<p>Когда Вы используете сырой дисковый раздел, гарантируете, что
пользовательский ID, который выполняет сервер MySQL, имеет привилегии чтения
и записи для того раздела. Например, если Вы выполняете сервер как
<code>mysql</code>, раздел должен быть читаем и записываем для
<code>mysql</code>. Если Вы выполняете сервер с опцией
<a href="server.htm#option_mysqld_memlock"><code>--memlock</code></a>, сервер
должен быть выполнен как <code>root</code>, таким образом, раздел
должен быть доступен для <code>root</code>.</p>

<p>Процедуры, описанные ниже, вовлекают модификацию файла опции.
Для дополнительной информации см. <a href="programs.htm#option-files">раздел
5.2.6</a>.</p>

<h4><a name="idm139965327884000"></a>Выделение сырого дискового раздела
на системах Linux и Unix</h4>
<ol type="1"><li><p>Когда Вы создаете новый файл с данными, определите
ключевое слово <code>newraw</code> сразу после размера файла с данными для
опции <a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a>. Раздел должен быть, по крайней мере, столь
же большим как размер, который Вы определяете.
<pre>
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Gnewraw;/dev/hdd2:2Gnewraw
</pre></li>

<li>Перезапустите сервер. <code>InnoDB</code> найдет ключевое слово
<code>newraw</code> и инициализирует новый раздел. Однако, не создавайте или
изменяйте таблицы. Иначе, когда Вы затем перезапускаете сервер,
<code>InnoDB</code> повторно инициализирует раздел, и Ваши изменения
потеряны. Как мера по безопасности <code>InnoDB</code> препятствует тому,
чтобы пользователи изменили данные, когда любой
раздел определен с <code>newraw</code>.</li>

<li>После того, как <code>InnoDB</code> инициализировал новый раздел,
остановите сервер и измените <code>newraw</code> на <code>raw</code>:
<pre>
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=/dev/hdd1:3Graw;/dev/hdd2:2Graw
</pre></li>
<li>Перезапустите сервер. <code>InnoDB</code> теперь разрешает
вносить любые изменения.</p></li></ol>

<h4><a name="idm139965327866800"></a>
Выделение сырого дискового раздела в Windows</h4>
<p>В Windows те же самые шаги , описанные для систем Linux и Unix,
применяются за исключением того, что
<a href="#sysvar_innodb_data_file_path"><code>innodb_data_file_path
</code></a> расходится немного в Windows.</p>

<ol type="1"><li><p>Когда Вы создаете новый файл с данными, определите
ключевое слово <code>newraw</code> сразу после размера файла с данными для
опции <a href="#sysvar_innodb_data_file_path">
<code>innodb_data_file_path</code></a>:
<pre>
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Gnewraw
</pre>

<p><code>//./</code> соответствует синтаксису Windows <code>\\.\</code>
для того, чтобы получить доступ к физическим дискам. В примере выше
<code>D:</code> имя диска раздела.</li>

<li><li>Перезапустите сервер. <code>InnoDB</code> найдет ключевое слово
<code>newraw</code> и инициализирует новый раздел.</li>
<li>После этого остановите сервер и измените
<code>newraw</code> на <code>raw</code>:
<pre>
[mysqld]
innodb_data_home_dir=
innodb_data_file_path=//./D::10Graw
</pre></li>
<li>Перезапустите сервер. <code>InnoDB</code> теперь может работать.
</p></li></ol>

<h3><a name="innodb-multiple-tablespaces"></a>16.7.4.
Табличные пространства InnoDB File-Per-Table</h3>
<p>Исторически все таблицы и индексы <code>InnoDB</code> были сохранены в
<a href="glossary.htm#glos_system_tablespace">системном табличном
пространстве</a>. Этот монолитный подход был хорош в машинах, посвященных
полностью обработке базы данных, с тщательно запланированным ростом данных,
где любое дисковое хранение, выделенное MySQL, никогда не будет необходимо в
других целях. Табличное пространство <code>InnoDB</code>'s
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
обеспечивает более гибкую альтернативу, где каждая таблица и индекс
<code>InnoDB</code> сохранены в отдельном файле
<a href="glossary.htm#glos_ibd_file"><code>.ibd</code></a>.
Каждый такой файл <a href="glossary.htm#glos_ibd_file"><code>.ibd</code></a>
представляет отдельное <a href="glossary.htm#glos_tablespace">табличное
пространство</a>. Этой особенностью управляет опция
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>, которая включена по умолчанию.</p>

<h4><a name="idm139965327834848"></a>Преимущества табличных пространств
File-Per-Table</h4>
<ul><li><p>Вы можете исправить дисковое пространство, усекая или удаляя
таблицу, сохраненную в файле. Усечение или удаление таблиц, сохраненных в
совместно используемом <a href="glossary.htm#glos_system_tablespace">
системном табличном пространстве</a> создает свободное пространство внутренне
в системных файлах с данными табличного пространства
(<a href="glossary.htm#glos_ibdata_file">файлах ibdata</a>),
которое может использоваться только для новых данных <code>InnoDB</code>.</p>

<p>Точно так же копирование таблицы <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> на таблице, которая находится в совместно используемом
табличном пространстве, может увеличить количество места, использованного
табличным пространством. Такие операции могут потребовать такого большого
количества дополнительного места, как данные в таблице плюс индекс.</li>

<li><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
быстрее, когда выполнено на таблицах, сохраненных в файле.</li>
<li>Вы можете сохранить определенные таблицы на отдельных устройствах
хранения данных, для оптимизации ввода/вывода, управления пространством или
сделать копию, определяя местоположение каждой таблицы, используя синтаксис
<code>CREATE TABLE ... DATA DIRECTORY =
<em><code>absolute_path_to_directory</code></em></code>, как описано в
<a href="#tablespace-placing">разделе 16.7.5</a>.</li>

<li>Вы можете выполнить <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE
</code></a>, чтобы уплотнить или обновить табличное пространство
file-per-table. Когда Вы выполняете <a href="sql.htm#optimize-table"><code>
OPTIMIZE TABLE</code></a>, <code>InnoDB</code> создает новый файл
<code>.ibd</code> с временным именем, используя только место, требуемое,
чтобы сохранить фактические данные. Когда оптимизация завершена,
<code>InnoDB</code> удаляет старый файл <code>.ibd</code>
и заменяет его новым. Если предыдущий файл <code>.ibd</code>
вырос значительно, но фактические данные составляли только часть его размера,
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>
может восстановить неиспользуемое место.</li>

<li>Вы можете переместить таблицы, а не всю базу данных.</li>
<li>Вы можете скопировать таблицы между серверами MySQL.</li>
<li>Таблицы, составленные в табличных пространствах file-per-table,
поддерживают функции, связанные с форматами строки
<a href="glossary.htm#glos_compressed_row_format">compressed</a>
и <a href="glossary.htm#glos_dynamic_row_format">dynamic</a>.</li>

<li>Вы можете включить более эффективное хранение для таблиц с большими
столбцами <code>BLOB</code> или <code>TEXT</code>, используя
<a href="glossary.htm#glos_dynamic_row_format">динамический формат строки
</a>.</li>

<li>Табличные пространства File-per-table могут улучшить возможности для
успешного восстановления и сэкономить время, когда повреждение происходит,
когда сервер не может быть перезапущен, или резервные и
двоичные журналы недоступны.</li>

<li>Табличные пространства File-per-table удобны для создания отчетов о
состоянии таблиц, копируя или поддерживая таблицы.</li>
<li>Вы можете контролировать табличный размер на уровне файловой системы, не
получая доступ к MySQL.</li>

<li>Общие файловые системы Linux не разрешают параллельную запись в
единственный файл, когда
<a href="#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a> установлено <code>O_DIRECT</code>. В результате есть возможные
исполнительные усовершенствования, используя табличные пространства
file-per-table в соединении с
<a href="#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a>.</li>

<li>Системное табличное пространство хранит словарь данных и журналы отмены,
и имеет 64TB предел размера. В сравнении, каждое табличное пространство
file-per-table имеет 64TB предел размера, который предоставляет Вам место
для роста. См. <a href="restr.htm#table-size-limit">раздел C.10.3</a>.
</p></li></ul>

<h4><a name="idm139965327793872"></a>
Потенциальные недостатки табличных пространств File-Per-Table</h4>
<ul><li><p>С табличными пространствами file-per-table
у каждой таблицы может быть неиспользуемое место, которое может быть
использовано только строками той же самой таблицы. Это могло привести к
потраченному впустую пространству если не должным образом управляется.</li>

<li><code>fsync</code> должен работать на каждой открытой таблице, а не на
единственном файле. Поскольку есть отдельный <code>fsync</code>
для каждого файла, операции записи на многих таблицах не могут быть
объединены в единственную работу ввода/вывода. Это может потребовать
выполнить более высокое общее количество <code>fsync</code>.</li>

<li><a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
должен сохранить один открытый дескриптор на таблицу, что может
воздействовать на работу, если у Вас есть многочисленные таблицы в табличных
пространствах file-per-table.</li>

<li>Используется больше описателей файла.</li>
<li><a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> включен по умолчанию. Вы можете рассмотреть
отключение этого параметра, если обратная совместимость с MySQL 5.5 или ранее
является важной. Отключение <a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a> не даст
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> переместить
таблицы <code>InnoDB</code> из системного табличного пространства в
отдельные файлы <code>.ibd</code> в случаях, где
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
обновляет таблицу (<code>ALGORITHM=COPY</code>).</p>

<p>Например, когда идет реструктурирование кластеризируемого индека для
<code>InnoDB</code>, таблица обновлена, используя текущую установку для
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a>. Это поведение не применяется, добавляя или удаляя вторичные
индексы. Когда вторичный индекс создается, не восстанавливая таблицу,
индексирование сохранено в том же самом файле, где табличные данные,
независимо от текущего значения
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a>. Это поведение также не относится к таблицам, добавленным к
системному табличному пространству через
<a href="sql.htm#create-table"><code>CREATE TABLE ... TABLESPACE</code></a>
или <a href="sql.htm#alter-table"><code>ALTER TABLE ... TABLESPACE</code>
</a>. Эти таблицы не затронуты настройкой
<a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a>.</li>

<li>Если много таблиц растут, есть потенциал для большего количества
фрагментации, которая может препятствовать <a href="sql.htm#drop-table">
<code>DROP TABLE</code></a> и замедлить сканирование таблицы.
Однако, когда фрагментацией управляют, файлы в их собственном табличном
пространстве могут улучшить работу.</li>

<li>Буферный пул просмотрен при удалении табличного пространства
file-per-table, что может занять несколько секунд для буферных пулов, которые
имеют десятки гигабайтов в размере. Просмотр выполнен с широкой внутренней
блокировкой, которая может задержать другие операции. Таблицы в системном
табличном пространстве не затронуты.</li>

<li><a href="#sysvar_innodb_autoextend_increment"><code>
innodb_autoextend_increment</code></a>, которая определяет размер инкремента
(в MB) для автомасштабирования совместно используемого файла табличного
пространства, когда это становится полным, не относится к файлам табличного
пространства file-per-table, которые масштабируются независимо от
<a href="#sysvar_innodb_autoextend_increment"><code>
innodb_autoextend_increment</code></a>.
Начальные расширения небольшие, после них расширения
происходят в инкрементах 4 МБ.</p></li></ul>

<h4><a name="tablespace-enabling"></a>16.7.4.1.
Включение и отключение табличных пространств File-Per-Table</h4>
<p>Опция <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> включена по умолчанию.</p>

<p>Установить <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> можно как параметр командной строки
<a href="#sysvar_innodb_file_per_table"><code>
--innodb_file_per_table</code></a> или добавив строку в раздел
<code>[mysqld]</code> файла <code>my.cnf</code>:
<pre>
[mysqld]
innodb_file_per_table=1
</pre>

<p>Вы можете также установить
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> динамически, в то время как сервер работает:
<pre>
SET GLOBAL innodb_file_per_table=1;
</pre>

<p>При включении <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> Вы можете сохранить таблицы
<code>InnoDB</code> в файл <code><em><code>tbl_name</code></em>.ibd</code>.
В отличие от механизма хранения <code>MyISAM</code> с его отдельными
файлами <code><em><code>tbl_name</code></em>.MYD</code> и
<code><em><code>tbl_name</code></em>.MYI</code>, <code>InnoDB</code>
хранит данные и индексы вместе в файле <code>.ibd</code>.</p>

<p>При выключении <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> в Ваших опциях запуска и перезапуске сервера
или отключении этого через <code>SET GLOBAL</code>, <code>InnoDB</code>
составляет новые таблицы в системном табличном пространстве, если Вы явно не
поместили таблицу в табличное пространство file-per-table
или общее табличное пространство, используя опцию
<a href="sql.htm#alter-table"><code>CREATE TABLE ... TABLESPACE</code></a>.
</p>

<p>Вы можете всегда читать и писать любую таблицу <code>InnoDB</code>,
независимо от установки file-per-table.</p>
<p>Чтобы переместить таблицу из системного табличного пространства в свое,
измените <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> и пересоздайте таблицу:
<pre>
SET GLOBAL innodb_file_per_table=1;
ALTER TABLE <em><code>table_name</code></em> ENGINE=InnoDB;
</pre>

<p>Таблицы, добавленные к системному табличному пространству через
<a href="sql.htm#create-table"><code>CREATE TABLE ... TABLESPACE</code></a>
или <a href="sql.htm#alter-table"><code>ALTER TABLE ... TABLESPACE</code></a>
не затронуты <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>. Чтобы переместить эти таблицы из системного
табличного пространства в свое табличное пространство, они должны быть
перемещены явно, используя
<a href="sql.htm#alter-table"><code>ALTER TABLE ... TABLESPACE</code></a>.
</p>

<p><code>InnoDB</code> всегда нуждается в системном табличном пространстве,
потому что помещает свой внутренний
<a href="glossary.htm#glos_data_dictionary">словарь данных</a>
и <a href="glossary.htm#glos_undo_log">журналы отмены</a> там. Файлы
<code>.ibd</code> недостаточны для работы <code>InnoDB</code>.</p>

<p>Когда таблица перемещена из системного табличного пространства в свое,
файлы с данными, которые составляют системное табличное пространство,
остаются того же самого размера. Место, прежде занятое таблицей, может быть
снова использовано для новых данных, но не для использования операционной
системой. Перемещая большие таблицы из системного табличного пространства,
где дисковое пространство ограничено, Вы можете предпочесть включить
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> и обновите весь экземпляр, применяя
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>.
Как упомянуто выше, таблицы, добавленные к системному табличному пространству
через <a href="sql.htm#create-table"><code>CREATE TABLE ... TABLESPACE</code>
</a> или <a href="sql.htm#alter-table"><code>ALTER TABLE ... TABLESPACE
</code></a> не затронуты настройкой
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a>. Эти таблицы должны быть перемещены индивидуально.</p>

<h3><a name="tablespace-placing"></a>16.7.5. Создание табличного пространства
File-Per-Table вне каталога данных</h3>
<p>Чтобы создать новое табличное пространство
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
в определенном местоположении вне каталога данных MySQL, используйте параметр
<code>DATA DIRECTORY = <em><code>absolute_path_to_directory</code></em>
</code> в <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.</p>

<p>Запланируйте местоположение заранее, потому что Вы не можете использовать
<code>DATA DIRECTORY</code> с <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a>. Каталог, который Вы определяете, мог быть на другом устройстве
хранения данных с особыми характеристиками, таком как быстрый
<a href="glossary.htm#glos_ssd">SSD</a> или особо большой
<a href="glossary.htm#glos_hdd">HDD</a>.</p>

<p>В пределах целевого каталога MySQL создает подкаталог, соответствующий
имени базы данных, и в его пределах
<a href="glossary.htm#glos_ibd_file">файл .ibd</a> для новой таблицы.</p>

<p>Следующий пример демонстрирует создание табличного пространства
file-per-table вне каталога данных MySQL. Это показывает
<code>.ibd</code>, создаваемый в указанном каталоге.
<pre>
mysql&gt; USE test;
Database changed

mysql&gt; SHOW VARIABLES LIKE 'innodb_file_per_table';
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| innodb_file_per_table | ON    |
+-----------------------+-------+
1 row in set (0.00 sec)

mysql&gt; CREATE TABLE t1 (c1 INT PRIMARY KEY)
                 DATA DIRECTORY = '/alternative/directory';
Query OK, 0 rows affected (0.03 sec)

# MySQL creates a .ibd file for the new table in a
# subdirectory that corresponding
# to the database name

db_user@ubuntu:~/alternative/directory/test$ ls
t1.ibd
</pre>

<p>Вы можете также использовать
<a href="sql.htm#create-table"><code>CREATE TABLE ... TABLESPACE</code></a>
в комбинации с <code>DATA DIRECTORY</code>, чтобы создать табличное
пространство вне каталога данных MySQL. Чтобы сделать так, Вы должны
определить <code>innodb_file_per_table</code> как имя табличного пространства.
<pre>
CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE = innodb_file_per_table
       DATA DIRECTORY = '/alternative/directory';
</pre>

<p>Вы не должны включать
<a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a>, используя этот метод.</p>

<h4><a name="idm139965327694224"></a>Примечания использования</h4>
<ul><li><p>MySQL первоначально держит открытым файл <code>.ibd</code>,
препятствуя Вам демонтировать устройство, но мог бы в конечном счете закрыть
таблицу, если сервер занят. Бойтесь случайно демонтировать внешнее
устройство, в то время как MySQL работает, или запустить MySQL, в то время
как устройство отмонтировано. Попытка получить доступ к таблице, когда
связанный файл <code>.ibd</code> отсутствует, это
серьезная ошибка, которая требует перезапуска сервера.</p>

<p>Перезапуск сервера снимает ошибки и предупреждения, если файл
<code>.ibd</code> не в ожидаемом пути.</li>
<li>Не помещайте таблицы MySQL на NFS-том. NFS использует передающий
сообщение протокол, чтобы писать файлы, который может вызвать
несогласованность данных, если сетевые сообщения потеряны или получены
не в том порядке.</li>

<li>Если Вы используете снимок LVM, копию файла или другой основанный на
файле механизм, чтобы резервировать файл <code>.ibd</code>, всегда
используйте <a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code>
</a> сначала, чтобы удостовериться, что все изменения, которые были
буферизованы в памяти, <a href="glossary.htm#glos_flush">сброшены</a> на
диск прежде, чем резервное копирование произойдет.</li>

<li><code>DATA DIRECTORY</code> поддерживает
<a href="optimiz.htm#symbolic-links">использование символических ссылок</a>,
которые всегда был проблематичны и никогда не поддерживались
для таблиц <code>InnoDB</code> tables.</p></li></ul>

<h3><a name="tablespace-copying"></a>16.7.6.
Копирование табличных пространств к другому серверу</h3>
<p>Этот раздел описывает, как скопировать табличные пространства
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
от одного сервера базы данных на другой. Свойство известно как
<a href="glossary.htm#glos_transportable_tablespace">мобильность</a>. Эта
особенность также поддерживает разделенные таблицы <code>InnoDB</code>.</p>

<p>Для информации о других методах копирования таблиц <code>InnoDB</code>
см. <a href="#innodb-migration">раздел 16.8.3</a>.</p>
<p>Есть много причин, почему Вы могли бы скопировать табличное пространство
<code>InnoDB</code> <a href="glossary.htm#glos_file_per_table">
file-per-table</a> на другой сервер базы данных:</p>

<ul><li><p>Выполнять отчеты, не создавая дополнительную
нагрузку производственному серверу.</li>
<li>Настраивать идентичные данные для таблицы на новом
<a href="glossary.htm#glos_slave_server">подчиненном сервере</a>.</li>

<li>Восстановить таблицу или раздел после проблемы или ошибки.</li>
<li>Как более быстрый способ переместить данные, чем импортирование
результатов <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a>. Данные доступны немедленно, вместо того, чтобы повторно
вставлять и индексировать восстановленное.</li>

<li>Перемещать табличное пространство
<a href="glossary.htm#glos_file_per_table">file-per-table</a> на сервер
получше. Например, Вы можете хотеть иметь занятые таблицы на устройстве
<a href="glossary.htm#glos_ssd">SSD</a> или большие таблицы на устройстве
<a href="glossary.htm#glos_hdd">HDD</a> высокой емкости.</p></li></ul>

<h4><a name="innodb-transportable-tablespace-limitations"></a>
Ограничения и примечания использования</h4>
<ul><li><p>Процедура копирования табличного пространства возможна только,
когда включен параметр <a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a>, что является настройкой по умолчанию.
Таблицы, находящиеся в совместно используемом системном табличном
пространстве, не могут быть скопированы.
</li>

<li>В процессе копирования транзакции только для чтения позволены
на затронутой таблице.</li>
<li>Импортируя табличное пространство, размер страницы должен соответствовать
размер страницы экземпляра импортирования.</li>

<li><a href="sql.htm#alter-table"><code>ALTER TABLE ... DISCARD TABLESPACE
</code></a> поддержан для разделенных таблиц <code>InnoDB</code> и
<a href="sql.htm#alter-table"><code>ALTER TABLE ... DISCARD PARTITION ...
TABLESPACE</code></a> поддержан для разделов.</li>

<li><code>DISCARD TABLESPACE</code> не поддержан для табличных пространств с
родительским дочерним элементом (внешний ключ первичного ключа), когда
<a href="server.htm#sysvar_foreign_key_checks"><code>foreign_key_checks
</code></a> установлен в <code>1</code>. Прежде, чем отказаться от табличного
пространства для родительско-дочерних таблиц, установите
<code>foreign_key_checks=0</code>. Разделенные таблицы <code>InnoDB</code>
не поддерживают внешние ключи.</li>

<li><a href="sql.htm#alter-table"><code>ALTER TABLE ... IMPORT TABLESPACE
</code></a> не проводит в жизнь ограничения внешнего ключа на импортированные
данные. Если есть ограничения внешнего ключа между таблицами, все таблицы
должны быть экспортированы в том же самом (логическом) моменте времени.
Разделенные таблицы <code>InnoDB</code> не поддерживают внешние ключи.</li>

<li><a href="sql.htm#alter-table"><code>ALTER TABLE ...
IMPORT TABLESPACE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER
TABLE ... IMPORT PARTITION ... TABLESPACE</code></a> не требуют
метафайл <code>.cfg</code> с данными, чтобы импортировать табличное
пространство. Однако, проверки метаданных не выполнены, импортируя без
файла <code>.cfg</code>, и предупреждение, подобное следующему, будет:
<pre>
Message: InnoDB: IO Read error: (2, No such file or directory)
Error opening '.\test\t.cfg', will attempt to import
without schema verification
1 row in set (0.00 sec)
</pre>

<p>Способность импортировать без файла <code>.cfg</code> может быть более
удобна, когда никакие несоответствия схемы не ожидаются. Дополнительно,
способность импортировать без файла <code>.cfg</code>
может быть полезна в сценариях восстановления катастрофического отказа, в
которых метаданные не могут быть собраны в файле <code>.ibd</code>.</p>

<p>Если файл <code>.cfg</code> не используется, <code>InnoDB</code>
использует эквивалент <code>SELECT MAX(ai_col) FROM
<em><code>table_name</code></em> FOR UPDATE</code>, чтобы инициализировать
счетчик автоинкремента в памяти, который используется в назначении значений
для столбца <code>AUTO_INCREMENT</code>. Иначе текущее максимальное значение
счетчика автоинкремента считано из
<a href="#innodb-auto-increment-initialization">InnoDB
AUTO_INCREMENT Counter Initialization</a>.</li>

<li>Из-за ограничений метафайла с данными, о несоответствиях схемы не
сообщают для типа разделения или различий в определении разделения,
импортируя файлы табличного пространства для разделенных таблиц.
О различиях в столбце сообщают.</li>

<li>При запуске <a href="sql.htm#alter-table"><code>ALTER TABLE ...
DISCARD PARTITION ... TABLESPACE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE ...
IMPORT PARTITION ... TABLESPACE</code></a> на разделенных таблицах позволены
имена разделов и подразделов таблицы. Когда имя раздела определено, подраздел
того раздела включен в работу.</li>

<li>Импортирование файла табличного пространства от другого сервера работает,
если у обоих серверов есть статус GA, и их версии в пределах того же самого
ряда. Иначе файл должен быть был создан на сервере той версии, в
которую он импортирован.</li>

<li>В скриптах репликации <a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a> должна быть <code>ON</code>
на ведущем и на ведомом устройствах.</li>

<li>В Windows <code>InnoDB</code> табличное пространство и имена таблиц
внутренне хранятся в нижнем регистре. Чтобы избежать проблем импорта на
чувствительных к регистру операционных системах, таких как Linux и UNIX,
создайте все базы данных, табличные пространства и таблицы, используя
строчные имена. Удобный способ достигнуть этого состоит в том, чтобы добавить
следующую строку к разделу <code>[mysqld]</code> файла
<code>my.cnf</code> или <code>my.ini</code>
прежде, чем создать базы данных, табличные пространства или таблицы:
<pre>
[mysqld]
lower_case_table_names=1
</pre></li>

<li><a href="sql.htm#alter-table"><code>ALTER TABLE ... DISCARD TABLESPACE
</code></a> и <a href="sql.htm#alter-table"><code>ALTER TABLE ...IMPORT
TABLESPACE</code></a> не поддержаны с таблицами, которые принадлежат
общему табличному пространству <code>InnoDB</code>. Для получения
дополнительной информации см. <a href="sql.htm#create-tablespace"><code>
CREATE TABLESPACE</code></a>.</li>

<li>Формат строки по умолчанию для таблиц <code>InnoDB</code> настраивается
параметром <a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>.
Попытка импортировать таблицу, которая явно не определяет формат строки
(<code>ROW_FORMAT</code>) или использует <code>ROW_FORMAT=DEFAULT</code>,
может привести к ошибке несоответствия схемы, если
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a> на исходном сервере отличается от
установки на целевом сервере. Для соответствующей информации см.
<a href="#innodb-row-format-specification">раздел 16.10.2</a>.</li>

<li>Экспортируя табличное пространство, которое зашифровано, используя
особенность шифрования табличного пространства, <code>InnoDB</code>
производит файл <code>.cfp</code> в дополнение к метафайлу <code>.cfg</code>.
Файл <code>.cfp</code> должен быть скопирован к целевому серверу вместе с
<code>.cfg</code> и файлом табличного пространства прежде, чем
скомандовать <a href="sql.htm#alter-table"><code>ALTER TABLE ... IMPORT
TABLESPACE</code></a> на целевом сервере. <code>.cfp</code>
содержит ключ передачи и зашифрованный ключ табличного пространства. При
импорте <code>InnoDB</code> использует ключ передачи, чтобы дешифровать ключ
табличного пространства. Для соответствующей информации см.
<a href="#innodb-tablespace-encryption">раздел 16.7.10</a>.
</p></li></ul>

<h4><a name="innodb-transportable-tablespace-examples"></a>16.7.6.1.
Мобильные примеры табличного пространства</h4>
<p>Если Вы транспортируете таблицы, которые зашифрованы, используя
шифрование табличного пространства см.
<a href="#innodb-transportable-tablespace-limitations">здесь</a>
прежде, чем Вы начнете для дополнительной процедурной информации.</p>

<h5><a name="idm139965327588080"></a>Пример 1: Копирование Таблицы InnoDB
с одного сервера на другой</h5>
<p>Эта процедура демонстрирует, как скопировать таблицу с одного экземпляра
MySQL на другой. Та же самая процедура с незначительными корректировками
может использоваться, чтобы выполнить полное табличное восстановление на том
же самом сервере.</p>

<ol type="1"><li><p>На исходном сервере составьте таблицу, если ее нет:
<pre>
mysql&gt; use test;
mysql&gt; CREATE TABLE t(c1 INT) engine=InnoDB;
</pre></li>

<li>На целевом сервере составьте таблицу, если ее нет:
<pre>
mysql&gt; use test;
mysql&gt; CREATE TABLE t(c1 INT) engine=InnoDB;
</pre></li>

<li>На целевом сервере откажитесь от существующего табличного пространства.
Прежде, чем табличное пространство сможет быть импортировано,
<code>InnoDB</code> должен отказаться от табличного пространства, которое
присоединено к таблице получения.
<pre>
mysql&gt; ALTER TABLE t DISCARD TABLESPACE;
</pre></li>

<li>На исходном сервере выполните
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>,
чтобы создать метафайл <code>.cfg</code> с данными:
<pre>
mysql&gt; use test;
mysql&gt; FLUSH TABLES t FOR EXPORT;
</pre>

<p>Метафайл (<code>.cfg</code>) создается в
каталоге данных <code>InnoDB</code>.</p>
<p><a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>
гарантирует, что изменения названной таблицы сброшены на диск
так, чтобы двоичная табличная копия могла быть сделана в то время, как сервер
работает. Когда выполняется
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>,
<code>InnoDB</code> делает файл <code>.cfg</code>
в том же самом каталоге базы данных, где таблица. Файл <code>.cfg</code>
содержит метаданные, используемые для проверки схемы, импортируя
файл табличного пространства.</p></li>

<li><p>Скопируйте файлы <code>.ibd</code> и <code>.cfg</code>
с исходного сервера на целевой:
<pre>
shell&gt; scp <em><code>/path/to/datadir</code></em>/test/t.{ibd,cfg} destination-server:<em><code>/path/to/datadir</code></em>/test
</pre>

<p>Файлы <code>.ibd</code> и <code>.cfg</code>
должны быть скопированы прежде, чем выпустить совместно используемые
блокировки, как описано в следующем шаге.</p></li>

<li><p>На исходном сервере скомандуйте
<a href="sql.htm#lock-tables"><code>UNLOCK TABLES</code></a>, чтобы
выпустить блокировки, приобретенные
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>:
<pre>
mysql&gt; use test;
mysql&gt; UNLOCK TABLES;
</pre></li>

<li>На целевом сервере импортируйте табличное пространство:
<pre>
mysql&gt; use test;
mysql&gt; ALTER TABLE t IMPORT TABLESPACE;
</pre>

<p><a href="sql.htm#alter-table"><code>ALTER TABLE ... IMPORT TABLESPACE
</code></a> не проводит в жизнь ограничения внешнего ключа на импортированные
данные. Если есть ограничения внешнего ключа между таблицами, все таблицы
должны быть экспортированы в том же самом (логическом) моменте времени. В
этом случае Вы прекратите обновлять таблицы, закроете все транзакции,
приобрете совместно используемые блокировки на таблицах и затем
выполните экспортную работу.</p></li></ol>

<h5><a name="idm139965327553584"></a>Пример 2: Копирование разделенной
таблицы InnoDB с одного сервера на другой</h5>
<p>Эта процедура демонстрирует, как скопировать разделенную таблицу
<code>InnoDB</code> с одного сервера на другой. Та же самая процедура с
незначительными корректировками может использоваться, чтобы выполнить полное
восстановление разделенной таблицы на том же самом сервере.</p>

<ol type="1"><li><p>На исходном сервере составьте разделенную таблицу, если
ее нет. В следующем примере составлена таблица с тремя разделами
(p0, p1, p2):
<pre>
mysql&gt; use test;
mysql&gt; CREATE TABLE t1 (i int) ENGINE = InnoDB
                 PARTITION BY KEY (i) PARTITIONS 3;
</pre>

<p>В каталоге <code>/<em><code>datadir</code></em>/test</code>
Вы будете видеть отдельное табличное пространство (<code>.ibd</code>)
для каждого из этих трех разделов.
<pre>
mysql&gt; \! ls <em><code>/path/to/datadir</code></em>/test/
t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd
</pre></li>

<li>На целевом сервере составьте ту же самую разделенную таблицу:
<pre>
mysql&gt; use test;
mysql&gt; CREATE TABLE t1 (i int) ENGINE = InnoDB
                 PARTITION BY KEY (i) PARTITIONS 3;
</pre>

<p>В каталоге <code>/<em><code>datadir</code></em>/test</code>
Вы будете видеть отдельное табличное пространство (<code>.ibd</code>)
для каждого из этих трех разделов.
<pre>
mysql&gt; \! ls <em><code>/path/to/datadir</code></em>/test/
t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd
</pre></li>

<li>На целевом сервере откажитесь от табличного пространства для разделенной
таблицы. Прежде, чем табличное пространство сможет быть импортировано на
целевом сервере, от табличного пространства, которое присоединено к таблице
получения, нужно отказаться.
<pre>
mysql&gt; ALTER TABLE t1 DISCARD TABLESPACE;
</pre>

<p>Три файла <code>.ibd</code>, которые составляют табличное пространство для
разделенной таблицы, исчезают из каталога
<code>/<em><code>datadir</code></em>/test</code>.</li>

<li>На исходном сервере выполните
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>, что
создаст файл <code>.cfg</code>:
<pre>
mysql&gt; use test;
mysql&gt; FLUSH TABLES t1 FOR EXPORT;
</pre>

<p>Файлы данных, один для каждого табличного пространства (<code>.ibd
</code>), и метафайл (<code>.cfg</code>) создаются в каталоге
<code>/<em><code>datadir</code></em>/test</code> на исходном сервере:
<pre>
mysql&gt; \! ls <em><code>/path/to/datadir</code></em>/test/
t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd
t1#P#p0.cfg  t1#P#p1.cfg  t1#P#p2.cfg
</pre>

<p><a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>
гарантирует, что изменения названной таблицы сброшены на диск так, чтобы
двоичная табличная копия могла быть сделана в то время, как сервер работает.
Когда выполняется <a href="sql.htm#flush"><code>FLUSH TABLES ...
FOR EXPORT</code></a>, <code>InnoDB</code> создает файл
<code>.cfg</code> с данными для файлов табличного пространства таблицы в том
же самом каталоге базы данных, где таблица. <code>.cfg</code>
содержат метаданные, используемые для проверки схемы, импортируя файлы
табличного пространства. <a href="sql.htm#flush"><code>FLUSH TABLES ... FOR
EXPORT</code></a> может быть выполнен только на таблице, не на
отдельном табличном разделе.</p></li>

<li><p>Скопируйте файлы <code>.ibd</code> и <code>.cfg</code>
на сервер назначения:
<pre>
shell&gt; scp <em><code>/path/to/datadir</code></em>/test/t1*.{ibd,cfg}
              destination-server:<em><code>/path/to/datadir</code></em>/test
</pre>

<p>Файлы <code>.ibd</code> и <code>.cfg</code>
должны быть скопированы прежде, чем выпустить совместно используемые
блокировки, как описано в следующем шаге.</p><p></li>

<li><p>На исходном сервере скомандуйте <a href="sql.htm#lock-tables"><code>
UNLOCK TABLES</code></a>, чтобы снять блокировки, приобретенные
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>:
<pre>
mysql&gt; use test;
mysql&gt; UNLOCK TABLES;
</pre></li>

<li>На целевом сервере импортируйте табличное пространство
для разделенной таблицы:
<pre>
mysql&gt; use test;
mysql&gt; ALTER TABLE t1 IMPORT TABLESPACE;
</pre></li></ol>

<h5><a name="idm139965327507472"></a>Пример 3: Копирование табличного раздела
с сервера на сервер</h5>
<p>Эта процедура демонстрирует, как скопировать табличный раздел. Та же самая
процедура с незначительными корректировками может использоваться, чтобы
выполнить восстановление раздела. В следующем примере разделенная таблица с
четырьмя разделами (p0, p1, p2, p3) составлена на исходном сервере. Два
раздела (p2 и p3) скопированы целевому серверу.</p>

<ol type="1"><li><p>На исходном сервере составьте разделенную таблицу, если
ее нет. В следующем примере составлена таблица с четырьмя разделами
(p0, p1, p2, p3):
<pre>
mysql&gt; use test;
mysql&gt; CREATE TABLE t1 (i int) ENGINE = InnoDB
                 PARTITION BY KEY (i) PARTITIONS 4;
</pre>

<p>В каталоге <code>/<em><code>datadir</code></em>/test</code>
Вы будете видеть отдельное табличное пространство (<code>.ibd</code>)
для каждого из этих четырех разделов.
<pre>
mysql&gt; \! ls <em><code>/path/to/datadir</code></em>/test/
t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd t1#P#p3.ibd
</pre></li>

<li>На целевом сервере составьте ту же самую разделенную таблицу:
<pre>
mysql&gt; use test;
mysql&gt; CREATE TABLE t1 (i int) ENGINE = InnoDB
                 PARTITION BY KEY (i) PARTITIONS 4;
</pre>

<p>В каталоге <code>/<em><code>datadir</code></em>/test</code>
Вы будете видеть отдельное табличное пространство (<code>.ibd</code>)
для каждого из этих четырех разделов.
<pre>
mysql&gt; \! ls <em><code>/path/to/datadir</code></em>/test/
t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd t1#P#p3.ibd
</pre></li>

<li>На целевом сервере откажитесь от раздела табличного пространства, который
Вы планируете импортировать с исходного сервера.
Прежде, чем раздел табличного пространства сможет быть импортирован на
целевом сервере, от соответствующего раздела, который присоединен к таблице
получения, нужно отказаться.
<pre>
mysql&gt; ALTER TABLE t1 DISCARD PARTITION p2, p3 TABLESPACE;
</pre>

<p>Файлы <code>.ibd</code> для двух разделов, от которых отказываются,
удалены из каталога <code>/<em><code>datadir</code></em>/test</code>
на целевом сервере, оставляя следующие файлы:
<pre>
mysql&gt; \! ls <em><code>/path/to/datadir</code></em>/test/
t1#P#p0.ibd  t1#P#p1.ibd
</pre>

<p>Когда <a href="sql.htm#alter-table"><code>ALTER TABLE ... DISCARD
PARTITION ... TABLESPACE</code></a> работает на разделенных таблицах имена
таблиц и подразделов позволены. Когда имя раздела определено, подраздел того
раздела включен в работу.</p></li>

<li><p>На исходном сервере выполните
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>, чтобы
получить файл <code>.cfg</code>.<pre>
mysql&gt; use test;
mysql&gt; FLUSH TABLES t1 FOR EXPORT;
</pre>

<p>Файл (<code>.cfg</code>) для каждого раздела создается в каталоге
<code>/<em><code>datadir</code></em>/test</code> на исходном сервере. Есть
<code>.cfg</code> для каждого табличного пространства (<code>.ibd</code>).
<pre>
mysql&gt; \! ls <em><code>/path/to/datadir</code></em>/test/
t1#P#p0.ibd  t1#P#p1.ibd  t1#P#p2.ibd t1#P#p3.ibd
t1#P#p0.cfg  t1#P#p1.cfg  t1#P#p2.cfg t1#P#p3.cfg
</pre>

<p><a href="sql.htm#flush"><code>FLUSH TABLES ...
FOR EXPORT</code></a> гарантирует, что изменения в названной таблице
сброшены на диск так, чтобы двоичная табличная копия могла быть сделана в то
время, как сервер работает. Когда
<a href="sql.htm#flush"><code>FLUSH TABLES ...
FOR EXPORT</code></a> работает, <code>InnoDB</code> производит файл
<code>.cfg</code> с данными для файлов табличного пространства таблицы в том
же самом каталоге базы данных, где таблица. <code>.cfg</code>
содержат метаданные, используемые для проверки схемы, импортируя файлы
табличного пространства. <a href="sql.htm#flush"><code>FLUSH TABLES ...
FOR EXPORT</code></a> может быть выполнен только на таблице, не на
отдельном табличном разделе.</p></li>

<li><p>Скопируйте файлы <code>.ibd</code> и <code>.cfg</code>
на сервер назначения. В этом примере только файлы
<code>.ibd</code> and <code>.cfg</code> для разделов 2 (p2) и 3 (p3)
скопированы в каталог <code>data</code> на сервере назначения. Другие разделы
остаются на исходном сервере.
<pre>
shell&gt; scp t1#P#p2.ibd  t1#P#p2.cfg t1#P#p3.ibd t1#P#p3.cfg \
              destination-server:<em><code>/path/to/datadir</code></em>/test
</pre>

<p>Файлы <code>.ibd</code> и <code>.cfg</code>
должны быть скопированы прежде, чем выпустить совместно используемые
блокировки, как описано в следующем шаге.</p></li>

<li><p>На исходном сервере скомандуйте
<a href="sql.htm#lock-tables"><code>UNLOCK TABLES</code></a>, чтобы
выпустить блокировки, приобретенные
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>:
<pre>
mysql&gt; use test;
mysql&gt; UNLOCK TABLES;
</pre></li>

<li>На целевом сервере импортируйте разделы табличного пространства
(p2 и p3):
<pre>
mysql&gt; use test;
mysql&gt; ALTER TABLE t1 IMPORT PARTITION p2, p3 TABLESPACE;
</pre>

<p><p>Когда <a href="sql.htm#alter-table"><code>ALTER TABLE ... DISCARD
PARTITION ... TABLESPACE</code></a> работает на разделенных таблицах имена
таблиц и подразделов позволены. Когда имя раздела определено, подраздел того
раздела включен в работу.</p></li></ol>

<h4><a name="innodb-transportable-tablespace-internals"></a>16.7.6.2.
Мобильные внутренности табличного пространства</h4>
<p>Следующая информация описывает внутренности и сообщения в журнале ошибок
для процедуры копирования мобильных табличных пространств.</p>

<p>Когда <a href="sql.htm#alter-table"><code>ALTER TABLE
... DISCARD TABLESPACE</code></a> выполнена на целевом сервере:</p>
<ul><li><p>Таблица заблокирована в режиме X.</li>
<li>Табличное пространство отделено от таблицы.</p></li></ul>

<p>Когда <a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>
выполнен на исходном сервере:</p>
<ul><li><p>Таблица заблокирована в совместно используемом режиме.</li>
<li>Поток координатора чистки остановлен.</li>
<li>Грязные страницы синхронизированы с диском.</li>
<li>Табличные метаданные записаны в двоичный файл <code>.cfg</code>.
</p></li></ul>

<p>Ожидаемые сообщения журнала ошибок для этой работы:
<pre>
2013-09-24T13:10:19.903526Z 2 [Note] InnoDB: Sync to disk of '"test"."t"' started.
2013-09-24T13:10:19.903586Z 2 [Note] InnoDB: Stopping purge
2013-09-24T13:10:19.903725Z 2 [Note] InnoDB: Writing table metadata to './test/t.cfg'
2013-09-24T13:10:19.904014Z 2 [Note] InnoDB: Table '"test"."t"' flushed to disk
</pre>

<p>Когда <a href="sql.htm#lock-tables"><code>UNLOCK TABLES</code></a>
выполнен на исходном сервере:</p>
<ul><li><p>Двоичный файл .cfg удален.</li>
<li>Совместно используемые блокировки на таблице выпущены, и поток
координатора чистки перезапущен.</p></li></ul>

<p>Ожидаемые сообщения журнала ошибок для этой работы:
<pre>
2013-09-24T13:10:21.181104Z 2 [Note] InnoDB: Deleting the meta-data file
                              './test/t.cfg'
2013-09-24T13:10:21.181180Z 2 [Note] InnoDB: Resuming purge
</pre>

<p>Когда <a href="sql.htm#alter-table"><code>ALTER TABLE ... IMPORT
TABLESPACE</code></a> выполнен на целевом сервере, алгоритм импорта выполняет
следующие операции для каждого импортируемого табличного пространства:</p>

<ul><li><p>Каждая страница табличного пространства проверена на повреждение.
</li>
<li>ID пространства и порядковые номера журнала (LSNs)
на каждой странице обновлены.</li>
<li>Флаги утверждены, и LSN обновлен для страницы заголовка.</li>
<li>Страницы Btree обновлены.</li>
<li>Статус страницы установлен в "грязная", чтобы она была записана на диск.
</p></li></ul>

<p>Ожидаемые сообщения журнала ошибок для этой работы:
<pre>
2013-07-18 15:15:01 34960 [Note] InnoDB: Importing tablespace for table
                    'test/t' that was exported from host 'ubuntu'
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase I - Update all pages
2013-07-18 15:15:01 34960 [Note] InnoDB: Sync to disk
2013-07-18 15:15:01 34960 [Note] InnoDB: Sync to disk - done!
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase III - Flush changes to disk
2013-07-18 15:15:01 34960 [Note] InnoDB: Phase IV - Flush complete
</pre>

<p>Вы можете также получить предупреждение, что от табличного пространства
отказываются (если Вы отказались от табличного пространства для целевой
таблицы) и сообщение, что статистика не может быть вычислена из-за
отсутствия файла <code>.ibd</code>:
<pre>
2013-07-18 15:14:38 34960 [Warning] InnoDB: Table "test"."t" tablespace is
                    set as discarded.
2013-07-18 15:14:38 7f34d9a37700 InnoDB: cannot calculate statistics for
                    table "test"."t" because the .ibd file is missing.
                    For help, please refer to
http://dev.mysql.com/doc/refman/5.8/en/innodb-troubleshooting.html
</pre>

<h3><a name="innodb-undo-tablespace"></a>16.7.7. Хранение журналов отмены в
отдельных табличных пространствах</h3>
<p>Вы можете сохранить <a href="glossary.htm#glos_undo_log">журналы отмены
</a> в одном или более отдельных
<a href="glossary.htm#glos_undo_tablespace">табличных пространствах отмены
</a> за пределами <a href="glossary.htm#glos_system_tablespace">
системного табличного пространства</a>.
Это расположение отличается от конфигурации значения по умолчанию, где журнал
отмены это часть <a href="glossary.htm#glos_system_tablespace">системного
табличного пространства</a>. Образцы ввода/вывода для журнала отмены делают
эти табличные пространства хорошими кандидатами, чтобы переместить на
<a href="glossary.htm#glos_ssd">SSD</a>, сохраняя системное табличное
пространство на жестком диске. Пользователи не могут удалить отдельные
табличные пространства, создаваемые, чтобы хранить журналы или отдельные
<a href="glossary.htm#glos_segment">сегменты</a> в тех табличных
пространствах. Однако, журналы отмены, сохраненные в табличных пространствах
отмены, могут быть усеченными. Для получения дополнительной информации см.
<a href="#truncate-undo-tablespace">раздел 16.7.8</a>.</p>

<p>Поскольку эти файлы обрабатывают операции ввода/вывода, прежде сделанные в
системном табличном пространстве, мы расширяем определение системного
табличного пространства, чтобы включать эти новые файлы.</p>

<p>Журналы отмены также упоминаются как
<a href="glossary.htm#glos_rollback_segment">сегменты отмены</a>.</p>
<p>Эта особенность вовлекает следующие новые или
переименованные параметры конфигурации:</p>

<ul><li><p><a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a></li>
<li><a href="#sysvar_innodb_undo_directory"><code>
innodb_undo_directory</code></a></li>
<li><a href="#sysvar_innodb_rollback_segments"><code>
innodb_rollback_segments</code></a> становится
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a>. Старое название все еще доступно для совместимости.</p></li></ul>

<p>Поскольку особенность <a href="glossary.htm#glos_undo_log">
журнала отмены</a> вовлекает установку двух нединамических переменных запуска
(<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> и
<a href="#sysvar_innodb_undo_directory"><code>
innodb_undo_directory</code></a>), эта опция может быть активирована только
инициализируя экземпляр MySQL.</p>

<h4><a name="idm139965327394544"></a>Примечания</h4>
<p>Чтобы использовать эту функцию:</p>
<ol type="1"><li><p>Выберите путь, где хранить журналы отмены. Вы определите
путь как параметр <a href="#sysvar_innodb_undo_directory"><code>
innodb_undo_directory</code></a> в Вашем конфигурационном файле MySQL или
скрипте запуска. Если никакой путь не определен, табличные пространства
отмены создаются в каталоге данных MySQL, как определено
<a href="server.htm#sysvar_datadir"><code>datadir</code></a>.</li>

<li>Выберите начальное значение для
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a>. Вы можете запустить с относительно низким значением и увеличить его в
течение долгого времени, чтобы исследовать эффект.</p>

<p>Один журнал отмены всегда назначается на системное табличное пространство,
и 32 журнала отмены сохранены для использования временными таблицами и
размещены во временном табличном пространстве (<code>ibtmp1</code>).
Поэтому, чтобы выделить журналы отмены для табличных пространств отмены,
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a> должен быть установлен в значение, больше 33. Например, если у Вас есть
два табличных пространства отмены
(<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces=2</code></a>),
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a> должен быть установлен в 35, чтобы назначить один журнал отмены на
каждое из двух табличных пространств отмены.</p>
<p>Когда Вы конфигурируете отдельные табличные пространства отмены,
журнал отмены в системном табличном пространстве бездействует.</p></li>

<li><p>Выберите ненулевое значение для
<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a>. Множественные журналы отмены,
определенные <a href="#sysvar_innodb_undo_logs"><code>
innodb_undo_logs</code></a>, разделены между этим числом отдельных табличных
пространств (файлы <a href="glossary.htm#glos_ibd_file"><code>.ibd</code>
</a>). Это значение установлено для жизни сервера MySQL,
так что, если Вы не уверены в оптимальном значении, повысьте его.</li>

<li>Создайте новый экземпляр MySQL, используя значения, которые Вы выбрали в
конфигурационном файле или в Вашем скрипте запуска MySQL. Используйте
реалистическую рабочую нагрузку с объемом данных, подобным Вашим
производственным серверам. Альтернативно, используйте мобильную функцию
табличных пространств, чтобы скопировать существующие таблицы базы данных к
Вашему недавно сконфигурированному экземпляру MySQL. См.
<a href="#tablespace-copying">раздел 16.7.6</a>.</li>

<li>Определите эффективность исполнения ввода/вывода
интенсивных рабочих нагрузок.</li>
<li>Периодически увеличивайте значение
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a> и повторно делайте тесты производительности. Найдите значение, где Вы
прекращаете получать улучшение в работе ввода/вывода.</li>

<li>Разверните новый производственный сервер, используя идеальные настройки
для этих опций. Настройте это как
<a href="glossary.htm#glos_slave_server">ведомый сервер</a> в
<a href="glossary.htm#glos_replication">репликации</a>
или возьмите данные с предыдущего сервера.</p></li></ol>

<h4><a name="idm139965327367840"></a>Соображения масштабируемости</h4>
<p>Хранение журналов отмены позволяют MySQL осуществлять ввод/вывод и
оптимизацию памяти, связанную с этими транзакционными данными. Например,
потому что данные об отмене написаны на диск и затем редко используются
(только в случае восстановления катастрофического отказа),
это не должно быть сохранено в кэш-памяти файловой системы, в свою очередь
позволяя более высокий процент системной памяти выделить
<a href="glossary.htm#glos_buffer_pool">буферному пулу</a>.</p>

<p>Типичная передовая практика SSD:
хранить системное табличное пространство на жестком диске и переместить
табличные пространства per-table на SSD.</p>

<h4><a name="idm139965327363392"></a>Внутренности</h4>
<p>Физические файлы табличного пространства называют
<code>undo<em><code>N</code></em></code>, где <em><code>N</code></em>
ID пространства, включая начальные нули.</p>

<p>Вы можете усечь журналы отмены, которые находятся в табличных
пространствах отмены. Для получения дополнительной информации см.
<a href="#truncate-undo-tablespace">раздел 16.7.8</a>.</p>

<h3><a name="truncate-undo-tablespace"></a>16.7.8. Усечение журналов отмены,
которые находятся в табличных пространствах отмены</h3>
<p>Вы можете усечь <a href="glossary.htm#glos_undo_log">журналы отмены</a>,
которые находятся в <a href="glossary.htm#glos_undo_tablespace">табличных
пространствах отмены</a>, при условии, что следующие условия верны:</p>

<ul><li><p>Ваш случай MySQL сконфигурирован минимум с
двумя табличными пространствами отмены
(<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces=2</code></a>).
Когда табличное пространство отмены является усеченным, оно временно
отключается. Чтобы сервер функционировал, должно быть по крайней мере одно
активное табличное пространство отмены. Число табличных пространств отмены
определено опцией <a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a>, которая может быть установлена только,
когда сервер MySQL инициализирован. Значение по умолчанию 0. Проверить
значение <a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> можно так:
<pre>
mysql&gt; SELECT @@innodb_undo_tablespaces;
+---------------------------+
| @@innodb_undo_tablespaces |
+---------------------------+
| 2                         |
+---------------------------+
1 row in set (0.00 sec)
</pre></li>

<li><a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs
</code></a>, который определяет число
<a href="glossary.htm#glos_rollback_segment">сегментов отмены</a>,
используемых <code>InnoDB</code>, должен быть установлен в 35 или больше.
Установка 35 или больше гарантирует, что журнал отмены, назначен на каждое из
двух табличных пространств отмены. С
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a> 35:</p>

<ul><li><p>Первый сегмент отмены всегда находится в
<a href="glossary.htm#glos_system_tablespace">системном табличном
пространстве</a> (когда табличные пространства отмены присутствуют, этот
сегмент отмены является бездействующим).</li>

<li>Сегменты отмены 2-33 находятся в совместно используемом временном
табличном пространстве (<code>ibtmp1</code>).</li>
<li>34-ый сегмент отмены находится в первом табличном пространстве
отмены (если есть).</li>
<li>35-ый сегмент отмены находится во втором табличном пространстве
отмены (если есть).</p></li></ul>

<p>Есть отношения &quot;многие к одному&quot; между сегментами отмены и
табличными пространствами отмены. Если число выделенных сегментов отмены
больше 35, <span><span>доаолнитльные</span></span>
сегменты отмены назначаются табличным пространствам круговым способом.
Например, если у Вас есть 2 табличных пространства отмены (табличное
пространство отмены 1 и табличное пространство отмены 2) и
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs=37</code>
</a>, табличному пространству отмены 1 и табличному пространству отмены 2
каждому назначили бы второй сегмент отмены.</p>

<p>По умолчанию <a href="#sysvar_innodb_undo_logs"><code>
innodb_undo_logs</code></a> 128, что является также максимальным значением.
Проверить значение <a href="#sysvar_innodb_undo_logs"><code>
innodb_undo_logs</code></a> можно так:
<pre>
mysql&gt; SELECT @@innodb_undo_logs;
+--------------------+
| @@innodb_undo_logs |
+--------------------+
|  128               |
+--------------------+
1 row in set (0.00 sec)
</pre>

<p><a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a> динамическая глобальная переменная и может быть сконфигурирована,
используя <code>SET GLOBAL</code>:
<pre>
mysql&gt; SET GLOBAL innodb_undo_logs=128;
</pre></li></ul>

<h4><a name="idm139965327325648"></a>
Включение усечения табличных пространств отмены</h4>
<p>Чтобы усечь журналы отмены, которые находятся в табличных пространствах
отмены, Вы должны сначала включить
<a href="#sysvar_innodb_undo_log_truncate">
<code>innodb_undo_log_truncate</code></a>.
<pre>
mysql&gt; SET GLOBAL innodb_undo_log_truncate=ON;
</pre>

<p>Когда Вы включаете <a href="#sysvar_innodb_undo_log_truncate">
<code>innodb_undo_log_truncate</code></a>, файлы табличного пространства
отмены, которые превышают предел размера, определенный
<a href="#sysvar_innodb_max_undo_log_size"><code>
innodb_max_undo_log_size</code></a>, отмечены для усечения.
<a href="#sysvar_innodb_max_undo_log_size"><code>
innodb_max_undo_log_size</code></a> динамическая глобальная переменная со
значением по умолчанию 1024 MiB (1073741824 байт).
<pre>
mysql&gt; SELECT @@innodb_max_undo_log_size;
+----------------------------+
| @@innodb_max_undo_log_size |
+----------------------------+
|   1073741824               |
+----------------------------+
1 row in set (0.00 sec)
</pre>

<p>Вы можете сконфигурировать
<a href="#sysvar_innodb_max_undo_log_size"><code>
innodb_max_undo_log_size</code></a> с использованием <code>SET GLOBAL</code>:
<pre>
mysql&gt; SET GLOBAL innodb_max_undo_log_size=2147483648;
Query OK, 0 rows affected (0.00 sec)
</pre>

<p>Когда <a href="#sysvar_innodb_undo_log_truncate">
<code>innodb_undo_log_truncate</code></a> включена:</p>
<ol type="1"><li><p>Табличные пространства отмены, которые превышают
<a href="#sysvar_innodb_max_undo_log_size"><code>
innodb_max_undo_log_size</code></a>, отмечены для усечения. Выбор табличного
пространства отмены для усечения выполнен круговым способом, чтобы не усекать
то же самое табличное пространство отмены каждый раз.</li>

<li>Сегменты отмены, находящиеся в выбранном табличном пространстве отмены,
сделаны бездействующими так, чтобы они не были выделены новым транзакциям.
Существующим транзакциям, которые в настоящее время используют сегменты
отмены, позволяют завершиться.</li>

<li>Система <a href="glossary.htm#glos_purge">чистки</a>
освобождает сегменты отмены, которые больше не необходимы.</li>
<li>После того, как все сегменты отмены в табличном пространстве отмены
освобождены, табличное пространство отмены усечено к его начальному размеру.
Начальный размер файла табличного пространства отмены составляет 10 МБ.</p>

<p>Если Вы проверяете размер табличного пространства отмены после того
усечения, размер файла может быть больше 10 МБ из-за непосредственного
использования после завершения работы усечения. Опция
<a href="#sysvar_innodb_undo_directory"><code>innodb_undo_directory
</code></a> определяет местоположение файлов табличного пространства отмены.
Значение по умолчанию <span><span>.</span></span> представляет каталог, где
<code>InnoDB</code> создает другие файлы системного журнала по умолчанию.
<pre>
mysql&gt; select @@innodb_undo_directory;
+-------------------------+
| @@innodb_undo_directory |
+-------------------------+
| .                       |
+-------------------------+
1 row in set (0.00 sec)
</pre></li>
<li><p>Сегменты отмены включены так, чтобы они могли быть
выделены новым транзакциям.</p></li></ol>

<h4><a name="idm139965327299136"></a>Ускорение усечения файлов
табличного пространства отмены</h4>
<p>Табличное пространство отмены не может быть усечено, пока его сегменты
отмены не освобождены. Обычно система чистки освобождает сегменты отмены
каждый 128-й раз. Чтобы ускорить усечение табличных пространств отмены, Вы
можете использовать опцию
<a href="#sysvar_innodb_purge_rseg_truncate_frequency"><code>
innodb_purge_rseg_truncate_frequency</code></a>, чтобы временно увеличить
частоту, с которой система чистки освобождает сегменты отмены. По умолчанию
<a href="#sysvar_innodb_purge_rseg_truncate_frequency"><code>
innodb_purge_rseg_truncate_frequency</code></a> 128, что
является также максимальным значением.
<pre>
mysql&gt; select @@innodb_purge_rseg_truncate_frequency;
+----------------------------------------+
| @@innodb_purge_rseg_truncate_frequency |
+----------------------------------------+
|  128                                   |
+----------------------------------------+
1 row in set (0.00 sec)
</pre>

<p>Чтобы увеличить частоту, с которой поток чистки освобождает сегменты
отмены, уменьшите значение
<a href="#sysvar_innodb_purge_rseg_truncate_frequency">
<code>innodb_purge_rseg_truncate_frequency</code></a>:
<pre>
mysql&gt; SET GLOBAL innodb_purge_rseg_truncate_frequency=32;
Query OK, 0 rows affected (0.00 sec)
</pre>

<h4><a name="idm139965327290928"></a>Исполнительное воздействие усечения
файлов табличного пространства отмены</h4>
<p>В то время как работа усечения табличного пространства отмены происходит,
сегменты отмены в одном табличном пространстве отмены временно
дезактивированы. Например, если у Вас есть 2 табличных пространства отмены
(<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces=2</code></a>) и 128 выделенных журналов отмены
(<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs=128
</code></a>), 95 из журналов отмены находятся в двух табличных пространствах
отмены (48 сегментов отмены в одном табличном пространстве отмены и 47 в
другом). Если первое табличное пространство отмены взято офлайн, 48 журналов
отмены сделаны бездействующими, уменьшая ресурс журнала отмены немного
больше, чем наполовину. В то время, как работа усечения происходит,
остающиеся журналы отмены принимают на себя всю системную нагрузку, что может
привести к небольшой исполнительной деградации.
Степень исполнительной деградации зависит в ряде факторов, включая:</p>

<ul><li><p>Число табличных пространств отмены.</li>
<li>Число журналов отмены.</li>
<li>Размер табличного пространства отмены.</li>

<li>Скорость ввода/вывода.</li>
<li>Существующие рабочие транзакции.</li>
<li>Системная загрузка.</p></li></ul>

<h3><a name="general-tablespaces"></a>16.7.9.
Общие табличные пространства InnoDB</h3>
<p><span><em>Общее табличное пространство</em></span> это особенность
табличного пространства, которая обеспечивает следующие способности:</p>

<ul><li><p>Подобно системному табличному пространству, общие табличные
пространства это совместно используемые табличные пространства, которые могут
хранить данные для многих таблиц.</li>

<li>У общих табличных пространств есть потенциальное преимущество памяти
перед <a href="#innodb-multiple-tablespaces">табличными
пространствами file-per-table</a>. Сервер сохраняет метаданные о табличном
пространстве в памяти все время жизни табличного пространства. Многие таблицы
в меньшем количестве общих табличных пространств потребляют меньше памяти для
метаданных о табличном пространстве, чем то же самое число таблиц в отдельных
табличных пространствах file-per-table.</li>

<li>Общие файлы с данными табличного пространства могут быть помещены в
каталог относительно или независимо от каталога данных MySQL, который
предоставляет Вам многие управленческие способности хранения
of <a href="#innodb-multiple-tablespaces">табличных пространств
file-per-table</a>. Как с табличными пространствами file-per-table,
способность поместить файлы с данными за пределами каталога данных MySQL
позволяет Вам управлять исполнением критических таблиц отдельно, используя
RAID или DRBD для определенных таблиц или связывать
таблицы с особыми дисками.</li>

<li>Общие табличные пространства поддерживают форматы файла Antelope и
Barracuda и поэтому поддерживают все форматы строки таблицы и связанные
особенности. С поддержкой обоих форматов файла у общих табличных пространств
нет никакой зависимости от настроек
<a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_file_format"
target="_top"><code>innodb_file_format</code></a> или
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> и при этом эти переменные не имеют никакого
эффекта на общие табличные пространства.</li>

<li>Опция <code>TABLESPACE</code> может использоваться с
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>, чтобы
составлять таблицы в общих табличных пространствах, табличных пространствах
file-per-table или в системном табличном пространстве.</li>

<li>Опция <code>TABLESPACE</code> может использоваться с
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, чтобы
перемещать таблицы между общими табличными пространствами, табличными
пространствами file-per-table и системным табличным пространством. Ранее не
было возможно переместить таблицу от табличного пространства file-per-table
к системному табличному пространству. С общей особенностью табличного
пространства Вы можете теперь сделать так.</p></li></ul>

<h4><a name="general-tablespaces-creating"></a>
Создание общего табличного пространства</h4>
<p>Общие табличные пространства создаются, используя
<a href="sql.htm#create-tablespace"><code>CREATE TABLESPACE</code></a>.
<pre>
CREATE TABLESPACE tablespace_name ADD DATAFILE 'file_name'
       [FILE_BLOCK_SIZE = value]
       [ENGINE [=] engine_name]
</pre>

<p>Общее табличное пространство может быть создано в каталоге данных MySQL
или в каталоге за пределами каталога данных MySQL. Чтобы избегать конфликтов
с неявно создаваемыми табличными пространствами file-per-table,
создание общего табличного пространства в подкаталоге в соответствии с
каталогом данных MySQL не поддержано. Кроме того, создавая общее табличное
пространство за пределами каталога данных MySQL, каталог должен существовать
до создания табличного пространства.</p>

<p>Например:</p>
<p>Создание общего табличного пространства в каталоге данных MySQL:
<pre>
mysql&gt; CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;
</pre>

<p>Создание общего табличного пространства в каталоге за пределами
каталога данных MySQL:
<pre>
mysql&gt; CREATE TABLESPACE `ts1` ADD DATAFILE
                 '/my/tablespace/directory/ts1.ibd' Engine=InnoDB;
</pre>

<p>Вы можете определить путь относительно каталога данных MySQL, пока каталог
табличного пространства не является подкаталогом каталога данных MySQL. В
этом примере <code>my_tablespace</code> каталог на том же самом уровне, как
каталог данных MySQL:
<pre>
mysql&gt; CREATE TABLESPACE `ts1` ADD DATAFILE '../my_tablespace/ts1.ibd'
                 Engine=InnoDB;
</pre>

<p><code>ENGINE = InnoDB</code> должен быть определен как часть
<a href="sql.htm#create-tablespace"><code>CREATE TABLESPACE</code></a>
или <code>InnoDB</code> должен быть определен как механизм хранения по
умолчанию (<a href="server.htm#sysvar_default_storage_engine"><code>
default_storage_engine=InnoDB</code></a>).</p>

<h4><a name="general-tablespaces-adding-tables"></a>
Добавление таблиц к общему табличному пространству</h4>
<p>После создания общего табличного пространства, Вы можете использовать
<a href="sql.htm#create-table"><code>CREATE TABLE <em><code>tbl_name</code>
</em> ... TABLESPACE [=] <em><code>tablespace_name</code></em></code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> TABLESPACE [=]
<em><code>tablespace_name</code></em></code></a>, чтобы добавить таблицы к
табличному пространству, как показано в следующих примерах:</p>

<p><a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
mysql&gt; CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1
                 ROW_FORMAT=COMPACT;
</pre>

<p><a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>:
<pre>
mysql&gt; ALTER TABLE t2 TABLESPACE ts1;
</pre>

<p>Для подробной информации о синтаксисе см.
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<h4><a name="general-tablespaces-row-format-support"></a>
Поддержка формата строки табличным пространством</h4>
<p>Общие табличные пространства поддерживают все форматы строки таблицы
(<code>REDUNDANT</code>, <code>COMPACT</code>,
<code>DYNAMIC</code>, <code>COMPRESSED</code>), но сжатые и несжатые таблицы
не могут сосуществовать в том же самом общем табличном пространстве из-за
различных физических размеров страницы.</p>

<p>Для общего табличного пространства, чтобы содержать сжатые таблицы
(<code>ROW_FORMAT=COMPRESSED</code>), <code>FILE_BLOCK_SIZE</code>
должен быть определен, и <code>FILE_BLOCK_SIZE</code>
должно быть допустимым сжатым размером страницы относительно
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. Кроме того, физический размер страницы сжатой таблицы
(<code>KEY_BLOCK_SIZE</code>) должен быть равным
<code>FILE_BLOCK_SIZE/1024</code>. Например, если
<a href="#sysvar_innodb_page_size"><code>innodb_page_size=16K
</code></a> и <code>FILE_BLOCK_SIZE=8K</code>,
<code>KEY_BLOCK_SIZE</code> из таблицы должен быть 8.</p>

<p>Следующая таблица показывает допустимые
<code>FILE_BLOCK_SIZE</code> и <code>KEY_BLOCK_SIZE</code> для каждого
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. <code>FILE_BLOCK_SIZE</code> могут также быть определены в байтах.
Определить допустимое <code>KEY_BLOCK_SIZE</code> для данного
<code>FILE_BLOCK_SIZE</code> можно, поделив
<code>FILE_BLOCK_SIZE</code> на 1024. Табличное сжатие не поддерживает
размеры страницы 32K и 64K. Для получения дополнительной информации о
<code>KEY_BLOCK_SIZE</code> см.
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="#innodb-compression-usage">раздел 16.9.1.2</a>.</p>

<a name="idm139965327211440"></a><p><b>Таблица 16.5. FILE_BLOCK_SIZE и
KEY_BLOCK_SIZE для CREATE TABLESPACE</b></p>
<table border="1">
<thead><tr><th>Размер страницы InnoDB (innodb_page_size)</th>
<th>Permitted FILE_BLOCK_SIZE</th>
<th>Permitted KEY_BLOCK_SIZE</th></tr></thead>
<tbody><tr><td>64K</td><td>64K (65536)</td><td>Сжатие не поддерживается</td>
</tr>
<tr><td>32K</td><td>32K (32768)</td><td>Сжатие не поддерживается</td></tr>
<tr><td rowspan="5">16K</td><td>16K (16384)</td><td>N/A: Если
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> равно <code>FILE_BLOCK_SIZE</code>,
табличное пространство не может содержать сжатую таблицу.</td></tr>
<tr><td>8K (8192)</td><td>8</td></tr>
<tr><td>4K (4096)</td><td>4</td></tr>
<tr><td>2K (2048)</td><td>2</td></tr>
<tr><td>1K (1024)</td><td>1</td></tr>
<tr><td rowspan="4">8K</td><td>8K (8192)</td><td>N/A: Если
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> равно <code>FILE_BLOCK_SIZE</code>,
табличное пространство не может содержать сжатую таблицу.</td></tr>
<tr><td>4K (4096)</td><td>4</td></tr>
<tr><td>2K (2048)</td><td>2</td></tr>
<tr><td>1K (1024)</td><td>1</td></tr>
<tr><td rowspan="3">4K</td><td>4K (4096)</td><td>N/A: Если
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> равно <code>FILE_BLOCK_SIZE</code>,
табличное пространство не может содержать сжатую таблицу.</td></tr>
<tr><td>2K (2048)</td><td>2</td></tr>
<tr><td>1K (1024)</td><td>1</td></tr></tbody></table>

<p>Этот пример демонстрирует создание общего табличного пространства и
добавление сжатой таблицы. Пример принимает значение по умолчанию
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> 16K. <code>FILE_BLOCK_SIZE</code> 8192 требует, чтобы у сжатой таблицы
был <code>KEY_BLOCK_SIZE</code> 8.
<pre>
mysql&gt; CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd'
                 FILE_BLOCK_SIZE = 8192 Engine=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2
                 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
Query OK, 0 rows affected (0.00 sec)
</pre>

<p>Если Вы не определяете <code>FILE_BLOCK_SIZE</code>,
создавая общее табличное пространство, <code>FILE_BLOCK_SIZE</code>
по умолчанию <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a>. Когда
<code>FILE_BLOCK_SIZE</code> = <a href="#sysvar_innodb_page_size">
<code>innodb_page_size</code></a>, табличное пространство может содержать
только таблицы с несжатым форматом строки
(<code>COMPACT</code>, <code>REDUNDANT</code> и <code>DYNAMIC</code>).</p>

<h4><a name="general-tablespaces-moving-non-partitioned-tables"></a>
Перемещение неразделенной таблицы между табличными пространствами,
используя ALTER TABLE</h4>
<p>Вы можете использовать <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> с опцией <code>TABLESPACE</code>, чтобы переместить неразделенную
таблица к существующему общему табличному пространству, к новому табличному
пространству file-per-table или к системному табличному пространству.</p>

<p>Выполнение <code>ALTER TABLE <em><code>tbl_name</code></em> TABLESPACE [=]
<em><code>tablespace_name</code></em></code> на
<span><em>разделенной</em></span> таблице только изменяет табличное
пространство по умолчанию таблицы. Это не перемещает разделы таблицы.</p>

<p>Чтобы переместить неразделенную таблицу от табличного пространства
file-per-table или системного табличного пространства в общее, определите
название общего табличного пространства. Общее табличное пространство должно
уже существовать. См. <a href="sql.htm#create-tablespace"><code>CREATE
TABLESPACE</code></a>.
<pre>
ALTER TABLE tbl_name TABLESPACE [=] <em><code>tablespace_name</code></em>
</pre>

<p>Чтобы переместить неразделенную таблицу от общего табличного пространства
или табличного пространства file-per-table в системное, надо определить
<code>innodb_system</code> как имя табличного пространства.
<pre>
ALTER TABLE tbl_name ... TABLESPACE [=] innodb_system
</pre>

<p>Чтобы переместить неразделенную таблицу от системного табличного
пространства или общего табличного пространства в file-per-table, укажите
<code>innodb_file_per_table</code> как имя табличного пространства.
<pre>
ALTER TABLE tbl_name ... TABLESPACE [=] innodb_file_per_table
</pre>

<p><code>ALTER TABLE ... TABLESPACE</code>
всегда вызывает полное пересоздание таблицы, даже если атрибут
<code>TABLESPACE</code> не изменился от его предыдущего значения.</p>

<p><code>ALTER TABLE ... TABLESPACE</code> не поддерживает перемещение
таблицы из временного табличного пространства в постоянное.</p>

<p><code>DATA DIRECTORY</code> разрешен с <code>CREATE TABLE ...
TABLESPACE=innodb_file_per_table</code>, но иное не поддержано для
использования в комбинации с опцией <code>TABLESPACE</code>.</p>

<h4><a name="general-tablespaces-table-partition-support"></a>
Поддержка разделов таблиц в общем пространстве</h4>
<p>Опция <code>TABLESPACE</code> может использоваться, чтобы назначить
отдельный табличный раздел или подраздел к
<a href="glossary.htm#glos_general_tablespace">общему табличному
пространству</a>, отдельному табличному пространству file-per-table
или системному табличному пространству. Все разделы должны принадлежать тому
же самому механизму хранения.
Использование продемонстрировано в следующих примерах.
<pre>
mysql&gt; CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;
mysql&gt; CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd' Engine=InnoDB;
mysql&gt; CREATE TABLE t1 (a INT, b INT) ENGINE = InnoDB
    -&gt;        PARTITION BY RANGE(a) SUBPARTITION BY KEY(b) (
    -&gt;        PARTITION p1 VALUES LESS THAN (100) TABLESPACE=`ts1`,
    -&gt;        PARTITION p2 VALUES LESS THAN (1000) TABLESPACE=`ts2`,
    -&gt;        PARTITION p3 VALUES LESS THAN (10000) TABLESPACE `innodb_file_per_table`,
    -&gt;        PARTITION p4 VALUES LESS THAN (100000) TABLESPACE `innodb_system`);

mysql&gt; CREATE TABLE t2 (a INT, b INT) ENGINE = InnoDB
    -&gt;        PARTITION BY RANGE(a) SUBPARTITION BY KEY(b) (
    -&gt;           PARTITION p1 VALUES LESS THAN (100) TABLESPACE=`ts1`
    -&gt;              (SUBPARTITION sp1, SUBPARTITION sp2),
    -&gt;           PARTITION p2 VALUES LESS THAN (1000)
    -&gt;              (SUBPARTITION sp3,
    -&gt;               SUBPARTITION sp4 TABLESPACE=`ts2`),
    -&gt;           PARTITION p3 VALUES LESS THAN (10000)
    -&gt;              (SUBPARTITION sp5 TABLESPACE `innodb_system`,
    -&gt;               SUBPARTITION sp6 TABLESPACE `innodb_file_per_table`));
</pre>

<p>Опция <code>TABLESPACE</code> также допустима с
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
<pre>
mysql&gt; ALTER TABLE t1 ADD PARTITION (PARTITION p5 VALUES LESS
                THAN (1000000) TABLESPACE = `ts1`);
</pre>

<p>Если опция <code>TABLESPACE = <em><code>tablespace_name</code></em></code>
не определена, <a href="sql.htm#alter-table"><code>ALTER TABLE ...
ADD PARTITION</code></a> добавляет раздел к табличному пространству по
умолчанию таблицы, которое может быть определено на табличном уровне во время
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<p>Чтобы проверить, что раздел был помещен в указанные табличные
пространства, Вы можете запросить
<a href="inform.htm#innodb-sys-tables-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>:
<pre>
mysql&gt; SELECT NAME, SPACE, SPACE_TYPE
                 FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES
    -&gt;        WHERE NAME LIKE '%t1%';
+-----------------------+-------+------------+
| NAME                  | SPACE | SPACE_TYPE |
+-----------------------+-------+------------+
| test/t1#P#p1#SP#p1sp0 | 57    | General    |
| test/t1#P#p2#SP#p2sp0 | 58    | General    |
| test/t1#P#p3#SP#p3sp0 | 59    | Single     |
| test/t1#P#p4#SP#p4sp0 |  0    | System     |
| test/t1#P#p5#SP#p5sp0 | 57    | General    |
+-----------------------+-------+------------+

mysql&gt; SELECT NAME, SPACE, SPACE_TYPE FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES
    -&gt;        WHERE NAME LIKE '%t2%';
+---------------------+-------+------------+
| NAME                | SPACE | SPACE_TYPE |
+---------------------+-------+------------+
| test/t2#P#p1#SP#sp1 |    57 | General    |
| test/t2#P#p1#SP#sp2 |    57 | General    |
| test/t2#P#p2#SP#sp3 |    60 | Single     |
| test/t2#P#p2#SP#sp4 |    58 | General    |
| test/t2#P#p3#SP#sp5 |     0 | System     |
| test/t2#P#p3#SP#sp6 |    61 | Single     |
+---------------------+-------+------------+
</pre>

<h4><a name="general-tablespaces-moving-partitions"></a>
Перемещение табличного раздела между табличными пространствами,
используя ALTER TABLE</h4>
<p>Чтобы переместить табличное разделение в иное табличное пространство, Вы
должны переместить каждый раздел, используя <code>ALTER TABLE
<em><code>tbl_name</code></em> REORGANIZE PARTITION</code>.</p>

<p>Следующий пример демонстрирует, как переместить табличное разделение в
иное табличное пространство.
<a href="inform.htm#innodb-sys-tables-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a> и
<a href="inform.htm#innodb-sys-tablespaces-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a>
запрошены, чтобы проверить, что разделение помещено в
ожидаемое табличное пространство.</p>

<p>Если опция <code>TABLESPACE = <em><code>tablespace_name</code></em></code>
не определена в запросе <code>REORGANIZE PARTITION</code>,
<code>InnoDB</code> перемещает разделение в табличное пространство
по умолчанию таблицы. В этом примере табличное пространство <code>ts1</code>,
которое определено на табличном уровне, является табличным пространством по
умолчанию для таблицы <code>t1</code>. Раздел <code>P3</code>
перемещен от системного табличного пространства в <code>ts1</code>, поскольку
нет опции <code>TABLESPACE</code> в <a href="sql.htm#alter-table"><code>ALTER
TABLE t1 REORGANIZE PARTITION</code></a> для раздела <code>P3</code>.</p>

<p>Чтобы изменить табличное пространство
по умолчанию разделенной таблицы, Вы можете сделать
<code>ALTER TABLE <em><code>tbl_name</code></em> TABLESPACE [=]
<em><code>tablespace_name</code></em></code> на
<span><em>разделенной</em></span> таблице.</p>

<pre>
mysql&gt; CREATE TABLESPACE ts1 ADD DATAFILE 'ts1.ibd';
mysql&gt; CREATE TABLESPACE ts2 ADD DATAFILE 'ts2.ibd';
mysql&gt; CREATE TABLE t1 ( a INT NOT NULL, PRIMARY KEY (a))
    -&gt;        ENGINE=InnoDB TABLESPACE ts1
    -&gt;        PARTITION BY RANGE (a) PARTITIONS 3 (
    -&gt;        PARTITION P1 VALUES LESS THAN (2),
    -&gt;        PARTITION P2 VALUES LESS THAN (4) TABLESPACE `innodb_file_per_table`,
    -&gt;        PARTITION P3 VALUES LESS THAN (6) TABLESPACE `innodb_system`);

mysql&gt; SELECT A.NAME as partition_name, A.SPACE_TYPE as space_type,
                 B.NAME as space_name
    -&gt;        FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES A
    -&gt;        LEFT JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES B
    -&gt;        ON A.SPACE = B.SPACE WHERE A.NAME LIKE '%t1%'
                 ORDER BY A.NAME;
+----------------+------------+--------------+
| partition_name | space_type | space_name   |
+----------------+------------+--------------+
| test/t1#P#P1   | General    | ts1          |
| test/t1#P#P2   | Single     | test/t1#P#P2 |
| test/t1#P#P3   | System     | NULL         |
+----------------+------------+--------------+

mysql&gt; ALTER TABLE t1 REORGANIZE PARTITION P1
    -&gt;       INTO (PARTITION P1 VALUES LESS THAN (2) TABLESPACE = `ts2`);
mysql&gt; ALTER TABLE t1 REORGANIZE PARTITION P2
    -&gt;       INTO (PARTITION P2 VALUES LESS THAN (4) TABLESPACE = `ts2`);
mysql&gt; ALTER TABLE t1 REORGANIZE PARTITION P3
    -&gt;       INTO (PARTITION P3 VALUES LESS THAN (6));

mysql&gt; SELECT A.NAME AS partition_name, A.SPACE_TYPE AS space_type,
                 B.NAME AS space_name
    -&gt;        FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES A
    -&gt;        LEFT JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES B
    -&gt;        ON A.SPACE = B.SPACE WHERE A.NAME LIKE '%t1%'
                 ORDER BY A.NAME;
+----------------+------------+------------+
| partition_name | space_type | space_name |
+----------------+------------+------------+
| test/t1#P#P1   | General    | ts2        |
| test/t1#P#P2   | General    | ts2        |
| test/t1#P#P3   | General    | ts1        |
+----------------+------------+------------+
</pre>

<h4><a name="general-tablespaces-dropping"></a>
Удаление общего табличного пространства</h4>
<p><a href="sql.htm#drop-tablespace"><code>DROP TABLESPACE</code></a>
используется, чтобы удалить общее табличное пространство.</p>

<p>Все таблицы должны быть исключены из табличного пространства до
<a href="sql.htm#drop-tablespace"><code>DROP TABLESPACE</code></a>.
Если табличное пространство не пусто, <a href="sql.htm#drop-tablespace">
<code>DROP TABLESPACE</code></a> возвращает ошибку.</p>

<p>Табличное пространство не удалено автоматически, когда последняя
таблица в табличном пространстве удалена. Табличное пространство должно быть
удалено явно, используя
<a href="sql.htm#drop-tablespace"><code>DROP TABLESPACE
<em><code>tablespace_name</code></em></code></a>.</p>

<p>Общее табличное пространство не принадлежит никакой особой базе данных.
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>
может удалить таблицы, которые принадлежат общему табличному пространству, но
она не может удалить табличное пространство, даже если
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>
удаляет все таблицы, которые принадлежат табличному пространству. Общее
табличное пространство должно быть явно, используя
<a href="sql.htm#drop-tablespace"><code>DROP TABLESPACE <em><code>
tablespace_name</code></em></code></a>.</p>

<p>Подобно системному табличному пространству, удаление
таблиц, сохраненных в общем табличном пространстве, создает свободное
пространство внутренне в общем табличном пространстве
<a href="glossary.htm#glos_ibd_file">файле данных .ibd</a>,
которое может использоваться только для новых данных <code>InnoDB</code>.
Пространство не освобождено назад к операционной системе, как
табличное пространство file-per-table удалено во время
<a href="sql.htm#drop-table"><code>DROP TABLE</code></a>.</p>

<p>Этот пример демонстрирует, как удалить
общее табличное пространство. Общее табличное пространство <code>ts1</code>
создается с единственной таблицей. Таблица должна быть удалена прежде, чем
все табличное пространство.
<pre>
mysql&gt; CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts10 Engine=InnoDB;
Query OK, 0 rows affected (0.02 sec)

mysql&gt; DROP TABLE t1;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; DROP TABLESPACE ts1;
Query OK, 0 rows affected (0.01 sec)
</pre>
<p><code><em><code>tablespace_name</code></em></code>
чувствительный к регистру идентификатор в MySQL.</p>

<h4><a name="general-tablespaces-limitations"></a>
Ограничения общего табличного пространства</h4>
<ul><li><p>Существующее табличное пространство не может
быть изменено на общее табличное пространство.</li>

<li>Создание временных общих табличных пространств не поддержано.</li>
<li>Общие табличные пространства не поддерживают временные таблицы.</li>
<li>Копирование таблицы <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> на таблице, которая находится в совместно используемом табличном
пространстве (общее табличное пространство или системное табличное
пространство) может увеличить количество места, использованного табличным
пространством. Такие операции требуют такого большого количества
дополнительного пространства, как данные в таблице плюс индекс.
Дополнительное пространство требуется для копирования таблицы.</li>

<li><a href="sql.htm#alter-table"><code>ALTER TABLE ...
DISCARD TABLESPACE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE ... IMPORT TABLESPACE</code>
</a> не поддержаны для таблиц, которые принадлежат
общему табличному пространству.</p></li></ul>
<p>Для получения дополнительной информации см.
<a href="sql.htm#create-tablespace">раздел 14.1.16</a>.</p>

<h3><a name="innodb-tablespace-encryption"></a>16.7.10.
Шифрование табличного пространства InnoDB</h3>
<p><code>InnoDB</code> допускает шифрование данных для
таблиц, сохраненных в табличных пространствах
<a href="glossary.htm#glos_file_per_table">file-per-table</a>.
Эта особенность обеспечивает шифрование для физических файлов с
данными табличного пространства.</p>

<p>Шифрование табличного пространства использует две архитектуры ключа
шифрования ряда, состоя из основного ключа шифрования и ключей табличного
пространства. Когда таблица зашифрована, ключ табличного пространства
зашифрован и сохранен в заголовке табличного пространства. Когда приложение
или пользователь хотят получить доступ к зашифрованным данным табличного
пространства, <code>InnoDB</code> использует основной ключ шифрования, чтобы
дешифровать ключ табличного пространства. Основной ключ шифрования сохранен в
файле <code>keyring</code> в местоположении, определенном опцией
<a href="server.htm#sysvar_keyring_file_data"><code>keyring_file_data</code>
</a>. Дешифрованная версия ключа табличного пространства никогда не
изменяется, но основной ключ шифрования может быть изменен как требуется.
Это действие упоминается как <span><em>ротация главного ключа</em></span>.
</p>

<p>Особенность шифрования табличного пространства полагается на плагин
keyring для основного управления ключом шифрования.</p>
<p>Шифрование табличного пространства поддерживает алгоритм
Advanced Encryption Standard (AES) block-based.
Это использует режим блочного шифрования Electronic Codebook (ECB)
для ключевого шифрования табличного пространства и режим блочного шифрования
Cipher Block Chaining (CBC) для шифрования данных.</p>

<p>Особенность шифрования табличного пространства, предоставленная
MySQL Community Edition, не предназначена как решение для соответствия
установленным требованиям. Стандарты безопасности, такие как
PCI, FIPS и другие требуют, чтобы использование систем ключевого менеджмента
обеспечило, управляло и защитило ключи в ключевых хранилищах или модулях
безопасности аппаратных средств (HSM).</p>

<p>Для часто задаваемых вопросов о особенности шифрования табличного
пространства см. <a href="faqs.html#faqs-tablespace-encryption">раздел A.15
</a>.</p>

<h4><a name="innodb-tablespace-encryption-encryption-prerequisites"></a>
Предпосылки шифрования табличного пространства InnoDB</h4>
<ul><li><p>Плагин <code>keyring_file</code> должен быть установлен. Установка
плагина выполнена при запуске, используя опцию
<a href="server.htm#option_mysqld_early-plugin-load"><code>
--early-plugin-load</code></a>.
Ранняя загрузка гарантирует, что плагин доступен до инициализации
<code>InnoDB</code>. Для установки плагина и инструкций конфигурации см.
<a href="security.html#keyring">раздел 7.5.3</a>.</p>

<p>После того, как зашифрованные таблицы составлены в случае MySQL, плагин
должен продолжить загружаться, используя
<a href="server.htm#option_mysqld_early-plugin-load"><code>
early-plugin-load</code></a> до инициализации <code>InnoDB</code>.</p>

<p>Чтобы проверить, что плагин является активным, используйте
<a href="sql.htm#show-plugins"><code>SHOW PLUGINS</code></a> или запросите
<a href="inform.htm#plugins-table"><code>INFORMATION_SCHEMA.PLUGINS</code>
</a>:
<pre>
mysql&gt; SELECT PLUGIN_NAME, PLUGIN_STATUS FROM INFORMATION_SCHEMA.PLUGINS
    -&gt;        WHERE PLUGIN_NAME LIKE 'keyring%';
+--------------+---------------+
| PLUGIN_NAME  | PLUGIN_STATUS |
+--------------+---------------+
| keyring_file | ACTIVE        |
+--------------+---------------+
</pre></li>

<li>Опция <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> должна быть включена (значение по
умолчанию). Шифрование табличного пространства поддерживает только
табличные пространства <a href="glossary.htm#glos_file_per_table">
file-per-table</a>. Альтернативно, Вы можете определить опцию
<code>TABLESPACE='innodb_file_per_table'</code>, составляя зашифрованную
таблицу или изменяя существующую таблицу, чтобы включить шифрование.</li>

<li>Перед использованием шифрования табличного пространства, гарантируйте,
что Вы предприняли шаги, чтобы предотвратить потерю основного ключа
шифрования. <span><em>Если основной ключ шифрования потерян, данные в
зашифрованных файлах табличного пространства восстановить нельзя.</em></span>
Рекомендуется, чтобы Вы создали резервную копию файла <code>keyring</code>
немедленно после составления первой зашифрованной таблицы, прежде и после
ротации главного ключа. Местоположение файла <code>keyring</code> определено
опцией <a href="server.htm#sysvar_keyring_file_data"><code>keyring_file_data
</code></a>. См. <a href="security.html#keyring">раздел 7.5.3</a>.
</p></li></ul>

<h4><a name="innodb-tablespace-encryption-enabling-disabling"></a>
Включение и отключение шифрования табличного пространства InnoDB</h4>
<p>Чтобы включить шифрование для новой таблицы, укажите опцию
<code>ENCRYPTION</code> в <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a>.
<pre>
mysql&gt; CREATE TABLE t1 (c1 INT) ENCRYPTION='Y';
</pre>

<p>Чтобы включить шифрование для существующей таблицы, укажите опцию
<code>ENCRYPTION</code> в <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a>.
<pre>
mysql&gt; ALTER TABLE t1 ENCRYPTION='Y';
</pre>

<p>Чтобы выключить шифрование для таблицы, укажите опцию
<code>ENCRYPTION='N'</code> в <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a>.
<pre>
mysql&gt; ALTER TABLE t1 ENCRYPTION='N';
</pre>

<p>Запланируйте все, изменяя существующую таблицу с опцией
<code>ENCRYPTION</code>. <a href="sql.htm#alter-table"><code>ALTER TABLE ...
ENCRYPTION</code></a> пересоздает таблицу алгоритмом
<code>ALGORITHM=COPY</code>. <code>ALGORITM=INPLACE</code> не поддержан.</p>

<h4><a name="innodb-tablespace-encryption-master-key-rotation"></a>
Шифрование табличного пространства InnoDB и ротация главного ключа</h4>
<p>Основной ключ шифрования должен периодически меняться
и всякий раз, когда Вы подозреваете, что ключ, возможно,
поставлен под угрозу.</p>

<p>Ротация главного ключа атомная работа на уровне сервера.
Каждый раз, когда основной ключ шифрования меняется, все ключи табличных
пространств повторно зашифрованы и сохранены назад к их соответствующим
заголовкам табличного пространства. Как атомная работа, перешифрование должно
пройти для всех ключей табличного пространства, как только работа начата.
Если ротация главного ключа прервана отказом сервера, <code>InnoDB</code>
продолжает процесс при перезапуске сервера.</p>

<p>Ротация основного ключа шифрования
изменяет только основной ключ шифрования и повторно шифрует ключи табличного
пространства. Это не дешифрует или повторно шифрует связанные
данные о табличном пространстве.</p>

<p>Ротация основного ключа шифрования требует привилегии
<a href="security.html#priv_super"><code>SUPER</code></a>.</p>
<p>Чтобы сменить основной ключ шифрования:
<pre>
mysql&gt; ALTER INSTANCE ROTATE INNODB MASTER KEY;
</pre>

<p><a href="sql.htm#alter-instance"><code>ALTER INSTANCE
ROTATE INNODB MASTER KEY</code></a> поддерживает параллельный DML. Однако,
это не может быть выполнено одновременно с
<a href="sql.htm#create-table"><code>CREATE TABLE ... ENCRYPTED</code></a>
или <a href="sql.htm#alter-table"><code>ALTER TABLE ... ENCRYPTED</code></a>,
блокировки взяты, чтобы предотвратить конфликты, которые могли явиться
результатом параллельного выполнения этих запросов. Если один из
противоречивых запросов работает, он должно завершиться прежде, чем
другой сможет продолжить.</p>

<h4><a name="innodb-tablespace-encryption-recovery"></a>
Шифрование табличного пространства InnoDB и восстановление</h4>
<p>Если отказ сервера происходит во время ротации
главного ключа, <code>InnoDB</code> продолжает работу
при перезапуске сервера.</p>

<p>Плагин keyring должен быть загружен до инициализации механизма хранения,
чтобы информация, необходимая, чтобы дешифровать страницы данных о табличном
пространстве, могла быть получена от заголовков табличного пространства
прежде инициализации <code>InnoDB</code> и востановления
активности доступа к данным.</p>

<p>Когда инициализация и восстановление начинаются, ротация
восстанавливается. Из-за отказа сервера, некоторые ключи табличных
пространств могут уже быть зашифрованы, используя новый основной ключ
шифрования. <code>InnoDB</code> читает данные о шифровании из каждого
заголовка табличного пространства, и если данные указывают, что ключ
табличного пространства зашифрован, используя старый ключ шифрования,
получает старый ключ и использует это, чтобы дешифровать ключ пространства.
<code>InnoDB</code> тогда повторно шифрует ключ табличного пространства с
использованием нового основного ключа шифрования и сохраняет повторно
зашифрованный ключ табличного пространства назад в заголовке.</p>

<h4><a name="innodb-tablespace-encryption-exporting"></a>
Экспорт зашифрованных таблиц</h4>
<p>Когда зашифрованная таблица экспортируется, <code>InnoDB</code>
производит <span><em>ключ передачи</em></span>, который используется, чтобы
зашифровать ключ табличного пространства. Зашифрованный ключ табличного
пространства и ключ передачи сохранены в файле
<code><em><code>tablespace_name</code></em>.cfp</code>.
Этот файл вместе с зашифрованным файлом табличного пространства обязан
выполнять работу импорта. При импорте <code>InnoDB</code>
использует ключ передачи, чтобы дешифровать ключ табличного пространства
в <code><em><code>tablespace_name</code></em>.cfp</code>. Подробности в
<a href="#tablespace-copying">разделе 16.7.6</a>.</p>

<h4><a name="innodb-tablespace-encryption-replication"></a>
Шифрование табличного пространства InnoDB и репликация</h4>
<ul><li><p><a href="sql.htm#alter-instance"><code>ALTER INSTANCE ROTATE
INNODB MASTER KEY</code></a> поддержано в среде репликации, если
ведущее устройство и ведомые устройства выполняют версию MySQL, которая
поддерживает функцию шифрования табличного пространства.</li>

<li>Успешный запрос <a href="sql.htm#alter-instance"><code>ALTER
INSTANCE ROTATE INNODB MASTER KEY</code></a> внесен в
двоичный журнал на ведомых устройствах.</li>

<li>Если <a href="sql.htm#alter-instance"><code>ALTER INSTANCE ROTATE INNODB
MASTER KEY</code></a> провалился, оно не пишется в двоичный журнал и не
копируется на ведомые устройства.</li>

<li>Репликация <a href="sql.htm#alter-instance"><code>ALTER INSTANCE ROTATE
INNODB MASTER KEY</code></a> терпит неудачу, если плагин keyring установлен
на ведущем устройстве, но не на ведомом.</li>

<li>Если плагин <code>keyring_file</code> установлен на ведущем
и на ведомом устройствах, но у ведомого устройства нет файла
<code>keyring</code>, репликация <a href="sql.htm#alter-instance"><code>ALTER
INSTANCE ROTATE INNODB MASTER KEY</code></a> создает файл
<code>keyring</code> на ведомом устройстве, принимая что
данные о файле не кэшируются в памяти.
<a href="sql.htm#alter-instance"><code>ALTER INSTANCE ROTATE INNODB MASTER
KEY</code></a> будет использовать данные о файле <code>keyring</code>,
которые кэшируются в памяти, при наличии.</p></li></ul>

<h4><a name="innodb-tablespace-encryption-identifying"></a>
Идентификация Таблиц, которые используют шифрование
табличного пространства InnoDB</h4>
<p>Когда опция <code>ENCRYPTION</code> определена в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
это зарегистрировано в поле <code>CREATE_OPTIONS</code> в
<a href="inform.htm#tables-table"><code>INFORMATION_SCHEMA.TABLES</code></a>.
Это поле может быть запрошена, чтобы идентифицировать зашифрованные таблицы.
<pre>
mysql&gt; SELECT TABLE_SCHEMA, TABLE_NAME, CREATE_OPTIONS
                 FROM INFORMATION_SCHEMA.TABLES
    -&gt;        WHERE CREATE_OPTIONS LIKE '%ENCRYPTION="Y"%';
+--------------+------------+----------------+
| TABLE_SCHEMA | TABLE_NAME | CREATE_OPTIONS |
+--------------+------------+----------------+
| test         | t1         | ENCRYPTION="Y" |
+--------------+------------+----------------+
</pre>

<h4><a name="innodb-tablespace-encryption-usage-notes"></a>
Примечания использования шифрования табличного пространства</h4>
<ul><li><p>Если сервер остановлен во время нормального функционирования,
рекомендуется перезапустить сервер, используя те же самые настройки
шифрования, которые были сконфигурированы ранее.</li>

<li>Первый основной ключ шифрования произведен, когда первая новая или
существующая таблица зашифрована.</li>

<li>Ротация главного ключа повторно шифрует ключи табличных пространств, но
не изменяет ключ табличного пространства непосредственно.
Чтобы изменить ключ табличного пространства, Вы должны отключить и повторно
включить шифрование с использованием
<a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> ENCRYPTION</code></a>,
который является <code>ALGORITHM=COPY</code>,
которая восстанавливает таблицу.</li>

<li>Если таблица составлена с обоими опциями
<a href="sql.htm#create-table"><code>COMPRESSION</code></a> и
<a href="sql.htm#create-table"><code>ENCRYPTION</code></a>, сжатие выполнено
прежде, чем данные о табличном пространстве зашифрованы.</li>

<li>Если файл <code>keyring</code> пуст или отсутствует, первое выполнение
<a href="sql.htm#alter-instance"><code>ALTER INSTANCE ROTATE INNODB MASTER
KEY</code></a> создает основной ключ шифрования.</li>

<li>Удаление плагина <code>keyring_file</code> не удаляет
существующий файл <code>keyring</code>.</li>
<li>Рекомендуется, чтобы Вы не помещали файл <code>keyring</code>
под каталогом, в котором лежат файлы с данными табличного пространства.
Местоположение <code>keyring</code> определено опцией
<a href="server.htm#sysvar_keyring_file_data"><code>keyring_file_data</code>
</a>.</li>

<li>Изменение <a href="server.htm#sysvar_keyring_file_data"><code>
keyring_file_data</code></a> во время выполнения или перезапуск сервера с
новым <a href="server.htm#sysvar_keyring_file_data"><code>keyring_file_data
</code></a> может сделать ранее зашифрованные таблицы недоступными,
приводя к потере данных.</p></li></ul>

<h4><a name="innodb-tablespace-encryption-limitations"></a>
Ограничения шифрования табличного пространства InnoDB</h4>
<ul><li><p>Advanced Encryption Standard (AES) является единственным
поддержанным алгоритмом шифрования. <code>InnoDB</code> шифрование табличного
пространства использует режим блочного шифрования Electronic Codebook (ECB)
для ключевого шифрования табличного пространства и режим блочного шифрования
Cipher Block Chaining (CBC) для шифрования данных.</li>

<li>Изменение атрибута таблицы <code>ENCRYPTION</code> делается через
<code>ALGORITHM=COPY</code>. <code>ALGORITHM=INPLACE</code> не поддержан.
</li>

<li>Шифрование табличного пространства поддерживает только таблицы, которые
сохранены в табличных пространствах
<a href="glossary.htm#glos_file_per_table">file-per-table</a>.
Шифрование не поддержано для таблиц, сохраненных в другом
типе табличного пространства, включая
<a href="glossary.htm#glos_general_tablespace">общие табличные пространства
</a>, <a href="glossary.htm#glos_system_tablespace">
системное табличное пространство</a>, табличные пространства журнала отмены
и временное табличное пространство.</li>

<li>Вы не можете переместить или скопировать зашифрованную таблицу из
табличного пространства <a href="glossary.htm#glos_file_per_table">
file-per-table</a> в неподдерживаемый тип табличного пространства.</li>

<li>Шифрование табличного пространства
относится только к данным в табличном пространстве. Данные не зашифрованы в
каких-либо журналах.</p></li></ul>

<h2><a name="innodb-tables"></a>16.8. Таблицы и индексы InnoDB</h2>
<h3><a name="using-innodb-tables"></a>16.8.1. Составление таблиц InnoDB</h3>
<p>Чтобы создать таблицу, используйте
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.
Вы не должны определить <code>ENGINE=InnoDB</code>, если <code>InnoDB</code>
определен как механизм хранения по умолчанию. Вы могли бы все еще
использовать <code>ENGINE=InnoDB</code>, если Вы планируете использовать
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
или репликацию, чтобы повторить <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> на сервере, где механизм хранения по умолчанию
не <code>InnoDB</code>.
<pre>
-- Default storage engine = InnoDB.
CREATE TABLE t1 (a INT, b CHAR (20), PRIMARY KEY (a));
-- Backward-compatible with older MySQL.
CREATE TABLE t2 (a INT, b CHAR (20), PRIMARY KEY (a)) ENGINE=InnoDB;
</pre>

<p>Когда включена опция <a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a>, что является значением по умолчанию,
таблица неявно составлена в отдельном табличном пространстве file-per-table.
Наоборот, когда <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> выключена, таблица неявно составлена в
системном табличном пространстве. Вы можете использовать
<a href="sql.htm#create-table"><code>CREATE TABLE ... TABLESPACE</code></a>,
чтобы явно создать таблицу в любом из трех типов табличного пространства.</p>

<p>Когда Вы создаете таблицу, MySQL создает каталог базы данных в
соответствии с каталогом данных MySQL.
Для таблицы, составленной в табличном пространстве file-per-table,
создается файл <a href="glossary.htm#glos_ibd_file">.ibd</a>.
Таблица, создаваемая в системном табличном пространстве, составлена в
существующем системном табличном пространстве файлов
<a href="glossary.htm#glos_ibd_file">ibdata</a>.
Таблица, создаваемая в общем табличном пространстве, составлена в
существующем общем табличном пространстве файла
<a href="glossary.htm#glos_ibd_file">.ibd</a>.</p>

<p>Внутренне <code>InnoDB</code> добавляет запись
для каждой таблицы к словарю данных. Запись включает имя базы данных.
Например, если таблица <code>t1</code> создается в базе данных
<code>test</code>, запись будет <code>'test/t1'</code>.
Это означает, что Вы можете составить таблицу с тем же самым именем
(<code>t1</code>) в иной базе данных, и имена таблиц не сталкиваются
внутри <code>InnoDB</code>.</p>

<h4><a name="idm139965326876384"></a>Просмотр свойств таблиц</h4>
<p>Используйте <a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS
</code></a>:
<pre>
mysql &gt; SHOW TABLE STATUS FROM test LIKE 't%' \G;
*************************** 1. row ***************************
 Name: t1
 Engine: InnoDB
Version: 10
 Row_format: Compact
 Rows: 0
 Avg_row_length: 0
Data_length: 16384
Max_data_length: 0
   Index_length: 0
  Data_free: 0
 Auto_increment: NULL
Create_time: 2015-03-16 15:13:31
Update_time: NULL
 Check_time: NULL
  Collation: latin1_swedish_ci
   Checksum: NULL
 Create_options:
Comment:
1 row in set (0.00 sec)
</pre>

<p>В выводе состояния Вы видите, что свойство
<a href="glossary.htm#glos_row_format">Row format</a> таблицы
<code>t1</code> <code>Compact</code>. Формат строки
<code><a href="glossary.htm#glos_dynamic_row_format">Dynamic</a></code> или
<code><a href="glossary.htm#glos_compressed_row_format">Compressed</a>
</code> используют особенности <code>InnoDB</code>, такие как табличное
сжатие и хранение вне страницы для длинных значений столбцов. Чтобы
использовать эти форматы строки, Вы можете включить
<a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a> (по умолчанию):
<pre>
SET GLOBAL innodb_file_per_table=1;
CREATE TABLE t3 (a INT, b CHAR (20), PRIMARY KEY (a)) ROW_FORMAT=DYNAMIC;
CREATE TABLE t4 (a INT, b CHAR (20), PRIMARY KEY (a)) ROW_FORMAT=COMPRESSED;
</pre>

<p>Или Вы можете использовать <a href="sql.htm#create-table"><code>CREATE
TABLE ... TABLESPACE</code></a>, чтобы создать таблицу <code>InnoDB</code>
в общем табличном пространстве. Общие табличные пространства поддерживают
все форматы строки. Для получения дополнительной информации см.
<a href="#general-tablespaces">раздел 16.7.9</a>.
<pre>
CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1 ROW_FORMAT=DYNAMIC;
</pre>

<p><a href="sql.htm#create-table"><code>CREATE TABLE ... TABLESPACE</code>
</a> может также использоваться, чтобы создать таблицу с форматом строки
<code>Dynamic</code> в системном табличном пространстве, а также таблицы с
форматом строк <code>Compact</code> или <code>Redundant</code>.
<pre>
CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE = innodb_system
       ROW_FORMAT=DYNAMIC;
</pre>

<p>Табличные свойства могут также быть запрошены, используя
таблицы Information Schema:
<pre>
SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES WHERE NAME='test/t1' \G
*************************** 1. row ***************************
 TABLE_ID: 45
 NAME: test/t1
 FLAG: 1
   N_COLS: 5
SPACE: 35
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
SPACE_TYPE: Single
</pre>

<h4><a name="idm139965326851168"></a>
Определение первичного ключа для таблиц InnoDB</h4>
<p>Всегда настраивайте <a href="glossary.htm#glos_primary_key">первичный
ключ</a> для каждой таблицы, определяя столбец или столбцы, которые:</p>

<ul><li><p>Ссылаются самыми важными запросами.</li>
<li>Никогда не оставляются незаполненными.</li>
<li>Никогда не имеют двойных значений.</li>
<li>Редко изменяют однажды вставленное значение.</p></li></ul>

<p>Например, в таблице, содержащей информацию о людях, Вы не создали бы
первичный ключ на <code>(firstname, lastname)</code> потому, что больше чем у
одного человека может быть то же самое имя, у некоторых людей есть пустые
фамилии, и иногда люди меняют свои имена. С очень многими ограничениями часто
нет очевидного набора столбцов, чтобы использовать в качестве первичного
ключа, таким образом, Вы создаете новый столбец с числовым ID, чтобы служить
всем или частью первичного ключа. Вы можете объявить столбец
<a href="glossary.htm#glos_auto_increment">auto-increment</a>, чтобы
значения были заполнены автоматически, когда строки вставлены:
<pre>
-- The value of ID can act like a pointer between related items in different tables.
CREATE TABLE t5 (id INT AUTO_INCREMENT, b CHAR (20), PRIMARY KEY (id));
-- The primary key can consist of more than one column. Any autoinc column must come first.
CREATE TABLE t6 (id INT AUTO_INCREMENT, a INT, b CHAR (20), PRIMARY KEY (id,a));
</pre>

<p>Хотя таблица работает правильно, не определяя первичный ключ, первичный
ключ связан со многими аспектами работы и является решающим аспектом проекта
для любой большой или часто используемой таблицы. Рекомендуется, чтобы Вы
всегда определили первичный ключ в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.
Если Вы составляете таблицу, вводите данные и затем выполняете
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
чтобы добавить первичный ключ позже, эта работа намного медленнее, чем
определение первичного ключа, составляя таблицу.</p>

<h3><a name="innodb-physical-record"></a>16.8.2.
Физическая структура строки таблиц InnoDB</h3>
<p>Физическая структура строки таблицы зависит от формата строки,
определенного, когда таблица составлена. Если формат строки не определен,
формат строки по умолчанию используется. Формат строки по умолчанию определен
опцией <a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>, у которой есть значение
по умолчанию <code>DYNAMIC</code>.</p>

<p>Формат <code>REDUNDANT</code> доступен, чтобы сохранить совместимость с
более старыми версиями MySQL.</p>
<p>Чтобы проверить формат строки таблицы, Вы можете использовать
<a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS</code></a>:
<pre>
mysql&gt; SHOW TABLE STATUS IN test1\G
*************************** 1. row ***************************
 Name: t1
 Engine: InnoDB
Version: 10
 Row_format: Dynamic
 Rows: 0
 Avg_row_length: 0
Data_length: 16384
Max_data_length: 0
   Index_length: 16384
  Data_free: 0
 Auto_increment: 1
Create_time: 2016-09-14 16:29:38
Update_time: NULL
 Check_time: NULL
  Collation: latin1_swedish_ci
   Checksum: NULL
 Create_options:
Comment:
</pre>

<p>Вы можете также проверить формат строки, запрашивая
<a href="inform.htm#innodb-sys-tables-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>.
<pre>
mysql&gt; SELECT NAME, ROW_FORMAT FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES
                 WHERE NAME='test1/t1';
+----------+------------+
| NAME     | ROW_FORMAT |
+----------+------------+
| test1/t1 | Dynamic    |
+----------+------------+
</pre>

<h4><a name="idm139965326822144"></a>Характеристики формата строки Redundant
</h4>
<p>Строки в таблицах, использующие формат <code>REDUNDANT</code>,
имеют следующие характеристики:</p>
<ul><li><p>Каждый индекс содержит 6-байтовый заголовок. Заголовок
используется, чтобы соединить последовательные записи, а также в блокировке
на уровне строки.</li>

<li>Записи в кластеризируемом индекс содержат области для всех определяемых
пользователем столбцов. Кроме того, есть 6-байтовая операционная область
ID и 7-байтовая область указателя.</li>

<li>Если никакой первичный ключ не был определен для таблицы, каждый
кластеризируемый индекс также содержит 6-байтовую область ID.</li>
<li>Каждый вторичный индекс также содержит все области первичного ключа,
определенные для кластеризируемых индексных ключей, которые не
находятся во вторичном индексе.</li>

<li>Запись содержит указатель на каждую область записи.
Если полная длина областей меньше 128 байтов, указатель составляет один байт,
иначе, два байта. Массив этих указателей называют каталогом записей.
Область, куда эти указатели указывают, называют частью данных записи.</li>

<li>Внутренне <code>InnoDB</code> хранит символьные столбцы фиксированной
длины, такие как <a href="types.htm#char"><code>CHAR(10)</code></a>,
в формате фиксированной длины. <code>InnoDB</code> не усекает конечные
пробелы столбцов <a href="types.htm#char"><code>VARCHAR</code></a>.</li>

<li>Значение SQL <code>NULL</code> резервирует один или два байта в
каталоге записей. Помимо этого, SQL <code>NULL</code>
резервирует нулевые байты в части данных, если сохранен в столбце переменной
длины. В столбце фиксированной длины это резервирует фиксированную длину
столбца в части данных. Сохранение фиксированного пространства для
<code>NULL</code> позволяет обновление столбца от значения <code>NULL</code>
до не-<code>NULL</code>, не вызывая фрагментацию индексной страницы.</p></li></ul>

<h4><a name="idm139965326804480"></a>Характеристики формата строки COMPACT
</h4>
<p>Формат строки <code>COMPACT</code> уменьшает место для хранения строки
приблизительно на 20% по сравнению с <code>REDUNDANT</code>
за счет увеличения использования центрального процессора для некоторых
операций. Если Ваша рабочая нагрузка типичная, которая ограничена частотами
успешных обращений кэша и дисковой скоростью, <code>COMPACT</code>,
вероятно, будет быстрее. Если рабочая нагрузка редкий случай, который
ограничен скоростью центрального процессора, компактный формат мог
бы быть медленнее.</p>

<p>Строки в таблице имеют следующие характеристики:</p>
<ul><li><p>Каждая индексная запись содержит 5-байтовый заголовок, которому
может предшествовать заголовок переменной длины.
Заголовок используется, чтобы соединить последовательные записи, а
также в блокировке на уровне строки.</li>

<li>Часть переменной длины заголовка содержит битовый вектор для того,
чтобы указать столбцы <code>NULL</code>.
Если число столбцов в индексировании, которые могут быть
<code>NULL</code> <em><code>N</code></em>, битовый вектор занимает
<code>CEILING(<em><code>N</code></em>/8)</code> байт.
Например, если есть от 9 до 15 столбцов, которые могут быть
<code>NULL</code>, битовый вектор занимает два байта. Столбцы, которые
являются <code>NULL</code>, не занимают место, кроме бита в этом векторе.
Часть переменной длины заголовка также содержит длины столбцов переменной
длины. Каждая длина берет один или два байта, в зависимости от максимальной
длины столбца. Если все столбцы в индексировании <code>NOT NULL</code> и
имеют фиксированную длину, у заголовка нет никакой части переменной длины.
</li>

<li>Для каждого не-<code>NULL</code> поля переменной длины
заголовок содержит длину столбца в одном или двух байтах. Два байта
необходимы только, если часть столбца сохранена внешне в страницах
переполнения, или максимальная длина превышает 255 байтов, и фактическая
длина превышает 127 байтов. Для внешне сохраненного столбца 2-байтовая длина
указывает на длину внутренне сохраненной части плюс 20-байтовый указатель на
внешне сохраненную часть. Внутренняя часть составляет 768 байтов, таким
образом, длина 768+20. 20-байтовый указатель хранит истинную длину столбца.
</li>

<li>Ззаголовок сопровождается содержанием столбцов не-<code>NULL</code>.</li>
<li>Записи в кластеризируемом индексе содержат области для всех определяемых
пользователем столбцов. Кроме того, есть 6-байтовая операционная область ID
и 7-байтовая область указателя.</li>

<li>Если никакой первичный ключ не был определен для таблицы, каждая запись
кластеризируемого индекса также содержит 6-байтовую область ID.</li>
<li>Каждая запись вторичного индекса
также содержит все области первичного ключа, определенные для
кластеризируемого индексного ключа, которые не находятся во вторичном
индексе. Если какая-либо из этих областей первичного ключа
переменной длины, заголовок для каждого вторичного индекса
имеет часть переменной длины, чтобы сделать запись их длин, даже если
вторичный индекс определен на столбцах фиксированной длины.</li>

<li>Внутренне, для хранения наборов символов фиксрованной длины
прменяются столбцы символов фиксированной длины, например,
<a href="types.htm#char"><code>CHAR(10)</code></a> в
формате фиксированной длины.</p>

<p><code>InnoDB</code> не усекает конечные пробелы в столбцах
<a href="types.htm#char"><code>VARCHAR</code></a>.</li>

<li>Внутренне, для наборов символов переменной длины, например,
<code>utf8mb3</code> и <code>utf8mb4</code>, <code>InnoDB</code>
использует для хранения
<a href="types.htm#char"><code>CHAR(<em><code>N</code></em>)</code></a>
в <em><code>N</code></em> байт, обрезая конечные пробелы. Если байт длины
<a href="types.htm#char"><code>CHAR(<em><code>N</code></em>)</code></a>
столбца превышает <em><code>N</code></em> байт, <code>InnoDB</code>
обрезает конечные пробелы к минимуму длины байта значения столбца.
Максимальная длина столбца
<a href="types.htm#char"><code>CHAR(<em><code>N</code></em>)</code></a>
максимальная длина символа *<em><code>N</code></em>.</p>

<p><code>InnoDB</code> резервирует минимум
<em><code>N</code></em> байт для
<a href="types.htm#char"><code>CHAR(<em><code>N</code></em>)</code></a>.
Сохранение минимального пространства <em><code>N</code></em>
во многих случаях позволяет обновлениям столбца быть сделанными на месте, не
вызывая фрагментацию индексной страницы. В сравнении, для
<code>ROW_FORMAT=REDUNDANT</code>, столбцы
<a href="types.htm#char"><code>CHAR(<em><code>N</code></em>)</code></a>
занимают максимальную символьную длину байта *<em><code>N</code></em>.</p>

<p><code>CHAR</code> обработан как тип переменной длины, если длина значения
столбца больше чем или равна 768 байтам, что может произойти, если
максимальная длина байта набора символов больше 3, как с
<code>utf8mb4</code>. Когда обработано как тип переменной длины,
значение столбца <code>CHAR</code> может быть выбрано для хранения вне
страницы. Для получения дополнительной информации см.
<a href="#innodb-row-format">раздел 16.10</a>.</p>

<p>Дескриптор <code>ROW_FORMAT=DYNAMIC</code> и
<code>ROW_FORMAT=COMPRESSED</code> хранят
<a href="types.htm#char"><code>CHAR</code></a>
таким же образом, как <code>ROW_FORMAT=COMPACT</code>.</p></li></ul>

<h4><a name="idm139965326753952"></a>Форматы строк DYNAMIC и COMPRESSED</h4>
<p>Форматы строк <code>DYNAMIC</code> и <code>COMPRESSED</code>
это варианты формата <code>COMPACT</code>.
Для информации об этих форматах строки см.
<a href="#innodb-row-format-dynamic">раздел 16.10.3</a>.</p>

<h3><a name="innodb-migration"></a>16.8.3. Перемещение или копирование таблиц
InnoDB в другую машину</h3>
<p>Этот раздел описывает методы для перемещения или копирования некоторых
или всех таблиц <code>InnoDB</code> на другой сервер.
Например, Вы могли бы переместить весь экземпляр MySQL на больший, более
быстрый сервер, Вы могли бы клонировать весь экземпляр MySQL к новому
ведомому серверу репликации, Вы могли бы скопировать отдельные таблицы на
другой сервер, чтобы развить и проверить приложение, или к серверу хранилища
данных, чтобы представить доклады.</p>

<p>Методы для перемещения или копирования таблиц включают:</p>
<ul><li><p><a href="#copy-tables-transportable-tablespaces">
Мобильные табличные пространства</a></li>

<li><a href="#copy-tables-meb">MySQL Enterprise Backup</a></li>
<li><a href="#copy-tables-cold-backup">Копирование файлов с данными
</a></li>
<li><a href="#copy-tables-export-import">
Экспорт и импорт (mysqldump)</a></p></li></ul>

<h4><a name="idm139965326737632"></a>Имена в нижнем регистре</h4>
<p>В Windows <code>InnoDB</code> всегда хранит имена базы данных и таблиц
внутренне в нижнем регистре. Чтобы переместить базы данных в двоичном формате
из Unix в Windows или наоборот, создайте все базы данных и таблицы, используя
строчные имена. Удобный способ достигнуть этого состоит в том, чтобы добавить
следующую строку к группе <code>[mysqld]</code> файла
<code>my.cnf</code> or <code>my.ini</code>
прежде, чем создать любые базы данных или таблицы:
<pre>
[mysqld]
lower_case_table_names=1
</pre>

<h4><a name="copy-tables-transportable-tablespaces"></a>
Мобильные табличные пространства</h4>
<p>Мобильные табличные пространства используют
<a href="sql.htm#flush"><code>FLUSH TABLES ... FOR EXPORT</code></a>, чтобы
скопировать таблицы. Чтобы использовать эту функцию,
таблицы должны быть составлены с
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> в <code>ON</code>, чтобы каждая таблица
имела свое собственное табличное пространство. Для информации об
использовании см. <a href="#tablespace-copying">раздел 16.7.6</a>.
</p>

<h4><a name="copy-tables-meb"></a>MySQL Enterprise Backup</h4>
<p>MySQL Enterprise Backup позволяет Вам поддерживать рабочую базу данных
MySQL, включая таблицы <code>InnoDB</code> и <code>MyISAM</code>, с
минимальным разрушением к операциям, производя последовательный снимок базы
данных. Когда MySQL Enterprise Backup копирует таблицы <code>InnoDB</code>,
чтение и запись таблиц <code>InnoDB</code> и <code>MyISAM</code>
могут продолжиться. Во время копирования <code>MyISAM</code> и других
не-InnoDB таблиц, чтения (но не записи) к тем таблицам разрешены.
Кроме того, MySQL Enterprise Backup может создать сжатые резервные файлы и
поддержать подмножества таблиц <code>InnoDB</code>.
В соединении с двоичным журналом Вы можете выполнить восстановление момента
времени. MySQL Enterprise Backup включен как часть MySQL Enterprise.</p>

<p>Подробности в <a href="mysql.htm#mysql-enterprise-backup">разделе 27.2
</a>.</p>

<h4><a name="copy-tables-cold-backup"></a>Копирование файлов с данными</h4>
<p>Вы можете переместить база данных, просто копируя все соответствующие
файлы, см. <a href="#innodb-backup">раздел 16.17</a>.</p>

<p>Аналогично файлам <code>MyISAM</code>, <code>InnoDB</code>
данные и файлы системного журнала совместимы на всех платформах, имеющих тот
же самый числовой формат с плавающей запятой. Если форматы с плавающей
запятой отличаются, но Вы не использовали
<a href="types.htm#floating-point-types"><code>DOUBLE</code></a> в Ваших
таблицах, процедура та же самая: просто скопируйте соответствующие файлы.</p>

<h4><a name="idm139965326708944"></a>
Соображения мобильности для файлов .ibd File-Per-Table</h4>
<p>Когда Вы перемещаете или копируете файл <code>.ibd</code>, имя каталога
базы данных должно быть тем же самым на целевых системах и источнике.
Табличное определение, сохраненное в совместно используемом табличном
пространстве включает имя базы данных. Операционные ID
и порядковые номера журнала, сохраненные в файлах табличного пространства,
также отличаются между базами данных.</p>

<p>Перемещать файл <code>.ibd</code> и связанную таблицу от одной базы данных
к другой можно с помощью <a href="sql.htm#rename-table"><code>RENAME TABLE
</code></a>:
<pre>
RENAME TABLE <em><code>db1.tbl_name</code></em> TO <em><code>db2.tbl_name</code></em>;
</pre>

<p>Если у Вас есть резервная копия файла <code>.ibd</code>,
Вы можете восстановить ее к исходной установке MySQL следующим образом:</p>
<ol type="1"><li><p>Таблица, должно быть, не была удалена или усечена, так
как Вы скопировали <code>.ibd</code>, табличный ID
сохранен в табличном пространстве.</li>

<li>С помощью <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
удалите текущий файл <code>.ibd</code>:
<pre>
ALTER TABLE <em><code>tbl_name</code></em> DISCARD TABLESPACE;
</pre></li>

<li>Скопируйте резервную копию файла <code>.ibd</code>
к надлежащему каталогу базы данных.</li>
<li>Используйте <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
чтобы сказать <code>InnoDB</code> использовать новый файл
<code>.ibd</code> для таблицы:
<pre>
ALTER TABLE <em><code>tbl_name</code></em> IMPORT TABLESPACE;
</pre>

<p><a href="sql.htm#alter-table"><code>ALTER TABLE ... IMPORT TABLESPACE
</code></a> не проводит в жизнь ограничения внешнего ключа
на импортированные данные.</p></li></ol>

<p>В этом контексте копия файла <code>.ibd</code>
удовлетворяет следующим требованиям:</p>
<ul><li><p>Нет никаких нейтральных модификаций
транзакциями в файле <code>.ibd</code>.</li>

<li>Нет не неслитых буферных записей вставки в <code>.ibd</code>.</li>
<li>Чистка удалила все отмеченные как удаленные записи индекса.</li>
<li><a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
сбросил все измененные страницы <code>.ibd</code>
из буферного пула.</p></li></ul>

<p>Вы можете сделать чистое резервное копирование <code>.ibd</code>:</p>
<ol type="1"><li><p>Остановите всю деятельность
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
и передайте все транзакции.</li>

<li>Ждите, пока <a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS
</code></a> покажет, что нет никаких активных транзакций в базе данных, и
состояние основного потока <code>InnoDB</code> <code>Waiting for server
activity</code>. Тогда Вы можете сделать копию файла <code>.ibd</code>.
</p></li></ol>

<p>Другой метод для того, чтобы сделать чистую копию <code>.ibd</code>:</p>
<ol type="1"><li><p>Используйте MySQL Enterprise Backup.</li>
<li>Запустите второй сервер <a href="programs.htm#mysqld"><span><strong>
mysqld</strong></span></a> и позвольте ему очистить файлы
<code>.ibd</code> в резервном копировании.</p></li></ol>

<h4><a name="copy-tables-export-import"></a>Экспорт и импорт (mysqldump)</h4>
<p>Вы можете использовать <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a>, чтобы вывести Ваши таблицы в дамп на одной
машине и затем импортировать файлы дампа на другой машине. Используя этот
метод, не имеет значения, отличаются ли форматы или содержат ли Ваши таблицы
данные с плавающей запятой.</p>

<p>Один способ увеличить скорость этого метода состоит в том, чтобы выключить
режим <a href="glossary.htm#glos_autocommit">autocommit</a>, импортируя
данные, предполагая, что у табличного пространства есть достаточно
пространства для большого сегмента отмены, который производят транзакции
импорта. Сделайте передачу только после импортирования целой таблицы
или сегмента таблицы.</p>

<h3><a name="converting-tables-to-innodb"></a>16.8.4.
Преобразование таблиц из MyISAM в InnoDB</h3>
<p>Если Вы имеете таблицы <a href="storage.htm#myisam-storage-engine"><code>
MyISAM</code></a>, которые Вы хотите преобразовать в
<a href="innodb.htm"><code>InnoDB</code></a>, рассмотрите следующие
подсказки прежде, чем сделать преобразование.</p>

<p>Разделенные таблицы <code>MyISAM</code>, составленные в предыдущих версиях
MySQL, несовместимы с MySQL 8.0. Такие таблицы должны быть подготовлены до
обновления, удаляя разделение, или преобразовывая их в <code>InnoDB</code>.
См. <a href="partit.htm#partitioning-limitations-storage-engines">раздел
20.6.2</a>.</p>

<ul><li><p><a href="#innodb-convert-memory-usage">
Уменьшите использование памяти для MyISAM</a></li>
<li><a href="#innodb-convert-transactions">
Не упустите слишком длинные или короткие транзакции</a></li>

<li><a href="#innodb-convert-deadlock">
Не волнуйтесь слишком много о тупиках</a></li>
<li><a href="#innodb-convert-plan-storage">
Запланируйте расположение хранения</a></li>

<li><a href="#innodb-convert-convert">
Преобразование существующей таблицы</a></li>
<li><a href="#innodb-convert-clone">Клонирование структуры таблицы
</a></li>

<li><a href="#innodb-convert-transfer">Передача существующих данных
</a></li>
<li><a href="#innodb-convert-plan-storage-2">
Требования хранения</a></li>

<li><a href="#innodb-convert-primary-key">
Тщательно выберите PRIMARY KEY для каждой таблицы</a></li>
<li><a href="#innodb-convert-application-performance">
Соображения потребительских свойств</a></li>
<li><a href="#innodb-convert-understand-files">
Файлы, связанные с таблицами InnoDB</a></p></li></ul>

<h4><a name="innodb-convert-memory-usage"></a>
Уменьшите использование памяти для MyISAM</h4>
<p>Поскольку Вы переходите от таблиц <code>MyISAM</code>, понизьте значение
<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code></a>,
чтобы освободить память, больше не нужную для того, чтобы кэшировать
результаты. Увеличьте значение
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>, которое выполняет подобную роль выделения
кэш-памяти для <code>InnoDB</code>. <a href="glossary.htm#glos_buffer_pool">
Буферный пул</a> кэширует табличные данные и индексы, таким образом, это
действительно удваивает ускорение поисков для запросов и хранения результатов
запроса в памяти для повторного использования.
Для руководства относительно буферной конфигурации размера пула см.
<a href="optimiz.htm#memory-use">раздел 9.12.3.1</a>.</p>

<p>На занятом сервере выполните тесты с выключенным кэшем запроса.
Буферный пул обеспечивает подобную выгоду, таким образом, кэш запроса мог бы
излишне связывать память.</p>

<h4><a name="innodb-convert-transactions"></a>Не упустите слишком длинные
или короткие транзакции</h4>
<p>Поскольку таблицы <code>MyISAM</code> не поддерживают
<a href="glossary.htm#glos_transaction">транзакции</a>,
Вы, возможно, не обратили много внимания на настройку
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>
и команды <a href="sql.htm#commit"><code>COMMIT</code></a> и
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.
Эти ключевые слова важны, чтобы позволить многим сеансам читать и писать
таблицы <code>InnoDB</code> одновременно, обеспечивая
существенную выгоду масштабируемости.</p>

<p>В то время как транзакция открыта, система сохраняет снимок данных в
начале транзакции, что может вызвать существенные накладные расходы, если
система вставляет, обновляет и удаляет миллионы строк, в то время как
беспризорная транзакция продолжает работать. Таким образом, заботьтесь о том,
чтобы избежать транзакций, которые работают слишком долго:</p>

<ul><li><p>Если Вы используете <a href="programs.htm#mysql"><span><strong>
mysql</strong></span></a> для интерактивных экспериментов, всегда командуйте
<a href="sql.htm#commit"><code>COMMIT</code></a> (чтобы завершить изменения)
или <a href="sql.htm#commit"><code>ROLLBACK</code></a>
(чтобы отменить изменения) когда закончите.
Закройте интерактивные сеансы вместо того, чтобы оставить их открытыми в
течение длительных периодов, чтобы избежать долго открытых транзакций.</li>

<li>Удостоверьтесь что любые ошибочные обработчики в Вашем приложении также
вызывают <a href="sql.htm#commit"><code>ROLLBACK</code></a>
или <a href="sql.htm#commit"><code>COMMIT</code></a>.</li>

<li><a href="sql.htm#commit"><code>ROLLBACK</code></a>
относительно дорогая работа, потому что операции
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>
записаны в таблицы <code>InnoDB</code> до
<a href="sql.htm#commit"><code>COMMIT</code></a>,
с ожиданием, что большинство изменений будет передано успешно и обратные
перемотки будут редки. Экспериментируя с большими объемами данных, избегите
производить изменения в больших количествах строк и затем откатывать те
изменения до прежнего уровня.</li>

<li>Загружая большие объемы данных с последовательностью
<a href="sql.htm#insert"><code>INSERT</code></a>, периодически выполняйте
<a href="sql.htm#commit"><code>COMMIT</code></a>, чтобы
избежать транзакций, которые длятся в течение многих часов.
В типичных операциях загрузки для складирования данных, если что-то идет не
так, как надо, Вы усекаете таблицу (используя
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>)
и запустите с начала вместо того, чтобы делать
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.</p></li></ul>

<p>Предыдущие подсказки сохраняют место в памяти и дисковое пространство,
которое может быть потрачено впустую во время слишком длинных транзакций.
Когда транзакции короче, чем они должны быть, проблемой будет чрезмерный
ввод/вывод. С каждым <a href="sql.htm#commit"><code>COMMIT</code></a> MySQL
удостоверяется, что каждое изменение безопасно зарегистрировано на диске,
что вовлекает некоторый ввод/вывод.</p>

<ul><li><p>Для большинства операций на таблицах <code>InnoDB</code>
Вы должны использовать установку
<a href="server.htm#sysvar_autocommit"><code>autocommit=0</code></a>.
С точки зрения эффективности это избегает ненужного ввода/вывода, когда Вы
выпускаете большие количества последовательных
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>.
С точки зрения безопасности это позволяет Вам использовать
<a href="sql.htm#commit"><code>ROLLBACK</code></a>, чтобы возвратить
потерянные или искаженные данные, если Вы делаете ошибку в командах
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
или в обработчике исключения в Вашем приложении.</li>

<li>Время, когда <a href="server.htm#sysvar_autocommit"><code>autocommit=1
</code></a> является подходящим для таблицы, выполняя последовательность
запросов для того, чтобы произвести отчеты или проанализировать статистику.
В этой ситуации нет никакого лишнего ввода/вывода, связанного с
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>, а <code>InnoDB</code>
может <a href="optimiz.htm#innodb-performance-ro-txn">автоматически
оптимизировать рабочую нагрузку только для чтения</a>.</li>

<li>Если Вы делаете серию связанных изменений, завершайте все те
изменения сразу <a href="sql.htm#commit"><code>COMMIT</code></a> в конце.
Например, если Вы вставляете связанные сведения в несколько таблиц, сделайте
одиночный <a href="sql.htm#commit"><code>COMMIT</code></a> после произведения
всех изменений. Или если Вы выполняете много последовательных
<a href="sql.htm#insert"><code>INSERT</code></a>, сделайте
<a href="sql.htm#commit"><code>COMMIT</code></a> после того, как все данные
загружены, если Вы делаете миллионы
<a href="sql.htm#insert"><code>INSERT</code></a>,
возможно разделить огромную транзакцию с помощью
<a href="sql.htm#commit"><code>COMMIT</code></a>
каждые десять тысяч или сто тысяч отчетов, таким образом, транзакция не
становится слишком большой.</li>

<li>Помните, что даже <a href="sql.htm#select"><code>SELECT</code></a>
открывает транзакцию, таким образом, после выполнения некоторого отчета или
отладки запросов в интерактивном <a href="programs.htm#mysql"><span><strong>
mysql</strong></span></a>, выполните <a href="sql.htm#commit"><code>COMMIT
</code></a> или закройте <a href="programs.htm#mysql"><span><strong>mysql
</strong></span></a>.</p></li></ul>

<h4><a name="innodb-convert-deadlock"></a>
Не волнуйтесь слишком много о тупиках</h4>
<p>Вы могли бы видеть предупреждающие сообщения о
<span><span>тупиках</span></span> в журнале ошибок MySQL или выводе
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.
Несмотря на страшно звучащее имя,
<a href="glossary.htm#glos_deadlock">тупик</a> не серьезная проблема для
<code>InnoDB</code> и часто не требуют никакого корректирующего действия.
Когда две транзакции начинают изменять многие таблицы, получая доступ к
таблицам в различном порядке, они могут достигнуть состояния, где каждая
транзакция ждет другую, и ни одна не может продолжить. Когда
<a href="glossary.htm#glos_deadlock_detection">определение тупиков</a>
включено (значение по умолчанию), MySQL немедленно обнаруживает это условие,
и отменяет <span><span>меньшую</span></span>, позволяя другой продолжиться.
Если обнаружение тупика отключено, используя
<a href="#sysvar_innodb_deadlock_detect"><code>
innodb_deadlock_detect</code></a>, <code>InnoDB</code> полагается на
<a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a>, чтобы откатить транзакции до прежнего
уровня в случае тупика.</p>

<p>Так или иначе, Ваши приложения нуждаются в логике обработки ошибок, чтобы
перезапустить транзакцию, которая насильственно отменена из-за тупика. Когда
Вы переиздаете те же самые запросы SQL как прежде, оригинальная проблема
синхронизации больше не применяется: или другая транзакция уже закончилась, и
Ваша может продолжиться, или другая транзакция все еще происходит, и Ваша
транзакция ждет, пока это не заканчивается.</p>

<p>Если предупреждения тупика постоянно происходят, Вы могли бы рассмотреть
код программы, чтобы переупорядочить операции SQL последовательным способом,
или сократить транзакции. Вы можете проверить с включенной опцией
<a href="#sysvar_innodb_print_all_deadlocks"><code>
innodb_print_all_deadlocks</code></a>, чтобы видеть все предупреждения тупика
в журнале ошибок MySQL, а не только последнее предупреждение в
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.</p>
<p>Подробности в <a href="#innodb-deadlocks">разделе 16.5.5</a>.</p>

<h4><a name="innodb-convert-plan-storage"></a>
Запланируйте расположение хранения</h4>
<p>Получить лучшую работу от <code>InnoDB</code> Вы можете, скорректировав
много параметров, связанных с расположением хранения.</p>

<p>Когда Вы преобразовываете таблицы <code>MyISAM</code>, которые являются
большими, часто используемыми и содержащими жизненные данные, исследуйте и
рассмотрите опции <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> и
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>, а также параметры
<a href="#innodb-row-format"><code>ROW_FORMAT</code> и
<code>KEY_BLOCK_SIZE</code></a> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.</p>

<p>Во время Ваших начальных экспериментов самая важная установка
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>. Когда эта установка включена, что
является значением по умолчанию, новые таблицы неявно составлены в табличных
пространствах <a href="glossary.htm#glos_file_per_table">file-per-table</a>.
В отличие от системного табличного пространства, табличные пространства
file-per-table позволяют дисковому пространству использоваться операционной
системой, когда таблица является усеченной или удаленной. Табличные
пространства File-per-table также поддерживают строки форматов
<a href="glossary.htm#glos_dynamic_row_format">DYNAMIC</a> и
<a href="glossary.htm#glos_compressed_row_format">COMPRESSED</a>
и связанные особенности, такие как табличное сжатие, хранение вне страницы
для длинных столбцов переменной длины и большой префикс индекса.
Для получения дополнительной информации см.
<a href="#innodb-multiple-tablespaces">раздел 16.7.4</a>.</p>

<p>Вы можете также сохранить таблицы в совместно используемом общем табличном
пространстве, которое поддерживает многие таблицы и все форматы строки.
Для получения дополнительной информации см.
<a href="#general-tablespaces">раздел 16.7.9</a>.</p>

<h4><a name="innodb-convert-convert"></a>Преобразование существующей таблицы
</h4>
<p>Преобразовать не-<code>InnoDB</code> таблицу, чтобы использовать
<code>InnoDB</code> можно через
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>:
<pre>
ALTER TABLE <em><code>table_name</code></em> ENGINE=InnoDB;
</pre>

<h4><a name="innodb-convert-clone"></a>Клонирование структуры таблицы</h4>
<p>Вы могли бы сделать таблицу <code>InnoDB</code>, которая является клоном
таблицы MyISAM, вместо того, чтобы делать
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
чтобы проверить старую и новую таблицу бок о бок перед переключением.</p>

<p>Создайте пустую таблицу с идентичными определениями столбца и индексов.
Примените <code>show create table <em><code>table_name</code></em>\G</code>,
чтобы посмотреть полный запрос
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.
Смените <code>ENGINE</code> на <code>ENGINE=INNODB</code>.</p>

<h4><a name="innodb-convert-transfer"></a>Передача существующих данных</h4>
<p>Передать большой объем данных в пустую таблицу, составленную как показано
в предыдущем разделе, можно, вставив строки с помощью <code>INSERT INTO
<em><code>innodb_table</code></em> SELECT * FROM
<em><code>myisam_table</code></em> ORDER BY
<em><code>primary_key_columns</code></em></code>.</p>

<p>Вы можете также создать индексирование для
таблицы после вставки данных. Исторически, создание
новых вторичных индексов было медленной работой для InnoDB, но теперь Вы
можете создать индексирование после того, как данные загружены,
относительно легко и быстро.</p>

<p>Если Вы имеете ограничения <code>UNIQUE</code> на вторичные ключи, Вы
можете ускорить табличный импорт, выключая проверки уникальности временно во
время работы импорта:
<pre>
SET unique_checks=0;
<em><code>... import operation ...</code></em>
SET unique_checks=1;
</pre>

<p>Для больших таблиц это сохраняет дисковый ввод/вывод потому, что
<code>InnoDB</code> может использовать
<a href="glossary.htm#glos_change_buffer">буфер изменения</a>, чтобы
записать вторичный индекс как пакет.
Будьте уверены, что данные не содержат дубликаты ключа.
<a href="server.htm#sysvar_unique_checks"><code>unique_checks</code></a>
разрешает, но не требует, чтобы механизмы хранения
проигнорировали дубликаты ключа.</p>

<p>Чтобы получить лучший контроль над процессом вставки, Вы могли бы
вставить большие таблицы по частям:
<pre>
INSERT INTO newtable SELECT * FROM oldtable
       WHERE yourkey &gt; <em><code>something</code></em> AND
             yourkey &lt;= <em><code>somethingelse</code></em>;
</pre>

<p>После того, как все записи были вставлены, Вы
можете переименовать таблицы.</p>
<p>Во время преобразования больших таблиц, увеличьте размер буферного пула,
чтобы уменьшить дисковый ввод/вывод, максимум до 80% физической памяти. Вы
можете также увеличить размер файлов системного журнала.</p>

<h4><a name="innodb-convert-plan-storage-2"></a>Требования хранения</h4>
<p>Если Вы намереваетесь сделать несколько временных копий своих данных в
таблицах во время конверсионного процесса, рекомендуется, чтобы Вы составили
таблицы в табличных пространствах file-per-table, чтобы Вы могли восстановить
дисковое пространство, когда Вы удаляете таблицы. Как упомянуто ранее, когда
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> включена (значение по умолчанию), созданные таблицы
неявно составлены в табличных пространствах file-per-table.</p>

<p>Преобразовываете ли Вы <code>MyISAM</code> непосредственно или создаете
клонированную таблицу <code>InnoDB</code>, удостоверьтесь, что у Вас есть
достаточное дисковое пространство, чтобы хранить старые и новые таблицы во
время процесса. Таблицы <span>InnoDB</span> требуют большего количества
дискового пространства, чем <code>MyISAM</code>. Если
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
исчерпывает пространство, она запускает откат, а это может занять часы.
Для вставок <code>InnoDB</code> использует буфер вставки, чтобы слить
вторичные индексные записи в пакетах. Это сохраняет много дискового
ввода/вывода. Для отмены не используется такой механизм, и отмена может
занять в 30 раз дольше, чем вставка.</p>

<p>В случае безудержной отмены, если у Вас нет ценных данных в Вашей базе
данных, может быть желательно уничтожить процесс базы данных, а не ждать
миллионов дисковых операций ввода/вывода. Для полной процедуры см.
<a href="#forcing-innodb-recovery">раздел 16.20.2</a>.</p>

<h4><a name="innodb-convert-primary-key"></a>Тщательно выберите PRIMARY KEY
для каждой таблицы</h4>
<p><code>PRIMARY KEY</code> это критический фактор, затрагивающий исполнение
запросов MySQL и использование пространства для таблиц и индексов.
У каждой строки в таблице должно быть значение первичного ключа, но ни у
каких двух строк не может быть того же самого значения первичного ключа.</p>

<p>Вот направляющие идеи для первичного ключа, сопровождаемые
более подробными объяснениями.</p>
<ul><li><p>Объявите <code>PRIMARY KEY</code> для каждой таблицы. Как правило,
это самый важный столбец, к которому Вы обращаетесь в <code>WHERE</code>,
ища единственную строку.</li>

<li>Объявите <code>PRIMARY KEY</code> в <a href="sql.htm#create-table"><code>
CREATE TABLE</code></a> вместо того, чтобы добавить это позже через
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</li>

<li>Выберите столбец и его тип данных тщательно. Предпочтите числовые столбцы
символьным или строкам.</li>
<li>Рассмотрите использование столбца auto-increment, если нет другого
устойчивого, уникального, ненулевого, числового столбца, чтобы использовать.
</li>

<li>Столбец auto-increment также хороший выбор, если есть сомнение, могло ли
значение столбца первичного ключа когда-либо изменяться. Изменение значения
столбца первичного ключа является дорогой работой, возможно вовлекая
реконструкцию данных в пределах таблицы и в пределах
каждого вторичного индекса.</p></li></ul>

<p>Рассмотрите добавление <a href="glossary.htm#glos_primary_key">primary
key</a> к любой таблице, у которой его еще нет. Используйте самый маленький
практический числовой тип, основанный на максимальном спроектированном
размере таблицы. Это может сделать каждую строку немного более компактной,
что может привести к существенной экономии места для больших таблиц.
Сбережения пространства умножены, если таблица имеет
<a href="glossary.htm#glos_secondary_index">вторичный индекс</a>,
потому что значение первичного ключа повторено в каждом вторичном индексе.
В дополнение к сокращению размера данных на диске маленький первичный ключ
также позволяет большее количество совпадения данных в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>,
ускоряя все виды операций и улучшая параллелизм.</p>

<p>Если у таблицы уже есть первичный ключ на некотором более длинном столбце,
таком как <code>VARCHAR</code>, рассмотрите добавление нового столбца
unsigned <code>AUTO_INCREMENT</code> и переключение первичного ключа на
него, даже если на этот столбец не ссылаются в запросах. Это изменение
проекта может произвести существенную экономию места во вторичном индексе.
Вы можете определять прежние столбцы первичного ключа как
<code>UNIQUE NOT NULL</code>, чтобы провести в жизнь те же самые ограничения,
как <code>PRIMARY KEY</code>, то есть, чтобы предотвратить двойные или
нулевые значения в этих столбцах.</p>

<p>Если Вы распространяете соответствующую информацию через много таблиц,
как правило, каждая таблица использует тот же самый столбец для своего
первичного ключа. Например, у базы данных персонала могло бы быть несколько
таблиц, каждая с первичным ключом номера служащего. У базы данных продаж
могли бы быть некоторые таблицы с первичным ключом номера заказчика и другие
таблицы с первичным ключом порядкового номера. Поскольку поиски, используя
первичный ключ очень быстры, Вы можете создать эффективные запросы
для таких таблиц.</p>

<p>Если Вы не используете <code>PRIMARY KEY</code>, MySQL создает невидимый.
Это 6-байтовое значение, которое могло бы быть более длинным, чем надо,
таким образом тратя впустую место.
Поскольку это скрыто, Вы не можете обратиться к этому в запросах.</p>

<h4><a name="innodb-convert-application-performance"></a>
Соображения потребительских свойств</h4>
<p>Дополнительная надежность и особенности масштабируемости
<code>InnoDB</code> действительно потребуют большего количества дискового
места, чем эквивалентные таблицы <code>MyISAM</code>.
Вы могли бы изменить столбец и определения индекса для лучшего
использования пространства, уменьшенного ввода/вывода и потребления памяти,
обрабатывая наборы результатов, и лучших планов оптимизации запроса, делающих
эффективное использование поисков по индексу.</p>

<p>Если Вы действительно настраиваете числовой столбец ID
для первичного ключа, используйте это значение, чтобы перекрестно сослаться
со связанными значениями в любых других таблицах, особенно для запросов
<a href="glossary.htm#glos_join">join</a>. Например, вместо того, чтобы
принять название страны как входное значение и сделать запросы, ищущие то же
самое имя, сделайте один поиск, чтобы определить ID страны, затем сделайте
другие запросы (или единственный запрос), чтобы искать релевантную информацию
в нескольких таблицах. Вместо того, чтобы хранить клиента или номер изделия
по каталогу как строку цифр, потенциально израсходовав несколько байтов,
преобразуйте это в числовой ID для хранения и запросов. 4 байтный столбец
<a href="types.htm#integer-types"><code>INT</code></a>
может индексировать более чем 4 миллиарда элементов.
Для диапазонов различных типов целого числа см.
<a href="types.htm#integer-types">раздел 12.2.1</a>.</p>

<h4><a name="innodb-convert-understand-files"></a>
Файлы, связанные с таблицами InnoDB</h4>
<p>Файлы <code>InnoDB</code> требуют большей заботы, чем <code>MyISAM</code>:
</p>

<ul><li><p>Вы не должны удалить файлы
<a href="glossary.htm#glos_ibdata_file">ibdata</a>, которые представляют
<a href="glossary.htm#glos_system_tablespace">
системное табличное пространство</a>.</li>

<li>Копирование таблицы от одного сервера на другой требует
<code>FLUSH TABLES ... FOR EXPORT</code> и копирования
<code><em><code>table_name</code></em>.cfg</code> файла наряду с
<code><em><code>table_name</code></em>.ibd</code>.</p></li></ul>

<h3><a name="innodb-auto-increment-handling"></a>16.8.5.
Обработка AUTO_INCREMENT в InnoDB</h3>
<p><code>InnoDB</code> обеспечивает конфигурируемый механизм блокировки,
который может значительно улучшить масштабируемость и исполнение запросов
SQL, которые добавляют строки к таблицам со столбцами
<code>AUTO_INCREMENT</code>. Чтобы использовать механизм
<code>AUTO_INCREMENT</code> с таблицей <code>InnoDB</code>, столбец
<code>AUTO_INCREMENT</code> должен быть определен как часть индексирования
таким образом, что возможно выполнить эквивалент индексированного поиска
<code>SELECT MAX(<em><code>ai_col</code></em>)</code>
на таблице, чтобы получить максимальное значение столбца. Как правило, это
достигнуто, делая столбец, который индексирует первый
столбец некоторой таблицы.</p>

<p>Этот раздел описывает поведение режимов блокировки
<code>AUTO_INCREMENT</code>, значения использования для различных
настроек режима блокировки <code>AUTO_INCREMENT</code> и как
<code>InnoDB</code> инициализирует счетчик <code>AUTO_INCREMENT</code>.</p>

<ul><li><p>Режимы блокировки <a href="#innodb-auto-increment-lock-modes">
AUTO_INCREMENT</a></li>

<li>Значения использования режима блокировки
<a href="#innodb-auto-increment-lock-mode-usage-implications">
AUTO_INCREMENT</a></li>

<li>Инициализация счетчика <a href="#innodb-auto-increment-initialization">
AUTO_INCREMENT</a></p></li></ul>

<h4><a name="innodb-auto-increment-lock-modes"></a>Режимы блокировки
AUTO_INCREMENT</h4>
<p>Этот раздел описывает поведение режимов блокировки
<code>AUTO_INCREMENT</code>, и как каждый режим блокировки затрагивает
репликацию. Режимы блокировки сконфигурированы при запуске, используя
<a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a>.</p>

<p>Следующие термины использованы в описании
<a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a>:</p>

<ul><li><p><span><span><a href="sql.htm#insert"><code>
INSERT</code></a>-подобные</span></span> запросы</p>
<p>Все запросы, которые производят новые строки в таблице, включая
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>,
<a href="sql.htm#replace"><code>REPLACE</code></a>,
<a href="sql.htm#replace"><code>REPLACE ... SELECT</code></a> и
<a href="sql.htm#load-data"><code>LOAD DATA</code></a>. Включает
<span><span>простые вставки</span></span>, <span><span>bulk-вставки</span>
</span> и <span><span>смешанные вставки</span></span>.</li>

<li><span><span>Простые вставки</span></span></p>
<p>Запросы, для которых число строк, которые будут вставлены, может быть
определено заранее (когда запрос первоначально обработано). Это включает
однострочные и многострочные <a href="sql.htm#insert"><code>INSERT</code></a>
и <a href="sql.htm#replace"><code>REPLACE</code></a>, у которых нет
вложенного подзапроса, но не
<a href="sql.htm#insert-on-duplicate"><code>INSERT
... ON DUPLICATE KEY UPDATE</code></a>.</li>

<li><span><span>Bulk-вставки</span></span></p>
<p>Запросы, которыми число строк, которые будут вставлены (и число
необходимых значений auto-increment) не известно заранее. Это включает
<a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>,
<a href="sql.htm#replace"><code>REPLACE ... SELECT</code></a> и
<a href="sql.htm#load-data"><code>LOAD DATA</code></a>,
но не простой <code>INSERT</code>. <code>InnoDB</code>
назначает новые значения для столбца <code>AUTO_INCREMENT</code>
по одному по мере того, как каждая строка обработана.</li>

<li><span><span>Смешанные вставки</span></span></p>
<p>Это <span><span>простые вставки</span></span>, которые определяют значение
auto-increment для некоторых (но не всех) новых строк. Пример следует, где
<code>c1</code> столбец <code>AUTO_INCREMENT</code> таблицы <code>t1</code>:
<pre>
INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'), (NULL,'d');
</pre>

<p>Другой тип <span><span>смешанных вставок</span></span>:
<a href="sql.htm#insert-on-duplicate"><code>INSERT ... ON DUPLICATE KEY
UPDATE</code></a>, который в худшем случае является в действительности
<a href="sql.htm#insert"><code>INSERT</code></a> сопровождаемый
<a href="sql.htm#update"><code>UPDATE</code></a>, где выделенное значение для
столбца <code>AUTO_INCREMENT</code>
может или не может использоваться во время фазы обновления.</p></li></ul>

<p>Есть три возможных настройки для
<a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a>. Это 0, 1 или 2, соответственно для
режимов <span><span>traditional</span></span>, <span><span>consecutive</span>
</span> или <span><span>interleaved</span></span>.</p>

<ul><li><p><a name="innodb-auto-increment-lock-mode-traditional"></a>
<code>innodb_autoinc_lock_mode = 0</code>
(режим <span><span>traditional</span></span>).</p>

<p>Традиционный режим блокировки обеспечивает то же самое поведение, которое
существовало перед тем, как параметр конфигурации
<a href="#sysvar_innodb_autoinc_lock_mode">
<code>innodb_autoinc_lock_mode</code></a> был введен в MySQL 5.1.
Традиционная возможность режима блокировки предоставлена для обратной
совместимости, исполнительного тестирования и обхода проблем со
смешанным режимом вставки из-за возможных различий в семантике.</p>

<p>В этом режиме блокировки все <span><span>INSERT-подобные</span></span>
запросы, получают специальную блокировку <code>AUTO-INC</code> на уровне
таблицы для вставок в таблицы со столбцом <code>AUTO_INCREMENT</code>.
Эта блокировка остается до конца запроса (не до конца транзакции) и
гарантирует, что значения auto-increment назначены в предсказуемом и
повторимом порядке на данную последовательность запросов
<a href="sql.htm#insert"><code>INSERT</code></a>, при этом
гарантируя, что значения автоинкремента, назначенные любым
данным запросом, последовательны.</p>

<p>В случае основанной на запросе репликации
это означает, что, когда запрос SQL копируется на ведомом сервере, те же
самые значения используются для столбца auto-increment
на главном сервере. Результат выполнения многократных
<a href="sql.htm#insert"><code>INSERT</code></a> детерминирован,
и ведомое устройство воспроизводит те же самые данные, как на ведущем
устройстве. Если значения auto-increment, произведенные многократным
<a href="sql.htm#insert"><code>INSERT</code></a>,
были чередованы, результатом будут два параллельных запроса
<a href="sql.htm#insert"><code>INSERT</code></a>, которые
недетерминированы, и не могут быть достоверно размножены к ведомому серверу,
используя основанную на запросе репликацию.</p>

<p>Чтобы ясно понять это, рассмотрите пример, который использует эту таблицу:
<pre>
CREATE TABLE t1 (c1 INT(11) NOT NULL AUTO_INCREMENT,
                 c2 VARCHAR(10) DEFAULT NULL,
                 PRIMARY KEY (c1)) ENGINE=InnoDB;
</pre>

<p>Предположите, что есть две операции, каждая вставляет строки в таблицу со
столбцом <code>AUTO_INCREMENT</code>. Одна транзакция использует
<a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>,
который вставляет 1000 строк, другая использует простой
<a href="sql.htm#insert"><code>INSERT</code></a>, который
вставляет одну строку:
<pre>
Tx1: INSERT INTO t1 (c2) SELECT 1000 rows from another table ...
Tx2: INSERT INTO t1 (c2) VALUES ('xxx');
</pre>

<p><code>InnoDB</code> не может сказать заранее, сколько строк будет получено
от <a href="sql.htm#select"><code>SELECT</code></a> в запросе
<a href="sql.htm#insert"><code>INSERT</code></a> в Tx1, и это назначает
значения auto-increment по одному, в то время как запрос продолжается. С
блокировкой на уровне таблицы, проводимой до конца запроса, только один
<a href="sql.htm#insert"><code>INSERT</code></a>, относящийся к таблице
<code>t1</code>, можно выполнить за один раз, и генерация чисел
auto-increment различными запросами не чередована. Значение, произведенное
для Tx1 запросом <a href="sql.htm#insert-select"><code>INSERT ... SELECT
</code></a>, будет последовательно, и (единственное) значение, используемое
<a href="sql.htm#insert"><code>INSERT</code></a> в Tx2,
будет меньше или больше, чем все используемые для Tx1, в зависимости от того,
который запрос выполняется сначала.</p>

<p>Пока запросы SQL выполняют в том же самом порядке, когда повторяют из
двоичного журнала (используя основанную на запросе репликацию
или в скриптах восстановления), результатами будет то же самое, как было,
когда Tx1 и Tx2 сначала работали. Таким образом, блокировки на уровне
таблицы, проводимые до конца запроса, делают запросы
<a href="sql.htm#insert"><code>INSERT</code></a>, использующие
auto-increment, безопасными для использования с основанной на запросе
репликацией. Однако, те блокировки на уровне таблицы ограничивают параллелизм
и масштабируемость, когда многократные транзакции выполняют вставки
в то же самое время.</p>

<p>В предыдущем примере, если не было никакой блокировки на уровне таблицы,
значения столбца auto-increment, используемого для
<a href="sql.htm#insert"><code>INSERT</code></a> в Tx2,
зависит от того, когда запрос выполняется. Если
<a href="sql.htm#insert"><code>INSERT</code></a> в Tx2
выполняется в то время, как
<a href="sql.htm#insert"><code>INSERT</code></a> в Tx1
работает (а не прежде, чем он запустится или после того, как он завершается),
определенные значения auto-increment, назначенные двумя
<a href="sql.htm#insert"><code>INSERT</code></a>
недетерминированы, и могут измениться.</p>

<p>В режиме <a href="#innodb-auto-increment-lock-mode-consecutive">
последовательной</a> блокировки <code>InnoDB</code>
может избегать использования на уровне таблицы блокировок
<code>AUTO-INC</code> для <span><span>простых вставок</span></span>, где
число строк известно заранее, и все еще сохраняет детерминированное
выполнение и безопасность для основанной на запросе репликации.</p>

<p>Если Вы не используете двоичный журнал, чтобы переиграть запросы SQL как
часть восстановления или репликации, может использоваться режим блокировки
<a href="#innodb-auto-increment-lock-mode-interleaved">interleaved
</a>, чтобы устранить все использование на уровне таблицы блокировки
<code>AUTO-INC</code> для еще большего параллелизма и работы, за счет
разрешения промежутков в числах auto-increment, назначенных запросом и
потенциально назначением чисел, одновременно выполняемых запросов.</li>

<li><a name="innodb-auto-increment-lock-mode-consecutive"></a>
<code>innodb_autoinc_lock_mode = 1</code>
(режим блокировки <span><span>consecutive</span></span>)</p>

<p>Это режим блокировки значения по умолчанию. В этом режиме
<span><span>bulk-вставки</span></span> используют специальную блокировку
<code>AUTO-INC</code> на уровне таблицы и держат это до конца запроса. Это
относится ко всем запросам <a href="sql.htm#insert-select"><code>INSERT ...
SELECT</code></a>, <a href="sql.htm#replace"><code>REPLACE ... SELECT</code>
</a> и <a href="sql.htm#load-data"><code>LOAD DATA</code></a>.
Только одно запрос, держащий <code>AUTO-INC</code>,
может выполниться за один раз.</p>

<p><span><span>Простые вставки</span></span> (число строк, которые будут
вставлены, известно заранее) избегают на уровне таблицы блокировки
<code>AUTO-INC</code>, получая необходимое число auto-increment
под управлением mutex (легкая блокировка), который проводится только во время
процесса распределения, а не до тех пор, когда запрос завершится.
На уровне таблицы блокировка <code>AUTO-INC</code> не применяется, если
<code>AUTO-INC</code> проводится другой транзакцией. Если другая транзакция
держит <code>AUTO-INC</code> <span><span>простая вставка</span></span>
ждет <code>AUTO-INC</code>, как будто это была
<span><span>bulk-вставка</span></span>.</p>

<p>Этот режим блокировки гарантирует, что в запросе
<a href="sql.htm#insert"><code>INSERT</code></a>, где число строк не известно
заранее (и где числа auto-increment назначены в ходе продвижения запроса),
все значения auto-increment, назначенные любым
<span><span><a href="sql.htm#insert"><code>INSERT</code></a>-подобным</span>
</span> запросом, последовательны, и операции безопасны для основанной
на запросе репликации.</p>

<p>Проще говоря, этот режим блокировки значительно улучшает масштабируемость,
будучи безопасным для использования с основанной на запросе репликацией.
Далее, как с режимом блокировки <span><span>traditional</span></span>, числа
auto-increment, назначенные любым данным запросом,
<span><em>последовательны</em></span>. Нет
<span><em>никакого изменения</em></span> в семантике по сравнению с
режимом <span><span>traditional</span></span> ни для какого запроса, с
одним важным исключением (ну а как же без него!).</p>

<p>Исключение для <span><span>смешанного режима вставки</span></span>,
где пользователь обеспечивает явные значения столбца
<code>AUTO_INCREMENT</code> для некоторых, но не всех, строк в многострочной
<span><span>простой вставке</span></span>. Для таких вставок
<code>InnoDB</code> выделяет больше значений auto-increment,
чем число строк, которые будут вставлены. Однако, все значения, автоматически
назначенные, последовательно произведены (и таким образом выше) значения
auto-increment, произведенного последний раз выполненным предыдущим запросом.
</li>

<li><a name="innodb-auto-increment-lock-mode-interleaved"></a>
<code>innodb_autoinc_lock_mode = 2</code>
(режим блокировки <span><span>interleaved</span></span>)</p>

<p>В этом режиме блокировки никакие
<span><span><a href="sql.htm#insert"><code>INSERT</code></a>-подобные</span>
</span> запросы не используют на уровне таблицы блокировку
<code>AUTO-INC</code>, и многократные запросы могут выполняться в то же
самое время. Это является самым быстрым и масштабируемым режимом блокировки,
но <span><em>не безопасно</em></span>, используя основанную на запросе
репликацию или скрипты восстановления, когда запросы SQL переигрываются
из двоичного журнала.</p>

<p>В этом режиме блокировки значения auto-increment точно
будут уникальны и монотонно увеличивающимися через все одновременно
выполняющиеся <span><span><a href="sql.htm#insert"><code>
INSERT</code></a>-подобные</span></span> запросы.
Однако, потому что многократные запросы могут производить числа в то же самое
время (то есть, распределение чисел <span><em>interleaved</em></span>),
значения, произведенные для строк, вставленных любым данным запросом,
возможно, не последовательны.</p>

<p>Если единственное выполнение запросов <span><span>простая вставка</span>
</span>, где число строк, которые будут вставлены, известно заранее, не будет
никаких промежутков в числах, произведенных для единственного запроса, за
исключением <span><span>смешанного режима вставок</span></span>.
Однако, когда <span><span>bulk-вставки</span></span> выполнены, могут быть
промежутки в значениях, назначенных любым данным запросом.</p></li></ul>

<h4><a name="innodb-auto-increment-lock-mode-usage-implications"></a>
Значения использования режима блокировки AUTO_INCREMENT</h4>
<ul><li><p>Применение auto-increment с репликацией.</p>

<p>Если Вы используете основанную на запросе репликацию, установите
<a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> в 0 или 1 и используйте то же самое
значение на ведущем устройстве и его ведомых устройствах. Значения
не будут теми же самыми на ведомых устройствах, как на ведущем устройстве,
если Вы используете <a href="#sysvar_innodb_autoinc_lock_mode">
<code>innodb_autoinc_lock_mode</code></a> = 2
(<span><span>interleaved</span></span>) или конфигурации, где ведущее
устройство и ведомые устройства не используют тот же самый режим блокировки.
</p>

<p>Если Вы используете репликацию, основанную на строке или
смешанного формата, все режимы блокировки безопасны, так как основанная на
строке репликация не чувствителен к порядку выполнения запросов SQL (и
смешанный формат использует основанную на строке репликацию для любых
запросов, которые опасны для основанной на запросе репликации).</li>

<li><span><span>Потерянные</span></span> значения auto-increment
и промежутки последовательности.</p>
<p>Во всех режимах блокировки (0, 1 и 2), если транзакция, которая произвела
значения, откатывается, те значения <span><span>потеряны</span></span>.
Как только значение произведено для столбца, оно не может быть отменено до
прежнего уровня, действительно ли выполнен
<span><span><a href="sql.htm#insert"><code>INSERT</code></a>-подобный</span>
</span> запрос или отменен. Такие потерянные значения снова не использованы.
Таким образом, могут быть промежутки в значениях, сохраненных в
столбце <code>AUTO_INCREMENT</code> таблицы.</li>

<li>Определение NULL или 0 для столбца <code>AUTO_INCREMENT</code>.</p>
<p>Во всех режимах блокировки (0, 1 и 2), если пользователь определяет
NULL или 0 для столбца <code>AUTO_INCREMENT</code> в
<a href="sql.htm#insert"><code>INSERT</code></a>, <code>InnoDB</code>
обрабатывает строку, как будто значение не было определено и производит новое
значение для нее.</li>

<li>Назначение отрицательной величины столбцу <code>AUTO_INCREMENT</code>.
</p>
<p>Во всех режимах блокировки (0, 1 и 2) не определено поведение механизма
auto-increment, если Вы назначаете отрицательную величину
столбцу <code>AUTO_INCREMENT</code>.</li>

<li>Если значение <code>AUTO_INCREMENT</code> становится больше, чем
максимальное целое число для указанного типа целого числа.</p>
<p>Во всех режимах блокировки (0, 1 и 2) не определено поведение механизма
auto-increment, если значение становится больше, чем максимальное целое
число, которое может быть сохранено в указанном типе целого числа.</li>

<li>Промежутки в значениях для <span><span>bulk-вставок</span></span>.</p>
<p>С опцией <a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> в значении 0 (<span><span>traditional
</span></span>) или 1 (<span><span>consecutive</span></span>) значения
auto-increment, произведенные любым данным запросом, последовательны без
промежутков, потому что на уровне таблицы блокировка <code>AUTO-INC</code>
проводится до конца запроса, и только один такой запрос может выполниться
за один раз.</p>

<p>С опцией <a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> в значении 2 (<span><span>interleaved
</span></span>), могут быть промежутки в значениях, произведенных
<span><span>bulk-вставками</span></span>, но только если там одновременно
выполняются <span><span><a href="sql.htm#insert"><code>
INSERT</code></a>-подобные</span></span> запросы.</p>

<p>Для режимов блокировки 1 или 2 промежутки могут произойти между
последовательными запросами, потому что для bulk-вставок точное число
значений auto-increment, требуемых каждым запросм, возможно, не известно
заранее, и переоценка возможна.</li>

<li>Значения Auto-increment, назначенные
<span><span>смешанным режимом вставок</span></span>.</p>
<p>Полагайте, что <span><span>смешанный режим</span></span>,
определяет значение auto-increment для некоторых (но не всех) получающихся
строк. Такой запрос ведет себя по-другому в режимах блокировки 0, 1 и 2.
Например, предположим, что столбец <code>c1</code>
<code>AUTO_INCREMENT</code> в таблице <code>t1</code>,
и что новый автоматически произведенный порядковый номер 100.
<pre>
mysql&gt; CREATE TABLE t1 (
    -&gt;        c1 INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;        c2 CHAR(1)) ENGINE = INNODB;
mysql&gt; INSERT INTO t1 VALUES(1,'a'),(101,'b'),(5,'c'),(102,'d');
</pre>

<p>Теперь считайте следующее
<span><span>смешанным режимом вставки</span></span>:
<pre>
mysql&gt; INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'), (5,'c'),
                 (NULL,'d');
</pre>

<p>Если <a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> = 0 (<span><span>traditional</span>
</span>), четыре новых строки:
<pre>
mysql&gt; SELECT c1, c2 FROM t1 ORDER BY c2;
+-----+----+
| c1  | c2 |
+-----+----+
|   1 | a  |
| 101 | b  |
|   5 | c  |
| 102 | d  |
+-----+----+
</pre>

<p>Следующее доступное значение 103, потому что значения автоинкремента
выделены по одному, а не все в начале выполнения запроса.
Этот результат верен при выполнении одновременно
<span><span><a href="sql.htm#insert"><code>INSERT</code></a>-подобных</span>
</span> запросов (любого типа).</p>

<p>Если <a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> = 1 (<span><span>consecutive</span>
</span>), четыре новых строки также:
<pre>
mysql&gt; SELECT c1, c2 FROM t1 ORDER BY c2;
+-----+----+
| c1  | c2 |
+-----+----+
|   1 | a  |
| 101 | b  |
|   5 | c  |
| 102 | d  |
+-----+----+
</pre>

<p>Однако, в этом случае, следующее доступное значение 105, не 103, потому
что четыре значения выделены в то время, когда запрос обработан, но только
два используются. Этот результат верен при выполнении одновременно
<span><span><a href="sql.htm#insert"><code>INSERT</code></a>-подобных</span>
</span> запросов (любого типа).</p>

<p>Если <a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> = 2 (<span><span>interleaved</span>
</span>), четыре новых строки:
<pre>
mysql&gt; SELECT c1, c2 FROM t1 ORDER BY c2;
+----+----+
| c1 | c2 |
+----+----+
| 1  | a  |
| <em><code>x</code></em> | b  |
| 5  | c  |
| <em><code>y</code></em> | d  |
+----+----+
</pre>

<p>Значения <em><code>x</code></em> и <em><code>y</code></em>
уникальны и больше, чем любые ранее произведенные строки. Однако,
определенные значения <em><code>x</code></em> и <em><code>y</code></em>
зависят от числа значений auto-increment, произведенных
одновременно выполняемыми запросами.</p>

<p>Наконец, рассмотрите следующий запрос, сделанный, когда последний раз
произведенный порядковый номер был значением 4:
<pre>
mysql&gt; INSERT INTO t1 (c1,c2) VALUES (1,'a'), (NULL,'b'),
                 (5,'c'), (NULL,'d');
</pre>

<p>При любом значении <a href="#sysvar_innodb_autoinc_lock_mode">
<code>innodb_autoinc_lock_mode</code></a> этот запрос производит ошибку
дублирования ключа 23000 (<code>Can't write; duplicate key in table</code>)
потому, что 5 выделено для строки <code>(NULL, 'b')</code> и вставка
строки <code>(5, 'c')</code> терпит неудачу.</li>

<li>Изменение значения столбцов <code>AUTO_INCREMENT</code> в середине
последовательности <a href="sql.htm#insert"><code>INSERT</code></a>.</p>
<p>В MySQL 5.7 и ранее изменение значения столбца <code>AUTO_INCREMENT</code>
в середине последовательности <a href="sql.htm#insert"><code>INSERT</code>
</a> могло привести к ошибке <span><span>Duplicate entry</span></span>.
Например, если Вы запускали <a href="sql.htm#update"><code>UPDATE</code></a>,
которая изменила столбец <code>AUTO_INCREMENT</code> к значению, большему,
чем текущий максимум, последующий
<a href="sql.htm#insert"><code>INSERT</code></a>, который не определял
неиспользованное значение auto-increment, мог столкнуться с ошибкой
<span><span>Duplicate entry</span></span>. В MySQL 8.0 и позже, если Вы
изменяете столбец <code>AUTO_INCREMENT</code>
к значению, больше, чем текущее максимальное значение auto-increment,
новое значение сохранено, и последующие
<a href="sql.htm#insert"><code>INSERT</code></a>
выделяют значения, начиная с нового, большего значения.
Это поведение продемонстрировано в следующем примере.
<pre>
mysql&gt; CREATE TABLE t1 (
    -&gt;        c1 INT NOT NULL AUTO_INCREMENT,
    -&gt;        PRIMARY KEY (c1)) ENGINE = InnoDB;

mysql&gt; INSERT INTO t1 VALUES(0), (0), (3);
mysql&gt; SELECT c1 FROM t1;
+----+
| c1 |
+----+
|  1 |
|  2 |
|  3 |
+----+

mysql&gt; UPDATE t1 SET c1 = 4 WHERE c1 = 1;
mysql&gt; SELECT c1 FROM t1;
+----+
| c1 |
+----+
|  2 |
|  3 |
|  4 |
+----+

mysql&gt; INSERT INTO t1 VALUES(0);
mysql&gt; SELECT c1 FROM t1;
+----+
| c1 |
+----+
|  2 |
|  3 |
|  4 |
|  5 |
+----+
</pre></li></ul>

<h4><a name="innodb-auto-increment-initialization"></a>
Инициализация счетчика InnoDB AUTO_INCREMENT</h4>
<p>Этот раздел описывает как <code>InnoDB</code> инициализирует
счетчики <code>AUTO_INCREMENT</code>.</p>

<p>Если Вы определяете столбец <code>AUTO_INCREMENT</code> для
таблица, табличный объект в памяти содержит специальный счетчик, названный
счетчиком auto-increment, который используется, назначая новые
значения для столбца.</p>

<p>В MySQL 5.7 и ранее счетчик автоинкремента сохранен только в основной
памяти, не на диске. Инициализируя счетчик автоинкремента после
перезапуска сервера, <code>InnoDB</code> выполнил бы эквивалент следующего
запроса о первой вставке в таблицу, содержащую столбец
<code>AUTO_INCREMENT</code>.
<pre>
SELECT MAX(ai_col) FROM <em><code>table_name</code></em> FOR UPDATE;
</pre>

<p>В MySQL 8.0 это не так. Текущее максимальное значение счетчика написано
в журнал redo каждый раз, когда это изменяется и сохранено в приватной
системной таблице механизма на каждой контрольной точке. Эти изменения делают
текущее максимальное значение счетчика постоянным через перезапуски сервера.
</p>

<p>При перезапуске сервера после нормального завершения работы
<code>InnoDB</code> инициализирует счетчик в памяти с использованием
текущего максимального значения, сохраненного в системной
таблице словаря данных.</p>

<p>При перезапуске во время восстановления катастрофического отказа
<code>InnoDB</code> инициализирует счетчик в памяти с использованием
текущего максимального значения, сохраненного в системной таблице словаря
данных, и просматривает журнал redo для значений счетчика, записанных,
начиная с последней контрольной точки. Если зарегистрированное значение
больше, чем встречное значение в памяти, зарегистрированное значение
применено. Однако, в случае катастрофического отказа сервера, повторное
использование ранее выделенного значения не может быть гарантировано. Каждый
раз, когда текущее максимальное значение изменено из-за
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>, новое значение записано в
журнал, но если катастрофический отказ происходит прежде, чем журнал
сброшен на диск, ранее выделенное значение могло быть снова использовано,
когда счетчик инициализирован после того, как сервер перезапущен.</p>

<p>Единственное обстоятельство, когда <code>InnoDB</code> использует
эквивалент <code>SELECT MAX(ai_col)
FROM <em><code>table_name</code></em> FOR UPDATE</code> в MySQL 8.0, это
инициализируя счетчик, <a href="#tablespace-copying">импортируя
табличное пространство</a> без файла метаданных <code>.cfg</code>.
Иначе текущее максимальное значение счетчика считано из
файла метаданных <code>.cfg</code>.</p>

<p>В MySQL 5.7 и ранее, перезапуск сервера отменяет эффект опции
<code>AUTO_INCREMENT = N</code>, которая может использоваться в
<code>CREATE TABLE</code> или <code>ALTER TABLE</code>, чтобы установить
начальное значение или изменить существующее значение, соответственно.
В MySQL 8.0 перезапуск сервера не отменяет эффект <code>AUTO_INCREMENT=N
</code>. Если Вы инициализируете автоинкремент в противоречии с определенным
значением, или если Вы изменяете счетчик к большему значению, новое значение
сохранено через перезапуски сервера.</p>

<p><a href="sql.htm#alter-table"><code>ALTER TABLE ... AUTO_INCREMENT = N
</code></a> может изменить счетчик только к
значению больше, чем текущий максимум.</p>

<p>В MySQL 5.7 и ранее перезапуск сервера немедленно после
a <a href="sql.htm#commit"><code>ROLLBACK</code></a>
мог привести к повторному использованию значений автоинкремента, которые были
ранее выделены отмененной транзакции, эффективно понижая текущее максимальное
значение автоинкремента до прежнего уровня. В MySQL 8.0, текущее максимальное
значение сохранено, предотвращая повторное использование
ранее выделенных значений.</p>

<p>Если <a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS</code>
</a> исследует таблицу прежде, чем счетчик будет инициализирован,
<code>InnoDB</code> открывает таблицу и инициализирует значение, используя
текущее максимальное значение автоинкремента, которое сохранено в системной
таблице словаря данных. Значение сохранено в памяти для использования позже.
Инициализация встречного значения использует нормальное исключительно
блокирующее чтение на таблице, которое длится до конца транзакции.
<code>InnoDB</code> следует за той же самой процедурой, инициализируя счетчик
автоинкремента для недавно составленной таблицы, у которой есть определенное
пользователем значение, которое больше 0.</p>

<p>После того, как счетчик инициализирован, если Вы явно не определяете
значение автоинкремента, вставляя строку, <code>InnoDB</code> неявно
постепенно увеличивает счетчик и назначает новое значение столбцу. Если Вы
вставляете строку, которая явно определяет значение столбца auto-increment,
и значение больше, чем текущее максимальное значение, счетчик
установлен в указанное значение.</p>

<p><code>InnoDB</code> использует счетчик auto-increment
в памяти пока выполняется сервер. Когда сервер остановлен и перезапущен,
<code>InnoDB</code> повторно инициализирует счетчик, как описано ранее.</p>

<p>Опция <a href="replica.htm#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a> определяет начальную точку для значения
<code>AUTO_INCREMENT</code>. Настройка по умолчанию 1.</p>

<p>Опция <a href="replica.htm#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a> управляет интервалом между
последовательными значениями столбцов. Настройка по умолчанию 1.</p>

<h3><a name="innodb-foreign-key-constraints"></a>16.8.6.
InnoDB и ограничения FOREIGN KEY</h3>
<p>Этот раздел описывает различия в обработке механизма хранения InnoDB
внешних ключей по сравнению с MySQL Server.</p>
<p>Для информации об использовании внешнего ключа и примеров см.
<a href="sql.htm#create-table-foreign-keys">раздел 14.1.15.3</a>.</p>

<h4><a name="idm139965326159168"></a>Определения внешнего ключа</h4>
<p>Определения внешнего ключа для <code>InnoDB</code> таблицы
подвергаются следующим условиям:</p>

<ul><li><p><code>InnoDB</code> разрешает внешнему ключу ссылаться на любой
индексный столбец или группу столбцов. Однако, в таблице, на которую
ссылаются, должно быть индексирование, где столбцы, на которые ссылаются,
перечислены как <span><em>первые</em></span> столбцы в том же самом порядке.
</li>

<li><a href="innodb.htm"><code>InnoDB</code></a> в настоящее время не
поддерживает внешние ключи для таблиц с определяемым пользователем
разделением. Это означает что не разделенная пользователем таблица
может содержать ссылки внешнего ключа или столбцы, на которые
ссылаются внешние ключи.</li>

<li><code>InnoDB</code> позволяет ограничению внешнего ключа ссылаться на
групповой ключ. <span><em>Это расширение <code>InnoDB</code>
стандартного SQL.</em></span></p></li></ul>

<h4><a name="idm139965326149136"></a>Ссылочные действия</h4>
<p>Ссылочные действия для внешних ключей таблицы <code>InnoDB</code>
подвергаются следующим условиям:</p>

<ul><li><p>В то время, как <code>SET DEFAULT</code> позволен MySQL Server,
это отклонено как недопустимое <code>InnoDB</code>.
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
использующие этот пункт, не позволены на таблицах InnoDB.</li>

<li>Если есть несколько строк в родительской таблице, у которых есть то же
самое значение ключа, на которое ссылаются, <code>InnoDB</code>
во внешнем ключе проверяет, как будто другие родительские строки с тем же
самым значением ключа не существуют. Например, если Вы определили ограничение
<code>RESTRICT</code> и есть дочерняя строка с несколькими родительскими
строками, <code>InnoDB</code> не разрешает удаление любой из
тех родительских строк.</li>

<li><code>InnoDB</code> выполняет располагающиеся каскадом операции через
алгоритм depth-first, основанный на записях в индексах, соответствующих
ограничениям внешнего ключа.</li>

<li>Если <code>ON UPDATE CASCADE</code> или <code>ON UPDATE SET NULL</code>
рекурсивны, чтобы обновить <span><em>ту же самую таблицу</em></span>, которую
это ранее обновило во время каскада, это действует как <code>RESTRICT</code>.
Это означает, что Вы не можете использовать самоссылочные операции
<code>ON UPDATE CASCADE</code> или <code>ON UPDATE SET NULL</code>.
Это должно предотвратить бесконечные петли, следующие из каскадных
обновлений. Самоссылочная <code>ON DELETE SET NULL</code>,
с другой стороны, возможна, как самоссылочная <code>ON DELETE CASCADE</code>.
Расположение каскадом операций не может быть вложено больше,
чем на 15 уровней.</li>

<li>Как MySQL вообще, в запросе SQL который вставляет, удаляет или обновляет
много строк, <code>InnoDB</code> проверяет ограничения
<code>UNIQUE</code> и <code>FOREIGN KEY</code> построчно.
Выполняя проверки внешнего ключа, <code>InnoDB</code> ставит
совместно используемые блокировки на уровне строки на дочерних или
родительских записях, на которые это должно смотреть. <code>InnoDB</code>
проверяет ограничения внешнего ключа немедленно, проверка не задержана до
закрытия транзакции. Согласно стандарту SQL, поведение значения по умолчанию
должно быть задержано, проверяя. Таким образом, ограничения проверены только
после того, как <span><em>весь запрос SQL</em></span> было обработан. Пока
<code>InnoDB</code> задерживает проверку ограничения, некоторые вещи
невозможны, например, удаление записи, которая обращается к себе,
используя внешний ключ.</p></li></ul>

<h4><a name="idm139965326124192"></a>Ограничения внешнего ключа для
произведенных столбцов и виртуальных индексов</h4>
<ul><li><p>Ограничение внешнего ключа на
<a href="glossary.htm#glos_generated_stored_column">
произведенный сохраненный столбец</a> не может использовать <code>ON UPDATE
CASCADE</code>, <code>ON DELETE SET NULL</code>, <code>ON UPDATE SET
NULL</code>, <code>ON DELETE SET DEFAULT</code> или
<code>ON UPDATE SET DEFAULT</code>.</li>

<li>Ограничение внешнего ключа не может сослаться на
<a href="glossary.htm#glos_generated_virtual_column">
произведенный виртуальный столбец</a>.</li>
<li>До MySQL 8.0.1 ограничение внешнего ключа не может сослаться на
вторичный индекс, определенный на произведенном виртуальном столбце.
</p></li></ul>

<h4><a name="idm139965326114912"></a>Использование внешнего ключа и
информация об ошибке</h4>
<p>Вы можете получить общую информацию о внешних ключах и их использовании,
запрашивая таблицу <a href="inform.htm#key-column-usage-table"><code>
INFORMATION_SCHEMA.KEY_COLUMN_USAGE</code></a>,
больше информации, более определенной для таблиц <code>InnoDB</code>,
может быть найдено в таблицах
<a href="inform.htm#innodb-sys-foreign-table"><code>INNODB_SYS_FOREIGN</code>
</a> и <a href="inform.htm#innodb-sys-foreign-cols-table"><code>
INNODB_SYS_FOREIGN_COLS</code></a> базы
данных <code>INFORMATION_SCHEMA</code>.</p>

<p>В дополнение к <a href="sql.htm#show-errors"><code>SHOW ERRORS</code></a>,
в случае ошибочного вовлечения внешнего ключа таблицами <code>InnoDB</code>
(обычно Error 150 в MySQL Server), Вы можете получить подробное объяснение
ошибки внешнего ключа, проверяя вывод
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.</p>

<h3><a name="innodb-restrictions"></a>16.8.7. Пределы на таблицах InnoDB</h3>
<p>Это не хорошая идея сконфигурировать <code>InnoDB</code>, чтобы
использовать файлы с данными или файлы системного журнала на томах NFS.
Файлы могли бы быть заблокированы другими процессами и становиться
недоступными к использованию MySQL.</p>

<h4><a name="idm139965326093552"></a>Максимумы и минимумы</h4>
<ul><li><p>Таблица может содержать максимум 1017 столбцов. Виртуальные
произведенные столбцы включены в этот предел.</li>

<li>Таблица может содержать максимум 64
<a href="glossary.htm#glos_secondary_index">вторичных индекса</a>.</li>
<li>Предел длины префикса ключа 3072 байт для таблиц с форматом строк
<code><a href="glossary.htm#glos_dynamic_row_format">DYNAMIC</a></code> или
<code><a href="glossary.htm#glos_compressed_row_format">COMPRESSED</a>
</code>.</p>

<p>Предел длины префикса ключа 767 байт для таблиц с форматом строк
<code><a href="glossary.htm#glos_redundant_row_format">REDUNDANT</a></code>
или <code><a href="glossary.htm#glos_compact_row_format">COMPACT</a></code>.
Например, Вы могли бы упереться в этот лимит с
<a href="glossary.htm#glos_column_prefix">префиксом столбца</a> индекса
больше, чем 191 символ на столбцах <code>TEXT</code> или <code>VARCHAR
</code>, принимая набор символов <code>utf8mb4</code>
и максимум 4 байта для каждого символа.</p>

<p>Попытка использовать длину префикса ключа, которая превышает
предел, возвращает ошибку.</p>
<p>Пределы, которые применяются, чтобы индексировать ключевые префиксы,
также относятся к индексным ключам полного столбца.</li>

<li>Если Вы уменьшаете
<a href="glossary.htm#glos_page_size">размер страницы</a> до 8KB или 4KB,
определяя <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a>, создавая сервер MySQL, максимальная длина
индексного ключа понижена пропорционально, основываясь на пределе 3072 байта
для размера страницы 16 КБ. Таким образом, максимум длины ключа 1536 байтов,
когда размер страницы составляет 8 КБ, и 768 байтов, когда размер
страницы составляет 4 КБ.</li>

<li>Максимум 16 столбцов разрешено для столбцового индекса.
Превышение предела возвращает ошибку.
<pre>
ERROR 1070 (42000): Too many key parts specified; max 16 parts allowed
</pre></li>

<li>Максимальная длина строки, за исключением столбцов переменной длины
(<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>),
немного меньше, чем половина страницы для размеров страницы 4 КБ, 8 КБ,
16 КБ и 32 КБ. Например, максимальная длина строки для значения по умолчанию
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> 16KB составляет около 8000 байт. Для размер страницы 64 КБ максимальная
длина строки составляет приблизительно 16000 байт. Столбцы
<a href="types.htm#blob"><code>LONGBLOB</code></a> и
<a href="types.htm#blob"><code>LONGTEXT</code></a>
должны быть меньше 4 ГБ, и суммарная длина строки, включая столбцы
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>, должна быть меньше 4GB.</p>

<p>Если строка меньше чем половина страницы длиной, все это сохранено в
местном масштабе в пределах страницы. Если это превышает половину страницы,
столбцы переменной длины выбраны для внешнего хранения вне страницы, как
описано в <a href="#innodb-file-space">разделе 16.11.2</a>.</li>

<li>Хотя <code>InnoDB</code> допускает размеры строки больше 65535
байтов внутренне, сам MySQL налагает предел размера строки 65 535 для
объединенного размера всех столбцов:
<pre>
mysql&gt; CREATE TABLE t (a VARCHAR(8000), b VARCHAR(10000),
    -&gt;        c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),
    -&gt;        f VARCHAR(10000), g VARCHAR(10000)) ENGINE=InnoDB;
ERROR 1118 (42000): Row size too large. The maximum row size for the
used table type, not counting BLOBs, is 65535. You have to change some
columns to TEXT or BLOBs
</pre>
<p>См. <a href="restr.htm#column-count-limit">раздел C.10.4</a>.</li>

<li>На некоторых старых операционных системах файлы должны быть меньше
2GB. Это не ограничение <code>InnoDB</code> непосредственно, но если Вы
требуете большого табличного пространства, конфигурируйте это, используя
несколько меньших файлов с данными, а не один большой.</li>

<li>Объединенный размер файлов системного журнала может быть до 512 ГБ.</li>
<li>Минимальный размер табличного пространства немного больше 10MB.
Максимальный размер табличного пространства составляет четыре миллиарда
страниц (64TB). Это также максимальный размер для таблицы.</li>

<li>Размер страницы по умолчанию в <code>InnoDB</code> 16 КБ. Вы можете
увеличить или уменьшить размер страницы, конфигурируя опцию
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> при установке MySQL.</p>

<p>Размеры страницы 32KB и 64KB поддержаны, но
<code>ROW_FORMAT=COMPRESSED</code> не поддержан для размеров страницы больше
16 КБ. Для размеров страницы 32 КБ и 64 КБ максимальный размер записи
составляет 16 КБ. Для <a href="#sysvar_innodb_page_size"><code>
innodb_page_size=32k</code></a> размер экстента 2MB. Для
<a href="#sysvar_innodb_page_size"><code>innodb_page_size=64k
</code></a> размер экстента 4MB.</p>

<p>MySQL, используя некий размер страницы не может использовать файлы с
данными или файлы системного журнала от экземпляра, который использует
иной размер страницы.</p></li></ul>

<h4><a name="idm139965326036224"></a>Ограничения на таблицы InnoDB</h4>
<ul><li><p><a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
определяет количество элементов индекса (как выведено на экран в столбце
<code>Cardinality</code> вывода <a href="sql.htm#show-index"><code>SHOW INDEX
</code></a>), делая <a href="glossary.htm#glos_random_dive">случайные
погружения</a> к каждому из индексных деревьев и обновляя индексные оценки
количества элементов соответственно. Поскольку это только оценки, повторные
выполнения <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
могут произвести различные числа. Это делает
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> быстрым на
<code>InnoDB</code>, но не 100% точным, потому что это не принимает все
строки во внимание.</p>

<p>Вы можете сделать сбор
<a href="glossary.htm#glos_statistics">статистики</a>
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
более точным и устойчивым, включая опцию
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a>, как описано в
<a href="#innodb-persistent-stats">разделе 16.6.10.1</a>.
Когда эта установка включена, важно выполнить
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
после существенных изменений индексированных данных в столбце, потому что
статистические данные не вычисляются повторно периодически
(как после перезапуска сервера).</p>

<p>Вы можете изменить число случайных погружений, изменяя переменную
<a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a>
(если постоянная установка статистики включена) или
<a href="#sysvar_innodb_stats_transient_sample_pages"><code>
innodb_stats_transient_sample_pages</code></a>
(если постоянная установка статистики выключена).</p>

<p>MySQL использует оценки количества элементов только в оптимизации
соединения. Если некоторое соединение не оптимизировано правильным способом,
Вы можете попытаться использовать <a href="sql.htm#analyze-table"><code>
ANALYZE TABLE</code></a>. В немногих случаях это
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
не производит значения, достаточно хорошие для Ваших особых таблиц, Вы можете
использовать <code>FORCE INDEX</code> с Вашими запросами, чтобы вызвать
использование индекса или установить
<a href="server.htm#sysvar_max_seeks_for_key"><code>max_seeks_for_key</code>
</a>, чтобы гарантировать, что MySQL предпочитает, индексные поиски
сканированию таблицы. См. разделы
<a href="server.htm#server-system-variables">6.1.5</a> и
<a href="error.htm#optimizer-issues">B.5.5</a>.</li>

<li>Если запрос или транзакции работают на таблице и
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
выполнен на той же самой таблице, сопровождаемый вторым
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>, второй вызов
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
заблокирован, пока запрос или транзакции не завершены. Это поведение
происходит потому, что <a href="sql.htm#analyze-table"><code>ANALYZE
TABLE</code></a> отмечает в настоящее время загружаемое табличное определение
как устаревшее, когда <a href="sql.htm#analyze-table"><code>ANALYZE TABLE
</code></a> закончен. Новые запросы или транзакции (включая второй
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>)
должен загрузить новое табличное определение в табличный кэш, что не может
произойти, пока в настоящее время рабочие запросы или транзакции не
завершены, и старое табличное определение не очищено.
Загрузка многократных параллельных табличных определений не поддержана.</li>

<li><a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS</code></a>
не дает точную статистику по таблицам <code>InnoDB</code>, за исключением
физического места, зарезервированного таблицей. Количество строки только
грубая оценка, используемая в оптимизации SQL.</li>

<li><code>InnoDB</code> не проводит внутренний подсчет строк в таблице,
потому что параллельные транзакции могли бы
<span><span>видеть</span></span> различные числа строк в то же самое время.
Следовательно, <code>SELECT COUNT(*) FROM t</code>
считает только строки, видимые текущей транзакции.</p>

<p>Чтобы выполнить <code>SELECT COUNT(*) FROM t</code>, <code>InnoDB</code>
кластерный индекс, что занимает время, если записи индекса не находятся
полностью в буферном пуле. Для более быстрого счета Вы можете составить
таблицу счетчиков и позволить Вашему приложению обновлять ее, согласно
вставкам и удалениям. Однако, этот метод, возможно, не масштабируется хорошо
в ситуациях, где тысячи параллельных транзакций начинают обновления той же
самой таблицы. Если приблизительное количество строки достаточно, может
использоваться <a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS
</code></a>.</p>

<p><code>SELECT COUNT(*) FROM t</code> вызывает единственный вызов
обработчика механизма хранения, чтобы просмотреть кластеризируемый индекс
и возвращает количество строк. Эта оптимизация очевидна в выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a> для
<code>SELECT COUNT(*) FROM t</code>, который сообщает
<code>Select tables optimized away</code>:
<pre>
mysql&gt; EXPLAIN SELECT COUNT(*) FROM t1\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: NULL
   partitions: NULL
 type: NULL
possible_keys: NULL
key: NULL
  key_len: NULL
ref: NULL
 rows: NULL
 filtered: NULL
Extra: Select tables optimized away
</pre></li>

<li>Столбец <code>AUTO_INCREMENT</code> <em><code>ai_col</code></em>
должен быть определен как часть индексирования таким образом, что возможно
выполнить эквивалент индексного <code>SELECT MAX(<em><code>ai_col</code>
</em>)</code> поиска на таблице, чтобы получить максимальное значение
столбца. Как правило, это достигнуто, делая столбец первым столбцом
индекса некоторой таблицы.</li>

<li><code>InnoDB</code> устанавливает исключительную блокировку на конце
индексирования, связанного со столбцом <code>AUTO_INCREMENT</code>,
инициализируя ранее указанный столбец <code>AUTO_INCREMENT</code> таблицы.
</p>

<p>С <a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode=0</code></a> <code>InnoDB</code> использует
специальный режим блокировки таблицы <code>AUTO-INC</code>, где блокировка
получена и проведена до конца текущего запроса SQL, получая доступ к счетчику
auto-increment. Другие клиенты не могут вставить в таблицу в то время, как
табличная блокировка <code>AUTO-INC</code> проводится.
То же самое поведение происходит для <span><span>bulk-вставок</span></span> с
<a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode=1</code></a>. На уровне таблицы блокировки
<code>AUTO-INC</code> не используются с
<a href="#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode=2</code></a>. Подробности в
<a href="#innodb-auto-increment-handling">разделе 16.8.5</a>.</li>

<li>Когда столбец целого числа <code>AUTO_INCREMENT</code>
исчерпывает значения, последующий <code>INSERT</code>
возвращает  ошибку дубликата ключа. Это общее поведение
MySQL, подобное <code>MyISAM</code>.</li>

<li><code>DELETE FROM <em><code>tbl_name</code></em></code>
не восстанавливает таблицу, но вместо этого удаляет все строки поштучно.</li>
<li>Каскадные действия внешнего ключа не активируют триггеры.</li>

<li>Вы не можете составить таблицу с именем столбца, которое соответствует
названию внутреннего столбца <code>InnoDB</code> (включая
<code>DB_ROW_ID</code>, <code>DB_TRX_ID</code>, <code>DB_ROLL_PTR</code>,
и <code>DB_MIX_ID</code>). Это ограничение применяется к использованию
имен в любом регистре.
<pre>
mysql&gt; CREATE TABLE t1 (c1 INT, db_row_id INT) ENGINE=INNODB;
ERROR 1166 (42000): Incorrect column name 'db_row_id'
</pre></li></ul>

<h4><a name="idm139965325958112"></a>Блокировка и транзакции</h4>
<ul><li><p><a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a>
приобретает две блокировки на каждой таблице, если
<code>innodb_table_locks=1</code> (значение по умолчанию). В дополнение к
табличному уровню MySQL, это также приобретает табличную блокировку
<code>InnoDB</code>. MySQL до 4.1.2 не приобретал табличную блокировку
<code>InnoDB</code>, старое поведение может быть выбрано, устанавливая
<code>innodb_table_locks=0</code>. Если табличная блокировка
<code>InnoDB</code> не приобретена,
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a>
завершается, даже если некоторые записи таблиц
блокируются другими транзакциями.</p>

<p>В MySQL 8.0 <a href="#sysvar_innodb_table_locks"><code>
innodb_table_locks=0</code></a> не имеет никакого эффекта для таблиц,
заблокированных явно с <a href="sql.htm#lock-tables"><code>LOCK TABLES ...
WRITE</code></a>. Это действительно имеет эффект для таблиц, заблокированных
для чтения или записи через <a href="sql.htm#lock-tables"><code>LOCK TABLES
... WRITE</code></a> неявно (например, через триггеры) или
<a href="sql.htm#lock-tables"><code>LOCK TABLES ... READ</code></a>.</li>

<li>Все блокировки, проводимые транзакцией, выпущены, когда транзакция
передана или прервана. Таким образом, не имеет большого смысла вызывать
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a> на таблицах
<code>InnoDB</code> в режиме <a href="server.htm#sysvar_autocommit"><code>
autocommit=1</code></a> потому что приобретенные табличные блокировки были
бы немедленно выпущены.</li>

<li>Вы не можете заблокировать дополнительные таблицы в середине транзакции
потому, что <a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a>
выполняет неявные <a href="sql.htm#commit"><code>COMMIT</code></a> и
<a href="sql.htm#lock-tables"><code>UNLOCK TABLES</code></a>.</li>

<li>Предел на изменяющие данные транзакции 96 * 1023
параллельных транзакции, которые производят записи отмены. 32 из 128
сегментов отмены назначены не-redo журналам для транзакций, которые изменяют
временные таблицы и связанные объекты. Это означает, что максимальное
количество параллельных изменяющих данные транзакций составляет 96K.
Предел 96K предполагает, что транзакции не изменяют временные таблицы. Если
все изменяющие данные транзакции также изменяют временные таблицы, предел
составляет 32K параллельных транзакций.</p></li></ul>

<h3><a name="innodb-index-types"></a>16.8.8.
Кластеризируемый и вторичный индексы</h3>
<p>У каждой таблицы <code>InnoDB</code> есть специальный
<a href="glossary.htm#glos_clustered_index">кластеризируемый индекс</a>,
где данные для строк хранятся. Как правило, кластеризируемый индекс
синонимичен с <a href="glossary.htm#glos_primary_key">первичным ключом</a>.
Чтобы получить лучшую работу от запросов, вставок и других операций базы
данных, Вы должны понять, как использовать кластеризируемый индекс, чтобы
оптимизировать наиболее распространенный поиск и операции DML
для каждой таблицы.</p>

<ul><li><p>Когда Вы определяете <code>PRIMARY KEY</code>
на Вашей таблице, <code>InnoDB</code> использует это как кластеризируемый
индекс. Определите первичный ключ для каждой таблицы, которую Вы составляете.
Если нет никакого логического уникального и ненулевого столбца или набора
столбцов, добавьте новый столбец <a href="glossary.htm#glos_auto_increment">
auto-increment</a>, значения которого заполнены автоматически.</li>

<li>Если Вы не определяете <code>PRIMARY KEY</code>
для Вашей таблицы MySQL определяет местонахождение первого индекса
<code>UNIQUE</code>, где все ключевые столбцы <code>NOT NULL</code> и
использует это как кластеризируемый индекс.</li>

<li>Если таблица не имеет <code>PRIMARY KEY</code> или подходящий индекс
<code>UNIQUE</code>, <code>InnoDB</code> внутренне производит
кластеризируемый скрытый индекс на синтетическом столбце, содержащем значения
идентификаторов строки. Строки упорядочены по ID, которые <code>InnoDB</code>
назначает строкам в такой таблице. ID строки 6-байтовая область, которая
увеличивается монотонно, когда новые строки вставлены. Таким образом, строки,
упорядоченные ID строки, находятся физически в порядке вставки.</p></li></ul>

<h4><a name="idm139965325910688"></a>
Как кластеризируемый индекс ускоряет запросы</h4>
<p>Доступ к строке через кластеризируемый индекс быстр, потому что поиск
приводит непосредственно к странице со всеми данными о строке.
Если таблица является большой, кластеризируемый индекс
часто уменьшает дисковую нагрузку ввода/вывода по сравнению с организациями
хранения, которые хранят данные о строке, используя иную страницу для
индексной записи. Например, <code>MyISAM</code> использует один файл для
строк данных и другой для индексных записей.</p>

<h4><a name="idm139965325908400"></a>
Как вторичный индекс связан с кластеризируемым</h4>
<p>Все индексирует кроме кластеризируемого известны как
<a href="glossary.htm#glos_secondary_index">вторичные</a>. В
<code>InnoDB</code> каждая запись во вторичном индексе содержит столбцы
первичного ключа для строки, так же как столбцы, определенные для вторичного
индекса. <code>InnoDB</code> применяет это значение первичного ключа, чтобы
искать строку в кластеризируемом индексе.</p>

<p>Если первичный ключ длинен, вторичные индексы
используют больше пространства, таким образом, выгодно иметь
короткий первичный ключ.</p>

<p>См. подробности в разделах
<a href="optimiz.htm#optimizing-primary-keys">9.3.2</a>,
<a href="optimiz.htm#optimization-indexes">9.3</a>,
<a href="optimiz.htm#optimizing-innodb">9.5</a> и
<a href="optimiz.htm#optimizing-primary-keys">9.3.2</a>.</p>

<h3><a name="innodb-fulltext-index"></a>16.8.9. Индексы InnoDB FULLTEXT</h3>
<p>Индексы <code>FULLTEXT</code> создаются на основанных на тексте столбцах
(<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>), чтобы
ускорить запросы и операции DML на данных в пределах тех столбцов, опуская
любые слова, которые определены как stopword.</p>

<p>Индекс <code>FULLTEXT</code> может быть определен как часть
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
или добавлен позже с использованием
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> или
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a>.</p>

<p>Полнотекстовый поиск выполнен, используя
<a href="funct.htm#function_match"><code>MATCH() ... AGAINST</code></a>.
Подробности в <a href="funct.htm#fulltext-search">разделе 13.9</a>.</p>

<h4><a name="idm139965325883920"></a>Проект индекса Full-Text</h4>
<p>Индексы <code>InnoDB</code> <code>FULLTEXT</code> имеют проект
инвертированного индекса. Инвертированные индексы хранят список слов, и для
каждого слова, список документов, в которых появляется слово. Чтобы
поддержать поиск близости, информация о положении для каждого слова также
сохранена, как смещение байта.</p>

<h4><a name="idm139965325881184"></a>Таблицы полнотекстового индекса</h4>
<p>Для каждого индекса <code>FULLTEXT</code> ряд индексных таблиц создается,
как показано в следующем примере:
<pre>
CREATE TABLE opening_lines (id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY
       KEY, opening_line TEXT(500), author VARCHAR(200),
       title VARCHAR(200), FULLTEXT idx (opening_line)) ENGINE=InnoDB;

mysql&gt; SELECT table_id, name, space from
                 INFORMATION_SCHEMA.INNODB_SYS_TABLES
                 WHERE name LIKE 'test/%';
+----------+----------------------------------------------------+-------+
| table_id | name                                               | space |
+----------+----------------------------------------------------+-------+
|  333     | test/FTS_0000000000000147_00000000000001c9_INDEX_1 |   289 |
|  334     | test/FTS_0000000000000147_00000000000001c9_INDEX_2 |   290 |
|  335     | test/FTS_0000000000000147_00000000000001c9_INDEX_3 |   291 |
|  336     | test/FTS_0000000000000147_00000000000001c9_INDEX_4 |   292 |
|  337     | test/FTS_0000000000000147_00000000000001c9_INDEX_5 |   293 |
|  338     | test/FTS_0000000000000147_00000000000001c9_INDEX_6 |   294 |
|  330     | test/FTS_0000000000000147_BEING_DELETED            |   286 |
|  331     | test/FTS_0000000000000147_BEING_DELETED_CACHE      |   287 |
|  332     | test/FTS_0000000000000147_CONFIG                   |   288 |
|  328     | test/FTS_0000000000000147_DELETED                  |   284 |
|  329     | test/FTS_0000000000000147_DELETED_CACHE            |   285 |
|  327     | test/opening_lines                                 |   283 |
+----------+----------------------------------------------------+-------+
</pre>

<p>Первые шесть таблиц представляют инвертированный индекс и упоминаются,
как вспомогательные индексные таблицы. Когда поступающие документы размечены,
отдельные слова (также называемые <span><span>токенами</span></span>)
вставлены в индексные таблицы наряду с информацией о положении и связанным
Document ID (<code>DOC_ID</code>). Слова полностью сортированы и разделены
среди этих шести индексных таблиц, основываясь на весе вида набора символов
первого символа слова.</p>

<p>Инвертированный индекс разделен на шесть вспомогательных
индексных таблицы, чтобы поддержать параллельное создание индексов.
По умолчанию два потока размечают, сортируют и вставляют слова и связанные
данные в таблицы. Число потоков конфигурируемое с использованием опции
<a href="#sysvar_innodb_ft_sort_pll_degree"><code>
innodb_ft_sort_pll_degree</code></a>. Создавая <code>FULLTEXT</code> на
больших таблицах, рассмотрите увеличивание числа потоков.</p>

<p>Имена таблиц предварительно установлены с префиксом
<code>FTS_</code> и постфиксом <code>INDEX_*</code>.
Каждая таблица связана с индексированной таблицей значением
в имени индексной таблицы, которое соответствует <code>table_id</code>
индексированной таблицы. Например, <code>table_id</code> из
<code>test/opening_lines</code> <code>327</code> для которого
шестнадцатеричное значение 0x147. Как показано в предыдущем примере,
<span><span>147</span></span> появляется в названиях индексных таблиц,
которые связаны с <code>test/opening_lines</code>.</p>

<p>Значение представляющее <code>index_id</code> индекса
<code>FULLTEXT</code> также появляется в именах вспомогательных индексных
таблиц. Например, во вспомогательном имени таблицы
<code>test/FTS_0000000000000147_00000000000001c9_INDEX_1</code> это
<code>1c9</code>, в десятичном виде 457. Индекс определен в таблице
<code>opening_lines</code> (<code>idx</code>) и может быть идентифицирован,
запрашивая из таблицы <a href="inform.htm#innodb-sys-indexes-table">
<code>INFORMATION_SCHEMA.INNODB_SYS_INDEXES</code></a> его значение (457).
<pre>
mysql&gt; SELECT index_id, name, table_id, space
                 from INFORMATION_SCHEMA.INNODB_SYS_INDEXES
                 WHERE index_id=457;
+----------+------+----------+-------+
| index_id | name | table_id | space |
+----------+------+----------+-------+
|  457     | idx  |  327     |   283 |
+----------+------+----------+-------+
</pre>

<p>Индексные таблицы сохранены в их собственном табличном пространстве, если
основная таблица составлена в табличном пространстве file-per-table.</p>
<p>Другие индексные таблицы, показанные в предыдущем примере, используются
для обработки удаления и для того, чтобы сохранить внутреннее
состояние индекса <code>FULLTEXT</code>.</p>

<ul><li><p><code>FTS_*_DELETED</code> и <code>FTS_*_DELETED_CACHE</code>:
Хранят ID (DOC_ID) для документов, которые удалены, но чьи данные еще не
удалены из полнотекстового индекса. <code>FTS_*_DELETED_CACHE</code>
версия в памяти для <code>FTS_*_DELETED</code>.</li>

<li><code>FTS_*_BEING_DELETED</code> и <code>FTS_*_BEING_DELETED_CACHE
</code>: Хранят ID (DOC_ID) для документов, которые удалены, но чьи данные
в настоящее время находятся в процессе того, чтобы быть удаленными
из полнотекстового индекса. <code>FTS_*_BEING_DELETED_CACHE</code>
версия в памяти для <code>FTS_*_BEING_DELETED</code>.</li>

<li><code>FTS_*_CONFIG</code>: Хранит информацию о внутреннем состоянии
индекса <code>FULLTEXT</code>. Что наиболее важно, это хранит
<code>FTS_SYNCED_DOC_ID</code>, который идентифицирует документы, которые
были разобраны и сброшены на диск. В случае восстановления катастрофического
отказа значения <code>FTS_SYNCED_DOC_ID</code> используются, чтобы
идентифицировать документы, которые не сброшены на диск, чтобы документы
могли быть повторно разобраны и добавлены назад к кэшу индекса
<code>FULLTEXT</code>. Чтобы смотреть данные в этой таблице, запросите
таблицу <a href="inform.htm#innodb-ft-config-table"><code>
INFORMATION_SCHEMA.INNODB_FT_CONFIG</code></a>.</p></li></ul>

<h4><a name="idm139965325839888"></a>Кэш полнотекстового индекса</h4>
<p>Когда документ вставлен, он размечен, и отдельные слова и связанные данные
вставлены в таблицу, чтобы рассмотреть размеченные данные для
недавно вставленных строк. Этот процесс, даже для маленьких документов, мог
привести к многочисленным небольшим вставкам во вспомогательные
таблицы, делая параллельный доступ к этим таблицам предметом спора. Чтобы
избежать этой проблемы, <code>InnoDB</code> использует кэш индекса
<code>FULLTEXT</code>, чтобы временно кэшировать табличные вставки для
недавно вставленных строк. Эта структура в кэш-памяти содержит вставки, пока
кэш не заполнится, и затем пакетом сбрасывает их на диск (к вспомогательной
индексной таблице). Вы можете запросить таблицу
<a href="inform.htm#innodb-ft-index-cache-table"><code>
INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE</code></a>, чтобы смотреть
размеченные данные для недавно вставленных строк.</p>

<p>Поведение кэширования и пакета избегает частых обновлений вспомогательных
таблиц, которые могли привести к параллельным проблемам доступа во время
занятой вставки и обновления. Метод группирования также избегает многократных
вставок для того же самого слова и минимизирует двойные записи.
Вместо того, чтобы сбросить каждое слово индивидуально, вставки для того же
самого слова слиты и сбрасываются на диск как единственная запись, улучшая
эффективность вставки, в то время как размер индексных таблиц
как можно меньше.</p>

<p>Переменная <a href="#sysvar_innodb_ft_cache_size"><code>
innodb_ft_cache_size</code></a> используется, чтобы сконфигурировать размер
кэша (на основе таблицы), который затрагивает, как часто полнотекстовый
индексный кэш сбрасывается. Вы можете также определить глобальный предел
размера кэша для всех таблиц в приведенном примере, используя опцию
<a href="#sysvar_innodb_ft_total_cache_size">
<code>innodb_ft_total_cache_size</code></a>.</p>

<p>Полнотекстовый индексный кэш хранит ту же самую информацию, как и
вспомогательные индексные таблицы. Однако, полнотекстовый индексный кэш
кэширует только размеченные данные для недавно вставленных строк.
Данные, которые уже сброшены на диск (к полнотекстовым вспомогательным
таблицам) не возвращены в кэш когда запрошены. Данные во вспомогательных
таблицах запрошены непосредственно, и результаты из вспомогательных таблиц
слиты с результатами из кэша прежде, чем быть возвращенными.</p>

<h4><a name="idm139965325829568"></a>ID документа и столбец FTS_DOC_ID</h4>
<p><code>InnoDB</code> использует уникальный идентификатор документа,
называемый Document ID (<code>DOC_ID</code>),
чтобы отобразить слова в полнотекстовом индекс на записи, где слово
появляется. Отображение требует столбца <code>FTS_DOC_ID</code> в
индексированной таблице. Если <code>FTS_DOC_ID</code>
не определен, <code>InnoDB</code> автоматически добавляет скрытый столбец
<code>FTS_DOC_ID</code>, когда полнотекстовый индекс создается. Следующий
пример демонстрирует это поведение.</p>

<p>Следующее табличное определение не включает <code>FTS_DOC_ID</code>:
<pre>
CREATE TABLE opening_lines (id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY
       KEY, opening_line TEXT(500), author VARCHAR(200),
       title VARCHAR(200)) ENGINE=InnoDB;
</pre>

<p>Когда Вы создаете полнотекстовый индекс, используя
<code>CREATE FULLTEXT INDEX</code>, предупреждение возвращено, которое
сообщает о том, что <code>InnoDB</code> переделывает таблицу, чтобы
добавить столбец <code>FTS_DOC_ID</code>.
<pre>
mysql&gt; CREATE FULLTEXT INDEX idx ON opening_lines(opening_line);
Query OK, 0 rows affected, 1 warning (0.19 sec)
Records: 0  Duplicates: 0  Warnings: 1

mysql&gt; SHOW WARNINGS;
+---------+------+--------------------------------------------------+
| Level   | Code | Message                                          |
+---------+------+--------------------------------------------------+
| Warning |  124 | InnoDB rebuilding table to add column FTS_DOC_ID |
+---------+------+--------------------------------------------------+
</pre>

<p>То же самое предупреждение возвращено, используя
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
чтобы добавить полнотекстовый индекс к таблице, которая не имеет столбца
<code>FTS_DOC_ID</code>. Если Вы создаете полнотекстовый индекс через
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
и не определяете <code>FTS_DOC_ID</code>, <code>InnoDB</code>
добавляет скрытый столбец <code>FTS_DOC_ID</code> без предупреждения.</p>

<p>Определение <code>FTS_DOC_ID</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
уменьшает время, требуемое, чтобы создать полнотекстовый индекс на таблице,
которая уже загружена данными. Если столбец <code>FTS_DOC_ID</code>
определен на таблице до загрузки данных, таблица и индекс не должны быть
переделаны, чтобы добавить новый столбец. <code>InnoDB</code>
создает скрытый столбец <code>FTS_DOC_ID</code> наряду с уникальным индексом
(<code>FTS_DOC_ID_INDEX</code>) на столбце <code>FTS_DOC_ID</code>.
Если Вы хотите создать свой собственный <code>FTS_DOC_ID</code>,
столбец должен быть определен как <code>BIGINT UNSIGNED NOT NULL</code> и
назван <code>FTS_DOC_ID</code> (все буквы большие), как в следующем примере:
</p>

<p>Столбец <code>FTS_DOC_ID</code> не должен быть определен как
<code>AUTO_INCREMENT</code>, но
<code>AUTO_INCREMENT</code> мог сделать загрузку данных легче.</p>

<pre>
CREATE TABLE opening_lines (
       FTS_DOC_ID BIGINT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
       opening_line TEXT(500), author VARCHAR(200), title VARCHAR(200))
       ENGINE=InnoDB;
</pre>

<p>Если Вы хотите определять <code>FTS_DOC_ID</code>
самостоятельно, Вы ответственны за управление столбцом, чтобы избежать пустых
или двойных значений. Значения <code>FTS_DOC_ID</code>
не могут быть снова использованы, что означает, что значения
<code>FTS_DOC_ID</code> должны когда-либо увеличиваться.</p>

<p>Произвольно Вы можете создать необходимый уникальный
<code>FTS_DOC_ID_INDEX</code> на столбце <code>FTS_DOC_ID</code>.
<pre>
CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on opening_lines(FTS_DOC_ID);
</pre>

<p>Если Вы не создаете <code>FTS_DOC_ID_INDEX</code>, <code>InnoDB</code>
создает это автоматически.</p>
<p>Разрешенный промежуток между используемым самым большим значением
<code>FTS_DOC_ID</code> и новым значением <code>FTS_DOC_ID</code> 65535.</p>

<h4><a name="idm139965325786576"></a>
Обработка удаления полнотекстового индекса</h4>
<p>Удаление записи, у которой есть полнотекстовый индекс, может привести к
многочисленным маленьким удалениям во вспомогательных индексных таблицах,
делая параллельный доступ к этим таблицам предметом спора. Чтобы
избежать этой проблемы, Document ID (<code>DOC_ID</code>)
из удаленного документа зарегистрирован в спецтаблице
<code>FTS_*_DELETED</code> всякий раз, когда запись удалена из
индексированной таблицы, и запись остается в полнотекстовом индексе.
Перед возвращением результатов запроса, информация в
<code>FTS_*_DELETED</code> используется, чтобы отфильтровать удаленные
Document ID. Выгода этого проекта то, что удаления быстры и недороги.
Недостаток состоит в том, что размер индекса не был немедленно уменьшен после
удаления записей. Чтобы удалить полнотекстовые индексные записи,
надо выполнить <code>OPTIMIZE TABLE</code> на индексированной таблице с
<a href="#sysvar_innodb_optimize_fulltext_only"><code>
innodb_optimize_fulltext_only=ON</code></a>, чтобы восстановить
полнотекстовый индекс.</p>

<h4><a name="idm139965325779632"></a>Обработка транзакций Full-Text</h4>
<p>Индексы <code>FULLTEXT</code> имеют специальные операционные
характеристики управляемости, описывающие поведение кэширования и пакетной
обработки данных. Определенно, обновления и вставки на индексе
<code>FULLTEXT</code> обработаны в момент закрытия транзакции, что означает,
что поиск <code>FULLTEXT</code> может видеть только переданные данные.
Следующий пример демонстрирует это поведение. <code>FULLTEXT</code>
возвращает результат после того, как вставленные строки переданы.
<pre>
mysql&gt; CREATE TABLE opening_lines (
                 id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
                 opening_line TEXT(500), author VARCHAR(200),
                 title VARCHAR(200), FULLTEXT idx (opening_line))
                 ENGINE=InnoDB;
mysql&gt; BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; INSERT INTO opening_lines(opening_line,author,title) VALUES
   ('Call me Ishmael.','Herman Melville','Moby-Dick'),
   ('A screaming comes across the sky.','Thomas Pynchon','Gravity\'s Rainbow'),
   ('I am an invisible man.','Ralph Ellison','Invisible Man'),
   ('Where now? Who now? When now?','Samuel Beckett','The Unnamable'),
   ('It was love at first sight.','Joseph Heller','Catch-22'),
   ('All this happened, more or less.','Kurt Vonnegut','Slaughterhouse-Five'),
   ('Mrs. Dalloway said she would buy the flowers herself.','Virginia Woolf','Mrs. Dalloway'),
   ('It was a pleasure to burn.','Ray Bradbury','Fahrenheit 451');
Query OK, 8 rows affected (0.00 sec)
Records: 8  Duplicates: 0  Warnings: 0

mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line)
                 AGAINST('Ishmael');
+----------+
| COUNT(*) |
+----------+
| 0        |
+----------+

mysql&gt; COMMIT;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT COUNT(*) FROM opening_lines WHERE MATCH(opening_line)
                 AGAINST('Ishmael');
+----------+
| COUNT(*) |
+----------+
| 1        |
+----------+
</pre>

<h4><a name="idm139965325771664"></a>Контроль полнотекстовых индексов</h4>
<p>Вы можете контролировать и исследовать специальные относящиеся к обработке
текстов аспекты <code>InnoDB</code> <code>FULLTEXT</code>, запрашивая
следующие таблицы <code>INFORMATION_SCHEMA</code>:</p>

<ul><li><p><a href="inform.htm#innodb-ft-config-table"><code>INNODB_FT_CONFIG
</code></a></li>
<li><a href="inform.htm#innodb-ft-index-table-table"><code>
INNODB_FT_INDEX_TABLE</code></a></li>

<li><a href="inform.htm#innodb-ft-index-cache-table"><code>
INNODB_FT_INDEX_CACHE</code></a></li>
<li><a href="inform.htm#innodb-ft-default-stopword-table"><code>
INNODB_FT_DEFAULT_STOPWORD</code></a></li>

<li><a href="inform.htm#innodb-ft-deleted-table"><code>INNODB_FT_DELETED
</code></a></li>
<li><a href="inform.htm#innodb-ft-being-deleted-table"><code>
INNODB_FT_BEING_DELETED</code></a></p></li></ul>

<p>Вы можете также рассмотреть основную информацию для индексов
<code>FULLTEXT</code> и таблиц, запрашивая
<a href="inform.htm#innodb-sys-indexes-table"><code>INNODB_SYS_INDEXES</code>
</a> и <a href="inform.htm#innodb-sys-tables-table"><code>INNODB_SYS_TABLES
</code></a>.</p>
<p>См. <a href="#innodb-information-schema-fulltext_index-tables">
раздел 16.14.4</a>.</p>

<h3><a name="innodb-physical-structure"></a>16.8.10.
Физическая структура индексов InnoDB</h3>
<p>За исключением пространственного индекса, индексы <code>InnoDB</code>
это структуры данных <a href="glossary.htm#glos_b_tree">B-tree</a>.
Пространственный индекс использует <a href="glossary.htm#glos_r_tree">
R-tree</a>, которые являются специализированными структурами данных для того,
чтобы индексировать многомерные данные. Индексные записи сохранены в
страницах листа их структуры данных B-tree или R-tree.
Размер по умолчанию индексной страницы составляет 16 КБ.</p>

<p>Когда новые записи вставлены в
<a href="glossary.htm#glos_clustered_index">кластеризируемый индекс</a>,
<code>InnoDB</code> попытается оставить 1/16 страницы свободной для будущих
вставок и обновлений. Если индексные записи вставлены в последовательном
порядке (возрастание или убывание), получающиеся индексные страницы полны на
15/16. Если записи вставлены в случайном порядке, страницы полны от 1/2 до
15/16.</p>

<p><code>InnoDB</code> выполняет оптовую загрузку, когда создает B-tree
индексов. Этот метод создания индекса известен как сортированный индекс.
<a href="#sysvar_innodb_fill_factor"><code>innodb_fill_factor
</code></a> определяет процент пространства на каждой странице B-дерева,
который заполнен во время создания сортированного индекса с остающимся
пространством, сохраненным для будущего роста. Создание сортированного
индекса не поддержанр для пространственного индекса. Для получения
дополнительной информации см.
<a href="#sorted-index-builds">раздел 16.8.11</a>.
<a href="#sysvar_innodb_fill_factor"><code>innodb_fill_factor
</code></a> устанавливает 1/16 пространства в кластеризируемых индексных
страницах свободным для будущего роста.</p>

<p>Если коэффициент заполнения индексной страницы понижается ниже
<code>MERGE_THRESHOLD</code>, который составляет 50% по умолчанию, если не
определен <code>InnoDB</code> пробует сократить индексное дерево, чтобы
освободить страницу. <code>MERGE_THRESHOLD</code> относится к B-tree и
R-tree. Подробности в <a href="#index-page-merge-threshold">разделе
16.6.11</a>.</p>

<p>Вы можете сконфигурировать <a href="glossary.htm#glos_page_size">размер
страницы</a> для всех табличных пространств <code>InnoDB</code>, задав опцию
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> прежде, чем создать экземпляр. Как только размер страницы установлен, Вы
не можете изменить его. Поддержанные размеры составляют 64KB, 32KB, 16KB
(значение по умолчанию), 8KB и 4KB, соответствуя значениям опции
<code>64k</code>, <code>32k</code>, <code>16k</code>, <code>8k</code> и
<code>4k</code>.</p>

<h3><a name="sorted-index-builds"></a>
16.8.11. Создание сортированного индекса</h3>
<p><code>InnoDB</code> выполняет оптовую загрузку вместо того, чтобы вставить
каждую запись в то время, когда создает индекс. Этот метод известен как
создание сортированного индекса. Сортированный индекс не поддержан
для пространственного индекса.</p>

<p>Есть три фазы создания индекса. В первой фазе
<a href="glossary.htm#glos_clustered_index">кластеризируемый индекс</a>
просмотрен, и индексные записи произведены и добавлены к буферу. Когда
<a href="glossary.htm#glos_sort_buffer">буфер сортировки</a>
становится полным, записи сортированы и записаны во временный промежуточный
файл. Этот процесс также известен как <span><span>run</span></span>.
Во второй фазе, с одним или более выполнениями, записанными во временный
промежуточный файл, сортировка слиянием выполнена на всех записях в файле.
В третьей и заключительной фазе сортированные записи вставлены в
<a href="glossary.htm#glos_b_tree">B-tree</a>.</p>

<p>До введения сортированных индексов записи были вставлены в B-tree
поштучно, используя insert API. Этот метод вовлекал открытие B-tree
<a href="glossary.htm#glos_cursor">курсора</a>, чтобы найти позицию вставки,
а затем вставку записей в страницу B-tree, используя
<a href="glossary.htm#glos_optimistic">оптимистическую</a>вставку. Если бы
вставка потерпела неудачу из-за полной страницы, то
<a href="glossary.htm#glos_pessimistic">пессимистическая</a>
вставка была бы выполнена, которая вовлекает открытие курсора B-tree,
разделение и слияние узлов B-tree по мере необходимости, чтобы найти
пространство для входа. Недостатки этого метод создания индексирования
являются стоимостью поиска позиции вставки и постоянного разделения и
слияния узлов B-tree.</p>

<p>Сортированный индекс использует восходящий подход к созданию индекса.
С этим подходом ссылка на самую правую страницу листа проводится на всех
уровнях B-tree. Самая правая страница листа в необходимой глубине B-tree
выделена, и записи вставлены согласно их сортированному порядку. Как только
страница листа полна, указатель узла приложен к родительской странице, и
страница листа выделена для следующей вставки. Этот процесс продолжается,
пока все записи не вставлены, что может привести к вставкам до уровня корня.
Когда страница выделена, ссылка на ранее прикрепленную страницу листа
выпущена, и недавно выделенная страница листа становится самой правой
страницей листа (и новым значением по умолчанию места для вставки).</p>

<h4><a name="idm139965325707328"></a>Резервирование места на страницах
B-tree для будущего роста индекса</h4>
<p>Чтобы отложить пространство для будущего индексного роста, Вы можете
использовать опцию <a href="#sysvar_innodb_fill_factor"><code>
innodb_fill_factor</code></a>, чтобы зарезервировать процент пространства
страницы B-tree. Например, установка
<a href="#sysvar_innodb_fill_factor"><code>innodb_fill_factor
</code></a> в 80 резервирует 20 процентов пространства в страницах B-tree
во время создания сортированного индекса. Эта установка относится к страницам
листа и не к страницам листа B-tree. Это не относится к внешним страницам,
используемым для <a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>.
Количество пространства, которое сохранено, не может быть точно
сконфигурировано, поскольку <a href="#sysvar_innodb_fill_factor">
<code>innodb_fill_factor</code></a> интерпретируется как подсказка, а
не жесткий предел.</p>

<h4><a name="idm139965325699392"></a>Создание сортированного индекса
и поддержка Fulltext Index</h4>
<p>Создание сортированного индекса поддерживается для
<a href="glossary.htm#glos_fulltext_index">индексов fulltext</a>.
Ранее SQL использовался, чтобы вставить записи в индексы fulltext.</p>

<h4><a name="idm139965325697168"></a>Создание сортированного индекса
и сжатые таблицы</h4>
<p>Для <a href="glossary.htm#glos_compression">сжатых таблиц</a>
предыдущие метод создания индекса добавляет записи в сжатые и в несжатые
страницы. Когда журнал модификации (представляющий свободное пространство на
сжатой странице) станет полным, сжатая страница будет пересжата. Если бы
сжатие потерпело неудачу из-за недостатка места, то страница была бы
разделена. С сортированным индексом записи добавлены только к несжатым
страницам. Когда несжатая страница становится полной, она сжата. Адаптивное
дополнение используется, чтобы гарантировать, что сжатие преуспевает в
большинстве случаев, но если сжатие терпит неудачу, страница разделена, и
сжатие предпринято снова. Этот процесс продолжается, пока сжатие не пройдет
успешно. Для дополнительной информации о сжатии страниц B-Tree см.
<a href="#innodb-compression-internals">раздел 16.9.1.5</a>.</p>

<h4><a name="idm139965325693648"></a>Создание сортированного индекса и
журнал Redo</h4>
<p><a href="glossary.htm#glos_redo_log">Журнал Redo</a>
выключен во время создания сортированного индекса. Вместо этого есть
<a href="glossary.htm#glos_checkpoint">контрольная точка</a>, чтобы
гарантировать, что индексирование может противостоять катастрофическому
отказу. Контрольная точка вызывает запись всех грязных страниц на диск. Во
время создания сортированного индекса поток
<a href="glossary.htm#glos_page_cleaner">уборщика страницы</a>
вызван периодически, чтобы сбросить <a href="glossary.htm#glos_dirty_page">
грязные страницы</a>, чтобы гарантировать, что работа контрольной точки может
быть обработана быстро. Обычно поток уборщика сбрасывает грязные страницы,
когда число чистых страниц падает ниже порога набора. При создании
сортированного индекса грязные страницы сбрасываются быстро, чтобы уменьшить
издержки контрольной точки.</p>

<h4><a name="idm139965325688512"></a>Создание сортированного индекса и
статистика оптимизатора</h4>
<p>Создание сортированного индекса может привести к статистическим данным,
которые отличаются от произведенных предыдущим методом создания индекса,
используемым в более ранних выпусках MySQL. Различие в статистике, которое,
как ожидают, не затронет рабочую нагрузку, происходит из-за различного
алгоритма, который используется, чтобы заполнить индекс.</p>

<h2><a name="innodb-compression"></a>16.9. Таблица InnoDB и сжатие страницы
</h2>
<p>Этот раздел предоставляет информацию о табличном сжатии и
особенности сжатия страницы. Особенность сжатия страницы также упоминается
как <a href="glossary.htm#glos_transparent_page_compression">
прозрачное сжатие страницы</a>.</p>

<p>Используя функции сжатия <code>InnoDB</code>, Вы можете составить таблицы,
где данные хранятся в сжатой форме. Сжатие может помочь улучшить сырую работу
и масштабируемость. Сжатие означает, что меньше данных передано между диском
и памятью, и занимает меньше места на диске и в памяти. Выгода усилена для
таблиц с <a href="glossary.htm#glos_secondary_index">вторичными индексами
</a>, потому что индексные данные сжаты также. Сжатие может быть особенно
важным для устройств хранения данных <a href="glossary.htm#glos_ssd">SSD</a>
из-за их низкой емкости.</p>

<h3><a name="innodb-table-compression"></a>16.9.1. Табличное сжатие InnoDB
</h3>
<p>Этот раздел описывает табличное сжатие, которое поддержано
таблицами, которые находятся в табличных пространствах
<a href="glossary.htm#glos_file_per_table">file_per_table</a> или
<a href="glossary.htm#glos_general_tablespace">общих табличных пространствах
</a>. Табличное сжатие включено, используя атрибут
<code>ROW_FORMAT=COMPRESSED</code> с
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<h4><a name="innodb-compression-background"></a>16.9.1.1.
Краткий обзор табличного сжатия</h4>
<p>Поскольку процессоры и кэш-память увеличили в скорости больше,
чем дисковые устройства хранения данных, много рабочих нагрузок являются
<a href="glossary.htm#glos_disk_bound">зависящими от диска</a>.
<a href="glossary.htm#glos_compression">Сжатие</a> данных приводит к
меньшему размеру базы данных, уменьшенному вводу/выводу и улучшенной
пропускной способности, при маленькой стоимости увеличенного использования
центрального процессора. Сжатие особенно ценно для интенсивных чтением
приложений, на системах с достаточным количеством RAM, чтобы сохранить часто
используемые данные в памяти.</p>

<p>Таблица, составленная с <code>ROW_FORMAT=COMPRESSED</code> может
использовать меньший <a href="glossary.htm#glos_page_size">размер страницы
</a> на диске, чем сконфигурировано
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. Меньшие страницы требуют меньше ввода/вывода, который особенно ценен
для устройств <a href="glossary.htm#glos_ssd">SSD</a>.</p>

<p>Сжатый размер страницы определен через параметр
<code>KEY_BLOCK_SIZE</code> в <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> или <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>. Различный размер страницы требует, чтобы таблица была помещена в
табличное пространство <a href="glossary.htm#glos_file_per_table">
file-per-table</a> или в <a href="glossary.htm#glos_general_tablespace">
общее табличное пространство</a>, а не в
<a href="glossary.htm#glos_system_tablespace">системное табличное
пространство</a>, поскольку системное табличное пространство не может
сохранить сжатые таблицы. Для получения дополнительной информации см. разделы
<a href="#innodb-multiple-tablespaces">16.7.4</a> и
<a href="#general-tablespaces">16.7.9</a>.</p>

<p>Уровень сжатия не зависит от <code>KEY_BLOCK_SIZE</code>.
Поскольку Вы определяете меньшие значения для <code>KEY_BLOCK_SIZE</code>,
Вы извлекаете пользу ввода/вывода из все более и более меньших страниц. Но
если Вы определяете значение, которое является слишком маленьким, будут
лишние накладные расходы, чтобы реорганизовать страницы, когда значения
данных не могут быть сжаты достаточно, чтобы разместить много строк в каждой
странице. Есть жесткий предел нижнего размера <code>KEY_BLOCK_SIZE</code>,
который может быть для таблицы, основанный на длинах ключевых столбцов для
каждого из индексов. Определите значение, которое является слишком маленьким,
и <a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> не сработают.</p>

<p>В буферном пуле сжатые данные проводятся в маленьких страницах, с размером
страницы, основанным на <code>KEY_BLOCK_SIZE</code>.
Для извлечения или обновления значений столбцов MySQL также создает несжатую
страницу в буферном пуле с несжатыми данными. В буферном пуле любые
обновления несжатой страницы также переписаны назад к эквивалентной сжатой
странице. Вы, возможно, должны были бы измерить свой буферный пул, чтобы
приспособить дополнительные данные и сжатых и несжатых страниц,
хотя несжатые страницы <a href="glossary.htm#glos_eviction">вычеркиваются
</a> из буферного пула, когда пространство необходимо, и затем разсжаты снова
при следующем доступе.</p>

<h4><a name="innodb-compression-usage"></a>16.9.1.2.
Составление сжатых таблиц</h4>
<p>Сжатые таблицы могут быть составлены в табличных пространствах
<a href="glossary.htm#glos_file_per_table">file-per-table</a> или в
<a href="glossary.htm#glos_general_tablespace">общих табличных пространствах
</a>. Табличное сжатие недоступно для
<a href="glossary.htm#glos_system_tablespace">системного табличного
пространства</a>. Системное табличное пространство
(файлы <a href="glossary.htm#glos_ibd_file">.ibdata</a>) может содержать
создаваемые пользователем таблицы, но оно также содержит внутренние системные
данные, которые никогда не сжимаются. Таким образом, сжатие применяется
только к таблицам и индексам, сохраненным в file-per-table или
общих табличных пространствах.</p>

<h5><a name="idm139965325629488"></a>Составление сжатой таблицы в табличном
пространстве File-Per-Table</h5>
<p>Чтобы создать сжатую таблицу в табличном пространстве file-per-table,
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> должен быть включен (значение по умолчанию). Вы можете установить
эти параметры в конфигурационном файле MySQL (<code>my.cnf</code> или
<code>my.ini</code>) или динамически с использованием
<a href="sql.htm#set-variable"><code>SET</code></a>.</p>

<p>После настройки опции <a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a> определите параметр
<code>ROW_FORMAT=COMPRESSED</code>, <code>KEY_BLOCK_SIZE</code> или оба
в <a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
чтобы составить сжатую таблицу в табличном пространстве file-per-table.</p>

<p>Например, Вы могли бы использовать следующие запросы:
<pre>
SET GLOBAL innodb_file_per_table=1;
CREATE TABLE t1 (c1 INT PRIMARY KEY) ROW_FORMAT=COMPRESSED
       KEY_BLOCK_SIZE=8;
</pre>

<h5><a name="idm139965325617248"></a>Составление сжатой таблицы в
общем табличном пространстве</h5>
<p>Чтобы создать сжатую таблицу в общем табличном пространстве,
<code>FILE_BLOCK_SIZE</code> должен быть определен для общего табличного
пространства, которое определено, когда табличное пространство создается.
<code>FILE_BLOCK_SIZE</code> должно быть допустимым сжатым размером страницы
относительно <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a>, размер страницы сжатой таблицы, определенной
параметром <code>KEY_BLOCK_SIZE</code> в <a href="sql.htm#create-table">
<code>CREATE TABLE</code></a> или <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> должен быть равным <code>FILE_BLOCK_SIZE/1024</code>.
Например, если <a href="#sysvar_innodb_page_size"><code>
innodb_page_size=16384</code></a> и <code>FILE_BLOCK_SIZE=8192</code>,
<code>KEY_BLOCK_SIZE</code> должен быть 8. Для получения дополнительной
информации см. <a href="#general-tablespaces">раздел 16.7.9</a>.
</p>

<p>Следующий пример демонстрирует создание общего табличного пространства и
добавление сжатой таблицы. Пример принимает значение по умолчанию
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> 16K. <code>FILE_BLOCK_SIZE</code> = 8192 требует, чтобы у сжатой таблицы
был <code>KEY_BLOCK_SIZE</code> = 8.
<pre>
mysql&gt; CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd'
                 FILE_BLOCK_SIZE = 8192 Engine=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE t4 (c1 INT PRIMARY KEY) TABLESPACE ts2
                 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
Query OK, 0 rows affected (0.00 sec)
</pre>

<h5><a name="idm139965325601616"></a>Примечания</h5>
<ul><li><p>Если Вы определяете <code>ROW_FORMAT=COMPRESSED</code>,
Вы можете опустить <code>KEY_BLOCK_SIZE</code>, <code>KEY_BLOCK_SIZE</code>
по умолчанию установится к половине
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>.</li>

<li>Если Вы определяете допустимое значение <code>KEY_BLOCK_SIZE</code>, Вы
можете опустить <code>ROW_FORMAT=COMPRESSED</code>,
сжатие включено автоматически.</li>

<li>Чтобы определить лучшее значение для <code>KEY_BLOCK_SIZE</code>,
как правило, Вы создаете несколько копий той же самой таблицы с различными
значениями для этого параметра, затем измеряете размер получающегося файла
<code>.ibd</code>. Для общих табличных пространств имейте в виду, что
понижение таблицы не уменьшает размер файла <code>.ibd</code> общего
табличного пространства и при этом не возвращает дисковое пространство к
операционной системе. Для получения дополнительной информации см.
<a href="#general-tablespaces">раздел 16.7.9</a>.</li>

<li><code>KEY_BLOCK_SIZE</code> обработано как подсказка,
иной размер может использоваться <code>InnoDB</code> в случае необходимости.
Для табличных пространств file-per-table <code>KEY_BLOCK_SIZE</code>
может быть только меньше или равным
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. Если Вы определяете значение больше, чем
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>, указанное значение проигнорировано, предупреждение выпущено и
<code>KEY_BLOCK_SIZE</code> установлен в половину
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. Если <code>innodb_strict_mode=ON</code>, определение недопустимого
<code>KEY_BLOCK_SIZE</code> возвращает ошибку. Для общих табличных
пространств допустимые значения <code>KEY_BLOCK_SIZE</code>
зависят от <code>FILE_BLOCK_SIZE</code>. Подробности в
<a href="#general-tablespaces">разделе 16.7.9</a>.</li>

<li><code>InnoDB</code> поддерживает размеры страницы 32 k и 64 k, но эти
размеры страницы не поддерживают сжатие. Для получения дополнительной
информации обратитесь к описанию
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>.</li>

<li>Значение по умолчанию несжатого размера
<a href="glossary.htm#glos_page">страниц</a> 16KB.
В зависимости от комбинации значений опций MySQL использует размер страницы
1KB, 2KB, 4KB, 8KB или 16KB для файла с данными табличного пространства
(файл <code>.ibd</code>). Фактический алгоритм сжатия не затронут
<code>KEY_BLOCK_SIZE</code>, значение определяет, насколько большой каждый
сжатый кусок, что в свою очередь затрагивает, сколько строк может быть
упаковано в каждую сжатую страницу.</li>

<li>Составляя сжатую таблицу в табличном пространстве file-per-table
установка <code>KEY_BLOCK_SIZE</code> равным
<a href="glossary.htm#glos_page_size">размеру страницы</a>,
как правило, не приводит к большому сжатию. Например, установка
<code>KEY_BLOCK_SIZE=16</code> обычно не приводила бы к большому сжатию,
начиная с нормального размера страницы 16KB. Эта установка может все еще быть
полезной для таблиц с многими большими столбцами
<a href="types.htm#blob"><code>BLOB</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>, потому что такие значения
часто сжимаются хорошо, и могли бы поэтому потребовать меньшего количества
<a href="glossary.htm#glos_overflow_page">страниц переполнения</a>,
как описано в <a href="#innodb-compression-internals">разделе
16.9.1.5</a>. Для общих табличных пространств <code>KEY_BLOCK_SIZE</code>
равный размеру страницы не разрешен. Для получения дополнительной информации
см. <a href="#general-tablespaces">раздел 16.7.9</a>.</li>

<li>Все индексы таблицы (включая
<a href="glossary.htm#glos_clustered_index">кластеризируемый индекс</a>)
сжаты, используя тот же самый размер страницы, как определено в
<code>CREATE TABLE</code> или <code>ALTER TABLE</code>. Табличные признаки
<code>ROW_FORMAT</code> и <code>KEY_BLOCK_SIZE</code> не часть синтаксиса
<code>CREATE INDEX</code> для таблиц <code>InnoDB</code>
и проигнорированы, если они определены (хотя если определены, они появятся в
выводе <a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE</code>
</a>).</li>

<li>Для связанных с работой параметров конфигурации см.
<a href="#innodb-compression-tuning">раздел 16.9.1.3</a>.
</p></li></ul>

<h5><a name="idm139965325548608"></a>Ограничения на сжатые таблицы</h5>
<ul><li><p>Сжатые таблицы не могут быть сохранены в
системное табличное пространство.</li>

<li>Общие табличные пространства могут содержать много таблиц, но сжатые и
несжатые таблицы не могут сосуществовать в пределах того же самого
общего табличного пространства.</li>

<li>Сжатие относится ко всей таблице и всем связанным индексам, а не к
отдельным строкам, несмотря на имя параметра <code>ROW_FORMAT</code>.</li>
<li><code>InnoDB</code> не поддерживает сжатые временные таблицы. Когда
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> включен (значение по умолчанию),
<a href="sql.htm#create-table"><code>CREATE TEMPORARY TABLE</code></a>
возвращает ошибку, если указан <code>ROW_FORMAT=COMPRESSED</code> или
<code>KEY_BLOCK_SIZE</code>. Если
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> отключен, предупреждения выпущены, и временная таблица
составлена, используя несжатый формат строки. Те же самые ограничения
относятся к <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
на временных таблицах.</p></li></ul>

<h4><a name="innodb-compression-tuning"></a>16.9.1.3.
Настройка сжатия для таблиц InnoDB</h4>
<p>Потому что эффективность сжатия зависит от природы Ваших данных, Вы можете
принять решения, которые затрагивают исполнение сжатых таблиц:</p>

<ul><li><p>Какие таблицы сжать.</li>
<li>Какой сжатый размер страницы использовать.</li>
<li>Скорректировать ли размер буферного пула, основываясь на технических
характеристиках во время выполнения, таких как количество времени, которое
система тратит на сжатие и разсжатие данных. Походит ли рабочая нагрузка
больше на <a href="glossary.htm#glos_data_warehouse">хранилище данных</a>
(прежде всего запросы) или система
<a href="glossary.htm#glos_oltp">OLTP</a> (соединение запросов и
<a href="glossary.htm#glos_dml">DML</a>).</li>

<li>Если система выполняет операции DML на сжатых таблицах, и способ, которым
распределены данные, приводит к дорогим
<a href="glossary.htm#glos_compression_failure">отказам сжатия</a>
во времени выполнения, Вы могли бы скорректировать дополнительные
усовершенствованные параметры конфигурации.</p></li></ul>

<p>Когда Вы готовы провести долгосрочное тестирование и поместить сжатые
таблицы в производство см.
<a href="#innodb-compression-tuning-monitoring">раздел 16.9.1.4</a>
для способов проверить эффективность выбора в условиях реального мира.</p>

<h5><a name="innodb-compression-tuning-when"></a>Когда использовать сжатие
</h5>
<p>Вообще, сжатие работает лучше всего с
таблицами, которые включают разумное число столбцов символьных строк
и где данные считаны намного чаще, чем записаны. Поскольку нет никаких
гарантируемых способов предсказать, приносит ли сжатие пользу в особой
ситуации, всегда проверяйте с определенной
<a href="glossary.htm#glos_workload">рабочей нагрузкой</a>
и набором данных, работающим на представительной конфигурации. Рассмотрите
следующие факторы, решая которые таблицы сжать.</p>

<h5><a name="innodb-compression-tuning-when-data"></a>
Характеристики данных и сжатие</h5>
<p>Ключевой детерминант эффективности сжатия в сокращении размера файлов
с данными является природой данных. Вспомните, что сжатие работает,
идентифицируя повторные строки байтов в блоке данных. Полностью
рандомизированные данные худший случай. Типичные данные часто повторяют
значения, там сжатие эффективно. Строки символов часто сжимаются хорошо,
независимо от типа столбца <code>CHAR</code>, <code>VARCHAR</code>,
<code>TEXT</code> или <code>BLOB</code>. С другой стороны, таблицы,
содержащие главным образом двоичные данные (целые числа или числа с плавающей
запятой) или данные, которые ранее сжаты (например, изображения
<acronym class="acronym">JPEG</acronym> или
<acronym class="acronym">PNG</acronym>), возможно, не сжимаются хорошо,
значительно или вообще.</p>

<p>Вы выбираете, включить ли сжатие для каждой таблицы InnoDB. Таблица и весь
индекс используют тот же самый (сжатый)
<a href="glossary.htm#glos_page_size">размер страницы</a>.
Могло бы случиться так, что
that the <a href="glossary.htm#glos_primary_key">первичный ключ</a>
(кластеризируемый) индекс, который содержит данные для всех столбцов таблицы,
сжимается эффективнее, чем вторичный индекс. Для тех случаев, где есть
длинные строки, использование сжатия могло бы привести к длинным значениям
столбцов, сохраненным <span><span>вне страницы</span></span>, как обсуждает
<a href="#innodb-row-format-dynamic">раздел 16.10.3</a>.
Те страницы переполнения можно сжать хорошо. Для многих приложений некоторые
таблицы сжимаются эффективнее, чем другие, и Вы могли бы найти, что Ваша
рабочая нагрузка выступает лучше всего только с подмножеством сжатых таблиц.
</p>

<p>Чтобы определить, сжать ли особую таблицу, проведите эксперименты.
Вы можете получить грубую оценку того, как эффективно Ваши данные могут быть
сжаты при использовании утилиты, которая осуществляет сжатие LZ77 (такой, как
<code>gzip</code> или WinZip) на копии
<a href="glossary.htm#glos_ibd_file">файла .ibd</a>
для несжатой таблицы. Вы можете ожидать, что будет меньше сжатия от MySQL для
таблицы, чем от основанных на файле инструментов сжатия, потому что MySQL
сжимает данные в кусках, основанных на
<a href="glossary.htm#glos_page_size">размере страницы</a>, 16KB
по умолчанию. В дополнение к пользовательским данным формат страницы включает
некоторые внутренние системные данные, которые не сжаты. Основанные на файле
утилиты сжатия могут исследовать намного большие куски данных, и так найти
повторные строки в огромном файле, чем MySQL может
найти в отдельной странице.</p>

<p>Другой способ проверить сжатие на определенной таблице состоит в том,
чтобы скопировать некоторые данные от Вашей несжатой таблицы в подобную
сжатую таблицу (имеющую все те же индексы) в табличном пространстве
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
и смотреть на размер получающегося файла <code>.ibd</code>:
<pre>
use test;
set global innodb_file_per_table=1;
set global autocommit=0;

-- Create an uncompressed table with a million or two rows.
create table big_table as select * from information_schema.columns;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
commit;
alter table big_table add id int unsigned not null primary key auto_increment;
show create table big_table\G
select count(id) from big_table;

-- Check how much space is needed for the uncompressed table.
\! ls -l data/test/big_table.ibd

create table key_block_size_4 like big_table;
alter table key_block_size_4 key_block_size=4 row_format=compressed;

insert into key_block_size_4 select * from big_table;
commit;

-- Check how much space is needed for a compressed table
-- with particular compression settings.
\! ls -l data/test/key_block_size_4.ibd
</pre>

<p>Этот эксперимент произвел следующие числа, которые, конечно, могли
значительно измениться в зависимости от Вашей структуры таблицы и данных:
<pre>
-rw-rw----  1 cirrus  staff  310378496 Jan  9 13:44 data/test/big_table.ibd
-rw-rw----  1 cirrus  staff   83886080 Jan  9 15:10 data/test/key_block_size_4.ibd
</pre>

<p>Чтобы понять, эффективно ли сжатие для Вашей особой
<a href="glossary.htm#glos_workload">рабочей нагрузки</a>:</p>
<ul><li><p>Для простых тестов, используйте
MySQL без других сжатых таблиц и выполните запросы для таблицы
<a href="inform.htm#innodb-cmp-table"><code>INFORMATION_SCHEMA.INNODB_CMP
</code></a>.</li>

<li>Для более тщательно продуманных тестов, вовлекающих рабочие нагрузки с
многими сжатыми таблицами, выполните запросы на таблице
<a href="inform.htm#innodb-cmp-per-index-table"><code>
INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code></a>.
Поскольку статистика в <code>INNODB_CMP_PER_INDEX</code> дорого собирается,
Вы должны включить параметру конфигурации
<a href="#sysvar_innodb_cmp_per_index_enabled"><code>
innodb_cmp_per_index_enabled</code></a> прежде, чем запросить ту таблицу, и
Вы могли бы ограничить такое тестирование сервером развития или некритическим
<a href="glossary.htm#glos_slave_server">ведомым сервером</a>.</li>

<li>Выполните некоторые типичные запросы SQL для сжатой таблицы,
которую Вы проверяете.</li>

<li>Исследуйте отношение успешных операций сжатия к полным операциям сжатия,
запрашивая <a href="inform.htm#innodb-cmp-table"><code>
INFORMATION_SCHEMA.INNODB_CMP</code></a> или
<a href="inform.htm#innodb-cmp-per-index-table"><code>
INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code></a> и сравнивая
<code>COMPRESS_OPS</code> с <code>COMPRESS_OPS_OK</code>.</li>

<li>Если высокий процент операций сжатия успешен, таблица могла бы быть
хорошим кандидатом на сжатие.</li>
<li>Если Вы получаете высокий процент
<a href="glossary.htm#glos_compression_failure">отказов сжатия</a>,
Вы можете корректировать опции
<a href="#sysvar_innodb_compression_level"><code>
innodb_compression_level</code></a>,
<a href="#sysvar_innodb_compression_failure_threshold_pct"><code>
innodb_compression_failure_threshold_pct</code></a> и
<a href="#sysvar_innodb_compression_pad_pct_max"><code>
innodb_compression_pad_pct_max</code></a> как описано в
<a href="#innodb-performance-compression-oltp">разделе 16.9.1.6
</a> и пробовать дальнейшие тесты.</p></li></ul>

<h5><a name="innodb-compression-application"></a>
Сжатие базы данных против сжатия приложения</h5>
<p>Решите, сжать ли данные в Вашем приложении или в таблице,
не используйте оба типа сжатия для тех же самых данных. Когда Вы сжимаете
данные в приложении и храните результаты в сжатой таблице, дополнительная
экономия пространства крайне маловероятна, и двойное сжатие только тратит
впустую циклы центрального процессора.</p>

<h5><a name="innodb-compression-in-database"></a>Сжатие в базе данных</h5>
<p>Когда включено, табличное сжатие MySQL является автоматическим и относится
ко всем столбцам. Столбцы могут все еще быть проверены с такими операторами,
как <code>LIKE</code>, и операции сортировки могут все еще использовать
индекс, даже когда индексированные значения сжаты. Поскольку индекс часто
существенная фракция полного размера базы данных, сжатие могло привести к
существенной экономии в хранении, вводе/выводе или времени процессора.
Операции сжатия и декомпрессии происходят на сервере базы данных, который,
вероятно, является сильной системой, которая измерена, чтобы
обработать ожидаемую загрузку.</p>

<h5><a name="innodb-compression-in-application"></a>Сжатие в приложении</h5>
<p>Если Вы сжимаете данные, такие как текст в Вашем приложении, прежде, чем
это будет вставлено в базу данных, Вы могли бы сохранить заголовок
для данных, которые не сжимаются хорошо, сжимая некоторые столбцы.
Этот подход использует циклы центрального процессора для сжатия на машине
клиента, а не сервере базы данных, который мог бы быть подходящим для
распределенного приложения со многими клиентами, или где у машины клиента
есть запасные циклы центрального процессора.</p>

<h5><a name="innodb-compression-hybrid"></a>Гибридный подход</h5>
<p>Конечно, возможно объединить эти подходы. Для некоторых приложений может
быть уместно использовать некоторые сжатые таблицы и некоторые несжатые
таблицы. Может быть лучшим внешне сжать некоторые данные (и сохранить в
несжатых таблицах) и позволить MySQL сжимать другие таблицы приложения.
Как всегда, грамотный проект и реальное тестирование ценны в
достижении правильного решения.</p>

<h5><a name="innodb-compression-tuning-when-workload"></a>
Характеристики рабочей нагрузки и сжатие</h5>
<p>В дополнение к выбору, какие таблицы сжать (и размер страницы),
рабочая нагрузка это другой ключевой детерминант работы. Если приложение
в основном читает, а не обновлено, меньше страниц должно быть реорганизовано
и повторно сжато после того, как индексная страница исчерпывает место для
страницы в <span><span>журнале модификаций</span></span>, который MySQL
поддерживает для сжатых данных. Если обновления преобладающе изменяют
неиндексированные столбцы или те, которые содержат <code>BLOB</code> или
большие строки, которые сохранены <span><span>вне страницы</span></span>,
издержки сжатия могут быть приемлемыми. Если единственные изменения таблицы
<code>INSERT</code>, которые используют монотонно увеличивающийся первичный
ключ, и есть немногие вторичные индексы, есть небольшая потребность
реорганизовать и повторно сжать индексные страницы. Так как MySQL может
<span><span>помечать как удаленные</span></span> и удалять строки на сжатых
страницах <span><span>на месте</span></span>, изменяя несжатые данные,
операции<code>DELETE</code> на таблице относительно эффективны.</p>

<p>Для некоторой окружающей среды время, чтобы загрузить данные, может быть
столь же важным, как извлечение во время выполнения. Особенно в окружающей
среде хранилища данных много таблиц могут быть только для чтения или чтения
главным образом. В тех случаях это могло бы или не могло бы быть приемлемым
заплатить цену сжатия с точки зрения увеличенного времени загрузки, если
получающиеся сбережения в меньшем количестве дисковых чтений или в стоимости
хранения не являются существенными.</p>

<p>Сжатие работает лучше всего, когда время центрального процессора доступно
для сжатия и разсжатия данных. Таким образом, если Ваша рабочая нагрузка
ввод/вывод, а не центральный процессор, сжатие может улучшить эффективность
работы. Когда Вы проверяете потребительские свойства с различными
конфигурациями сжатия, проверяйте на платформе, подобной запланированной
конфигурации производственной системы.</p>

<h5><a name="innodb-compression-tuning-when-config"></a>
Характеристики конфигурации и сжатие</h5>
<p>Чтение и запись <a href="glossary.htm#glos_page">страниц</a>
базы данных с диска являются самым медленным аспектом работы. Сжатие
пытается уменьшить ввод/вывод при использовании времени центрального
процессора, чтобы сжать данные, и является самым эффективным, когда
ввод/вывод относительно недостаточный ресурс по
сравнению с циклами процессора.</p>

<p>Когда страница сжатой таблицы находится в памяти, MySQL часто использует
дополнительную память, как правило 16 КБ, в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>
для несжатой копии страницы. Адаптивный алгоритм LRU пытается сбалансировать
использование памяти между сжатыми и несжатыми страницами, чтобы принять во
внимание, работает ли рабочая нагрузка в манере I/O или CPU.
Однако, конфигурация с большей памятью, посвященной буферному пулу, имеет
тенденцию работать лучше, когда используется сжатие таблицы, чем
конфигурация, где память чрезвычайно ограничена.</p>

<h5><a name="innodb-compression-tuning-when-size"></a>
Выбор сжатого размера страницы</h5>
<p>Оптимальная установка сжатого размера страницы зависит от типа и
распределения данных, которые содержат индекс и таблица.
Сжатый размер страницы должен всегда быть больше, чем максимальный размер
записи, или операции могут потерпеть неудачу.</p>

<p>Устанавливая сжатый размер страницы слишком большим, затратите
некоторое пространство, но страницы не должны быть сжаты часто. Если сжатый
размер страницы установлен слишком маленьким, вставки или обновления могут
потребовать отнимающего много времени пересжатия, и узлы
<a href="glossary.htm#glos_b_tree">B-tree</a>, вероятно, придется разделять
чаще, приводя к большим файлам с данными и менее эффективной индексации.</p>

<p>Как правило, Вы устанавливаете сжатый размер страницы в 8K или 4K.
Учитывая, что максимальный размер строки для таблицы InnoDB составляет
приблизительно 8K, <code>KEY_BLOCK_SIZE=8</code> обычно безопасный выбор.</p>

<h4><a name="innodb-compression-tuning-monitoring"></a>16.9.1.4.
Контроль сжатия во время выполнения</h4>
<p>Полные потребительские свойства, центральный процессор и использование
ввода/вывода и размер дисковых файлов это хорошие индикаторы того,
как эффективно сжатие для Вашего приложения.
Этот раздел основывается на совете из
<a href="#innodb-compression-tuning">раздела 16.9.1.3</a>
и показывает, как найти проблемы, которые не могли бы проявиться во
время начального тестирования.</p>

<p>Вы можете контролировать работу сжатия во время выполнения, используя
таблицы <a href="glossary.htm#glos_information_schema">Information Schema
</a>, описанные в <a href="#innodb-information-schema-examples-compression">
примере 16.10</a>. Эти таблицы отражают внутреннее пользование памяти и
уровни сжатия, используемого повсюду.</p>

<p>Таблица <a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP</code></a>
сообщает о информацию о деятельности сжатия для каждого сжатого размера
страницы (<code>KEY_BLOCK_SIZE</code>). Информация в этих таблицах в масштабе
всей системы: это суммирует статистику сжатия через все сжатые таблицы в
Вашей базе данных. Вы можете использовать эти данные, чтобы помочь решить,
сжать ли таблицу, исследуя эти таблицы, когда ни к каким другим сжатым
таблицам не получают доступ. Это вовлекает относительно низкие издержки
на сервере, таким образом, Вы могли бы периодически запрашивать это на
производственном сервере, чтобы проверить полную эффективность сжатия.</p>

<p>Таблица <a href="inform.htm#innodb-cmp-per-index-table"><code>
INNODB_CMP_PER_INDEX</code></a> сообщает о информацию о деятельности сжатия
для отдельных таблиц и индексов. Эта информация предназначена и более полезна
для того, чтобы оценить эффективность сжатия и диагностировать исполнительные
проблемы одной таблицы или индекса за один раз.
Поскольку каждая таблица представлена как кластеризируемый индекс, MySQL
не делает большое различие между таблицами и индексами в этом контексте.
Таблица <a href="inform.htm#innodb-cmp-per-index-table"><code>
INNODB_CMP_PER_INDEX</code></a> действительно вовлекает существенные
издержки, таким образом, это является более подходящим для серверов развития,
где Вы можете сравнить эффекты различных
<a href="glossary.htm#glos_workload">рабочих нагрузок</a>,
данных и настроек сжатия в изоляции. Чтобы принять меры против наложения
этого контроля на издержки, Вы должны включить опцию
<a href="#sysvar_innodb_cmp_per_index_enabled"><code>
innodb_cmp_per_index_enabled</code></a> прежде, чем Вы сможете запросить
таблицу <a href="inform.htm#innodb-cmp-per-index-table"><code>
INNODB_CMP_PER_INDEX</code></a>.</p>

<p>Ключевые статистические данные являются числом, и количеством времени
на выполнение сжатия. Так как MySQL разделяет узлы
<a href="glossary.htm#glos_b_tree">B-tree</a>, когда они слишком полны,
чтобы содержать сжатые данные после модификации, сравните число
<span><span>успешных</span></span> операций сжатия с числом таких операций
вообще. Основываясь на информации в таблицах
<a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP</code></a> и
<a href="inform.htm#innodb-cmp-per-index-table"><code>INNODB_CMP_PER_INDEX
</code></a>, Вы могли бы произвести изменения в своей конфигурации аппаратных
средств, скорректировать размер буферного пула, выбрать иной размер страницы
или выбрать набор таблиц, чтобы сжать.</p>

<p>Если количество времени центрального процессора, требуемого для сжатия
высоко, изменение на быстрый центральный процессор может помочь улучшить
работу с теми же самыми данными, рабочую нагрузку приложения и набор сжатых
таблиц. Увеличение размера буферного пула могло бы также помочь работе, так,
чтобы несжатые страницы могли остаться в памяти, уменьшая потребность
разсжимать страницы, которые существуют в памяти только в сжатой форме.</p>

<p>Большое количество операций сжатия (по сравнению с числом
<code>INSERT</code>, <code>UPDATE</code> и <code>DELETE</code>
в Вашем приложении и размером базы данных), может указать, что некоторые из
Ваших сжатых таблиц обновляются слишком сильно для эффективного сжатия.
Если это так, выберите больший размер страницы или разберитесь,
которые таблицы Вы сжимаете.</p>

<p>Если число <span><span>успешных</span></span> операций сжатия
(<code>COMPRESS_OPS_OK</code>) выше процента общего количества операций
сжатия (<code>COMPRESS_OPS</code>), тогда система, вероятно, работает хорошо.
Если отношение низко, то MySQL реорганизует, пересжимает и разделяет узлы
B-tree чаще, чем желательно. В этом случае избегайте сжимать некоторые
таблицы или увеличьте <code>KEY_BLOCK_SIZE</code> для некоторых из сжатых
таблиц. Вы могли бы выключить сжатие для таблиц, которые заставляют число
<span><span>неудачных сжатий</span></span> в Вашем приложении составлять
больше 1%-2%. Такое отношение отказа могло бы быть приемлемым во время
временной работы, такой как загрузка данных.</p>

<h4><a name="innodb-compression-internals"></a>16.9.1.5.
Как работает сжатие для таблиц InnoDB</h4>
<p>Этот раздел описывает некоторые внутренние детали выполнения
<a href="glossary.htm#glos_compression">сжатия</a> для таблиц InnoDB.
Информация, представленная здесь, может быть полезной в настройке для работы,
но не необходима, чтобы знать для основного использования сжатия.</p>

<h5><a name="innodb-compression-internals-algorithms"></a>Алгоритмы сжатия
</h5>
<p>Некоторые операционные системы осуществляют сжатие на уровне файловой
системы. Файлы, как правило, делятся на блоки фиксированного размера, которые
сжаты в блоки переменного размера, который легко приводит к фрагментации.
Каждый раз, когда что-то в блоке изменено, целый блок повторно сжат прежде,
чем он будет записан на диск. Эти свойства делают этот метод сжатия
неподходящим для использования в интенсивной обновляемой системе базы данных.
</p>

<p>MySQL осуществляет сжатие с помощью известной библиотеки
<a href="../../../www.zlib.net/default.htm" target="_top">zlib</a>, которая осуществляет
алгоритм сжатия LZ77. Этот алгоритм сжатия является зрелым, здравым и
эффективным в использовании центрального процессора и в сокращении размера
данных. Алгоритм <span><span>без потерь</span></span>, чтобы оригинальные
несжатые данные могли всегда быть восстановлены от сжатой формы. Сжатие LZ77
работает, находя последовательности данных, которые повторены в пределах
данных, которые будут сжаты. Образцы значений в Ваших данных определяют, как
хорошо они сжимаются, но типичные пользовательские данные часто сжимаются на
50% или даже лучше.</p>

<p>В отличие от сжатия, выполненного приложением или особенностями сжатия
некоторых других систем управления базой данных, сжатие InnoDB применяется к
пользовательским данным и индексам. Во многих случаях индекс
может составить 40-50% полного размера базы данных, таким образом, это
различие является существенным. Когда сжатие работает хорошо на наборе
данных, размер файлов с данными InnoDB (табличное пространство
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
<a href="glossary.htm#glos_general_tablespace">общее табличное пространство
</a> файлы <code>.idb</code>) ужимает на 25%-50%. В зависимости от
<a href="glossary.htm#glos_workload">рабочей нагрузки</a>,
эта меньшая база данных может в свою очередь привести к сокращению
ввода/вывода и увеличению пропускной способности по скромной стоимости с
точки зрения увеличенного использования центрального процессора.
Вы можете скорректировать баланс между уровнем сжатия и нагрузкой на
центральный процессор, изменяя параметр
<a href="#sysvar_innodb_compression_level"><code>
innodb_compression_level</code></a>.</p>

<h5><a name="innodb-compression-internals-storage"></a>
Хранение данных InnoDB и сжатие</h5>
<p>Все пользовательские данные в таблицах InnoDB хранятся в страницах,
включающих индекс <a href="glossary.htm#glos_b_tree">B-tree</a>
(<a href="glossary.htm#glos_clustered_index">кластеризируемый индекс</a>).
В некоторых других системах базы данных этот тип индекса назван
<span><span>index-organized table</span></span>. Каждая строка в индексном
узле содержит значение (определенное пользователем или произведенное
системой) <a href="glossary.htm#glos_primary_key">первичного ключа</a>
и все другие столбцы таблицы.</p>

<p><a href="glossary.htm#glos_secondary_index">Вторичные индексы</a> в
InnoDB также B-tree, содержащие пары значений: ключ индекса и указатель на
строку в кластеризируемом индексе. Указатель фактически значение первичного
ключа таблицы, который используется, чтобы получить доступ к
кластеризируемому индексу, если столбцы кроме индексного ключа и первичного
ключа требуются. Вторичный индекс должен всегда соответствовать на
единственной странице B-дерева.</p>

<p>Сжатие узлов B-дерева (кластеризируемого и вторичного индексов)
обработано отлично от сжатия
<a href="glossary.htm#glos_overflow_page">страниц переполнения</a>,
используемых, чтобы хранить столбцы <code>VARCHAR</code>, <code>BLOB</code>
или <code>TEXT</code>, как объяснено в следующих разделах.</p>

<h5><a name="innodb-compression-internals-storage-btree"></a>
Сжатие страниц B-дерева</h5>
<p>Поскольку они часто обновляются, страницы B-дерева требуют специального
режима. Важно минимизировать число раз разделения узлов B-дерева, так же как
минимизировать потребность разсжать и повторно сжать их контент.</p>

<p>Один метод, который использует MySQL, должен поддержать некоторую
информацию о системе в узле B-дерева в несжатой форме, таким образом облегчая
определенные оперативные обновления. Например, это позволяет строкам быть
отмеченными для удаления и удаленными без любой работы подсистемы сжатия.</p>

<p>Кроме того, MySQL пытается избежать ненужного и пересжатия индексных
страниц, когда они изменены. В пределах каждой страницы B-дерева система
сохраняет несжатый <span><span>журнал изменений</span></span>, чтобы сделать
запись изменений, произведенных в странице. Обновления и вставки небольших
записей могут быть записаны в этот журнал модификации не требуя, чтобы вся
страница была полностью восстановлена.</p>

<p>Когда пространство для журнала модификации заканчивается, InnoDB разжимает
страницу, применяет изменения и повторно сжимает страницу.
Если пересжатие терпит неудачу (ситуация, известная как
<a href="glossary.htm#glos_compression_failure">отказ сжатия</a>),
узлы B-дерева разделены, и процесс повторен до успеха.</p>

<p>Чтобы избежать частых отказов сжатия в интенсивных по записи
рабочих нагрузках, что касается приложений <a href="glossary.htm#glos_oltp">
OLTP</a>, MySQL иногда резервирует некоторое пустое место (дополнение) в
странице, чтобы журнал модификации заполнился скорее, и страница повторно
сжата, в то время как есть все еще достаточно места, чтобы избежать
разделения. Количество дополнения пространства, оставленного в каждой
странице, изменяется, поскольку система отслеживает частоту разделений
страницы. На занятом сервере, делающем частые записи
сжатых таблиц, Вы можете корректировать опции
<a href="#sysvar_innodb_compression_failure_threshold_pct"><code>
innodb_compression_failure_threshold_pct</code></a> и
<a href="#sysvar_innodb_compression_pad_pct_max"><code>
innodb_compression_pad_pct_max</code></a> и точно настроить этот механизм.
</p>

<p>Вообще, MySQL требует, чтобы каждая страница B-дерева в таблице InnoDB
могла вместить по крайней мере две записи. Для сжатых таблиц было смягчено
это требование. Страницы листа узлов B-дерева
(из первичного ключа или вторичного) должны вмещать только одну запись, но
что она должна заполниться, в несжатой форме, в журнале модификации для
страницы. Если <a href="#sysvar_innodb_strict_mode"><code>
innodb_strict_mode</code></a> <code>ON</code>, MySQL
проверяет максимальный размер строки во время
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a>.
Если строка не соответствует, следующее сообщение об ошибке выпущено:
<code>ERROR HY000: Too big row</code>.</p>

<p>Если Вы составляете таблицу, когда
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> OFF, и последующий <code>INSERT</code> или <code>UPDATE</code>
пытается создать индексную запись, которая не помещается в размер сжатой
страницы, работа терпит неудачу с <code>ERROR 42000: Row size too large
</code>. Это сообщение об ошибке не называет индекс, для которого запись
является слишком большой, или упоминает длину индексной записи или
максимального размера записи на этой индексной странице.
Чтобы решить эту проблему, пересоздайте таблицу с помощью
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
и выберите больший сжатый размер страницы (<code>KEY_BLOCK_SIZE</code>),
сократите префикс столбца индекса или отключите сжатие полностью с
<code>ROW_FORMAT=DYNAMIC</code> или <code>ROW_FORMAT=COMPACT</code>.</p>

<p><a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> не применимо к общим табличным пространствам, которые также
поддерживают сжатые таблицы. Управленческие правила табличного пространства
для общих табличных пространств строго проведены в жизнь, независимо от
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a>. Подробности в <a href="sql.htm#create-tablespace">разделе
14.1.16</a>.</p>

<h5><a name="innodb-compression-internals-storage-blobs"></a>
Сжатие BLOB, VARCHAR и TEXT</h5>
<p>В таблице столбцы <a href="types.htm#blob"><code>BLOB</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>, которые не являются частью
первичного ключа, могут быть сохранены на отдельно выделенных
<a href="glossary.htm#glos_overflow_page">страницах переполнения</a>.
Мы именуем эти столбцы
<a href="glossary.htm#glos_off_page_column">столбцы вне страницы</a>. Их
значения сохранены в отдельно-связанных списках страниц переполнения.</p>

<p>Для таблиц, составленных с <code>ROW_FORMAT=DYNAMIC</code> или
<code>ROW_FORMAT=COMPRESSED</code>, значения
<a href="types.htm#blob"><code>BLOB</code></a>,
<a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#char"><code>VARCHAR</code></a> могут быть сохранены
полностью вне страницы, в зависимости от их длины и длины всей строки. Для
столбцов, которые сохранены вне страницы, кластеризируемые индексные записи
содержит только 20-байтовые указатели на страницы переполнения, один на
столбец. Сохранены ли какие-либо столбцы вне страницы, зависит от размера
страницы и полного размера строки. Когда строка является слишком длинной,
чтобы поместиться полностью в пределах страницы кластеризируемого индекса,
MySQL выбирает самые длинные столбцы для хранения вне страницы на
кластеризируемой индексной странице. Как отмечено выше, если строка не
помещается отдельно на сжатой странице, происходит ошибка.</p>

<p>Для таблиц, составленных в <code>ROW_FORMAT=DYNAMIC</code> или
<code>ROW_FORMAT=COMPRESSED</code>, столбцы
<a href="types.htm#blob"><code>TEXT</code></a> и
<a href="types.htm#blob"><code>BLOB</code></a>, которые меньше или равны 40
байтам, всегда сохранены местно.</p>

<p>Таблицы с <code>ROW_FORMAT=REDUNDANT</code> и
<code>ROW_FORMAT=COMPACT</code> сохраняют первые 768 байтов
столбцов <a href="types.htm#blob"><code>BLOB</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a> в кластеризируемой индексной
записи наряду с первичным ключом. 768-байтовая приставка сопровождается
20-байтовым указателем на страницы переполнения, которые содержат остальную
часть значения столбца.</p>

<p>Когда таблица находится в формате <code>COMPRESSED</code>,
все данные, написанные на страницу переполнения, сжаты <span><span>как есть
</span></span>, то есть, MySQL применяет алгоритм сжатия zlib ко всему
элементу данных. Кроме данных, сжатые страницы переполнения содержат несжатый
заголовок и метку конца, включающую контрольную сумму страницы и ссылку на
следующую страницу переполнения. Поэтому, очень существенная экономия
хранения может быть получена для больших <code>BLOB</code>, <code>TEXT</code>
или <code>VARCHAR</code>, если данные очень сжимаемы, как это часто бывает с
текстовыми данными. Данные изображений (к примеру, <code>JPEG</code>),
как правило, уже сжаты и не извлекают выгоду из сохранения в сжатой таблице,
двойное сжатие может потратить впустую циклы центрального процессора для
небольшой или никакой экономии пространства.</p>

<p>Страницы переполнения имеют тот же самый размер, как другие страницы.
Строка, содержащая десять столбцов, сохраненная вне страницы, занимает десять
страниц переполнения, даже если полная длина столбцов составляет только 8K.
В несжатой таблице десять несжатых страниц переполнения занимают 160K.
В сжатой таблице с размером страницы 8K они занимают только 80K.
Таким образом, часто более эффективно использовать сжатый формат таблицы для
таблиц с длинными значениями столбцов.</p>

<p>Для табличных пространств <a href="glossary.htm#glos_file_per_table">
file-per-table</a>, используя размера сжатой страницы 16K,
можно уменьшить затраты ввода/вывода для
<a href="types.htm#blob"><code>BLOB</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>, потому что такие данные часто
сжимаются хорошо, и могли бы поэтому потребовать меньшего количества страниц
переполнения, даже при том, что узлы самого B-дерева берут так много страниц
в несжатой форме. Общие табличные пространства не поддерживают
размер сжатой страницы 16K (<code>KEY_BLOCK_SIZE</code>). Подробности в
<a href="#general-tablespaces">разделе 16.7.9</a>.</p>

<h5><a name="innodb-compression-internals-pool"></a>Сжатие и буферный пул
</h5>
<p>В сжатой таблице каждая сжатая страница соответствует несжатой странице
16K (или меньшего размера, если <a href="#sysvar_innodb_page_size">
<code>innodb_page_size</code></a> задана). Чтобы получить доступ к данным в
странице, MySQL читает сжатую страницу с диска, если это еще не находится в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>,
затем разсжимает страницу к оригинальной форме. Этот раздел описывает, как
<code>InnoDB</code> управляет буферным пулом относительно
страниц сжатых таблиц.</p>

<p>Чтобы минимизировать ввод/вывод и уменьшить потребность расжимать
страницу, буферный пул содержит сжатую и несжатую форму страницы базы данных.
Чтобы создать место для других необходимых страниц базы данных, MySQL может
<a href="glossary.htm#glos_eviction">вычеркнуть</a> из буферного пула
несжатую страницу, оставляя сжатую страницу в памяти. Или, если к странице не
получили доступ некоторое время, сжатая форма страницы могла бы быть записана
на диск, освобождая пространство для других данных. Таким образом, в любой
момент времени буферный пул мог бы содержать сжатые и несжатые формы
страницы, только сжатую форму страницы, или ни одной.</p>

<p>MySQL отслеживает, какие страницы хранятся в памяти, а какие можно
вычеркнуть с применением алгоритма (<a href="glossary.htm#glos_lru">LRU</a>),
чтобы <a href="glossary.htm#glos_hot">горячие</a> (часто используемые)
данные имели тенденцию оставаться в памяти. Когда к сжатым таблицам получают
доступ, MySQL использует адаптивный алгоритм LRU, чтобы достигнуть
соответствующего баланса сжатых и несжатых страниц в памяти.
Этот адаптивный алгоритм чувствителен к тому, работает ли система в
нагрузке <a href="glossary.htm#glos_io_bound">I/O-bound</a> или
<a href="glossary.htm#glos_cpu_bound">CPU-bound</a>.
Цель состоит в том, чтобы избежать тратить слишком много времени обработки
на распаковку страниц, когда центральный процессор занят, и избегать делать
лишний ввод/вывод, когда у центрального процессора есть запасные циклы,
которые могут использоваться для того, чтобы разсжать сжатые страницы
(которые могут уже быть в памяти). Когда система I/O-bound, алгоритм
предпочитает вычеркивать несжатую копию страницы, а не обе копии, делать
больше места для других дисковых страниц.
Когда система лимитирована центральным процессором, MySQL предпочитает
вычеркивать сжатую и несжатую страницу, чтобы больше памяти могло
использоваться для <span><span>горячих</span></span> страниц.</p>

<h5><a name="innodb-compression-internals-log"></a>
Сжатие и файлы системного журнала Redo</h5>
<p>Прежде, чем сжатая страница записана в
<a href="glossary.htm#glos_data_files">файл с данными</a>, MySQL пишет
копию страницы в redo-журнал (если это было повторно сжато с прошлого раза,
это было записано в базе данных). Это сделано, чтобы гарантировать, что
журналы, применимы для <a href="glossary.htm#glos_crash_recovery">
восстановления катастрофического отказа</a>, даже в маловероятном случае что
библиотека <code>zlib</code> обновлена, и это изменение начинает проблему
совместимости со сжатием данных. Поэтому, некоторое увеличение размера
<a href="glossary.htm#glos_log_file">файлов системного журнала</a>
или потребность в более частых <a href="glossary.htm#glos_checkpoint">
контрольных точках</a> может ожидаться, используя сжатие. Количество
увеличения размера файла системного журнала или частоты контрольной точки
зависит от числа изменений сжатых страниц.</p>

<p>Чтобы создать сжатую таблицу в табличном пространстве
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> должен быть включен. Нет никакой зависимости
от <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>, составляя сжатую таблицу в общем табличном
пространстве. Для получения дополнительной информации см.
<a href="#general-tablespaces">раздел 16.7.9</a>.</p>

<h4><a name="innodb-performance-compression-oltp"></a>16.9.1.6.
Сжатие для рабочих нагрузок OLTP</h4>
<p>Традиционно <a href="glossary.htm#glos_compression">сжатие</a>
рекомендовалась прежде всего для рабочих нагрузок только для чтения,
например, для <a href="glossary.htm#glos_data_warehouse">хранилища данных
</a>. Распространение устройств хранения данных
<a href="glossary.htm#glos_ssd">SSD</a>, которые являются быстрыми, но
относительно маленькими и дорогими, делает сжатие привлекательным также для
<code>OLTP</code>: высокий трафик, интерактивные веб-сайты могут уменьшить
свои требования хранения и свои операции в секунду ввода/вывода
(<a href="glossary.htm#glos_iops">IOPS</a>) при использовании сжатых таблиц
с приложениями, которые действительно часто используют
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>.</p>

<p>Эти параметры конфигурации позволяют Вам корректировать способ, которым
сжатие работает с акцентом на работу и масштабируемость для разных действий:
</p>

<ul><li><p><a href="#sysvar_innodb_compression_level"><code>
innodb_compression_level</code></a>
позволяет Вам менять степень сжатия или вниз. Более высокое значение
позволяет Вам вместить большее количество данных на устройство хранения,
за счет большего количества времени центрального процессора во время сжатия.
Нижнее значение позволяет Вам уменьшать загрузку центрального процессора,
когда место для хранения не будет важно, или Вы ожидаете, что данные
не особенно сжимаемы.</li>

<li><a href="#sysvar_innodb_compression_failure_threshold_pct">
<code>innodb_compression_failure_threshold_pct</code></a> определяет предел
для <a href="glossary.htm#glos_compression_failure">отказов сжатия</a>
во время обновлений сжатой таблицы. Когда этот порог превышен, MySQL
начинает оставлять дополнительное свободное пространство в пределах каждой
новой сжатой страницы, динамически корректируя количество свободного
пространства до процента размера страницы, определенного
<a href="#sysvar_innodb_compression_pad_pct_max"><code>
innodb_compression_pad_pct_max</code></a>.</li>

<li><a href="#sysvar_innodb_compression_pad_pct_max"><code>
innodb_compression_pad_pct_max</code></a>
позволяет Вам корректировать максимальное количество пространства,
сохраненного в пределах каждой <a href="glossary.htm#glos_page">страницы
</a>, чтобы сделать запись изменений сжатых строк, не пережимая всю страницу
снова. Чем выше значение, тем больше изменений может быть зарегистрировано,
не сжимая повторно страницу. MySQL использует переменное количество
свободного пространства для страниц в пределах каждой сжатой таблицы, только
когда определяемый процент операций сжатия сбоит во время выполнения, требуя,
разделить сжатую страницу.</li>

<li><a href="#sysvar_innodb_log_compressed_pages"><code>
innodb_log_compressed_pages</code></a> позволяет Вам отключать запись образов
<a href="glossary.htm#glos_compression">пересжатых страниц</a>
<a href="glossary.htm#glos_redo_log">журнал redo</a>.
Пересжатие может произойти, когда изменения произведены в сжатых данных. Эта
опция включена по умолчанию, чтобы предотвратить повреждение, которое могло
произойти, если иная версия <code>zlib</code> используется во время
восстановления. Если Вы уверены, что версия <code>zlib</code>
не будет изменяться, отключите
<a href="#sysvar_innodb_log_compressed_pages"><code>
innodb_log_compressed_pages</code></a>, чтобы уменьшить журнал
redo для рабочих нагрузок, которые изменяют сжатые данные.</p></li></ul>

<p>Поскольку работа со сжатыми данными иногда вовлекает хранение сжатых и
несжатых версий страницы в памяти в то же самое время, используя сжатие с
рабочей нагрузкой OLTP-стиля, будьте готовы увеличить значение опции
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>.</p>

<h4><a name="innodb-compression-syntax-warnings"></a>16.9.1.7.
Предупреждения синтаксиса сжатия SQL и ошибки</h4>
<p>Этот раздел описывает предупреждения и ошибки, с которыми Вы можете
столкнуться, используя табличную функцию сжатия с табличными пространствами
<a href="glossary.htm#glos_file_per_table">file-per-table</a> и
<a href="glossary.htm#glos_general_tablespace">
общими табличными пространствами</a>.</p>

<h5><a name="idm139965325242240"></a>Предупреждения синтаксиса сжатия SQL и
ошибки для табличных пространств File-Per-Table</h5>
<p>Когда <a href="#sysvar_innodb_strict_mode"><code>
innodb_strict_mode</code></a> включен (значение по умолчанию), определение
<code>ROW_FORMAT=COMPRESSED</code> или
<code>KEY_BLOCK_SIZE</code> в <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> или <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a> производит следующую ошибку, если
<a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a> отключен.
<pre>
ERROR 1031 (HY000): Table storage engine for 't1' doesn't have this option
</pre>

<p>Таблица не составлена, если текущая конфигурация не разрешает
использовать сжатые таблицы.</p>
<p>Когда <a href="#sysvar_innodb_strict_mode"><code>
innodb_strict_mode</code></a> отключен, определение
<code>ROW_FORMAT=COMPRESSED</code> или
<code>KEY_BLOCK_SIZE</code> в <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> или <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a> производят следующие предупреждения, если
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> отключен.
<pre>
mysql&gt; SHOW WARNINGS;
+---------+------+---------------------------------------------------------------+
| Level   | Code | Message                                                       |
+---------+------+---------------------------------------------------------------+
| Warning | 1478 | InnoDB: KEY_BLOCK_SIZE requires innodb_file_per_table.        |
| Warning | 1478 | InnoDB: ignoring KEY_BLOCK_SIZE=4.                            |
| Warning | 1478 | InnoDB: ROW_FORMAT=COMPRESSED requires innodb_file_per_table. |
| Warning | 1478 | InnoDB: assuming ROW_FORMAT=DYNAMIC.                          |
+---------+------+---------------------------------------------------------------+
</pre>

<p>Эти сообщения только предупреждения, не ошибки, и таблица составлена без
сжатия, как будто опции не были определены.</p>
<p>Поведение <span><span>non-strict</span></span>
позволяет Вам импортировать файл <code>mysqldump</code>
в базу данных, которая не поддерживает сжатые таблицы, даже если исходная
база данных содержала сжатые таблицы. В этом случае MySQL составляет таблицу
в <code>ROW_FORMAT=DYNAMIC</code>.</p>

<p>Чтобы импортировать файл дампа в новую базу данных и обновить таблицы,
поскольку они существуют в оригинальной базе данных, гарантируюйте, что у
сервера есть надлежащая установка для
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>.</p>

<p>Признак <code>KEY_BLOCK_SIZE</code> разрешен только, когда
<code>ROW_FORMAT</code> определен как <code>COMPRESSED</code>
или опущен. Определение <code>KEY_BLOCK_SIZE</code> с любым другим
<code>ROW_FORMAT</code> производит предупреждение, которое Вы можете
рассмотреть с <code>SHOW WARNINGS</code>. Однако, таблица несжата: указанное
<code>KEY_BLOCK_SIZE</code> проигнорировано).</p>

<table border="1">
<thead><tr><th>Уровень</th><th>Code</th><th>Сообщение</th></tr></thead>
<tbody><tr><td>Предупреждение</td><td>1478</td>
<td><code> InnoDB: ignoring KEY_BLOCK_SIZE=<em><code>n</code></em>
unless ROW_FORMAT=COMPRESSED. </code></td></tr></tbody></table>

<p>Если Вы работаете с <a href="#sysvar_innodb_strict_mode"><code>
innodb_strict_mode</code></a>, комбинация <code>KEY_BLOCK_SIZE</code>
с любым <code>ROW_FORMAT</code>, кроме <code>COMPRESSED</code>,
производит ошибку, а не предупреждение, и таблица не составлена.</p>

<p><a href="#innodb-compression-create-and-alter-options-table">
Таблица 16.6</a> обеспечивает краткий обзор опций <code>ROW_FORMAT</code> и
<code>KEY_BLOCK_SIZE</code>, которые используются с
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<a name="innodb-compression-create-and-alter-options-table"></a>
<p><b>Table 16.6. Опции ROW_FORMAT и KEY_BLOCK_SIZE</b></p>
<table border="1">
<thead><tr><th>Опция</th><th>Как использовать</th><th>Описание</th></tr>
</thead>
<tbody><tr><td><code>ROW_FORMAT=REDUNDANT</code></td><td>
Формат хранения, используемый до MySQL 5.0.3</td><td>Менее эффективный, чем
<code>ROW_FORMAT=COMPACT</code>, для обратной совместимости.</td></tr>
<tr><td><code>ROW_FORMAT=COMPACT</code></td><td>Формат хранения по
умолчанию, начиная с MySQL 5.0.3</td><td>Хранит префикс 768 байтов длинных
значений столбцов в кластеризируемой индексной странице, с остающимися
байтами, сохраненными в странице переполнения.</td></tr>
<tr><td><code>ROW_FORMAT=DYNAMIC</code></td><td> </td><td>
Храните значения в пределах кластеризируемой индексной страницы, если они
там поместятся, в противном случае хранит только 20-байтовый указатель на
страницу переполнения (никакого префикса).</td></tr>
<tr><td><code>ROW_FORMAT=COMPRESSED</code></td><td> </td><td>
Сжимает таблицу и индексы с использованием zlib.</td></tr>
<tr><td><code>KEY_BLOCK_SIZE=<em><code>n</code></em></code></td><td> </td>
<td>Определяет сжатый размер страницы 1, 2, 4, 8 или 16 килобайтов,
подразумевает <code>ROW_FORMAT=COMPRESSED</code>. Для общих табличных
пространств <code>KEY_BLOCK_SIZE</code> равный размеру страницы не разрешен.
</td></tr></tbody></table>

<p><a href="#innodb-compression-create-and-alter-errors-table">
Таблица 16.7</a> суммирует состояния ошибки, которые происходят с
определенными комбинациями параметров конфигурации и опций в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
и то, как опции появляются в выводе <code>SHOW TABLE STATUS</code>.</p>

<p>Когда <a href="#sysvar_innodb_strict_mode"><code>
innodb_strict_mode</code></a> <code>OFF</code>, MySQL
создает или изменяет таблицу, но игнорирует определенные настройки как
показано ниже. Вы можете видеть предупреждающие сообщения в журнале ошибок
MySQL. Когда <a href="#sysvar_innodb_strict_mode"><code>
innodb_strict_mode</code></a> <code>ON</code>, эти указанные комбинации опций
производят ошибки, и таблица не составлена или изменена. Чтобы видеть полное
описание состояния ошибки, скомандуйте <code>SHOW ERRORS</code>:</p>

<pre>
mysql&gt; CREATE TABLE x (id INT PRIMARY KEY, c INT)
    -&gt; ENGINE=INNODB KEY_BLOCK_SIZE=33333;
ERROR 1005 (HY000): Can't create table 'test.x' (errno: 1478)

mysql&gt; SHOW ERRORS;
+-------+------+-------------------------------------------+
| Level | Code | Message                                   |
+-------+------+-------------------------------------------+
| Error | 1478 | InnoDB: invalid KEY_BLOCK_SIZE=33333.     |
| Error | 1005 | Can't create table 'test.x' (errno: 1478) |
+-------+------+-------------------------------------------+
</pre>

<a name="innodb-compression-create-and-alter-errors-table"></a>
<p><b>Таблица 16.7. Предупреждения и ошибки CREATE/ALTER TABLE, когда
InnoDB Strict Mode OFF</b></p>
<table border="1">
<thead><tr><th>Синтаксис</th><th>Предупреждение или состояние ошибки</th>
<th>Результирующий <code>ROW_FORMAT</code>, как показано в
<code>SHOW TABLE STATUS</code></th></tr></thead>
<tbody><tr><td><code>ROW_FORMAT=REDUNDANT</code></td><td>Нет</td>
<td><code>REDUNDANT</code></td></tr>
<tr><td><code>ROW_FORMAT=COMPACT</code></td><td>Нет</td><td><code>COMPACT
</code></td></tr>
<tr><td><code>ROW_FORMAT=COMPRESSED</code>, <code>ROW_FORMAT=DYNAMIC</code>
или <code>KEY_BLOCK_SIZE</code> указан</td><td>Проигнорирован для табличных
пространств file-per-table, если включена
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a>. Общие табличные пространства поддерживают все форматы строки.
См. <a href="#general-tablespaces">раздел 16.7.9</a>.</td>
<td><code>Формат строки по умолчанию для file-per-table, указанный формат
строки для общего табличного пространства</code></td></tr>
<tr><td>Неправильный <code>KEY_BLOCK_SIZE</code> (не 1, 2, 4, 8 или 16)</td>
<td><code>KEY_BLOCK_SIZE</code> пропущен</td><td>
Указанный формат строки или формат строки по умолчанию</td></tr>
<tr><td><code>ROW_FORMAT=COMPRESSED</code> и допустимый
<code>KEY_BLOCK_SIZE</code> определены</td><td>Нет, используется определенный
<code>KEY_BLOCK_SIZE</code></td><td><code>COMPRESSED</code></td></tr>
<tr><td><code>KEY_BLOCK_SIZE</code> определен с форматом строки
<code>REDUNDANT</code>, <code>COMPACT</code> или <code>DYNAMIC</code></td>
<td><code>KEY_BLOCK_SIZE</code> пропущен</td><td><code>REDUNDANT</code>,
<code>COMPACT</code> или <code>DYNAMIC</code></td></tr>
<tr><td><code>ROW_FORMAT</code> не <code>REDUNDANT</code>,
<code>COMPACT</code>, <code>DYNAMIC</code> или <code>COMPRESSED</code></td>
<td>Проигнорирован, если признан анализатором MySQL. Иначе ошибка.</td>
<td>Формат строки значения по умолчанию или N/A</td></tr></tbody></table>

<p>Когда <code>innodb_strict_mode</code> <code>ON</code>, MySQL
отклоняет недопустимый <code>ROW_FORMAT</code> или
<code>KEY_BLOCK_SIZE</code> и выдает ошибку. Строгий режим
<code>ON</code> по умолчанию. Когда <code>innodb_strict_mode</code>
<code>OFF</code>, MySQL выдает предупреждения вместо ошибок для
проигнорированных недопустимых параметров.</p>

<p>Невозможно видеть выбранный <code>KEY_BLOCK_SIZE</code> через
<code>SHOW TABLE STATUS</code>. <code>SHOW CREATE TABLE</code> покажет
<code>KEY_BLOCK_SIZE</code> (даже если это было проигнорировано, составляя
таблицу). Реальный сжатый размер страницы таблицы не может быть выведен
на экран MySQL.</p>

<h5><a name="idm139965325114576"></a>Предупреждения синтаксиса сжатия SQL и
ошибки для общих табличных пространств</h5>
<ul><li><p>Если <code>FILE_BLOCK_SIZE</code> не был определен для общего
табличного пространства, когда табличное пространство создавалось, табличное
пространство не может содержать сжатые таблицы. Если Вы пытаетесь добавить
сжатую таблицу, ошибка возвращена, как показано в следующем примере:
<pre>
mysql&gt; CREATE TABLESPACE `ts1` ADD DATAFILE 'ts1.ibd' Engine=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE t1 (c1 INT PRIMARY KEY) TABLESPACE ts1
                 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=8;
ERROR 1478 (HY000): InnoDB: Tablespace `ts1` cannot
                    contain a COMPRESSED table
</pre></li>

<li>Попытка добавить таблицу с недопустимым <code>KEY_BLOCK_SIZE</code>
к общему табличному пространству возвращает ошибку, как
показано в следующем примере:
<pre>
mysql&gt; CREATE TABLESPACE `ts2` ADD DATAFILE 'ts2.ibd'
                 FILE_BLOCK_SIZE = 8192 Engine=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE t2 (c1 INT PRIMARY KEY) TABLESPACE ts2
                 ROW_FORMAT=COMPRESSED KEY_BLOCK_SIZE=4;
ERROR 1478 (HY000): InnoDB: Tablespace `ts2` uses block size 8192 and cannot
                    contain a table with physical page size 4096
</pre>

<p>Для общих табличных пространств <code>KEY_BLOCK_SIZE</code>
из таблицы должно быть равным <code>FILE_BLOCK_SIZE</code>
из табличного пространства, разделенного на 1024. Например, если
<code>FILE_BLOCK_SIZE</code> 8192, то <code>KEY_BLOCK_SIZE</code> 8.</li>

<li>Попытка добавить таблицу с несжатым форматом строки к общему табличному
пространству, сконфигурированному, чтобы сохранить сжатые таблицы, возвращает
ошибку, как показано в следующем примере:
<pre>
mysql&gt; CREATE TABLESPACE `ts3` ADD DATAFILE 'ts3.ibd'
                 FILE_BLOCK_SIZE = 8192 Engine=InnoDB;
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE t3 (c1 INT PRIMARY KEY) TABLESPACE ts3
                 ROW_FORMAT=COMPACT;
ERROR 1478 (HY000): InnoDB: Tablespace `ts3` uses block size 8192 and cannot
                    contain a table with physical page size 16384
</pre></li></ul>

<p><a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> не применимо к общим табличным пространствам. Управленческие
правила табличного пространства для общих табличных пространств строго
проведены в жизнь независимо от
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a>. Подробности в <a href="sql.htm#create-tablespace">разделе
14.1.16</a>.</p>

<h3><a name="innodb-page-compression"></a>16.9.2. Сжатие страницы InnoDB</h3>
<p><code>InnoDB</code> поддерживает сжатие на уровне страницы для таблиц,
которые находятся в табличных пространствах
<a href="glossary.htm#glos_file_per_table">file-per-table</a>. Эта
особенность упоминается как <span><em>Прозрачное сжатие страницы</em></span>.
Сжатие страницы включено, определяя <code>COMPRESSION</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Поддержанные
алгоритмы сжатия включают <code>Zlib</code> и <code>LZ4</code>.</p>

<h4><a name="idm139965325085120"></a>Поддержанные платформы</h4>
<p>Сжатие страницы поддержано на Windows с NTFS, и на следующем подмножестве
MySQL-поддержанных платформ Linux, где уровень ядра оказывает
поддержку hole punching:</p>

<ul><li><p>RHEL 7 и полученные дистрибутивы, которые используют версию
ядра 3.10.0-123 или выше.</li>
<li>OEL 5.10 (UEK2) ядро версии 2.6.39 или выше.</li>

<li>OEL 6.5 (UEK3) kernel version 3.8.13 или выше.</li>
<li>OEL 7.0 kernel version 3.8.13 или выше.</li>
<li>SLE11 kernel version 3.0-x</li>

<li>SLE12 kernel version 3.12-x</li>
<li>OES11 kernel version 3.0-x</li>
<li>Ubuntu 14.0.4 LTS kernel version 3.13 или выше.</li>
<li>Ubuntu 12.0.4 LTS kernel version 3.2 или выше.</li>
<li>Debian 7 kernel version 3.2 или выше.</p></li></ul>
<p>Все доступные файловые системы для данного дистрибутива Linux,
возможно, не поддерживают hole punching.</p>

<h4><a name="idm139965325074000"></a>Как сжатие страницы работает</h4>
<p>Когда страница написана, она сжата, используя указанный алгоритм сжатия.
Если сжатие терпит неудачу, данные записаны как есть.</p>

<h4><a name="idm139965325072592"></a>Hole Punch в Linux</h4>
<p>В Linux размер блока файловой системы это
размер модуля, используемый для hole punching. Поэтому сжатие страницы
работает только, если данные о странице могут быть сжаты к размеру, который
меньше или равен размеру страницы минус размер блока файловой системы.
Например, если <a href="#sysvar_innodb_page_size"><code>
innodb_page_size=16K</code></a> и размер блока файловой системы составляет
4K, данные о странице должны в сжатом виде быть меньше или равны 12K.</p>

<h4><a name="idm139965325069104"></a>Hole Punch в Windows</h4>
<p>В Windows основная инфраструктура для sparse-файлов
основана на сжатии NTFS. Размер Hole punching это модуль сжатия NTFS, который
в 16 раз больше размером кластера NTFS.
Размеры кластера и их модули сжатия показаны в следующей таблице:</p>

<a name="idm139965325067680"></a><p><b>Таблица 16.8. Размер кластера и
модули сжатия NTFS</b></p>
<table border="1">
<thead><tr><th>Размер кластера</th><th>Модуль сжатия</th></tr></thead>
<tbody><tr><td>512 байт</td><td>8 KB</td></tr>
<tr><td>1 KB</td><td>16 KB</td></tr>
<tr><td>2 KB</td><td>32 KB</td></tr>
<tr><td>4 KB</td><td>64 KB</td></tr></tbody></table>

<p>Сжатие страницы на системах Windows работает, если данные о странице могут
быть сжаты к размеру, который меньше или равен
размеру страницы минус размер модуля сжатия.</p>

<p>Размер кластера NTFS по умолчанию составляет 4K,
для которого размер модуля сжатия составляет 64K.
Это означает, что сжатие страницы не обладает никаким преимуществом для
Windows NTFS, поскольку максимум
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> 64K.</p>

<p>Для сжатия страницы под Windows файловая система должна быть создана с
размером кластера меньше 4K, и
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> должен быть, по крайней мере, двойным размером модуля сжатия. Например,
для сжатия страницы в Windows Вы могли создать файловую систему с размером
кластера 512 байтов (у которого есть модуль сжатия 8 КБ) и инициализировать
<code>InnoDB</code> с <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a> 16K или больше.</p>

<h4><a name="idm139965325049984"></a>Включение сжатия страницы</h4>
<p>Чтобы включить сжатие страницы, определите атрибут
<code>COMPRESSION</code> в <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a>:
<pre>
CREATE TABLE t1 (c1 INT) COMPRESSION="zlib";
</pre>

<p>Вы можете также включить сжатие страницы в
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Но
<a href="sql.htm#alter-table"><code>ALTER TABLE ... COMPRESSION</code></a>
только обновляет признак сжатия табличного пространства.
Записи в табличное пространство, которые происходят после установки нового
алгоритма сжатия, используют новую установку, но чтобы применять новый
алгоритм сжатия к существующим страницам, Вы должны пересоздать таблицу с
использованием <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code>
</a>.
<pre>
ALTER TABLE t1 COMPRESSION="zlib";
OPTIMIZE TABLE t1;
</pre>

<h4><a name="idm139965325040944"></a>Отключение сжатия страницы</h4>
<p>Чтобы отключить сжатие страницы, установите <code>COMPRESSION=None</code>
через <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Записи в табличное пространство, которые происходят после установки
<code>COMPRESSION=None</code>, больше не используют сжатие страницы. Чтобы
распаковать существующие страницы, Вы должны пересоздать таблицу с
использованием <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code>
</a> после установки <code>COMPRESSION=None</code>.
<pre>
ALTER TABLE t1 COMPRESSION="None";
OPTIMIZE TABLE t1;
</pre>

<h4><a name="idm139965325034288"></a>Метаданные о сжатии страницы</h4>
<p>Метаданные о сжатии страницы найдены в таблице
<a href="inform.htm#innodb-sys-tablespaces-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a> в следующих столбцах:
</p>

<ul><li><p><code>FS_BLOCK_SIZE</code>: Размер блока файловой системы, который
является размером модуля, используемым для hole punching.</li>
<li><code>FILE_SIZE</code>: Размер файла, который представляет максимальный
размер несжатого файла.</li>
<li><code>ALLOCATED_SIZE</code>: Фактический размер файла, который является
количеством места, выделенного на диске.</p></li></ul>

<p>Примените <a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE
</code></a>, чтобы смотреть текущую установку сжатия страницы
(<code>Zlib</code>, <code>Lz4</code> или <code>None</code>). Таблица может
содержать соединение страниц с различными настройками сжатия.</p>

<p>В следующем примере метаданные о сжатии страницы для таблицы служащих
получены от <a href="inform.htm#innodb-sys-tablespaces-table">
<code>INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a>.
<pre>
# Create the employees table with Zlib page compression
CREATE TABLE employees (emp_no INT NOT NULL, birth_date DATE NOT NULL,
                        first_name VARCHAR(14) NOT NULL,
                        last_name VARCHAR(16) NOT NULL,
                        gender ENUM ('M','F') NOT NULL,
                        hire_date DATE NOT NULL, PRIMARY KEY (emp_no))
                        COMPRESSION="zlib";

# Insert data (not shown)
# Query page compression metadata in INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES

mysql&gt; SELECT SPACE, NAME, FS_BLOCK_SIZE, FILE_SIZE, ALLOCATED_SIZE FROM
                 INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES
                 WHERE NAME='employees/employees'\G
*************************** 1. row ***************************
SPACE: 45
NAME: employees/employees
FS_BLOCK_SIZE: 4096
FILE_SIZE: 23068672
ALLOCATED_SIZE: 19415040
</pre>

<p>Метаданные о сжатии страницы для таблицы служащих показывают, что
очевидный размер файла составляет 23068672 байта, в то время как фактический
размер файла (со сжатием страницы) составляет 19415040 байт. Размер блока
файловой системы составляет 4096 байтов, что является размером блока,
используемым для hole punching.</p>

<h4><a name="idm139965325018128"></a>
Ограничения сжатия страницы и примечания использования</h4>
<ul><li><p>Сжатие страницы отключено, если размер блока файловой системы (или
размер модуля сжатия в Windows) * 2 &gt;
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>.</li>

<li>Сжатие страницы не поддержано для таблиц, которые находятся в совместно
используемых табличных пространствах, которые включают системное табличное
пространство, временное табличное пространство и общие табличные пространства.
</li>

<li>Сжатие страницы не поддержано для табличных пространств журнала отмены.
</li>
<li>Сжатие страницы не поддержано для страниц журнала redo.</li>
<li>Страницы R-дерева, которые используются для пространственного
индекса, не сжаты.</li>

<li>Страницы, которые принадлежат сжатым таблицам
(<code>ROW_FORMAT=COMPRESSED</code>) оставлены как есть.</li>
<li>Во время восстановления обновленные страницы записаны в несжатой форме.
</li>

<li>Загрузка сжатого табличного пространства на сервере, который не
поддерживает алгоритм сжатия, который использовался, вызывает
ошибку ввода/вывода.</li>

<li>Прежде, чем откатиться к более ранней версии MySQL, который не делает
сжатия страниц, распакуйте таблицы, которые используют функцию сжатия
страницы. Чтобы распаковать таблицу, скомандуйте
<a href="sql.htm#alter-table"><code>ALTER TABLE ... COMPRESSION=None</code>
</a> и <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.</li>

<li>Сжатые странично табличные пространства могут быть скопированы между
Linux и серверами Windows, если алгоритм сжатия, который использовался,
доступен на обоих серверах.</li>

<li>Сохранение сжатия страницы, перемещая сжатый файл табличного пространства
от одного узла до другого требует утилиты, которая сохраняет sparse-файлы.
</li>
<li>Лучшее сжатие страницы может быть достигнуто на аппаратных средствах
Fusion-io с NVMFS, чем на других платформах, поскольку NVMFS разработан,
чтобы использовать в своих интересах функциональность punch hole.</li>

<li>Использование функции сжатия страницы с большим
размером страницы и относительно маленьким размером блока файловой системы
может привести к увеличению записи. Например, максимальный размер страницы
<code>InnoDB</code> 64 КБ с размером блока файловой системы 4 КБ может
улучшить сжатие, но может также увеличить требование к буферному пулу,
приводя к увеличенному вводу/выводу.</p></li></ul>

<h2><a name="innodb-row-format"></a>16.10. Форматы хранения и строки InnoDB
</h2>
<p>Этот раздел обсуждает InnoDB, такие как табличное
<a href="glossary.htm#glos_compression">сжатие</a>, хранение вне страницы
длинных значений столбцов переменной длины и большой индексный ключевой
префикс, контролируемые форматом строки таблицы <code>InnoDB</code>.
Это также обсуждает соображения о том, как выбрать правильный формат строки
и совместимость форматов строки между выпусками MySQL.</p>

<h3><a name="innodb-row-format-overview"></a>16.10.1.
Краткий обзор хранения строки InnoDB</h3>
<p>Хранение для строк и связанных столбцов затрагивает работу для запросов и
операций DML. Поскольку больше строк вписывается в единственную дисковую
disk <a href="glossary.htm#glos_page">страницу</a>,
запросы и индексные поиски могут работать быстрее, меньше кэш-памяти
требуется в буферном пуле InnoDB и меньше ввода/вывода нужно, чтобы
записывать обновленные значения для числовых и коротких строковых столбцов.
</p>

<p>Данные в каждой таблице InnoDB разделены на
<a href="glossary.htm#glos_page">страницы</a>. Страницы, которые составляют
каждую таблицу, расположены в структуре данных дерева, названной
<a href="glossary.htm#glos_b_tree">индекс B-tree</a>. Табличные данные и
<a href="glossary.htm#glos_secondary_index">вторичные индексы</a>
применяют этот тип структуры. Индекс B-tree, который представляет всю
таблицу, известен как
<a href="glossary.htm#glos_clustered_index">кластеризируемый индекс</a>,
который организован согласно столбцам
<a href="glossary.htm#glos_primary_key">первичного ключа</a>.
Узлы индексной структуры данных содержат значения всех столбцов в той
строке (для кластеризируемого индекса) или индексные столбцы и столбцы
первичного ключа (для вторичного индекса).</p>

<p>Столбцы переменной длины исключение из этого правила. Столбцы
<code>BLOB</code> и <code>VARCHAR</code> слишком длинные, чтобы поместиться
на странице B-дерева, сохранены на отдельно выделенных дисковых страницах,
названных <a href="glossary.htm#glos_overflow_page">страницами переполнения
</a>. Мы называем такие столбцы <a href="glossary.htm#glos_off_page_column">
столбцами вне страницы</a>. Значения этих столбцов сохранены в
отдельно-связанных списках страниц переполнения, и у каждого такого столбца
есть свой собственный список из одной или более страниц переполнения. В
некоторых случаях префикс длинного значения столбца сохранен в B-дереве,
чтобы избежать тратить впустую место и избавиться от необходимости
читать отдельную страницу.</p>

<p>Следующие разделы описывают, как сконфигурировать формат строки таблицы,
чтобы управлять, как сохранены значения столбцов переменной длины.
Конфигурация формата строки также решает доступность
<a href="glossary.htm#glos_compression">табличного сжатия</a> и поддержки
больших префиксов индексных ключей.</p>

<h3><a name="innodb-row-format-specification"></a>16.10.2.
Определение формата строки для таблицы</h3>
<p>Формат строки по умолчанию определен параметром
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>, у которого есть значение по умолчанию
<code>DYNAMIC</code>. Формат строки по умолчанию используется, когда
табличная опция <code>ROW_FORMAT</code> не определена явно, или когда
определено <code>ROW_FORMAT=DEFAULT</code>.</p>

<p>Формат строки таблицы может быть определен явно, используя
табличную опцию <code>ROW_FORMAT</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>:
<pre>
CREATE TABLE t1 (c1 INT) ROW_FORMAT=DYNAMIC;
</pre>

<p>Явно определенный <code>ROW_FORMAT</code>
переопределяет неявное значение по умолчанию. Определение
<code>ROW_FORMAT=DEFAULT</code> эквивалентно использованию неявного
значения по умолчанию.</p>

<p>Опция <a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>
может быть установлена динамически:
<pre>
mysql&gt; SET GLOBAL innodb_default_row_format=DYNAMIC;
</pre>

<p>Допустимые значения
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a> включают <code>DYNAMIC</code>,
<code>COMPACT</code> и <code>REDUNDANT</code>. Формат строки
<code>COMPRESSED</code>, который не поддержан для использования в системном
табличном пространстве, не может быть определен как значение по умолчанию.
Это может быть определено только явно в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Попытка
установить <a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a> в <code>COMPRESSED</code>
возвращает эту ошибку:
<pre>
mysql&gt; SET GLOBAL innodb_default_row_format=COMPRESSED;
ERROR 1231 (42000): Variable 'innodb_default_row_format'
can't be set to the value of 'COMPRESSED'
</pre>

<p>Недавно составленные таблицы используют формат строки, определенный
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>, когда <code>ROW_FORMAT</code>
не определена явно или когда <code>ROW_FORMAT=DEFAULT</code>.
Например, следующие <a href="sql.htm#create-table"><code>CREATE TABLE</code>
</a> используют формат строки, определенный
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>.
<pre>
CREATE TABLE t1 (c1 INT);
CREATE TABLE t2 (c1 INT) ROW_FORMAT=DEFAULT;
</pre>

<p>Когда опция <code>ROW_FORMAT</code> не определена явно, или когда
<code>ROW_FORMAT=DEFAULT</code>, любая операция, которая пересоздает таблицу,
также тихо изменяет формат строки таблицы к формату, определенному
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>.</p>

<p>Пересоздающие таблицу операции включают
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> с использованием
<code>ALGORITHM=COPY</code> или <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> с использованием <code>ALGORITM=INPLACE</code>,
где табличное восстановление требуется. См.
<a href="#innodb-online-ddl-summary-grid">таблицу 16.9</a>
для краткого обзора состояния операций DDL. <a href="sql.htm#optimize-table">
<code>OPTIMIZE TABLE</code></a> тоже пересоздает таблицу.</p>

<p>Следующий пример демонстрирует восстанавливающую таблицу работу, которая
тихо изменяет формат строки таблицы, составленной без явно
определенного формата строки.
<pre>
mysql&gt; SELECT @@innodb_default_row_format;
+-----------------------------+
| @@innodb_default_row_format |
+-----------------------------+
| dynamic                     |
+-----------------------------+

mysql&gt; CREATE TABLE t1 (c1 INT);
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES
                   WHERE NAME LIKE 'test/t1' \G
*************************** 1. row ***************************
 TABLE_ID: 54
 NAME: test/t1
 FLAG: 33
   N_COLS: 4
SPACE: 35
   ROW_FORMAT: Dynamic
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single

mysql&gt; SET GLOBAL innodb_default_row_format=COMPACT;
mysql&gt; ALTER TABLE t1 ADD COLUMN (c2 INT);
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES
                   WHERE NAME LIKE 'test/t1' \G
*************************** 1. row ***************************
 TABLE_ID: 55
 NAME: test/t1
 FLAG: 1
   N_COLS: 5
SPACE: 36
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
   SPACE_TYPE: Single
</pre>

<p>Рассмотрите следующие потенциальные проблемы прежде, чем изменить формат
строки существующих таблиц с <code>REDUNDANT</code> или
<code>COMPACT</code> на <code>DYNAMIC</code>.</p>

<ul><li><p><code>REDUNDANT</code> и <code>COMPACT</code>
поддерживают префикс индексного ключа максимум в 767 байт, тогда как
<code>DYNAMIC</code> и <code>COMPRESSED</code> допускают префикс индексного
ключа в 3072 байт. В среде репликации, если
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a> установлен в <code>DYNAMIC</code>
на ведущем устройстве и в <code>COMPACT</code> на ведомом устройстве,
следующий запрос DDL, который явно не определяет формат строки, работает на
ведущем устройстве, но терпит неудачу на ведомом устройстве:
<pre>
CREATE TABLE t1 (c1 INT PRIMARY KEY, c2 VARCHAR(5000), KEY i1(c2(3070)));
</pre>
<p>Подробности в <a href="#innodb-restrictions">разделе 16.8.7</a>.
</li>

<li>Импортирование таблицы, которая явно не определяет формат строки,
заканчивается ошибкой несоответствия схемы, если
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a> на исходном сервере отличается от
установки на целевом сервере. Для получения дополнительной информации,
обратитесь к ограничениям, обрисованным в общих чертах в
<a href="#tablespace-copying">разделе 16.7.6</a>.</p></li></ul>

<p>Чтобы смотреть формат строки таблицы, скомандуйте
<a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS</code></a> или
запросите <a href="inform.htm#tables-table"><code>INFORMATION_SCHEMA.TABLES
</code></a>.
<pre>
SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES
         WHERE NAME LIKE 'test/t1' \G
</pre>
<p>Формат строки определяет физическую структуру строки. См.
<a href="#innodb-physical-record">раздел 16.8.2</a>.</p>

<h3><a name="innodb-row-format-dynamic"></a>16.10.3.
Форматы строки DYNAMIC и COMPRESSED</h3>
<p>Когда таблица составлена с <code>ROW_FORMAT=DYNAMIC</code> или
<code>ROW_FORMAT=COMPRESSED</code>, <code>InnoDB</code>
может сохранить длинные значения столбцов переменной длины (для типов
<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>)
полностью вне страницы, с кластеризируемой индексной записью, содержащий
только 20-байтовый указатель на страницу переполнения. <code>InnoDB</code>
может также сохранить значения столбцов <a href="types.htm#char"><code>CHAR
</code></a> вне страницы, если значение столбца больше или равно 768 байтам,
что может произойти, если максимальная длина байта набора символов больше 3,
как это с набором <code>utf8mb4</code>.</p>

<p>Сохранены ли какие-либо столбцы вне страницы, зависит от размера страницы
и полного размера строки. Когда строка является слишком длинной,
<code>InnoDB</code> выбирает самые длинные столбцы для хранения вне страницы,
пока записи кластеризируемого индекса помещаются на странице
<a href="glossary.htm#glos_b_tree">B-tree</a>. Столбцы
<a href="types.htm#blob"><code>TEXT</code></a> и
<a href="types.htm#blob"><code>BLOB</code></a>, которые меньше или равны 40
байтам, всегда сохранены на месте.</p>

<p>Формат строки <code>DYNAMIC</code> поддерживает эффективность хранения
всей строки в индексном узле, если она там помещается (так же, как и форматы
<code>COMPACT</code> и <code>REDUNDANT</code>), но <code>DYNAMIC</code>
избегает проблемы заполняющихся узлов B-дерева с большим количеством байтов
данных длинных столбцов. <code>DYNAMIC</code> основан на идее, что если часть
большого значения данных сохранена вне страницы, обычно самым эффективным
будет сохранить все значение вне страницы. С форматом <code>DYNAMIC</code>
более короткие столбцы, вероятно, останутся в узле B-дерева, минимизируя
число страниц переполнения, необходимых для любой данной строки.</p>

<p>Формат строки <code>COMPRESSED</code>
использует подобные внутренние детали для хранения вне страницы, как
<code>DYNAMIC</code> с дополнительными соображениями в плане
сжатых данных таблицы и индекса и использования меньших размеров страницы. С
<code>COMPRESSED</code> опция <code>KEY_BLOCK_SIZE</code>
управляет, сколько данных столбца хранится в кластеризируемом индексе, а
сколько помещено на страницах переполнения. Для полного изложения
формата <code>COMPRESSED</code> см.
<a href="#innodb-compression">раздел 16.9</a>.</p>

<p><code>DYNAMIC</code> и <code>COMPRESSED</code> поддерживают префикс
индексного ключа в 3072 байт.</p>
<p>Таблицы, которые используют <code>COMPRESSED</code>
могут быть создан в табличных пространствах
<a href="glossary.htm#glos_file_per_table">file-per-table</a> или
<a href="glossary.htm#glos_general_tablespace">общих табличных пространствах
</a>. Системное табличное пространство не поддерживает формат строки
<code>COMPRESSED</code>. Чтобы сохранить таблицу <code>COMPRESSED</code>
в табличном пространстве file-per-table, параметр
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> должен быть включен. Опция
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> не применима к общим табличным пространствам.
Общие табличные пространства поддерживают все форматы строки, но сжатые
и несжатые таблицы не могут сосуществовать в том же самом общем табличном
пространстве из-за различных физических размеров страницы. Для получения
дополнительной информации об общих табличных пространствах см.
<a href="#general-tablespaces">раздел 16.7.9</a>.</p>

<p>Таблицы <code>DYNAMIC</code> могут быть сохранены в табличных
пространствах file-per-table, общих табличных пространствах и системном
табличном пространстве. Чтобы сохранить <code>DYNAMIC</code>
в системном табличном пространстве, Вы можете отключить
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> и использовать <code>CREATE TABLE</code> или <code>ALTER TABLE
</code> или Вы можете использовать табличную опцию <code>TABLESPACE
[=] innodb_system</code> с <code>CREATE TABLE</code> или <code>ALTER TABLE
</code> не имея необходимость изменять
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a>. Опция <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> неприменима к общим табличным пространствам,
и при этом они неприменимы, используя опцию <code>TABLESPACE [=]
innodb_system</code>, чтобы сохранить таблицы <code>DYNAMIC</code>
в системном табличном пространстве.</p>

<p><code>InnoDB</code> не поддерживает сжатые временные таблицы. Когда
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> включен (значение по умолчанию),
<a href="sql.htm#create-table"><code>CREATE TEMPORARY TABLE</code></a>
возвращает ошибку, если задан <code>ROW_FORMAT=COMPRESSED</code> или
<code>KEY_BLOCK_SIZE</code>. Если
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> выключен, предупреждения выпущены, и временная таблица
составлена, используя несжатый формат строки.</p>

<p><code>DYNAMIC</code> и <code>COMPRESSED</code> это варианты
<code>COMPACT</code> и поэтому обрабатывают
<a href="types.htm#char"><code>CHAR</code></a> аналогично подходу
<code>COMPACT</code>. Подробности в
<a href="#innodb-physical-record">разделе 16.8.2</a>.</p>

<h3><a name="innodb-row-format-antelope"></a>16.10.4.
Форматы строки COMPACT и REDUNDANT</h3>
<p>Таблицы, которые используют <code>COMPACT</code> или
<code>REDUNDANT</code>, хранят первые 768 байт столбцов переменной длины
(<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>)
в индексной записи в пределах узла
<a href="glossary.htm#glos_b_tree">B-tree</a>
с остатком, сохраненным в страницах переполнения.</p>

<p>Для таблиц, определенных с <code>ROW_FORMAT=COMPACT</code>,
<code>CHAR</code> обработан как столбец переменной длины, если длина значения
столбца больше или равна 768 байтам, что может произойти, если максимальная
длина байта набора символов больше 3, как это с <code>utf8mb4</code>.</p>

<p>Для <code>COMPACT</code> или <code>REDUNDANT</code>
, если значение столбца составляет 768 байтов или меньше, никакая страница
переполнения не нужна и некоторая экономия во вводе/выводе может получиться,
так как значение находится в узле B-дерева. Это работает хорошо на
относительно коротких <code>BLOB</code>, но может заставить узлы B-дерева
заполняться данными, а не значениями ключа, уменьшая их эффективность.
Таблицы со многими столбцами <code>BLOB</code> могут заставить узлы B-дерева
становиться слишком полными данными и содержать слишком мало строк, заставляя
все индексировать менее эффективно, чем если бы строки были короче или если
значения столбцов были сохранены вне страницы.</p>

<p>Формат строки по умолчанию <code>DYNAMIC</code>, как определено опцией
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>. См.
<a href="#innodb-row-format-dynamic">раздел 16.10.3</a>.</p>

<p>Для информации о физической структуре строки таблиц, которые используют
форматы <code>REDUNDANT</code> или <code>COMPACT</code>, см.
<a href="#innodb-physical-record">раздел 16.8.2</a>.</p>

<h2><a name="innodb-disk-management"></a>
16.11. Управление вводом/выводом и местом в файлах</h2>
<p>Как DBA, Вы должны управлять дисковым вводом/выводом, чтобы
препятствовать перегрузке подсистемы ввода/вывода
и управлять дисковым пространством, чтобы избежать переполнения устройства
хранения данных. Модель <a href="glossary.htm#glos_acid">ACID</a>
требует определенного количества ввода/вывода, который мог бы казаться
избыточным, но помогает гарантировать надежность данных. В пределах этих
ограничений <code>InnoDB</code> предпринимает попытки оптимизировать базу
данных и организацию дисковых файлов, чтобы минимизировать количество
дискового ввода/вывода. Иногда, ввод/вывод отложен, пока база данных не
освободится или пока все должно быть приведено в последовательное состояние,
как во время перезапуска базы данных после
<a href="glossary.htm#glos_fast_shutdown">быстрого завершения работы</a>.
</p>

<p>Этот раздел обсуждает основные соображения для ввода/вывода и дискового
пространства с таблицами MySQL <code>InnoDB</code>):</p>
<ul><li><p>Управление количеством фонового ввода/вывода
улучшает работу запроса.</li>

<li>Включение или отключение опций, которые обеспечивают дополнительную
длительность за счет дополнительного ввода/вывода.</li>
<li>Организация таблиц во многие маленькие файлы, несколько больших файлов
или комбинацию обоих вариантов.</li>

<li>Балансирование размера файлов системного журнала против деятельности
ввода/вывода, которая происходит, когда файлы системного
журнала становятся полными.</li>
<li>Как реорганизовать таблицу для оптимальной работы запроса.</p></li></ul>

<h3><a name="innodb-disk-io"></a>16.11.1. Дисковый ввод/вывод</h3>
<p><code>InnoDB</code> использует асинхронный дисковый ввод/вывод где только
возможно, создавая много потоков, чтобы обработать операции ввода/вывода,
разрешая другим операциям базы данных продолжиться в то время, как ввод/вывод
все еще происходит. На Linux и платформах Windows <code>InnoDB</code>
использует доступные функции OS и библиотеки, чтобы выполнить
<span><span>нативный</span></span> асинхронный ввод/вывод. На других
платформах <code>InnoDB</code> все еще использует потоки ввода/вывода, но
потоки могут фактически ждать запросов ввода/вывода, этот метод известен как
<span><span>симулированный</span></span> асинхронный ввод/вывод.</p>

<h4><a name="innodb-disk-io-read-ahead"></a>Чтение вперед</h4>
<p>Если <code>InnoDB</code> может решить, что есть высокая вероятность, что
данные могли бы скоро быть необходимы, это выполняет операции чтения вперед,
чтобы принести те данные в буферный пул так, чтобы это было доступно в
памяти. Обращение с несколькими большими запросами чтения для непрерывных
данных может быть более эффективным чем обращение с несколькими маленькими.
Есть две эвристики чтения вперед в <code>InnoDB</code>:</p>

<ul><li><p>В последовательном чтении вперед, если <code>InnoDB</code>
знает, что образец доступа к сегменту в табличном пространстве
последователен, это отправляет заранее пакет чтений страниц базы данных
системе ввода/вывода.</li>

<li>В случайном чтении вперед, если <code>InnoDB</code> знает, что некоторая
область в табличном пространстве, кажется, находится в процессе того, чтобы
быть полностью считанной в буферный пул, это отправляет остающиеся чтения в
систему ввода/вывода.</p></li></ul>
<p>Подробности в <a href="#innodb-performance-read_ahead">разделе
16.6.3.5</a>.</p>

<h4><a name="innodb-disk-io-doublewrite"></a>Буфер Doublewrite</h4>
<p><code>InnoDB</code> использует новый метод сброса файла, вовлекающий
структуру, названную <a href="glossary.htm#glos_doublewrite_buffer">буфер
doublewrite</a>, который включен по умолчанию в большинстве случаев
(<a href="#sysvar_innodb_doublewrite"><code>innodb_doublewrite=ON
</code></a>). Это добавляет безопасности восстановлению после отключения
электричества катастрофического отказа и улучшает работу относительно
большинства вариантов Unix, уменьшая
потребность в операциях <code>fsync()</code>.</p>

<p>Перед записью страниц в файл с данными <code>InnoDB</code>
сначала пишет их в непрерывной области табличного пространства, названной
буфером doublewrite. Только после завершения записи в буфер doublewrite,
делается запись страниц на их надлежащие позиции в файле с данными. Если есть
катастрофический отказ процесса <a href="programs.htm#mysqld"><span><strong>
mysqld</strong></span></a> или чего-то еще в середине записи страницы,
<code>InnoDB</code> может позже найти хорошую копию страницы в буфере
doublewrite во время восстановления.</p>

<p>Если системные файлы табличного пространства (<span><span>файлы ibdata
</span></span>) расположены на устройствах Fusion-io, которые поддерживают
атомные записи, буферизация doublewrite автоматически отключена, и
Fusion-io используются для всех файлов с данными. Поскольку буферная
установка doublewrite глобальна, doublewrite-буферизация также отключена для
файлов с данными, находящихся на не-Fusion-io  аппаратных средствах. Эта
функция поддерживается только на аппаратных средствах Fusion-io NVMFS в
Linux. Чтобы в полной мере воспользоваться этой особенностью, установите
<a href="#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a> в <code>O_DIRECT</code>.</p>

<h3><a name="innodb-file-space"></a>16.11.2. Управление пространством файла
</h3>
<p>Файлы с данными, которые Вы определяете в конфигурационном файле,
используя опцию <a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a> создают
<a href="glossary.htm#glos_system_tablespace">системное табличное
пространство</a>. Файлы логически связаны, чтобы сформировать системное
табличное пространство. В использовании нет никакого чередования. Вы не
можете определить, где в пределах системного табличного пространства Ваши
таблицы выделены. В создаваемом системном табличном пространстве
<code>InnoDB</code> выделяет место, начиная с первого файла с данными.</p>

<p>Чтобы избежать проблем, которые идут с хранением всех таблиц и индексов
в системном табличном пространстве, Вы можете включить опцию
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> (значение по умолчанию), которая хранит
каждую недавно составленную таблицу в отдельном файле табличного пространства
(с расширением <code>.ibd</code>). Для таблицы, сохраненной этим путем, есть
меньше фрагментации в пределах дискового файла, и когда таблица усечена,
пространство возвращено к операционной системе вместо того, чтобы все еще
быть сохраненным InnoDB в пределах системного табличного пространства. Для
получения дополнительной информации см.
<a href="#innodb-multiple-tablespaces">раздел 16.7.4</a>.</p>

<p>Вы можете также сохранить таблицы в
<a href="glossary.htm#glos_general_tablespace">общих табличных пространствах
</a>. Общие табличные пространства это совместно используемые табличные
пространства, создаваемые с <a href="sql.htm#create-tablespace"><code>CREATE
TABLESPACE</code></a>. Они могут быть созданы за пределами каталога данных
MySQL, способны к хранению многих таблиц и поддерживают таблицы всех форматов
строки. Для получения дополнительной информации см.
<a href="#general-tablespaces">раздел 16.7.9</a>.</p>

<h4><a name="idm139965324763760"></a>
Страницы, сегменты и табличные пространства</h4>
<p>Каждое табличное пространство состоит из
<a href="glossary.htm#glos_page">страниц</a>.
У каждого табличного пространства в случае MySQL есть тот же самый
<a href="glossary.htm#glos_page_size">размер страницы</a>.
По умолчанию у всех табличных пространств есть размер страницы 16KB,
Вы можете уменьшить размер страницы до 8 КБ или 4 КБ, определяя опцию
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>, когда Вы создаете экземпляр MySQL. Вы можете также увеличить размер
страницы до 32 КБ или 64 КБ. Для получения дополнительной информации
обратитесь к описанию опции <a href="#sysvar_innodb_page_size">
<code>innodb_page_size</code></a>.</p>

<p>Страницы сгруппированы в <a href="glossary.htm#glos_extent">экстенты</a>
размера 1 МБ для страниц до 16 КБ в размере (64 последовательных страницы по
16 КБ, 128 страниц по 8KB или 256 страниц по 4KB). Для размера страницы 32
КБ размер экстента 2MB. Для размера страницы 64KB размер экстента 4MB.
<span><span>Файлы</span></span> в табличном пространстве называют
<a href="glossary.htm#glos_segment">сегментами</a> в <code>InnoDB</code>.
Эти сегменты отличаются от <a href="glossary.htm#glos_rollback_segment">
сегмента отмены</a>, который фактически содержит много
сегментов табличного пространства.</p>

<p>Когда сегмент растет в табличном пространстве, <code>InnoDB</code>
выделяет первые 32 страницы по одной. После этого <code>InnoDB</code>
начинает выделять целые экстенты сегменту. <code>InnoDB</code> может добавить
до 4 экстентов за один раз к большому сегменту, чтобы гарантировать
хорошее размещение данных.</p>

<p>Два сегмента выделены для каждого индекса.
Один для безлистных узлов <a href="glossary.htm#glos_b_tree">B-tree</a>,
другой для узлов с листьями. Хранение узлов листа непрерывными на диске
улучшает последовательные операции ввода/вывода, потому что эти узлы листа
содержат фактические табличные данные.</p>

<p>Некоторые страницы в табличном пространстве содержат битовые массивы
других страниц, и поэтому несколько экстентов в табличном пространстве
<code>InnoDB</code> не могут быть выделено сегментам в целом, только
как отдельные страницы.</p>

<p>Когда Вы запрашиваете доступное свободное пространство в табличном
пространстве посредством <a href="sql.htm#show-table-status"><code>SHOW TABLE
STATUS</code></a>, <code>InnoDB</code> сообщает экстенты, которые определенно
свободны в табличном пространстве. <code>InnoDB</code> всегда имеет в запасе
некоторые экстенты для уборки и других внутренних целей, эти сохраненные
экстенты не включены в свободное пространство.</p>

<p>Когда Вы удаляете данные из таблицы, <code>InnoDB</code>
сокращает соответствующее B-дерево индексов. Становится ли освобожденное
пространство доступным другим пользователям, зависит от того,
освобождаются ли отдельные страницы или экстенты в табличном пространстве.
Удаление таблицы или удаление всех строк из нее будет освобождать
пространство другим пользователям, но помните, что удаленные строки физически
удалены только <a href="glossary.htm#glos_purge">чисткой</a>,
которая происходит автоматически через некоторое время после того, как они
больше не нужны для операционных отмен или последовательных чтений. См.
<a href="#innodb-multi-versioning">раздел 16.3</a>.</p>

<h4><a name="idm139965324740848"></a>Как страницы касаются строк таблицы</h4>
<p>Максимальная длина строки немного меньше, чем половина страницы базы
данных для 4KB, 8KB, 16KB и 32KB
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. Например, максимальная длина строки немного меньше, чем 8 КБ для
значения по умолчанию 16 КБ размера страницы <code>InnoDB</code>.
Для страниц 64 КБ максимальная длина строки немного меньше 16 КБ.</p>

<p>Если строка не превышает максимальную длину строки, все это сохранено в
местном масштабе в пределах страницы. Если строка превышает максимальную
длину строки, <a href="glossary.htm#glos_variable_length_type">
столбцы переменной длины</a> выбраны для внешнего хранения вне страницы в
пределах максимального предела длины строки. Внешнее хранение вне страницы
для столбцов переменной длины отличается форматом строки:</p>

<ul><li><p><span><em>COMPACT и REDUNDANT</em></span></p>
<p>Когда столбец переменной длины выбран для внешнего хранения вне страницы,
<code>InnoDB</code> хранит первые 768 байтов в местном масштабе в строке, а
остальные внешне в странице переполнения. У каждого такого столбца есть свой
собственный список страниц переполнения. 768-байтовый префикс сопровождается
20-байтовым значением, которое хранит истинную длину столбца и указывает на
список переполнения, где остальная часть значения сохранена. См.
<a href="#innodb-row-format-antelope">раздел 16.10.4</a>.</li>

<li><span><em>DYNAMIC и COMPRESSED</em></span></p>
<p>Когда столбец переменной длины выбран для внешнего хранения вне страницы,
<code>InnoDB</code> хранит 20-байтовый указатель в местном масштабе в строке,
а остальное внешне в странице переполнения. См.
<a href="#innodb-row-format-dynamic">раздел 16.10.3</a>.
</p></li></ul>

<p>Столбцы <a href="types.htm#blob"><code>LONGBLOB</code></a> и
<a href="types.htm#blob"><code>LONGTEXT</code></a>
должны быть меньше 4 ГБ, и суммарная длина строки, включая
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>,
должна быть меньше 4 ГБ.</p>

<h3><a name="innodb-checkpoints"></a>16.11.3. Контрольные точки InnoDB</h3>
<p>Создание Ваших очень больших <a href="glossary.htm#glos_log_file">
файлов системного журнала</a> может уменьшить дисковый ввод/вывод во время
<a href="glossary.htm#glos_checkpoint">установки контрольных точек</a>.
Часто имеет смысл устанавливать полный размер файлов системного журнала
столь же большим, как буферный пул или еще больше.</p>

<h4><a name="idm139965324718144"></a>Как обработка контрольной точки работает
</h4>
<p><code>InnoDB</code> осуществляет механизм
<a href="glossary.htm#glos_checkpoint">контрольной точки</a>, известный как
<a href="glossary.htm#glos_fuzzy_checkpointing">нечеткая установка
контрольных точек</a>. <code>InnoDB</code> сбрасывает измененные страницы
базы данных из буферного пула в маленьких пакетах. Нет никакой потребности
сбрасывать буферный пул в одном огромном пакете, который разрушил бы
обработку пользовательских запросов SQL во время процесса
установки контрольных точек.</p>

<p>Во время <a href="glossary.htm#glos_crash_recovery">восстановления
катастрофического отказа</a> <code>InnoDB</code> ищет метку контрольной
точки, записанную в файлы системного журнала. Это знает, что все модификации
базы данных перед меткой присутствуют в образе базы данных на диске. Тогда
<code>InnoDB</code> просматривает файлы системного журнала вперед от
контрольной точки, применяя зарегистрированные модификации к базе данных.</p>

<h3><a name="innodb-file-defragmenting"></a>16.11.4. Дефрагментация таблиц
</h3>
<p>Случайные вставки или удаления из вторичного индекса
могут заставить индексирование становится фрагментированным. Фрагментация
означает, что физическое упорядочивание индексных страниц на диске не близко
к индексному упорядочиванию записей на страницах, или что есть много
неиспользованных страниц в блоках на 64 страницы, которые
были выделены индексу.</p>

<p>Один признак фрагментации: что таблица занимает больше места, чем она
<span><span>должна</span></span> занимать. То, сколько это точно, трудно
определить. Все данные <code>InnoDB</code> и индексы сохранены в
<a href="glossary.htm#glos_b_tree">B-tree</a>, и их
<a href="glossary.htm#glos_fill_factor">коэффициент заполнения</a>
может измениться от 50% до 100%. Другой признак фрагментации: сканирование
таблицы, такое как это, занимает больше времени, чем
<span><span>должно</span></span>:
<pre>
SELECT COUNT(*) FROM t WHERE <em><code>non_indexed_column</code></em> &lt;&gt; 12345;
</pre>

<p>Предыдущий запрос требует, чтобы MySQL выполнил полное сканирование
таблицы, самый медленный тип запроса для большой таблицы.</p>
<p>Чтобы убыстрить индексные просмотры, Вы можете периодически выполнять
<span><span>нулевой</span></span> <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, которая заставляет MySQL восстанавливать таблицу:
<pre>
ALTER TABLE <em><code>tbl_name</code></em> ENGINE=INNODB
</pre>

<p>Вы можете также использовать
<a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> FORCE</code></a>, чтобы выполнить
<span><span>нулевую</span></span> работу, которая восстанавливает таблицу.
</p>

<p><a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> ENGINE=INNODB</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE
<em><code>tbl_name</code></em> FORCE</code></a> используют
<a href="#innodb-online-ddl">online DDL</a>
(<code>ALGORITHM=COPY</code>). Подробности в
<a href="#innodb-create-index-overview">разделе 16.12.1</a>.</p>

<p>Другой способ выполнить работу дефрагментации состоит в том, чтобы
использовать <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a>, чтобы вывести таблицу в дамп, удалить таблицу и
перезагрузить ее из файла дампа.</p>

<p>Если вставки в индекс всегда растут, а записи удалены только из конца,
управленческий алгоритм <code>InnoDB</code> гарантирует, что фрагментация в
индексе не происходит.</p>

<h3><a name="innodb-truncate-table-reclaim-space"></a>16.11.5.
Восстановление дискового пространства с TRUNCATE TABLE</h3>
<p>Чтобы восстановить дисковое пространство операционной системы,
<a href="glossary.htm#glos_truncate">усекая</a> таблицу,
эта таблица должна быть сохранена в ее собственном файле
<a href="glossary.htm#glos_ibd_file">.ibd</a>.
Для таблицы, которая будет сохранена в ее собственном файле
<a href="glossary.htm#glos_ibd_file">.ibd</a>,
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> должен быть включен, когда таблица составлена. Дополнительно не
может быть ограничения <a href="glossary.htm#glos_foreign_key">внешнего
ключа</a> между таблицей для усечения и другими таблицами, иначе
<code>TRUNCATE TABLE</code> выдаст ошибку. Ограничение внешнего ключа между
двумя столбцами в той же самой таблице, однако, разрешено.</p>

<p>Когда таблица является усеченной, она удалена и пересоздана в новом файле
<code>.ibd</code>, а освобожденное пространство возвращено операционной
системе. Это в отличие от усечения таблиц, которые сохранены в пределах
<a href="glossary.htm#glos_system_tablespace">системного табличного
пространства</a> (таблицы, составленные, когда
<code>innodb_file_per_table=OFF</code>) и таблиц, сохраненных в совместно
используемых <a href="glossary.htm#glos_general_tablespace">общих табличных
пространствах</a>, где только <code>InnoDB</code> может использовать
освобожденное пространство после того, как таблица усечена.</p>

<p>Способность усечь таблицы и возвратить дисковое пространство операционной
системе также означает, что
<a href="glossary.htm#glos_physical_backup">физические резервные копии</a>
могут быть меньшими. Усечение таблиц, которые сохранены в системном табличном
пространстве (таблицы, составленные, когда
<code>innodb_file_per_table=OFF</code>)
или в общем табличном пространстве оставляет блоки неиспользуемого
места в табличном пространстве.</p>

<h2><a name="innodb-online-ddl"></a>16.12. InnoDB и Online DDL</h2>
<p><a href="glossary.htm#glos_online_ddl">online DDL</a>
улучшает много типов <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>, чтобы избежать табличного копирования или блокирования операций
<a href="glossary.htm#glos_dml">DML</a> в то время, как
<a href="glossary.htm#glos_ddl">DDL</a> происходит.</p>

<p>Особенность <a href="glossary.htm#glos_online_ddl">online DDL</a>
обладает следующими преимуществами:</p>
<ul><li><p>Это улучшает отклик и доступность в занятых производственных
средах, где создание таблицы, недоступной в течение многих минут или
часов, не практично.</li>

<li>Это позволяет Вам корректировать баланс между работой и параллелизмом во
время работы DDL, выбирая, блокировать ли доступ к таблице полностью
(<code>LOCK=EXCLUSIVE</code>), позволить запросы, но не DML
(<code>LOCK=SHARED</code>) или позволить полный доступ запросам и DML к
таблице (<code>LOCK=NONE</code>). Когда Вы опускаете <code>LOCK</code>
или определяете <code>LOCK=DEFAULT</code>, MySQL позволяет такой большой
параллелизм, насколько возможно, в зависимости от типа работы.</li>

<li>Выполнение оперативных изменений, где только возможно, вместо того, чтобы
создать новую копию таблицы, избегает временных увеличений использования
дискового пространства и ввода/вывода, связанного с копированием таблицы.
</p></li></ul>

<h3><a name="innodb-create-index-overview"></a>16.12.1. Обзор Online DDL</h3>
<p>Исторически, много операций <a href="glossary.htm#glos_ddl">DDL</a>
в таблицах <code>InnoDB</code> были дороги. Многие
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
работали, составляя новую, пустую, таблицу, определенную с требуемыми
табличными опциями и индексами, затем копируя существующие строки к новой
таблице поштучно, обновляя индексирование по мере того, как строки были
вставлены. После того, как все строки оригинальной таблицы были
скопированы, старая таблица была удалена, а копия переименована с
названием оригинальной таблицы.</p>

<p>MySQL 5.5 и MySQL 5.1 с InnoDB Plugin оптимизировали
<code>CREATE INDEX</code> и <code>DROP INDEX</code>, чтобы
избегать копирующего таблицу поведения. Та особенность была известна, как
<a href="glossary.htm#glos_fast_index_creation">быстрое создание индекса
</a>. MySQL 5.6 улучшил много других типов
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, чтобы избежать
копировать таблицу. Другое улучшение позволило запросам
<a href="sql.htm#select"><code>SELECT</code></a>
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>
(<a href="glossary.htm#glos_dml">DML</a>) продолжиться в то время, как
таблица изменяется. В MySQL 5.7 <a href="sql.htm#alter-table"><code>ALTER
TABLE RENAME INDEX</code></a> был также улучшен, чтобы избежать табличного
копирования. Эта комбинация особенностей теперь известна как
<a href="glossary.htm#glos_online_ddl">online DDL</a>.</p>

<p>Этот механизм также означает, что Вы можете вообще ускорить полный процесс
создания и загрузки таблицы, составляя таблицу без вторичного индекса, затем
добавляя, вторичный индекс после того, как данные загружены.</p>

<p>Хотя никакие изменения синтаксиса не требуются в
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a> или
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a>,
некоторые факторы затрагивают работу и семантику этой работы (см.
<a href="#innodb-create-index-limitations">раздел 16.12.9</a>).</p>

<p>Возможность online DDL в MySQL 5.6 улучшила много операций DDL, которые
прежде требовали табличной копии или блокировали операции DML на таблице.
<a href="#innodb-online-ddl-summary-grid">Таблица 16.9</a>
показывает изменения <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>как особенность DDL онлайн относится к каждому запросу.</p>

<p>За исключением параметров разделения в <a href="sql.htm#alter-table">
<code>ALTER TABLE</code></a>, online DDL для разделенных таблиц
следуют тем же самым правилам, которые относятся к обычным таблицам. Для
получения дополнительной информации см.
<a href="#online-ddl-partitioning">раздел 16.12.8</a>.</p>

<ul><li><p>Столбец <span><span>In-Place?</span></span> показывает, которые
операции позволяют <code>ALGORITHM=INPLACE</code>.</li>
<li>Столбец <span><span>Copies Table?</span></span> показывает, которые
операции в состоянии избежать дорогой копирующей таблицу работы.
Этот столбец главным образом обратен <span><span>In-Place?</span></span>
за исключением того, что несколько операций позволяют
<code>ALGORITHM=INPLACE</code>, но все еще вовлекают некоторое
количество табличного копирования.</li>

<li>Столбец <span><span>Allows Concurrent DML?</span></span>
показывает, которые операции могут быть выполнены полностью онлайн.
Вы можете определить <code>LOCK=NONE</code>, чтобы утверждать, что полный
параллелизм позволен во время DDL, но MySQL автоматически позволяет этот
уровень параллелизма, когда можно. Когда параллельный DML позволен,
параллельные запросы также всегда позволяются.</li>

<li>Столбец <span><span>Allows Concurrent Queries?</span></span>
показывает, которые DDL-операции DDL позволяются запросам на таблице в то
время, как работа происходит. Параллельный запрос позволен во время всех
онлайн операции DDL. Вы можете определить <code>LOCK=SHARED</code>,
чтобы утверждать, что параллельные запросы позволены во время DDL, но MySQL
автоматически позволяет этот уровень параллелизма когда возможно.</li>

<li>Столбец <span><span>Примечания</span></span> объясняет любые исключения
такие, как тогда, когда ответ зависит от установки параметра конфигурации или
некоторого другого пункта в запросе DDL. Значения
<span><span>Yes*</span></span> и <span><span>No*</span></span>
указывают, что ответ зависит от этих дополнительных примечаний.</p></li></ul>

<a name="innodb-online-ddl-summary-grid"></a><p><b>
Таблица 16.9. Резюме состояния онлайн для операций DDL</b></p>
<table border="1">
<thead><tr><th align="left">Операция</th><th align="center">In-Place?</th>
<th align="center">Copies Table?</th><th align="center">
Allows Concurrent DML?</th><th align="center">Allows Concurrent Query?</th>
<th align="left">Примечания</th></tr></thead>
<tbody><tr><td align="left"><a href="sql.htm#create-index"><code>CREATE INDEX
</code></a>, <a href="sql.htm#alter-table"><code>ADD INDEX</code></a></td>
<td align="center">Yes*</td><td align="center">No*</td><td align="center">Да
</td><td align="center">Да</td><td align="left">Некоторые ограничения для
индекса <code>FULLTEXT</code>.</td></tr>
<tr><td align="left"><a href="sql.htm#alter-table"><code>ADD FULLTEXT
INDEX</code></a></td><td align="center">Да</td><td align="center">No*</td>
<td align="center">Нет</td><td align="center">Да</td><td align="left">
Создание первого индекса <code>FULLTEXT</code> для таблицы, вовлекает
табличную копию, если нет столбца <code>FTS_DOC_ID</code>. Последующие
индексы <code>FULLTEXT</code> на той же самой таблице могут
быть созданы оперативно.</td></tr>
<tr><td align="left"><a href="sql.htm#alter-table"><code>ADD SPATIAL INDEX
</code></a></td><td align="center">Да</td><td align="center">Нет</td>
<td align="center">Нет</td><td align="center">Да</td><td align="left">
Оптовая загрузка не поддержана.</td></tr>
<tr><td align="left"><a href="sql.htm#alter-table"><code>RENAME INDEX</code>
</a></td><td align="center">Да</td><td align="center">Нет</td>
<td align="center">Да</td><td align="center">Да</td><td align="left">
Только изменяет табличные метаданные.</td></tr>
<tr><td align="left"><a href="sql.htm#drop-index"><code>DROP INDEX</code></a>
</td><td align="center">Да</td><td align="center">Нет</td><td align="center">
Да</td><td align="center">Да</td><td align="left">
Только изменяет табличные метаданные.</td></tr>
<tr><td align="left"><a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE
</code></a></td><td align="center">Да</td><td align="center">Да</td>
<td align="center">Да</td><td align="center">Да</td><td align="left"><code>
ALGORITHM=COPY</code> используется, если <code>old_alter_table=1</code> или
включена опция <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> <code>--skip-new</code>. <code>OPTIMIZE TABLE</code>
использует онлайн DDL (<code>ALGORITHM=INPLACE</code>), не поддерживая
таблицы с индексами FULLTEXT.</td></tr>
<tr><td align="left">Установить значение по умолчанию для столбца.
</td><td align="center">Да</td><td align="center">Нет</td><td align="center">
Да</td><td align="center">Да</td><td align="left">
Только изменяет табличные метаданные.</td></tr>
<tr><td align="left">Изменить для столбца значение
<a href="glossary.htm#glos_auto_increment">auto-increment</a>.</td>
<td align="center">Да</td><td align="center">Нет</td><td align="center">Да
</td><td align="center">Да</td><td align="left">Изменяет значение, сохраненное
в памяти, а не в файле с данными.</td></tr><tr><td align="left">Добавить
<a href="glossary.htm#glos_foreign_key_constraint">ограничение внешнего
ключа</a></td><td align="center">Yes*</td><td align="center">No*</td>
<td align="center">Да</td><td align="center">Да</td><td align="left">
Чтобы избежать копировать таблицу, отключите
<a href="server.htm#sysvar_foreign_key_checks"><code>foreign_key_checks
</code></a> во время создания ограничения.</td></tr><tr><td align="left">
Удалить <a href="glossary.htm#glos_foreign_key_constraint">ограничение
внешнего ключа</a></td><td align="center">Да</td><td align="center">Нет</td>
<td align="center">Да</td><td align="center">Да</td><td align="left">
<a href="server.htm#sysvar_foreign_key_checks"><code>foreign_key_checks
</code></a> может быть включена или отключена.</td></tr>
<tr><td align="left">Переименовать столбец</td><td align="center">Yes*</td>
<td align="center">No*</td><td align="center">Yes*</td><td align="center">Да
</td><td align="left">Чтобы позволить параллельный DML, сохраните тот же
самый тип данных и измените только имя столбца. <code>ALGORITHM=INPLACE
</code> не поддержан для того, чтобы переименовать
<a href="glossary.htm#glos_generated_column">произведенный столбец</a>.
</td></tr>
<tr><td align="left">Добавить</td><td align="center">Yes*</td>
<td align="center">Yes*</td><td align="center">Yes*</td><td align="center">Да
</td><td align="left">Параллельный DML не позволен, добавляя столбец
<a href="glossary.htm#glos_auto_increment">auto-increment</a>.
Хотя <code>ALGORITHM=INPLACE</code> позволен, данные реорганизованы
существенно, таким образом, это все еще дорогая работа.
<code>ALGORITHM=INPLACE</code> поддержан для того, чтобы добавить
<a href="glossary.htm#glos_generated_virtual_column">произведенный
виртуальный столбец</a>, но не для того, чтобы добавить
<a href="glossary.htm#glos_generated_virtual_column">произведенный
сохраненный столбец</a>. Добавление произведенного виртуального столбца не
требует табличной копии.</td></tr>
<tr><td align="left">Удалить столбец</td><td align="center">Да</td>
<td align="center">Yes*</td><td align="center">Да</td><td align="center">Да
</td><td align="left">Хотя <code>ALGORITHM=INPLACE</code>
позволен, данные реорганизованы существенно, таким образом, это все еще
дорогая работа. <code>ALGORITHM=INPLACE</code> поддержан для того, чтобы
удалить произведенный столбец. Удаление
<a href="glossary.htm#glos_generated_virtual_column">
произведенного виртуального столбца</a> не требует табличной копии.</td></tr>
<tr><td align="left">Reorder columns</td><td align="center">Да</td>
<td align="center">Да</td><td align="center">Да</td><td align="center">Да
</td><td align="left">Хотя <code>ALGORITHM=INPLACE</code> позволен, данные
реорганизованы существенно, таким образом, это все еще дорогая работа.
</td></tr>
<tr><td align="left">Изменить свойства <code>ROW_FORMAT</code></td>
<td align="center">Да</td><td align="center">Да</td><td align="center">Да
</td><td align="center">Да</td><td align="left">
Хотя <code>ALGORITHM=INPLACE</code> позволен, данные
реорганизованы существенно, таким образом, это все еще дорогая работа.
</td></tr>
<tr><td align="left">Изменить свойства <code>KEY_BLOCK_SIZE</code></td>
<td align="center">Да</td><td align="center">Да</td><td align="center">Да
</td><td align="center">Да</td><td align="left">
Хотя <code>ALGORITHM=INPLACE</code> позволен, данные
реорганизованы существенно, таким образом, это все еще дорогая работа.
</td></tr>
<tr><td align="left">Сделать столбец <code>NULL</code></td>
<td align="center">Да</td><td align="center">Да</td><td align="center">Да
</td><td align="center">Да</td><td align="left">
Хотя <code>ALGORITHM=INPLACE</code> позволен, данные
реорганизованы существенно, таким образом, это все еще дорогая работа.
</td></tr>
<tr><td align="left">Сделать столбец <code>NOT NULL</code></td>
<td align="center">Yes*</td><td align="center">Да</td><td align="center">Да
</td><td align="center">Да</td><td align="left"><code>STRICT_ALL_TABLES
</code> или <code>STRICT_TRANS_TABLES</code>
<a href="server.htm#sysvar_sql_mode"><code>SQL_MODE</code></a>
требуется для работы. Работа терпит неудачу, если столбец содержит значения
NULL. Сервер запрещает изменения столбцов внешнего ключа, у которых есть
потенциал, чтобы вызвать потерю ссылочной целостности.
Для получения дополнительной информации см.
<a href="sql.htm#alter-table">раздел 14.1.7</a>.
Хотя <code>ALGORITHM=INPLACE</code> позволен, данные
реорганизованы существенно, таким образом, это все еще дорогая работа.
</td></tr>
<tr><td align="left">Изменить тип столбца</td><td align="center">No*</td>
<td align="center">Yes*</td><td align="center">Нет</td><td align="center">Да
</td><td align="left">Исключение: <a href="types.htm#char"><code>VARCHAR
</code></a> может быть увеличен, используя онлайн
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</td></tr>
<tr><td align="left">Добавить <a href="glossary.htm#glos_primary_key">
primary key</a></td><td align="center">Yes*</td><td align="center">Да</td>
<td align="center">Да</td><td align="center">Да</td><td align="left">
Хотя <code>ALGORITHM=INPLACE</code> позволен, данные
реорганизованы существенно, таким образом, это все еще дорогая работа.
<code>ALGORITHM=INPLACE</code> не позволен при определенных условиях, если
столбцы должны быть преобразованы в <code>NOT NULL</code>. См.
<a href="#online-ddl-ex-primary-key">Пример 16.9</a>.</td></tr>
<tr><td align="left">Удалить <a href="glossary.htm#glos_primary_key">primary
key</a> и добавить другой</td><td align="center">Да</td><td align="center">Да
</td><td align="center">Да</td><td align="center">Да</td><td align="left">
<code>ALGORITHM=INPLACE</code> позволен только, когда Вы добавляете новый
первичный ключ в том же самом <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>.</td></tr>
<tr><td align="left">Удалить <a href="glossary.htm#glos_primary_key">primary
key</a></td><td align="center">Нет</td><td align="center">Да</td>
<td align="center">Нет</td><td align="center">Да</td><td align="left">
Ограничения применяются, когда Вы удаляете первичный ключ, не добавляя новый
в том же самом <code>ALTER TABLE</code>.</td></tr>
<tr><td align="left">Сменить набор символов</td><td align="center">Нет</td>
<td align="center">Да</td><td align="center">Нет</td><td align="center">Да
</td><td align="left">Пересоздает таблицу, если новая
кодировка символов отличается.</td></tr>
<tr><td align="left">Определить набор символов</td><td align="center">Нет
</td><td align="center">Да</td><td align="center">Нет</td><td align="center">
Да</td><td align="left">Пересоздает таблицу, если новая
кодировка символов отличается.</td></tr>
<tr><td align="left">Пересоздать с опцией <code>FORCE</code></td>
<td align="center">Да</td><td align="center">Да</td><td align="center">Да
</td><td align="center">Да</td><td align="left"><code>ALGORITHM=COPY</code>
используется, если <code>old_alter_table=1</code> или включена опция
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
<code>--skip-new</code>. Пересоздание таблицы с использованием онлайн DDL
(<code>ALGORITHM=INPLACE</code>) не поддержано для
таблиц с индексами FULLTEXT.</td></tr>
<tr><td align="left">Пересоздать с <span><span>null</span></span> <code>ALTER
TABLE ... ENGINE=INNODB</code></td><td align="center">Да</td>
<td align="center">Да</td><td align="center">Да</td><td align="center">Да
</td><td align="left"><code>ALGORITHM=COPY</code> используется, если
<code>old_alter_table=1</code> или включена опция
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
<code>--skip-new</code>. Пересоздание таблицы с использованием онлайн DDL
(<code>ALGORITHM=INPLACE</code>) не поддержано для
таблиц с индексами FULLTEXT.</td></tr>
<tr><td align="left">Установить <a href="glossary.htm#glos_persistent_statistics">
постоянные</a> опции статистики на уровне таблицы
(<code>STATS_PERSISTENT</code>, <code>STATS_AUTO_RECALC</code>
<code>STATS_SAMPLE_PAGES</code>).</td>
<td align="center">Да</td><td align="center">Нет</td><td align="center">Да
</td><td align="center">Да</td><td align="left">
Только изменяет табличные метаданные.</td></tr></tbody></table>

<p>Следующие разделы показывают основной синтаксис и примечания
использования, связанные с DDL онлайн, для каждой из главных операций,
которые могут быть выполнены с параллельным DML:</p>

<h4><a name="idm139965324456976"></a>Вторичные индексы</h4>
<ul><li><p>Создание <a href="glossary.htm#glos_secondary_index">вторичных
индексов</a>: <code>CREATE INDEX <em><code>name</code></em> ON
<em><code>table</code></em>
(<em><code>col_list</code></em>)</code> или
<code>ALTER TABLE <em><code>table</code></em> ADD
INDEX <em><code>name</code></em>
(<em><code>col_list</code></em>)</code>. Создание индекса
<code>FULLTEXT</code> все еще требует блокировки таблицы.</li>

<li>Удаление <a href="glossary.htm#glos_secondary_index">вторичных
индексов</a>: <code>DROP INDEX <em><code>name</code></em> ON
<em><code>table</code></em>;</code> или <code>ALTER
TABLE <em><code>table</code></em> DROP INDEX
<em><code>name</code></em></code></p></li></ul>
<p>Создание и удаление вторичного индекса на
таблице пропускает копирующее таблицу поведение.</p>

<p>Таблица остается доступной для чтения и записи
в то время, как индекс создается или удаляется.
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a> или
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a>
заканчивается только после того, как все транзакции, которые получают доступ
к таблице, завершены, чтобы начальное состояние индекса отразило новое
содержание таблицы. Ранее изменение таблицы в то время, как индекс создается
или удаляется, как правило, приводило к
<a href="glossary.htm#glos_deadlock">тупику</a>, который отменял
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>.</p>

<h4><a name="innodb-online-ddl-column-properties"></a>Свойства столбца</h4>
<ul><li><p>Установите значение по умолчанию для столбца:
<code>ALTER TABLE <em><code>tbl</code></em> ALTER COLUMN
<em><code>col</code></em> SET DEFAULT <em><code>literal</code></em></code>
или <code>ALTER TABLE <em><code>tbl</code></em> ALTER COLUMN
<em><code>col</code></em> DROP DEFAULT</code></p>
<p>Значения по умолчанию для столбцов сохранены в
<a href="glossary.htm#glos_data_dictionary">словаре данных</a>.</li>

<li>Изменение значения <a href="glossary.htm#glos_auto_increment">
auto-increment</a> для столбца: <code>ALTER TABLE <em><code>table</code></em>
AUTO_INCREMENT=<em><code>next_value</code></em>;</code></p>

<p>Особенно в распределенной системе, используя репликацию, Вы иногда
сбрасываете счетчик автоинкремента для таблицы к определенному значению.
Следующая строка, вставленная в таблицу, использует указанное значение для
своего столбца auto-increment. Вы могли бы также использовать этот метод в
окружающей среде складирования данных, где Вы периодически очищаете все
таблицы и перезагружаете их и можете перезапустить
последовательность автоинкремента от 1.</li>

<li>Переименование столбца: <code>ALTER TABLE <em><code>tbl</code></em>
CHANGE <em><code>old_col_name</code></em> <em><code>new_col_name</code></em>
<em><code>datatype</code></em></code></p>

<p>Когда Вы сохраняете тот же самый тип данных и параметр
<code>[NOT] NULL</code>, только изменяя имя столбца, эта работа может
всегда выполняться онлайн.</p>

<p>Вы можете также переименовать столбец, который является частью ограничения
внешнего ключа. Определение внешнего ключа автоматически обновлено, чтобы
использовать новое имя столбца. Переименование столбца, участвующего во
внешнем ключе, работает только с оперативным режимом
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Если Вы используете <code>ALGORITHM=COPY</code> или некоторое другое условие
заставляет команду использовать <code>ALGORITHM=COPY</code> негласно,
<code>ALTER TABLE</code> потерпит неудачу.</li>

<li>Изменение размера <a href="types.htm#char"><code>VARCHAR</code></a>,
используя оперативное <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>, как в этом примере:
<pre>
ALTER TABLE t1 ALGORITHM=INPLACE, CHANGE COLUMN c1 c1 VARCHAR(255);
</pre>

<p>Число байтов длины, требуемое столбцом
<a href="types.htm#char"><code>VARCHAR</code></a>,
должно остаться тем же самым. Для <a href="types.htm#char"><code>VARCHAR
</code></a> от 0 до 255, один байт длины обязан кодировать значение. Для
<a href="types.htm#char"><code>VARCHAR</code></a> в 256 байт или больше
надо два байта. В результате оперативный <a href="sql.htm#alter-table"><code>
ALTER TABLE</code></a> допускает только увеличение
<a href="types.htm#char"><code>VARCHAR</code></a> от 0 до 255 байт или
увеличение размера от значения, равного или большего 256 байтов. Оперативный
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> не поддерживает
увеличение <a href="types.htm#char"><code>VARCHAR</code></a> от значения
меньше 256 байт до значения, равного или больше 256 байтов. В этом случае
число необходимых байтов длины изменилось бы от 1 до 2, что поддержано только
табличной копией (<code>ALGORITHM=COPY</code>). Например, попытка изменить
размер столбца <a href="types.htm#char"><code>VARCHAR</code></a> от
255 до 256, используя оперативный
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
возвратила бы ошибку:
<pre>
ALTER TABLE t1 ALGORITHM=INPLACE, CHANGE COLUMN c1 c1 VARCHAR(256);
ERROR 0A000: ALGORITHM=INPLACE is not supported. Reason: Cannot change
column type INPLACE. Try ALGORITHM=COPY.
</pre>

<p>Уменьшение размера <a href="types.htm#char"><code>VARCHAR</code></a>,
используя оперативный <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a> не поддержано. Уменьшение <a href="types.htm#char"><code>VARCHAR</code>
</a> требует табличной копии (<code>ALGORITHM=COPY</code>).</p></li></ul>

<h4><a name="idm139965324391376"></a>Внешние ключи</h4>
<ul><li><p>Добавление или удаление
<a href="glossary.htm#glos_foreign_key_constraint">
ограничения внешнего ключа</a>:
<pre>
ALTER TABLE <em><code>tbl1</code></em> ADD CONSTRAINT <em><code>fk_name</code></em>
      FOREIGN KEY <em><code>index</code></em> (<em><code>col1</code></em>)
      REFERENCES <em><code>tbl2</code></em>(<em><code>col2</code></em>)
      <em><code>referential_actions</code></em>;
ALTER TABLE <em><code>tbl</code></em> DROP FOREIGN KEY <em><code>fk_name</code></em>;
</pre>

<p>Удаление внешнего ключа может быть выполнено онлайн с включенной или
выключенной опцией <a href="server.htm#sysvar_foreign_key_checks"><code>
foreign_key_checks</code></a>. Создание внешнего ключа онлайн требует
выключения <a href="server.htm#sysvar_foreign_key_checks">
<code>foreign_key_checks</code></a>.</p>

<p>Если Вы не знаете названия ограничений внешнего ключа на особую таблицу,
делаете следующее запрос и находите имя ограничения в параметре
<code>CONSTRAINT</code> для каждого внешнего ключа:
<pre>
show create table <em><code>table</code></em>\G
</pre>

<p>Или запросите таблицу
<a href="inform.htm#table-constraints-table"><code>
information_schema.table_constraints</code></a> и используйте столбцы
<code>constraint_name</code> и <code>constraint_type</code>, чтобы
идентифицировать имена внешнего ключа.</p>

<p>Вы можете также удалить внешний ключ и его связанный
индекс в единственном запросе:
<pre>
ALTER TABLE <em><code>table</code></em> DROP FOREIGN KEY <em><code>constraint</code></em>,
      DROP INDEX <em><code>index</code></em>;
</pre></li></ul>

<p>Если <a href="glossary.htm#glos_foreign_key">внешние ключи</a>
уже присутствуют в измененной таблице (то есть, это
<a href="glossary.htm#glos_child_table">дочерняя таблица</a>,
содержащая любой <code>FOREIGN KEY ... REFERENCE</code>), дополнительные
ограничения относятся к операциям онлайн DDL, даже те, которые
непосредственно не вовлекают столбцы внешнего ключа:</p>

<ul><li><p><a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
на дочерней таблице мог ждать завершения другой транзакции, если бы изменение
родительской таблицы вызвало связанные изменения в дочерней таблице через
<code>ON UPDATE</code> или <code>ON DELETE</code>, используя параметры
<code>CASCADE</code> или <code>SET NULL</code>.</li>

<li>Таким же образом, если таблица
<a href="glossary.htm#glos_parent_table">родительская</a>
в отношениях внешнего ключа, даже при том, что это не содержит никакого
<code>FOREIGN KEY</code>, это могло ждать конца
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, если
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a> вызвал
<code>ON UPDATE</code> или <code>ON DELETE</code> в дочерней таблице.
</p></li></ul>

<h4><a name="idm139965324355344"></a>Замечания по ALGORITHM=COPY</h4>
<p>Любая <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
выполненная с <code>ALGORITHM=COPY</code>, предотвращает параллельные
операции DML. Параллельные запросы все еще позволены. Таким образом,
копирующая таблицу работа всегда включает, по крайней мере, ограничения
параллелизма <code>LOCK=SHARED</code> (позволяет запросы, но не DML). Вы
можете далее ограничить параллелизм для таких операций, определяя
<code>LOCK=EXCLUSIVE</code>, что предотвращает DML и запросы.</p>

<h4><a name="idm139965324350528"></a>Параллельный DML, но табличная
копия все еще необходима</h4>
<p>Некоторый другой вызов <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> позволяет параллельный DML, но все еще требует табличной копии.
</p>

<ul><li><p>Добавление, удаление или переупорядочивание столбцов.</li>
<li>Добавление или удаление <a href="glossary.htm#glos_primary_key">
primary key</a>.</li>

<li>Изменение <code>ROW_FORMAT</code> или <code>KEY_BLOCK_SIZE</code>.</li>
<li>Изменение статуса nullable для столбца.</li>
<li><a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.</li>
<li>Пересоздание с опцией <code>FORCE</code>.</li>
<li>Пересоздание, используя <span><span>null</span></span> <code>ALTER
TABLE ... ENGINE=INNODB</code>.</p></li></ul>

<h4><a name="idm139965324336592"></a>Поддержание CREATE TABLE</h4>
<p>Поскольку Ваша схема базы данных развивается с новыми столбцами, типами
данных, ограничениями, индексами и так далее, держите Ваш
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
современным с последними табличными определениями. Даже с исполнительными
усовершенствованиями DDL онлайн, более эффективно создать устойчивые
структуры базы данных вначале, вместо того, чтобы создать часть схемы и затем
использовать <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> позже.
</p>

<p>Основное исключение: <a href="glossary.htm#glos_secondary_index">
вторичные индексы</a> на таблицах с большими количествами строк. Является,
как правило, самым эффективным составить таблицу со всеми деталями, кроме
вторичного индекса, загрузите данные, затем создать вторичный индекс.
Вы можете использовать тот же самый метод с
<a href="glossary.htm#glos_foreign_key">внешними ключами</a>,
если Вы знаете, что исходные данные чисты и не нуждаются в проверках
непротиворечивости во время процесса загрузки.</p>

<p>Безотносительно последовательности <a href="sql.htm#create-table"><code>
CREATE TABLE</code></a>, <a href="sql.htm#create-index"><code>CREATE INDEX
</code></a>, <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
и подобных запросов, Вы можете получить SQL, который должен восстановить
текущую форму таблицы, делая запрос <code>SHOW CREATE TABLE
<em><code>table</code></em>\G</code> (верхний регистр <code>\G</code> нужен
для опрятного форматирования). Этот вывод показывает такие пункты, как
числовая точность, <code>NOT NULL</code> и <code>CHARACTER SET</code>,
это иногда добавляется негласно, которые Вы можете не учесть, клонируя
таблицу на новой системе или настраивая столбцы внешнего
ключа с идентичным типом.</p>

<h3><a name="innodb-create-index-concurrency"></a>16.12.2.
Работа и соображения параллелизма для Online DDL</h3>
<p><a href="glossary.htm#glos_online_ddl">Online DDL</a>
улучшает несколько аспектов работы MySQL, таких как работа, параллелизм,
доступность и масштабируемость:</p>

<ul><li><p>Поскольку запросы и операции
<a href="glossary.htm#glos_dml">DML</a>
на таблице могут продолжиться, в то время как DDL происходит, приложения,
которые получают доступ к таблице, более отзывчивы. Уменьшенная
<a href="glossary.htm#glos_locking">блокировка</a> и ожидание других
ресурсов всюду по серверу MySQL приводят к большей масштабируемости, даже для
операций, не вовлекающих измененную таблицу.</li>

<li>Для оперативных операций, избегая дискового ввода/вывода и циклов
центрального процессора, чтобы пересоздать таблицу, Вы минимизируете полную
загрузку базы данных и поддерживаете хорошую работу и высокую пропускную
способность во время работы DDL.</li>

<li>Для оперативных операций, потому что меньше данных считано в
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>,
чем если бы все данные были скопированы, Вы избегаете чистки данных, к
которым часто получают доступ, что прежде могло вызвать временное
исполнительное падение после работы DDL.</p></li></ul>

<p>Если работа онлайн требует временных файлов, <code>InnoDB</code>
создает их во временном каталоге по умолчанию, а не в каталоге, содержащем
оригинальную таблицу. Если этот каталог не является достаточно большим, чтобы
содержать такие файлы, Вы, возможно, должны установить
<a href="server.htm#sysvar_tmpdir"><code>tmpdir</code></a>
к иному каталогу. Альтернативно, Вы можете определить отдельный временный
каталог для операций <code>InnoDB</code> online
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, применяя опцию
<a href="#sysvar_innodb_tmpdir"><code>innodb_tmpdir</code></a>.
Эта опция была введена, чтобы помочь избежать временных переполнений
каталога, которые могли произойти в результате больших временных файлов,
создаваемых во время онлайн <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a>. Подробности в <a href="error.htm#temporary-files">разделе
B.5.3.5</a>.</p>

<h4><a name="idm139965324304016"></a>Опции блокировки для Online DDL</h4>
<p>В то время, как таблица InnoDB изменяется работой DDL, таблица может или
не может быть <a href="glossary.htm#glos_locking">блокирована</a>,
в зависимости от внутренних работ и параметра
<code>LOCK</code> <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
По умолчанию MySQL использует такую небольшую блокировку, насколько возможно,
во время работы DDL, Вы определяете параметр, чтобы сделать блокировку более
сильной, чем обычно (таким образом ограничиваете параллельный DML или DML и
запросов), или гарантировать, что некоторая ожидаемая степень блокировки
позволена для работы. Если <code>LOCK</code> определяет уровень блокировки,
которая не доступна для того определенного вида работы DDL, например,
<code>LOCK=SHARED</code> или <code>LOCK=NONE</code> создавая или удаляя
первичный ключ, пункт работает как утверждение, заставляя запрос потерпеть
неудачу с ошибкой. Следующий список показывает различные возможности для
<code>LOCK</code>, от самой разрешающей до самой строгой:</p>

<ul><li><p>Для DDL с <code>LOCK=NONE</code> запросы и параллельный DML
позволены. Этот пункт делает <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> неудачым, если вид работы DDL не может быть выполнен с требуемым
типом блокировки, так что определите <code>LOCK=NONE</code>, если хранение
полностью доступной таблицы жизненно важно, и нормально отменять DDL, если
это невозможно. Например, Вы могли бы использовать этот пункт в DDL для
таблиц, вовлекающих потребительские регистрации или покупки, чтобы избежать
делать те таблицы недоступными, по ошибке создав сложный
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</li>

<li>Для DDL с <code>LOCK=SHARED</code> любые записи в таблицу (то есть,
операции DML) заблокированы, но данные в таблице могут быть считаны. Этот
пункт делает <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
неудачным, если вид работы DDL не может быть выполнен с требуемым типом
блокировки, так что определите <code>LOCK=SHARED</code>, если хранение
таблицы, доступной для запросов, жизненно важно, и нормально отменять DDL,
если это невозможно. Например, Вы могли бы использовать этот пункт в DDL для
таблиц в хранилище данных, где нормально задерживать операции загрузки
данных, пока DDL не закончен, но запросы не могут быть отсрочены в
течение длительных периодов.</li>

<li>Для DDL с <code>LOCK=DEFAULT</code> или без <code>LOCK</code> MySQL
использует самый низкий уровень блокировки, которая доступна для такой
работы, позволяя параллельные запросы и DML везде, где возможно. Это
установка, чтобы использовать, производя предварительно запланированные и
проверенные изменения, которые Вы знаете, не будет вызывать проблем
доступности, основанных на рабочей нагрузке для этой таблицы.</li>

<li>Для DDL с <code>LOCK=EXCLUSIVE</code> блокировано все. Этот пункт делает
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> неудачным, если
вид работы DDL не может быть выполнен с требуемым типом блокировки, так что
определите <code>LOCK=EXCLUSIVE</code>, если первоочередная задача
заканчивает DDL в самое короткое возможное время, и нормально, что заявки
ждут, когда они пытаются получить доступ к таблице. Вы могли бы также
использовать <code>LOCK=EXCLUSIVE</code>, если сервер, как предполагается,
неактивен, чтобы избегать неожиданных доступов к таблице.</p></li></ul>

<p>В зависимости от внутренних работ online DDL и <code>LOCK</code> в
<code>ALTER TABLE</code>, online DDL может ждать того, чтобы
в настоящее время выполняемые транзакции, которые получают доступ к таблице,
завершились прежде, чем завершиться, потому что эксклюзивный доступ к таблице
требуется в течение краткого времени во время начальных и заключительных фаз
работы DDL. Эти online DDL также ждут завершения получающих доступ к таблице
транзакций, запущенных в то время, как DDL происходит. Следовательно, в
случае долгого рабочего операционного выполнения вставки, обновления,
удаления или <code>SELECT ... FOR UPDATE</code> на таблице, онлайн
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
может исчерпать время, поскольку это ждет эксклюзивного доступа к таблице.
Операции DML, которые выполнены на таблице в то время, как онлайн
<code>ALTER TABLE</code> ждет исключительной табличной блокировки, могут
также быть заблокированы.</p>

<p>Поскольку есть некоторая работа обработки, связанная с записью изменений,
произведенных параллельными операциями DML, затем применяя те изменения в
конце, работа DDL онлайн могла занять больше времени, чем механизм в
старинном стиле, который блокирует табличный доступ от других сеансов.
Сокращение сырой работы сбалансировано относительно лучшего отклика для
приложений, которые используют таблицу. Оценивая идеальные методы для
структуры изменения таблицы, рассмотрите восприятие конечного пользователя
работы, основанной на факторах, таких как времена загрузки для веб-страниц.
</p>

<p>Недавно создаваемый вторичный индекс
\содержит только преданные данные в таблице в то время, как
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> заканчивает
выполняться. Это не содержит нейтральных значений, старых версий значений или
отмеченных для удаления значений.</p>

<h4><a name="idm139965324267904"></a>Исполнение оперативных операций DDL
против копирующих таблицу</h4>
<p>Сырое исполнение работы DDL онлайн в значительной степени определено тем,
выполнена ли работа оперативно или требует копирования и восстановления всей
таблицы. См. <a href="#innodb-online-ddl-summary-grid">таблицу 16.9
</a>, чтобы видеть, какие виды операций могут быть выполнены оперативно, и
любые требования для того, чтобы избежать операций табличной копии.</p>

<p>Исполнительное ускорение от оперативного DDL относится к операциям на
вторичном индексе, не к первичному ключу. Строки таблицы InnoDB сохранены в
<a href="glossary.htm#glos_clustered_index">кластеризируемом индексе</a>
организованном, основываясь на <a href="glossary.htm#glos_primary_key">
primary key</a>, формируя то, что некоторые системы базы данных называют
<span><span>index-organized table</span></span>. Поскольку структура таблицы
близко связана с первичным ключом, пересмотр первичного ключа все еще
требует копирования данных.</p>

<p>Когда работа с первичным ключом использует <code>ALGORITHM=INPLACE</code>,
даже при том, что данные все еще скопированы, это более эффективно, чем
использование <code>ALGORITHM=COPY</code>:</p>

<ul><li><p>Никакое журналирование отмены не требуется для
<code>ALGORITHM=INPLACE</code>. Эти операции добавляют издержки к запросам
DDL, которые используют <code>ALGORITHM=COPY</code>.</li>

<li>Вторичные индексные записи, предварительно сортированы и могут быть
загружены в нужном порядке.</li>
<li>Буфер изменения не используется, потому что нет никаких произвольных
вставок во вторичный индекс.</p></li></ul>

<p>Чтобы судить относительное исполнение операций DDL онлайн, Вы можете
выполнить такие операции на большой таблице <code>InnoDB</code>,
используя текущие и более ранние версии MySQL. Вы можете также выполнить все
тесты производительности под последней версией MySQL, моделируя предыдущее
поведение DDL для <span><span>предыдущих</span></span> результатов,
устанавливая <a href="server.htm#sysvar_old_alter_table"><code>
old_alter_table</code></a>. Скомандуйте <code>set old_alter_table=1</code> в
сеансе и примените DDL, чтобы сделать запись <span><span>предварительных
</span></span> чисел. Затем верните <code>set old_alter_table=0</code>,
чтобы повторно включить более новое, более быстрое поведение и выполните
операции DDL снова, чтобы сделать запись чисел <span><span>после</span>
</span>.</p>

<p>Для основной идеи о том, делает ли работа DDL свои оперативные изменения
или выполняет табличную копию, см. значение <span><span>rows affected</span>
</span>, выведенное на экран после того, как команда заканчивается. Например,
вот строки, которые Вы могли бы видеть после выполнения различных
типов операций DDL:</p>

<ul><li><p>Изменяя значение по умолчанию столбца (сверхбыстро, не
затрагивает табличные данные вообще):
<pre>
Query OK, 0 rows affected (0.07 sec)
</pre></li>

<li>Добавление индексирования (занимает время, но <code>0 rows affected
</code> говорит, что таблица не скопирована):
<pre>
Query OK, 0 rows affected (21.42 sec)
</pre></li>

<li>Изменение типа данных столбца (занимает время и действительно требует
пересоздания всех строк таблицы):
<pre>
Query OK, 1671168 rows affected (1 min 35.54 sec)
</pre>

<p>Изменение типа данных столбца требует восстановления всех строк таблицы за
исключением изменения размера <a href="types.htm#char"><code>VARCHAR</code>
</a>, который может быть выполнен, используя онлайн
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p></li></ul>

<p>Например, прежде, чем выполнить работу DDL на большой таблице, Вы могли бы
проверить, будет ли работа быстра или замедлится следующим образом:</p>
<ol type="1"><li><p>Клонируйте структуру таблицы.</li>
<li>Заполните клонированную таблицу крошечным объемом данных.</li>

<li>Выполните работу DDL на клонированной таблице.</li>
<li>Проверьте, является ли <span><span>rows affected</span></span>
нолем или нет. Ненулевое значение означает, что работа потребует
восстановления всей таблицы, которая могла бы потребовать специального
планирования. Например, Вы могли бы сделать работу DDL во время периода
запланированного времени простоя, или на каждом ведомом сервере
репликации по одному.</p></li></ol>

<p>Для более глубокого понимания сокращения обработки MySQL, исследуйте
таблицы <code>performance_schema</code> и <code>INFORMATION_SCHEMA</code>,
связанные с <code>InnoDB</code>, до и после DDL, чтобы видеть число
физических чтений, записей, распределения памяти и так далее.</p>

<h3><a name="innodb-online-ddl-syntax"></a>16.12.3.
Синтаксис SQL для онлайн DDL</h3>
<p>Как правило, Вы не должны сделать ничего специального, чтобы включить
<a href="glossary.htm#glos_online_ddl">online DDL</a>, используя
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. См.
<a href="#innodb-online-ddl-summary-grid">таблицу 16.9</a>
для видов операций DDL, которые могут быть выполнены оперативно, позволяя
параллельный DML. Некоторые изменения требуют особых комбинаций настроек
конфигурации или параметров <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a>.</p>

<p>Вы можете управлять различными аспектами особой работы DDL онлайн при
использовании <code>LOCK</code> и <code>ALGORITHM</code> в
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Эти пункты
стоят в конце запроса, отделенные от таблицы и технических требований столбца
запятыми. <code>LOCK</code> полезен для точной настройки степени
параллельного доступа к таблице. <code>ALGORITHM</code>
прежде всего предназначен для исполнительных сравнений и как отступление к
более старому копирующему таблицу поведению в случае, если Вы сталкиваетесь с
любыми проблемами с существующим кодом DDL. Например:</p>

<ul><li><p>Чтобы избежать случайно сделать таблицу недоступной, определите
в <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> параметр
<code>LOCK=NONE</code> (разрешает чтения и записи)
<code>LOCK=SHARED</code> (только чтения).
Работа немедленно останавливается, если требуемый
уровень параллелизма недоступен.</li>

<li>Чтобы сравнить работу, выполните запрос с
<code>ALGORITHM=INPLACE</code> и другой с <code>ALGORITHM=COPY</code>,
как альтернатива установке опции <a href="server.htm#sysvar_old_alter_table">
<code>old_alter_table</code></a>.</li>

<li>Избегайте связывать сервер операцией
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, которая копирует
таблицу, включая <code>ALGORITHM=INPLACE</code>. Запрос немедленно
останавливается, если не может использовать оперативный механизм. См.
<a href="#innodb-online-ddl-summary-grid">таблицу 16.9</a> для
списка операций DDL, которые могут или не могут быть выполнены оперативно.
</p></li></ul>

<p>См. <a href="#innodb-create-index-concurrency">раздел 16.12.2
</a> для большего количества деталей о <code>LOCK</code>.
Для полных примеров использования онлайн DDL см.
<a href="#innodb-create-index-examples">раздел 16.12.5</a>.</p>

<h3><a name="innodb-online-ddl-single-multi"></a>16.12.4.
Объединение или отделение запросов DDL</h3>
<p>Перед введением <a href="glossary.htm#glos_online_ddl">online DDL</a>
было обычной практикой объединить много операций DDL в один запрос
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Поскольку каждый <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
вовлекал копирование и восстановление таблицы, было более эффективно
произвести несколько изменений в той же самой таблице сразу, так как те
изменения могли все быть сделаны сразу. Проблема была в том, что код SQL,
вовлекающий операции DDL, было трудно поддержать и снова использовать в
различных скриптах. Определенные изменения отличались каждый раз, когда
Вам, возможно, придется создать новый <a href="sql.htm#alter-table"><code>
ALTER TABLE</code></a> для каждого немного отличающегося скрипта.</p>

<p>Для DDL, которые могут быть сделаны оперативно, как показано в
<a href="#innodb-online-ddl-summary-grid">таблице 16.9</a>,
теперь Вы можете разделить их на отдельные <a href="sql.htm#alter-table">
<code>ALTER TABLE</code></a> для более легких сценариев и обслуживания, не
жертвуя эффективностью. Например, Вы могли бы взять сложный
запрос, такой как:
<pre>
ALTER TABLE t1 ADD INDEX i1(c1), ADD UNIQUE INDEX i2(c2),
      CHANGE c4_old_name c4_new_name INTEGER UNSIGNED;
</pre>

<p>и поделить это на более простые части, которые могут быть
проверены и выполнены независимо:
<pre>
ALTER TABLE t1 ADD INDEX i1(c1);
ALTER TABLE t1 ADD UNIQUE INDEX i2(c2);
ALTER TABLE t1 CHANGE c4_old_name c4_new_name INTEGER UNSIGNED NOT NULL;
</pre>

<p>Вы могли бы все еще использовать многослойный
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> для:</p>
<ul><li><p>Операции, которые должны быть выполнены в определенной
последовательности, такие как создание индексирования, сопровождаемого
ограничением внешнего ключа.</li>

<li>Операции, которые не могут быть выполнены оперативно,
то есть, все еще копируют таблицу.</li>
<li>Операции, для которых Вы определяете <code>ALGORITHM=COPY</code> или
<a href="server.htm#sysvar_old_alter_table"><code>old_alter_table=1</code>
</a>, чтобы вызвать копирующее таблицу поведение если нужно для точной
прежней совместимости в специализированных ситуациях.</p></li></ul>

<h3><a name="innodb-create-index-examples"></a>16.12.5. Примеры Online DDL
</h3>
<p>Вот примеры кода, показывающих некоторые операции, работа которых,
параллелизм и масштабируемость улучшены последними улучшениями
<a href="glossary.htm#glos_online_ddl">online DDL</a>.</p>

<ul><li><p><a href="#online-ddl-ex-setup">
Пример 16.1</a> настраивает таблицы
<code>BIG_TABLE</code> и <code>SMALL_TABLE</code>,
используемые в последующих примерах.</li>

<li><a href="#online-ddl-ex-create-drop-index">
Пример 16.2</a> иллюстрирует исполнительные аспекты
создания и удаления индексов.</li>

<li><a href="#online-ddl-ex-concurrent-dml">
Пример 16.3</a> показывает запросы DML, работающие во время
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a>.</li>

<li><a href="#online-ddl-ex-rename-column">
Пример 16.4</a> демонстрирует усовершенствование скорости для того, чтобы
переименовать столбец, и показывает, что важно сохранить тип данных точно
тем же самым, делая переименование.</li>

<li><a href="#online-ddl-ex-drop-foreign-key">
Пример 16.5</a> демонстрирует, как внешние ключи работают с DDL онлайн.
Поскольку две таблицы вовлечены в операции внешнего ключа, есть
дополнительные соображения блокировки. Таким образом, у таблиц с внешними
ключами иногда есть ограничения для операций DDL онлайн.</li>

<li><a href="#online-ddl-ex-auto-increment">
Пример 16.6</a> демонстрирует, как столбцы auto-increment
работают с DDL онлайн. У таблиц со столбцами auto-increment
иногда есть ограничения для операций DDL онлайн.</li>

<li><a href="#online-ddl-ex-lock-clause">
Пример 16.7</a> демонстрирует опции, чтобы разрешить или ограничить
параллельные запросы и операции DML, в то время как работа DDL онлайн
происходит. Это показывает ситуации, когда запрос DDL или параллельная
транзакция могли бы ждать, или параллельная транзакция могла бы отменить
запрос DML из-за ошибки тупика.</li>

<li><a href="#online-ddl-ex-multi-create-index">
Пример 16.8</a> демонстрирует создание и удаление нескольких индексов в
в единственном запросе, которое может быть более эффективным, чем
использование отдельного запроса для каждого индекса.</li>

<li><a href="#online-ddl-ex-primary-key">
Пример 16.9</a> демонстрирует, как более эффективно определить
<a href="glossary.htm#glos_primary_key">primary key</a>, составляя таблицу,
и относительно дорого добавить еще один позже.</p></li></ul>

<a name="online-ddl-ex-setup"></a><p><b>Пример 16.1. Установки схемы для
экспериментов DDL онлайн</b></p>
<p>Вот код, который настраивает начальные таблицы,
используемые в этих демонстрациях:</p>

<a name="online-ddl-setup"></a>
<pre>
/*
Setup code for the online DDL demonstration:
- Set up some config variables.
- Create 2 tables that are clones of one of the INFORMATION_SCHEMA tables
  that always has some data. The "small" table has a couple of thousand rows.
  For the "big" table, keep doubling the data until it reaches over a million rows.
- Set up a primary key for the sample tables, since we are demonstrating InnoDB aspects.
*/

set autocommit = 0;
set foreign_key_checks = 1;
set global innodb_file_per_table = 1;
set old_alter_table=0;
prompt mysql:

use test;

\! echo "Setting up 'small' table:"
drop table if exists small_table;
create table small_table as select * from information_schema.columns;
alter table small_table add id int unsigned not null primary key auto_increment;
select count(id) from small_table;

\! echo "Setting up 'big' table:"
drop table if exists big_table;
create table big_table as select * from information_schema.columns;
show create table big_table\G

insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
insert into big_table select * from big_table;
commit;

alter table big_table add id int unsigned not null primary key auto_increment;
select count(id) from big_table;
</pre>

<p>
Running this code gives this output, condensed for brevity and
with the most important points bolded:
<pre>
Setting up 'small' table:
Query OK, 0 rows affected (0.01 sec)

Query OK, 1678 rows affected (0.13 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 1678 rows affected (0.07 sec)
Records: 1678  Duplicates: 0  Warnings: 0
+-----------+
| count(id) |
+-----------+
|  <span><strong>1678</strong></span> |
+-----------+
1 row in set (0.00 sec)

Setting up 'big' table:
Query OK, 0 rows affected (0.16 sec)

Query OK, 1678 rows affected (0.17 sec)
Records: 1678  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
   Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT ''
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

Query OK, 1678 rows affected (0.09 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 3356 rows affected (0.07 sec)
Records: 3356  Duplicates: 0  Warnings: 0

Query OK, 6712 rows affected (0.17 sec)
Records: 6712  Duplicates: 0  Warnings: 0

Query OK, 13424 rows affected (0.44 sec)
Records: 13424  Duplicates: 0  Warnings: 0

Query OK, 26848 rows affected (0.63 sec)
Records: 26848  Duplicates: 0  Warnings: 0

Query OK, 53696 rows affected (1.72 sec)
Records: 53696  Duplicates: 0  Warnings: 0

Query OK, 107392 rows affected (3.02 sec)
Records: 107392  Duplicates: 0  Warnings: 0

Query OK, 214784 rows affected (6.28 sec)
Records: 214784  Duplicates: 0  Warnings: 0

Query OK, 429568 rows affected (13.25 sec)
Records: 429568  Duplicates: 0  Warnings: 0

Query OK, 859136 rows affected (28.16 sec)
Records: 859136  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.03 sec)
Query OK, 1718272 rows affected (1 min 9.22 sec)
Records: 1718272  Duplicates: 0  Warnings: 0
+-----------+
| count(id) |
+-----------+
|   <span><strong>1718272</strong></span> |
+-----------+
1 row in set (1.75 sec)
</pre>

<a name="online-ddl-ex-create-drop-index"></a><p><b>
Пример 16.2. Скорость и эффективность CREATE INDEX и DROP INDEX</b></p>
<p>Вот последовательность запросов, демонстрирующих относительную скорость
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a> и
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a>.
Для маленькой таблицы прошедшее время меньше, чем секунда, используем ли мы
быстрый или медленный метод, таким образом, мы смотрим на <span><span>rows
affected</span></span>, чтобы проверить, какие операции могут избежать
пересоздания таблицы. Для большой таблицы различие в эффективности очевидно,
потому что пропуск пересоздания таблицы экономит существенное время.</p>

<a name="online-ddl-create_drop_index"></a>
<pre>
\! clear

\! echo "=== Create and drop index (small table, new/fast technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/small_table.ibd
create index i_dtyp_small on small_table (data_type)<span><strong>, algorithm=inplace</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/small_table.ibd
drop index i_dtyp_small on small_table<span><strong>, algorithm=inplace</strong></span>;

-- Compare against the older slower DDL.

\! echo "=== Create and drop index (small table, old/slow technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/small_table.ibd
create index i_dtyp_small on small_table (data_type)<span><strong>, algorithm=copy</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/small_table.ibd
drop index i_dtyp_small on small_table<span><strong>, algorithm=copy</strong></span>;

-- In the above example, we examined the "rows affected" number,
-- ideally looking for a zero figure. Let's try again with a larger
-- sample size, where we'll see that the actual time taken can
-- vary significantly.

\! echo "=== Create and drop index (big table, new/fast technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/big_table.ibd
create index i_dtyp_big on big_table (data_type)<span><strong>, algorithm=inplace</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/big_table.ibd
drop index i_dtyp_big on big_table<span><strong>, algorithm=inplace</strong></span>;

\! echo "=== Create and drop index (big table, old/slow technique) ==="
\! echo
\! echo "Data size (kilobytes) before index created: "
\! du -k data/test/big_table.ibd
create index i_dtyp_big on big_table (data_type)<span><strong>, algorithm=copy</strong></span>;
\! echo "Data size after index created: "
\! du -k data/test/big_table.ibd
drop index i_dtyp_big on big_table<span><strong>, algorithm=copy</strong></span>;
</pre>

<p>Выполнение этого кода дает этот вывод, сжатый для краткости и с выделенными
наиболее важными моментами:
<pre>
Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (small table, new/fast technique) ===

Data size (kilobytes) before index created:
384  data/test/small_table.ibd
Query OK, <span><strong>0 rows affected</strong></span> (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

Data size after index created:
432  data/test/small_table.ibd
Query OK, <span><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (small table, old/slow technique) ===

Data size (kilobytes) before index created:
432  data/test/small_table.ibd
Query OK, <span><strong>1678 rows affected</strong></span> (0.12 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Data size after index created:
448  data/test/small_table.ibd
Query OK, <span><strong>1678 rows affected</strong></span> (0.10 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (big table, new/fast technique) ===

Data size (kilobytes) before index created:
315392  data/test/big_table.ibd
Query OK, <span><strong>0 rows affected</strong></span> (33.32 sec)
Records: 0  Duplicates: 0  Warnings: 0

Data size after index created:
335872  data/test/big_table.ibd
Query OK, <span><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)

=== Create and drop index (big table, old/slow technique) ===

Data size (kilobytes) before index created:
335872  data/test/big_table.ibd
Query OK, <span><strong>1718272 rows affected</strong></span> (1 min 5.01 sec)
Records: 1718272  Duplicates: 0  Warnings: 0

Data size after index created:
348160  data/test/big_table.ibd
Query OK, <span><strong>1718272 rows affected</strong></span> (46.59 sec)
Records: 1718272  Duplicates: 0  Warnings: 0
</pre>

<a name="online-ddl-ex-concurrent-dml"></a><p><b>
Пример 16.3. Параллельные DML во время DML CREATE INDEX и DROP INDEX</b></p>
<p>Вот некоторые отрывки кода, которые выполнены в отдельных сессиях
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>,
соединенных с той же самой базой данных, чтобы иллюстрировать запрос DML
(вставка, обновление или удаление), работающий в то же самое время, как
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a> и
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a>.
<pre>
/*
CREATE INDEX statement to run against a table while
insert/update/delete statements are modifying the
column being indexed.
*/

-- Run this script in one session, while simultaneously creating and dropping
-- an index on test/big_table.table_name in another session.

use test;
create index i_concurrent on big_table(table_name);

/*
DROP INDEX statement to run against a table while
insert/update/delete statements are modifying the
column being indexed.
*/

-- Run this script in one session, while simultaneously creating and dropping
-- an index on test/big_table.table_name in another session.

use test;
drop index i_concurrent on big_table;

/*
Some queries and insert/update/delete statements to run against a table
while an index is being created or dropped. Previously, these operations
would have stalled during the index create/drop period and possibly
timed out or deadlocked.
*/

-- Run this script in one session, while simultaneously creating and dropping
-- an index on test/big_table.table_name in another session.

-- In the test instance, that column has about 1.7M rows, with 136 different values.
-- Sample values: COLUMNS (20480), ENGINES (6144), EVENTS (24576), FILES (38912),
-- TABLES (21504), VIEWS (10240).

set autocommit = 0;
use test;

select distinct character_set_name from big_table where table_name = 'FILES';
delete from big_table where table_name = 'FILES';
select distinct character_set_name from big_table where table_name = 'FILES';

-- I'll issue the final rollback interactively, not via script,
-- the better to control the timing.
-- rollback;
</pre>

<p>Выполнение этого кода дает этот вывод, сжатый для краткости и с
выделенными наиболее важными моментами:
<pre>
mysql: source concurrent_ddl_create.sql
Database changed
Query OK, <span><strong>0 rows affected</strong></span> (1 min 25.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql: source concurrent_ddl_drop.sql
Database changed
Query OK, <span><strong>0 rows affected</strong></span> (24.98 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql: source concurrent_dml.sql
Query OK, 0 rows affected (0.00 sec)

Database changed
+--------------------+
| character_set_name |
+--------------------+
| NULL               |
| utf8               |
+--------------------+
2 rows in set (0.32 sec)

Query OK, <span><strong>38912 rows affected</strong></span> (1.84 sec)
Empty set (0.01 sec)

mysql: rollback;
Query OK, 0 rows affected (1.05 sec)
</pre>

<a name="online-ddl-ex-rename-column"></a><p><b>
Пример 16.4. Переименование столбца</b></p>
<p>Вот демонстрация использования <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, чтобы переименовать столбец. Мы используем новый быстрый
механизм DDL, чтобы изменить название, потом старый механизм DDL (с
<code>old_alter_table=1</code>), чтобы восстановить оригинальное имя столбца.
</p>

<p>Замечания:</p>
<ul><li><p>Поскольку синтаксис для того, чтобы переименовать столбец также
вовлекает переопределение типа данных, надо определить точно тот же самый тип
данных, чтобы избежать пересоздания таблицы. В этом случае смотрим вывод
<code>show create table <em><code>table</code></em>\G</code> и важные
параметры <code>CHARACTER SET</code> и <code>NOT NULL</code> берем из
оригинального определения столбца.</li>

<li>Переименование столбца для маленькой таблицы достаточно быстро, так что
мы должны исследовать <span><span>rows affected</span></span>, чтобы
проверить, что новый механизм DDL более эффективен, чем старый. С большой
таблицей различие в прошедшем времени делает усовершенствование очевидным.
</p></li></ul>

<a name="online-ddl-rename_column"></a>
<pre>
/*
Run through a sequence of 'rename column' statements.
Because this operation involves only metadata, not table data,
it is fast for big and small tables, with new or old DDL mechanisms.
*/

\! clear
\! echo "Rename column (fast technique, small table):"
alter table small_table change `IS_NULLABLE` `NULLABLE` varchar(3) character
  set utf8 not null<span><strong>, algorithm=inplace</strong></span>;
\! echo "Rename back to original name (slow technique):"
alter table small_table change `NULLABLE` `IS_NULLABLE` varchar(3) character
  set utf8 not null<span><strong>, algorithm=copy</strong></span>;


\! echo "Rename column (fast technique, big table):"
alter table big_table change `IS_NULLABLE` `NULLABLE` varchar(3) character
  set utf8 not null<span><strong>, algorithm=inplace</strong></span>;
\! echo "Rename back to original name (slow technique):"
alter table big_table change `NULLABLE` `IS_NULLABLE` varchar(3) character
  set utf8 not null<span><strong>, algorithm=copy</strong></span>;
</pre>

<p>Выполнение этого кода дает этот вывод, сжатый для краткости и с
выделенными наиболее важными моментами:
<pre>
Rename column (fast technique, small table):
Query OK, 0 rows affected (0.05 sec)

Query OK, <span><strong>0 rows affected</strong></span> (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0

Rename back to original name (slow technique):
Query OK, 0 rows affected (0.00 sec)

Query OK, <span><strong>1678 rows affected</strong></span> (0.35 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Rename column (fast technique, big table):
Query OK, 0 rows affected (0.00 sec)

Query OK, 0 <span><strong>rows affected</strong></span> (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0

Rename back to original name (slow technique):
Query OK, 0 rows affected (0.00 sec)

Query OK, <span><strong>1718272 rows affected</strong></span> (1 min 0.00 sec)
Records: 1718272  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)
</pre>

<a name="online-ddl-ex-drop-foreign-key"></a><p><b>
Пример 16.5. Удаление Foreign Keys</b></p>
<p>Вот демонстрация внешних ключей, включая усовершенствование скорости
удаления ограничения внешнего ключа.</p>

<a name="online-ddl-foreign_key"></a>
<pre>
/*
Demonstrate aspects of foreign keys that are or aren't affected by the DDL improvements.
- Create a new table with only a few values to serve as the parent table.
- Set up the 'small' and 'big' tables as child tables using a foreign key.
- Verify that the ON DELETE CASCADE clause makes changes ripple from parent to child tables.
- Drop the foreign key constraints, and optionally associated indexes. (This is the operation that is sped up.)
*/

\! clear

-- Make sure foreign keys are being enforced, and allow
-- rollback after doing some DELETEs that affect both
-- parent and child tables.
set foreign_key_checks = 1;
set autocommit = 0;

-- Create a parent table, containing values that we know are already present
-- in the child tables.
drop table if exists schema_names;
create table schema_names (id int unsigned not null primary key
       auto_increment, schema_name varchar(64) character set utf8 not null,
       index i_schema (schema_name)) as select distinct
       table_schema schema_name from small_table;

show create table schema_names\G
show create table small_table\G
show create table big_table\G

-- Creating the foreign key constraint still involves a table rebuild when foreign_key_checks=1,
-- as illustrated by the "rows affected" figure.
alter table small_table add constraint small_fk foreign key i_table_schema (table_schema)
  references schema_names(schema_name) on delete cascade;
alter table big_table add constraint big_fk foreign key i_table_schema (table_schema)
  references schema_names(schema_name) on delete cascade;

show create table small_table\G
show create table big_table\G

select schema_name from schema_names order by schema_name;
select count(table_schema) howmany, table_schema from small_table
       group by table_schema;
select count(table_schema) howmany, table_schema from big_table
       group by table_schema;

-- big_table is the parent table.
-- schema_names is the parent table.
-- big_table is the child table.
-- (One row in the parent table can have many "children" in the child table.)
-- Changes to the parent table can ripple through to the child table.
-- For example, removing the value 'test' from schema_names.schema_name will
-- result in the removal of 20K or so rows from big_table.

delete from schema_names where schema_name = 'test';
select schema_name from schema_names order by schema_name;
select count(table_schema) howmany, table_schema from small_table
       group by table_schema;
select count(table_schema) howmany, table_schema from big_table
       group by table_schema;

-- Because we've turned off autocommit, we can still get back those deleted rows
-- if the DELETE was issued by mistake.
rollback;

select schema_name from schema_names order by schema_name;
select count(table_schema) howmany, table_schema from small_table
       group by table_schema;
select count(table_schema) howmany, table_schema from big_table
       group by table_schema;

-- All of the cross-checking between parent and child tables would be
-- deadly slow if there wasn't the requirement for the corresponding
-- columns to be indexed!

-- But we can get rid of the foreign key using a fast operation
-- that doesn't rebuild the table.
-- If we didn't specify a constraint name when setting up the foreign key, we would
-- have to find the auto-generated name such as 'big_table_ibfk_1' in the
-- output from 'show create table'.

-- For the small table, drop the foreign key and the associated index.
-- Having an index on a small table is less critical.

\! echo "DROP FOREIGN KEY and INDEX from small_table:"
alter table small_table drop foreign key small_fk, drop index small_fk;

-- For the big table, drop the foreign key and leave the associated index.
-- If we are still doing queries that reference the indexed column, the index is
-- very important to avoid a full table scan of the big table.
\! echo "DROP FOREIGN KEY from big_table:"
alter table big_table drop foreign key big_fk;
show create table small_table\G
show create table big_table\G
</pre>

<p>Выполнение этого кода дает этот вывод, сжатый для краткости и с
выделенными наиболее важными моментами:
<pre>
Query OK, 0 rows affected (0.00 sec)
Query OK, 0 rows affected (0.00 sec)
Query OK, 0 rows affected (0.01 sec)
Query OK, 4 rows affected (0.03 sec)
Records: 4  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
   Table: schema_names
Create Table: CREATE TABLE `schema_names` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `schema_name` varchar(64) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`), KEY `i_schema` (`schema_name`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

*************************** 1. row ***************************
   Table: small_table
Create Table: CREATE TABLE `small_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1679
  DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

*************************** 1. row ***************************
   Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`),
  <span><strong>KEY `big_fk` (`TABLE_SCHEMA`)</strong></span>
) ENGINE=InnoDB AUTO_INCREMENT=1718273 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

Query OK, 1678 rows affected (0.10 sec)
Records: 1678  Duplicates: 0  Warnings: 0

Query OK, 1718272 rows affected (1 min 14.54 sec)
Records: 1718272  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
   Table: small_table
Create Table: CREATE TABLE `small_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`),
  <span><strong>KEY `small_fk` (`TABLE_SCHEMA`),</strong></span>
  <span><strong>CONSTRAINT `small_fk` FOREIGN KEY (`TABLE_SCHEMA`)
REFERENCES `schema_names` (`schema_name`) ON DELETE CASCADE</strong></span>
) ENGINE=InnoDB AUTO_INCREMENT=1679 DEFAULT CHARSET=latin1
1 row in set (0.12 sec)

*************************** 1. row ***************************
   Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT, PRIMARY KEY (`id`),
  <span><strong>KEY `big_fk` (`TABLE_SCHEMA`),</strong></span>
  <span><strong>CONSTRAINT `big_fk` FOREIGN KEY (`TABLE_SCHEMA`)
  REFERENCES `schema_names` (`schema_name`) ON DELETE CASCADE</strong></span>
) ENGINE=InnoDB AUTO_INCREMENT=1718273 DEFAULT CHARSET=latin1
1 row in set (0.01 sec)

+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
4 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
| 563     | information_schema |
| 286     | mysql              |
| 786     | performance_schema |
|  43     | test               |
+---------+--------------------+
4 rows in set (0.01 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|  576512 | information_schema |
|  292864 | mysql              |
|  804864 | performance_schema |
|   44032 | test               |
+---------+--------------------+
4 rows in set (2.10 sec)
Query OK, 1 row affected (1.52 sec)

+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
+--------------------+
3 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
| 563     | information_schema |
| 286     | mysql              |
| 786     | performance_schema |
+---------+--------------------+
3 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|  576512 | information_schema |
|  292864 | mysql              |
|  804864 | performance_schema |
+---------+--------------------+
3 rows in set (1.74 sec)
Query OK, 0 rows affected (0.60 sec)

+--------------------+
| schema_name        |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| test               |
+--------------------+
4 rows in set (0.00 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
| 563     | information_schema |
| 286     | mysql              |
| 786     | performance_schema |
|  43     | test               |
+---------+--------------------+
4 rows in set (0.01 sec)

+---------+--------------------+
| howmany | table_schema       |
+---------+--------------------+
|  576512 | information_schema |
|  292864 | mysql              |
|  804864 | performance_schema |
|   44032 | test               |
+---------+--------------------+
4 rows in set (1.59 sec)

DROP FOREIGN KEY and INDEX from small_table:
Query OK, <span><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

DROP FOREIGN KEY from big_table:
Query OK, <span><strong>0 rows affected</strong></span> (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

*************************** 1. row ***************************
   Table: small_table
Create Table: CREATE TABLE `small_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1679
  DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

*************************** 1. row ***************************
   Table: big_table
Create Table: CREATE TABLE `big_table` (
  `TABLE_CATALOG` varchar(512) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_SCHEMA` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `TABLE_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_NAME` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `ORDINAL_POSITION` bigint(21) unsigned NOT NULL DEFAULT '0',
  `COLUMN_DEFAULT` longtext CHARACTER SET utf8,
  `IS_NULLABLE` varchar(3) CHARACTER SET utf8 NOT NULL,
  `DATA_TYPE` varchar(64) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `CHARACTER_MAXIMUM_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_OCTET_LENGTH` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `NUMERIC_SCALE` bigint(21) unsigned DEFAULT NULL,
  `DATETIME_PRECISION` bigint(21) unsigned DEFAULT NULL,
  `CHARACTER_SET_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLLATION_NAME` varchar(32) CHARACTER SET utf8 DEFAULT NULL,
  `COLUMN_TYPE` longtext CHARACTER SET utf8 NOT NULL,
  `COLUMN_KEY` varchar(3) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `EXTRA` varchar(30) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `PRIVILEGES` varchar(80) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `COLUMN_COMMENT` varchar(1024) CHARACTER SET utf8 NOT NULL DEFAULT '',
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`id`), KEY `big_fk` (`TABLE_SCHEMA`)
) ENGINE=InnoDB AUTO_INCREMENT=1718273 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre>

<a name="online-ddl-ex-auto-increment"></a><p><b>
Пример 16.6. Изменение значений Auto-Increment</b></p>
<p>Вот иллюстрация увеличения нижнего предела
<a href="glossary.htm#glos_auto_increment">auto-increment</a>
для столбца таблицы, демонстрируя, как эта работа теперь обходит
пересоздание таблицы плюс другие факты о столбцах
<code>InnoDB</code> auto-increment.</p>

<a name="online-ddl-autoinc"></a>
<pre>
/*
If this script is run after foreign_key.sql, the schema_names table is
already set up. But to allow this script to run multiple times without
running into duplicate ID errors, we set up the schema_names table
all over again.
*/

\! clear
\! echo "=== Adjusting the Auto-Increment Limit for a Table ==="
\! echo

drop table if exists schema_names;
create table schema_names (id int unsigned not null primary key auto_increment,
  schema_name varchar(64) character set utf8 not null, index i_schema (schema_name))
  as select distinct table_schema schema_name from small_table;

\! echo "Initial state of schema_names table."
\! echo "AUTO_INCREMENT is included in SHOW CREATE TABLE output."
\! echo "Note how MySQL reserved a block of IDs."
\! echo "Only 4 IDs are needed in this transaction. The next inserted values get IDs 8 and 9."
show create table schema_names\G
select * from schema_names order by id;

\! echo "Inserting even a tiny amount of data can produce gaps in the ID sequence."
insert into schema_names (schema_name) values ('eight'), ('nine');

\! echo "Bumping auto-increment lower limit to 20 (fast mechanism):"
alter table schema_names auto_increment=20<span><strong>, algorithm=inplace</strong></span>;

\! echo "Inserting 2 rows that should get IDs 20 and 21:"
insert into schema_names (schema_name) values ('foo'), ('bar');
commit;

\! echo "Bumping auto-increment lower limit to 30 (slow mechanism):"
alter table schema_names auto_increment=30<span><strong>, algorithm=copy</strong></span>;

\! echo "Inserting 2 rows that should get IDs 30 and 31:"
insert into schema_names (schema_name) values ('bletch'),('baz');
commit;

select * from schema_names order by id;

\! echo "Final state of schema_names table."
\! echo "AUTO_INCREMENT value shows the next inserted row would get ID=32."
show create table schema_names\G
</pre>

<p>Выполнение этого кода дает этот вывод, сжатый для краткости и с
выделенными наиболее важными моментами:
<pre>
=== Adjusting the Auto-Increment Limit for a Table ===

Query OK, 0 rows affected (0.01 sec)
Query OK, 4 rows affected (0.02 sec)
Records: 4  Duplicates: 0  Warnings: 0

Initial state of schema_names table.
AUTO_INCREMENT is included in SHOW CREATE TABLE output.
Note how MySQL reserved a block of IDs.
Only 4 IDs are needed in this transaction.
The next inserted values get IDs 8 and 9.
*************************** 1. row ***************************
   Table: schema_names
Create Table: CREATE TABLE `schema_names` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `schema_name` varchar(64) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`), KEY `i_schema` (`schema_name`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

+----+--------------------+
| id | schema_name        |
+----+--------------------+
|  1 | information_schema |
|  2 | mysql              |
|  3 | performance_schema |
|  4 | test               |
+----+--------------------+
4 rows in set (0.00 sec)

Inserting even a tiny amount of data can produce gaps in the ID sequence.
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)
Bumping auto-increment lower limit to 20 (fast mechanism):
Query OK, <span><strong>0 rows affected</strong></span> (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

Inserting 2 rows that should get IDs 20 and 21:
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.00 sec)
Query OK, 0 rows affected (0.00 sec)

Bumping auto-increment lower limit to 30 (slow mechanism):
Query OK, <span><strong>8 rows affected</strong></span> (0.02 sec)
Records: 8  Duplicates: 0  Warnings: 0

Inserting 2 rows that should get IDs 30 and 31:
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

Query OK, 0 rows affected (0.01 sec)

+----+--------------------+
| id | schema_name        |
+----+--------------------+
|  1 | information_schema |
|  2 | mysql              |
|  3 | performance_schema |
|  4 | test               |
|  8 | eight              |
|  9 | nine               |
| 20 | foo                |
| 21 | bar                |
| 30 | bletch             |
| 31 | baz                |
+----+--------------------+
10 rows in set (0.00 sec)
Query OK, 0 rows affected (0.00 sec)

Final state of schema_names table.
AUTO_INCREMENT value shows the next inserted row would get ID=32.
*************************** 1. row ***************************
   Table: schema_names
Create Table: CREATE TABLE `schema_names` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `schema_name` varchar(64) CHARACTER SET utf8 NOT NULL,
  PRIMARY KEY (`id`), KEY `i_schema` (`schema_name`)
) ENGINE=InnoDB <span><strong>AUTO_INCREMENT=32</strong></span>
  DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
</pre>

<a name="online-ddl-ex-lock-clause"></a><p><b>
Пример 16.7. Параллелизм управления с LOCK</b></p>
<p>Этот пример показывает, как использовать <code>LOCK</code> в
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, чтобы позволить
или лишить параллельного доступа к таблице, в то время как происходит работа
DDL онлайн. Есть настройки, которые позволяют запросы
<a href="glossary.htm#glos_dml">DML</a> (<code>LOCK=NONE</code>), только
<a href="glossary.htm#glos_query">запросы</a> (<code>LOCK=SHARED</code>) или
никакой параллельный доступ вообще (<code>LOCK=EXCLUSIVE</code>).</p>

<p>В одном сеансе мы выполняем последовательность
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, чтобы создать и
удалить индекс, используя различные значения для <code>LOCK</code>, чтобы
видеть, что происходит с ожиданием или заведением в тупик в любом сеансе. Мы
используем ту же самую таблицу <code>BIG_TABLE</code>, как в предыдущих
примерах, запускающихся приблизительно с 1.7 миллионов строк. В целях
иллюстрации мы индексируем и запросим столбец <code>IS_NULLABLE</code>.
Хотя в действительности было бы глупо сделать индексирование для крошечного
столбца только с 2 отличными значениями.
<pre>
mysql: desc big_table;
+------------------+---------------------+------+-----+---------+-------+
| Field            | Type                | Null | Key | Default | Extra |
+------------------+---------------------+------+-----+---------+-------+
| TABLE_CATALOG    | varchar(512)        | NO   |     |         |       |
| TABLE_SCHEMA     | varchar(64)         | NO   |     |         |       |
| TABLE_NAME       | varchar(64)         | NO   |     |         |       |
| COLUMN_NAME      | varchar(64)         | NO   |     |         |       |
| ORDINAL_POSITION | bigint(21) unsigned | NO   |     | 0       |       |
| COLUMN_DEFAULT   | longtext            | YES  |     | NULL    |       |

| IS_NULLABLE      | varchar(3)          | NO   |     |         |       |</strong></span>
...
+------------------+---------------------+------+-----+---------+-------+
21 rows in set (0.14 sec)

mysql: alter table big_table add index i1(is_nullable);
Query OK, 0 rows affected (20.71 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.02 sec)

mysql: alter table big_table add index i1(is_nullable)<span><strong>, lock=exclusive</strong></span>;
Query OK, 0 rows affected (19.44 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.03 sec)

mysql: alter table big_table add index i1(is_nullable)<span><strong>, lock=shared</strong></span>;
Query OK, 0 rows affected (16.71 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.05 sec)

mysql: alter table big_table add index i1(is_nullable)<span><strong>, lock=none</strong></span>;
Query OK, 0 rows affected (12.26 sec)

mysql: alter table big_table drop index i1;
Query OK, 0 rows affected (0.01 sec)

... repeat statements like the above while running queries ...
... and DML statements at the same time in another session ...
</pre>

<p>Ничто драматическое не происходит в сеансе, выполняющем запросы DDL.
Иногда <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
работает необычно долго, потому что это ждет завершения другой транзакции,
так как та транзакция изменила таблицу во время DDL или запросила
таблицу перед DDL:
<pre>
mysql: alter table big_table add index i1(is_nullable), lock=none;
<span><strong>Query OK, 0 rows affected (59.27 sec)</strong></span>

mysql: -- The previous ALTER took so long because it was waiting for all the concurrent
mysql: -- transactions to commit or roll back.

mysql: alter table big_table drop index i1;
<span><strong>Query OK, 0 rows affected (41.05 sec)</strong></span>

mysql: -- Even doing a SELECT on the table in the other session first causes
mysql: -- the ALTER TABLE above to stall until the transaction
mysql: -- surrounding the SELECT is committed or rolled back.
</pre>

<p>Вот журнал от другого сеанса, работающего одновременно, где мы выпускаем
запросы данных и запросы DML для таблицы прежде, во время и после операций
DDL, показанных в предыдущих примерах. Первый листинг показывает только
запросы. Мы ожидаем, что запросы будут позволены во время использования
операций DDL через <code>LOCK=NONE</code> или <code>LOCK=SHARED</code>,
и запроса будет ждать, пока DDL не закончен, если
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> включает
<code>LOCK=EXCLUSIVE</code>.
<pre>
mysql: show variables like 'autocommit';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| autocommit    | ON    |
+---------------+-------+
1 row in set (0.01 sec)

mysql: -- A trial query before any ADD INDEX in the other session:
mysql: -- Note: because autocommit is enabled, each
mysql: -- transaction finishes immediately after the query.
mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+
2 rows in set (4.49 sec)

mysql: -- Index is being created with LOCK=EXCLUSIVE on the ALTER statement.
mysql: -- The query waits until the DDL is finished before proceeding.
mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+
<span><strong>2 rows in set (17.26 sec)</strong></span>

mysql: -- Index is being created with LOCK=SHARED on the ALTER statement.
mysql: -- The query returns its results while the DDL is in progress.
mysql: -- The same thing happens with LOCK=NONE on the ALTER statement.
mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+
<span><strong>2 rows in set (3.11 sec)</strong></span>

mysql: -- Once the index is created, and with no DDL in progress,
mysql: -- queries referencing the indexed column are very fast:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
<span><strong>1 row in set (0.20 sec)</strong></span>

mysql: select distinct is_nullable from big_table;
+-------------+
| is_nullable |
+-------------+
| NO          |
| YES         |
+-------------+
<span><strong>2 rows in set (0.00 sec)</strong></span>
</pre>

<p>Теперь в этом параллельном сеансе, мы выполняем некоторые транзакции,
включая запрос DML или комбинацию запросов DML и запросов данных. Применим
<a href="sql.htm#delete"><code>DELETE</code></a>, чтобы иллюстрировать
предсказуемые изменения таблицы. Поскольку транзакции в этой части могут
охватить много запросов, мы выполняем эти тесты с выключенным
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>.
<pre>
mysql: set global autocommit = off;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Count the rows that will be involved in our DELETE statements:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
1 row in set (0.95 sec)

mysql: -- After this point, any DDL statements back in the other session
mysql: -- stall until we commit or roll back.

mysql: delete from big_table where is_nullable = 'YES' limit 11648;
Query OK, 11648 rows affected (0.14 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (1.04 sec)

mysql: rollback;
Query OK, 0 rows affected (0.09 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
1 row in set (0.93 sec)

mysql: -- OK, now we're going to try that during index creation with LOCK=NONE.
mysql: delete from big_table where is_nullable = 'YES' limit 11648;
Query OK, 11648 rows affected (0.21 sec)

mysql: -- We expect that now there will be 400000 'YES' rows left:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (1.25 sec)

mysql: -- In the other session, the ALTER TABLE is waiting before finishing,
mysql: -- because _this_ transaction hasn't committed or rolled back yet.
mysql: rollback;
Query OK, 0 rows affected (0.11 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   411648 |
+----------+
1 row in set (0.19 sec)

mysql: -- The ROLLBACK left the table in the same state we originally found it.
mysql: -- Now let's make a permanent change while the index is being created,
mysql: -- again with ALTER TABLE ... , LOCK=NONE.
mysql: -- First, commit so the DROP INDEX in the other shell can finish;
mysql: -- the previous SELECT started a transaction that accessed the table.
mysql: commit;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Now we add the index back in the other shell, then issue DML in this one
mysql: -- while the DDL is running.
mysql: delete from big_table where is_nullable = 'YES' limit 11648;
Query OK, 11648 rows affected (0.23 sec)

mysql: commit;
Query OK, 0 rows affected (0.01 sec)

mysql: -- In the other shell, the ADD INDEX has finished.
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (0.19 sec)

mysql: -- At the point the new index is finished being created, it contains entries
mysql: -- only for the 400000 'YES' rows left when all concurrent transactions are finished.
mysql:
mysql: -- Now we will run a similar test, while ALTER TABLE ... , LOCK=SHARED is running.
mysql: -- We expect a query to complete during the ALTER TABLE, but for the DELETE
mysql: -- to run into some kind of issue.
mysql: commit;
Query OK, 0 rows affected (0.00 sec)

mysql: -- As expected, the query returns results while the LOCK=SHARED DDL is running:
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (2.07 sec)

mysql: -- The DDL in the other session is not going to finish until this transaction
mysql: -- is committed or rolled back. If we tried a DELETE now and it waited because
mysql: -- of LOCK=SHARED on the DDL, both transactions would wait forever (deadlock).
mysql: -- MySQL detects this condition and cancels the attempted DML statement.
mysql: delete from big_table where is_nullable = 'YES' limit 100000;
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
mysql: -- The transaction here is still going, so in the other shell, the ADD INDEX operation
mysql: -- is waiting for this transaction to commit or roll back.
mysql: rollback;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Now let's try issuing a query and some DML, on one line, while running
mysql: -- ALTER TABLE ... , LOCK=EXCLUSIVE in the other shell.
mysql: -- Notice how even the query is held up until the DDL is finished.
mysql: -- By the time the DELETE is issued, there is no conflicting access
mysql: -- to the table and we avoid the deadlock error.
mysql: select count(*) from big_table where is_nullable = 'YES'; delete from big_table
  where is_nullable = 'YES' limit 100000;
+----------+
| count(*) |
+----------+
|   400000 |
+----------+

<span><strong>1 row in set (15.98 sec)</strong></span>

Query OK, 100000 rows affected (2.81 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   300000 |
+----------+
1 row in set (0.17 sec)

mysql: rollback;
Query OK, 0 rows affected (1.36 sec)

mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   400000 |
+----------+
1 row in set (0.19 sec)

mysql: commit;
Query OK, 0 rows affected (0.00 sec)

mysql: -- Next, we try ALTER TABLE ... , LOCK=EXCLUSIVE in the other session
mysql: -- and only issue DML, not any query, in the concurrent transaction here.
mysql: delete from big_table where is_nullable = 'YES' limit 100000;
<span><strong>Query OK, 100000 rows affected (16.37 sec)</strong></span>

mysql: -- That was OK because the ALTER TABLE did not have to wait for the transaction
mysql: -- here to complete. The DELETE in this session waited until the index was ready.
mysql: select count(*) from big_table where is_nullable = 'YES';
+----------+
| count(*) |
+----------+
|   300000 |
+----------+
1 row in set (0.16 sec)

mysql: commit;
Query OK, 0 rows affected (0.00 sec)
</pre>

<p>В предыдущих примерах мы узнали что:</p>
<ul><li><p><code>LOCK</code> для <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> отделен от остальной части запроса запятой.</li>

<li>Online DDL могут ждать перед запуском, пока любые предшествующие
транзакции, которые получают доступ к таблице, не завершены.</li>
<li>Online DDL могут ждать перед завершением, пока любые параллельные
транзакции, которые получают доступ к таблице, не завершены.</li>

<li>В то время как online DDL работает, параллельные запросы являются
относительно прямыми, пока
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> использует
<code>LOCK=NONE</code> или <code>LOCK=SHARED</code>.</li>

<li>Обратите внимание на отключение
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>.
Если он выключен, сделайте все возможное, чтобы закончить транзакции в других
сеансах (даже только запросы) прежде, чем выполнить операции DDL на таблице.
</li>

<li>С <code>LOCK=SHARED</code> параллельные транзакции, которые смешивают
запросы и DML, могли столкнуться с ошибками тупика и быть перезапущенными
после того, как DDL закончен.</li>

<li>С <code>LOCK=NONE</code> параллельные транзакции могут свободно смешать
запросы и DML. Работа DDL ждет, пока параллельные транзакции не завершены.
</li>

<li>С <code>LOCK=EXCLUSIVE</code> параллельные транзакции могут свободно
смешать запросы и DML, но те транзакции ждут, пока работа DDL не закончена
прежде, чем они смогут получить доступ к таблице.</p></li></ul>

<a name="online-ddl-ex-multi-create-index"></a><p><b>
Пример 16.8. Установки схемы для экспериментов DDL онлайн</b></p>
<p>Вы можете создать много индексов на таблице одним вызовом
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Это относительно эффективно, потому что кластеризируемый индекс
таблицы должен быть просмотрен только однажды (хотя данные отсортированы
отдельно для каждого нового индекса). Например:
<pre>
CREATE TABLE T1(A INT PRIMARY KEY, B INT, C CHAR(1)) ENGINE=InnoDB;
INSERT INTO T1 VALUES (1,2,'a'), (2,3,'b'), (3,2,'c'), (4,3,'d'), (5,2,'e');
COMMIT;
ALTER TABLE T1 ADD INDEX (B), ADD UNIQUE INDEX (C);
</pre>

<p>Вышеупомянутые запросы составляют таблицу <code>T1</code>
с первичным ключом на столбце <code>A</code>, вставляют несколько строк,
затем создают два новых индекса на столбцах <code>B</code> и <code>C</code>.
Если было много строк, вставленных в
<code>T1</code> до <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, этот подход намного более эффективен, чем создание всех
вторичных индексов прежде, чем загрузить данные.</p>

<p>Поскольку удаление вторичного индекса, также не требует никакого
копирования табличных данных, одинаково эффективно удалить много индексов
одним вызовом <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> или
несколькими <a href="sql.htm#drop-index"><code>DROP INDEX</code></a>:

<pre>
ALTER TABLE T1 DROP INDEX B, DROP INDEX C;
</pre>

<p>Или:
<pre>
DROP INDEX B ON T1;
DROP INDEX C ON T1;
</pre>

<a name="online-ddl-ex-primary-key"></a><p><b>
Пример 16.9. Создание и удаление первичного ключа</b></p>
<p>Реструктурирование <a href="glossary.htm#glos_clustered_index">
кластеризируемого индекса</a> всегда требует копирования табличных данных.
Таким образом, лучше определять
<a href="glossary.htm#glos_primary_key">primary key</a>, когда Вы
составляете таблицу, вместо <code>ALTER TABLE ... ADD PRIMARY KEY</code>
позже, чтобы избежать пересоздания таблицы.</p>

<p>Определение <code>PRIMARY KEY</code> позже требует копирования
данных, как в следующем примере:
<pre>
CREATE TABLE T2 (A INT, B INT);
INSERT INTO T2 VALUES (NULL, 1);
ALTER TABLE T2 ADD PRIMARY KEY (B);
</pre>

<p>Когда Вы создаете индекс <code>UNIQUE</code> или <code>PRIMARY KEY</code>,
MySQL должен сделать некоторую дополнительную работу. Для <code>UNIQUE</code>
MySQL проверяет, что таблица не содержит двойных значений для ключа. Для
<code>PRIMARY KEY</code> MySQL также проверяет что ни один из
столбцов <code>PRIMARY KEY</code> не содержит <code>NULL</code>.</p>

<p>Когда Вы добавляете первичный ключ, используя
<code>ALGORITHM=COPY</code>, MySQL фактически преобразовывает
<code>NULL</code> в связанных столбцах к значениям по умолчанию: 0 для чисел,
пустая строка для символьно-ориентированных столбцов и BLOB, 0000-00-00
00:00:00 для <code>DATETIME</code>. Это нестандартное поведение, Oracle не
рекомендует на него полагаться. Добавление использования первичного ключа
<code>ALGORITHM=INPLACE</code> позволено только когда
<a href="server.htm#sysvar_sql_mode"><code>SQL_MODE</code></a> включает
the <code>strict_trans_tables</code> или
<code>strict_all_tables</code>, когда <code>SQL_MODE</code> строгий,
<code>ADD PRIMARY KEY ... , ALGORITHM=INPLACE</code> позволен, но запрос
может все еще потерпеть неудачу, если требуемые столбцы первичного ключа
содержат <code>NULL</code>. Поведение <code>ALGORITHM=INPLACE</code>
более стандартно-послушно.</p>

<p>Следующие примеры показывают различные возможности для
<code>ADD PRIMARY KEY</code>. С <code>ALGORITHM=COPY</code>
работа преуспевает несмотря на присутствие <code>NULL</code> в столбцах
первичного ключа, данные тихо изменены, что может вызвать проблемы.
<pre>
mysql&gt; CREATE TABLE add_pk_via_copy (c1 INT, c2 VARCHAR(10), c3 DATETIME);
Query OK, 0 rows affected (0.03 sec)

mysql&gt; INSERT INTO add_pk_via_copy VALUES (1,'a','2014-11-03 11:01:37'),
                 (NULL,NULL,NULL);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_copy ADD PRIMARY KEY (c1,c2,c3),
                ALGORITHM=COPY;
Query OK, 2 rows affected, 3 warnings (0.07 sec)
Records: 2  Duplicates: 0  Warnings: 3

mysql&gt; SHOW WARNINGS;
+---------+------+-----------------------------------------+
| Level   | Code | Message                                 |
+---------+------+-----------------------------------------+
| Warning | 1265 | Data truncated for column 'c1' at row 2 |
| Warning | 1265 | Data truncated for column 'c2' at row 2 |
| Warning | 1265 | Data truncated for column 'c3' at row 2 |
+---------+------+-----------------------------------------+
3 rows in set (0.00 sec)

mysql&gt; SELECT * FROM add_pk_via_copy;
+----+----+---------------------+
| c1 | c2 | c3                  |
+----+----+---------------------+
|  0 |    | 0000-00-00 00:00:00 |
|  1 | a  | 2014-11-03 11:01:37 |
+----+----+---------------------+
2 rows in set (0.00 sec)
</pre>

<p>С <code>ALGORITHM=INPLACE</code> работа могла потерпеть неудачу по
различным причинам, потому что эта установка считает целостность данных
высоким приоритетом: запрос дает ошибку, если
<a href="server.htm#sysvar_sql_mode"><code>SQL_MODE</code></a> недостаточно
<span><span>строг</span></span>, или если столбцы первичного ключа содержат
<code>NULL</code>. Как только мы обращаемся к обоим требованиям,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> успешна.
<pre>
mysql&gt; CREATE TABLE add_pk_via_inplace (c1 INT, c2 VARCHAR(10),
                 c3 DATETIME);
Query OK, 0 rows affected (0.02 sec)

mysql&gt; INSERT INTO add_pk_via_inplace VALUES (1, 'a',
                 '2014-11-03 11:01:37'),(NULL,NULL,NULL);
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql&gt; SELECT * FROM add_pk_via_inplace;
+------+------+---------------------+
| c1   | c2   | c3                  |
+------+------+---------------------+
| 1    | a    | 2014-11-03 11:01:37 |
| NULL | NULL | NULL                |
+------+------+---------------------+
2 rows in set (0.00 sec)

mysql&gt; SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_inplace ADD PRIMARY KEY (c1,c2,c3),
                ALGORITHM=INPLACE;
ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported. Reason: cannot silently convert NULL
values, as required in this SQL_MODE. Try ALGORITHM=COPY.

mysql&gt; SET sql_mode ='strict_trans_tables';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_inplace ADD PRIMARY KEY (c1,c2,c3),
                ALGORITHM=INPLACE;
ERROR 1138 (22004): Invalid use of NULL value
mysql&gt; DELETE FROM add_pk_via_inplace WHERE c1 IS NULL OR c2 IS NULL OR
                 c3 IS NULL;
Query OK, 1 row affected (0.01 sec)

mysql&gt; SELECT * FROM add_pk_via_inplace;
+----+----+---------------------+
| c1 | c2 | c3                  |
+----+----+---------------------+
| 1  | a  | 2014-11-03 11:01:37 |
+----+----+---------------------+
1 row in set (0.00 sec)

mysql&gt; ALTER TABLE add_pk_via_inplace ADD PRIMARY KEY (c1,c2,c3),
                ALGORITHM=INPLACE;
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre>

<p>Если Вы составляете таблицу без первичного ключа, InnoDB выбирает один для
Вас, которые могут быть первым <code>UNIQUE</code> ключом, определенный на
столбце <code>NOT NULL</code> или произведенный системой ключ. Чтобы избежать
любой неуверенности и потенциального требования пространства для
дополнительного скрытого столбца, определите <code>PRIMARY KEY</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.</p>

<h3><a name="innodb-create-index-implementation"></a>16.12.6.
Детали выполнения DDL онлайн</h3>
<p>Каждой операцией <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a> для <code>InnoDB</code> управляют несколько аспектов:</p>

<ul><li><p>Есть ли какое-либо изменение физического представления таблицы
или это просто изменение метаданных, которые могут быть сделаны, не
касаясь таблицы непосредственно.</li>

<li>Остается ли объем данных в таблице тем же самым,
увеличивается или уменьшается.</li>
<li>Вовлекает ли изменение в табличных данных кластеризируемый индекс,
вторичный индекс или оба.</li>

<li>Есть ли какие-либо отношения <a href="glossary.htm#glos_foreign_key">
foreign key</a> между измененной таблицей и некоторой другой таблицей.
Механика отличается в зависимости от параметра конфигурации
<a href="server.htm#sysvar_foreign_key_checks"><code>foreign_key_checks
</code></a>.</li>

<li>Разделена ли таблица. Разделы в
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
превращены в низкоуровневые операции, вовлекающие одну или более таблиц, и те
операции следуют регулярным правилам для DDL онлайн.</li>

<li>Должны ли табличные данные быть скопированы, может ли таблица быть
реорганизована <span><span>на месте</span></span>.</li>
<li>Содержит ли таблица какие-либо столбцы
<a href="glossary.htm#glos_auto_increment">auto-increment</a>.</li>

<li>Какая степень <a href="glossary.htm#glos_locking">блокировки</a>
требуется: природой основных операций базы данных или указанием
<code>LOCK</code> в <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>.</p></li></ul>
<p>Этот раздел объясняет, как эти факторы затрагивают различные виды
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<h4><a name="idm139965323899680"></a>Состояния ошибки для DDL онлайн</h4>
<p>Вот основные причины, почему работа DDL онлайн могла потерпеть неудачу:
</p>
<ul><li><p>Если <code>LOCK</code> определяет низкую степень блокировки
(<code>SHARED</code> или <code>NONE</code>), это не совместимо с особым
типом работы DDL.</li>

<li>Если тайм-аут происходит при ожидании, чтобы получить
<a href="glossary.htm#glos_exclusive_lock">исключительную блокировку</a>
на таблице, которая может быть необходима кратко во время начальных и
заключительных фаз работы DDL.</li>

<li>Если <a href="server.htm#sysvar_tmpdir"><code>tmpdir</code></a> или
<a href="#sysvar_innodb_tmpdir"><code>innodb_tmpdir</code></a>
исчерпывает дисковое пространство, в то время как MySQL пишет временные
файлы на диске во время создания индекса.
Для получения дополнительной информации см.
<a href="error.htm#temporary-files">раздел B.5.3.5</a>.</li>

<li>Если <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
занимает много времени, и параллельный DML изменяет таблицу так, что
размер временного журнала превышает значение параметра
<a href="#sysvar_innodb_online_alter_log_max_size"><code>
innodb_online_alter_log_max_size</code></a>. Это условие вызывает ошибку
<code>DB_ONLINE_LOG_TOO_BIG</code>.</li>

<li>Если параллельный DML производит изменения в таблице, которые позволены с
оригинальным табличным определением, но не с новым. Работа только неудачу
терпит в самом конце, когда MySQL пытается применить все изменения из
параллельных запросов DML. Например, Вы могли бы вставить двойные значения в
столбец, в то время как уникальный индекс создается, или Вы могли бы вставить
<code>NULL</code> в столбец, создавая индекс
<a href="glossary.htm#glos_primary_key">primary key</a> на том столбце.
Изменения, произведенные параллельным DML, имеют приоритет, и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
<a href="glossary.htm#glos_rollback">откатывается</a>.</p></li></ul>

<p>Хотя параметр конфигурации
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> имеет сильное воздействие на
представление таблицы, все операции online DDL работают одинаково хорошо,
включена ли та опция или отключена, и расположена ли таблица физически в ее
собственном <a href="glossary.htm#glos_ibd_file">файле .ibd</a> или в
<a href="glossary.htm#glos_system_tablespace">
системном табличном пространстве</a>.</p>

<p>У InnoDB есть два типа индексов:
<a href="glossary.htm#glos_clustered_index">кластеризируемые</a>,
представляющие все данные в таблице, и дополнительные
<a href="glossary.htm#glos_secondary_index">вторичные</a>, чтобы ускорить
запросы. Так как кластеризируемый индекс содержит значения данных в его узлах
B-дерева, добавление или удаление кластеризируемого индекса действительно
вовлекает копирование данных и создание новой копии таблицы. Вторичный
индекс, однако, содержит только ключ индекса и значение первичного ключа.
Этот тип индекса может быть создан или удален, не копируя данные в
кластеризируемом индексе. Поскольку каждый вторичный индекс содержит копии
значений первичного ключа (получает доступ к кластеризируемому индексу при
необходимости), когда Вы изменяете определение первичного ключа, все
вторичные индексы обновлены также.</p>

<p>Удаление вторичного индекса просто.  Только внутренние системные таблицы
InnoDB и таблицы словаря данных MySQL обновлены, чтобы отразить факт, что
индекс больше не существует. InnoDB возвращает место для индекса табличному
пространству, чтобы новый индекс или дополнительные строки таблицы
могут использовать пространство.</p>

<p>Чтобы добавить вторичный индекс к существующей таблице, InnoDB
просматривает таблицу и сортирует строки, используя буферы памяти и временные
файлы, в порядке значений ключевых столбцов вторичного индекса.
B-дерево тогда создано в порядке значений ключа, что более эффективно, чем
вставка строк в индекс в случайном порядке. Поскольку узлы B-дерева
разделены, когда они заполняются, создание индекса таким образом приводит к
более высокому коэффициенту заполнения для индекса, делая это более
эффективным для последующего доступа.</p>

<h3><a name="innodb-create-index-recovery"></a>16.12.7.
Восстановление катастрофического отказа с DDL онлайн</h3>
<p>Хотя никакие данные не потеряны, если сервер отказывает в то время,
как выполняется <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
процесс <a href="glossary.htm#glos_crash_recovery">восстановления
катастрофического отказа</a> отличается для
<a href="glossary.htm#glos_clustered_index">кластеризируемого</a> и
<a href="glossary.htm#glos_secondary_index">вторичного</a> индексов.</p>

<p>Если сервер отказывает в то время, как идет создание вторичного
индекса, после восстановления MySQL удаляет любой частично созданный индекс.
Вы должны запустить повторно <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> или <a href="sql.htm#create-index"><code>CREATE INDEX</code></a>.
</p>

<p>Когда катастрофический отказ происходит во время создания
кластеризируемого индекса, восстановление является более сложным, потому что
данные в таблице должны быть скопированы к полностью новому
кластеризируемому индексу. Помните, что все таблицы InnoDB сохранены
как кластеризуемый индекс.</p>

<p>MySQL создает новый кластеризируемый индекс, копируя существующие данные
от оригинальной таблицы InnoDB во временную таблицу, у которой есть желаемая
структура индекса. Как только данные полностью скопированы к этой временной
таблице, оригинальная таблица переименована. Временная таблица, включающая
кластеризируемый индекс, переименована с названием оригинальной таблицы, а
оригинальная таблица исключена из базы данных.</p>

<p>Если системный катастрофический отказ происходит в то время, как идет
создание кластеризируемого индекса, никакие данные не потеряны, но Вы должны
завершить процесс восстановления, используя временные таблицы, которые
существуют во время процесса. Так как кластеризируемый индекса редко
обновляется или пересматривают первичные ключи на больших таблицах,
столкнуться с системным катастрофическим отказом во время этой работы шансов
мало, поэтому это руководство не предоставляет информацию о восстановлении
от этого сбоя.</p>

<h3><a name="online-ddl-partitioning"></a>16.12.8.
Online DDL для разделенных таблиц InnoDB</h3>
<p>За исключением параметров разделения в <a href="sql.htm#alter-table">
<code>ALTER TABLE</code></a>, online DDL следует тем же самым правилам,
которые относятся к обычным таблицам. Правила DDL обрисованы в общих чертах в
<a href="#innodb-online-ddl-summary-grid">таблице 16.9</a>.</p>

<p>Параметры разделения <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> не проходят тот же самый внутренний DDL онлайн API, как
обычные таблицы и позволены только в соединении с
<code>ALGORITHM=DEFAULT</code> и <code>LOCK=DEFAULT</code>.</p>

<p>Если Вы используете параметры разделения в
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, разделенная
таблица будет <span><span>переразделена</span></span> с использованием
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> <code>COPY</code>.
Другими словами, новая разделенная таблица составлена с новой схемой
разделения. Недавно составленная таблица будет включать любые изменения,
примененные <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
табличные данные будут скопированы в новую структуру таблицы.</p>

<p>Если Вы не изменяете разделения таблицы
или выполняете любое другое управление разделением в Вашем
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
будет использовать <code>INPLACE</code> на каждом табличном разделе.
Знайте, однако, что когда <code>INPLACE</code>
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> выполнен на каждом
разделе, будут увеличены требования к системным ресурсам из-за операций,
выполняемых на многих разделах.</p>

<p>Даже при том, что разделы в <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> не проходят тот же самый внутренний DDL онлайн API, как
обычные таблицы, MySQL все еще пытается минимизировать копирование данных и
блокировку где только возможно:</p>

<ul><li><p><code>ADD PARTITION</code> и <code>DROP PARTITION</code>
для таблиц, разделенных <code>RANGE</code> или <code>LIST</code>
не копируют существующие данные.</li>

<li><code>TRUNCATE PARTITION</code> не копирует существующих данных для всех
типов разделенных таблиц.</li>

<li>Во время параллельных запросов позволяются <code>ADD PARTITION</code> и
<code>COALESCE PARTITION</code> для таблиц, разделенных <code>HASH</code> или
<code>LIST</code>. MySQL копирует данные, держа
совместно используемую блокировку.</li>

<li>Для <code>REORGANIZE PARTITION</code>, <code>REBUILD PARTITION</code>,
<code>ADD PARTITION</code> или <code>COALESCE PARTITION</code>
для таблицы, разделенной by <code>LINEAR HASH</code> или <code>LIST</code>,
параллельные запросы позволены. Данные затронутого раздела скопированы, держа
совместно используемую блокировку (чтение) метаданных на табличном уровне.
</p></li></ul>

<p>Полнотекстовый поиск (FTS) и внешние ключи не поддержаны
разделенными таблицами <code>InnoDB</code>. Подробности в разделах
<a href="funct.htm#fulltext-restrictions">13.9.5</a> и
<a href="partit.htm#partitioning-limitations-storage-engines">20.6.2</a>.</p>

<h3><a name="innodb-create-index-limitations"></a>16.12.9.
Ограничения Online DDL</h3>
<p>Примите следующие ограничения во внимание, выполняя операции online DDL:
</p>

<ul><li><p>Работа DDL онлайн, которая копирует таблицу, может вызвать ошибку,
если работа использует все доступное дисковое пространство на файловой
системе, где каталог данных находится (<a href="server.htm#sysvar_datadir">
<code>datadir</code></a>). Чтобы избежать этой проблемы, гарантируйте, что
есть достаточно дискового пространства, чтобы выполнить операции
online <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
которые копируют таблицу. Во время этих операций MySQL пишет временные файлы
во временный каталог (<code>$TMPDIR</code> в Unix, <code>%TEMP%</code> в
Windows или каталог, определенный переменной
<a href="server.htm#sysvar_tmpdir"><code>--tmpdir</code></a>).
Каждый временный файл является достаточно большим, чтобы держать один столбец
в новой таблице или индексе, и удален, как только это слито в заключительную
таблицу. Такие операции могут потребовать временное пространство, равное
сумме данных в таблице плюс индексы.</p>

<p>Вы можете использовать опцию <a href="#sysvar_innodb_tmpdir">
<code>innodb_tmpdir</code></a>, чтобы определить отдельный временный каталог
для операций DDL онлайн. Опция <a href="#sysvar_innodb_tmpdir">
<code>innodb_tmpdir</code></a> была введена, чтобы помочь избежать временных
переполнений каталога, которые могли произойти в результате больших временных
файлов вида, создаваемых во время операций онлайн
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
которые пересоздают таблицу.</li>

<li>Таблица скопирована, вместо того, чтобы использовать быстрое создание
индекса, когда Вы создаете индекс на <code>TEMPORARY TABLE</code>.
Об этом сообщили как MySQL Bug #39833.</li>

<li>InnoDB обрабатывает ошибочные случаи, когда пользователи пытаются удалить
индекс, необходимый для внешних ключей. См.
<a href="error.htm#error-messages-server">раздел B.3</a>.</li>

<li><code>LOCK=NONE</code> в <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> не позволен, если есть ограничения
<code>ON...CASCADE</code> или <code>ON...SET NULL</code> на таблицу.</li>

<li>В зависимости от внутренних работ, online DDL и <code>LOCK</code>
в <code>ALTER TABLE</code> может потребовать эксклюзивного доступа к таблице
в течение краткого времени во время начальных и заключительных фаз работы
DDL. Таким образом, работа DDL онлайн могла бы ждать прежде, чем закончиться,
если есть продолжительное выполнение вставки, обновления, удаления или
<code>SELECT ... FOR UPDATE</code> на таблице, работа DDL онлайн могла бы
ждать прежде, чем закончиться, если подобная продолжительная транзакция
запущена в то время, как выполняется <a href="sql.htm#alter-table">
<code>ALTER TABLE</code></a>.</li>

<li>Выполняя работу DDL онлайн, поток, который выполняет
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, применит
<span><span>online-журнал</span></span> операций DML, которые были выполнены
одновременно на той же самой таблице от других потоков соединения. Когда
операции DML применены, возможно столкнуться с ошибкой дубликата ключа
(<span>ERROR 1062 (23000): Duplicate entry</span>), даже если бы двойная
запись является только временной и исправилась бы более поздней запись в
<span><span>online-журнале</span></span>. Это подобно идее ограничения
внешнего ключа, в котором ограничения должны держаться во время транзакции.
</li>

<li><a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a> для
<code>InnoDB</code> отображена на <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, чтобы восстановить таблицу, обновить индексную статистику
и свободное неиспользуемое место в кластеризируемом индексе. Вторичный индекс
не создаются так эффективно, потому что ключи вставлены в порядке, в котором
они появились в первичном ключе.
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>
также поддерживает <a href="#innodb-online-ddl">online DDL</a> для
пересоздания таблиц <code>InnoDB</code>. Для дополнительной информации см.
<a href="#innodb-create-index-overview">раздел 16.12.1</a>.</p>
<p>До MySQL 5.6.17/5.7.4 не было поддержки
<a href="#innodb-online-ddl">online DDL</a> для этого.</p></li>

<li><p>Таблицы <code>InnoDB</code>, составленные перед MySQL 5.6, не
поддерживают <a href="sql.htm#alter-table"><code>ALTER
TABLE ... ALGORITHM=INPLACE</code></a> для таблиц, которые включают временные
столбцы (<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> или
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>)
и не были пересозданы через <a href="sql.htm#alter-table"><code>
ALTER TABLE ... ALGORITHM=COPY</code></a>. В этом случае
<a href="sql.htm#alter-table"><code>ALTER TABLE ... ALGORITHM=INPLACE</code>
</a> возвращает следующую ошибку:
<pre>
ERROR 1846 (0A000): ALGORITHM=INPLACE is not supported.
Reason: Cannot change column type INPLACE. Try ALGORITHM=COPY.
</pre></li>

<li>Эти ограничения вообще применимы к операциям DDL онлайн на больших
таблицах, где копирование таблицы вовлечено:</p>
<ul><li><p>Нет никакого механизма, чтобы сделать паузу в online DDL или
ограничить ввод/вывод или использование центрального процессора
для работы DDL.</li>

<li>Откат online DDL может быть дорогим.</li>
<li>Долгое выполнение онлайн операции DDL может вызвать задержку
репликации. Работа DDL онлайн должна закончить работать на ведущем устройстве
прежде, чем она будет выполнена на ведомом устройстве. Кроме того, DML,
который был обработан одновременно на ведущем устройстве, обработан на
ведомом устройстве только после того, как работа DDL на ведомом
устройстве завершена (Bug #73196).</p></li></ul>

<p>Для дополнительной информации, связанной с выполнением онлайн операции DDL
на больших таблицах, см.
<a href="#innodb-create-index-concurrency">раздел 16.12.2</a>.
</p></li></ul>

<h2><a name="innodb-parameters"></a>16.13.
Опции запуска InnoDB и системные переменные</h2>
<ul><li><p>Системные переменные, которые являются истиной или ложью, могут
быть включены при запуске сервера или отключены при использовании префикса
<code>--skip-</code>. Например, чтобы включить или отключить адаптивный хэш
индекс, Вы можете использовать
<a href="#sysvar_innodb_adaptive_hash_index"><code>
--innodb_adaptive_hash_index</code></a> или
<a href="#sysvar_innodb_adaptive_hash_index"><code>
--skip-innodb_adaptive_hash_index</code></a> в командной строке или
<a href="#sysvar_innodb_adaptive_hash_index"><code>
innodb_adaptive_hash_index</code></a> или
<code>skip-innodb_adaptive_hash_index</code> в файле опций.</li>

<li>Системные переменные, которые берут числовое значение, могут быть
определены как <code>--<em><code>var_name</code></em>=<em><code>value</code>
</em></code> в командной строке или как
<code><em><code>var_name</code></em>=<em><code>value</code></em>
</code> в файле опций.</li>

<li>Много системных переменных могут быть изменены во время выполнения (см.
<a href="server.htm#dynamic-system-variables">раздел 6.1.6.2</a>).</li>
<li>Для информации о модификаторах контекста
<code>GLOBAL</code> и <code>SESSION</code> обратитесь к описанию команды
<a href="sql.htm#set-variable"><code>SET</code></a>.</li>

<li>Определенные опции управляют местоположением и расположением
файлов с данными <code>InnoDB</code>.
<a href="#innodb-configuration">Раздел 16.6</a>
объясняет, как использовать эти опции.</li>

<li>Некоторые опции, которые Вы не могли бы использовать первоначально,
помогают настроить технические характеристики <code>InnoDB</code>,
основанные на машинной конфигурации и Вашей
<a href="glossary.htm#glos_workload">рабочей нагрузке</a> базы данных.</li>

<li>Для получения дополнительной информации об определении опций и системных
переменных см. <a href="programs.htm#program-options">раздел 5.2.3</a>.
</p></li></ul>

<a name="idm139965323729408"></a><p><b>Таблица 16.10. Опции и переменные
<code>InnoDB</code></b></p>
<table border="1">
<thead><tr><th>Имя</th><th>Cmd-Line</th><th>Файл опций</th>
<th>Системная</th><th>Статусная</th><th>Область видимости</th>
<th>Динамическая</th></tr></thead>
<tbody><tr><td><a href="#sysvar_daemon_memcached_enable_binlog">
daemon_memcached_enable_binlog</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_daemon_memcached_engine_lib_name">
daemon_memcached_engine_lib_name</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_daemon_memcached_engine_lib_path">
daemon_memcached_engine_lib_path</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_daemon_memcached_option">
daemon_memcached_option</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_daemon_memcached_r_batch_size">
daemon_memcached_r_batch_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_daemon_memcached_w_batch_size">
daemon_memcached_w_batch_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#sysvar_foreign_key_checks">foreign_key_checks</a>
</td><td> </td><td> </td><td>Да</td><td> </td><td>Обе</td><td>Да</td></tr>
<tr><td><a href="#option_mysqld_ignore-builtin-innodb">
ignore-builtin-innodb</a></td><td>Да</td><td>Да</td><td> </td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td> - <span><em>Переменные</em></span>:
<a href="#sysvar_ignore_builtin_innodb">ignore_builtin_innodb</a>
</td><td> </td><td> </td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td>
</tr>
<tr><td><a href="#option_mysqld_innodb">innodb</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td><a href="#sysvar_innodb_adaptive_flushing">
innodb_adaptive_flushing</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_adaptive_flushing_lwm">
innodb_adaptive_flushing_lwm</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_adaptive_hash_index">
innodb_adaptive_hash_index</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_adaptive_hash_index_parts">
innodb_adaptive_hash_index_parts</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_adaptive_max_sleep_delay">
innodb_adaptive_max_sleep_delay</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_api_bk_commit_interval">
innodb_api_bk_commit_interval</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_api_disable_rowlock">
innodb_api_disable_rowlock</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_api_enable_binlog">
innodb_api_enable_binlog</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_api_enable_mdl">
innodb_api_enable_mdl</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_api_trx_level">
innodb_api_trx_level</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_autoextend_increment">
innodb_autoextend_increment</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_autoinc_lock_mode">
innodb_autoinc_lock_mode</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_available_undo_logs">
Innodb_available_undo_logs</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_background_drop_list_empty">
innodb_background_drop_list_empty</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_bytes_data">
Innodb_buffer_pool_bytes_data</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_bytes_dirty">
Innodb_buffer_pool_bytes_dirty</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_chunk_size">
innodb_buffer_pool_chunk_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_debug">
innodb_buffer_pool_debug</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_dump_at_shutdown">
innodb_buffer_pool_dump_at_shutdown</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_dump_now">
innodb_buffer_pool_dump_now</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_dump_pct">
innodb_buffer_pool_dump_pct</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_dump_status">
Innodb_buffer_pool_dump_status</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_filename">
innodb_buffer_pool_filename</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_instances">
innodb_buffer_pool_instances</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_load_abort">
innodb_buffer_pool_load_abort</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_load_at_startup">
innodb_buffer_pool_load_at_startup</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_load_now">
innodb_buffer_pool_load_now</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_load_status">
Innodb_buffer_pool_load_status</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_pages_data">
Innodb_buffer_pool_pages_data</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_pages_dirty">
Innodb_buffer_pool_pages_dirty</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_pages_flushed">
Innodb_buffer_pool_pages_flushed</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_pages_free">
Innodb_buffer_pool_pages_free</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_pages_latched">
Innodb_buffer_pool_pages_latched</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_pages_misc">
Innodb_buffer_pool_pages_misc</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_pages_total">
Innodb_buffer_pool_pages_total</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_read_ahead">
Innodb_buffer_pool_read_ahead</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_read_ahead_evicted">
Innodb_buffer_pool_read_ahead_evicted</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_read_ahead_rnd">
Innodb_buffer_pool_read_ahead_rnd</a></td><td> </td><td> </td><td> </td><td>
Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_read_requests">
Innodb_buffer_pool_read_requests</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_reads">
Innodb_buffer_pool_reads</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_resize_status">
Innodb_buffer_pool_resize_status</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_buffer_pool_size">
innodb_buffer_pool_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_wait_free">
Innodb_buffer_pool_wait_free</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_buffer_pool_write_requests">
Innodb_buffer_pool_write_requests</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_change_buffer_max_size">
innodb_change_buffer_max_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_change_buffering">
innodb_change_buffering</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_change_buffering_debug">
innodb_change_buffering_debug</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_checksum_algorithm">
innodb_checksum_algorithm</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_cmp_per_index_enabled">
innodb_cmp_per_index_enabled</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_commit_concurrency">
innodb_commit_concurrency</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_compress_debug">
innodb_compress_debug</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_compression_failure_threshold_pct">
innodb_compression_failure_threshold_pct</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_compression_level">
innodb_compression_level</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_compression_pad_pct_max">
innodb_compression_pad_pct_max</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_concurrency_tickets">
innodb_concurrency_tickets</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_data_file_path">
innodb_data_file_path</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_fsyncs">
Innodb_data_fsyncs</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_data_home_dir">
innodb_data_home_dir</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_pending_fsyncs">
Innodb_data_pending_fsyncs</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_pending_reads">
Innodb_data_pending_reads</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_pending_writes">
Innodb_data_pending_writes</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_read">Innodb_data_read</a>
</td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_reads">Innodb_data_reads</a>
</td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_writes">Innodb_data_writes
</a></td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_data_written">Innodb_data_written
</a></td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td><td>Нет
</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_dblwr_pages_written">
Innodb_dblwr_pages_written</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_dblwr_writes">Innodb_dblwr_writes
</a></td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td><td>Нет
</td></tr>
<tr><td><a href="#sysvar_innodb_default_row_format">
innodb_default_row_format</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_disable_sort_file_cache">
innodb_disable_sort_file_cache</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_doublewrite">innodb_doublewrite</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет
</td></tr>
<tr><td><a href="#sysvar_innodb_fast_shutdown">innodb_fast_shutdown
</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Да
</td></tr>
<tr><td><a href="#sysvar_innodb_fil_make_page_dirty_debug">
innodb_fil_make_page_dirty_debug</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_file_per_table">
innodb_file_per_table</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_fill_factor">innodb_fill_factor</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Да
</td></tr>
<tr><td><a href="#sysvar_innodb_flush_log_at_timeout">
innodb_flush_log_at_timeout</a></td><td> </td><td> </td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_flush_log_at_trx_commit">
innodb_flush_log_at_trx_commit</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_flush_method">
innodb_flush_method</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_flush_neighbors">
innodb_flush_neighbors</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_flush_sync">innodb_flush_sync</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Да
</td></tr>
<tr><td><a href="#sysvar_innodb_flushing_avg_loops">
innodb_flushing_avg_loops</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_force_load_corrupted">
innodb_force_load_corrupted</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_force_recovery">
innodb_force_recovery</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_ft_aux_table">
innodb_ft_aux_table</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_ft_cache_size">
innodb_ft_cache_size</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_ft_enable_diag_print">
innodb_ft_enable_diag_print</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_ft_enable_stopword">
innodb_ft_enable_stopword</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_ft_max_token_size">
innodb_ft_max_token_size</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_ft_min_token_size">
innodb_ft_min_token_size</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_ft_num_word_optimize">
innodb_ft_num_word_optimize</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_ft_result_cache_limit">
innodb_ft_result_cache_limit</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_ft_server_stopword_table">
innodb_ft_server_stopword_table</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_ft_sort_pll_degree">
innodb_ft_sort_pll_degree</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_ft_total_cache_size">
innodb_ft_total_cache_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_ft_user_stopword_table">
innodb_ft_user_stopword_table</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Обе</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_have_atomic_builtins">
Innodb_have_atomic_builtins</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_io_capacity">innodb_io_capacity</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_io_capacity_max">
innodb_io_capacity_max</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_limit_optimistic_insert_debug">
innodb_limit_optimistic_insert_debug</a></td><td>Да</td><td>Да</td><td>Да
</td><td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_lock_wait_timeout">
innodb_lock_wait_timeout</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Обе</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_log_buffer_size">
innodb_log_buffer_size</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_log_checksums">innodb_log_checksums
</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_log_compressed_pages">
innodb_log_compressed_pages</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_log_file_size">innodb_log_file_size
</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_log_files_in_group">
innodb_log_files_in_group</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_log_group_home_dir">
innodb_log_group_home_dir</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_log_waits">Innodb_log_waits</a>
</td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_log_write_ahead_size">
innodb_log_write_ahead_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_log_write_requests">
Innodb_log_write_requests</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_log_writes">Innodb_log_writes</a>
</td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_lru_scan_depth">
innodb_lru_scan_depth</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_max_dirty_pages_pct">
innodb_max_dirty_pages_pct</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_max_dirty_pages_pct_lwm">
innodb_max_dirty_pages_pct_lwm</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_max_purge_lag">innodb_max_purge_lag
</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_max_purge_lag_delay">
innodb_max_purge_lag_delay</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_max_undo_log_size">
innodb_max_undo_log_size</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_merge_threshold_set_all_debug">
innodb_merge_threshold_set_all_debug</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_monitor_disable">
innodb_monitor_disable</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_monitor_enable">
innodb_monitor_enable</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_monitor_reset">
innodb_monitor_reset</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_monitor_reset_all">
innodb_monitor_reset_all</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_num_open_files">
Innodb_num_open_files</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_numa_interleave">
innodb_numa_interleave</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_old_blocks_pct">
innodb_old_blocks_pct</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_old_blocks_time">
innodb_old_blocks_time</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_online_alter_log_max_size">
innodb_online_alter_log_max_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_open_files">innodb_open_files</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_optimize_fulltext_only">
innodb_optimize_fulltext_only</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_os_log_fsyncs">
Innodb_os_log_fsyncs</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_os_log_pending_fsyncs">
Innodb_os_log_pending_fsyncs</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_os_log_pending_writes">
Innodb_os_log_pending_writes</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_os_log_written">
Innodb_os_log_written</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_page_cleaners">
innodb_page_cleaners</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_page_size">Innodb_page_size</a>
</td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_page_size">innodb_page_size</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_pages_created">
Innodb_pages_created</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_pages_read">Innodb_pages_read</a>
</td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_pages_written">
Innodb_pages_written</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_print_all_deadlocks">
innodb_print_all_deadlocks</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_purge_batch_size">
innodb_purge_batch_size</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_purge_rseg_truncate_frequency">
innodb_purge_rseg_truncate_frequency</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_purge_threads">innodb_purge_threads
</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_random_read_ahead">
innodb_random_read_ahead</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_read_ahead_threshold">
innodb_read_ahead_threshold</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_read_io_threads">
innodb_read_io_threads</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_read_only">
innodb_read_only</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_replication_delay">
innodb_replication_delay</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_rollback_on_timeout">
innodb_rollback_on_timeout</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_rollback_segments">
innodb_rollback_segments</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_row_lock_current_waits">
Innodb_row_lock_current_waits</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_row_lock_time">
Innodb_row_lock_time</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_row_lock_time_avg">
Innodb_row_lock_time_avg</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_row_lock_time_max">
Innodb_row_lock_time_max</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_row_lock_waits">
Innodb_row_lock_waits</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_rows_deleted">Innodb_rows_deleted
</a></td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_rows_inserted">
Innodb_rows_inserted</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_rows_read">Innodb_rows_read</a>
</td><td> </td><td> </td><td> </td><td>Да</td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_rows_updated">
Innodb_rows_updated</a></td><td> </td><td> </td><td> </td><td>Да</td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_saved_page_number_debug">
innodb_saved_page_number_debug</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_sort_buffer_size">
innodb_sort_buffer_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_spin_wait_delay">
innodb_spin_wait_delay</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_stats_auto_recalc">
innodb_stats_auto_recalc</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_stats_include_delete_marked">
innodb_stats_include_delete_marked</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_stats_method">
innodb_stats_method</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_stats_on_metadata">
innodb_stats_on_metadata</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_stats_persistent">
innodb_stats_persistent</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_stats_persistent_sample_pages">
innodb_stats_persistent_sample_pages</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_stats_transient_sample_pages">
innodb_stats_transient_sample_pages</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#option_mysqld_innodb-status-file">
innodb-status-file</a></td><td>Да</td><td>Да</td><td> </td><td> </td>
<td> </td><td> </td></tr>
<tr><td><a href="#sysvar_innodb_status_output">
innodb_status_output</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_status_output_locks">
innodb_status_output_locks</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_strict_mode">
innodb_strict_mode</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Обе</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_sync_array_size">
innodb_sync_array_size</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_sync_debug">
innodb_sync_debug</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_sync_spin_loops">
innodb_sync_spin_loops</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_table_locks">
innodb_table_locks</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Обе</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_temp_data_file_path">
innodb_temp_data_file_path</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_thread_concurrency">
innodb_thread_concurrency</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_thread_sleep_delay">
innodb_thread_sleep_delay</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_tmpdir">innodb_tmpdir</a></td>
<td>Да</td><td>Да</td><td>Да</td><td> </td><td>Обе</td><td>Да</td></tr>
<tr><td><a href="server.htm#statvar_Innodb_truncated_status_writes">
Innodb_truncated_status_writes</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_trx_purge_view_update_only_debug">
innodb_trx_purge_view_update_only_debug</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_trx_rseg_n_slots_debug">
innodb_trx_rseg_n_slots_debug</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_undo_directory">
innodb_undo_directory</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_undo_log_truncate">
innodb_undo_log_truncate</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_undo_logs">innodb_undo_logs</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Да</td></tr>
<tr><td><a href="#sysvar_innodb_undo_tablespaces">
innodb_undo_tablespaces</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_use_native_aio">
innodb_use_native_aio</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_version">innodb_version</a></td>
<td> </td><td> </td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="#sysvar_innodb_write_io_threads">
innodb_write_io_threads</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td><a href="server.htm#sysvar_mecab_rc_file">mecab_rc_file</a></td>
<td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#sysvar_ngram_token_size">ngram_token_size</a>
</td><td>Да</td><td>Да</td><td>Да</td><td> </td><td>Глобальная</td>
<td>Нет</td></tr>
<tr><td><a href="server.htm#sysvar_unique_checks">unique_checks</a></td>
<td> </td><td> </td><td>Да</td><td> </td><td>Обе</td><td>Да</td>
</tr></tbody></table>

<h3><a name="idm139965323065968"></a>Опции команд InnoDB</h3>
<ul><li><p><a name="option_mysqld_ignore-builtin-innodb"></a>
<code>--ignore-builtin-innodb</code></p>

<table border="1">
<tbody><tr><td><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.5.22</td></tr>
<tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--ignore-builtin-innodb</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_ignore_builtin_innodb">ignore_builtin_innodb</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td><td><span>
<strong>Тип</strong></span></td><td colspan="2"><code>boolean</code></td>
</tr></tbody></table>

<p>В MySQL 5.1 эта опция заставила сервер вести себя как будто встроенный
<code>InnoDB</code> не присутствовал, что заставляет <code>InnoDB Plugin
</code> использовать вместо этого. В MySQL 8.0 <code>InnoDB</code>
механизм хранения по умолчанию и <code>InnoDB Plugin</code>
не используется, таким образом, эта опция проигнорирована.</li>

<li><a name="option_mysqld_innodb"></a>
<code>--innodb[=<em><code>value</code></em>]</code></p>
<table border="1">
<tbody><tr><td><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.7.5</td></tr>
<tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb[=value]</code></td></tr>
<tr><td rowspan="5"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2">
<code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr>
<tr><td rowspan="3" valign="top"><span><strong>Допустимые значения</strong>
</span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td colspan="2"><code>ON</code></td></tr>
<tr><td colspan="2"><code>FORCE</code></td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr></tbody></table>

<p>Загрузка средств управления <code>InnoDB</code>, если сервер был собран с
поддержкой <code>InnoDB</code>.  У этой опции есть формат tristate, с
возможными значениями <code>OFF</code>,
<code>ON</code> или <code>FORCE</code>. См.
<a href="server.htm#server-plugin-loading">раздел 6.6.2</a>.</p>

<p>Чтобы отключить <code>InnoDB</code>, используйте
<a href="#option_mysqld_innodb"><code>--innodb=OFF</code></a> или
<a href="#option_mysqld_innodb"><code>--skip-innodb</code></a>.
В этом случае, потому что <a href="innodb.htm"><code>InnoDB</code></a>
механизм хранения по умолчанию, сервер не будет запускаться, если Вы также не
будете использовать <a href="server.htm#sysvar_default_storage_engine"><code>
--default-storage-engine</code></a> и
<a href="server.htm#sysvar_default_tmp_storage_engine"><code>
--default-tmp-storage-engine</code></a>, чтобы установить значением по
умолчанию некоторый другой механизм для постоянных и для
<code>TEMPORARY</code> таблиц.</p>

<p>Механизм хранения <code>InnoDB</code>
больше не может быть отключен, и
<a href="#option_mysqld_innodb"><code>--innodb=OFF</code></a> и
<a href="#option_mysqld_innodb"><code>--skip-innodb</code></a>
устарели и не имеют никакого эффекта. Их использование приводит к
предупреждению. Эти опции будут удалены в будущем выпуске MySQL.</li>

<li><a name="option_mysqld_innodb-status-file"></a>
<code>--innodb-status-file</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb-status-file</code></td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Управляет, создает ли <code>InnoDB</code> файл
<code>innodb_status.<em><code>pid</code></em></code> в каталоге данных MySQL.
Если включено, <code>InnoDB</code> периодически пишет вывод
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code>
</a> в этот файл.</p>

<p>По умолчанию файл не создается. Чтобы создать его, запустите
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
с опцией <code>--innodb-status-file=1</code>.
Файл удален во время нормального завершения работы.</li>

<li><a href="#option_mysqld_innodb"><code>--skip-innodb</code></a>
</p>
<p>Отключает <code>InnoDB</code>. См. описание
<a href="#option_mysqld_innodb"><code>--innodb</code></a>.
</p></li></ul>

<h3>Системные переменные InnoDB</h3>
<ul><li><p><a name="sysvar_daemon_memcached_enable_binlog"></a>
<code>daemon_memcached_enable_binlog</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--daemon_memcached_enable_binlog=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_daemon_memcached_enable_binlog">
daemon_memcached_enable_binlog</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>false</code></td></tr></tbody></table>
<p>См. <a href="#innodb-memcached">раздел 16.19</a> для
подробностей об этой опции.</li>

<li><a name="sysvar_daemon_memcached_engine_lib_name"></a>
<code>daemon_memcached_engine_lib_name</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--daemon_memcached_engine_lib_name=library
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_daemon_memcached_engine_lib_name">
daemon_memcached_engine_lib_name</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>file name</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>innodb_engine.so</code></td></tr></tbody></table>

<p>Определяет совместно используемую библиотеку, которая осуществляет
плагин <code>InnoDB</code> <span><strong>memcached</strong></span>.</p>
<p>См. <a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_daemon_memcached_engine_lib_path"></a>
<code>daemon_memcached_engine_lib_path</code></p>
<table summary="Options for daemon_memcached_engine_lib_path" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--daemon_memcached_engine_lib_path=directory
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_daemon_memcached_engine_lib_path">
daemon_memcached_engine_lib_path</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>directory name</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>NULL</code></td></tr></tbody></table>

<p>Путь к каталогу, содержащесу совместно используемую библиотеку, которая
осуществляет плагин <code>InnoDB</code> <span><strong>memcached</strong>
</span>. Значение по умолчанию NULL, представляя каталог плагинов MySQL. Вы
не должны менять этот параметр, не определяя иной механизм хранения,
плагин для которого расположен за пределами каталога плагинов MySQL.</p>
<p>См. <a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_daemon_memcached_option"></a>
<code>daemon_memcached_option</code></p>
<table summary="Options for daemon_memcached_option" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--daemon_memcached_option=options</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_daemon_memcached_option">
daemon_memcached_option</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code></code></td></tr></tbody></table>

<p>Используется, чтобы передать разделенные пробелом опции
<span><strong>memcached</strong></span> опции к основному
демону кэширования объекта памяти при запуске. Например, Вы могли бы изменить
порт, на котором слушает <span><strong>memcached</strong></span>,
уменьшить максимальное количество одновременных соединений, изменить
максимальный размер памяти для пары ключ/значение или позволить отладочные
сообщения для журнала ошибок.</p>
<p>См. <a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_daemon_memcached_r_batch_size"></a>
<code>daemon_memcached_r_batch_size</code></p>
<table summary="Options for daemon_memcached_r_batch_size" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--daemon_memcached_r_batch_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_daemon_memcached_r_batch_size">
daemon_memcached_r_batch_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr></tbody></table>

<p>Определяет, сколько операций чтения
<span><strong>memcached</strong></span> (<code>get</code>) выполнить
прежде, чем сделать <a href="sql.htm#commit"><code>COMMIT</code></a>,
чтобы запустить новую транзакцию. Копия
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a>.</p>

<p>Это значение установлено в 1 по умолчанию, чтобы любые изменения,
произведенные в таблице через запросы SQL, были немедленно видимы в
<span><strong>memcached</strong></span>. Вы могли бы увеличить это,
чтобы уменьшить издержки от частых передач в системе, где к основной таблице
получают доступ только через интерфейс <span><strong>memcached</strong>
</span>. Если Вы устанавливаете слишком большое значение, размер данных в
undo или redo добавит издержек по системе хранения, как с
любой продолжительной транзакцией.</p>
<p>См. <a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_daemon_memcached_w_batch_size"></a>
<code>daemon_memcached_w_batch_size</code></p>
<table summary="Options for daemon_memcached_w_batch_size" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--daemon_memcached_w_batch_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_daemon_memcached_w_batch_size">
daemon_memcached_w_batch_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr></tbody></table>

<p>Определяет, скольким операциям записи
<span><strong>memcached</strong></span> таким, как <code>add</code>,
<code>set</code> или <code>incr</code>, выполниться прежде, чем сделать
<a href="sql.htm#commit"><code>COMMIT</code></a>. Копия
<a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a>.</p>

<p>Это значение установлено в 1 по умолчанию, при условии, что любые хранимые
данные важны, чтобы сохранить в случае отключения электричества и должны
немедленно быть переданы. Храня некритические данные, Вы могли бы увеличить
это значение, чтобы уменьшить издержки, но тогда последние
<em><code>N</code></em>-1 операций записи могут быть потеряны в
случае катастрофического отказа. См.
<a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_ignore_builtin_innodb"></a>
<code>ignore_builtin_innodb</code></p>
<table summary="Options for ignore-builtin-innodb" border="1">
<tbody><tr><td><span><strong>Устаревшая</strong></span></td><td colspan="3">
5.5.22</td></tr>
<tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--ignore-builtin-innodb</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_ignore_builtin_innodb">
ignore_builtin_innodb</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr></tbody></table>

<p>См. описание на
<a href="#option_mysqld_ignore-builtin-innodb"><code>
--ignore-builtin-innodb</code></a>.</li>

<li><a name="sysvar_innodb_adaptive_flushing"></a>
<code>innodb_adaptive_flushing</code></p>
<table summary="Options for innodb_adaptive_flushing" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_adaptive_flushing=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_adaptive_flushing">
innodb_adaptive_flushing</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Определяет, скорректировать ли динамически уровень сброса
<a href="glossary.htm#glos_dirty_page">грязных страниц</a> в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>, основываясь на
рабочей нагрузке. Корректировка уровня потока динамически предназначена,
чтобы избежать взрывов деятельности ввода/вывода. Эта установка включена по
умолчанию. См. <a href="#innodb-performance-adaptive_flushing">
раздел 16.6.3.6</a>. Для общих советов по настройке ввода/вывода см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</li>

<li><a name="sysvar_innodb_adaptive_flushing_lwm"></a>
<code>innodb_adaptive_flushing_lwm</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_adaptive_flushing_lwm=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_adaptive_flushing_lwm">
innodb_adaptive_flushing_lwm</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>70</code></td></tr></tbody></table>
<p>Нижний предел процента размера
<a href="glossary.htm#glos_redo_log">журнала redo</a>, на котором включен
<a href="glossary.htm#glos_adaptive_flushing">адаптивный сброс</a>.</li>

<li><a name="sysvar_innodb_adaptive_hash_index"></a>
<code>innodb_adaptive_hash_index</code></p>
<table summary="Options for innodb_adaptive_hash_index" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_adaptive_hash_index=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_adaptive_hash_index">
innodb_adaptive_hash_index</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Включен или отключен
<a href="glossary.htm#glos_adaptive_hash_index">адаптивный хеш индекс</a>.
Может быть желательно, в зависимости от Вашей рабочей нагрузки, динамически
включить или отключить
<a href="glossary.htm#glos_adaptive_hash_index">адаптивный хеш индекс</a>,
чтобы улучшить работу запроса. Поскольку адаптивный хеш индекс, возможно, не
полезен для всех рабочих нагрузок, надо смотреть результаты работы с ним,
используя реалистические рабочие нагрузки. См.
<a href="#innodb-adaptive-hash">раздел 16.4.3</a>.</p>

<p>Эта переменная включена по умолчанию. Вы можете изменить этот параметр,
используя <code>SET GLOBAL</code>, не перезапуская сервер. Изменение настроек
требует привилегии <code>SUPER</code>. Вы можете также использовать
<code>--skip-innodb_adaptive_hash_index</code> при запуске сервера,
чтобы отключить это.</p>

<p>Отключение адаптивного хеш-индекса опустошает хэш-таблицу немедленно.
Нормальное функционирование может продолжиться, в то время как хэш-таблица
освобождена, и выполняются запросы, которые использовали хэш-таблицу,
получают доступ к индексным B-деревьям непосредственно вместо этого. Когда
адаптивный хеш-индекс повторно включен,
хэш-таблица заполнена снова во время нормального функционирования.</li>

<li><a name="sysvar_innodb_adaptive_hash_index_parts"></a>
<code>innodb_adaptive_hash_index_parts</code></p>
<table summary="Options for innodb_adaptive_hash_index_parts" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_adaptive_hash_index_parts=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_adaptive_hash_index_parts">
innodb_adaptive_hash_index_parts</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>numeric</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>512</code></td></tr></tbody></table>

<p>Разделы системы поиска адаптивного хеш-индекса. Каждый индекс связан с
определенным разделом, каждый раздел защищен отдельно.</p>
<p>Адаптивный хеш индекс разделен на 8
частей по умолчанию. Максимальная установка 512.</p>
<p>См. <a href="#innodb-adaptive-hash">раздел 16.4.3</a>.</li>

<li><a name="sysvar_innodb_adaptive_max_sleep_delay"></a>
<a href="#sysvar_innodb_adaptive_max_sleep_delay"><code>
innodb_adaptive_max_sleep_delay</code></a></p>

<table summary="Options for innodb_adaptive_max_sleep_delay" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_adaptive_max_sleep_delay=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_adaptive_max_sleep_delay">
innodb_adaptive_max_sleep_delay</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>150000</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000000</code></td></tr></tbody></table>

<p>Позволяет автоматически скорректировать значение
<a href="#sysvar_innodb_thread_sleep_delay"><code>
innodb_thread_sleep_delay</code></a>, согласно текущей рабочей нагрузке.
Любое ненулевое значение включает автоматизированную динамическую
корректировку <code>innodb_thread_sleep_delay</code>
до максимального значения, определенного в
<code>innodb_adaptive_max_sleep_delay</code>.
Значение представляет число микросекунд. Эта опция может быть полезной
в занятых системах, более чем с 16 потоками <code>InnoDB</code>.
Практически это является самым ценным для систем MySQL с сотнями или
тысячами одновременных соединений.</p>
<p>См. <a href="#innodb-performance-thread_concurrency">раздел
16.6.5</a>.</li>

<li><a name="sysvar_innodb_api_bk_commit_interval"></a>
<code>innodb_api_bk_commit_interval</code></p>

<table summary="Options for innodb_api_bk_commit_interval" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_api_bk_commit_interval=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_api_bk_commit_interval">
innodb_api_bk_commit_interval</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>5</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1073741824 </code></td></tr></tbody></table>

<p>Как часто передать неактивные соединения, которые используют
<code>InnoDB</code> <span><strong>memcached</strong></span>, в секундах. См.
<a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_innodb_api_disable_rowlock"></a>
<code>innodb_api_disable_rowlock</code></p>
<table summary="Options for innodb_api_disable_rowlock" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_api_disable_rowlock=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_api_disable_rowlock">innodb_api_disable_rowlock</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Используйте эту переменную, чтобы отключить блокировки строки, когда
<code>InnoDB</code> <span><strong>memcached</strong></span> выполняет DML.
По умолчанию <code>innodb_api_disable_rowlock</code> <code>OFF</code>,
что означает, что <span><strong>memcached</strong></span>
просит блокировки строки для операций получения и установки. Когда
<code>innodb_api_disable_rowlock</code> <code>ON</code>,
<span><strong>memcached</strong></span> просит табличную блокировку
вместо блокировок строки.</p>

<p><code>innodb_api_disable_rowlock</code>
не является динамичной. Это должно быть определено в командной строке
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a> или
введено в конфигурационный файл MySQL. Конфигурация вступает в силу, когда
плагин установлен, что делается каждый раз, когда сервер MySQL запущен.</li>

<li><a name="sysvar_innodb_api_enable_binlog"></a>
<code>innodb_api_enable_binlog</code></p>
<table summary="Options for innodb_api_enable_binlog" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_api_enable_binlog=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_api_enable_binlog">
innodb_api_enable_binlog</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Позволяет Вам использовать плагин <span><strong>memcached</strong></span>
с MySQL <a href="glossary.htm#glos_binary_log">двоичным журналом</a>. См.
<a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_innodb_api_enable_mdl"></a>
<code>innodb_api_enable_mdl</code></p>
<table summary="Options for innodb_api_enable_mdl" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_api_enable_mdl=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_api_enable_mdl">
innodb_api_enable_mdl</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Блокирует таблицу, используемую
<span><strong>memcached</strong></span>, чтобы это не могло быть удалено или
изменено <a href="glossary.htm#glos_ddl">DDL</a> через интерфейс SQL. См.
<a href="#innodb-memcached">раздел 16.19</a>.</li>

<li><a name="sysvar_innodb_api_trx_level"></a>
<code>innodb_api_trx_level</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_api_trx_level=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_api_trx_level">
innodb_api_trx_level</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr></tbody></table>

<p>Позволяет Вам управлять операционным
<a href="glossary.htm#glos_isolation_level">уровнем изоляции</a>
на запросах, обработанных интерфейсом <span><strong>memcached</strong>
</span>. См. <a href="#innodb-memcached">раздел 16.19</a>.
Константы, соответствующие именам:</p>

<ul><li><p>0 = <a href="#isolevel_read-uncommitted"><code>
READ UNCOMMITTED</code></a></li>
<li>1 = <a href="#isolevel_read-committed"><code>READ COMMITTED
</code></a></li>
<li>2 = <a href="#isolevel_repeatable-read"><code>REPEATABLE READ
</code></a></li>
<li>3 = <a href="#isolevel_serializable"><code>SERIALIZABLE</code>
</a></p></li></ul></li>

<li><p><a name="sysvar_innodb_autoextend_increment"></a>
<code>innodb_autoextend_increment</code></p>
<table summary="Options for innodb_autoextend_increment" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_autoextend_increment=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_autoextend_increment">
innodb_autoextend_increment</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>64</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000</code></td></tr></tbody></table>

<p>Размер увеличения (в MB) для того, чтобы расширить размер файла
<a href="glossary.htm#glos_system_tablespace">системного табличного
пространства</a>, когда это становится полным. Значение по умолчанию 64. Эта
переменная не затрагивает файлы file-per-table (<code>.ibd</code>),
которые создаются, если Вы используете
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table=1</code></a>, или общее табличное пространство.
Те файлы автомасштабируются независимо от значения
<a href="#sysvar_innodb_autoextend_increment"><code>
innodb_autoextend_increment</code></a>.
Начальные расширения идут небольшими порциями, после которых расширения
происходят блоками по 4MB.</li>

<li><a name="sysvar_innodb_autoinc_lock_mode"></a>
<code>innodb_autoinc_lock_mode</code></p>
<table summary="Options for innodb_autoinc_lock_mode" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_autoinc_lock_mode=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_autoinc_lock_mode">
innodb_autoinc_lock_mode</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="5"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td rowspan="3" valign="top"><span>
<strong>Допустимые значения</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td colspan="2"><code>1</code></td></tr>
<tr><td colspan="2"><code>2</code></td></tr></tbody></table>

<p><a href="glossary.htm#glos_lock_mode">Режим блокировки</a>, чтобы
произвести значения <a href="glossary.htm#glos_auto_increment">
auto-increment</a>. Допустимые значения 0, 1 или 2 для режимов
<span><span>traditional</span></span>, <span><span>consecutive</span></span>
или <span><span>interleaved</span></span>.
<a href="#innodb-auto-increment-handling">раздел 16.8.5</a>
описывает характеристики этих режимов.</p>
<p>У этой переменной есть значение по умолчанию 1
(<span><span>consecutive</span></span>).</li>

<li><a name="sysvar_innodb_background_drop_list_empty"></a>
<code>innodb_background_drop_list_empty</code></p>
<table summary="Options for innodb_background_drop_list_empty" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_background_drop_list_empty=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_background_drop_list_empty">
innodb_background_drop_list_empty</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включение опции отладки
<code>innodb_background_drop_list_empty</code>
помогает избежать отказов, задерживая табличное создание, пока фоновый список
удаления не пуст. Например, если случай теста A поместил таблицу
<code>t1</code> в фоновый список, случай теста B пока фоновый список не пуст
прежде, чем составить таблицу <code>t1</code>.</li>

<li><a name="sysvar_innodb_buffer_pool_chunk_size"></a>
<code>innodb_buffer_pool_chunk_size</code></p>
<table summary="Options for innodb_buffer_pool_chunk_size" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_chunk_size</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_buffer_pool_chunk_size">
innodb_buffer_pool_chunk_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>134217728</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>innodb_buffer_pool_size/innodb_buffer_pool_instances
</code></td></tr></tbody></table>

<p><code>innodb_buffer_pool_chunk_size</code> определяет размер куска для
изменения размера буферного пула.</p>
<p><a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> является динамичным, который позволяет Вам
изменять размеры буферного пула, не перезапуская сервер. Чтобы избежать
копировать все буферные страницы пула во время изменения размеров операций,
работа выполнена <span><span>кусками</span></span>. Размер куска определен
<code>innodb_buffer_pool_chunk_size</code>. По умолчанию
<code>innodb_buffer_pool_chunk_size</code> 128 MB (134217728 байт).
Число страниц, содержавшихся в куске, зависит от значения
<a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a>. <code>innodb_buffer_pool_chunk_size</code>
может быть увеличен или уменьшен с шагом 1MB (1048576 байт).</p>

<p>Следующие условия применяются, изменяя
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>:</p>

<ul><li><p>Если <a href="#sysvar_innodb_buffer_pool_chunk_size">
<code>innodb_buffer_pool_chunk_size</code></a>*
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> больше чем текущий буферный размер
пула, когда буферный пул инициализирован,
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> усечен к
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>/
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>.</li>

<li>Буферный размер пула должен всегда быть равным или кратным
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>*
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>. Если Вы изменяете
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>,
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> автоматически скорректирован к значению,
которое равно или кратно
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>*
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>, что не меньше, чем текущий буферный
размер пула. Корректировка происходит, когда буферный пул инициализирован.
</p></li></ul>

<p>Меняя <a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a> будьте осторожны, так как
изменяя это значение можно автоматически увеличить размер буферного пула.
Прежде, чем Вы измените
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>, вычислите эффект, который это будет
иметь <a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>, чтобы
гарантировать, что получающийся буферный размер пула является приемлемым.</p>

<p>Чтобы избегать потенциальных исполнительных проблем, число кусков
(<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>/
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>) не должно превысить 1000.</p>
<p>См. <a href="#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.
</li>

<li><a name="sysvar_innodb_buffer_pool_debug"></a>
<code>innodb_buffer_pool_debug</code></p>
<table summary="Options for innodb_buffer_pool_debug" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_debug=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_buffer_pool_debug">
innodb_buffer_pool_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включение этой опции разрешает многократные буферные экземпляры, когда
буферный пул меньше 1GB, игнорируя ограничение минимума размера пула в 1GB,
наложенное на <a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>. Опция <code>innodb_buffer_pool_debug
</code> доступна, если поддержка отладка собрана с использованием опции
<a href="install.htm#option_cmake_with_debug"><code>WITH_DEBUG</code></a> в
<span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_buffer_pool_dump_at_shutdown"></a>
<code>innodb_buffer_pool_dump_at_shutdown</code></p>
<table summary="Options for innodb_buffer_pool_dump_at_shutdown" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_dump_at_shutdown=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_buffer_pool_dump_at_shutdown">
innodb_buffer_pool_dump_at_shutdown</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Определяет, сделать ли запись страниц, кэшируемых в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>, когда сервер
MySQL закрыт, чтобы сократить процесс
<a href="glossary.htm#glos_warm_up">разминки</a> в следующем перезапуске.
Как правило используется в комбинации с
<a href="#sysvar_innodb_buffer_pool_load_at_startup"><code>
innodb_buffer_pool_load_at_startup</code></a>.
Опция <a href="#sysvar_innodb_buffer_pool_dump_pct"><code>
innodb_buffer_pool_dump_pct</code></a> определяет процент последний раз
используемых буферных страниц пула для дампа.</p>

<p><a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a> и
<code>innodb_buffer_pool_load_at_startup</code> включены по умолчанию.</p>
<p>См. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.
</li>

<li><a name="sysvar_innodb_buffer_pool_dump_now"></a>
<code>innodb_buffer_pool_dump_now</code></p>
<table summary="Options for innodb_buffer_pool_dump_now" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_dump_now=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_buffer_pool_dump_now">
innodb_buffer_pool_dump_now</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Немедленно делает запись страниц, кэшируемых в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>.
Как правило используется в комбинации с
<a href="#sysvar_innodb_buffer_pool_load_now"><code>
innodb_buffer_pool_load_now</code></a>.</p>
<p>См. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.
</li>

<li><a name="sysvar_innodb_buffer_pool_dump_pct"></a>
<code>innodb_buffer_pool_dump_pct</code></p>
<table summary="Options for innodb_buffer_pool_dump_pct" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_dump_pct=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_buffer_pool_dump_pct">
innodb_buffer_pool_dump_pct</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>25</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr></tbody></table>

<p>Определяет процент последний раз используемых страниц для каждого
буферного пула, чтобы читать и сбросить в дамп. Диапазон 1-100. Значение по
умолчанию 25. Например, если есть 4 буферных пула с 100 страницами каждый, и
<a href="#sysvar_innodb_buffer_pool_dump_pct"><code>
innodb_buffer_pool_dump_pct</code></a> 25, то 25 последний раз используемых
страниц из каждого буферного пула выведены в дамп.</li>

<li><a name="sysvar_innodb_buffer_pool_filename"></a>
<code>innodb_buffer_pool_filename</code></p>
<table summary="Options for innodb_buffer_pool_filename" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_filename=file</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_buffer_pool_filename">
innodb_buffer_pool_filename</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>file name</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ib_buffer_pool</code></td></tr></tbody></table>

<p>Определяет название файла, который хранит список ID
табличного пространства и страниц, произведенный
<a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a> или
<a href="#sysvar_innodb_buffer_pool_dump_now"><code>
innodb_buffer_pool_dump_now</code></a>. ID сохраняют следующий формат:
<code>space, page_id</code>. По умолчанию, файл называют
<code>ib_buffer_pool</code> и расположен он в каталоге данных.
Местоположение не по умолчанию должно быть определено
относительно каталога данных.</p>

<p>Имя файла может быть определено во время выполнения, используя
<a href="sql.htm#set-variable"><code>SET</code></a>:
<pre>
SET GLOBAL innodb_buffer_pool_filename=<em><code>'file_name'</code></em>;
</pre>

<p>Вы можете также определить определяемое пользователем имя файла при
запуске в строке запуска или конфигурационном файле MySQL. Определяя имя
файла при запуске, файл должен уже существовать или
<code>InnoDB</code> возвратит ошибку запуска, указывающую, что нет такого
файла или каталога.</p>
<p>См. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.
</li>

<li><a name="sysvar_innodb_buffer_pool_instances"></a>
<code>innodb_buffer_pool_instances</code></p>
<table summary="Options for innodb_buffer_pool_instances" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_instances=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_innodb_buffer_pool_instances">
innodb_buffer_pool_instances</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(Windows, 32-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>(autosized)</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>64</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(Другие)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8 (или 1, если innodb_buffer_pool_size &lt; 1GB</code>
</td></tr><tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>64</code></td></tr></tbody></table>

<p>Число областей, на которые
<a href="glossary.htm#glos_buffer_pool">буферный пул</a> разделен.
Для систем с буферными пулами в диапазоне нескольких гигабай деление
буферного пула на отдельные экземпляры может улучшить параллелизм, уменьшая
издержки на различное чтение потоков и запись кэшируемых страниц.
Каждая страница, которая сохранена или считана из буферного пула, назначена
на один из буферных экземпляров пула беспорядочно, используя хеширующую
функцию. Каждый буферный пул управляет своими собственными свободными
списками, <a href="glossary.htm#glos_flush_list">списками потока</a>,
<a href="glossary.htm#glos_lru">LRU</a> и всеми другими структурами данных,
соединенными с буферным пулом, и защищен его собственным
<a href="glossary.htm#glos_mutex">mutex</a>.</p>

<p>Эта опция вступает в силу, только когда Вы устанавливаете
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> в 1GB или больше.
Полный буферный размер пула разделен среди всех буферных пулов.
Для лучшей эффективности определите комбинацию
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> и
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>
так, чтобы каждый буферный экземпляр был минимум в 1GB.</p>

<p>Значение по умолчанию в 32-bit Windows зависит от значения
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>:</p>

<ul><li><p>Если <a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> больше 1.3GB, значение по умолчанию для
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>=
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>/128MB,
с отдельным распределением памяти для каждого куска. 1.3GB
был выбран в качестве границы, в которой есть существенный риск для
32-битной Windows не быть способной выделить непрерывное адресное
пространство, необходимое для единственного буферного пула.</li>
<li>Иначе значение по умолчанию 1.</p></li></ul>

<p>На всех других платформах значение по умолчанию 8, когда
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> больше или равен 1GB. Иначе 1.</p>
<p>См. <a href="#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.
</li>

<li><a name="sysvar_innodb_buffer_pool_load_abort"></a>
<code>innodb_buffer_pool_load_abort</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_load_abort=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_innodb_buffer_pool_load_abort">
innodb_buffer_pool_load_abort</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Прерывает процесс восстановления содержания
<a href="glossary.htm#glos_buffer_pool">буферного пула</a>, вызванный
<a href="#sysvar_innodb_buffer_pool_load_at_startup"><code>
innodb_buffer_pool_load_at_startup</code></a> или
<a href="#sysvar_innodb_buffer_pool_load_now"><code>
innodb_buffer_pool_load_now</code></a>.</p>
<p>См. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.
</li>

<li><a name="sysvar_innodb_buffer_pool_load_at_startup"></a>
<code>innodb_buffer_pool_load_at_startup</code></p>
<table summary="Options for innodb_buffer_pool_load_at_startup" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_load_at_startup=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_innodb_buffer_pool_load_at_startup">
innodb_buffer_pool_load_at_startup</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Определяет, что на запуске сервера MySQL
<a href="glossary.htm#glos_buffer_pool">буферный пул</a> автоматически
<a href="glossary.htm#glos_warm_up">подогревается</a>, загружая те же самые
страницы, которые это содержало в более раннее время. Как правило,
используется в комбинации с
<a href="#sysvar_innodb_buffer_pool_dump_at_shutdown"><code>
innodb_buffer_pool_dump_at_shutdown</code></a>.</p>

<p><a href="#sysvar_innodb_buffer_pool_dump_at_shutdown">
<code>innodb_buffer_pool_dump_at_shutdown</code></a>
и <code>innodb_buffer_pool_load_at_startup</code> включены по умолчанию.</p>
<p>См. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.
</li>

<li><a name="sysvar_innodb_buffer_pool_load_now"></a>
<code>innodb_buffer_pool_load_now</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_load_now=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_buffer_pool_load_now">
innodb_buffer_pool_load_now</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Немедленно <a href="glossary.htm#glos_warm_up">нагревает</a>
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>, загружая ряд
страниц данных, не ожидая перезапуска сервера. Может быть полезным, чтобы
возвратить кэш-память к известному состоянию во время сопоставительного
анализа, или к готовому сервер MySQL, чтобы возобновить его нормальную
рабочую нагрузку после выполнения запросов для отчетов или обслуживания.
См. <a href="#innodb-preload-buffer-pool">раздел 16.6.3.8</a>.</li>

<li><a name="sysvar_innodb_buffer_pool_size"></a>
<code>innodb_buffer_pool_size</code></p>
<table summary="Options for innodb_buffer_pool_size" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_buffer_pool_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_buffer_pool_size">
innodb_buffer_pool_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="3"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8388608</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(32-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>134217728</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>5242880</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(64-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>134217728</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>5242880</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**64-1</code></td></tr></tbody></table>

<p>Размер в байтах <a href="glossary.htm#glos_buffer_pool">буферного пула
</a>, области памяти, где <code>InnoDB</code> хранит таблицу кэшей и
индексные данные. Значение по умолчанию составляет 128 МБ. Максимальное
значение зависит от архитектуры центрального процессора: максимум 4294967295
(2<sup>32</sup>-1) в 32-bit системах и 18446744073709551615
(2<sup>64</sup>-1) в 64-bit системах. В 32-bit системах
архитектура центрального процессора и операционная система могут наложить
более низкий практический максимальный размер, чем установленный максимум.
Когда размер буферного пула больше 1GB, установка
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> к значению больше 1 может улучшить
масштабируемость относительно занятого сервера.</p>

<p>Буферный пул большего размера требует, чтобы меньше дискового ввода/вывода
получило доступ к тем же самым табличным данным. На специализированном
сервере базы данных Вы могли бы установить буферный размер пула в 80%
размера физической памяти машины. Знайте о следующих потенциальных проблемах,
когда конфигурируете размер буфера, и будьте подготовлены вычислить размер
буферного пула в случае необходимости.</p>

<ul><li><p>Соревнование за физическую память может вызвать
своп в операционной системе.</li>
<li><code>InnoDB</code> резервирует дополнительную память для буферов и
структур управления, чтобы полное выделенное место было приблизительно на
10% больше, чем указанный размер пула.</li>

<li>Адресное пространство для буферного пула должно быть непрерывным, что
может быть проблемой на системах Windows с DLL, которые
загружаются в определенных адресах.</li>

<li>Время, чтобы инициализировать буферный пул, примерно пропорционально его
размеру. На больших установках время инициализации могло бы быть
существенным. Например, на современном сервере Linux x86_64 инициализация
буферного пула в 10 GB занимает приблизительно 6 секунд. См.
<a href="#innodb-buffer-pool">раздел 16.6.3.1</a>.</p></li></ul>

<p>Когда Вы увеличиваете или уменьшаете
размер пула, работа выполнена в кусках. Размер куска определен
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>, у которой есть значение
по умолчанию 128 MB.</p>

<p>Буферный размер должен всегда быть равным или кратным
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>
*<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>.
Если Вы изменяете буферный размер к значению, которое не равно или кратно
<a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>*
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>,
буферный размер автоматически скорректирован к значению, которое равно или
кратно <a href="#sysvar_innodb_buffer_pool_chunk_size"><code>
innodb_buffer_pool_chunk_size</code></a>*
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>, но не меньше, чем
указанный буферный размер.</p>

<p><code>innodb_buffer_pool_size</code> может быть установлен динамически,
что позволяет Вам изменять размеры буферного пула, не перезапуская сервер.
<a href="server.htm#statvar_Innodb_buffer_pool_resize_status"><code>
Innodb_buffer_pool_resize_status</code></a>
сообщает о состоянии изменения размера буферного пула. См.
<a href="#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.</li>

<li><a name="sysvar_innodb_change_buffer_max_size"></a>
<code>innodb_change_buffer_max_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_change_buffer_max_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_change_buffer_max_size">
innodb_change_buffer_max_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>25</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>50</code></td></tr></tbody></table>

<p>Максимальный размер для
<a href="glossary.htm#glos_change_buffer">буфера изменений</a>,
как процент от полного размера
<a href="glossary.htm#glos_buffer_pool">буферного пула</a>.
Вы могли бы увеличить это значение для сервера MySQL с тяжелой вставкой,
обновлением и удалением или уменьшить это для сервера MySQL с неизменными
данными. Для общих советов по настройке ввода/вывода см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</li>

<li><a name="sysvar_innodb_change_buffering"></a>
<code>innodb_change_buffering</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_change_buffering=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_change_buffering">
innodb_change_buffering</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="8"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>all</code></td></tr>
<tr><td rowspan="6" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>none</code></td></tr>
<tr><td colspan="2"><code>inserts</code></td></tr>
<tr><td colspan="2"><code>deletes</code></td></tr>
<tr><td colspan="2"><code>changes</code></td></tr>
<tr><td colspan="2"><code>purges</code></td></tr>
<tr><td colspan="2"><code>all</code></td></tr></tbody></table>

<p>Выполняет ли <code>InnoDB</code>
<a href="glossary.htm#glos_change_buffering">буферизацию изменений</a>,
оптимизируя задержки операции записи вторичного индекса так, чтобы операции
ввода/вывода могли быть выполнены последовательно. Разрешенные значения
описаны в следующей таблице. Значения могут также быть определены в цифровой
форме. Для получения дополнительной информации см.
<a href="#innodb-performance-change_buffering">раздел 16.6.4</a>.
Для общих советов по настройке ввода/вывода см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</p>

<a name="idm139965321898320"></a><p><b>
Таблица 16.11. Разрешенные значения для innodb_change_buffering</b></p>
<table border="1">
<thead><tr><th>Value</th><th>Числовое значение</th>
<th>Описание</th></tr></thead>
<tbody><tr><td><code>none</code></td><td><code>0</code></td><td>
Не буферизовать операции.</td></tr>
<tr><td><code>inserts</code></td><td><code>1</code></td><td>
Буферизовать операции вставки.</td></tr>
<tr><td><code>deletes</code></td><td><code>2</code></td><td>
Буферизовать операции маркировки удаления, строго говоря, отметка записей
индекса для более позднего удаления во время работы чистки.</td></tr>
<tr><td><code>changes</code></td><td><code>3</code></td><td>
Буферизовать операции маркировки удаления и вставки.</td></tr>
<tr><td><code>purges</code></td><td><code>4</code></td><td>
Буферизовать операции удаления, которые происходят в фоне.</td></tr>
<tr><td><code>all</code></td><td><code>5</code></td><td>
По умолчанию. Буферизовать операции маркировки удаления, вставки и чистки.
</td></tr></tbody></table></li>

<li><p><a name="sysvar_innodb_change_buffering_debug"></a>
<code>innodb_change_buffering_debug</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_change_buffering_debug=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_innodb_change_buffering_debug">
innodb_change_buffering_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="3"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2</code></td></tr></tbody></table>

<p>Устанавливает флаг отладки для буферизации изменений. Значение 1 пишет
все изменения буфера изменения. Значение 2 пишет катастрофический отказ при
слиянии. Значение по умолчанию 0 указывает, что флаг отладки, не установлен.
Эта опция только доступна, когда отладка поддержки собрана с использованием
<a href="install.htm#option_cmake_with_debug"><code>WITH_DEBUG</code></a> в
<span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_checksum_algorithm"></a>
<a href="#sysvar_innodb_checksum_algorithm"><code>
innodb_checksum_algorithm</code></a></p>

<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_checksum_algorithm=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_checksum_algorithm">
innodb_checksum_algorithm</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="8"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>crc32</code></td></tr>
<tr><td rowspan="6" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>innodb</code></td></tr>
<tr><td colspan="2"><code>crc32</code></td></tr>
<tr><td colspan="2"><code>none</code></td></tr>
<tr><td colspan="2"><code>strict_innodb</code></td></tr>
<tr><td colspan="2"><code>strict_crc32</code></td></tr>
<tr><td colspan="2"><code>strict_none</code></td></tr></tbody></table>

<p>Определяет, как произвести и проверить
<a href="glossary.htm#glos_checksum">контрольную сумму</a>, сохраненную в
каждом дисковом блоке каждого <a href="glossary.htm#glos_tablespace">
табличного пространства</a>. Значение по умолчанию для
<code>innodb_checksum_algorithm</code> <code>crc32</code>.</p>

<p><a href="mysql.htm#mysql-enterprise-backup">MySQL Enterprise Backup</a> до
версии 3.8.0 не поддерживают табличные пространства с использованием
контрольных сумм CRC32. <a href="mysql.htm#mysql-enterprise-backup">MySQL
Enterprise Backup</a> добавляет поддержку контрольной суммы
CRC32 в 3.8.1 с некоторыми ограничениями.</p>

<p>Значение <code>innodb</code> обратно совместимо со всеми версиями MySQL.
Значение <code>crc32</code> использует алгоритм, который быстрее, чтобы
вычислить контрольную сумму для каждого измененного блока и проверить
контрольные суммы при каждом дисковом чтении. Это просматривает блоки по 32
бита за один раз, что является быстрее алгоритма контрольной суммы
<code>innodb</code>, который просматривает блоки по 8 бит за раз. Значение
<code>none</code> пишет постоянную величину в области контрольной суммы
вместо того, чтобы вычислить значение, основанное на данных о блоке. Блоки в
табличном пространстве могут использовать соединение старых, новых и никаких
значений контрольной суммы, будучи обновлены постепенно, по мере того, как
данные изменены. Как только любые блоки в табличном пространстве изменены,
чтобы использовать <code>crc32</code>, связанные таблицы не могут быть
считаны более ранними версиями MySQL.</p>

<p>Форма <code>strict_*</code> работает как
<code>innodb</code>, <code>crc32</code> и
<code>none</code>, за исключением того, что <code>InnoDB</code>
сообщает об ошибке, если сталкивается с допустимым, но несоответствующим
значением контрольной суммы. В этом случае страница все еще принята как
допустимая. Рекомендуется, чтобы Вы использовали <code>strict_*</code> только
в новом экземпляре, чтобы настроить все табличные пространства впервые.
Настройки <code>strict_*</code> несколько быстрее, потому что они не должны
вычислить все значения контрольной суммы во время дисковых чтений.</p>

<p>Следующая таблица иллюстрирует различие между значениями опции и их
версиями <code>strict_</code>. <code>none</code>, <code>innodb</code> и
<code>crc32</code> пишут указанный тип значения контрольной суммы в каждый
блок данных, но для совместимости принимают любое из других значений
контрольной суммы, проверяя блок во время работы чтения.
Форма <code>strict_</code> каждого параметра также принимает любое допустимое
значение контрольной суммы, но печатает сообщение об ошибке, когда
сталкивается с несоответствием допустимого значения контрольной суммы.
Используя <code>strict_*</code> можно сделать проверку быстрее, если все
файлы с данными создаются с идентичным значением
<code>innodb_checksum_algorithm</code>.</p>

<a name="idm139965321790080"></a><p><b>
Таблица 16.12. Настройки innodb_checksum_algorithm</b></p>
<table border="1">
<thead><tr><th>Значение</th><th>Произведенная контрольная сумма (при записи)
</th><th>Разрешенные контрольные суммы (при чтении)</th></tr></thead>
<tbody><tr><td>none</td><td>Число.</td>
<td>Любая из контрольных сумм, произведенных <code>none</code>,
<code>innodb</code> или <code>crc32</code>.</td></tr>
<tr><td>innodb</td><td>Контрольная сумма, вычисленная в программном
обеспечении, используя оригинальный алгоритм <code>InnoDB</code>.</td>
<td>Любая из контрольных сумм, произведенных <code>none</code>,
<code>innodb</code> или <code>crc32</code>.</td></tr>
<tr><td>crc32</td><td>Контрольная сумма, вычисленная с использованием
алгоритма <code>crc32</code>, возможно сделанного аппаратными средствами.
</td><td>Любая из контрольных сумм, произведенных <code>none</code>,
<code>innodb</code> или <code>crc32</code>.</td></tr>
<tr><td>strict_none</td><td>Число.</td><td>Любая из контрольных сумм,
произведенных <code>none</code>, <code>innodb</code> или <code>crc32</code>.
<code>InnoDB</code> печатает сообщение об ошибке, если сталкивается с
допустимой, но несоответствующей контрольной суммой.</td></tr>
<tr><td>strict_innodb</td><td>Контрольная сумма, вычисленная в программном
обеспечении, используя оригинальный алгоритм <code>InnoDB</code>.</td>
<td>Любая из контрольных сумм,
произведенных <code>none</code>, <code>innodb</code> или <code>crc32</code>.
<code>InnoDB</code> печатает сообщение об ошибке, если сталкивается с
допустимой, но несоответствующей контрольной суммой.</td></tr>
<tr><td>strict_crc32</td><td>Контрольная сумма, вычисленная с использованием
алгоритма <code>crc32</code>, возможно сделанного аппаратными средствами.
</td><td>Любая из контрольных сумм,
произведенных <code>none</code>, <code>innodb</code> или <code>crc32</code>.
<code>InnoDB</code> печатает сообщение об ошибке, если сталкивается с
допустимой, но несоответствующей контрольной суммой.
</td></tr></tbody></table></li>

<li><p><a name="sysvar_innodb_cmp_per_index_enabled"></a>
<code>innodb_cmp_per_index_enabled</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_cmp_per_index_enabled=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_innodb_cmp_per_index_enabled">
innodb_cmp_per_index_enabled</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td rowspan="2" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>OFF</code></td></tr>
<tr><td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Включает индексную связанную со сжатием статистику в
<a href="inform.htm#innodb-cmp-per-index-table"><code>
INFORMATION_SCHEMA.INNODB_CMP_PER_INDEX</code></a>.
Поскольку эти статистические данные могут быть дорогими в сборе, включите эту
опцию только на тесте или ведомых экземплярах во время исполнительной
настройки, связанной с <a href="glossary.htm#glos_compression">
сжатыми</a> таблицами <code>InnoDB</code>.</li>

<li><a name="sysvar_innodb_commit_concurrency"></a>
<code>innodb_commit_concurrency</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_commit_concurrency=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_commit_concurrency">
innodb_commit_concurrency</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000</code></td></tr></tbody></table>

<p>Число <a href="glossary.htm#glos_thread">потоков</a>, которые могут
<a href="glossary.htm#glos_commit">завершать транзакции</a>
в то же самое время. Значение 0 (значение по умолчанию) разрешает любое число
<a href="glossary.htm#glos_transaction">транзакций</a> одновременно.</p>

<p>Значение <code>innodb_commit_concurrency</code> не может быть изменено во
время выполнения от ноля до отличного от нуля или наоборот. Значение может
быть изменено от одного ненулевого значения до другого.</li>

<li><a name="sysvar_innodb_compress_debug"></a>
<code>innodb_compress_debug</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_compress_debug=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_compress_debug">innodb_compress_debug</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="6"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>none</code></td></tr>
<tr><td rowspan="4" valign="top"><span><strong>Допустимые значения</strong>
</span></td>
<td colspan="2"><code>none</code></td></tr>
<tr><td colspan="2"><code>zlib</code></td></tr>
<tr><td colspan="2"><code>lz4</code></td></tr>
<tr><td colspan="2"><code>lz4hc</code></td></tr></tbody></table>

<p>Сжимает все таблицы, используя указанный алгоритм сжатия, не имея
необходимости определять атрибут <code>COMPRESSION</code>
для каждой таблицы. Эта опция доступна только, если поддержка отладки собрана
с использованием <a href="install.htm#option_cmake_with_debug"><code>
WITH_DEBUG</code></a> в <span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_compression_failure_threshold_pct"></a>
<code>innodb_compression_failure_threshold_pct</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_compression_failure_threshold_pct=#</code>
</td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_compression_failure_threshold_pct">
innodb_compression_failure_threshold_pct</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>5</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr></tbody></table>

<p>Устанавливает предел, в котором MySQL начинает добавлять место в
пределах <a href="glossary.htm#glos_compression">сжатых</a>
страниц, чтобы избежать дорогих
<a href="glossary.htm#glos_compression_failure">отказов сжатия</a>.
Значение 0 отключает механизм, который контролирует эффективность сжатия и
динамически корректирует количество места. См.
<a href="#innodb-performance-compression-oltp">раздел 16.9.1.6</a>.
</li>

<li><a name="sysvar_innodb_compression_level"></a>
<code>innodb_compression_level</code></p>
<table summary="Options for innodb_compression_level" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_compression_level=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_compression_level">
innodb_compression_level</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>6</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>9</code></td></tr></tbody></table>

<p>Определяет уровень zlib сжатия, чтобы использовать для
<a href="glossary.htm#glos_compression">сжатых</a> таблицы и индекса.
См. <a href="#innodb-performance-compression-oltp">раздел 16.9.1.6
</a>.</li>

<li><a name="sysvar_innodb_compression_pad_pct_max"></a>
<code>innodb_compression_pad_pct_max</code></p>
<table summary="Options for innodb_compression_pad_pct_max" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_compression_pad_pct_max=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_compression_pad_pct_max">
innodb_compression_pad_pct_max</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>50</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>75</code></td></tr></tbody></table>

<p>Определяет максимальный процент, который может быть сохранен как свободное
пространство в пределах каждой сжатой
<a href="glossary.htm#glos_page">страницы</a>,
позволяя реорганизовать данные и журнал модификации в пределах страницы,
когда a <a href="glossary.htm#glos_compression">сжатая</a> таблица или
индекс обновлены, и данные могли бы быть повторно сжаты. Применяется только
когда <a href="#sysvar_innodb_compression_failure_threshold_pct">
<code>innodb_compression_failure_threshold_pct</code></a>
установлен в ненулевое значение, и уровень
<a href="glossary.htm#glos_compression_failure">отказов сжатия</a> передает
предел. См. <a href="#innodb-performance-compression-oltp">раздел
16.9.1.6</a>.</li>

<li><a name="sysvar_innodb_concurrency_tickets"></a>
<code>innodb_concurrency_tickets</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_concurrency_tickets=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_concurrency_tickets">
innodb_concurrency_tickets</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>5000</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Определяет число <a href="glossary.htm#glos_thread">потоков</a>,
которые могут работать одновременно. Поток помещен в очередь, когда он
пытается обратиться к <code>InnoDB</code>, если число потоков уже достигло
предела параллелизма. Когда потоку разрешают работать, ему дают несколько
<span><span>свободных тикетов</span></span>, заданное значением
<a href="#sysvar_innodb_concurrency_tickets"><code>
innodb_concurrency_tickets</code></a>, поток работает, пока не израсходует
свои тикеты. После этого поток снова подвергается проверке параллелизма (и
возможна организация очереди) в следующий раз, когда пытается обратиться к
<code>InnoDB</code>. Значение по умолчанию 5000.</p>

<p>С маленьким значением <code>innodb_concurrency_tickets</code>
маленькие транзакции, которые должны обработать только несколько строк,
конкурирует справедливо с большими транзакциями, которые обрабатывают много
строк. Недостаток маленького
<code>innodb_concurrency_tickets</code>: большие транзакции должны образовать
петли через очередь много раз прежде, чем они смогут завершиться, что
расширяет отрезок времени, требуемый, чтобы завершить их задачу.</p>

<p>С большим значением <code>innodb_concurrency_tickets</code>
большие транзакции проводят меньше времени, ожидая позиции в конце очереди
(управляемой <a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a>) и получение строки требует
большего количества времени. Большие транзакции также требуют меньше
проходов через очередь. Недостаток большого
<code>innodb_concurrency_tickets</code>: слишком много больших транзакций,
работающих в то же самое время, могут держать меньшие транзакции, заставляя
их ждать более длительное время перед выполнением.</p>

<p>С отличным от нуля значением
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a> Вы, возможно, должны корректировать
<code>innodb_concurrency_tickets</code>, чтобы найти оптимальный баланс между
большими и меньшими транзакциями. <code>SHOW ENGINE INNODB STATUS</code>
показывает число билетов, остающихся для транзакции выполнения в ее потоке,
при текущем проходе через очередь. Эти данные могут также быть получены из
столбца <code>TRX_CONCURRENCY_TICKETS</code> таблицы
<a href="inform.htm#innodb-trx-table"><code>INFORMATION_SCHEMA.INNODB_TRX
</code></a>.</p>
<p>См. <a href="#innodb-performance-thread_concurrency">раздел
16.6.5</a>.</li>

<li><a name="sysvar_innodb_data_file_path"></a>
<code>innodb_data_file_path</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_data_file_path=name</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_data_file_path">
innodb_data_file_path</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ibdata1:12M:autoextend</code></td></tr></tbody></table>

<p>Пути к <a href="glossary.htm#glos_data_files">файлам с данными</a> и
их размеры. Полный путь к каталогу к каждому файлу с данными сформирован,
добавляя <a href="#sysvar_innodb_data_home_dir"><code>
innodb_data_home_dir</code></a> к каждому пути, определенному здесь.
Размеры файл определен в KB, MB или GB (1024 MB), добавляя <code>K</code>,
<code>M</code> или <code>G</code> к значению размера. Определяя размер файла
с данными в килобайтах (КБ), умножьте его на 1024. Иначе значения КБ
округлены к самому близкому мегабайту (MB). Сумма размеров файлов должна
быть, по крайней мере, немного больше 10 МБ. Если Вы не определяете
<code>innodb_data_file_path</code>, поведение по умолчанию должно создать
единственный автомасштабируемый файл с данными, немного больше 12 МБ,
названный <code>ibdata1</code>. Предел размера отдельных файлов определен
Вашей операционной системой. Вы можете установить размер файла больше 4 ГБ на
тех операционных системах, которые поддерживают большие файлы. Вы можете
также <a href="#innodb-raw-devices">использовать сырой дисковый
раздел в качестве файлов с данными</a>. См.
<a href="#innodb-configuration">раздел 16.6</a>.</p>

<p>Следующие минимальные размеры файла проведены в жизнь для
<span><em>первого</em></span> системного файла с данными табличного
пространства (<code>ibdata1</code>), чтобы гарантировать, что есть достаточно
пространства для буферных блоков doublewrite (Bug #20972309):</p>

<ul><li><p>Для <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a> 16 KB или меньше минимальный размер файла с
данными составляет 3 МБ.</li>

<li>Для <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a> 32 KB минимальный размер файла с
данными составляет 6 MB.</li>

<li>Для <a href="#sysvar_innodb_page_size"><code>innodb_page_size
</code></a> 64 KB минимальный размер файла с данными составляет 12 MB.
</p></li></ul></li>

<li><p><a name="sysvar_innodb_data_home_dir"></a>
<code>innodb_data_home_dir</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_data_home_dir=dir_name</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_data_home_dir">
innodb_data_home_dir</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td><td><span>
<strong>Тип</strong></span></td>
<td colspan="2"><code>Имя каталога</code></td></tr></tbody></table>

<p>Общая часть пути к каталогу для всех
<a href="glossary.htm#glos_data_files">файлов с данными</a> в
<a href="glossary.htm#glos_system_tablespace">системном табличном
пространстве</a>. Эта установка не затрагивает местоположение табличных
пространств <a href="glossary.htm#glos_file_per_table">file-per-table</a>,
когда включена опция <a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>. Значение по умолчанию каталог MySQL
<code>data</code>. Если Вы определяете значение как пустую строку, Вы можете
использовать абсолютные пути к файлам в
<a href="#sysvar_innodb_data_file_path"><code>innodb_data_file_path
</code></a>.</li>

<li><a name="sysvar_innodb_deadlock_detect"></a>
<code>innodb_deadlock_detect</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_deadlock_detect</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_deadlock_detect">
innodb_deadlock_detect</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Эта опция используется, чтобы отключить обнаружение тупика. На системах с
высоким параллелизмом обнаружение тупика может вызвать замедление, когда
многочисленные потоки ждут той же самой блокировки. Время от времени может
быть более эффективно отключить обнаружение тупика и положиться на
<a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a> для операционной отмены,
когда тупик происходит.</li>

<li><a name="sysvar_innodb_default_row_format"></a>
<code>innodb_default_row_format</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_default_row_format=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_default_row_format">
innodb_default_row_format</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="5"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>DYNAMIC</code></td></tr>
<tr><td rowspan="3" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>DYNAMIC</code></td></tr>
<tr><td colspan="2"><code>COMPACT</code></td></tr>
<tr><td colspan="2"><code>REDUNDANT</code></td></tr></tbody></table>

<p>Определяет формат строки по умолчанию для таблицы (включая создаваемые
пользователем временные таблицы). Настройка по умолчанию <code>DYNAMIC</code>.
Другие разрешенные значения <code>COMPACT</code> и <code>REDUNDANT</code>.
<code>COMPRESSED</code> не поддержан для использования в системном табличном
пространстве и не может быть определен как значение по умолчанию.</p>

<p>Недавно составленные таблицы используют формат строки, определенный
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>, когда опция <code>ROW_FORMAT</code> не
определена явно или когда используется <code>ROW_FORMAT=DEFAULT</code>.</p>

<p>Когда <code>ROW_FORMAT</code> не определена явно или определена как
<code>ROW_FORMAT=DEFAULT</code>, любая работа, которая пересоздает таблицу,
также тихо изменяет формат строки таблицы к формату, определенному
<a href="#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>. См.
<a href="#innodb-row-format-specification">раздел 16.10.2</a>.</p>

<p>Внутренние временные таблицы, составленные сервером, чтобы обработать
запросы, используют формат <code>DYNAMIC</code>, независимо от
<a href="#sysvar_innodb_default_row_format">
<code>innodb_default_row_format</code></a>.</li>

<li><a name="sysvar_innodb_disable_sort_file_cache"></a>
<code>innodb_disable_sort_file_cache</code></p>
<table summary="Options for innodb_disable_sort_file_cache" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_disable_sort_file_cache=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_disable_sort_file_cache">
innodb_disable_sort_file_cache</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Если включено, эта переменная отключает кэш файловой системы операционной
системы для сортировки и слияния временных файлов. Эффект состоит в том,
чтобы открыть такие файлы с эквивалентом <code>O_DIRECT</code>.</li>

<li><a name="sysvar_innodb_doublewrite"></a>
<code>innodb_doublewrite</code></p>
<table summary="Options for innodb_doublewrite" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb-doublewrite</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_doublewrite">
innodb_doublewrite</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Если эта переменная включена (значение по умолчанию),
<code>InnoDB</code> хранит все данные дважды, сначала в
<a href="glossary.htm#glos_doublewrite_buffer">буфере doublewrite</a>,
затем в фактические <a href="glossary.htm#glos_data_files">файлы с данными
</a>. Эта переменная может быть выключена
<code>--skip-innodb_doublewrite</code> для точек отсчета или случаев, когда
главная работа необходима, а не беспокойство о целостности данных
или возможных отказах.</p>

<p>Если системные файлы табличного пространства (<span><span>ibdata</span>
</span>) расположены на устройствах Fusion-io, которые поддерживают атомную
запись, буфер doublewrite автоматически отключен, и атомная запись Fusion-io
используются для всех файлов с данными. Поскольку буферная установка
doublewrite глобальна, буферизация также отключена для файлов с данными,
находящихся на не-Fusion-io. Эта функция поддерживается только на аппаратных
средствах Fusion-io и включена только для Fusion-io NVMFS в Linux.
Чтобы в полной мере воспользоваться этой особенностью, установите
<a href="#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a> в <code>O_DIRECT</code>.</li>

<li><a name="sysvar_innodb_fast_shutdown"></a>
<code>innodb_fast_shutdown</code></p>
<table summary="Options for innodb_fast_shutdown" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_fast_shutdown[=#]</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_fast_shutdown">
innodb_fast_shutdown</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="5"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td rowspan="3" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>0</code></td></tr>
<tr><td colspan="2"><code>1</code></td></tr>
<tr><td colspan="2"><code>2</code></td></tr></tbody></table>

<p>Режим <code>InnoDB</code> <a href="glossary.htm#glos_shutdown">shutdown
</a>. Если значение 0, <code>InnoDB</code> делает
<a href="glossary.htm#glos_slow_shutdown">медленное завершение работы</a>,
полную <a href="glossary.htm#glos_purge">чистку</a>
и слияние буфера изменений перед закрытием. Если значение 1 (значение по
умолчанию), <code>InnoDB</code> пропускает эти операции при завершении
работы, процесс, известный как
<a href="glossary.htm#glos_fast_shutdown">быстрое завершение работы</a>.
Если значение 2, <code>InnoDB</code> сбрасывает журналы и закрывается, как
будто MySQL отказал, никакие переданные транзакции не потеряны, но работа
<a href="glossary.htm#glos_crash_recovery">восстановления катастрофического
отказа</a> заставляет следующий запуск занять больше времени.</p>

<p>Медленное завершение работы может занять минуты или даже часы в крайних
случаях, где значительное количество данных все еще буферизовано. Используйте
медленный метод завершения работы прежде, чем обновить MySQL между
главными выпусквси, чтобы все файлы с данными были полностью подготовлены в
случае, если процесс обновления обновляет формат файла.</p>

<p><code>innodb_fast_shutdown=2</code> применяется
в чрезвычайной ситуации или ситуациях с поиском неисправностей, чтобы
получить абсолютное самое быстрое завершение работы, если данные
подвергаются риску повреждения.</li>

<li><a name="sysvar_innodb_fil_make_page_dirty_debug"></a>
<code>innodb_fil_make_page_dirty_debug</code></p>
<table summary="Options for innodb_fil_make_page_dirty_debug" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_fil_make_page_dirty_debug=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_fil_make_page_dirty_debug">
innodb_fil_make_page_dirty_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="3"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr></tbody></table>

<p>По умолчанию установка <code>innodb_fil_make_page_dirty_debug</code> в ID
табличного пространства немедленно помечает грязной первую страницу
табличного пространства. Если
<a href="#sysvar_innodb_saved_page_number_debug"><code>
innodb_saved_page_number_debug</code></a> установлен в значение не по
умолчанию, установка <code>innodb_fil_make_page_dirty_debug</code> помечает
грязной указанную страницу. <code>innodb_fil_make_page_dirty_debug</code>
доступна только если поддержка отладки собрана с использованием
<a href="install.htm#option_cmake_with_debug"><code>WITH_DEBUG</code></a> в
<span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_file_per_table"></a>
<code>innodb_file_per_table</code></p>
<table summary="Options for innodb_file_per_table" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_file_per_table</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_file_per_table">
innodb_file_per_table</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Когда <code>innodb_file_per_table</code> включен (значение по умолчанию),
<code>InnoDB</code> хранит данные и индекс для каждой недавно составленной
таблицы в отдельном файле
<a href="glossary.htm#glos_ibd_file"><code>.ibd</code></a>,
а не в системном табличном пространстве. Место для этих таблиц освобождено,
когда таблицы удалены или усеченные. Эта установка позволяет несколько других
особенностй, например, <a href="glossary.htm#glos_compression">сжатие</a>.
См. <a href="#innodb-multiple-tablespaces">раздел 16.7.4</a>.</p>

<p>Знайте, что включение
<a href="#sysvar_innodb_file_per_table"><code>innodb_file_per_table
</code></a> также значит, что
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> переместит
таблицу из системного табличного пространства в отдельный файл
<code>.ibd</code> в случаях, где <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> обновляет таблицу (<code>ALGORITHM=COPY</code>).
Исключение: таблицы, которые были помещены в системное табличное
пространство, используя опцию <code>TABLESPACE=innodb_system</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Эти таблицы не затронуты <code>innodb_file_per_table</code>
и могут быть перемещены только в табличные пространства file-per-table,
применяя <a href="sql.htm#alter-table"><code>ALTER TABLE
... TABLESPACE=innodb_file_per_table</code></a>.</p>

<p>Если <code>innodb_file_per_table</code> выключен, <code>InnoDB</code>
хранит данные для всех таблиц и индексов в
<a href="glossary.htm#glos_ibdata_file">файлах ibdata</a>,
которые составляют <a href="glossary.htm#glos_system_tablespace">
системное табличное пространство</a>. Эта установка уменьшает издержки
операций файловой системы для таких операций, как
<a href="sql.htm#drop-table"><code>DROP TABLE</code></a> или
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>.
Для окружающей среды сервера является самым уместным, что все устройства
хранения данных посвящены данным MySQL. Поскольку системное табличное
пространство никогда не сжимается и совместно использовано всеми базами
данных, избегайте загружать огромное количество временных данных, если
<code>innodb_file_per_table=OFF</code>. Настройте отдельный экземпляр в таких
случаях, чтобы Вы могли удалить весь экземпляр, чтобы восстановить место.</p>

<p><code>innodb_file_per_table</code> включен по умолчанию. Рассмотрите
отключение этого, если обратная совместимость с MySQL 5.5 или ранее является
важной. Это не даст
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> переместить
таблицы из системного табличного пространства.</p>

<p><a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> является динамичным и может быть установлен
в <code>ON</code> или <code>OFF</code> через <code>SET GLOBAL</code>.
Вы можете также установить эти параметры в
<a href="glossary.htm#glos_configuration_file">конфигурационном файле</a>
MySQL (<code>my.cnf</code> или <code>my.ini</code>), но это требует
закрытия и перезапуска сервера.</p>

<p>Динамическое изменение значения этого параметра требует
привилегии <code>SUPER</code> и немедленно затрагивает
работу всех соединений.</p>

<p><a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per-table</code></a> не затрагивает создание временных таблиц.
Все временные таблицы составлены в совместно используемом
временном табличном пространстве.</li>

<li><a name="sysvar_innodb_fill_factor"></a><code>innodb_fill_factor</code>
</p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_fill_factor=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_fill_factor">innodb_fill_factor</a></code>
</td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>10</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr></tbody></table>

<p><code>InnoDB</code> выполняет оптовую загрузку, когда создает или
восстанавливает индекс. Этот метод известен как
<span><span>создание сортированного индекса</span></span>.</p>

<p><code>innodb_fill_factor</code> определяет процент пространства на каждой
странице B-дерева, которая заполнена во время создания сортированного
индекса, с остающимся пространством, сохраненным для будущего роста индекса.
Например, установка <code>innodb_fill_factor</code> в 80 резервирует 20%
пространства на каждой странице B-дерева для будущего роста индекса.
Фактические проценты могут измениться. <code>innodb_fill_factor</code>
интерпретируется как подсказка, а не жесткий предел.</p>

<p><a href="#sysvar_innodb_fill_factor"><code>innodb_fill_factor
</code></a> определяет 100 листьев 1/16 пространства в кластеризируемых
индексных страницах, свободных для будущего роста индекса.</p>

<p><code>innodb_fill_factor</code> относится к страницам листа и нелиста
B-дерева. Это не относится к внешним страницам, используемым для
<a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>.</p>
<p>См. <a href="#sorted-index-builds">раздел 16.8.11</a>.</li>

<li><a name="sysvar_innodb_flush_log_at_timeout"></a>
<code>innodb_flush_log_at_timeout</code></p>
<table summary="Options for innodb_flush_log_at_timeout" border="1">
<tbody><tr><td rowspan="3"><span><strong>Системная переменная</strong></span>
</td><td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_flush_log_at_timeout">
innodb_flush_log_at_timeout</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2700</code></td></tr></tbody></table>

<p>Записать и сбросить журналы каждые <em><code>N</code></em> секунд.
<a href="#sysvar_innodb_flush_log_at_timeout"><code>
innodb_flush_log_at_timeout</code></a> позволяет периоду тайм-аута между
потоками быть увеличенным, чтобы уменьшить сброс и избежать падения
производительности групповых записей в двоичный журнал.
Настройка по умолчанию для
<a href="#sysvar_innodb_flush_log_at_timeout"><code>
innodb_flush_log_at_timeout</code></a> однажды в секунду.</li>

<li><a name="sysvar_innodb_flush_log_at_trx_commit"></a>
<code>innodb_flush_log_at_trx_commit</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_flush_log_at_trx_commit[=#]</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_flush_log_at_trx_commit">
innodb_flush_log_at_trx_commit</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="5"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td rowspan="3" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>0</code></td></tr>
<tr><td colspan="2"><code>1</code></td></tr>
<tr><td colspan="2"><code>2</code></td></tr></tbody></table>

<p>Управляет балансом между строгой совместимостью с
<a href="glossary.htm#glos_acid">ACID</a> для
<a href="glossary.htm#glos_commit">commit</a> и
и более высокой производительностью, которая возможна, когда передача
связанных операций ввода/вывода перестроена и сделана в пакетах. Вы можете
достигнуть лучшей производительности, изменяя значение по умолчанию, но тогда
Вы можете потерять до секунды транзакций в катастрофическом отказе.</p>

<ul><li><p>Значение по умолчанию 1 требуется для полного соответствия ACID.
С этим значением содержимое
<a href="glossary.htm#glos_log_buffer">буфера журнала</a> записано в
<a href="glossary.htm#glos_log_file">файл системного журнала</a>
в каждой передаче транзакции, и файл системного журнала
<a href="glossary.htm#glos_flush">сброшен</a> на диск.</li>

<li>Со значением 0 содержание буфера журнала записано в файл
приблизительно однажды в секунду, и файл системного журнала сбрасывается на
диск. Ежесекундный сброс не составляет 100% гарантию, что сброс
будет происходить каждую секунду, есть проблемы планирования.
Поскольку сброс на диск происходит приблизительно однажды в секунду, Вы
можете потерять до секунды транзакций с любым катастрофическим отказом
процесса <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span>
</a>.</li>

<li>Со значением 2 содержание буфера журнала записано в файл
после того, как каждая транзакция передается, и файл системного журнала
сбрасывается на диск приблизительно однажды в секунду.
Ежесекундный сброс не составляет 100% гарантию, что сброс
будет происходить каждую секунду, есть проблемы планирования.
Поскольку сброс на диск происходит приблизительно однажды в секунду, Вы
можете потерять до секунды транзакций при катастрофическом
отказе операционной системы.</li>

<li>Частотой сброса журнала управляет
<a href="#sysvar_innodb_flush_log_at_timeout"><code>
innodb_flush_log_at_timeout</code></a>,
который позволяет Вам устанавливать частоту сброса журнала в
<em><code>N</code></em> секунд (где
<em><code>N</code></em> <code>1 ... 2700</code>, по умолчанию 1).
Однако, любой катастрофический отказ процесса
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
может стереть до <em><code>N</code></em> секунд транзакций.</li>

<li>DDL и другие внутренние изменения <code>InnoDB</code> вызывают сброс
журнала, независимый от <code>innodb_flush_log_at_trx_commit</code>.</li>
<li><a href="glossary.htm#glos_crash_recovery">Восстановление</a>
независимо от <code>innodb_flush_log_at_trx_commit</code>.
Транзакции или применены полностью или стерты полностью.</p></li></ul>

<p>Для длительности и последовательности в установке репликации, которая
использует <code>InnoDB</code> с транзакциями:</p>
<ul><li><p>Если двоичное журналирование включено, установите
<code>sync_binlog=1</code>.</li>
<li>Всегда установите <code>innodb_flush_log_at_trx_commit=1</code>.
</p></li></ul>

<p>Много операционных систем и некоторые дисковые аппаратные средства дурачат
работу потока. Они могут сказать
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>, что
сброс имел место, даже при том, что это не так. Тогда длительность транзакций
не гарантируется даже с установкой 1, и в худшем случае отключение
электричества может даже повредить данные <code>InnoDB</code>.
Использование поддержанного батареей дискового кэша в дисковом контроллере
SCSI или в самом диске делает работу более безопасной. Вы можете также
попытаться использовать команду Unix <span><strong>hdparm</strong></span>,
чтобы отключить кэширование диска или используйте некоторую другую команду,
определенную для аппаратных средств.</p></li>

<li><p><a name="sysvar_innodb_flush_method"></a>
<code>innodb_flush_method</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_flush_method=name</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_flush_method">innodb_flush_method</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="8"><span><strong>Допустимые значения</strong></span> (Unix)
</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>fsync</code></td></tr>
<tr><td rowspan="6" valign="top"><span><strong>Допустимые значения</strong>
</span></td>
<td colspan="2"><code>fsync</code></td></tr>
<tr><td colspan="2"><code>O_DSYNC</code></td></tr>
<tr><td colspan="2"><code>littlesync</code></td></tr>
<tr><td colspan="2"><code>nosync</code></td></tr>
<tr><td colspan="2"><code>O_DIRECT</code></td></tr>
<tr><td colspan="2"><code>O_DIRECT_NO_FSYNC</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(Windows)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>unbuffered</code></td></tr>
<tr><td rowspan="2" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>unbuffered</code></td></tr>
<tr><td colspan="2"><code>normal</code></td></tr></tbody></table>

<p>Определяет метод, используемый, чтобы
<a href="glossary.htm#glos_flush">сбросить</a> данные к
<a href="glossary.htm#glos_data_files">файлам с данными</a> и
<a href="glossary.htm#glos_log_file">файлам системного журнала</a>,
которые могут затронуть пропускную способность ввода/вывода.</p>

<p>В Unix-системах значение по умолчанию
<code>fsync</code>. В Windows <code>unbuffered</code>.</p>
<p>В MySQL 8.0 опции <a href="#sysvar_innodb_flush_method"><code>
innodb_flush_method</code></a> могут быть определены в цифровой форме.</p>

<p><code>innodb_flush_method</code> в Unix:</p>
<ul><li><p><code>fsync</code> или <code>0</code>: <code>InnoDB</code>
использует <code>fsync()</code>, чтобы сбросить данные и файлы системного
журнала. <code>fsync</code> настройка по умолчанию.</li>

<li><code>O_DSYNC</code> или <code>1</code>:
<code>InnoDB</code> использует <code>O_SYNC</code>, чтобы
открыть и сбросить файлы системного журнала, и
<code>fsync()</code>, чтобы сбросить файлы данных.
<code>InnoDB</code> не использует <code>O_DSYNC</code> непосредственно,
потому что были проблемы с этим на многих вариантах Unix.</li>

<li><code>littlesync</code> или <code>2</code>:
Эта опция используется для тестирования собственной производительности и в
настоящее время не поддерживается. Используйте на ваш собственный риск.</li>

<li><code>nosync</code> или <code>3</code>:
Эта опция используется для тестирования собственной производительности и в
настоящее время не поддерживается. Используйте на ваш собственный риск.</li>

<li><code>O_DIRECT</code> или <code>4</code>:
<code>InnoDB</code> использует <code>O_DIRECT</code>
(или <code>directio()</code> в Solaris), чтобы открыть файлы данных, и
<code>fsync()</code>, чтобы сбросить данные и файлы системного журнала.
Эта опция доступна на некоторых версиях GNU/Linux, FreeBSD и Solaris.</li>

<li><code>O_DIRECT_NO_FSYNC</code> или <code>5</code>:
<code>InnoDB</code> использует <code>O_DIRECT</code>
во время ввода/вывода, но пропускает <code>fsync()</code> позже.
Эта установка является подходящей для некоторых типов файловых систем, но не
других. Например, это не является подходящим для XFS. Если Вы не уверены,
требует ли файловая система, которую Вы используете, <code>fsync()</code>,
например, чтобы сохранить все метаданные о файле,
надо использовать <code>O_DIRECT</code>.</p></li></ul>

<p><code>innodb_flush_method</code> в Windows:</p>
<ul><li><p><code>unbuffered</code> или <code>0</code>:
<code>InnoDB</code> использует моделируемый асинхронный ввод/вывод и
небуферизованный ввод/вывод.</li>

<li><code>normal</code> или <code>1</code>:
<code>InnoDB</code> моделируемый асинхронный ввод/вывод и
буферизованный ввод/вывод.</p></li></ul>

<p>То, как каждая настройка затрагивают работу, зависит от конфигурации
аппаратных средств и рабочей нагрузки. Определите эффективность своей особой
конфигурации, чтобы решить, которую установку использовать или сохранить
настройку по умолчанию. Исследуйте
<a href="server.htm#statvar_Innodb_data_fsyncs"><code>Innodb_data_fsyncs
</code></a>, чтобы видеть общее количество <code>fsync()</code> для
каждой установки. Соединение чтения и записи в Вашей рабочей нагрузке может
затронуть, как установка работает. Например, на системе с контроллером
RAID и поддержанным батареей кэшем
<code>O_DIRECT</code> может помочь избежать двойной буферизации между
буферным пулом <code>InnoDB</code> и кэшем файловой системы операционной
системы. На некоторых системах, где данные и файлы системного журнала
расположены на SAN, значении по умолчанию или <code>O_DSYNC</code>
могло бы быть быстрее для нагруженной чтением рабочей нагрузки с главным
образом запросами <code>SELECT</code>. Всегда проверяйте этот параметр с
аппаратными средствами и рабочей нагрузкой, которые отражают Вашу
производственную среду. Для общих советов о настройке ввода/вывода см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</li>

<li><a name="sysvar_innodb_flush_neighbors"></a>
<code>innodb_flush_neighbors</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_flush_neighbors</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_flush_neighbors">innodb_flush_neighbors</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="5"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td rowspan="3" valign="top"><span><strong>Допустимые значения</strong>
</span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td colspan="2"><code>1</code></td></tr>
<tr><td colspan="2"><code>2</code></td></tr></tbody></table>

<p>Определяет <a href="glossary.htm#glos_flush">сброс</a> страниц из
<a href="glossary.htm#glos_buffer_pool">буферного пула</a> и другие
<a href="glossary.htm#glos_dirty_page">грязные страницы</a> в том же самом
<a href="glossary.htm#glos_extent">экстенте</a>.</p>

<ul><li><p>Значение по умолчанию 1 сбрасывает грязные страницы в том же самом
экстенте из буферного пула.</li>
<li>Установка 0 выключает <code>innodb_flush_neighbors</code>
и никакие другие грязные страницы из буферного пула не сбрасываются.</li>
<li>Установка 2 сбрасывает грязные страницы в том же самом экстенте
из буферного пула.</p></li></ul>

<p>Когда табличные данные хранятся на традиционном устройстве хранения данных
<a href="glossary.htm#glos_hdd">HDD</a>, сброс
such <a href="glossary.htm#glos_neighbor_page">соседних страниц</a>
в одной работе уменьшает ввод/вывод (прежде всего для операций поиска)
по сравнению со сбросом отдельных страниц в разное время. Для табличных
данных, хранимых на <a href="glossary.htm#glos_ssd">SSD</a>,
время поиска не значимый фактор, и Вы можете выключить эту установку.
Для общих советов о настройке ввода/вывода см.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</li>

<li><a name="sysvar_innodb_flush_sync"></a><code>innodb_flush_sync</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_flush_sync=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_flush_sync">innodb_flush_sync</a></code>
</td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p><code>innodb_flush_sync</code> включен по умолчанию, вызывает установку
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>, которая будет проигнорирована для взрывов деятельности
ввода/вывода, которые происходят в
<a href="glossary.htm#glos_checkpoint">контрольных точках</a>. Чтобы
придерживаться предела на фоновую деятельность ввода/вывода, определенного
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>, выключите <code>innodb_flush_sync</code>.</li>

<li><a name="sysvar_innodb_flushing_avg_loops"></a>
<code>innodb_flushing_avg_loops</code></p>
<table summary="Options for innodb_flushing_avg_loops" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_flushing_avg_loops=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_flushing_avg_loops">
innodb_flushing_avg_loops</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>30</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000</code></td></tr></tbody></table>

<p>Число итераций, для которых InnoDB сохраняет ранее расчетный образ
состояния сброса, управляя, как быстро
quickly <a href="glossary.htm#glos_adaptive_flushing">адаптивный сброс</a>
отвечает на изменяющуюся <a href="glossary.htm#glos_workload">нагрузку</a>.
Увеличение значения заставляет уровень операций
<a href="glossary.htm#glos_flush">сброса</a>
измениться гладко и постепенно, как рабочая нагрузка изменяется. Уменьшение
значения заставляет адаптивный сброс корректироваться быстро к изменениям
рабочей нагрузки, что может вызвать пики сброса,
если увеличения и уменьшения рабочей нагрузки внезапны.</li>

<li><a name="sysvar_innodb_force_load_corrupted"></a>
<a href="#sysvar_innodb_force_load_corrupted">
<code>innodb_force_load_corrupted</code></a></p>

<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_force_load_corrupted</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_force_load_corrupted">
innodb_force_load_corrupted</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Позволяет InnoDB загружать таблицы при запуске, которые отмечены как
поврежденные. Используйте только во время поиска неисправностей, чтобы
возвратить данные, которые иначе недоступны. Когда поиск неисправностей
выполнен, выключите это и перезапустите сервер.</li>

<li><a name="sysvar_innodb_force_recovery"></a>
<code>innodb_force_recovery</code></p>
<table summary="Options for innodb_force_recovery" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_force_recovery=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_force_recovery">
innodb_force_recovery</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>6</code></td></tr></tbody></table>

<p>Режим <a href="glossary.htm#glos_crash_recovery">восстановления
катастрофического отказа</a>, измененный в серьезных ситуациях с поиском
неисправностей. Возможные значения от 0 до 6. Для смысла этих значений и
важной информации о <code>innodb_force_recovery</code> см.
<a href="#forcing-innodb-recovery">раздел 16.20.2</a>.</p>

<p>Установите эту переменную в значение больше 0 в чрезвычайной ситуации,
чтобы Вы могли запустить <code>InnoDB</code> и выведите свои таблицы в дамп.
Как мера по безопасности, <code>InnoDB</code> запрещает
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>, когда
<code>innodb_force_recovery</code> больше 0. Установка
<code>innodb_force_recovery</code> в 4 или больше
переводит <code>InnoDB</code> в режим только для чтения.</p>

<p>Эти ограничения могут заставить такие команды управления репликацией, как
<a href="replica.htm#option_mysqld_relay-log-info-repository"><code>
--relay-log-info-repository=TABLE</code></a> и
<a href="replica.htm#option_mysqld_master-info-repository"><code>
--master-info-repository=TABLE</code></a> терпеть неудачу с ошибкой
сохранения информации в таблицах <code>InnoDB</code>.</p></li>

<li><p><a name="sysvar_innodb_ft_aux_table"></a>
<a href="#sysvar_innodb_ft_aux_table">
<code>innodb_ft_aux_table</code></a></p>

<table summary="Options for innodb_ft_aux_table" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_aux_table=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_aux_table">
innodb_ft_aux_table</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr></tbody></table>

<p>Определяет полностью определенное имя таблицы, содержащей индекс
<code>FULLTEXT</code>. Эта переменная предназначена в диагностических целях.
</p>
<p>После того, как Вы устанавливаете эту переменную в имя в формате
<code><em><code>db_name</code></em>/<em><code>table_name</code></em></code>,
таблицы <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-ft-index-table-table"><code>INNODB_FT_INDEX_TABLE
</code></a>, <a href="inform.htm#innodb-ft-index-cache-table"><code>
INNODB_FT_INDEX_CACHE</code></a>,
<a href="inform.htm#innodb-ft-config-table"><code>INNODB_FT_CONFIG</code>
</a>, <a href="inform.htm#innodb-ft-deleted-table"><code>INNODB_FT_DELETED
</code></a> и <a href="inform.htm#innodb-ft-being-deleted-table"><code>
INNODB_FT_BEING_DELETED</code></a>
покажет информацию о поисковом индексе для указанной таблицы.</li>

<li><a name="sysvar_innodb_ft_cache_size"></a>
<a href="#sysvar_innodb_ft_cache_size">
<code>innodb_ft_cache_size</code></a></p>

<table summary="Options for innodb_ft_cache_size" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_cache_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_cache_size">
innodb_ft_cache_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8000000</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1600000</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>80000000</code></td></tr></tbody></table>

<p>Выделенная память в байтах для кэша <code>FULLTEXT</code>, который держит
разобранный документ в памяти, создавая индекс <code>FULLTEXT</code>.
Вставки и обновления сохранены на диск, когда предел размера
<code>innodb_ft_cache_size</code> исчерпан. <code>innodb_ft_cache_size</code>
определяет размер кэша на таблицу. Чтобы установить глобальный предел для
всех таблиц см. <a href="#sysvar_innodb_ft_total_cache_size"><code>
innodb_ft_total_cache_size</code></a>.</li>

<li><a name="sysvar_innodb_ft_enable_diag_print"></a>
<a href="#sysvar_innodb_ft_enable_diag_print"><code>
innodb_ft_enable_diag_print</code></a></p>

<table summary="Options for innodb_ft_enable_diag_print" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_enable_diag_print=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_enable_diag_print">
innodb_ft_enable_diag_print</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включить ли дополнительный диагностический вывод полнотекстового поиска.
Эта опция прежде всего предназначена для усовершенствованной отладки FTS
и не будет представлять интерес для большинства пользователей. Вывод
напечатан в журнал ошибок и включает такую информацию, как:</p>

<ul><li><p>Ход синхронизации индекса FTS (когда предел кэша
FTS достигнут). Например:
<pre>
FTS SYNC for table test, deleted count: 100 size: 10000 bytes
SYNC words: 100
</pre></li>

<li>Ход оптимизации FTS:
<pre>
FTS start optimize test
FTS_OPTIMIZE: optimize "mysql"
FTS_OPTIMIZE: processed "mysql"
</pre></li>

<li>Ход создания индекса FTS:
<pre>
Number of doc processed: 1000
</pre></li>

<li>Для запросов FTS дерево парсинга запроса, вес слова, время обработки
запроса и использование памяти напечатано. Например:
<pre>
FTS Search Processing time: 1 secs: 100 millisec: row(s) 10000
Full Search Memory: 245678 (bytes),  Row: 10000
</pre></li></ul></li>

<li><p><a name="sysvar_innodb_ft_enable_stopword"></a>
<a href="#sysvar_innodb_ft_enable_stopword">
<code>innodb_ft_enable_stopword</code></a></p>

<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_enable_stopword=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_enable_stopword">
innodb_ft_enable_stopword</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Определяет ряд <a href="glossary.htm#glos_stopword">стоп-слов</a>,
связанный с индексом <code>InnoDB</code> <code>FULLTEXT</code>, когда индекс
создается. Если <a href="#sysvar_innodb_ft_user_stopword_table">
<code>innodb_ft_user_stopword_table</code></a> установлена, стоп-слова
взяты от той таблицы. Иначе если
<a href="#sysvar_innodb_ft_server_stopword_table">
<code>innodb_ft_server_stopword_table</code></a>
установлена, стоп-слова взяты от той таблицы. Иначе используется встроенный
набор стоп-слов по умолчанию.</li>

<li><a name="sysvar_innodb_ft_max_token_size"></a>
<a href="#sysvar_innodb_ft_max_token_size">
<code>innodb_ft_max_token_size</code></a></p>

<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_max_token_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_max_token_size">
innodb_ft_max_token_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>84</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>10</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>84</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>84</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>10</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>84</code></td></tr></tbody></table>

<p>Максимальная символьная длина слов, которые сохранены в индексе InnoDB
<code>FULLTEXT</code>. Установка предела для этого значения уменьшает размер
индекса, таким образом ускоряя запросы, опуская долгие ключевые слова или
произвольные наборы символов, которые не являются реальными словами и вряд ли
будут критериями поиска.</li>

<li><a name="sysvar_innodb_ft_min_token_size"></a>
<a href="#sysvar_innodb_ft_min_token_size">
<code>innodb_ft_min_token_size</code></a></p>

<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_min_token_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_min_token_size">
innodb_ft_min_token_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>3</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>16</code></td></tr></tbody></table>

<p>Минимальная длина слов, которые сохранены в индексе InnoDB
<code>FULLTEXT</code>. Увеличение этого значения уменьшает размер индекса,
таким образом ускоряя запросы, опуская общее слово, которые вряд ли будут
существенными в контексте поиска, такие как английские слова
<span><span>a</span></span> и <span><span>to</span></span>. Для контента,
использующего набор символов CJK
(Chinese, Japanese, Korean), определяют значение 1.</li>

<li><a name="sysvar_innodb_ft_num_word_optimize"></a>
<a href="#sysvar_innodb_ft_num_word_optimize">
<code>innodb_ft_num_word_optimize</code></a></p>

<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_num_word_optimize=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_num_word_optimize">
innodb_ft_num_word_optimize</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>2000</code></td></tr></tbody></table>

<p>Число слов, чтобы обработать во время каждого вызова
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a> для индекса
<code>InnoDB</code> <code>FULLTEXT</code>. Поскольку большая вставка или
обновление таблицы, содержащей полнотекстовый индекс может потребовать
существенное обслуживание индекса, чтобы включить все изменения, Вы могли бы
сделать серию <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code>
</a>, продолжающих работу друг друга.</li>

<li><a name="sysvar_innodb_ft_result_cache_limit"></a>
<a href="#sysvar_innodb_ft_result_cache_limit">
<code>innodb_ft_result_cache_limit</code></a></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_result_cache_limit=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_ft_result_cache_limit">
innodb_ft_result_cache_limit</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>2000000000</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1000000</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr></tbody></table>

<p><code>InnoDB</code> FULLTEXT search (FTS)
запрашивает предел кэша результата (определенный в байтах) на запрос FTS или
поток. Результаты запроса FTS обработаны в памяти. Используйте
<code>innodb_ft_result_cache_limit</code>, чтобы устанавливать границу
размера кэша результатов FTS, чтобы избежать чрезмерного потребления памяти в
случае очень большого результата запроса FTS (миллионы или сотни миллионов
строк, например). Память выделена как требуется, когда запрос FTS
обработан. Если предел размера кэша результата достигнут, ошибка возвращена,
указывая, что запрос превышает максимальную позволенную память.</p>
<p>Максимальное значение <code>innodb_ft_result_cache_limit</code> для всех
платформ 2**32-1. Bug #71554.</li>

<li><a name="sysvar_innodb_ft_server_stopword_table"></a>
<a href="#sysvar_innodb_ft_server_stopword_table">
<code>innodb_ft_server_stopword_table</code></a></p>

<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_server_stopword_table=db_name/table_name
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_ft_server_stopword_table">
innodb_ft_server_stopword_table</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>NULL</code></td></tr></tbody></table>

<p>Эта опция используется, чтобы определить Ваш собственный
список стоп-слов <code>FULLTEXT</code> для всех таблицы. Сконфигурировать
Ваш собственный список для определенной таблицы можно через
<a href="#sysvar_innodb_ft_user_stopword_table"><code>
innodb_ft_user_stopword_table</code></a>.</p>

<p>Установите <code>innodb_ft_server_stopword_table</code> в
название таблицы, содержащей список стоп-слов, в формате
<code><em><code>db_name</code></em>/<em><code>table_name</code></em></code>.
</p>

<p>Таблица должна существовать прежде, чем Вы сконфигурируете
<code>innodb_ft_server_stopword_table</code>.
<code>innodb_ft_enable_stopword</code> должен быть включен и
<code>innodb_ft_server_stopword_table</code> должна быть сконфигурирована
прежде, чем Вы создадите <code>FULLTEXT</code>.</p>

<p>Таблица должна быть таблицей <code>InnoDB</code> с одним столбцом
<code>VARCHAR</code> с именем <code>value</code>.</p>
<p>Подробности в <a href="funct.htm#fulltext-stopwords">разделе 13.9.4</a>.
</li>

<li><a name="sysvar_innodb_ft_sort_pll_degree"></a>
<a href="#sysvar_innodb_ft_sort_pll_degree"><code>
innodb_ft_sort_pll_degree</code></a></p>

<table summary="Options for innodb_ft_sort_pll_degree" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_sort_pll_degree=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_sort_pll_degree">
innodb_ft_sort_pll_degree</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>2</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>32</code></td></tr></tbody></table>

<p>Число потоков, чтобы параллельно индексировать и размечать текст в
индексе <code>FULLTEXT</code>, при создании
<a href="glossary.htm#glos_search_index">поискового индекса</a>. См.
<a href="#sysvar_innodb_sort_buffer_size"><code>
innodb_sort_buffer_size</code></a>.</li>

<li><a name="sysvar_innodb_ft_total_cache_size"></a>
<a href="#sysvar_innodb_ft_total_cache_size">
<code>innodb_ft_total_cache_size</code></a></p>

<table summary="Options for innodb_ft_total_cache_size" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_total_cache_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_ft_total_cache_size">
innodb_ft_total_cache_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>640000000</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>32000000</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1600000000</code></td></tr></tbody></table>

<p>Полная выделенная память в байтах для кэша поискового индекса FULLTEXT
для всех таблиц. Составление многочисленных таблиц, каждая с полнотекстовым
поисковым индексом, может потреблять существенную часть доступной памяти.
<a href="#sysvar_innodb_ft_total_cache_size"><code>
innodb_ft_total_cache_size</code></a> определяет глобальный предел памяти
для всего полнотекстового поиска, чтобы помочь избежать чрезмерного
потребления памяти. Если глобальный предел достигнут
вызвана принудительная синхронизация.</li>

<li><a name="sysvar_innodb_ft_user_stopword_table"></a>
<a href="#sysvar_innodb_ft_user_stopword_table"><code>
innodb_ft_user_stopword_table</code></a></p>

<table summary="Options for innodb_ft_user_stopword_table" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_ft_user_stopword_table=db_name/table_name
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_ft_user_stopword_table">
innodb_ft_user_stopword_table</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Global, Session</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>NULL</code></td></tr></tbody></table>

<p>Эта опция используется, чтобы определить Ваш список стоп-слов
<code>FULLTEXT</code> на определенной таблице. Сконфигурировать Ваш
собственный список для всех таблиц можно с помощью
<a href="#sysvar_innodb_ft_server_stopword_table"><code>
innodb_ft_server_stopword_table</code></a>.</p>

<p>Установите <code>innodb_ft_user_stopword_table</code> в
название таблицы, содержащей список стоп-слов, в формате
<code><em><code>db_name</code></em>/<em><code>table_name</code></em></code>.
</p>

<p>Таблица должна существовать прежде, чем Вы сконфигурируете
<code>innodb_ft_user_stopword_table</code>.
<code>innodb_ft_enable_stopword</code> должен быть включен и
<code>innodb_ft_user_stopword_table</code> должен быть сконфигурирован
прежде, чем Вы создадите индекс <code>FULLTEXT</code>.</p>

<p>Таблица должна быть таблицей <code>InnoDB</code> с одним столбцом
<code>VARCHAR</code> с именем <code>value</code>.</p>
См. <a href="funct.htm#fulltext-stopwords">раздел 13.9.4</a>.</li>

<li><a name="sysvar_innodb_io_capacity"></a>
<code>innodb_io_capacity</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_io_capacity=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_io_capacity">innodb_io_capacity</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(32-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>200</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>200</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**64-1</code></td></tr></tbody></table>

<p><a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> ставит верхний предел для деятельности ввода/вывода, выполненной
фоновыми задачами <code>InnoDB</code>, например,
<a href="glossary.htm#glos_flush">сбросом</a> страниц из
<a href="glossary.htm#glos_buffer_pool">буферного пула</a> и слиянием данных
из <a href="glossary.htm#glos_change_buffer">буфера изменений</a>.</p>

<p><a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> полный предел для всех экземпляров буферного пула. Когда грязные
страницы сбрасываются, предел разделен одинаково среди буферных экземпляров.
</p>

<p><a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a> должен быть установлен в приблизительно число операций
ввода/вывода, которые система может выполнить в секунду. Идеально сохранить
установку столь низкой, как возможно, но не настолько низкой, что фоновые
действия отстают. Если значение слишком высоко, данные удалены из буферного
пула и буфера вставок слишком быстро, чтобы кэшироваться и
обеспечить существенную выгоду.</p>

<p>Значение по умолчанию 200. Для занятых систем, способных к более высоким
уровням ввода/вывода, Вы можете установить более высокое значение, чтобы
помочь серверу обработать фоновую работу обслуживания, связанную с высоким
показателем изменений строки.</p>

<p>Вообще, Вы можете увеличить значение как функцию числа дисков,
используемых для ввода/вывода. Например, Вы можете увеличить значение на
системах, которые используют много дисков или диски (SSD).</p>

<p>Настройка по умолчанию 200 вообще достаточна для SSD более низкого уровня.
Для более высокого уровня bus-attached SSD считают более высокую установку,
например 1000. Для систем с отдельными дисками на 5400 RPM или 7200 RPM
Вы могли бы снизить значение до <code>100</code>, которое представляет
предполагаемую пропорцию операций в секунду ввода/вывода (IOPS), доступную
дисководам старшего поколения, которые могли
выполнить приблизительно 100 IOPS.</p>

<p>Хотя Вы можете определить очень высокое значение, например, миллион,
практически у таких больших значений мало пользы. Вообще, значение 20000 или
выше не рекомендуется, если Вы не доказали, что меньшие значения недостаточны
для Вашей рабочей нагрузки.</p>

<p>Рассмотрите рабочую нагрузку, настраивая
<a href="#sysvar_innodb_io_capacity"><code>
innodb_io_capacity</code></a>. Системы с большими записями, вероятно,
извлекут выгоду из более высокой установки. Более низкая установка может быть
достаточной для систем с маленьким уровнем записи.</p>

<p>Вы можете установить <code>innodb_io_capacity</code> в 100
или больше до максимума, определенного
<a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a>.
<code>innodb_io_capacity</code> может быть установлен в файле опции MySQL
(<code>my.cnf</code> или <code>my.ini</code>)
или изменен динамически использованием <code>SET GLOBAL</code>, что
требует привилегии <code>SUPER</code>.</p>

<p><a href="#sysvar_innodb_flush_sync"><code>innodb_flush_sync
</code></a> вызывает установку <a href="#sysvar_innodb_io_capacity">
<code>innodb_io_capacity</code></a>, которая будет проигнорирована во время
взрывов деятельности ввода/вывода, которые происходят в контрольных точках.
<a href="#sysvar_innodb_flush_sync"><code>innodb_flush_sync</code>
</a> включен по умолчанию.</p>
<p>См. <a href="#innodb-performance-thread_io_rate">раздел 16.6.7
</a>.</li>

<li><a name="sysvar_innodb_io_capacity_max"></a>
<code>innodb_io_capacity_max</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_io_capacity_max=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_io_capacity_max">innodb_io_capacity_max</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(32-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>see description</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(Unix, 64-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>См. описание</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**64-1</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(Windows, 64-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>См. описание</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr></tbody></table>

<p>Если сброс отстает, <code>InnoDB</code> может начать сбрасывать
более настойчиво чем предел, наложенный
<a href="#sysvar_innodb_io_capacity"><code>
innodb_io_capacity</code></a>.
<code>innodb_io_capacity_max</code> определяет верхний предел
ввода/вывода в таких ситуациях.</p>

<p><a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a> это полный предел для
всех буферных экземпляров.</p>

<p>Если Вы определяете <a href="#sysvar_innodb_io_capacity"><code>
innodb_io_capacity</code></a> при запуске, но не определяете значение для
<code>innodb_io_capacity_max</code>, <code>innodb_io_capacity_max</code>
по умолчанию дважды значение <a href="#sysvar_innodb_io_capacity">
<code>innodb_io_capacity</code></a>, но минимум 2000.</p>

<p>Конфигурируя <code>innodb_io_capacity_max</code>, дважды
<a href="#sysvar_innodb_io_capacity"><code>
innodb_io_capacity</code></a> часто хорошая начальная точка. Значение по
умолчанию 2000 предназначено для рабочих нагрузок, которые используют диск
SSD или больше, чем один обычный диск. Установка 2000, вероятно, слишком
высока для рабочих нагрузок, которые не используют SSD или много дисков, и
могли позволить слишком большой сброс. Для единственного диска рекомендуется
установка между 200 и 400. Для bus-attached SSD ставьте более высокую
установку, около 2500. Как с <a href="#sysvar_innodb_io_capacity">
<code>innodb_io_capacity</code></a>, сохраните установку столь низкой, как
можно, но не настолько низкой, чтобы <code>InnoDB</code>
не может достаточно масштабироваться вне предела
<a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>, если это надо.</p>

<p>Рассмотрите рабочую нагрузку, настраивая
<code>innodb_io_capacity_max</code>. Системы с большой записью могут извлечь
выгоду из более высокой установки. Более низкая установка может быть
достаточной для систем с маленьким объемом записей.</p>

<p><a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a> не может быть установлен в значение ниже,
чем <a href="#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>.</p>

<p>Установка <a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a> в <code>DEFAULT</code> через
<a href="sql.htm#set-variable"><code>SET</code></a>
(<code>SET GLOBAL innodb_io_capacity_max=DEFAULT</code>) ставит
<a href="#sysvar_innodb_io_capacity_max"><code>
innodb_io_capacity_max</code></a> к максимальному значению.</p>
<p>См. <a href="#innodb-lru-background-flushing">раздел 16.6.3.7
</a>.</li>

<li><a name="sysvar_innodb_limit_optimistic_insert_debug"></a>
<code>innodb_limit_optimistic_insert_debug</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_limit_optimistic_insert_debug=#</code>
</td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_limit_optimistic_insert_debug">
innodb_limit_optimistic_insert_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr></tbody></table>

<p>Ограничивает число записей на страницу
<a href="glossary.htm#glos_b_tree">B-tree</a>.
Значение по умолчанию 0 указывает, что никакой предел не наложен. Эта опция
доступна только если поддержка отладки собрана с использованием
<a href="install.htm#option_cmake_with_debug"><code>WITH_DEBUG</code></a> в
<span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_lock_wait_timeout"></a>
<code>innodb_lock_wait_timeout</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_lock_wait_timeout=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_lock_wait_timeout">
innodb_lock_wait_timeout</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Global, Session</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>50</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr></tbody></table>

<p>Отрезок времени в секундах, который
<a href="glossary.htm#glos_transaction">транзакция</a> ждет
a <a href="glossary.htm#glos_row_lock">блокировки строки</a>
перед отказом. Значение по умолчанию составляет 50 секунд. Транзакция,
которая пытается получить доступ к строке, которая заблокирована другой
транзакция ждет самое большее это число секунд для доступ к строке прежде,
чем выпустить следующую ошибку:
<pre>
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</pre>

<p>Когда блокировка ждет и тайм-аут происходит, текущий запрос
<a href="glossary.htm#glos_rollback">откатывается</a> (не вся транзакция!).
Чтобы вся транзакция откатывалась до прежнего уровня, запускайте сервер с
<a href="#sysvar_innodb_rollback_on_timeout"><code>
--innodb_rollback_on_timeout</code></a>. См.
<a href="#innodb-error-handling">раздел 16.20.4</a>.</p>

<p>Вы могли бы уменьшить это значение для очень интерактивных приложений или
систем <a href="glossary.htm#glos_oltp">OLTP</a>, чтобы вывести на экран
пользовательскую обратную связь быстро или поместить обновление в очередь для
того, чтобы обработать позже. Вы могли бы увеличить это значение для
продолжительных операций, таких как шаг преобразования в хранилище данных,
которые ждут большой вставки или операций обновления, чтобы закончиться.</p>

<p><code>innodb_lock_wait_timeout</code> относится только к строковой
блокировке. <a href="glossary.htm#glos_table_lock">Табличная блокировка</a>
MySQL не происходит внутри <code>InnoDB</code>
и этот тайм-аут не относится к ожиданию табличных блокировок.</p>

<p>Значение тайм-аута не относится к
<a href="glossary.htm#glos_deadlock">тупикам</a>, когда
<a href="#sysvar_innodb_deadlock_detect"><code>
innodb_deadlock_detect</code></a> включен (значение по умолчанию) потому, что
<code>InnoDB</code> обнаруживает тупики и откатывает одну
из заведенных в тупик транзакций. Когда
<a href="#sysvar_innodb_deadlock_detect"><code>
innodb_deadlock_detect</code></a> включен, <code>InnoDB</code>
полагается на <a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a> для операционной отмены,
когда тупик происходит.</p>

<p><a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a> может быть установлен во время выполнения
с помощью <code>SET GLOBAL</code> или <code>SET SESSION</code>. Изменение
<code>GLOBAL</code> требует привилегии <code>SUPER</code> и влияет на
работу всех клиентов, которые впоследствии соединяются. Любой клиент может
изменить <code>SESSION</code> для
<a href="#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a>, который затрагивает только того клиента.
</li>

<li><a name="sysvar_innodb_log_buffer_size"></a>
<code>innodb_log_buffer_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_log_buffer_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_log_buffer_size">
innodb_log_buffer_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>16777216</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Размер в байтах буфера для записи на диск
<a href="glossary.htm#glos_log_file">файлов системного журнала</a>.
Значение по умолчанию составляет 16 МБ. Большой
<a href="glossary.htm#glos_log_buffer">буфер журнала</a>
позволяет большим <a href="glossary.htm#glos_transaction">транзакциям</a>
работать без потребности писать журнал на диск прежде, чем транзакция
transactions <a href="glossary.htm#glos_commit">завершится</a>.
Таким образом, если у Вас есть транзакции, которые обновляют, вставляют или
удаляют много строк, увеличение журнала сохраняет дисковый ввод/вывод. См.
<a href="optimiz.htm#optimizing-innodb-diskio">раздел 9.5.8</a>.</li>

<li><a name="sysvar_innodb_log_checksums"></a>
<code>innodb_log_checksums</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_log_checksums=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_log_checksums">
innodb_log_checksums</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Включает или отключает контрольные суммы для страницы журнала redo.
<code>innodb_log_checksums=ON</code> включает алгоритм <code>CRC-32C</code>
контрольной суммы для страницы журнала redo. Когда
<code>innodb_log_checksums</code> отключен, содержание области контрольной
суммы страницы журнала проигнорировано.</p>
<p>Контрольные суммы на заголовке страницы журнала и
странице контрольной точки журнала никогда не отключаются.</li>

<li><a name="sysvar_innodb_log_compressed_pages"></a>
<code>innodb_log_compressed_pages</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_log_compressed_pages=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_log_compressed_pages">
innodb_log_compressed_pages</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Определяет, записаны ли образы
<a href="glossary.htm#glos_compression">пересжатых страниц</a>
в <a href="glossary.htm#glos_redo_log">журнал redo</a>.
Пересжатие может произойти, когда изменения произведены в сжатых данных.</p>

<p><code>innodb_log_compressed_pages</code> включен по умолчанию, чтобы
предотвратить повреждение, которое могло произойти, если иная версия
алгоритма сжатия <code>zlib</code> используется во время восстановления.
Если Вы уверены, что версия <code>zlib</code> не будет изменяться, Вы можете
отключить <code>innodb_log_compressed_pages</code>, чтобы уменьшить
журнал для рабочих нагрузок, которые изменяют сжатые данные.</p>

<p>Измерить эффект включения или отключения
<code>innodb_log_compressed_pages</code> можно, сравнивая генерацию журнала
redo для обеих настроек при той же самой рабочей нагрузке.
Это включает наблюдение за <code>Log sequence number</code> (LSN) в разделе
<code>LOG</code> вывода <a href="sql.htm#show-engine"><code>SHOW ENGINE
INNODB STATUS</code></a> или мониторинг
<a href="server.htm#statvar_Innodb_os_log_written"><code>
Innodb_os_log_written</code></a> для числа байтов, написанных
в файлы журнала redo.</li>

<li><a name="sysvar_innodb_log_file_size"></a>
<code>innodb_log_file_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_log_file_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_log_file_size">
innodb_log_file_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>50331648</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4194304</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>512GB / innodb_log_files_in_group</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>5242880</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Размер в байтах каждого <a href="glossary.htm#glos_log_file">
файла системного журнала</a> в <a href="glossary.htm#glos_log_group">
группе журнала</a>. Объединенный размер файлов системного журнала
(<code>innodb_log_file_size</code>*
<a href="#sysvar_innodb_log_files_in_group"><code>
innodb_log_files_in_group</code></a>) не может превысить максимальное
значение, которое является немного меньше 512 ГБ. Пара файлов по 255 GB
, например, позволила бы Вам приближаться к пределу, но не превышать его.
Значение по умолчанию составляет 48 МБ. Заметные значения колеблются от 4 МБ
до 1/<em><code>N</code></em> размера <a href="glossary.htm#glos_buffer_pool">
буферного пула</a>, где <em><code>N</code></em> число файлов системного
журнала в группе. Чем больше значение, тем меньше деятельности потока
контрольной точки необходимо в буферном пуле, сохраняя дисковый ввод/вывод.
Большие файлы системного журнала также делают
<a href="glossary.htm#glos_crash_recovery">восстановление катастрофического
отказа</a> медленнее, хотя усовершенствования работы восстановления в MySQL
5.5 и выше делают размер файла системного журнала меньше.</p>
<p>Минимум <code>innodb_log_file_size</code> увеличен с 1MB до 4MB в MySQL
8.0.</li>

<li><a name="sysvar_innodb_log_files_in_group"></a>
<code>innodb_log_files_in_group</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_log_files_in_group=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_log_files_in_group">
innodb_log_files_in_group</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>2</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>2</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr></tbody></table>

<p>Число <a href="glossary.htm#glos_log_file">файлов системного журнала</a>
в <a href="glossary.htm#glos_log_group">группе журнала</a>.
<code>InnoDB</code> пишет файлы круговым способом. Значение по умолчанию (и
рекомендуемое) значение 2. Местоположение этих файлов определено
<a href="#sysvar_innodb_log_group_home_dir"><code>
innodb_log_group_home_dir</code></a>. Объединенный размер файлов системного
журнала (<a href="#sysvar_innodb_log_file_size"><code>
innodb_log_file_size</code></a>*<code>innodb_log_files_in_group</code>)
может быть до 512 ГБ.</li>

<li><a name="sysvar_innodb_log_group_home_dir"></a>
<code>innodb_log_group_home_dir</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_log_group_home_dir=dir_name</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_log_group_home_dir">
innodb_log_group_home_dir</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>directory name</code></td></tr></tbody></table>

<p>Путь к каталогу с файлами
<a href="glossary.htm#glos_redo_log">журнала redo</a>,
число которых определено
<a href="#sysvar_innodb_log_files_in_group"><code>
innodb_log_files_in_group</code></a>. Если Вы не определяете
переменные журнала, значение по умолчанию должно создать два файла
<code>ib_logfile0</code> и <code>ib_logfile1</code> в
каталоге данных MySQL. Их размер задан в
<a href="#sysvar_innodb_log_file_size">
<code>innodb_log_file_size</code></a>.</li>

<li><a name="sysvar_innodb_log_write_ahead_size"></a>
<code>innodb_log_write_ahead_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_log_write_ahead_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_log_write_ahead_size">
innodb_log_write_ahead_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8192</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>512 (log file block size)</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>Equal to innodb_page_size</code></td>
</tr></tbody></table>

<p>Размер блока для журнала redo в байтах. Чтобы избежать
avoid <span><span>чтения на записи</span></span>, установите
<code>innodb_log_write_ahead_size</code>, чтобы
соответствовать размеру блока кэша файловой системы. Чтение на записи
происходит, когда блоки журнала не полностью кэшируются файловой системой
из-за несоответствия написанным размером блока и размером
блока кэша файловой системы.</p>

<p>Минимальное значение размер блока файла системного журнала (512).
Предзапись не происходит, когда минимальное значение определено. Максимальное
значение равно <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a>. Если Вы определяете значение для
<code>innodb_log_write_ahead_size</code> больше
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>, <code>innodb_log_write_ahead_size</code> усечено к
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>.</p>

<p>Установка <code>innodb_log_write_ahead_size</code>
слишком низко относительно операционной системы или размера блока кэша
файловой системы приведет к <span><span>чтению на записи</span></span>.
Установка значения слишком высоким может оказать небольшое влияние на
производительность <code>fsync</code> для файла системного журнала из-за
нескольких блоков, написанных сразу.</li>

<li><a name="sysvar_innodb_lru_scan_depth"></a>
<code>innodb_lru_scan_depth</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_lru_scan_depth=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_lru_scan_depth">
innodb_lru_scan_depth</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(32-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(64-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**64-1</code></td></tr></tbody></table>

<p>Параметр, который влияет на алгоритмы и эвристику для работы
the <a href="glossary.htm#glos_flush">сброса</a>
<a href="glossary.htm#glos_buffer_pool">буферного пула</a>.
Прежде всего интересен для исполнительных экспертов, настраивающих рабочие
нагрузки. Это определяет для экземпляра буферного пула как далеко вниз
поток уборщика страницы просматривает список LRU, ища
<a href="glossary.htm#glos_dirty_page">грязные страницы</a>, чтобы
сбросить. Это фоновая работа, выполненная раз в секунду.</p>

<p>Установка, меньшая чем значение по умолчанию, является вообще подходящей
для большинства рабочих нагрузок. Значение, которое намного выше, чем
необходимо, может воздействовать на работу. Рассмотрите увеличение значения
только если у Вас есть запас ввода/вывода при типичной рабочей нагрузке.
Наоборот, если рабочая нагрузка насыщает Ваш ввод/вывод, уменьшите значение,
особенно в случае большого буферного пула.</p>

<p>Настраивая <code>innodb_lru_scan_depth</code>, начните с низкого
значения и сконфигурируйте установку с целью редкого наблюдения нулевых
свободных страниц. Кроме того, рассмотрите корректировку
<code>innodb_lru_scan_depth</code>, изменяя число буферных экземпляров.
<code>innodb_lru_scan_depth</code>*
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>
определяет объем работы, выполненный потоком уборщика
страницы каждую секунду.</p></li>

<li><a name="sysvar_innodb_max_dirty_pages_pct"></a>
<code>innodb_max_dirty_pages_pct</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_max_dirty_pages_pct=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_max_dirty_pages_pct">
innodb_max_dirty_pages_pct</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>numeric</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>75</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>99.99</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>numeric</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>90</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>100</code></td></tr></tbody></table>

<p><code>InnoDB</code> пытается <a href="glossary.htm#glos_flush">сбросить
</a> данные из <a href="glossary.htm#glos_buffer_pool">буферного пула</a>,
чтобы процент <a href="glossary.htm#glos_dirty_page">грязных страниц</a>
не превысил это значение. Значение по умолчанию 75.</p>

<p><a href="#sysvar_innodb_max_dirty_pages_pct">
<code>innodb_max_dirty_pages_pct</code></a> устанавливает цель для сброса.
Это не затрагивает уровень сброса. Для информации об управлении уровнем
сброса см. <a href="#innodb-performance-adaptive_flushing">раздел
16.6.3.6</a>.</p>
<p>Подробности в <a href="#innodb-lru-background-flushing">разделе
16.6.3.7</a>.</li>

<li><a name="sysvar_innodb_max_dirty_pages_pct_lwm"></a>
<code>innodb_max_dirty_pages_pct_lwm</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_max_dirty_pages_pct_lwm=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_max_dirty_pages_pct_lwm">
innodb_max_dirty_pages_pct_lwm</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>numeric</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>99.99</code></td></tr></tbody></table>

<p>Нижний процент <a href="glossary.htm#glos_dirty_page">грязных страниц
</a>, где предварительный сброс управляет коэффициентом грязных страниц.
Значение по умолчанию 0 отключает предварительный сброс полностью. Для
дополнительной информации об этой переменной см.
<a href="#innodb-lru-background-flushing">раздел 16.6.3.7</a>.</li>

<li><a name="sysvar_innodb_max_purge_lag"></a>
<code>innodb_max_purge_lag</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_max_purge_lag=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_max_purge_lag">
innodb_max_purge_lag</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Эта переменная управляет, как задержатся
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>, когда
<a href="glossary.htm#glos_purge">чистка</a> отстает (см.
<a href="#innodb-multi-versioning">раздел 16.3</a>).
Значение по умолчанию 0 (никаких задержек).</p>

<p>Система транзакций поддерживает список транзакций, которые имеют
индексные записи, помеченные для удаления,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>. Длина этого списка
представляет <em><code>purge_lag</code></em>. Когда
<em><code>purge_lag</code></em> превышает
<a href="#sysvar_innodb_max_purge_lag"><code>innodb_max_purge_lag
</code></a>, каждый запрос <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a> задержится.</p>

<p>Чтобы предотвратить чрезмерные задержки, где
<em><code>purge_lag</code></em> становится огромным, Вы можете поправить
количество задержки, устанавливая
<a href="#sysvar_innodb_max_purge_lag_delay"><code>
innodb_max_purge_lag_delay</code></a>.
Задержка вычислена в начале пакета чистки.</p>

<p>Типичная установка для проблематичной рабочей нагрузки могла бы быть 1
миллионом, предполагая, что транзакции являются маленькими, только 100 байтов
в размере, и допустимо иметь 100 МБ неочищенных строк таблиц.</p>

<p>Значение задержки выведено на экран как длина списка истории в разделе
<code>TRANSACTIONS</code> InnoDB Monitor.
Например, если вывод включает следующие строки, значение задержки 20:
<pre>
------------
TRANSACTIONS
------------
Trx id counter 0 290328385
Purge done for trx's n:o &lt; 0 290315608 undo n:o &lt; 0 17
History list length 20
</pre></li>

<li><a name="sysvar_innodb_max_purge_lag_delay"></a>
<code>innodb_max_purge_lag_delay</code></p>
<table summary="Options for innodb_max_purge_lag_delay" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_max_purge_lag_delay=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_max_purge_lag_delay">
innodb_max_purge_lag_delay</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="3"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr></tbody></table>

<p>Определяет максимальную задержку в миллисекундах для задержки, наложенной
<a href="#sysvar_innodb_max_purge_lag"><code>innodb_max_purge_lag
</code></a>. Любое ненулевое значение представляет верхний предел времени
задержки, вычисленном от формулы, основанной на значении
<code>innodb_max_purge_lag</code>. Значение по умолчанию 0 значит, что нет
никакого верхнего предела, наложенного на интервал задержки.</p></li>

<li><a name="sysvar_innodb_max_undo_log_size"></a>
<code>innodb_max_undo_log_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_max_undo_log_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_max_undo_log_size">
innodb_max_undo_log_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>10485760</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**64-1</code></td></tr></tbody></table>

<p><code>innodb_max_undo_log_size</code> определяет пороговый размер для
табличных пространств отмены. Если табличное пространство отмены превышает
порог, оно может быть отмечено для усечения, когда
<a href="#sysvar_innodb_undo_log_truncate"><code>
innodb_undo_log_truncate</code></a> включен. Значение по
умолчанию 1024 MiB (1073741824 байт).</p>
<p>См. <a href="#truncate-undo-tablespace">раздел 16.7.8</a>.</li>

<li><a name="sysvar_innodb_merge_threshold_set_all_debug"></a>
<code>innodb_merge_threshold_set_all_debug</code></p>
<table summary="Options for innodb_merge_threshold_set_all_debug" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_merge_threshold_set_all_debug=#</code>
</td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_merge_threshold_set_all_debug">
innodb_merge_threshold_set_all_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>50</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>50</code></td></tr></tbody></table>

<p>Переопределяет текущее значение <code>MERGE_THRESHOLD</code>
указанным значением для всех индексов, которые в настоящее время находятся в
кэше словаря. Эта опция доступна только, если поддержка отладки собрана с
использованием <a href="install.htm#option_cmake_with_debug"><code>WITH_DEBUG
</code></a> в <span><strong>CMake</strong></span>. См.
<a href="#index-page-merge-threshold">раздел 16.6.11</a>.</li>

<li><a name="sysvar_innodb_monitor_disable"></a>
<code>innodb_monitor_disable</code></p>
<table summary="Options for innodb_monitor_disable" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_monitor_disable=[counter|module|pattern|all]
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_innodb_monitor_disable">innodb_monitor_disable</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Выключает один или более
<a href="glossary.htm#glos_counter">счетчиков</a> в таблице
<a href="inform.htm#innodb-metrics-table"><code>
INFORMATION_SCHEMA.INNODB_METRICS</code></a>. См.
<a href="inform.htm#innodb-metrics-table">раздел 22.30.16</a>.</p>

<p><code>innodb_monitor_disable='latch'</code> отключает набор статистики для
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB MUTEX</code></a>. См.
<a href="sql.htm#show-engine">раздел 14.7.5.15</a>.</li>

<li><a name="sysvar_innodb_monitor_enable"></a>
<code>innodb_monitor_enable</code></p>
<table summary="Options for innodb_monitor_enable" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_monitor_enable=[counter|module|pattern|all]
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_monitor_enable">
innodb_monitor_enable</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr></tbody></table>

<p>Включает один или более
<a href="glossary.htm#glos_counter">счетчиков</a> в таблице
<a href="inform.htm#innodb-metrics-table"><code>
INFORMATION_SCHEMA.INNODB_METRICS</code></a>. См.
<a href="inform.htm#innodb-metrics-table">раздел 22.30.16</a>.</p>

<p><code>innodb_monitor_enable='latch'</code> включает набору статистики для
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB MUTEX</code></a>. См.
<a href="sql.htm#show-engine">раздел 14.7.5.15</a>.</li>

<li><a name="sysvar_innodb_monitor_reset"></a>
<code>innodb_monitor_reset</code></p>
<table summary="Options for innodb_monitor_reset" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_monitor_reset=[counter|module|pattern|all]
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_monitor_reset">
innodb_monitor_reset</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr></tbody></table>

<p>Сбрасывает в 0 значение для одного или более
<a href="glossary.htm#glos_counter">счетчиков</a> в таблице
<a href="inform.htm#innodb-metrics-table"><code>
INFORMATION_SCHEMA.INNODB_METRICS</code></a>. См.
<a href="inform.htm#innodb-metrics-table">раздел 22.30.16</a>.</p>

<p><code>innodb_monitor_reset='latch'</code> обнуляет статистику,
которую сообщает <a href="sql.htm#show-engine"><code>SHOW ENGINE
INNODB MUTEX</code></a>. См.
<a href="sql.htm#show-engine">раздел 14.7.5.15</a>.</li>

<li><a name="sysvar_innodb_monitor_reset_all"></a>
<code>innodb_monitor_reset_all</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_monitor_reset_all=[counter|module|pattern|all]
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_monitor_reset_all">
innodb_monitor_reset_all</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr></tbody></table>

<p>Сбрасывает все значения (минимум, максимум и так далее) для одного или
более <a href="glossary.htm#glos_counter">счетчиков</a> в таблице
<a href="inform.htm#innodb-metrics-table"><code>
INFORMATION_SCHEMA.INNODB_METRICS</code></a>. См.
<a href="inform.htm#innodb-metrics-table">раздел 22.30.16</a>.</li>

<li><a name="sysvar_innodb_numa_interleave"></a>
<code>innodb_numa_interleave</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_numa_interleave=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_numa_interleave">innodb_numa_interleave</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включает политику чередования памяти NUMA для распределения
буферного пула. Когда <code>innodb_numa_interleave</code>
включен, политика памяти NUMA установлена в <code>MPOL_INTERLEAVE</code>
для процесса <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a>. После того, как буферный пул выделен, политика памяти NUMA
возвращена к <code>MPOL_DEFAULT</code>. Для доступности опции
<code>innodb_numa_interleave</code> MySQL должен быть собран
на NUMA-системе.</li>

<li><a name="sysvar_innodb_old_blocks_pct"></a>
<code>innodb_old_blocks_pct</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_old_blocks_pct=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_old_blocks_pct">innodb_old_blocks_pct</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>37</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>5</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>95</code></td></tr></tbody></table>

<p>Определяет приблизительный процент
<a href="glossary.htm#glos_buffer_pool">буферного пула</a>, используемый для
<a href="glossary.htm#glos_sublist">подсписка</a> старых блоков.
Диапазон значений 5-95. Значение по умолчанию 37 (то есть, 3/8 пула). Часто
используется в комбинации с
<a href="#sysvar_innodb_old_blocks_time"><code>
innodb_old_blocks_time</code></a>. См. разделы
<a href="#innodb-performance-midpoint_insertion">16.6.3.4
</a> и <a href="#innodb-buffer-pool">16.6.3.1</a>.</li>

<li><a name="sysvar_innodb_old_blocks_time"></a>
<code>innodb_old_blocks_time</code></p>
<table summary="Options for innodb_old_blocks_time" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_old_blocks_time=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_old_blocks_time">
innodb_old_blocks_time</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1000</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr></tbody></table>

<p>Ненулевые значения защищают от заполнения
<a href="glossary.htm#glos_buffer_pool">буферного пула</a>
данными, на которые ссылаются только в течение краткого периода, как во время
<a href="glossary.htm#glos_full_table_scan">полного сканирования таблицы
</a>. Увеличение этого значения предлагает больше защиты от полного
сканирования таблицы, вмешивающегося в данные, кэшируемые в буферном пуле.
</p>

<p>Определяет, сколько времени в миллисекундах
блок, вставленный в <a href="glossary.htm#glos_sublist">подсписок</a>
старых, должен остаться там после первого доступа к нему прежде, чем
может быть перемещен в подсписок новых. Если значение 0, блок, вставленный в
подсписок старых, немедленно перемещается в подсписок новых, когда к нему
в первый раз получают доступ, независимо от того, как скоро после вставки
доступ происходит. Если значение больше 0, блоки остаются в старом подсписке,
пока доступ не происходит, по крайней мере указанное число миллисекунды
после первого доступа. Например, значение 1000 предписывает блокам остаться в
старом подсписке в течение 1 секунды после первого доступа прежде, чем они
смогут переместиться в новый подсписок.</p>

<p>Значение по умолчанию 1000.</p>
<p>Эта переменная часто используется в комбинации с
<a href="#sysvar_innodb_old_blocks_pct"><code>innodb_old_blocks_pct
</code></a>. См. разделы
<a href="#innodb-performance-midpoint_insertion">16.6.3.4</a> и
<a href="#innodb-buffer-pool">16.6.3.1</a>.</li>

<li><a name="sysvar_innodb_online_alter_log_max_size"></a>
<code>innodb_online_alter_log_max_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_online_alter_log_max_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_online_alter_log_max_size">
innodb_online_alter_log_max_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>134217728</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>65536</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**64-1</code></td></tr></tbody></table>

<p>Определяет верхний предел на размер временных файлов системного журнала,
используемых во время операций <a href="glossary.htm#glos_online_ddl">online
DDL</a>. Есть один такой файл системного журнала для каждого создаваемого
индекса или при изменении таблицы. Этот файл системного журнала хранит
данные, вставленные, обновленные или удаленные в таблице во время работы DDL.
Временный файл системного журнала расширен при необходимости значением
<a href="#sysvar_innodb_sort_buffer_size"><code>
innodb_sort_buffer_size</code></a>, до максимума, определенного
<code>innodb_online_alter_log_max_size</code>.
Если какой-либо временный файл системного журнала превышает верхний предел
размера, <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
терпит неудачу, и все нейтральные параллельные операции DML откачены. Таким
образом, большое значение для этой опции позволяет большему количеству DML
происходить во время работы DDL онлайн, но также и вызывает более длинный
период в конце работы DDL, когда таблица заблокирована,
чтобы применить данные журнала.</li>

<li><a name="sysvar_innodb_open_files"></a>
<code>innodb_open_files</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_open_files=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_open_files">
innodb_open_files</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>10</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Эта переменная релевантна, только если Вы используете много
<a href="glossary.htm#glos_tablespace">табличных пространств</a>.
Это определяет максимальное количество файлов
<a href="glossary.htm#glos_ibd_file"><code>.ibd</code></a>,
которые MySQL может сохранить открытыми одновременно. Минимальное
значение 10. Значение по умолчанию 300, если
<a href="#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a> не включен, иначе выше 300 и
<a href="server.htm#sysvar_table_open_cache"><code>table_open_cache</code>
</a>.</p>

<p>Описатели файла, используемые для <code>.ibd</code>, только для таблиц.
Они независимы от определенных
<a href="server.htm#option_mysqld_open-files-limit"><code>--open-files-limit
</code></a> и не затрагивают работу табличного кэша.</li>

<li><a name="sysvar_innodb_optimize_fulltext_only"></a>
<code>innodb_optimize_fulltext_only</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_optimize_fulltext_only=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_optimize_fulltext_only">
innodb_optimize_fulltext_only</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Изменяет путь, которым <a href="sql.htm#optimize-table"><code>OPTIMIZE
TABLE</code></a> воздействует на таблицы. Предназначен, чтобы быть включенным
временно, во время операций обслуживания для
таблиц с индексами <code>FULLTEXT</code>.</p>

<p>По умолчанию <code>OPTIMIZE TABLE</code> реорганизует данные в
<a href="glossary.htm#glos_clustered_index">кластеризируемом индексе</a>
таблицы. Когда эта опция включена, <code>OPTIMIZE TABLE</code>
пропускает эту перестройку табличных данных, а вместо этого обрабатывают
недавно добавленные, удаленные и обновленные маркерные данные для индекса
<code>FULLTEXT</code>. См. <a href="#innodb-fulltext-index">раздел
16.8.9</a>.</li>

<li><a name="sysvar_innodb_page_cleaners"></a>
<code>innodb_page_cleaners</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_page_cleaners=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_page_cleaners">
innodb_page_cleaners</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>4</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>64</code></td></tr></tbody></table>

<p>Число потоков уборщика страницы, которые сбрасывают грязные страницы от
буферных экземпляров. Потоки уборщика страницы выполняют сброс списка и LRU.
Значение по умолчанию 4. Если число потоков уборщика страницы превышает
число буферных экземпляров, <code>innodb_page_cleaners</code>
автоматически установлен в то же самое значение, как
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>.</p>

<p>Если Ваша рабочая нагрузка связана write-IO
(сбрасывая грязные страницы от буферных экземпляров в файлы с данными) и если
у Ваших системных аппаратных средств есть полезная мощность, увеличение числа
потоков уборщика страницы может помочь улучшить пропускную способность.</p>

<p>Мультипоточная поддержка уборщика страницы также расширена на фазы
восстановления и завершения работы.</p>
<p><code>setpriority()</code> применяется в Linux
(где он поддержан и где пользователь
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
авторизован), чтобы дать <code>page_cleaner</code>
приоритет над другими потоками MySQL/InnoDB, чтобы ускорить сброс страниц
с текущей рабочей нагрузкой. Пользователь для выполнения
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
может быть сконфигурирован в <code>/etc/security/limits.conf</code>.
Например, если if <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> выполнен под пользователем <code>mysql</code>,
Вы могли бы разрешить <code>mysql</code> добавляя строки, подобные следующим,
в <code>/etc/security/limits.conf</code>:
<pre>
mysqlhardnice   -20
mysqlsoftnice   -20
</pre></li>

<li><a name="sysvar_innodb_page_size"></a>
<code>innodb_page_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_page_size=#k</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_page_size">
innodb_page_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="12"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>16384</code></td></tr>
<tr><td rowspan="10" valign="top"><span><strong>Допустимые значения</strong>
</span></td>
<td colspan="2"><code>4k</code></td></tr>
<tr><td colspan="2"><code>8k</code></td></tr>
<tr><td colspan="2"><code>16k</code></td></tr>
<tr><td colspan="2"><code>32k</code></td></tr>
<tr><td colspan="2"><code>64k</code></td></tr>
<tr><td colspan="2"><code>4096</code></td></tr>
<tr><td colspan="2"><code>8192</code></td></tr>
<tr><td colspan="2"><code>16384</code></td></tr>
<tr><td colspan="2"><code>32768</code></td></tr>
<tr><td colspan="2"><code>65536</code></td></tr></tbody></table>

<p>Определяет <a href="glossary.htm#glos_page_size">размер страницы</a>
для всех <a href="glossary.htm#glos_tablespace">табличных пространств</a> в
<a href="glossary.htm#glos_instance">экземпляре</a> MySQL.
Вы можете определить размер страницы, используя значения 64k, 32k,
<code>16k</code> (по умолчанию), <code>8k</code> или <code>4k</code>.
Альтернативно, Вы можете определить размер страницы в байтах
(65536, 32768, 16384, 8192, 4096).</p>

<p><a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a> может быть сконфигурирован только до инициализации MySQL и не может быть
изменен позже. Если никакое значение не определено, сервер инициализирован,
используя размер страницы по умолчанию.</p>

<p>Для размеров страницы 32k и 64k максимальная длина строки составляет
приблизительно 16000 байт. <code>ROW_FORMAT=COMPRESSED</code>
не поддержан, когда <code>innodb_page_size</code> 32KB или 64KB. Для
<code>innodb_page_size=32k</code> размер экстента 2MB. Для
<code>innodb_page_size=64k</code> размер экстента 4MB.
<a href="#sysvar_innodb_log_buffer_size"><code>
innodb_log_buffer_size</code></a> должен быть установлен по крайней мере в
16M (значение по умолчанию), используя размер страницы 32k или 64k.</p>

<p>Размер страницы по умолчанию 16 КБ и больше является подходящим для
широкого диапазона <a href="glossary.htm#glos_workload">рабочих нагрузок
</a>, особенно для запросов, вовлекающих сканирование таблицы и операции DML,
вовлекающие оптовые обновления. Меньшие размеры страницы могли бы быть более
эффективными для рабочих нагрузок <a href="glossary.htm#glos_oltp">OLTP</a>,
вовлекающих много маленьких записей, где утверждение может быть проблемой,
когда единственная страница содержит много строк. Меньшие страницы могли бы
также быть эффективными с устройствами хранения данных
<a href="glossary.htm#glos_ssd">SSD</a>, которые как правило используют
маленькие размеры блока. Хранение размера страницы близким к размеру блока
устройства хранения данных минимизирует количество неизменных данных, которые
переписаны на диск.</p>

<p>Минимальный размер файла для первого системного файла с данными табличного
пространства (<code>ibdata1</code>) отличается в зависимости от
<a href="#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>. См. <a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a>.</p></li>

<li><a name="sysvar_innodb_print_all_deadlocks"></a>
<code>innodb_print_all_deadlocks</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_print_all_deadlocks=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_print_all_deadlocks">
innodb_print_all_deadlocks</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Когда эта опция включена, информация обо всех
<a href="glossary.htm#glos_deadlock">тупиках</a> в
пользовательских транзакциях зарегистрирована в
<a href="server.htm#error-log">журнале ошибок</a>.
Иначе Вы видите информацию только о последнем тупике, используя
<code>SHOW ENGINE INNODB STATUS</code>. Случайный тупик не обязательно
проблема, потому что <code>InnoDB</code>
немедленно обнаруживает условие и откатывает одну из транзакций
автоматически. Вы могли бы использовать эту опцию, чтобы расследовать, почему
тупики происходят, если у приложения нет соответствующей логики обработки
ошибок, чтобы обнаружить откат и повторить ее работу. Большое количество
тупиков могло бы указать на потребность реструктурировать транзакции
<a href="glossary.htm#glos_dml">DML</a> или <code>SELECT ... FOR
UPDATE</code> для многих таблиц так, чтобы каждая транзакция получила доступ
к таблицам в том же самом порядке, таким образом избегая условия тупика.</li>

<li><a name="sysvar_innodb_purge_batch_size"></a>
<code>innodb_purge_batch_size</code></p>
<table summary="Options for innodb_purge_batch_size" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_purge_batch_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_purge_batch_size">
innodb_purge_batch_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>300</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>5000</code></td></tr></tbody></table>

<p>Определяет число страниц журнала отмены, которые производят чистку
в одном пакете <a href="glossary.htm#glos_history_list">списка истории</a>.
В мультипоточной конфигурации чистки поток делится координатором по
<a href="#sysvar_innodb_purge_threads"><code>
innodb_purge_threads</code></a> и назначает это число страниц к каждому
потоку чистки. <code>innodb_purge_batch_size</code> также определяет число
страниц журнала отмены, которые чистка освобождает после каждых 128 итераций
через журналы отмены.</p>

<p><code>innodb_purge_batch_size</code> предназначена для усовершенствованной
работы, настраивающей комбинацию с
<a href="#sysvar_innodb_purge_threads"><code>innodb_purge_threads
</code></a>. Большинство пользователей MySQL не должно изменять
<code>innodb_purge_batch_size</code>.</li>

<li><a name="sysvar_innodb_purge_threads"></a>
<code>innodb_purge_threads</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_purge_threads=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_purge_threads">
innodb_purge_threads</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>4</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>32</code></td></tr></tbody></table>

<p>Число фоновых потоков, посвященных
<a href="glossary.htm#glos_purge">чистке</a>.
Минимальное значение 1 показывает, что работа чистки всегда выполняется
фоновым потоком, никогда как часть
<a href="glossary.htm#glos_master_thread">мастер-потока</a>.
Выполнение работы чистки в одном или более фоновых потоках помогает уменьшить
внутренние издержки и улучшить масштабируемости. Увеличение значения к
большему, чем 1, создает много отдельных потоков чистки, которые могут
улучшить эффективность относительно систем, где операции
<a href="glossary.htm#glos_dml">DML</a>
выполнены на многих таблицах. Максимум 32.</p>
<p><code>innodb_purge_threads</code> по умолчанию 4.</li>

<li><a name="sysvar_innodb_purge_rseg_truncate_frequency"></a>
<code>innodb_purge_rseg_truncate_frequency</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_purge_rseg_truncate_frequency=#
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_purge_rseg_truncate_frequency">
innodb_purge_rseg_truncate_frequency</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>128</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>128</code></td></tr></tbody></table>

<p><code>innodb_purge_rseg_truncate_frequency</code>
определяет частоту, с которой система чистки освобождает сегменты отмены.
Табличное пространство отмены не может быть усечено, пока его сегменты отмены
не освобождены. Обычно система чистки освобождает сегменты отмены каждые 128
вызовов. Сокращение <code>innodb_purge_rseg_truncate_frequency</code>
увеличивает частоту, с которой поток чистки освобождает сегменты отмены.
Значение по умолчанию 128.</p>

<p><code>innodb_purge_rseg_truncate_frequency</code>
предназначен для использования с
<a href="#sysvar_innodb_undo_log_truncate"><code>
innodb_undo_log_truncate</code></a>. См.
<a href="#truncate-undo-tablespace">раздел 16.7.8</a>.</li>

<li><a name="sysvar_innodb_random_read_ahead"></a>
<code>innodb_random_read_ahead</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_random_read_ahead=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_random_read_ahead">
innodb_random_read_ahead</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включает случайный метод
<a href="glossary.htm#glos_read_ahead">предвыборки</a>, чтобы оптимизировать
<code>InnoDB</code> I/O.</p>
<p>См. <a href="#innodb-performance-read_ahead">раздел 16.6.3.5
</a>.</li>

<li><a name="sysvar_innodb_read_ahead_threshold"></a>
<code>innodb_read_ahead_threshold</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_read_ahead_threshold=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_read_ahead_threshold">
innodb_read_ahead_threshold</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>56</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>64</code></td></tr></tbody></table>

<p>Управляет чувствительностью линейной
<a href="glossary.htm#glos_read_ahead">предвыборки</a>, которую
использует <code>InnoDB</code>, чтобы предварительно принести страницы в
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>. Если
<code>InnoDB</code> читает по крайней мере
<code>innodb_read_ahead_threshold</code> страниц последовательно из
<a href="glossary.htm#glos_extent">экстента</a> (64 страницы), это начинает
асинхронное чтение для всего следующего экстента.
Допустимый диапазон значений от 0 до 64. Значение 0 отключает предвыборку.
Для значения по умолчанию 56 <code>InnoDB</code> должен считать по крайней
мере 56 страниц последовательно, чтобы начать асинхронное чтение
для следующего экстента.</p>

<p>Знание, сколько страниц считано через этот механизм
и сколько из них выселено из буферного пула без того, чтобы когда-либо к ним
обратились, может быть полезным, чтобы помочь точно настроить
<a href="#sysvar_innodb_read_ahead_threshold"><code>
innodb_read_ahead_threshold</code></a>. <a href="sql.htm#show-engine"><code>
SHOW ENGINE INNODB STATUS</code></a> выводит на экран информацию из
<a href="server.htm#statvar_Innodb_buffer_pool_read_ahead"><code>
Innodb_buffer_pool_read_ahead</code></a>
и <a href="server.htm#statvar_Innodb_buffer_pool_read_ahead_evicted"><code>
Innodb_buffer_pool_read_ahead_evicted</code></a>.
Эти переменные указывают на число страниц, принесенных в
<a href="glossary.htm#glos_buffer_pool">буферный пул</a> запросами
предвыборки, и число
<a href="glossary.htm#glos_eviction">вычеркнутых</a> страниц,
которые не понадобились. Эти счетчики обеспечивают глобальные значения,
начиная с последнего перезапуска сервера.</p>

<p><code>SHOW ENGINE INNODB STATUS</code>
также показывает коэффициент чтения страниц и коэффициент вычеркивания
страниц. Средние числа в секунду основаны на статистических данных, собранных
начиная с последнего запроса <code>SHOW ENGINE INNODB STATUS</code> и
выведены на экран в разделе <code>BUFFER POOL AND MEMORY</code>.</p>
<p>См. <a href="#innodb-performance-read_ahead">
раздел 16.6.3.5</a>.</li>

<li><a name="sysvar_innodb_read_io_threads"></a>
<code>innodb_read_io_threads</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_read_io_threads=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_read_io_threads">innodb_read_io_threads</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>4</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>64</code></td></tr></tbody></table>

<p>Число потоков ввода/вывода для операций чтения. Значение по умолчанию 4.
См. <a href="#innodb-performance-multiple_io_threads">раздел 16.6.6
</a>.</p>

<p>В Linux, выполняя много серверов MySQL (как правило, больше 12) с
настройками по умолчанию для <code>innodb_read_io_threads</code>,
<a href="#sysvar_innodb_write_io_threads"><code>
innodb_write_io_threads</code></a>, настройка <code>aio-max-nr</code>
может превысить системные пределы. Идеально увеличить
<code>aio-max-nr</code>, но как обходное решение, Вы могли бы уменьшить
настройки для одного или обоих из параметров конфигурации MySQL.</p></li>

<li><p><a name="sysvar_innodb_read_only"></a>
<code>innodb_read_only</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_read_only=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_read_only">
innodb_read_only</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Запустить <code>InnoDB</code> в режиме read-only.
Для того, чтобы распределить приложения базы данных или наборы данных.
Может также использоваться в хранилищах данных, чтобы совместно
использовать тот же самый каталог данных многими экземплярами. См.
<a href="#innodb-read-only-instance">раздел 16.6.2</a>.</p>

<p>Ранее, включение <a href="#sysvar_innodb_read_only"><code>
innodb_read_only</code></a> блокировало создание и удаление таблиц только для
<code>InnoDB</code>. В MySQL 8.0 включение
<a href="#sysvar_innodb_read_only"><code>innodb_read_only</code>
</a> блокирует эти операции для всех механизмов хранения. Табличное создание
и удаление изменяют таблицы словаря данных в системной базе данных
<code>mysql</code>, но те таблицы используют механизм хранения
<code>InnoDB</code> и не могут быть изменены, когда включен
<a href="#sysvar_innodb_read_only"><code>innodb_read_only</code>
</a>. Тот же самый принцип относится к другим табличным операциям, которые
требуют изменения таблиц словаря данных:</p>

<ul><li><p><a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
терпит неудачу, потому что это обновляет табличные статистические данные,
которые сохранены в словаре данных.</li>

<li><a href="sql.htm#alter-table"><code>ALTER TABLE <em><code>tbl_name</code>
</em> ENGINE=<em><code>engine_name</code></em></code></a>
терпит неудачу, потому что это обновляет обозначение механизма хранения,
которое сохранено в словаре данных.</p></li></ul>

<p>Кроме того, другие таблицы в системной базе данных <code>mysql</code>
используют механизм хранения <code>InnoDB</code> в MySQL 8.0.
Перевод тех таблиц в режим только для чтения приводит к ограничениям на
операции, которые изменяют их. Примеры:</p>

<ul><li><p>Запросы ведения учетных данных
<a href="sql.htm#create-user"><code>CREATE USER</code></a> и
<a href="sql.htm#grant"><code>GRANT</code></a>
терпят неудачу, потому что таблицы используют <code>InnoDB</code>.</li>

<li><a href="sql.htm#install-plugin"><code>INSTALL PLUGIN</code></a> и
<a href="sql.htm#uninstall-plugin"><code>UNINSTALL PLUGIN</code></a> терпят
неудачу потому что таблица <code>plugin</code> в <code>InnoDB</code>.</li>

<li><a href="sql.htm#create-function-udf"><code>CREATE FUNCTION</code></a> и
<a href="sql.htm#drop-function-udf"><code>DROP FUNCTION</code></a> терпят
неудачу потому что таблица <code>func</code> в <code>InnoDB</code>.
</p></li></ul></li>

<li><p><a name="sysvar_innodb_replication_delay"></a>
<code>innodb_replication_delay</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_replication_delay=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_replication_delay">innodb_replication_delay
</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Задержка потока репликации (в ms) на ведомом сервере, если достигнут
<a href="#sysvar_innodb_thread_concurrency">
<code>innodb_thread_concurrency</code></a>.</li>

<li><a name="sysvar_innodb_rollback_on_timeout"></a>
<code>innodb_rollback_on_timeout</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_rollback_on_timeout</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_rollback_on_timeout">
innodb_rollback_on_timeout</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>В MySQL 8.0 <code>InnoDB</code>
<a href="glossary.htm#glos_rollback">откатывает</a>
только последний запрос об операционном тайм-ауте по умолчанию. Если
<a href="#sysvar_innodb_rollback_on_timeout"><code>
--innodb_rollback_on_timeout</code></a> указан, операционный тайм-аут
откатывает всю транзакцию.</li>

<li><a name="sysvar_innodb_rollback_segments"></a>
<code>innodb_rollback_segments</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_rollback_segments=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_rollback_segments">innodb_rollback_segments
</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>128</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>128</code></td></tr></tbody></table>

<p>Определяет, сколько из
<a href="glossary.htm#glos_rollback_segment">сегментов отмены</a> в
<a href="glossary.htm#glos_system_tablespace">системном табличном
пространстве</a> используется для
<a href="glossary.htm#glos_transaction">транзакций</a>.
Эта установка все еще допустима, но заменена
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a>.</li>

<li><a name="sysvar_innodb_saved_page_number_debug"></a>
<code>innodb_saved_page_number_debug</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_saved_page_number_debug=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_saved_page_number_debug">
innodb_saved_page_number_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="3"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**23-1</code></td></tr></tbody></table>

<p>Сохраняет номер страницы. Установка
<a href="#sysvar_innodb_fil_make_page_dirty_debug"><code>
innodb_fil_make_page_dirty_debug</code></a> помечает страницу, определенную
<code>innodb_saved_page_number_debug</code> как грязную. Опция
<code>innodb_saved_page_number_debug</code> доступна только, если поддержка
отладки собрана с использованием
<a href="install.htm#option_cmake_with_debug"><code>WITH_DEBUG</code></a> в
<span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_sort_buffer_size"></a>
<code>innodb_sort_buffer_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_sort_buffer_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_sort_buffer_size">innodb_sort_buffer_size
</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>65536</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>67108864</code></td></tr></tbody></table>

<p>Определяет размер буферов, используемых для того, чтобы сортировать данные
во время создания индекса <code>InnoDB</code>. Определенный размер определяет
данные, заполняющие память для внутренней сортировки и записанные на диск,
которые могут упоминаться как <span><span>run</span></span>.
Во время фазы слияния пары буферов указанного размера <span><span>читаются
</span></span> и сливаются. Чем больше установка, тем
меньше <span><span>runs</span></span> и слияния.</p>

<p>Эта область используется только для сортировок слиянием во время
создания индекса, не во время обслуживания индекса.
Буферы освобождены, когда создание индекса завершается.</p>

<p>Значение этой опции также управляет на сколько временный файл системного
журнала расширен, чтобы сделать запись параллельного DML во время
операций <a href="glossary.htm#glos_online_ddl">online DDL</a>.</p>
<p>Прежде, чем эта установка была сделана конфигурируемой, размер был 1048576
байт (1MB), это значение остается значением по умолчанию.</p>

<p>Во время <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> или
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>, которые
создают индекс, 3 буфера выделено, каждый с размером, определенным этой
опцией. Дополнительно вспомогательные указатели выделены строкам в буфере
сортировки так, чтобы сортировка могла работать на указателях (в
противоположность перемещаемым строкам).</p>

<p>Для типичной работы сортировки может использоваться такая формула,
чтобы оценить потребление памяти:
<pre>
(6 /*FTS_NUM_AUX_INDEX*/ * (3*@@global.innodb_sort_buffer_size) + 2 *
  number_of_partitions * number_of_secondary_indexes_created *
  (@@global.innodb_sort_buffer_size/dict_index_get_min_size(index)*/) *
  8 /*64-bit sizeof *buf-&gt;tuples*/")
</pre>

<p><code>@@global.innodb_sort_buffer_size/dict_index_get_min_size(index)
</code> указывает на максимальные проводимые кортежи. <code>2 *
(@@global.innodb_sort_buffer_size/*dict_index_get_min_size(index)*/)
* 8 /*64-bit size of *buf-&gt;tuples*/</code>
указывает на вспомогательные выделенные указатели.</p>
<p>Для 32-bit множитель 4 вместо 8.</p>

<p>Для параллельных сортировок на полнотекстовом индексе множитель
<a href="#sysvar_innodb_ft_sort_pll_degree">
<code>innodb_ft_sort_pll_degree</code></a>:
<pre>
(6 /*FTS_NUM_AUX_INDEX*/ * @@global.innodb_ft_sort_pll_degree)
</pre></li>

<li><a name="sysvar_innodb_spin_wait_delay"></a>
<code>innodb_spin_wait_delay</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_spin_wait_delay=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_spin_wait_delay">innodb_spin_wait_delay</a>
</code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(32-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>6</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**32-1</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span>
(64-bit platforms)</td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>6</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>2**64-1</code></td></tr></tbody></table>

<p>Максимальная задержка между опросами для
<a href="glossary.htm#glos_spin">спин-блокировки</a>.
Низкоуровневое выполнение этого механизма изменяется в зависимости от
комбинации аппаратных средств и операционной системы, таким образом, задержка
не соответствует неподвижному временному интервалу. Значение по умолчанию 6.
См. <a href="#innodb-performance-spin_lock_polling">раздел 16.6.8
</a>.</li>

<li><a name="sysvar_innodb_stats_auto_recalc"></a>
<code>innodb_stats_auto_recalc</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_stats_auto_recalc=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_stats_auto_recalc">
innodb_stats_auto_recalc</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Автоматически повторно вычислить
<a href="glossary.htm#glos_persistent_statistics">постоянную статистику</a>
после того, как данные в таблице изменены существенно. Пороговое значение в
настоящее время 10% строк в таблице. Эта установка относится к таблицам,
составленным при включенном
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a> или с <code>STATS_PERSISTENT=1</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Объемом данных, выбранным, чтобы произвести статистику, управляет
<a href="#sysvar_innodb_stats_persistent_sample_pages"><code>
innodb_stats_persistent_sample_pages</code></a>.</p>
<p>См. <a href="#innodb-persistent-stats">раздел 16.6.10.1</a>.
</li>

<li><a name="sysvar_innodb_stats_include_delete_marked"></a>
<code>innodb_stats_include_delete_marked</code></p>
<table border="1">
<tbody><tr><td><span><strong>Introduced</strong></span></td>
<td colspan="3">8.0.1</td></tr>
<tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_stats_include_delete_marked=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_stats_include_delete_marked">
innodb_stats_include_delete_marked</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>По умолчанию <code>InnoDB</code> читает данные,
вычисляя статистику. В случае незавершенной транзакции, которая удаляет
строки из таблицы, <code>InnoDB</code> исключает записи, помеченные как
удаленные, вычисляя оценки строки и индексную статистику, которая может
привести к неоптимальным планам выполнения относительно других транзакций,
которые воздействуют на таблицу, одновременно используя операционный уровень
изоляции, кроме <a href="#isolevel_read-uncommitted"><code>READ
UNCOMMITTED</code></a>. Во избежание этого
<a href="#sysvar_innodb_stats_include_delete_marked"><code>
innodb_stats_include_delete_marked</code></a> может быть включен, чтобы
гарантировать, что <code>InnoDB</code> включает записи, помеченные как
удаленные, вычисляя постоянную статистику.</p>

<p>Когда <a href="#sysvar_innodb_stats_include_delete_marked">
<code>innodb_stats_include_delete_marked</code></a> включен,
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> рассматривает
записи, помеченные как удаленные, повторно вычисляя статистику.</p>

<p><a href="#sysvar_innodb_stats_include_delete_marked"><code>
innodb_stats_include_delete_marked</code></a> глобальная установка, которая
затрагивает все таблицы, и это применимо только к постоянной статистике.</p>
<p>См. <a href="#innodb-persistent-stats">раздел 16.6.10.1</a>.
</li>

<li><a name="sysvar_innodb_stats_method"></a>
<code>innodb_stats_method</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_stats_method=name</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_stats_method">
innodb_stats_method</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="5"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>enumeration</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>nulls_equal</code></td></tr>
<tr><td rowspan="3" valign="top"><span><strong>Допустимые значения</strong>
</span></td><td colspan="2"><code>nulls_equal</code></td></tr>
<tr><td colspan="2"><code>nulls_unequal</code></td></tr>
<tr><td colspan="2"><code>nulls_ignored</code></td></tr></tbody></table>

<p>Как сервер обрабатывает <code>NULL</code>, собирая
<a href="glossary.htm#glos_statistics">статистические данные</a>
о распределении индекса значения для таблиц.
У этой переменной есть три возможных значения: <code>nulls_equal</code>,
<code>nulls_unequal</code> и <code>nulls_ignored</code>. Для
<code>nulls_equal</code> все индексные значения <code>NULL</code>
считаются равными и формируют единственную группу значения, у которой есть
размер, равный числу значений <code>NULL</code>. Для
<code>nulls_unequal</code> значения <code>NULL</code>
считают неравными, и каждое значение <code>NULL</code> формирует отличную
группу значений размера 1. Для <code>nulls_ignored</code>
значения <code>NULL</code> проигнорированы.</p>

<p>Метод, который используется для того, чтобы произвести табличную
статистику, как оптимизатор выбирает индекс для выполнения запроса, описан в
<a href="optimiz.htm#index-statistics">разделе 9.3.7</a>.</li>

<li><a name="sysvar_innodb_stats_on_metadata"></a>
<code>innodb_stats_on_metadata</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_stats_on_metadata</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_stats_on_metadata">
innodb_stats_on_metadata</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_stats_on_metadata">
innodb_stats_on_metadata</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Когда эта переменная включена, <code>InnoDB</code> обновляет
<a href="glossary.htm#glos_statistics">статистику</a>, когда обрабатывает
запросы метаданных, например, <a href="sql.htm#show-table-status"><code>SHOW
TABLE STATUS</code></a>, или при обращении к таблицам
<a href="inform.htm#tables-table"><code>INFORMATION_SCHEMA.TABLES</code></a>
или <a href="inform.htm#statistics-table"><code>INFORMATION_SCHEMA.STATISTICS
</code></a>. Эти обновления подобны тому, что происходят для
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
Когда отключена, <code>InnoDB</code>
не обновляет статистику во время этих операций. Это может улучшить
скорость доступа для схем, у которых есть большое количество таблиц или
индексов. Это может также улучшить стабильность
<a href="glossary.htm#glos_query_execution_plan">планов выполнения</a>
относительно запросов, которые вовлекают таблицы <code>InnoDB</code>.</p>

<p>Чтобы изменить настройки, сделайте запрос <code>SET GLOBAL
innodb_stats_on_metadata=<em><code>mode</code></em></code>,
где <code><em><code>mode</code></em></code>
<code>ON</code> или <code>OFF</code> (<code>1</code> или <code>0</code>).
Изменение этих настроек требует привилегии <code>SUPER</code>
и немедленно затрагивает работу всех соединений.</p>
<p>Эта переменная отключена по умолчанию.</li>

<li><a name="sysvar_innodb_stats_persistent"></a>
<code>innodb_stats_persistent</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_stats_persistent=setting</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_stats_persistent">
innodb_stats_persistent</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="6"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr>
<tr><td rowspan="4" valign="top"><span><strong>Допустимые значения</strong>
</span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td colspan="2"><code>ON</code></td></tr>
<tr><td colspan="2"><code>0</code></td></tr>
<tr><td colspan="2"><code>1</code></td></tr></tbody></table>

<p>Определяет сохраняет ли <code>InnoDB</code> индексную статистику на диск.
Иначе статистика может часто повторно вычисляться, что может привести к
изменениям в <a href="glossary.htm#glos_query_execution_plan">планах
выполнения запроса</a>. Эта установка сохранена каждой таблицей, когда
таблица составлена. Вы можете установить
<code>innodb_stats_persistent</code>на глобальном уровне прежде, чем
составить таблицу, или использовать <code>STATS_PERSISTENT</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, чтобы
переопределить установку в масштабе всей системы и сконфигурировать
постоянную статистику для отдельных таблиц.</p>
<p>См. <a href="#innodb-persistent-stats">раздел 16.6.10.1</a>.
</li>

<li><a name="sysvar_innodb_stats_persistent_sample_pages"></a>
<code>innodb_stats_persistent_sample_pages</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_stats_persistent_sample_pages=#
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_stats_persistent_sample_pages">
innodb_stats_persistent_sample_pages</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>20</code></td></tr></tbody></table>

<p>Число индексных страниц, оценивая
<a href="glossary.htm#glos_cardinality">количество элементов</a> и другую
<a href="glossary.htm#glos_statistics">статистику</a>
для индексированного столбца, как вычисленная
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
Увеличение значения улучшает точность статистики индекса, которая может
улучшить <a href="glossary.htm#glos_query_execution_plan">план выполнения
запроса</a> за счет увеличенного ввода/вывода во время выполнения
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>. Подробности в
<a href="#innodb-persistent-stats">разделе 16.6.10.1</a>.</p>

<p>Указание большого значения для
<code>innodb_stats_persistent_sample_pages</code>
может привести к длинному времени выполнения <a href="sql.htm#analyze-table">
<code>ANALYZE TABLE</code></a>. Чтобы оценить число страниц базы данных, к
которым получат доступ, см.
<a href="#innodb-analyze-table-complexity">раздел 16.6.10.3</a>.
</p>

<p>Эта опция применяется только, когда включена
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a> для таблицы, когда та опция выключена для
таблицы, <a href="#sysvar_innodb_stats_transient_sample_pages">
<code>innodb_stats_transient_sample_pages</code></a>
применяется вместо этого.</li>

<li><a name="sysvar_innodb_stats_transient_sample_pages"></a>
<code>innodb_stats_transient_sample_pages</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_stats_transient_sample_pages=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_stats_transient_sample_pages">
innodb_stats_transient_sample_pages</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8</code></td></tr></tbody></table>

<p>Число индексных страниц для оценки
<a href="glossary.htm#glos_cardinality">количества элементов</a> и другой
<a href="glossary.htm#glos_statistics">статистики</a>
для индексированного столбца, такой как вычисленная
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
Значение по умолчанию 8. Увеличение значения улучшает точность статистики
индекса, которая может улучшить
<a href="glossary.htm#glos_query_execution_plan">план выполнения запроса
</a>, за счет увеличенного ввода/вывода или перевычисления статистики. Для
дополнительной информации см.
<a href="#innodb-statistics-estimation">раздел 16.6.10.2</a>.</p>

<p>Указание большого значения для
<code>innodb_stats_transient_sample_pages</code> может увеличить время
работы <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
Чтобы оценить число страниц базы данных, к которым получают доступ, см.
<a href="#innodb-analyze-table-complexity">раздел 16.6.10.3</a>.
</p>

<p>Эта опция применяется только, когда выключена
<a href="#sysvar_innodb_stats_persistent"><code>
innodb_stats_persistent</code></a> для таблицы, когда эта опция включена для
таблицы, <a href="#sysvar_innodb_stats_persistent_sample_pages">
<code>innodb_stats_persistent_sample_pages</code></a>
применяется вместо этого. См.
<a href="#innodb-statistics-estimation">раздел 16.6.10.2</a>.</li>

<li><a name="sysvar_innodb_status_output"></a>
<code>innodb_status_output</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_status_output</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_status_output">
innodb_status_output</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включает или отключает периодический вывод
<code>InnoDB</code> Monitor. Также используется в комбинации с
<a href="#sysvar_innodb_status_output_locks"><code>
innodb_status_output_locks</code></a>, чтобы включить или отключить
периодический вывод <code>InnoDB</code> Lock Monitor. См.
<a href="#innodb-monitors">раздел 16.16</a>.</li>

<li><a name="sysvar_innodb_status_output_locks"></a>
<code>innodb_status_output_locks</code></p>
<table summary="Options for innodb_status_output_locks" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_status_output_locks</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_status_output_locks">
innodb_status_output_locks</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включает или отключает <code>InnoDB</code> Lock Monitor. Когда включено,
<code>InnoDB</code> Lock Monitor печатает дополнительную информацию о
блокировках в <code>SHOW ENGINE INNODB STATUS</code> и в
периодическом выводе, напечатанном в журнал ошибок MySQL. Периодический
вывод для <code>InnoDB</code> Lock Monitor напечатан как часть вывода
<code>InnoDB</code> Monitor. Стандартный <code>InnoDB</code> Monitor
нужно поэтому включить для <code>InnoDB</code> Lock Monitor, чтобы напечатать
данные в журнал ошибок MySQL периодически. См.
<a href="#innodb-monitors">раздел 16.16</a>.</li>

<li><a name="sysvar_innodb_strict_mode"></a>
<code>innodb_strict_mode</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_strict_mode=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_strict_mode">
innodb_strict_mode</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Global, Session</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Когда <code>innodb_strict_mode</code> = <code>ON</code>,
<code>InnoDB</code> возвращает ошибки, а не предупреждения для определенных
условий. Значение по умолчанию <code>ON</code>.</p>

<p><a href="glossary.htm#glos_strict_mode">Строгий режим</a> помогает
принять меры против проигнорированных опечаток и синтаксических ошибок в SQL,
или других непреднамеренных последствий различных комбинаций операционных
режимов и запросов SQL. Когда
<code>innodb_strict_mode</code> = <code>ON</code>, <code>InnoDB</code>
поднимает состояния ошибки в определенных случаях, вместо того, чтобы
выпустить предупреждение и продолжить обработку указанного запроса (возможно,
с непреднамеренным поведением). Это походит на
<a href="server.htm#sql-mode"><code>sql_mode</code></a> в MySQL,
который управляет тем, что принимает синтаксис SQL MySQL, и определяет,
игнорирует ли это тихо ошибки, или утверждает входной
синтаксис и значения данных.</p>

<p><code>innodb_strict_mode</code> затрагивает обработку синтаксических
ошибок для <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a>, <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a> и
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a> statements.
<code>innodb_strict_mode</code> также включает проверку размера записи, чтобы
<code>INSERT</code> или <code>UPDATE</code> никогда не терпят неудачу из-за
слишком большой записи для выбранного размера страницы.</p>

<p>Oracle рекомендует включить <code>innodb_strict_mode</code>, используя
<code>ROW_FORMAT</code> и <code>KEY_BLOCK_SIZE</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> и
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a>. Если
<code>innodb_strict_mode</code> = <code>OFF</code>, <code>InnoDB</code>
игнорирует противоречивые параметры и составляет таблицу или индекс только с
предупреждением в журнале сообщения. У получающейся таблицы может быть
не то поведение, чем Вы предназначали, например, отсутствие сжатия, когда Вы
попытались составить сжатую таблицу. Когда
<code>innodb_strict_mode</code> = <code>ON</code>,
такие проблемы производят непосредственную ошибку, и таблица или индекс не
создается, избегая сеанса поиска неисправностей позже.</p>

<p>Вы можете переключить <code>innodb_strict_mode</code> в
<code>ON</code> или <code>OFF</code> в командной строке, когда Вы запускаете
<code>mysqld</code>, или в
<a href="glossary.htm#glos_configuration_file">конфигурационном файле</a>
<code>my.cnf</code> или <code>my.ini</code>.
Вы можете также включить или отключить
<code>innodb_strict_mode</code> через <code>SET [GLOBAL|SESSION]
innodb_strict_mode=<em><code>mode</code></em></code>, где
<code><em><code>mode</code></em></code>
<code>ON</code> или <code>OFF</code>. Изменение <code>GLOBAL</code>
требует привилегию <code>SUPER</code> и влияет на всех клиентов, которые
впоследствии соединяются. Любой клиент может изменить настройку
<code>SESSION</code> для <code>innodb_strict_mode</code>, и установка
затрагивает только этого клиента.</p>

<p><a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a> не применимо к общим табличным пространствам. Управленческие
правила табличного пространства для общих табличных пространств строго
проведены в жизнь, независимо от
<a href="#sysvar_innodb_strict_mode"><code>innodb_strict_mode
</code></a>. См. <a href="sql.htm#create-tablespace">раздел 14.1.16</a>.</li>

<li><a name="sysvar_innodb_sync_array_size"></a>
<code>innodb_sync_array_size</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_sync_array_size=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_sync_array_size">
innodb_sync_array_size</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr></tbody></table>

<p>Разделяет внутреннюю структуру данных, используемую, чтобы скоординировать
потоки, для более высокого параллелизма в рабочих нагрузках с большими
количествами потоков ожидания. Эта установка должна быть сконфигурирована,
когда экземпляр MySQL стартует и не может быть изменена позже. Увеличение
этого значения опции рекомендуется для рабочих нагрузок, которые часто
производят большое количество потоков ожидания, как правило, больше 768.</li>

<li><a name="sysvar_innodb_sync_spin_loops"></a>
<code>innodb_sync_spin_loops</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_sync_spin_loops=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_sync_spin_loops">
innodb_sync_spin_loops</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>30</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>
<p>Сколько поток ждет <code>InnoDB</code> mutex, который будет
освобожден перед тем, как поток приостановлен.Значение по умолчанию 30.</li>

<li><a name="sysvar_innodb_sync_debug"></a>
<code>innodb_sync_debug</code></p>
<table summary="Options for innodb_sync_debug" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_sync_debug=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_sync_debug">
innodb_sync_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включает синхронизирующую проверку отладки механизма хранения
<code>InnoDB</code>. Эта опция доступна только, если поддержка отладки
собрана с использованием <a href="install.htm#option_cmake_with_debug">
<code>WITH_DEBUG</code></a> в <span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_table_locks"></a>
<code>innodb_table_locks</code></p>
<table summary="Options for innodb_table_locks" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_table_locks</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_table_locks">
innodb_table_locks</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Global, Session</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>TRUE</code></td></tr></tbody></table>

<p>Если <a href="server.htm#sysvar_autocommit"><code>autocommit=0</code></a>,
<code>InnoDB</code> учитывает <a href="sql.htm#lock-tables"><code>LOCK
TABLES</code></a>, MySQL не возвращается из <code>LOCK TABLES ... WRITE
</code>, пока все другие потоки не выпустили все свои блокировки таблицы.
Значение по умолчанию <a href="#sysvar_innodb_table_locks"><code>
innodb_table_locks</code></a> 1, что значит, что
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a> предписывает
InnoDB заблокировать таблицу внутренне, если
<a href="server.htm#sysvar_autocommit"><code>autocommit=0</code></a>.</p>

<p>В MySQL 8.0 <a href="#sysvar_innodb_table_locks"><code>
innodb_table_locks = 0</code></a>
не имеет никакого эффекта для таблиц, заблокированных явно с
<a href="sql.htm#lock-tables"><code>LOCK TABLES ... WRITE</code></a>.
Это действительно имеет эффект для таблиц, заблокированных для чтения
или записи через <a href="sql.htm#lock-tables"><code>LOCK TABLES ... WRITE
</code></a> неявно (например, через триггеры) или через
<a href="sql.htm#lock-tables"><code>LOCK TABLES ... READ</code></a>.</li>

<li><a name="sysvar_innodb_temp_data_file_path"></a>
<code>innodb_temp_data_file_path</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_temp_data_file_path=file</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_temp_data_file_path">
innodb_temp_data_file_path</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>string</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ibtmp1:12M:autoextend</code></td></tr></tbody></table>

<p>Определяет путь, имя файла и размер файла для временных файлов с данными
табличного пространства. Полный путь к каталогу для файла сформирован,
связывая <a href="#sysvar_innodb_data_home_dir"><code>
innodb_data_home_dir</code></a> и путь из
<code>innodb_temp_data_file_path</code>.
Размер файла определен в КБ, MB, или ГБ (1024 МБ), прилагая
<code>K</code>, <code>M</code> или <code>G</code>
к значению размера. Сумма размеров файлов должна быть немного больше 12 МБ.
Если Вы не определяете <code>innodb_temp_data_file_path</code>,
поведение по умолчанию должно создать единственный автомасштабируемый
временный файл с данными табличного пространства, немного больше 12 МБ,
названный <code>ibtmp1</code>. Предел размера отдельных файлов определен
Вашей операционной системой. Вы можете установить размер файла больше 4 ГБ на
операционных системах, которые поддерживают большие файлы. Использование
сырого дискового раздела для временных файлов с данными табличного
пространства не поддержано.</p>

<p>Название временного файла с данными табличного пространства не может быть
тем же самым как название файла с данными. Любая ошибка создания временного
файла с данными табличного пространства обработана как фатальная, и запуск
сервера отменяется. У временного табличного табличного пространства есть
динамически произведенное ID, пространства, которое может измениться при
каждом перезапуске сервера.</p>

<p>Все временные таблицы <code>InnoDB</code>
составлены в совместно используемом временном табличном пространстве.
<code>InnoDB</code> не поддерживает сжатые временные таблицы.</p>

<p>Метаданные об активных временных таблицах найдены в
<a href="inform.htm#innodb-temp-table-info-table"><code>
INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO</code></a>.</li>

<li><a name="sysvar_innodb_tmpdir"></a>
<code>innodb_tmpdir</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_tmpdir=path</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_tmpdir">innodb_tmpdir
</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Global, Session</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>directory name</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>NULL</code></td></tr></tbody></table>

<p>Используется, чтобы определить дополнительный каталог для временных
файлов, создаваемых во время онлайн <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, которые пересоздают таблицу.</p>

<p>Online <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, которые
пересоздают таблицу, также создают
<span><em>промежуточный</em></span> табличный файл в том же самом каталоге,
как оригинальная таблица. <code>innodb_tmpdir</code>
не применима к промежуточным табличным файлам.</p>

<p>Допустимое значение любой путь к каталогу кроме пути к каталогу данных
MySQL. Если значение NULL (по умолчанию), временные файлы будут в создаваемом
MySQL временном каталоге (<code>$TMPDIR</code> в Unix, <code>%TEMP%</code> в
Windows или каталоге, определенном в
<a href="server.htm#sysvar_tmpdir"><code>--tmpdir</code></a>). Если
<code>innodb_tmpdir</code> каталог определен, существование каталога и
разрешения проверено, только когда <code>innodb_tmpdir</code>
сконфигурирован, используя <a href="sql.htm#set-variable"><code>SET</code>
</a>. Если символьная ссылка обеспечена в строке каталога, символьная ссылка
раскрыта и сохранена как абсолютный путь. Путь не должен превысить 512 байт в
длину. Онлайн <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
сообщает об ошибке, если <code>innodb_tmpdir</code> установлен в недопустимый
каталог. <code>innodb_tmpdir</code> переопределяет MySQL
<a href="server.htm#sysvar_tmpdir"><code>tmpdir</code></a>, но только для
онлайн <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<p>Привилегия <code>FILE</code> требуется для
настройки <code>innodb_tmpdir</code>.</p>
<p><code>innodb_tmpdir</code> была введена, чтобы помочь избежать
переполнения временного каталога, расположенного на файловой системе
<code>tmpfs</code>. Такие переполнения могли произойти в результате больших
временных файлов, создаваемых во время онлайн
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<p>В окружающей среде репликации рассмотрите мультиплицирование
<code>innodb_tmpdir</code> только, если у всех серверов есть та же самая
окружающая среда операционной системы. Иначе мультиплицирование
<code>innodb_tmpdir</code> может привести к отказу репликации при работе
online <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Если
операционные среды сервера отличаются, рекомендуется, чтобы Вы
сконфигурировали <code>innodb_tmpdir</code> на каждом сервере индивидуально.
</p></li>

<li><a name="sysvar_innodb_thread_concurrency"></a>
<code>innodb_thread_concurrency</code></p>
<table summary="Options for innodb_thread_concurrency" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_thread_concurrency=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_thread_concurrency">
innodb_thread_concurrency</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000</code></td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000</code></td></tr></tbody></table>

<p><code>InnoDB</code> пытается сохранить число потоков операционной системы
внутри <code>InnoDB</code> меньше или равным пределу, заданному этой
переменной (<code>InnoDB</code> использует потоки ОС, чтобы обработать
пользовательские транзакции). Как только число потоков достигает этого
предела, дополнительные потоки помещены в состояние ожидания в очередь
<span><span>First In, First Out</span></span> (FIFO) для выполнения.
Потоки, ждущие блокировок, не посчитаны в числе
параллельного выполнения потоков.</p>

<p>Диапазон этой переменной от 0 до 1000. Значение 0 (значение по умолчанию)
интерпретируется как бесконечный параллелизм (никакой проверки параллелизма).
Отключение проверки параллелизма потока разрешает <code>InnoDB</code>
создать так много потоков, как надо. Значение 0 также отключает
<code>queries inside InnoDB</code> и <code>queries in queue counters</code> в
разделе <code>ROW OPERATIONS</code> вывода
<code>SHOW ENGINE INNODB STATUS</code>.</p>

<p>Рассмотрите установку этой переменной, если Ваш случай MySQL совместно
использует ресурсы центрального процессора с другими приложениями, или если
Ваша рабочая нагрузка или число параллельных пользователей растут.
Правильная установка зависит от рабочей нагрузки, вычислительной окружающей
среды и версии MySQL. Вы должны будете проверить диапазон значений, чтобы
определить установку, которая обеспечивает лучшую работу.
<code>innodb_thread_concurrency</code> динамическая переменная, которая
позволяет Вам экспериментировать с различными настройками на живой
испытательной системе. Если особая установка выступает плохо, Вы можете
быстро установить <code>innodb_thread_concurrency</code> назад в 0.</p>

<p>Используйте следующие советы:</p>
<ul><li><p>Если число параллельных пользовательских потоков для рабочей
нагрузки меньше 64, <code>innodb_thread_concurrency=0</code>.</li>

<li>Если Ваша рабочая нагрузка последовательно тяжела или иногда выдает
пики, запустите <code>innodb_thread_concurrency=128</code> и снижайте до
96, 80, 64 и т.д., пока Вы не найдете число потоков, которое обеспечивает
лучшую работу. Например, предположим, что у Вашей системы, как правило, есть
40-50 пользователей, но периодически число увеличивается до 60, 70 или даже
200. Вы находите, что работа устойчива при 80 параллельных пользователях,
но начинает показывать регресс выше этого числа. В этом случае Вы установили
бы <code>innodb_thread_concurrency=80</code>.</li>

<li>Если Вы не хотите использовать больше, чем определенное число vCPU
для пользовательских потоков (20 vCPU, например), установите
<code>innodb_thread_concurrency</code> к этому числу (или возможно ниже, в
зависимости от исполнительных результатов). Если Ваша цель состоит в том,
чтобы изолировать MySQL от других приложений, Вы можете рассмотреть привязку
<code>mysqld</code> исключительно к vCPU. Знайте, однако, что исключительная
привязка может привести к неоптимальному использованию аппаратных средств,
если <code>mysqld</code> не занят непрерывно. В этом случае Вы могли бы
связать <code>mysqld</code> с vCPU, но также и позволить другим приложениям
использовать некоторых или все vCPU.</p>

<p>С точки зрения операционной системы использовать управленческое решение
для ресурса (при наличии), чтобы определить то, как время центрального
процессора совместно использовано среди приложений, может быть
предпочтительным для привязки <code>mysqld</code>.
Например, Вы могли назначить 90% времени vCPU
данному приложению, в то время как другой критический процесс
<span><em>не</em></span> работает, и вернуть значение к 40%,
когда другие критические процессы <span><em>работают</em></span>.</p></li>

<li><p><code>innodb_thread_concurrency</code>, которые слишком высоки, могут
вызвать исполнительный регресс.</li>
<li>В некоторых случаях оптимальное значение
<code>innodb_thread_concurrency</code> может быть меньше, чем число vCPU.
</li>

<li>Контролируйте и регулярно анализируйте свою систему. Изменения рабочей
нагрузки, числа пользователей или вычислительной окружающей среды могут
потребовать, чтобы Вы корректировали <code>innodb_thread_concurrency</code>.
</p></li></ul>
<p>См. <a href="#innodb-performance-thread_concurrency">раздел
16.6.5</a>.</li>

<li><a name="sysvar_innodb_trx_purge_view_update_only_debug"></a>
<code>innodb_trx_purge_view_update_only_debug</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_trx_purge_view_update_only_debug=#
</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_trx_purge_view_update_only_debug">
innodb_trx_purge_view_update_only_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Приостанавливает чистку помеченных как удаленные записей, позволяя
обновить обзор чистки. Эта опция искусственно создает ситуацию, в которой
обновлено представление чистки, но чистки еще не были выполнены. Эта опция
доступна только, если поддержка отладки собрана с использованием
<a href="install.htm#option_cmake_with_debug"><code>WITH_DEBUG</code></a> в
<span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_trx_rseg_n_slots_debug"></a>
<code>innodb_trx_rseg_n_slots_debug</code></p>
<table summary="Options for innodb_trx_rseg_n_slots_debug" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_trx_rseg_n_slots_debug=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code>
<a href="#sysvar_innodb_trx_rseg_n_slots_debug">
innodb_trx_rseg_n_slots_debug</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="3"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr></tbody></table>

<p>Устанавливает флаг отладки, который ограничивает
<code>TRX_RSEG_N_SLOTS</code> к данному значению для функции
<code>trx_rsegf_undo_find_free</code>, которая ищет свободный слот для
сегмента журнала отмены. Эта опция доступна только, если поддержка отладки
собрана с использованием <a href="install.htm#option_cmake_with_debug"><code>
WITH_DEBUG</code></a> в <span><strong>CMake</strong></span>.</li>

<li><a name="sysvar_innodb_thread_sleep_delay"></a>
<code>innodb_thread_sleep_delay</code></p>
<table summary="Options for innodb_thread_sleep_delay" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_thread_sleep_delay=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_thread_sleep_delay">
innodb_thread_sleep_delay</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10000</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000000</code></td></tr></tbody></table>

<p>Сколько времени потоки спят прежде, чем присоединиться к очереди
<code>InnoDB</code>, в микросекундах. Значение по умолчанию 10000. Значение 0
отключает сон. Вы можете установить параметр конфигурации
<a href="#sysvar_innodb_adaptive_max_sleep_delay"><code>
innodb_adaptive_max_sleep_delay</code></a>к самому высокому значению, которое
позволено для <code>innodb_thread_sleep_delay</code>, и InnoDB автоматически
корректирует <code>innodb_thread_sleep_delay</code> в зависимости от
намечающей текущий поток деятельности. Эта динамическая корректировка
помогает механизму планирования потока работать гладко в течение времен,
когда система слегка загружена и когда это управляет
близкой к полной мощности.</p>
<p>См. <a href="#innodb-performance-thread_concurrency">
раздел 16.6.5</a>.</li>

<li><a name="sysvar_innodb_undo_directory"></a>
<code>innodb_undo_directory</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_undo_directory=dir_name</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_undo_directory">
innodb_undo_directory</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>имя каталога</code></td></tr></tbody></table>

<p>Путь, где <code>InnoDB</code> создает отдельные табличные пространства для
журналов отмены. Как правило, используется, чтобы поместить журналы отмены
на отдельное устройство хранения данных. Используется в соединении с
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a> и <a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a>, которые определяют дисковое расположение
журналов отмены вне <a href="glossary.htm#glos_system_tablespace">
системного табличного пространства</a>.</p>

<p>Нет значения по умолчанию (NULL). Если путь не определен, табличные
пространства отмены создаются в каталоге данных MySQL, как определено
<a href="server.htm#sysvar_datadir"><code>datadir</code></a>.</p>
<p>См. <a href="#innodb-undo-tablespace">раздел 16.7.7</a>.</li>

<li><a name="sysvar_innodb_undo_log_truncate"></a>
<code>innodb_undo_log_truncate</code></p>
<table summary="Options for innodb_undo_log_truncate" border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_undo_log_truncate=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_undo_log_truncate">
innodb_undo_log_truncate</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Когда Вы включаете <code>innodb_undo_log_truncate</code>,
табличные пространства отмены, которые превышают пороговое значение,
определенное <a href="#sysvar_innodb_max_undo_log_size"><code>
innodb_max_undo_log_size</code></a>, отмечены для усечения. Только журналы
отмены, которые находятся в табличных пространствах отмены, могут быть
усеченны. Усечение журналов отмены, которые находятся в системном табличном
пространстве, не поддержано. Для усечения должно быть по крайней мере два
табличных пространства отмены и два журнала отмены, сконфигурированных, чтобы
использовать табличные пространства отмены. Это означает, что
<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> должен быть установлен в значение, равное
или больше 2, и <a href="#sysvar_innodb_undo_logs"><code>
innodb_undo_logs</code></a> должен быть равен или больше 35.</p>

<p>Опция <a href="#sysvar_innodb_purge_rseg_truncate_frequency">
<code>innodb_purge_rseg_truncate_frequency</code></a>
может использоваться, чтобы ускорить усечение журналов отмены.</p>
<p>См. <a href="#truncate-undo-tablespace">раздел 16.7.8</a>.</li>

<li><a name="sysvar_innodb_undo_logs"></a>
<code>innodb_undo_logs</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_undo_logs=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_undo_logs">
innodb_undo_logs</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>128</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>128</code></td></tr></tbody></table>

<p>Определяет число журналов отмены
(<a href="glossary.htm#glos_rollback_segment">сегментов отмены</a>),
используемых <code>InnoDB</code>.
<a href="#sysvar_innodb_undo_logs"><code>innodb_undo_logs</code>
</a> заменяет <a href="#sysvar_innodb_rollback_segments">
<code>innodb_rollback_segments</code></a>.</p>

<p>Один журнал отмены всегда назначается на системное табличное
пространство, и 32 журнала отмены сохранены для использования временными
таблицами и размещены во временном табличном пространстве (<code>ibtmp1
</code>). Чтобы выделить дополнительные журналы отмены для изменяющих данные
транзакций, которые производят отчеты отмены, <code>innodb_undo_logs</code>
должен быть установлен в значение больше 33. Если Вы конфигурируете отдельные
табличные пространства отмены, журнал отмены в системном табличном
пространстве неактивен. Каждый журнал отмены может
разместить максимум 1024 транзакции.</p>

<p>Когда <code>innodb_undo_logs</code> 32 или менее, <code>InnoDB</code>
назначает один журнал отмены на системное табличное пространство и 32
временному табличному пространству (<code>ibtmp1</code>).</p>

<p>Когда <code>innodb_undo_logs</code> больше 32, <code>InnoDB</code>
назначает один журнал отмены на системное табличное пространство, 32
временному табличному пространству (<code>ibtmp1</code>) и все
дополнительные журналы отмены на табличные пространства отмены, если они
существуют. Если табличные пространства отмены не существует, дополнительные
журналы отмены назначены на системное табличное пространство.</p>

<p>Хотя Вы можете увеличить или сократить число журналов отмены, используемых
<code>InnoDB</code>, число журналов отмены, физически существующих в системе,
никогда не уменьшается. Таким образом, Вы могли бы начать с низкого значения
этого параметра и постепенно увеличивать его, чтобы избежать выделять журналы
отмены, которые не требуются. Если
<a href="#sysvar_innodb_undo_logs"><code>
innodb_undo_logs</code></a> не установлен, это принимает значение по
умолчанию 128. Для общего количества доступных журналов отмены, а не числа
активных, см. <a href="server.htm#statvar_Innodb_available_undo_logs">
<code>Innodb_available_undo_logs</code></a>.</p>
<p>См. разделы <a href="#innodb-multi-versioning">16.3</a> и
<a href="#innodb-undo-tablespace">16.7.7</a>.</li>

<li><a name="sysvar_innodb_undo_tablespaces"></a>
<code>innodb_undo_tablespaces</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_undo_tablespaces=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_undo_tablespaces">
innodb_undo_tablespaces</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>95</code></td></tr></tbody></table>

<p>Число файлов <a href="glossary.htm#glos_tablespace">табличного
пространства</a>, между которыми разделены
<a href="glossary.htm#glos_undo_log">журналы отмены</a>.
По умолчанию все журналы отмены часть
<a href="glossary.htm#glos_system_tablespace">системного табличного
пространства</a>, и системное табличное пространство всегда содержит одно
табличное пространство отмены в дополнение к сконфигурированным
<a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a>.</p>

<p>Поскольку журналы отмены могут стать большими во время продолжительных
транзакций, многократные табличные пространства уменьшают максимальный размер
любого табличного пространства. Файлы табличного пространства отмены
создаются в местоположении, определенном
<a href="#sysvar_innodb_undo_directory"><code>
innodb_undo_directory</code></a> с именами в форме
<code>undo<em><code>N</code></em></code>, где <em><code>N</code></em>
последовательная серия целых чисел (включая начальные нули). Размер по
умолчанию файла табличного пространства отмены 10M.</p>

<p><a href="#sysvar_innodb_undo_tablespaces"><code>
innodb_undo_tablespaces</code></a> может только быть сконфигурирован до
инициализации MySQL и не может быть изменен позже. Если никакое значение не
определено, сервер инициализирован, используя настройку по умолчанию
(<code>0</code>). Попытка перезапустить <code>InnoDB</code>
с большим числом табличных пространств отмены, чем указано, когда MySQL был
инициализирован, приводит к отказу запуска и ошибке заявляя, что
<code>InnoDB</code> не нашел ожидаемое число табличных пространств отмены.
</p>

<p>32 из 128 журналов отмены сохранены для временных таблиц, как описано в
<a href="#innodb-temporary-table-undo-logs">разделе 16.4.11.1</a>.
Один журнал отмены всегда выделяется системному табличному пространству,
которое оставляет 95 журналов отмены доступными. Это означает, что
максимальный предел <a href="#sysvar_innodb_undo_tablespaces">
<code>innodb_undo_tablespaces</code></a> 95.</p>
<p>См. <a href="#innodb-undo-tablespace">раздел 16.7.7</a>.</li>

<li><a name="sysvar_innodb_use_native_aio"></a>
<code>innodb_use_native_aio</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_use_native_aio=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_use_native_aio">
innodb_use_native_aio</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="2"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>boolean</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Определяет, использовать ли асинхронную подсистему ввода/вывода Linux. Эта
переменная относится только к системам Linux и не может быть изменена в то
время, как сервер работает. Обычно Вы не должны касаться этой опции, потому
что она включена по умолчанию.</p>

<p><a href="glossary.htm#glos_asynchronous_io">Асинхронный I/O</a>,
который <code>InnoDB</code> имеет на системах Windows, доступен на системах
Linux. Другие подобные Unix системы продолжают использовать синхронный
ввод/вывод. Эта особенность улучшает масштабируемость в большой степени
систем, которые как правило показывают много чтений и записей в выводе
<code>SHOW ENGINE INNODB STATUS\G</code>.</p>

<p>Выполнение с большим количеством потоков ввода/вывода, а особенно
запуск нескольких экземпляров на той же самой машине сервера, могут
исчерпать пределы на системах Linux. В этом случае Вы можете
получить следующую ошибку:
<pre>
EAGAIN: The specified maxevents exceeds the user's limit of available events.
</pre>

<p>Вы можете, как правило, обращаться к этой ошибке при
записи более высокого предела в <code>/proc/sys/fs/aio-max-nr</code>.</p>
<p>Однако, если проблема с асинхронной подсистемой ввода/вывода в OS не дает
<code>InnoDB</code> запуститься, Вы можете запустить сервер с
<a href="#sysvar_innodb_use_native_aio"><code>
innodb_use_native_aio=0</code></a> в файле опции. Эта опция может также быть
выключена автоматически во время запуска, если <code>InnoDB</code>
обнаруживает потенциальную проблему, такую как комбинация
<code>tmpdir</code>, файловой системы <code>tmpfs</code> и ядра Linux,
которое не поддерживает AIO на <code>tmpfs</code>.</li>

<li><a name="sysvar_innodb_version"></a><code>innodb_version</code></p>
<p>Номер версии <code>InnoDB</code>. В 5.7 отдельная нумерация для
<code>InnoDB</code> не применяется и это значение то же самое, как
<a href="server.htm#sysvar_version"><code>version</code></a>.</li>

<li><a name="sysvar_innodb_write_io_threads"></a>
<code>innodb_write_io_threads</code></p>
<table border="1">
<tbody><tr><td><span><strong>Формат командной строки</strong></span></td>
<td colspan="3"><code>--innodb_write_io_threads=#</code></td></tr>
<tr><td rowspan="3"><span><strong>Системная переменная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_innodb_write_io_threads">
innodb_write_io_threads</a></code></td></tr>
<tr><td><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td rowspan="4"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>4</code></td></tr>
<tr><td><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>64</code></td></tr></tbody></table>

<p>Число потоков ввода/вывода для записи в <code>InnoDB</code>.
Значение по умолчанию 4. Его аналог для потоков чтения
<a href="#sysvar_innodb_read_io_threads"><code>
innodb_read_io_threads</code></a>. См.
<a href="#innodb-performance-multiple_io_threads">раздел 16.6.6
</a>.</p>

<p>В Linux, выполняя много серверов MySQL (как правило, больше 12) с
настройками по умолчанию для
<a href="#sysvar_innodb_read_io_threads"><code>
innodb_read_io_threads</code></a>, <code>innodb_write_io_threads</code>
и параметр Linux <code>aio-max-nr</code> могут превысить системные пределы.
Идеально увеличить <code>aio-max-nr</code>,
как обходное решение, Вы могли бы уменьшить настройки для одного или обоих
параметров конфигурации MySQL.</p>

<p>Вы должны также учесть значение
<a href="replica.htm#sysvar_sync_binlog"><code>sync_binlog</code></a>,
которое управляет синхронизацией двоичного журнала с диском.</p>
</p></li></ul>

<h2><a name="innodb-information-schema"></a>16.14.
Таблицы InnoDB INFORMATION_SCHEMA</h2>
<p>Этот раздел предоставляет информацию и примеры использования для таблиц
<code>InnoDB</code> <a href="inform.htm"><code>INFORMATION_SCHEMA</code></a>.
</p>

<p>Таблицы <code>InnoDB</code> <code>INFORMATION_SCHEMA</code>
обеспечивают метаданные, информацию о статусе и статистику о различных
аспектах механизма хранения <code>InnoDB</code>. Вы можете смотреть список
таблиц <code>InnoDB</code> <code>INFORMATION_SCHEMA</code> с помощью
<a href="sql.htm#show-tables"><code>SHOW TABLES</code></a> в базе
данных <code>INFORMATION_SCHEMA</code>:
<pre>
mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB%';
</pre>

<p>Для табличных определений см. <a href="inform.htm#innodb-i_s-tables">
раздел 22.30</a>. Для общей информации относительно базы данных
<code>MySQL</code> <code>INFORMATION_SCHEMA</code> см.
<a href="inform.htm">главу 22</a>.</p>

<h3><a name="innodb-information-schema-compression-tables"></a>
16.14.1. InnoDB INFORMATION_SCHEMA о сжатии</h3>
<p>Есть две пары таблиц <code>InnoDB</code> <code>INFORMATION_SCHEMA</code>
о сжатии, которые могут обеспечить понимание, как хорошо сжатие работает:</p>

<ul><li><p><a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP</code></a>
и <a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP_RESET</code></a>
содержат информацию о числе операций сжатия и количестве времени,
проведенного, выполняя сжатие.</li>

<li><a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM</code></a> и
<a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP_RESET</code></a>
содержат информацию о способе, которым память выделена для сжатия.
</p></li></ul>

<h4><a name="innodb-information-schema-innodb_cmp"></a>
16.14.1.1. INNODB_CMP и INNODB_CMP_RESET</h4>
<p><a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP</code></a> и
<a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP_RESET</code></a>
содержат информацию о статусе операций, связанных со сжатыми таблицами,
которые описаны в <a href="#innodb-compression">разделе 16.9</a>.
<code>PAGE_SIZE</code> сообщает о сжатом
<a href="glossary.htm#glos_page_size">размере страницы</a>.</p>

<p>У этих двух таблиц есть идентичное содержание, но чтение изж
<a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP_RESET</code></a>
сбрасывает статистику по операциям сжатия. Например, если Вы архивируете
вывод <a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP_RESET</code></a>
каждые 60 минут, Вы видите статистику в течение каждого почасового периода.
Если Вы контролируете вывод
<a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP</code></a>
(никогда не читая <a href="inform.htm#innodb-cmp-table"><code>
INNODB_CMP_RESET</code></a>), Вы видите накопленную статистику
с момента старта InnoDB.</p>
<p>См. <a href="inform.htm#innodb-cmp-table">раздел 22.30.5</a>.</p>

<h4><a name="innodb-information-schema-innodb_cmpmem"></a>
16.14.1.2. INNODB_CMPMEM и INNODB_CMPMEM_RESET</h4>
<p><a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM</code></a> и
<a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM_RESET</code></a>
содержат информацию о сжатых страницах, которые находятся в буферном пуле.
Пожалуйста, консультируйтесь с <a href="#innodb-compression">
разделом 16.9</a> для дополнительной информации о сжатых таблицах и
использовании буферного пула.
<a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP</code></a> и
<a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP_RESET</code></a>
должны обеспечить более полезную статистику по сжатию.</p>

<h5><a name="idm139965317700240"></a>Внутренние детали</h5>
<p><code>InnoDB</code> использует систему
<a href="glossary.htm#glos_buddy_allocator">распределителя</a>, чтобы
управлять памятью, выделенной
<a href="glossary.htm#glos_page_size">страницам различных размеров</a>,
от 1KB до 16KB. Каждая строка этих двух таблиц, описанных здесь,
соответствует единственному размеру страницы.</p>

<p><a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM</code></a> и
<a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM_RESET</code></a>
имеют идентичное содержание, но чтение
<a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM_RESET</code></a>
сбрасывает статистику по операциям перемещения. Например, если каждые 60
минут Вы заархивировали вывод
<a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM_RESET</code>
</a>, это показало бы почасовую статистику. Если Вы никогда не читаете
<a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM_RESET</code></a>
и читаете вывод <a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM
</code></a>, вместо этого, это показжет накопленную статистику с момента
запуска <code>InnoDB</code>.</p>
<p>См. <a href="inform.htm#innodb-cmpmem-table">раздел 22.30.6</a>.</p>

<h4><a name="innodb-information-schema-examples-compression-sect"></a>
16.14.1.3. Использование информации о сжатии</h4>
<a name="innodb-information-schema-examples-compression"></a><p><b>
Пример 16.10. Использование информации о сжатии</b></p>
<p>Следующее типовой вывод базы данных, которая содержит сжатые таблицы (см.
compressed tables (see <a href="#innodb-compression">раздел 16.9
</a>, <a href="inform.htm#innodb-cmp-table"><code>INNODB_CMP</code></a>,
<a href="inform.htm#innodb-cmp-per-index-table"><code>INNODB_CMP_PER_INDEX
</code></a> и <a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM
</code></a>).</p>

<p>Следующая таблица показывает содержание
<a href="inform.htm#innodb-cmp-table"><code>INFORMATION_SCHEMA.INNODB_CMP
</code></a> при легкой <a href="glossary.htm#glos_workload">рабочей нагрузке
</a>. Единственный сжатый размер страницы, который содержит буферный пул,
составляет 8K. Сжатие страниц потребляло меньше секунды времени,
статистические данные были сброшены, потому что столбцы
<code>COMPRESS_TIME</code> и <code>UNCOMPRESS_TIME</code> = 0.</p>

<a name="innodb-information-schema-sample-innodb_cmp"></a>
<table border="1">
<thead><tr><th>Размер страницы</th><th>compress ops</th>
<th>compress ops ok</th><th>compress time</th><th>uncompress ops</th>
<th>uncompress time</th></tr></thead>
<tbody><tr><td>1024</td><td>0</td><td>0</td><td>0</td><td>0</td>
<td>0</td></tr>
<tr><td>2048</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>4096</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>8192</td><td>1048</td><td>921</td><td>0</td><td>61</td>
<td>0</td></tr>
<tr><td>16384</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
</tr></tbody></table>

<p>Согласно <a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM
</code></a>, есть 6169 сжатых страницы по 8 КБ в
<a href="glossary.htm#glos_buffer_pool">буферном пуле</a>.
Единственный другой выделенный размер блока составляет 64 байта. Самый
маленький <code>PAGE_SIZE</code> в
<a href="inform.htm#innodb-cmpmem-table"><code>INNODB_CMPMEM</code></a>
используется для описателей блока тех сжатых страниц, для которых никакая
несжатая страница не существует в буферном пуле. Мы видим, что есть 5910
таких страниц. Косвенно мы видим, что 259 (6169-5910) сжатых страниц также
существуют в буферном пуле в несжатой форме.</p>

<p>Следующая таблица показывает содержание
<a href="inform.htm#innodb-cmpmem-table"><code>
INFORMATION_SCHEMA.INNODB_CMPMEM</code></a> при легкой
<a href="glossary.htm#glos_workload">рабочей нагрузке</a>.
Некоторая память непригодна из-за фрагментации распределителя памяти
для сжатых страниц: <code>SUM(PAGE_SIZE*PAGES_FREE)=6784</code>.
Это потому что маленькие запросы распределения памяти выполнены, разделяя
большие блоки, начиная с 16K блоков, которые выделены из основного буферного
пула, используя систему распределения. Фрагментация низкая потому, что
некоторые выделенные блоки были перемещены (скопированы), чтобы сформировать
большие смежные свободные блоки. Это копирование
<code>SUM(PAGE_SIZE*RELOCATION_OPS)</code> байт
потребляло меньше секунды <code>(SUM(RELOCATION_TIME)=0)</code>.</p>

<a name="innodb-information-schema-sample-innodb_cmpmem"></a>
<table border="1">
<thead><tr><th>Размер страницы</th><th>Страниц занято</th>
<th>Страниц свободно</th><th>relocation ops</th>
<th>relocation time</th></tr></thead>
<tbody><tr><td>64</td><td>5910</td><td>0</td><td>2436</td><td>0</td></tr>
<tr><td>128</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>256</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>512</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1024</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>2048</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>4096</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>8192</td><td>6169</td><td>0</td><td>5</td><td>0</td></tr>
<tr><td>16384</td><td>0</td><td>0</td><td>0</td><td>0</td>
</tr></tbody></table>

<h3><a name="innodb-information-schema-transactions"></a>16.14.2.
Информация о транзакциях и блокировках в InnoDB INFORMATION_SCHEMA</h3>
<p>Этот раздел описывает информацию о блокировке, предоставленную таблицами
Performance Schema <a href="perfor.htm#data-locks-table"><code>data_locks
</code></a> и <a href="perfor.htm#data-lock-waits-table"><code>
data_lock_waits</code></a>, которые заменяют <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-locks-table"><code>INNODB_LOCKS</code></a> и
<a href="inform.htm#innodb-lock-waits-table"><code>INNODB_LOCK_WAITS</code>
</a> в MySQL 8.0. Для подобного обсуждения, написанного с точки зрения более
старых таблиц <code>INFORMATION_SCHEMA</code>, см.
<a href="../../../dev.mysql.com/doc/refman/5.7/en/innodb-information-schema-transactions.html"
target="_top">InnoDB INFORMATION_SCHEMA Transaction and Locking Information
</a> в <a href="../../../dev.mysql.com/doc/refman/5.7/en/default.htm" target="_top">
MySQL 5.7 Reference Manual</a>.</p>

<p>Одна таблица <code>INFORMATION_SCHEMA</code> и две таблицы Performance
Schema позволяют Вам контролировать транзакции и диагностируют
потенциальные проблемы блокировки:</p>

<ul><li><p><a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>:
Эта таблица содержит информацию о каждой транзакции, в настоящее время
выполняющейся внутри <code>InnoDB</code>, включая операционное состояние
(например, работает ли это или ждет блокировки), когда транзакция запускалась
и запрос SQL, который транзакция выполняет.</li>

<li><p><a href="perfor.htm#data-locks-table"><code>data_locks</code></a>:
Эта таблица содержит содержит строку для каждой блокировки и каждого запроса
блокировки, который стоит, ожидая блокировки, которая будет выпущена:</p>

<ul><li><p>Есть одна строка для каждой проводимой блокировки, безотносительно
статуса транзакции, которая держит блокировку
(<code>INNODB_TRX.TRX_STATE</code> может быть
<code>RUNNING</code>, <code>LOCK WAIT</code>,
<code>ROLLING BACK</code> или <code>COMMITTING</code>).</li>

<li>Каждая транзакция в InnoDB, которая ждет другую транзакцию, чтобы
выпустить блокировку (<code>INNODB_TRX.TRX_STATE</code> = <code>LOCK
WAIT</code>) заблокирована точно одним запросом блокировки. Это запрос
блокировки для строки или табличной блокировки, проводимой другой транзакцией
в несовместимом режиме. У запроса блокировки всегда есть режим, который
является несовместимым с режимом проводимой блокировки, которая блокирует
запрос (чтение против записи, совместно
использованный против исключительного).</p>

<p>Заблокированная транзакция не может продолжиться, пока другая транзакция
не завершится, таким образом выпуская требуемую блокировку. Для каждой
заблокированной транзакции <a href="perfor.htm#data-locks-table"><code>
data_locks</code></a> содержит одну строку, которая описывает каждую
блокировку, которую транзакция просила, и которую это ждет.
</p></li></ul></li>

<li><p><a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits
</code></a>: Эта таблица показывает, какие транзакции ждут данной блокировки,
или которой блокировки данная транзакция ждет. Эта таблица содержит одну или
более строк для каждой заблокированной транзакции, указывая на блокировку,
которую это просило и любые блокировки, которые блокируют этот запрос.
<code>REQUESTING_ENGINE_LOCK_ID</code> обращается к блокировке, которую
требует транзакция, а <code>BLOCKING_ENGINE_LOCK_ID</code> обращается к
блокировке (проводимой другой транзакцией), которая препятствует тому, чтобы
первая транзакция продолжилась. Для любой данной заблокированной транзакции
все строки в <a href="perfor.htm#data-lock-waits-table"><code>
data_lock_waits</code></a> имеют то же самое значение для
<code>REQUESTING_ENGINE_LOCK_ID</code> и различные значения для
<code>BLOCKING_ENGINE_LOCK_ID</code>.</p></li></ul>

<p>См. разделы <a href="inform.htm#innodb-trx-table">22.30.28</a>,
<a href="perfor.htm#data-locks-table">23.9.12.1</a> и
<a href="perfor.htm#data-lock-waits-table">23.9.12.2</a>.</p>

<h4><a name="innodb-information-schema-examples"></a>16.14.2.1.
Использование информации о транзакции и блокировке</h4>
<p>Этот раздел описывает информацию о блокировке как выдано таблицами
<a href="perfor.htm#data-locks-table"><code>data_locks</code></a> и
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>,
которые заменяют <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-locks-table"><code>INNODB_LOCKS</code></a> и
<a href="inform.htm#innodb-lock-waits-table"><code>INNODB_LOCK_WAITS</code>
</a> в MySQL 8.0.</p>

<h5><a name="innodb-information-schema-examples-simple-blocking"></a>
Идентификация транзакций блокирования</h5>
<p>Иногда полезно идентифицировать, какая транзакция блокирует другую.
Таблицы, которые содержат информацию о транзакции и блокировке данных,
позволяют Вам определить, какая транзакция ждет другую и какой ресурс
требует. Для описаний этих таблиц см.
<a href="#innodb-information-schema-transactions">раздел 16.14.2
</a>.</p>

<p>Предположите, что три сеанса работают одновременно. Каждый сеанс
соответствует потоку MySQL и выполняет одну транзакцию за другой.
Рассмотрите состояние системы, когда эти сеансы сделали следующие запросы, но
ни один еще не передал свою транзакцию:</p>

<ul><li><p>
Session A:
<pre>
BEGIN;
SELECT a FROM t FOR UPDATE;
SELECT SLEEP(100);
</pre></li>

<li>
Session B:
<pre>
SELECT b FROM t FOR UPDATE;
</pre></li>

<li>
Session C:
<pre>
SELECT c FROM t FOR UPDATE;
</pre></li></ul>

<p>Используйте следующий запрос, чтобы видеть, какие транзакции ждут, а какие
транзакции блокируют их:
<pre>
SELECT r.trx_id waiting_trx_id, r.trx_mysql_thread_id waiting_thread,
       r.trx_query waiting_query, b.trx_id blocking_trx_id,
       b.trx_mysql_thread_id blocking_thread, b.trx_query blocking_query
       FROM performance_schema.data_lock_waits w
       INNER JOIN information_schema.innodb_trx b
       ON b.trx_id = w.blocking_engine_transaction_id
       INNER JOIN information_schema.innodb_trx r
       ON r.trx_id = w.requesting_engine_transaction_id;
</pre>

<p>Или, более просто, используйте представление
<a href="sys.htm#sys-innodb-lock-waits"><code>innodb_lock_waits</code></a>
в схеме <code>sys</code>:
<pre>
SELECT waiting_trx_id, waiting_pid, waiting_query, blocking_trx_id,
       blocking_pid, blocking_query FROM sys.innodb_lock_waits;
</pre>

<table border="1">
<thead><tr><th>waiting trx id</th><th>waiting thread</th>
<th>waiting query</th><th>blocking trx id</th><th>blocking thread</th>
<th>blocking query</th></tr></thead>
<tbody><tr><td><code>A4</code></td><td><code>6</code></td>
<td><code>SELECT b FROM t FOR UPDATE</code></td><td><code>A3</code></td>
<td><code>5</code></td><td><code>SELECT SLEEP(100)</code></td></tr>
<tr><td><code>A5</code></td><td><code>7</code></td>
<td><code>SELECT c FROM t FOR UPDATE</code></td><td><code>A3</code></td>
<td><code>5</code></td><td><code>SELECT SLEEP(100)</code></td></tr>
<tr><td><code>A5</code></td><td><code>7</code></td>
<td><code>SELECT c FROM t FOR UPDATE</code></td><td><code>A4</code></td>
<td><code>6</code></td><td><code>SELECT b FROM t FOR UPDATE</code>
</td></tr></tbody></table>

<p>В предыдущей таблице Вы можете идентифицировать сеансовые столбцы
<span><span>waiting query</span></span> или
<span><span>blocking query</span></span>:</p>

<ul><li><p>Session B (trx id <code>A4</code>, поток <code>6</code>) и
Session C (trx id <code>A5</code>, поток <code>7</code>) оба ждут
Session A (trx id <code>A3</code>, поток <code>5</code>).</li>
<li>Session C ждет Session B так же, как Session A.</p></li></ul>

<p>Вы можете видеть основные данные в
<code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a> и
Performance Schema <a href="perfor.htm#data-locks-table"><code>data_locks
</code></a> и <a href="perfor.htm#data-lock-waits-table"><code>
data_lock_waits</code></a>.</p>

<p>Следующая таблица показывает некоторое типовое содержание таблицы
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>.</p>
<a name="innodb-information-schema-examples-simple-blocking-trx"></a>
<table border="1">
<thead><tr><th>trx id</th><th>trx state</th><th>trx started</th>
<th>trx requested lock id</th><th>trx wait started</th><th>trx weight</th>
<th>trx mysql thread id</th><th>trx query</th></tr></thead>
<tbody><tr><td><code>A3</code></td><td><code>RUNNING</code></td>
<td><code>2008-01-15 16:44:54</code></td><td><code>NULL</code></td>
<td><code>NULL</code></td><td><code>2</code></td><td><code>5</code></td>
<td><code>SELECT SLEEP(100)</code></td></tr>
<tr><td><code>A4</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 16:45:09</code></td><td><code>A4:1:3:2</code></td>
<td><code>2008-01-15 16:45:09</code></td><td><code>2</code></td>
<td><code>6</code></td><td><code>SELECT b FROM t FOR UPDATE</code></td></tr>
<tr><td><code>A5</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 16:45:14</code></td><td><code>A5:1:3:2</code></td>
<td><code>2008-01-15 16:45:14</code></td><td><code>2</code></td>
<td><code>7</code></td><td><code>SELECT c FROM t FOR UPDATE</code>
</td></tr></tbody></table>

<p>Следующая таблица показывает некоторое типовое содержание таблицы
<a href="perfor.htm#data-locks-table"><code>data_locks</code></a>.</p>
<a name="innodb-information-schema-examples-simple-blocking-locks"></a>
<table border="1">
<thead><tr><th>lock id</th><th>lock trx id</th><th>lock mode</th>
<th>lock type</th><th>lock schema</th><th>lock table</th><th>lock index</th>
<th>lock data</th></tr></thead>
<tbody><tr><td><code>A3:1:3:2</code></td><td><code>A3</code></td>
<td><code>X</code></td><td><code>RECORD</code></td><td><code>test</code></td>
<td><code>t</code></td><td><code>PRIMARY</code></td><td><code>0x0200</code>
</td></tr>
<tr><td><code>A4:1:3:2</code></td><td><code>A4</code></td>
<td><code>X</code></td><td><code>RECORD</code></td><td><code>test</code></td>
<td><code>t</code></td><td><code>PRIMARY</code></td><td><code>0x0200</code>
</td></tr>
<tr><td><code>A5:1:3:2</code></td><td><code>A5</code></td>
<td><code>X</code></td><td><code>RECORD</code></td><td><code>test</code></td>
<td><code>t</code></td><td><code>PRIMARY</code></td><td><code>0x0200</code>
</td></tr></tbody></table>

<p>Следующая таблица показывает некоторое типовое содержание таблицы
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>.
</p>
<a name="innodb-information-schema-examples-simple-blocking-waits"></a>
<table border="1">
<thead><tr><th>requesting trx id</th><th>requested lock id</th>
<th>blocking trx id</th><th>blocking lock id</th></tr></thead>
<tbody><tr><td><code>A4</code></td><td><code>A4:1:3:2</code></td>
<td><code>A3</code></td><td><code>A3:1:3:2</code></td></tr>
<tr><td><code>A5</code></td><td><code>A5:1:3:2</code></td>
<td><code>A3</code></td><td><code>A3:1:3:2</code></td></tr>
<tr><td><code>A5</code></td><td><code>A5:1:3:2</code></td>
<td><code>A4</code></td><td><code>A4:1:3:2</code></td></tr></tbody></table>

<h5><a name="innodb-information-schema-sample-locks"></a>
Корреляция транзакций InnoDB с сеансами MySQL</h5>
<p>Иногда полезно коррелировать внутреннюю информацию блокировок
<code>InnoDB</code> с информацией на уровне сеанса MySQL.
Например, Вам могло бы понадобиться знать для данного ID транзакции
соответствующий MySQL session ID и название сеанса, который может держать
блокировку, и таким образом блокировать другие транзакции.</p>

<p>Следующий вывод <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a> и
Performance Schema <a href="perfor.htm#data-locks-table"><code>data_locks
</code></a> и <a href="perfor.htm#data-lock-waits-table"><code>
data_lock_waits</code></a> взят от загруженной системы. Как может быть
замечено, есть несколько транзакций.</p>

<p>Следующие таблицы <a href="perfor.htm#data-locks-table"><code>data_locks
</code></a> и <a href="perfor.htm#data-lock-waits-table"><code>
data_lock_waits</code></a> показывают, что:</p>

<ul><li><p>Транзакция <code>77F</code> (выполняет
<a href="sql.htm#insert"><code>INSERT</code></a>) ждет транзакции
<code>77E</code>, <code>77D</code> и <code>77B</code>.</li>

<li>Транзакция <code>77E</code> (выполняет
<a href="sql.htm#insert"><code>INSERT</code></a>) ждет транзакции
<code>77D</code> и <code>77B</code>.</li>

<li>Транзакция <code>77D</code> (выполняет
<a href="sql.htm#insert"><code>INSERT</code></a>) ждет транзакцию
<code>77B</code>.</li>

<li>Транзакция <code>77B</code> (выполняет
<a href="sql.htm#insert"><code>INSERT</code></a>) ждет транзакцию
<code>77A</code>.</li>

<li>Транзакция <code>77A</code> работает, в настоящее время выполняя
<a href="sql.htm#select"><code>SELECT</code></a>.</li>
<li>Транзакция <code>E56</code> (выполняет
<a href="sql.htm#insert"><code>INSERT</code></a>) ждет транзакцию
<code>E55</code>.</li>

<li>Транзакция <code>E55</code> (выполняет
<a href="sql.htm#insert"><code>INSERT</code></a>) ждет транзакцию
<code>19C</code>.</li>
<li>Транзакция <code>19C</code> работает, в настоящее время выполняя
<a href="sql.htm#insert"><code>INSERT</code></a>.</p></li></ul>

<p>Могут быть несогласованности между запросами, показанными в таблицах
<code>INFORMATION_SCHEMA</code> <a href="inform.htm#processlist-table">
<code>PROCESSLIST</code></a> и <a href="inform.htm#innodb-trx-table"><code>
INNODB_TRX</code></a>. См.
<a href="#innodb-information-schema-internal-data">раздел 16.14.2.3
</a>.</p>

<p>Следующая таблица показывает содержание таблицы
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a>
для системы, выполняющей тяжелую
<a href="glossary.htm#glos_workload">рабочую нагрузку</a>.</p>

<a name="innodb-information-schema-sample-processlist"></a>
<table border="1">
<thead><tr><th>ID</th><th>USER</th><th>HOST</th><th>DB</th>
<th>COMMAND</th><th>TIME</th><th>STATE</th><th>INFO</th></tr></thead>
<tbody><tr><td><code>384</code></td><td><code>root</code></td>
<td><code>localhost</code></td><td><code>test</code></td>
<td><code>Query</code></td><td><code>10</code></td>
<td><code>update</code></td><td><code>INSERT INTO t2 VALUES ...
</code></td></tr>
<tr><td><code>257</code></td><td><code>root</code></td>
<td><code>localhost</code></td><td><code>test</code></td>
<td><code>Query</code></td><td><code>3</code></td><td><code>update</code>
</td><td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr>
<tr><td><code>130</code></td><td><code>root</code></td>
<td><code>localhost</code></td><td><code>test</code></td><td><code>Query
</code></td><td><code>0</code></td><td><code>update</code></td>
<td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr>
<tr><td><code>61</code></td><td><code>root</code></td>
<td><code>localhost</code></td><td><code>test</code></td><td><code>Query
</code></td><td><code>1</code></td><td><code>update</code></td>
<td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr>
<tr><td><code>8</code></td><td><code>root</code></td>
<td><code>localhost</code></td><td><code>test</code></td><td><code>Query
</code></td><td><code>1</code></td><td><code>update</code></td>
<td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr>
<tr><td><code>4</code></td><td><code>root</code></td>
<td><code>localhost</code></td><td><code>test</code></td>
<td><code>Query</code></td><td><code>0</code></td>
<td><code>preparing</code></td><td><code>SELECT * FROM PROCESSLIST</code>
</td></tr>
<tr><td><code>2</code></td><td><code>root</code></td>
<td><code>localhost</code></td><td><code>test</code></td>
<td><code>Sleep</code></td><td><code>566</code></td><td><code></code></td>
<td><code>NULL</code></td></tr></tbody></table>

<p>Следующая таблица показывает содержание
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>
для системы, выполняющей тяжелую
<a href="glossary.htm#glos_workload">рабочую нагрузку</a>.</p>

<a name="innodb-information-schema-sample-innodb-trx"></a>
<table border="1">
<thead><tr><th>trx id</th><th>trx state</th><th>trx started</th>
<th>trx requested lock id</th><th>trx wait started</th><th>trx weight</th>
<th>trx mysql thread id</th><th>trx query</th></tr></thead>
<tbody><tr><td><code>77F</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>77F</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>1</code></td>
<td><code>876</code></td><td><code>INSERT INTO t09 (D, B, C) VALUES ...
</code></td></tr>
<tr><td><code>77E</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>77E</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>1</code></td>
<td><code>875</code></td><td><code>INSERT INTO t09 (D, B, C) VALUES ...
</code></td></tr>
<tr><td><code>77D</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>77D</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>1</code></td>
<td><code>874</code></td><td><code>INSERT INTO t09 (D, B, C) VALUES ...
</code></td></tr>
<tr><td><code>77B</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>77B:733:12:1</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>4</code></td>
<td><code>873</code></td><td><code>INSERT INTO t09 (D, B, C) VALUES ...
</code></td></tr>
<tr><td><code>77A</code></td><td><code>RUNб╜NING</code></td>
<td><code>2008-01-15 13:10:16</code></td><td><code>NULL</code></td>
<td><code>NULL</code></td><td><code>4</code></td><td><code>872</code></td>
<td><code>SELECT b, c FROM t09 WHERE Б─╕</code></td></tr>
<tr><td><code>E56</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 13:10:06</code></td><td><code>E56:743:6:2</code></td>
<td><code>2008-01-15 13:10:06</code></td><td><code>5</code></td>
<td><code>384</code></td><td><code>INSERT INTO t2 VALUES ...</code></td></tr>
<tr><td><code>E55</code></td><td><code>LOCK WAIT</code></td>
<td><code>2008-01-15 13:10:06</code></td><td><code>E55:743:38:2</code></td>
<td><code>2008-01-15 13:10:13</code></td><td><code>965</code></td>
<td><code>257</code></td><td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr>
<tr><td><code>19C</code></td><td><code>RUNб╜NING</code></td>
<td><code>2008-01-15 13:09:10</code></td><td><code>NULL</code></td>
<td><code>NULL</code></td><td><code>2900</code></td><td><code>130</code></td>
<td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr>
<tr><td><code>E15</code></td><td><code>RUNNING</code></td>
<td><code>2008-01-15 13:08:59</code></td><td><code>NULL</code></td>
<td><code>NULL</code></td><td><code>5395</code></td><td><code>61</code></td>
<td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr>
<tr><td><code>51D</code></td><td><code>RUNб╜NING</code></td>
<td><code>2008-01-15 13:08:47</code></td><td><code>NULL</code></td>
<td><code>NULL</code></td><td><code>9807</code></td><td><code>8</code></td>
<td><code>INSERT INTO t2 VALUES Б─╕</code></td></tr></tbody></table>

<p>Следующая таблица показывает содержание
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>
для системы, выполняющей тяжелую
<a href="glossary.htm#glos_workload">рабочую нагрузку</a>.</p>

<a name="innodb-information-schema-sample-innodb-lock-waits"></a>
<table border="1">
<thead><tr><th>requesting trx id</th><th>requested lock id</th>
<th>blocking trx id</th><th>blocking lock id</th></tr></thead>
<tbody><tr><td><code>77F</code></td><td><code>77F:806</code></td>
<td><code>77E</code></td><td><code>77E:806</code></td></tr>
<tr><td><code>77F</code></td><td><code>77F:806</code></td>
<td><code>77D</code></td><td><code>77D:806</code></td></tr>
<tr><td><code>77F</code></td><td><code>77F:806</code></td>
<td><code>77B</code></td><td><code>77B:806</code></td></tr>
<tr><td><code>77E</code></td><td><code>77E:806</code></td>
<td><code>77D</code></td><td><code>77D:806</code></td></tr>
<tr><td><code>77E</code></td><td><code>77E:806</code></td>
<td><code>77B</code></td><td><code>77B:806</code></td></tr>
<tr><td><code>77D</code></td><td><code>77D:806</code></td>
<td><code>77B</code></td><td><code>77B:806</code></td></tr>
<tr><td><code>77B</code></td><td><code>77B:733:12:1</code></td>
<td><code>77A</code></td><td><code>77A:733:12:1</code></td></tr>
<tr><td><code>E56</code></td><td><code>E56:743:6:2</code></td>
<td><code>E55</code></td><td><code>E55:743:6:2</code></td></tr>
<tr><td><code>E55</code></td><td><code>E55:743:38:2</code></td>
<td><code>19C</code></td><td><code>19C:743:38:2</code></td>
</tr></tbody></table>

<p>Следующая таблица показывает содержание
<a href="perfor.htm#data-locks-table"><code>data_locks</code></a>
для системы, выполняющей тяжелую <a href="glossary.htm#glos_workload">
рабочую нагрузку</a>.</p>

<a name="innodb-information-schema-sample-innodb-locks"></a>
<table border="1">
<thead><tr><th>lock id</th><th>lock trx id</th><th>lock mode</th>
<th>lock type</th><th>lock schema</th><th>lock table</th><th>lock index</th>
<th>lock data</th></tr></thead>
<tbody><tr><td><code>77F:806</code></td><td><code>77F</code></td><td><code>
AUTO_INC</code></td><td><code>TABLE</code></td><td><code>test</code></td><td>
<code>t09</code></td><td><code>NULL</code></td><td><code>NULL</code></td></tr>
<tr><td><code>77E:806</code></td><td><code>77E</code></td><td><code>AUTO_INC
</code></td><td><code>TABLE</code></td><td><code>test</code></td><td><code>
t09</code></td><td><code>NULL</code></td><td><code>NULL</code></td></tr>
<tr><td><code>77D:806</code></td><td><code>77D</code></td><td><code>AUTO_INC
</code></td><td><code>TABLE</code></td><td><code>test</code></td><td><code>
t09</code></td><td><code>NULL</code></td><td><code>NULL</code></td></tr>
<tr><td><code>77B:806</code></td><td><code>77B</code></td><td><code>AUTO_INC
</code></td><td><code>TABLE</code></td><td><code>test</code></td><td><code>
t09</code></td><td><code>NULL</code></td><td><code>NULL</code></td></tr>
<tr><td><code>77B:733:12:1</code></td><td><code>77B</code></td><td><code>X
</code></td><td><code>RECORD</code></td><td><code>test</code></td><td><code>
t09</code></td><td><code>PRIMARY</code></td><td><code>supremum pseudo-record
</code></td></tr>
<tr><td><code>77A:733:12:1</code></td><td><code>77A</code></td><td><code>X
</code></td><td><code>RECORD</code></td><td><code>test</code></td><td><code>
t09</code></td><td><code>PRIMARY</code></td><td><code>supremum pseudo-record
</code></td></tr>
<tr><td><code>E56:743:6:2</code></td><td><code>E56</code></td><td><code>S
</code></td><td><code>RECORD</code></td><td><code>test</code></td><td><code>
t2</code></td><td><code>PRIMARY</code></td><td><code>0, 0</code></td></tr>
<tr><td><code>E55:743:6:2</code></td><td><code>E55</code></td><td><code>X
</code></td><td><code>RECORD</code></td><td><code>test</code></td><td><code>
t2</code></td><td><code>PRIMARY</code></td><td><code>0, 0</code></td></tr>
<tr><td><code>E55:743:38:2</code></td><td><code>E55</code></td><td><code>S
</code></td><td><code>RECORD</code></td><td><code>test</code></td><td><code>
t2</code></td><td><code>PRIMARY</code></td><td><code>1922, 1922</code></td>
</tr>
<tr><td><code>19C:743:38:2</code></td><td><code>19C</code></td><td><code>X
</code></td><td><code>RECORD</code></td><td><code>test</code></td><td><code>
t2</code></td><td><code>PRIMARY</code></td><td><code>1922, 1922</code></td>
</tr></tbody></table>

<h4><a name="innodb-information-schema-understanding-innodb-locking"></a>
16.14.2.2. Информация о блокировках InnoDB</h4>
<p>Этот раздел описывает информацию о блокировке как выставлено таблицами
Performance Schema <a href="perfor.htm#data-locks-table"><code>data_locks
</code></a> и <a href="perfor.htm#data-lock-waits-table"><code>
data_lock_waits</code></a>, которые заменяют
supersede the <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-locks-table"><code>INNODB_LOCKS</code></a> и
<a href="inform.htm#innodb-lock-waits-table"><code>INNODB_LOCK_WAITS</code>
</a> в MySQL 8.0.</p>

<p>Когда транзакция обновляет строку в таблице или блокирует ее с
<code>SELECT FOR UPDATE</code>, <code>InnoDB</code>
составляет список или очередь блокировок этой строки. Точно так же
<code>InnoDB</code> поддерживает список для блокировок на уровне таблицы.
Если вторая транзакция хочет обновить строку или заблокировать таблицу, уже
заблокированную предшествующей транзакцией в несовместимом режиме,
<code>InnoDB</code> добавляет запрос блокировки строки в соответствующую
очередь. Для блокировки, которая будет приобретена транзакцией, все
несовместимые запросы блокировки ранее вступившие в очередь блокировки для
той строки или таблицы, должны быть удалены.</p>

<p>У транзакции может быть любое число запросов блокировки о различных
строках или таблицах. В любой момент времени, транзакция может просить
блокировку, которая проводится другой транзакцией, тогда это заблокировано
той другой транзакцией. Если транзакция не ждет блокировки, она находится в
в состоянии <code>RUNNING</code>. Если транзакция ждет блокировки, это
находится в состоянии <code>LOCK WAIT</code>. <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>
показывает значения статуса транзакций.</p>

<p>Performance Schema <a href="perfor.htm#data-locks-table"><code>
data_locks</code></a> содержит одну или более строк для каждой транзакции
<code>LOCK WAIT</code>, указывая на любые запросы блокировки, которые
предотвращают ее продвижение. Эта таблица также содержит одну строку,
описывающую каждую блокировку в очереди блокировок, ожидающих для данной
строки или таблицы. Performance Schema
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>
показывает, которые блокировки, уже проводимые транзакцией, блокируют
блокировки, которые требуют другие транзакции.</p>

<h4><a name="innodb-information-schema-internal-data"></a>
16.14.2.3. Постоянство и последовательность информации о
транзакции и блокировке InnoDB</h4>
<p>Этот раздел описывает информацию о блокировке как выставлено
Performance Schema <a href="perfor.htm#data-locks-table"><code>data_locks
</code></a> и <a href="perfor.htm#data-lock-waits-table"><code>
data_lock_waits</code></a>, которые заменяют <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-locks-table"><code>INNODB_LOCKS</code></a> и
<a href="inform.htm#innodb-lock-waits-table"><code>INNODB_LOCK_WAITS</code>
</a> в MySQL 8.0.</p>

<p>Данные, выставленные транзакцией и таблицами блокировки
(<code>INFORMATION_SCHEMA</code> <a href="inform.htm#innodb-trx-table"><code>
INNODB_TRX</code></a>, Performance Schema
<a href="perfor.htm#data-locks-table"><code>data_locks</code></a> и
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>)
представляют быстро изменяющиеся данные. Это не походит на пользовательские
таблицы, где данные изменяются только, когда происходят обновления в
приложении. Основные данные это внутренние управляемые системой данные, они
могут измениться очень быстро:</p>

<ul><li><p>Данные не могли бы быть последовательными между таблицами
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>,
<a href="perfor.htm#data-locks-table"><code>data_locks</code></a> и
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>.
</p>

<p><a href="perfor.htm#data-locks-table"><code>data_locks</code></a> и
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>
выставляют живые данные от механизма хранения <code>InnoDB</code>,
чтобы обеспечить информацию о блокировках и транзакциях в таблице
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>.
Данные, полученные от таблиц блокировки, существуют, когда выполняется
<a href="sql.htm#select"><code>SELECT</code></a>, но могут измениться к тому
времени, когда результат запроса потребляется клиентом.</p>

<p>Объединение <a href="perfor.htm#data-locks-table"><code>data_locks</code>
</a> с <a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits
</code></a> может показать строки в
<a href="perfor.htm#data-lock-waits-table"><code>data_lock_waits</code></a>,
это идентифицирует родительскую строку в
<a href="perfor.htm#data-locks-table"><code>data_locks</code></a>,
которая больше не существует или еще не существует.</li>

<li>Данные в транзакции и таблицах блокировки не могли бы быть совместимыми с
данными в <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a> или
Performance Schema <a href="perfor.htm#threads-table"><code>threads</code>
</a>.</p>

<p>Например, Вы должны быть осторожными, сравнивая данные в
таблицах транзакций и блокировок с данными в
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a>.
Даже если Вы выпускаете один <code>SELECT</code> (например, объединяя
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a> и
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a>),
контент тех таблиц вообще не последователен. Для возможно
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a> ссылаться
на строки, которые не присутствуют в
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a>
или для транзакции в настоящее время выполняющегося запроса SQL, показанной в
or for the <code>INNODB_TRX.TRX_QUERY</code> отличаться от связанных данных в
<code>PROCESSLIST.INFO</code>.</p></li></ul>

<h3><a name="innodb-information-schema-system-tables"></a>16.14.3.
Системные таблицы InnoDB INFORMATION_SCHEMA</h3>
<p>Вы можете извлечь метаданные об объектах схемы, которыми управляет
<code>InnoDB</code>, используя системные таблицы <code>InnoDB</code>
<code>INFORMATION_SCHEMA</code>. Эта информация прибывает из
внутренних системных таблиц <code>InnoDB</code> (словарь данных),
который не может быть запрошен непосредственно, как обычные таблицы.
Традиционно Вы получили бы этот тип информации, используя методы из
<a href="#innodb-monitors">раздела 16.16</a>, настраивая
мониторинг и парсинг вывода <a href="sql.htm#show-engine"><code>
SHOW ENGINE INNODB STATUS</code></a>. Таблицы <code>INFORMATION_SCHEMA</code>
позволяют Вам запрашивать эти данные, используя SQL.</p>

<p>За исключением <a href="inform.htm#innodb-sys-tablestats-table"><code>
INNODB_SYS_TABLESTATS</code></a>, для которого нет никакой соответствующей
внутренней системной таблицы, системные таблицы <code>INFORMATION_SCHEMA
</code> заполнены чтением данных непосредственно от внутренних
системных таблиц, а не от метаданных, которые кэшируются в памяти.</p>

<p>Системные таблицы <code>INFORMATION_SCHEMA</code>
включают упомянутые ниже таблицы.
<a href="inform.htm#innodb-sys-datafiles-table"><code>INNODB_SYS_DATAFILES
</code></a> и <a href="inform.htm#innodb-sys-tablespaces-table"><code>
INNODB_SYS_TABLESPACES</code></a> были включены с введением поддержки
параметра <code>DATA DIRECTORY='<em><code>directory</code></em>'</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>, который
позволяет создавать табличные пространства
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
(файлы <code>.ibd</code>) вне каталога данных MySQL.
<pre>
mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_SYS%';
+--------------------------------------------+
| Tables_in_information_schema (INNODB_SYS%) |
+--------------------------------------------+
| INNODB_SYS_DATAFILES                       |
| INNODB_SYS_TABLESTATS                      |
| INNODB_SYS_FOREIGN                         |
| INNODB_SYS_COLUMNS                         |
| INNODB_SYS_INDEXES                         |
| INNODB_SYS_FIELDS                          |
| INNODB_SYS_TABLESPACES                     |
| INNODB_SYS_FOREIGN_COLS                    |
| INNODB_SYS_TABLES                          |
+--------------------------------------------+
</pre>

<p>Имена таблиц показательны из типа обеспеченных данных:</p>
<ul><li><p><a href="inform.htm#innodb-sys-tables-table"><code>
INNODB_SYS_TABLES</code></a> обеспечивает метаданные о таблицах,
эквивалентные информации в <code>SYS_TABLES</code> в словаре данных.</li>

<li><a href="inform.htm#innodb-sys-columns-table"><code>INNODB_SYS_COLUMNS
</code></a> обеспечивает метаданные о столбцах таблицы, эквивалентные
информации в <code>SYS_COLUMNS</code> в словаре данных.</li>

<li><a href="inform.htm#innodb-sys-indexes-table"><code>INNODB_SYS_INDEXES
</code></a> обеспечивает метаданные об индексах, эквивалентные информации в
<code>SYS_INDEXES</code> в словаре данных.</li>

<li><a href="inform.htm#innodb-sys-fields-table"><code>INNODB_SYS_FIELDS
</code></a> обеспечивает метаданные о ключевых столбцах (полях) индексов,
эквивалентные информации в <code>SYS_FIELDS</code>.</li>

<li><a href="inform.htm#innodb-sys-tablestats-table"><code>
INNODB_SYS_TABLESTATS</code></a> обеспечивает представление низкоуровневой
информации о статусе о таблицах, который получен из структур данных в памяти.
Нет никакой внутренней передачи системной таблицы.</li>

<li><a href="inform.htm#innodb-sys-datafiles-table"><code>
INNODB_SYS_DATAFILES</code></a> предоставляет информацию о пути файла с
данными для file-per-table и общих табличных пространствах,
эквивалентную информации в <code>SYS_DATAFILES</code>.</li>

<li><a href="inform.htm#innodb-sys-tablespaces-table"><code>
INNODB_SYS_TABLESPACES</code></a> обеспечивает метаданные о file-per-table и
общих табличных пространствах, эквивалентную информации в
<code>SYS_TABLESPACES</code>.</li>

<li><a href="inform.htm#innodb-sys-foreign-table"><code>INNODB_SYS_FOREIGN
</code></a> обеспечивает метаданные о внешних ключах, определенных на
таблицах, эквивалентную информации в <code>SYS_FOREIGN</code>.</li>

<li><a href="inform.htm#innodb-sys-foreign-cols-table"><code>
INNODB_SYS_FOREIGN_COLS</code></a> обеспечивает метаданные о столбцах внешних
ключей, которые определены на таблицах, эквивалентную информации в
<code>SYS_FOREIGN_COLS</code>.</p></li></ul>

<p>Системные таблицы <code>InnoDB</code> <code>INFORMATION_SCHEMA</code>
могут быть объединены через такие поля, как
<code>TABLE_ID</code>, <code>INDEX_ID</code> и <code>SPACE</code>, позволяя
Вам легко получить все доступные данные для объекта.</p>

<a name="innodb-information-schema-system-tables-example"></a>
<p><b>Пример 16.11. Системные таблицы InnoDB INFORMATION_SCHEMA</b></p>
<p>Этот пример использует простую таблицу (<code>t1</code>) с одним индексом
(<code>i1</code>), чтобы продемонстрировать тип метаданных, найденных в
системных таблицах <code>INFORMATION_SCHEMA</code>.</p>

<ol type="1"><li><p>Создайте испытательную базу данных и таблицу
<code>t1</code>:
<pre>
mysql&gt; CREATE DATABASE test;
mysql&gt; USE test;
mysql&gt; CREATE TABLE t1 (col1 INT, col2 CHAR(10), col3 VARCHAR(10))
                 ENGINE = InnoDB;
mysql&gt; CREATE INDEX i1 ON t1(col1);
</pre></li>

<li>После составления таблицы <code>t1</code>, запросите
<a href="inform.htm#innodb-sys-tables-table"><code>INNODB_SYS_TABLES</code>
</a>, чтобы определить местонахождение метаданных для <code>test/t1</code>:
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES
                   WHERE NAME='test/t1' \G
*************************** 1. row ***************************
 TABLE_ID: 71
 NAME: test/t1
 FLAG: 1
   N_COLS: 6
SPACE: 57
   ROW_FORMAT: Compact
ZIP_PAGE_SIZE: 0
...
</pre>

<p>Таблица <code>t1</code> имеет <code>TABLE_ID</code> 71. Поле
<code>FLAG</code> предоставляет информацию о характеристиках хранения и
формате таблицы. Есть шесть столбцов, три из которых являются скрытыми
столбцами, создаваемыми <code>InnoDB</code> (<code>DB_ROW_ID</code>,
<code>DB_TRX_ID</code> и <code>DB_ROLL_PTR</code>). ID таблицы
<code>SPACE</code> 57 (0 указало бы, что таблица находится в системном
табличном пространстве). <code>ROW_FORMAT</code> Compact.
<code>ZIP_PAGE_SIZE</code> относится только к таблицам с
форматом строки <code>Compressed</code>.</li>

<li>Используя <code>TABLE_ID</code> information из
<a href="inform.htm#innodb-sys-tables-table"><code>INNODB_SYS_TABLES</code>
</a>, запросите <a href="inform.htm#innodb-sys-columns-table"><code>
INNODB_SYS_COLUMNS</code></a> для информации о столбцах таблицы.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_COLUMNS
                 where TABLE_ID = 71 \G
*************************** 1. row ***************************
TABLE_ID: 71
NAME: col1
 POS: 0
   MTYPE: 6
  PRTYPE: 1027
 LEN: 4
*************************** 2. row ***************************
TABLE_ID: 71
NAME: col2
 POS: 1
   MTYPE: 2
  PRTYPE: 524542
 LEN: 10
*************************** 3. row ***************************
TABLE_ID: 71
NAME: col3
 POS: 2
   MTYPE: 1
  PRTYPE: 524303
 LEN: 10
</pre>

<p>В дополнение к <code>TABLE_ID</code> и столбцу <code>NAME</code>
<a href="inform.htm#innodb-sys-columns-table"><code>INNODB_SYS_COLUMNS</code>
</a> обеспечивает порядковую позицию (<code>POS</code>) каждого столбца
(с 0 и постепенно увеличивающуюся последовательно), <code>MTYPE</code> или
<span><span>main type</span></span> столбца (6 = INT, 2 = CHAR, 1 = VARCHAR),
<code>PRTYPE</code> или <span><span>precise type</span></span>
(двоичное значение с битами, которые представляют тип данных MySQL, код
набора символов и null) и длину столбца (<code>LEN</code>).</li>

<li>Используя <code>TABLE_ID</code> из
<a href="inform.htm#innodb-sys-tables-table"><code>INNODB_SYS_TABLES</code>
</a> еще раз, запросите <a href="inform.htm#innodb-sys-indexes-table"><code>
INNODB_SYS_INDEXES</code></a> для информации об индексе, связанном с таблицей
<code>t1</code>.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_INDEXES
                 WHERE TABLE_ID = 71 \G
*************************** 1. row ***************************
   INDEX_ID: 111
 NAME: GEN_CLUST_INDEX
   TABLE_ID: 71
 TYPE: 1
   N_FIELDS: 0
PAGE_NO: 3
SPACE: 57
MERGE_THRESHOLD: 50
*************************** 2. row ***************************
   INDEX_ID: 112
 NAME: i1
   TABLE_ID: 71
 TYPE: 0
   N_FIELDS: 1
PAGE_NO: 4
SPACE: 57
MERGE_THRESHOLD: 50
</pre>

<p><a href="inform.htm#innodb-sys-indexes-table"><code>INNODB_SYS_INDEXES
</code></a> возвращает данные о двух индексах. Первый индекс
<code>GEN_CLUST_INDEX</code>, который является кластеризируемым,
создается <code>InnoDB</code>, если у таблицы нет определяемого
пользователем кластеризуемого индекса. Второй индекс (<code>i1</code>) это
определяемый пользователем вторичный индекс.</p>

<p><code>INDEX_ID</code> идентификатор для индекса, который уникален для
всех баз данных сервера. <code>TABLE_ID</code> идентифицирует таблицу, с
которой связан индекс. Значение индекса <code>TYPE</code> указывает тип
индекса (1 = Кластеризируемый, 0 = Вторичный). <code>N_FILEDS</code>
число полей, которые включает индекс. <code>PAGE_NO</code> номер страницы
корня индекса B-tree, <code>SPACE</code> ID табличного пространства, где
индекс находится. Ненулевое значение указывает, что индекс не находится в
системном табличном пространстве. <code>MERGE_THRESHOLD</code>
определяет пороговое значение процента для объема данных в индексной
странице. Если объем данных в индексной странице падает ниже этого значения
(по умолчанию составляет 50%), когда строка удалена или когда строка
сокращена работой обновления, <code>InnoDB</code> пытается
слить индексную страницу с соседней индексной страницей.</li>

<li>Используя <code>INDEX_ID</code> из
<a href="inform.htm#innodb-sys-indexes-table"><code>INNODB_SYS_INDEXES</code>
</a>, запросите <a href="inform.htm#innodb-sys-fields-table"><code>
INNODB_SYS_FIELDS</code></a> для информации о полях индекса <code>i1</code>.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FIELDS
                 where INDEX_ID = 112 \G
*************************** 1. row ***************************
INDEX_ID: 112
NAME: col1
 POS: 0
</pre>

<p><a href="inform.htm#innodb-sys-fields-table"><code>INNODB_SYS_FIELDS
</code></a> обеспечивает <code>NAME</code> из индексированной области и ее
порядковую позицию в пределах индекса. Если индекс (i1) был определен на
несукольких полях, <a href="inform.htm#innodb-sys-fields-table"><code>
INNODB_SYS_FIELDS</code></a> обеспечил бы метаданные для каждой
из индексированных областей.</li>

<li>Используя <code>SPACE</code> из
<a href="inform.htm#innodb-sys-tables-table"><code>INNODB_SYS_TABLES</code>
</a>, запросите <a href="inform.htm#innodb-sys-tablespaces-table"><code>
INNODB_SYS_TABLESPACES</code></a> для информации о
табличном пространстве таблицы.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES
                 WHERE SPACE = 57 \G
*************************** 1. row ***************************
SPACE: 57
 NAME: test/t1
 FLAG: 0
   ROW_FORMAT: Compact or Redundant
PAGE_SIZE: 16384
ZIP_PAGE_SIZE: 0
</pre>

<p>В дополнение к <code>SPACE</code> ID табличного пространства и
<code>NAME</code> из связанной таблицы,
<a href="inform.htm#innodb-sys-tablespaces-table"><code>
INNODB_SYS_TABLESPACES</code></a> обеспечивает данные <code>FLAG</code>
табличного пространства, которые являются разрядной информацией о формате
табличного пространства и характеристиках хранения. Также обеспечены
параметры табличного пространства <code>ROW_FORMAT</code>,
<code>PAGE_SIZE</code> и <code>ZIP_PAGE_SIZE</code>
(<code>ZIP_PAGE_SIZE</code> применим к табличным пространствам с
форматом строки <code>Compressed</code>).</li>

<li>Используя <code>SPACE</code> из
<a href="inform.htm#innodb-sys-tables-table"><code>INNODB_SYS_TABLES</code>
</a>, запросите <a href="inform.htm#innodb-sys-datafiles-table"><code>
INNODB_SYS_DATAFILES</code></a> для местоположения файла с
данными табличного пространства.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_DATAFILES
                 WHERE SPACE = 57 \G
*************************** 1. row ***************************
SPACE: 57
 PATH: ./test/t1.ibd
</pre>

<p>Файл данных расположен в подкаталоге <code>test</code> каталога
MySQL <code>data</code>. Если табличное пространство
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
создавалось в местоположении вне каталога данных MySQL, используя
<code>DATA DIRECTORY</code> в <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a>, <code>PATH</code> был бы полным путем к каталогу.</li>

<li>Как заключительный шаг, вставьте строку в таблицу
<code>t1</code> (<code>TABLE_ID = 71</code>) и рассмотрите данные в
<a href="inform.htm#innodb-sys-tablestats-table"><code>INNODB_SYS_TABLESTATS
</code></a>. Данные в этой таблице используются оптимизатором, чтобы
вычислить, который индекс использовать, запрашивая таблицу.
<pre>
mysql&gt; INSERT INTO t1 VALUES(5, 'abc', 'def');
Query OK, 1 row affected (0.06 sec)

mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS
                 where TABLE_ID = 71 \G
*************************** 1. row ***************************
 TABLE_ID: 71
   NAME: test/t1
STATS_INITIALIZED: Initialized
 NUM_ROWS: 1
 CLUST_INDEX_SIZE: 1
 OTHER_INDEX_SIZE: 0
 MODIFIED_COUNTER: 1
AUTOINC: 0
REF_COUNT: 1
</pre>

<p>Поле <code>STATS_INITIALIZED</code> указывает, были ли статистические
данные собраны для таблицы. <code>NUM_ROWS</code> текущее число строк в
таблице. Поля <code>CLUST_INDEX_SIZE</code> и <code>OTHER_INDEX_SIZE</code>
сообщают о числе страниц на диске, которые хранят кластеризируемый и
вторичный индексы для таблицы, соответственно. <code>MODIFIED_COUNTER</code>
показывает число строк, измененных операциями DML и каскадными операциями от
внешних ключей. <code>AUTOINC</code> следующее число, которое будет выпущено
для любой основанной на автоинкременте работы. Нет никаких столбцов
автоприращения, определенных в таблице <code>t1</code>, так что это всегда 0.
<code>REF_COUNT</code> счетчик. Когда счетчик достигает 0, он показывает, что
табличные метаданные могут быть вычеркнуты из табличного кэша.</p></li></ol>

<a name="innodb-information-schema-fk-system-tables-example"></a><p><b>
Пример 16.12. Системные таблицы Foreign Key INFORMATION_SCHEMA</b></p>
<p><a href="inform.htm#innodb-sys-foreign-table"><code>INNODB_SYS_FOREIGN
</code></a> и <a href="inform.htm#innodb-sys-foreign-cols-table"><code>
INNODB_SYS_FOREIGN_COLS</code></a> обеспечивают данные об отношениях внешнего
ключа. Этот пример использует родительскую таблицу и дочернюю таблицу с
отношениями внешнего ключа, чтобы продемонстрировать данные, найденные в
<a href="inform.htm#innodb-sys-foreign-table"><code>INNODB_SYS_FOREIGN</code>
</a> и <a href="inform.htm#innodb-sys-foreign-cols-table"><code>
INNODB_SYS_FOREIGN_COLS</code></a>.</p>

<ol type="1"><li><p>Создайте испытательную базу данных с
родительскими и дочерними таблицами:
<pre>
mysql&gt; CREATE DATABASE test;
mysql&gt; USE test;
mysql&gt; CREATE TABLE parent (id INT NOT NULL,
    -&gt;        PRIMARY KEY (id)) ENGINE=INNODB;
mysql&gt; CREATE TABLE child (id INT, parent_id INT,
    -&gt;        INDEX par_ind (parent_id), CONSTRAINT fk1
    -&gt;        FOREIGN KEY (parent_id) REFERENCES parent(id)
    -&gt;        ON DELETE CASCADE) ENGINE=INNODB;
</pre></li>

<li>После того, как родительские и дочерние таблицы составлены, запросите
<a href="inform.htm#innodb-sys-foreign-table"><code>INNODB_SYS_FOREIGN
</code></a> и определите местонахождение данных о внешнем ключе для
<code>test/child</code> и <code>test/parent</code>:
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FOREIGN \G
*************************** 1. row ***************************
  ID: test/fk1
FOR_NAME: test/child
REF_NAME: test/parent
  N_COLS: 1
TYPE: 1
</pre>

<p>Метаданные включают внешний ключ <code>ID</code> (<code>fk1</code>),
который назван по имени <code>CONSTRAINT</code>, был определен на дочерней
таблице. <code>FOR_NAME</code> название дочерней таблицы, где внешний ключ
определен. <code>REF_NAME</code> название родительской таблицы
(<span><span>referenced</span></span> таблица). <code>N_COLS</code>
число столбцов во внешнем ключе индекса. <code>TYPE</code> численное
значение, представляющее разрядные флаги, которые обеспечивают
дополнительную информацию о столбце внешнего ключа. В этом случае
<code>TYPE</code> = 1, который указывает, что опция <code>ON DELETE CASCADE
</code> была определена для внешнего ключа. См. опередение таблицы
<a href="inform.htm#innodb-sys-foreign-table"><code>INNODB_SYS_FOREIGN</code>
</a> для получения дополнительной информации о <code>TYPE</code>.</li>

<li>Используя внешний ключ <code>ID</code>, запросите
<a href="inform.htm#innodb-sys-foreign-cols-table"><code>
INNODB_SYS_FOREIGN_COLS</code></a>, чтобы просмотреть данные о
столбцах внешнего ключа.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_SYS_FOREIGN_COLS
                   WHERE ID = 'test/fk1' \G
*************************** 1. row ***************************
ID: test/fk1
FOR_COL_NAME: parent_id
REF_COL_NAME: id
 POS: 0
</pre>

<p><code>FOR_COL_NAME</code> название столбца внешнего ключа в дочерней
таблице, а <code>REF_COL_NAME</code> название столбца, на который ссылаются,
в родительской таблице. <code>POS</code> порядковая позиция поля ключа в
пределах индекса внешнего ключа, начиная с 0.</p></li></ol>

<a name="innodb-information-schema-system-tables-join-example"></a><p><b>
Пример 16.13. Объединение системных таблиц INFORMATION_SCHEMA</b></p>
<p>Этот пример демонстрирует присоединение трех системных таблиц
<code>InnoDB</code> <code>INFORMATION_SCHEMA</code>
(<a href="inform.htm#innodb-sys-tables-table"><code>INNODB_SYS_TABLES</code>
</a>, <a href="inform.htm#innodb-sys-tablespaces-table"><code>
INNODB_SYS_TABLESPACES</code></a> и
<a href="inform.htm#innodb-sys-tablestats-table"><code>INNODB_SYS_TABLESTATS
</code></a>), чтобы собрать формат файла, формат строки, размер страницы и
информацию о размере индекса о таблицах в базе данных.</p>

<p>Следующие псевдонимы имени таблицы используются, чтобы
сократить строку запроса:</p>
<ul><li><p><a href="inform.htm#innodb-sys-tables-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLES</code></a>: a</li>
<li><a href="inform.htm#innodb-sys-tablespaces-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES</code></a>: b</li>
<li><a href="inform.htm#innodb-sys-tablestats-table"><code>
INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS</code></a>: c</p></li></ul>

<p><a href="funct.htm#function_if"><code>IF()</code></a>
используется, чтобы составлять сжатые таблицы. Если таблица сжата,
размер индекса вычислен, используя <code>ZIP_PAGE_SIZE</code> вместо
<code>PAGE_SIZE</code>. <code>CLUST_INDEX_SIZE</code> и
<code>OTHER_INDEX_SIZE</code>, о которых сообщают в байтах, разделены на
<code>1024*1024</code> чтобы обеспечить размеры индекса в мегабайтах (MB).
Значения MB округлены, используя функцию <a href="funct.htm#function_round">
<code>ROUND()</code></a>.
<pre>
mysql&gt; SELECT a.NAME, a.ROW_FORMAT,
  @page_size := IF (a.ROW_FORMAT='Compressed',
                    b.ZIP_PAGE_SIZE, b.PAGE_SIZE) AS page_size,
  ROUND((@page_size * c.CLUST_INDEX_SIZE) /(1024*1024)) AS pk_mb,
  ROUND((@page_size * c.OTHER_INDEX_SIZE) /(1024*1024)) AS secidx_mb
  FROM INFORMATION_SCHEMA.INNODB_SYS_TABLES a
  INNER JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESPACES b on a.NAME = b.NAME
  INNER JOIN INFORMATION_SCHEMA.INNODB_SYS_TABLESTATS c on b.NAME = c.NAME
  WHERE a.NAME LIKE 'employees/%' ORDER BY a.NAME DESC;
+------------------------+------------+-----------+-------+-----------+
| NAME                   | ROW_FORMAT | page_size | pk_mb | secidx_mb |
+------------------------+------------+-----------+-------+-----------+
| employees/titles       | Dynamic    | 16384     | 20    |    11     |
| employees/salaries     | Dynamic    | 16384     | 93    |    34     |
| employees/employees    | Dynamic    | 16384     | 15    |     0     |
| employees/dept_manager | Dynamic    | 16384     |  0    |     0     |
| employees/dept_emp     | Dynamic    | 16384     | 12    |    10     |
| employees/departments  | Dynamic    | 16384     |  0    |     0     |
+------------------------+------------+-----------+-------+-----------+
</pre>

<h3><a name="innodb-information-schema-fulltext_index-tables"></a>
16.14.4. Таблицы индекса InnoDB INFORMATION_SCHEMA FULLTEXT</h3>
<p>Следующие таблицы хранят метаданные для <code>FULLTEXT</code>:
<pre>
mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_FT%';
+-------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_FT%) |
+-------------------------------------------+
| INNODB_FT_CONFIG                          |
| INNODB_FT_BEING_DELETED                   |
| INNODB_FT_DELETED                         |
| INNODB_FT_DEFAULT_STOPWORD                |
| INNODB_FT_INDEX_TABLE                     |
| INNODB_FT_INDEX_CACHE                     |
+-------------------------------------------+
</pre>

<h4><a name="idm139965316786816"></a>Краткий обзор таблиц</h4>
<ul><li><p><a href="inform.htm#innodb-ft-config-table"><code>
INNODB_FT_CONFIG</code></a>: Метаданные об индексе <code>FULLTEXT</code>
и связанная обработка для таблицы.</li>

<li><a href="inform.htm#innodb-ft-being-deleted-table"><code>
INNODB_FT_BEING_DELETED</code></a>: Обеспечивает снимок таблицы
<a href="inform.htm#innodb-ft-deleted-table"><code>INNODB_FT_DELETED</code>
</a>, которая используется только во время
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.
При работе <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>
<a href="inform.htm#innodb-ft-being-deleted-table"><code>
INNODB_FT_BEING_DELETED</code></a> освобождена, и DOC_ID удалены из
<a href="inform.htm#innodb-ft-deleted-table"><code>INNODB_FT_DELETED</code>
</a>. Поскольку содержание <a href="inform.htm#innodb-ft-being-deleted-table">
<code>INNODB_FT_BEING_DELETED</code></a>, как правило, хранится мало, эта
таблица является ограниченной утилитой для контроля или отладки. Для
информации о выполнении <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE
</code></a> на таблицах с <code>FULLTEXT</code> см.
<a href="funct.htm#fulltext-fine-tuning">раздел 13.9.6</a>.</li>

<li><a href="inform.htm#innodb-ft-deleted-table"><code>INNODB_FT_DELETED
</code></a>: Строки записей, которые удалены из <code>FULLTEXT</code>.
Чтобы избежать дорогой перестройки индекса во время операций DML для
<code>FULLTEXT</code>, информация о недавно удаленных словах хранится
отдельно, фильтруется из результатов поиска, когда Вы выполняете текстовый
поиск и удаляется из основного индекса только, когда Вы выполняете
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.</li>

<li><a href="inform.htm#innodb-ft-default-stopword-table"><code>
INNODB_FT_DEFAULT_STOPWORD</code></a>: Хранит список
<a href="glossary.htm#glos_stopword">стоп-слов</a>, которые используются
по умолчанию, создавая <code>FULLTEXT</code>.</p>
<p>См. <a href="funct.htm#fulltext-stopwords">раздел 13.9.4</a>.</li>

<li><a href="inform.htm#innodb-ft-index-table-table"><code>
INNODB_FT_INDEX_TABLE</code></a>: Содержит данные об инвертированном
индексе, используемом, чтобы обработать
текстовые поиски в <code>FULLTEXT</code>.</li>

<li><a href="inform.htm#innodb-ft-index-cache-table"><code>
INNODB_FT_INDEX_CACHE</code></a>: Содержит информацию о маркере о недавно
вставленных строках в <code>FULLTEXT</code>. Чтобы избежать дорогой
перестройки индекса во время операций DML, информация о недавно
индексированных словах хранится отдельно и объединена с основным поиском
только, когда выполняется <a href="sql.htm#optimize-table"><code>OPTIMIZE
TABLE</code></a>, сервер закрыт или размер кэша превышает предел,
определенный <a href="#sysvar_innodb_ft_cache_size"><code>
innodb_ft_cache_size</code></a> или
<a href="#sysvar_innodb_ft_total_cache_size"><code>
innodb_ft_total_cache_size</code></a>.</p></li></ul>

<p>За исключением <a href="inform.htm#innodb-ft-default-stopword-table">
<code>INNODB_FT_DEFAULT_STOPWORD</code></a>, Вы должны установить параметр
<a href="#sysvar_innodb_ft_aux_table"><code>innodb_ft_aux_table
</code></a> к названию таблицы
(<em><code>database_name</code></em>/<em><code>table_name</code></em>),
которая содержит индекс <code>FULLTEXT</code>. Иначе
таблицы <code>INFORMATION_SCHEMA</code> для индекса
<code>FULLTEXT</code> окажутся пустыми.</p>

<a name="innodb-information-schema-fulltext-tables-example"></a><p><b>
Пример 16.14. InnoDB Таблицы INFORMATION_SCHEMA FULLTEXT</b></p>
<p>Этот пример использует таблицу с <code>FULLTEXT</code>, чтобы
продемонстрировать данные, содержавшиеся в таблицах
<code>INFORMATION_SCHEMA</code> <code>FULLTEXT</code>.</p>

<ol type="1"><li><p>Составьте таблицу с <code>FULLTEXT</code>
и вставьте некоторые данные:
<pre>
mysql&gt; CREATE TABLE articles (
  id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
  title VARCHAR(200), body TEXT,
  FULLTEXT (title,body)) ENGINE=InnoDB;

INSERT INTO articles (title,body) VALUES
  ('MySQL Tutorial','DBMS stands for DataBase ...'),
  ('How To Use MySQL Well','After you went through a ...'),
  ('Optimizing MySQL','In this tutorial we will show ...'),
  ('1001 MySQL Tricks','1. Never run mysqld as root. 2. ...'),
  ('MySQL vs. YourSQL','In the following database comparison ...'),
  ('MySQL Security','When configured properly, MySQL ...');
</pre></li>

<li>Установите <a href="#sysvar_innodb_ft_aux_table"><code>
innodb_ft_aux_table</code></a> к названию таблицы с <code>FULLTEXT</code>.
Если эта переменная не установлена, <code>INFORMATION_SCHEMA</code>
<code>FULLTEXT</code> таблицы окажутся пустыми, за исключением
<a href="inform.htm#innodb-ft-default-stopword-table"><code>
INNODB_FT_DEFAULT_STOPWORD</code></a>.
<pre>
SET GLOBAL innodb_ft_aux_table = 'test/articles';
</pre></li>

<li>Запросите <a href="inform.htm#innodb-ft-index-cache-table"><code>
INNODB_FT_INDEX_CACHE</code></a>, которая показывает информацию о недавно
вставленных строках в <code>FULLTEXT</code>. Чтобы избежать дорогой
перестройки индекса во время операций DML, данные для недавно вставленных
строк остаются в кэше <code>FULLTEXT</code> до выполнения
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>, перезапуска
сервера или пока кэш не закончится.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |  5           | 5           | 1         |  5     | 0        |
| after      |  3           | 3           | 1         |  3     | 22       |
| comparison |  6           | 6           | 1         |  6     | 44       |
| configured |  7           | 7           | 1         |  7     | 20       |
| database   |  2           | 6           | 2         |  2     | 31       |
+------------+--------------+-------------+-----------+--------+----------+
</pre></li>

<li>Включите <a href="#sysvar_innodb_optimize_fulltext_only">
<code>innodb_optimize_fulltext_only</code></a> и выполните
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>
на таблице, которая содержит <code>FULLTEXT</code>. Эта работа сбрасывает
кэш <code>FULLTEXT</code> в индекс <code>FULLTEXT</code>.
<a href="#sysvar_innodb_optimize_fulltext_only"><code>
innodb_optimize_fulltext_only</code></a> изменяет логику действий
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>
и предназначены, чтобы быть включенным временно, во время операций
обслуживания таблиц с <code>FULLTEXT</code>.
<pre>
mysql&gt; SET GLOBAL innodb_optimize_fulltext_only=ON;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; OPTIMIZE TABLE articles;
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
</pre></li>

<li>Запросите <a href="inform.htm#innodb-ft-index-table-table"><code>
INNODB_FT_INDEX_TABLE</code></a>, чтобы рассмотреть информацию о данных в
основном индексе <code>FULLTEXT</code>, включая информацию о данных,
которые только поступили от кэша.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_TABLE LIMIT 5;
+------------+--------------+-------------+-----------+--------+----------+
| WORD       | FIRST_DOC_ID | LAST_DOC_ID | DOC_COUNT | DOC_ID | POSITION |
+------------+--------------+-------------+-----------+--------+----------+
| 1001       |  5           | 5           | 1         |  5     |        0 |
| after      |  3           | 3           | 1         |  3     |       22 |
| comparison |  6           | 6           | 1         |  6     |       44 |
| configured |  7           | 7           | 1         |  7     |       20 |
| database   |  2           | 6           | 2         |  2     |       31 |
+------------+--------------+-------------+-----------+--------+----------+
</pre>

<p>Таблица <a href="inform.htm#innodb-ft-index-cache-table">
<code>INNODB_FT_INDEX_CACHE</code></a> теперь пуста, начиная с выполнения
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_INDEX_CACHE LIMIT 5;
Empty set (0.00 sec)
</pre></li>

<li>Удалите некоторые записи из <code>test/articles</code>.
<pre>
mysql&gt; DELETE FROM test.articles WHERE id &lt; 4;
Query OK, 3 rows affected (0.11 sec)
</pre></li>

<li>Запросите <a href="inform.htm#innodb-ft-deleted-table"><code>
INNODB_FT_DELETED</code></a>. Эта таблица делает запись строк, которые
удалены из <code>FULLTEXT</code>. Чтобы избежать дорогой перестройки индекса
во время операций DML, информация о недавно удаленных записях хранится
отдельно, фильтруется из результатов поиска, когда Вы делаете текстовый
поиск и удалена из основного индекса, когда Вы выполняете
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;
+--------+
| DOC_ID |
+--------+
|  2     |
|  3     |
|  4     |
+--------+
</pre></li>

<li>Выполните <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code>
</a>, чтобы дкйствительно удалить удаленные запись.
<pre>
mysql&gt; OPTIMIZE TABLE articles;
+---------------+----------+----------+----------+
| Table         | Op       | Msg_type | Msg_text |
+---------------+----------+----------+----------+
| test.articles | optimize | status   | OK       |
+---------------+----------+----------+----------+
</pre>

<p>Таблица <a href="inform.htm#innodb-ft-deleted-table">
<code>INNODB_FT_DELETED</code></a> должна теперь быть пустой.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_DELETED;
Empty set (0.00 sec)
</pre></li>

<li>Запросите <a href="inform.htm#innodb-ft-config-table"><code>
INNODB_FT_CONFIG</code></a>. Эта таблица содержит метаданные об индексе
<code>FULLTEXT</code> и связанной обработке:</p>

<ul><li><p><code>optimize_checkpoint_limit</code> число секунд, после
которого остановится <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE
</code></a>.</li>

<li><code>synced_doc_id</code> следующий <code>DOC_ID</code>.</li>
<li><code>stopword_table_name</code> имя <em><code>database/table</code></em>
определяемой пользователем таблицы стоп-слов. Эта область окажется пустой,
если нет никакой определяемой пользователем таблицы стоп-слов.</li>

<li><code>use_stopword</code> указывает, используется ли таблица стоп-слов,
которая определена, когда создан <code>FULLTEXT</code>.</p></li></ul>
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_FT_CONFIG;
+---------------------------+-------+
| KEY                       | VALUE |
+---------------------------+-------+
| optimize_checkpoint_limit | 180   |
| synced_doc_id             |  8    |
| stopword_table_name       |       |
| use_stopword              |  1    |
+---------------------------+-------+
</pre></li></ol>

<h3><a name="innodb-information-schema-buffer-pool-tables"></a>16.14.5.
Таблицы буферного пула InnoDB INFORMATION_SCHEMA</h3>
<p>Таблицы буферного пула обеспечивают
информацию о статусе и метаданные о страницах в пределах
буферного пула <code>InnoDB</code>.</p>

<p>Таблицы буферного пула включают:
<pre>
mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_BUFFER%';
+-----------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_BUFFER%) |
+-----------------------------------------------+
| INNODB_BUFFER_PAGE_LRU                        |
| INNODB_BUFFER_PAGE                            |
| INNODB_BUFFER_POOL_STATS                      |
+-----------------------------------------------+
</pre>

<h4><a name="idm139965316660416"></a>Краткий обзор таблиц</h4>
<ul><li><p><a href="inform.htm#innodb-buffer-page-table"><code>
INNODB_BUFFER_PAGE</code></a>: хранит информацию о каждой странице в
буферном пуле <code>InnoDB</code>.</li>

<li><a href="inform.htm#innodb-buffer-page-lru-table"><code>
INNODB_BUFFER_PAGE_LRU</code></a>: хранит информацию о страницах в
буферном пуле в особенности как они упорядочиваются в списке LRU, который
определяет, какие страницы вычеркнуть из буферного пула, когда это становится
полным. <a href="inform.htm#innodb-buffer-page-lru-table"><code>
INNODB_BUFFER_PAGE_LRU</code></a> имеет те же самые столбцы, как
<a href="inform.htm#innodb-buffer-page-table"><code>INNODB_BUFFER_PAGE</code>
</a>, за исключением того, что
<a href="inform.htm#innodb-buffer-page-lru-table"><code>
INNODB_BUFFER_PAGE_LRU</code></a> имеет столбец <code>LRU_POSITION</code>
вместо <code>BLOCK_ID</code>.</li>

<li><a href="inform.htm#innodb-buffer-pool-stats-table"><code>
INNODB_BUFFER_POOL_STATS</code></a>: обеспечивает информацию о статусе.
Большая часть той же самой информации предоставлена
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>
или может быть получена, используя переменные состояния сервера.
</p></li></ul>

<p>Запросы <a href="inform.htm#innodb-buffer-page-table"><code>
INNODB_BUFFER_PAGE</code></a> или
<a href="inform.htm#innodb-buffer-page-lru-table"><code>
INNODB_BUFFER_PAGE_LRU</code></a>
могут ввести существенную нагрузку. Не запрашивайте эти таблицы на
производственной системе, если Вы не знаете об исполнительном влиянии,
которое Ваш запрос может оказать. Чтобы избежать воздействовать на работу,
воспроизведите проблему, которую Вы хотите исследовать,
на испытательном случае.</p>

<a name="innodb-information-schema-buffer-pool-system-data-example"></a>
<p><b>Пример 16.15. Запрос системных данных в таблице INNODB_BUFFER_PAGE
</b></p>
<p>Этот запрос предоставляет приблизительное количество страниц, которые
содержат системные данные, за исключением страниц, где
<code>TABLE_NAME</code> <code>NULL</code> или включает наклонную черту
<code>/</code> или точку <code>.</code> в имени таблицы, которое указывает на
определяемую пользователем таблицу.
<pre>
SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
       WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND
       INSTR(TABLE_NAME, '.') = 0);
+----------+
| COUNT(*) |
+----------+
| 1516     |
+----------+
</pre>

<p>Этот запрос возвращает приблизительное количество страниц, которые
содержат системные данные, общее количество страниц буферного пула и
приблизительный процент страниц, которые содержат системные данные.
<pre>
SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
        WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND
              INSTR(TABLE_NAME, '.') = 0)) AS system_pages,
       (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE) AS
               total_pages,
       (SELECT ROUND((system_pages/total_pages) * 100)) AS
               system_page_percentage;
+--------------+-------------+------------------------+
| system_pages | total_pages | system_page_percentage |
+--------------+-------------+------------------------+
| 295          | 8192        | 4                      |
+--------------+-------------+------------------------+
</pre>

<p>Тип системных данных в буферном пуле может быть определен, запрашивая
<code>PAGE_TYPE</code>. Например, следующий запрос возвращает восемь отличных
<code>PAGE_TYPE</code> среди страниц, которые содержат системные данные:
<pre>
mysql&gt; SELECT DISTINCT PAGE_TYPE
                 FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
                 WHERE TABLE_NAME IS NULL OR (INSTR(TABLE_NAME, '/') = 0 AND
                 INSTR(TABLE_NAME, '.') = 0);
+-------------------+
| PAGE_TYPE         |
+-------------------+
| SYSTEM            |
| IBUF_BITMAP       |
| UNKNOWN           |
| FILE_SPACE_HEADER |
| INODE             |
| UNDO_LOG          |
| ALLOCATED         |
+-------------------+
</pre>

<a name="innodb-information-schema-buffer-pool-user-data-example"></a><p><b>
Пример 16.16. Запрос пользовательских данных в таблице INNODB_BUFFER_PAGE
</b></p>
<p>Этот запрос предоставляет приблизительное количество страниц, содержащих
пользовательские данные, считая страницы, где
<code>TABLE_NAME</code> <code>NOT NULL</code> и
<code>NOT LIKE '%INNODB_SYS_TABLES%'</code>.
<pre>
mysql&gt; SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
                 WHERE TABLE_NAME IS NOT NULL AND TABLE_NAME NOT
                 LIKE '%INNODB_SYS_TABLES%';
+----------+
| COUNT(*) |
+----------+
| 7897     |
+----------+
</pre>

<p>Этот запрос возвращает приблизительное количество страниц, которые
содержат пользовательские данные, общее количество страниц буферного пула и
приблизительный процент страниц, которые содержат пользовательские данные.
<pre>
mysql&gt; SELECT (SELECT COUNT(*) FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
                  WHERE TABLE_NAME IS NOT NULL AND
                  (INSTR(TABLE_NAME, '/') &gt; 0 OR
                  INSTR(TABLE_NAME, '.') &gt; 0)) AS user_pages,
                 (SELECT COUNT(*) FROM information_schema.INNODB_BUFFER_PAGE)
                  AS total_pages,
                 (SELECT ROUND((user_pages/total_pages) * 100)) AS
                  user_page_percentage;
+------------+-------------+----------------------+
| user_pages | total_pages | user_page_percentage |
+------------+-------------+----------------------+
|   7897     | 8192        | 96                   |
+------------+-------------+----------------------+
</pre>

<p>Этот запрос идентифицирует определяемые пользователем таблицы со
страницами в буферном пуле:
<pre>
mysql&gt; SELECT DISTINCT TABLE_NAME
                 FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
                 WHERE TABLE_NAME IS NOT NULL AND
                 (INSTR(TABLE_NAME, '/') &gt; 0 OR
                 INSTR(TABLE_NAME, '.') &gt; 0) AND
                 TABLE_NAME NOT LIKE '`mysql`.`innodb_%';
+-------------------------+
| TABLE_NAME              |
+-------------------------+
| `employees`.`salaries`  |
| `employees`.`employees` |
+-------------------------+
</pre>

<a name="innodb-information-schema-buffer-pool-index-data-example"></a>
<p><b>Пример 16.17. Запрос индексных данных в таблице INNODB_BUFFER_PAGE
</b></p>
<p>Для информации об индексных страницах запросите столбец <code>INDEX_NAME
</code>, используя название индекса. Например, следующий запрос возвращает
число страниц и полный размер данных страниц для индекса <code>emp_no</code>,
который определен на таблице <code>employees.salaries</code>:
<pre>
mysql&gt; SELECT INDEX_NAME, COUNT(*) AS Pages,
                 ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@global.innodb_page_size,
                       COMPRESSED_SIZE))/1024/1024) AS 'Total Data (MB)'
                 FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
                 WHERE INDEX_NAME='emp_no' AND
                 TABLE_NAME = '`employees`.`salaries`';
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1609 | 25              |
+------------+-------+-----------------+
</pre>

<p>Этот запрос возвращает число страниц и полный размер данных страниц для
всех индексов, определенных в таблице <code>employees.salaries</code>:
<pre>
mysql&gt; SELECT INDEX_NAME, COUNT(*) AS Pages,
                 ROUND(SUM(IF(COMPRESSED_SIZE = 0, @@global.innodb_page_size,
                 COMPRESSED_SIZE))/1024/1024) AS 'Total Data (MB)'
                 FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE
                 WHERE TABLE_NAME = '`employees`.`salaries`'
                 GROUP BY INDEX_NAME;
+------------+-------+-----------------+
| INDEX_NAME | Pages | Total Data (MB) |
+------------+-------+-----------------+
| emp_no     |  1608 | 25              |
| PRIMARY    |  6086 | 95              |
+------------+-------+-----------------+
</pre>

<a name="innodb-information-schema-buffer-pool-lru-position-example"></a>
<p><b>Пример 16.18. Запрос данных LRU_POSITION в
INNODB_BUFFER_PAGE_LRU</b></p>
<p><a href="inform.htm#innodb-buffer-page-lru-table"><code>
INNODB_BUFFER_PAGE_LRU</code></a> содержит информацию о страницах в
буферном пуле, в особенности как он упорядочивается, что определяет, какие
страницы вычеркнуть из буферного пула, когда это становится полным.
Определение для этой страницы то же самое, как и
<a href="inform.htm#innodb-buffer-page-table">
<code>INNODB_BUFFER_PAGE</code></a>, но эта таблица имеет столбец
<code>LRU_POSITION</code> вместо <code>BLOCK_ID</code>.</p>

<p>Этот запрос считает число позиций в определенном местоположении в списке
LRU занятых страницами <code>employees.employees</code>.
<pre>
mysql&gt; SELECT COUNT(LRU_POSITION)
                 FROM INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU
                 WHERE TABLE_NAME='`employees`.`employees`' AND
                 LRU_POSITION &lt; 3072;
+---------------------+
| COUNT(LRU_POSITION) |
+---------------------+
|   548               |
+---------------------+
</pre>

<a name="innodb-information-schema-buffer-pool-stats-example"></a><p><b>
Пример 16.19. Запрос INNODB_BUFFER_POOL_STATS</b></p>
<p><a href="inform.htm#innodb-buffer-pool-stats-table"><code>
INNODB_BUFFER_POOL_STATS</code></a> предоставляет информацию, подобную
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB
STATUS</code></a> и переменным состояния.
<pre>
mysql&gt; SELECT * FROM information_schema.INNODB_BUFFER_POOL_STATS \G
*************************** 1. row ***************************
 POOL_ID: 0
   POOL_SIZE: 8192
FREE_BUFFERS: 1
DATABASE_PAGES: 8173
OLD_DATABASE_PAGES: 3014
 MODIFIED_DATABASE_PAGES: 0
PENDING_DECOMPRESS: 0
 PENDING_READS: 0
 PENDING_FLUSH_LRU: 0
PENDING_FLUSH_LIST: 0
  PAGES_MADE_YOUNG: 15907
  PAGES_NOT_MADE_YOUNG: 3803101
 PAGES_MADE_YOUNG_RATE: 0
   PAGES_MADE_NOT_YOUNG_RATE: 0
 NUMBER_PAGES_READ: 3270
  NUMBER_PAGES_CREATED: 13176
  NUMBER_PAGES_WRITTEN: 15109
   PAGES_READ_RATE: 0
 PAGES_CREATE_RATE: 0
PAGES_WRITTEN_RATE: 0
  NUMBER_PAGES_GET: 33069332
HIT_RATE: 0
YOUNG_MAKE_PER_THOUSAND_GETS: 0
NOT_YOUNG_MAKE_PER_THOUSAND_GETS: 0
 NUMBER_PAGES_READ_AHEAD: 2713
   NUMBER_READ_AHEAD_EVICTED: 0
   READ_AHEAD_RATE: 0
 READ_AHEAD_EVICTED_RATE: 0
LRU_IO_TOTAL: 0
LRU_IO_CURRENT: 0
  UNCOMPRESS_TOTAL: 0
UNCOMPRESS_CURRENT: 0
</pre>

<p>Для сравнения <a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB
STATUS</code></a> и переменные состояния показаны ниже, основанные на том же
самом наборе данных.</p>

<p>См. <a href="#innodb-standard-monitor">раздел 16.16.3</a>.
<pre>
mysql&gt; SHOW ENGINE INNODB STATUS \G
...
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 137428992
Dictionary memory allocated 579084
Buffer pool size   8192
Free buffers   1
Database pages 8173
Old database pages 3014
Modified db pages  0
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 15907, not young 3803101
0.00 youngs/s, 0.00 non-youngs/s
Pages read 3270, created 13176, written 15109
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
No buffer pool page gets since the last printout
Pages read ahead 0.00/s, evicted without access 0.00/s,
Random read ahead 0.00/s
LRU len: 8173, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
...
</pre>

<p>См. <a href="server.htm#server-status-variables">раздел 6.1.7</a>.
<pre>
mysql&gt; SHOW STATUS LIKE 'Innodb_buffer%';
+---------------------------------------+-------------+
| Variable_name                         | Value       |
+---------------------------------------+-------------+
| Innodb_buffer_pool_dump_status        | not started |
| Innodb_buffer_pool_load_status        | not started |
| Innodb_buffer_pool_resize_status      | not started |
| Innodb_buffer_pool_pages_data         | 8173        |
| Innodb_buffer_pool_bytes_data         | 133906432   |
| Innodb_buffer_pool_pages_dirty        | 0           |
| Innodb_buffer_pool_bytes_dirty        | 0           |
| Innodb_buffer_pool_pages_flushed      | 15109       |
| Innodb_buffer_pool_pages_free         | 1           |
| Innodb_buffer_pool_pages_misc         | 18          |
| Innodb_buffer_pool_pages_total        | 8192        |
| Innodb_buffer_pool_read_ahead_rnd     | 0           |
| Innodb_buffer_pool_read_ahead         | 2713        |
| Innodb_buffer_pool_read_ahead_evicted | 0           |
| Innodb_buffer_pool_read_requests      | 33069332    |
| Innodb_buffer_pool_reads              | 558         |
| Innodb_buffer_pool_wait_free          | 0           |
| Innodb_buffer_pool_write_requests     | 11985961    |
+---------------------------------------+-------------+
</pre>

<h3><a name="innodb-information-schema-metrics-table"></a>16.14.6.
Таблица метрик InnoDB INFORMATION_SCHEMA</h3>
<p><a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS</code></a>
хранит данные производительности и связанных с ресурсом счетчиков:</p>

<p>Столбцы <a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS
</code></a> показаны в следующем примере. Для описания каждого столбца см.
<a href="inform.htm#innodb-metrics-table">раздел 22.30.16</a>.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS
                   WHERE NAME="dml_inserts" \G
*************************** 1. row ***************************
 NAME: dml_inserts
  SUBSYSTEM: dml
COUNT: 46273
  MAX_COUNT: 46273
  MIN_COUNT: NULL
  AVG_COUNT: 492.2659574468085
COUNT_RESET: 46273
MAX_COUNT_RESET: 46273
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-11-28 16:07:53
  TIME_DISABLED: NULL
   TIME_ELAPSED: 94
 TIME_RESET: NULL
 STATUS: enabled
 TYPE: status_counter
COMMENT: Number of rows inserted
</pre>

<h4><a name="idm139965316573840"></a>Управление счетчиками</h4>
<p>Вы можете включить, отключить и сбросить счетчики, используя
следующие параметры конфигурации:</p>

<ul><li><p><a href="#sysvar_innodb_monitor_enable"><code>
innodb_monitor_enable</code></a>: Включает один или более счетчиков.
<pre>
SET GLOBAL innodb_monitor_enable = [counter-name|module_name|pattern|all];
</pre></li>

<li><a href="#sysvar_innodb_monitor_disable"><code>
innodb_monitor_disable</code></a>: Выключает один или более счетчиков.
<pre>
SET GLOBAL innodb_monitor_disable = [counter-name|module_name|pattern|all];
</pre></li>

<li><a href="#sysvar_innodb_monitor_reset"><code>
innodb_monitor_reset</code></a>: Сбрасывает в 0 один или более счетчиков.
<pre>
SET GLOBAL innodb_monitor_reset = [counter-name|module_name|pattern|all];
</pre></li>

<li><a href="#sysvar_innodb_monitor_reset_all"><code>
innodb_monitor_reset_all</code></a>: Сбрасывает все значения для одного или
более счетчиков. Счетчик должен быть отключен перед использованием
<a href="#sysvar_innodb_monitor_reset_all"><code>
innodb_monitor_reset_all</code></a>.
<pre>
SET GLOBAL innodb_monitor_reset_all = [counter-name|module_name|pattern|all];
</pre></li></ul>

<p>Вы можете также включить счетчик при запуске, используя конфигурационный
файл сервера MySQL. Например, чтобы включить модуль <code>log</code> и
счетчики <code>metadata_table_handles_opened</code> и
<code>metadata_table_handles_closed</code>, введите следующую строку в раздел
<code>[mysqld]</code> конфигурационного файла <code>my.cnf</code>.
<pre>
[mysqld]
innodb_monitor_enable = module_recovery,metadata_table_handles_opened,metadata_table_handles_closed
</pre>

<p>Включая много счетчиков в Вашем конфигурационном файле, Вы должны
определить <a href="#sysvar_innodb_monitor_enable"><code>
innodb_monitor_enable</code></a>, сопровождаемый счетчиком, отделенными
запятой, как показано в примере выше. Только
<a href="#sysvar_innodb_monitor_enable"><code>innodb_monitor_enable
</code></a> может использоваться в Вашем конфигурационном файле. Выключение и
сброс поддержаны только в командной строке.</p>

<p>Поскольку каждый счетчик налагает определенную степень времени выполнения
на сервере, как правило, Вы включаете большое количество счетчиков на сервере
теста и развития во время экспериментирования и сопоставительного анализа, и
позволяете счетчикам на производственных серверах только диагностировать
известные проблемы или аспекты, которые, вероятно, будут узкими местами для
особого сервера и рабочей нагрузки.</p>

<h4><a name="idm139965316550032"></a>Счетчики</h4>
<p>Счетчики, представленные в <a href="inform.htm#innodb-metrics-table">
<code>INNODB_METRICS</code></a> подвержены изменениям, таким образом, для
самого современного списка, запросите рабочий сервер MySQL. Список ниже
перечисляет счетчики, которые доступны с MySQL 8.0.</p>

<p>Счетчики, которые включены по умолчанию, соответствуют используемым
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.
Счетчики, используемые <a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB
STATUS</code></a>, всегда <span><span>on</span></span> на системном уровне,
но Вы можете отключить эти счетчики для
<a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS</code></a>,
как требуется. Кроме того, состояние не является постоянным. Если не
определено иное, счетчики возвращаются к своему значению по умолчанию,
когда сервер перезапущен.</p>

<p>Если бы Вы выполняете программы, которые были бы затронуты дополнениями
или изменяют <a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS
</code></a>, рекомендуется, чтобы Вы рассмотрели примечания выпусков и
запросили <a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS
</code></a> для нового выпуска до обновления.
<pre>
mysql&gt; SELECT name, subsystem, status
                 FROM INFORMATION_SCHEMA.INNODB_METRICS ORDER BY NAME;
+------------------------------------------+---------------------+----------+
| name                                     | subsystem           | status   |
+------------------------------------------+---------------------+----------+
| adaptive_hash_pages_added                | adaptive_hash_index | disabled |
| adaptive_hash_pages_removed              | adaptive_hash_index | disabled |
| adaptive_hash_rows_added                 | adaptive_hash_index | disabled |
| adaptive_hash_rows_deleted_no_hash_entry | adaptive_hash_index | disabled |
| adaptive_hash_rows_removed               | adaptive_hash_index | disabled |
| adaptive_hash_rows_updated               | adaptive_hash_index | disabled |
| adaptive_hash_searches                   | adaptive_hash_index | enabled  |
| adaptive_hash_searches_btree             | adaptive_hash_index | enabled  |
| buffer_data_reads                        | buffer              | enabled  |
| buffer_data_written                      | buffer              | enabled  |
| buffer_flush_adaptive                    | buffer              | disabled |
| buffer_flush_adaptive_avg_pass           | buffer              | disabled |
| buffer_flush_adaptive_avg_time_est       | buffer              | disabled |
| buffer_flush_adaptive_avg_time_slot      | buffer              | disabled |
| buffer_flush_adaptive_avg_time_thread    | buffer              | disabled |
| buffer_flush_adaptive_pages              | buffer              | disabled |
| buffer_flush_adaptive_total_pages        | buffer              | disabled |
| buffer_flush_avg_page_rate               | buffer              | disabled |
| buffer_flush_avg_pass                    | buffer              | disabled |
| buffer_flush_avg_time                    | buffer              | disabled |
| buffer_flush_background                  | buffer              | disabled |
| buffer_flush_background_pages            | buffer              | disabled |
| buffer_flush_background_total_pages      | buffer              | disabled |
| buffer_flush_batches                     | buffer              | disabled |
| buffer_flush_batch_num_scan              | buffer              | disabled |
| buffer_flush_batch_pages                 | buffer              | disabled |
| buffer_flush_batch_scanned               | buffer              | disabled |
| buffer_flush_batch_scanned_per_call      | buffer              | disabled |
| buffer_flush_batch_total_pages           | buffer              | disabled |
| buffer_flush_lsn_avg_rate                | buffer              | disabled |
| buffer_flush_neighbor                    | buffer              | disabled |
| buffer_flush_neighbor_pages              | buffer              | disabled |
| buffer_flush_neighbor_total_pages        | buffer              | disabled |
| buffer_flush_n_to_flush_by_age           | buffer              | disabled |
| buffer_flush_n_to_flush_requested        | buffer              | disabled |
| buffer_flush_pct_for_dirty               | buffer              | disabled |
| buffer_flush_pct_for_lsn                 | buffer              | disabled |
| buffer_flush_sync                        | buffer              | disabled |
| buffer_flush_sync_pages                  | buffer              | disabled |
| buffer_flush_sync_total_pages            | buffer              | disabled |
| buffer_flush_sync_waits                  | buffer              | disabled |
| buffer_LRU_batches_evict                 | buffer              | disabled |
| buffer_LRU_batches_flush                 | buffer              | disabled |
| buffer_LRU_batch_evict_pages             | buffer              | disabled |
| buffer_LRU_batch_evict_total_pages       | buffer              | disabled |
| buffer_LRU_batch_flush_avg_pass          | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_est      | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_slot     | buffer              | disabled |
| buffer_LRU_batch_flush_avg_time_thread   | buffer              | disabled |
| buffer_LRU_batch_flush_pages             | buffer              | disabled |
| buffer_LRU_batch_flush_total_pages       | buffer              | disabled |
| buffer_LRU_batch_num_scan                | buffer              | disabled |
| buffer_LRU_batch_scanned                 | buffer              | disabled |
| buffer_LRU_batch_scanned_per_call        | buffer              | disabled |
| buffer_LRU_get_free_loops                | buffer              | disabled |
| buffer_LRU_get_free_search               | Buffer              | disabled |
| buffer_LRU_get_free_waits                | buffer              | disabled |
| buffer_LRU_search_num_scan               | buffer              | disabled |
| buffer_LRU_search_scanned                | buffer              | disabled |
| buffer_LRU_search_scanned_per_call       | buffer              | disabled |
| buffer_LRU_single_flush_failure_count    | Buffer              | disabled |
| buffer_LRU_single_flush_num_scan         | buffer              | disabled |
| buffer_LRU_single_flush_scanned          | buffer              | disabled |
| buffer_LRU_single_flush_scanned_per_call | buffer              | disabled |
| buffer_LRU_unzip_search_num_scan         | buffer              | disabled |
| buffer_LRU_unzip_search_scanned          | buffer              | disabled |
| buffer_LRU_unzip_search_scanned_per_call | buffer              | disabled |
| buffer_pages_created                     | buffer              | enabled  |
| buffer_pages_read                        | buffer              | enabled  |
| buffer_pages_written                     | buffer              | enabled  |
| buffer_page_read_blob                    | buffer_page_io      | disabled |
| buffer_page_read_fsp_hdr                 | buffer_page_io      | disabled |
| buffer_page_read_ibuf_bitmap             | buffer_page_io      | disabled |
| buffer_page_read_ibuf_free_list          | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_leaf         | buffer_page_io      | disabled |
| buffer_page_read_index_ibuf_non_leaf     | buffer_page_io      | disabled |
| buffer_page_read_index_inode             | buffer_page_io      | disabled |
| buffer_page_read_index_leaf              | buffer_page_io      | disabled |
| buffer_page_read_index_non_leaf          | buffer_page_io      | disabled |
| buffer_page_read_other                   | buffer_page_io      | disabled |
| buffer_page_read_system_page             | buffer_page_io      | disabled |
| buffer_page_read_trx_system              | buffer_page_io      | disabled |
| buffer_page_read_undo_log                | buffer_page_io      | disabled |
| buffer_page_read_xdes                    | buffer_page_io      | disabled |
| buffer_page_read_zblob                   | buffer_page_io      | disabled |
| buffer_page_read_zblob2                  | buffer_page_io      | disabled |
| buffer_page_written_blob                 | buffer_page_io      | disabled |
| buffer_page_written_fsp_hdr              | buffer_page_io      | disabled |
| buffer_page_written_ibuf_bitmap          | buffer_page_io      | disabled |
| buffer_page_written_ibuf_free_list       | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_leaf      | buffer_page_io      | disabled |
| buffer_page_written_index_ibuf_non_leaf  | buffer_page_io      | disabled |
| buffer_page_written_index_inode          | buffer_page_io      | disabled |
| buffer_page_written_index_leaf           | buffer_page_io      | disabled |
| buffer_page_written_index_non_leaf       | buffer_page_io      | disabled |
| buffer_page_written_other                | buffer_page_io      | disabled |
| buffer_page_written_system_page          | buffer_page_io      | disabled |
| buffer_page_written_trx_system           | buffer_page_io      | disabled |
| buffer_page_written_undo_log             | buffer_page_io      | disabled |
| buffer_page_written_xdes                 | buffer_page_io      | disabled |
| buffer_page_written_zblob                | buffer_page_io      | disabled |
| buffer_page_written_zblob2               | buffer_page_io      | disabled |
| buffer_pool_bytes_data                   | buffer              | enabled  |
| buffer_pool_bytes_dirty                  | buffer              | enabled  |
| buffer_pool_pages_data                   | buffer              | enabled  |
| buffer_pool_pages_dirty                  | buffer              | enabled  |
| buffer_pool_pages_free                   | buffer              | enabled  |
| buffer_pool_pages_misc                   | buffer              | enabled  |
| buffer_pool_pages_total                  | buffer              | enabled  |
| buffer_pool_reads                        | buffer              | enabled  |
| buffer_pool_read_ahead                   | buffer              | enabled  |
| buffer_pool_read_ahead_evicted           | buffer              | enabled  |
| buffer_pool_read_requests                | buffer              | enabled  |
| buffer_pool_size                         | server              | enabled  |
| buffer_pool_wait_free                    | buffer              | enabled  |
| buffer_pool_write_requests               | buffer              | enabled  |
| compression_pad_decrements               | compression         | disabled |
| compression_pad_increments               | compression         | disabled |
| compress_pages_compressed                | compression         | disabled |
| compress_pages_decompressed              | compression         | disabled |
| ddl_background_drop_indexes              | ddl                 | disabled |
| ddl_background_drop_tables               | ddl                 | disabled |
| ddl_log_file_alter_table                 | ddl                 | disabled |
| ddl_online_create_index                  | ddl                 | disabled |
| ddl_pending_alter_table                  | ddl                 | disabled |
| ddl_sort_file_alter_table                | ddl                 | disabled |
| dml_deletes                              | dml                 | enabled  |
| dml_inserts                              | dml                 | enabled  |
| dml_reads                                | dml                 | disabled |
| dml_updates                              | dml                 | enabled  |
| file_num_open_files                      | file_system         | enabled  |
| ibuf_merges                              | change_buffer       | enabled  |
| ibuf_merges_delete                       | change_buffer       | enabled  |
| ibuf_merges_delete_mark                  | change_buffer       | enabled  |
| ibuf_merges_discard_delete               | change_buffer       | enabled  |
| ibuf_merges_discard_delete_mark          | change_buffer       | enabled  |
| ibuf_merges_discard_insert               | change_buffer       | enabled  |
| ibuf_merges_insert                       | change_buffer       | enabled  |
| ibuf_size                                | change_buffer       | enabled  |
| icp_attempts                             | icp                 | disabled |
| icp_match                                | icp                 | disabled |
| icp_no_match                             | icp                 | disabled |
| icp_out_of_range                         | icp                 | disabled |
| index_page_discards                      | index               | disabled |
| index_page_merge_attempts                | index               | disabled |
| index_page_merge_successful              | index               | disabled |
| index_page_reorg_attempts                | index               | disabled |
| index_page_reorg_successful              | index               | disabled |
| index_page_splits                        | index               | disabled |
| innodb_activity_count                    | server              | enabled  |
| innodb_background_drop_table_usec        | server              | disabled |
| innodb_checkpoint_usec                   | server              | disabled |
| innodb_dblwr_pages_written               | server              | enabled  |
| innodb_dblwr_writes                      | server              | enabled  |
| innodb_dict_lru_count                    | server              | disabled |
| innodb_dict_lru_usec                     | server              | disabled |
| innodb_ibuf_merge_usec                   | server              | disabled |
| innodb_log_flush_usec                    | server              | disabled |
| innodb_master_active_loops               | server              | disabled |
| innodb_master_idle_loops                 | server              | disabled |
| innodb_master_purge_usec                 | server              | disabled |
| innodb_master_thread_sleeps              | server              | disabled |
| innodb_mem_validate_usec                 | server              | disabled |
| innodb_page_size                         | server              | enabled  |
| innodb_rwlock_sx_os_waits                | server              | enabled  |
| innodb_rwlock_sx_spin_rounds             | server              | enabled  |
| innodb_rwlock_sx_spin_waits              | server              | enabled  |
| innodb_rwlock_s_os_waits                 | server              | enabled  |
| innodb_rwlock_s_spin_rounds              | server              | enabled  |
| innodb_rwlock_s_spin_waits               | server              | enabled  |
| innodb_rwlock_x_os_waits                 | server              | enabled  |
| innodb_rwlock_x_spin_rounds              | server              | enabled  |
| innodb_rwlock_x_spin_waits               | server              | enabled  |
| lock_deadlocks                           | lock                | enabled  |
| lock_rec_locks                           | lock                | disabled |
| lock_rec_lock_created                    | lock                | disabled |
| lock_rec_lock_removed                    | lock                | disabled |
| lock_rec_lock_requests                   | lock                | disabled |
| lock_rec_lock_waits                      | lock                | disabled |
| lock_row_lock_current_waits              | lock                | enabled  |
| lock_row_lock_time                       | lock                | enabled  |
| lock_row_lock_time_avg                   | lock                | enabled  |
| lock_row_lock_time_max                   | lock                | enabled  |
| lock_row_lock_waits                      | lock                | enabled  |
| lock_table_locks                         | lock                | disabled |
| lock_table_lock_created                  | lock                | disabled |
| lock_table_lock_removed                  | lock                | disabled |
| lock_table_lock_waits                    | lock                | disabled |
| lock_timeouts                            | lock                | enabled  |
| log_checkpoints                          | recovery            | disabled |
| log_lsn_buf_pool_oldest                  | recovery            | disabled |
| log_lsn_checkpoint_age                   | recovery            | disabled |
| log_lsn_current                          | recovery            | disabled |
| log_lsn_last_checkpoint                  | recovery            | disabled |
| log_lsn_last_flush                       | recovery            | disabled |
| log_max_modified_age_async               | recovery            | disabled |
| log_max_modified_age_sync                | recovery            | disabled |
| log_num_log_io                           | recovery            | disabled |
| log_padded                               | recovery            | enabled  |
| log_pending_checkpoint_writes            | recovery            | disabled |
| log_pending_log_flushes                  | recovery            | disabled |
| log_waits                                | recovery            | enabled  |
| log_writes                               | recovery            | enabled  |
| log_write_requests                       | recovery            | enabled  |
| metadata_table_handles_closed            | metadata            | disabled |
| metadata_table_handles_opened            | metadata            | disabled |
| metadata_table_reference_count           | metadata            | disabled |
| os_data_fsyncs                           | os                  | enabled  |
| os_data_reads                            | os                  | enabled  |
| os_data_writes                           | os                  | enabled  |
| os_log_bytes_written                     | os                  | enabled  |
| os_log_fsyncs                            | os                  | enabled  |
| os_log_pending_fsyncs                    | os                  | enabled  |
| os_log_pending_writes                    | os                  | enabled  |
| os_pending_reads                         | os                  | disabled |
| os_pending_writes                        | os                  | disabled |
| purge_del_mark_records                   | purge               | disabled |
| purge_dml_delay_usec                     | purge               | disabled |
| purge_invoked                            | purge               | disabled |
| purge_resume_count                       | purge               | disabled |
| purge_stop_count                         | purge               | disabled |
| purge_undo_log_pages                     | purge               | disabled |
| purge_upd_exist_or_extern_records        | purge               | disabled |
| trx_active_transactions                  | transaction         | disabled |
| trx_commits_insert_update                | transaction         | disabled |
| trx_nl_ro_commits                        | transaction         | disabled |
| trx_rollbacks                            | transaction         | disabled |
| trx_rollbacks_savepoint                  | transaction         | disabled |
| trx_rollback_active                      | transaction         | disabled |
| trx_ro_commits                           | transaction         | disabled |
| trx_rseg_current_size                    | transaction         | disabled |
| trx_rseg_history_len                     | transaction         | enabled  |
| trx_rw_commits                           | transaction         | disabled |
| trx_undo_slots_cached                    | transaction         | disabled |
| trx_undo_slots_used                      | transaction         | disabled |
+------------------------------------------+---------------------+----------+
235 rows in set (0.01 sec)
</pre>

<h4><a name="idm139965316501424"></a>Модули счетчиков</h4>
<p>Имена модуля соответствуют, но не идентичны, значениям столбца
<code>SUBSYSTEM</code> таблицы <a href="inform.htm#innodb-metrics-table">
<code>INNODB_METRICS</code></a>. Вместо включения, отключения или сброса
счетчиков индивидуально, Вы можете использовать имена модуля, чтобы быстро
включить, отключить или сбросить все счетчики для особой подсистемы.
Например, использовать <code>module_dml</code>, чтобы
включить все счетчики, связанные с подсистемой <code>dml</code>.
<pre>
mysql&gt; SET GLOBAL innodb_monitor_enable = module_dml;
mysql&gt; SELECT name, subsystem, status
                 FROM INFORMATION_SCHEMA.INNODB_METRICS
                 WHERE subsystem ='dml';
+-------------+-----------+---------+
| name        | subsystem | status  |
+-------------+-----------+---------+
| dml_reads   | dml       | enabled |
| dml_inserts | dml       | enabled |
| dml_deletes | dml       | enabled |
| dml_updates | dml       | enabled |
+-------------+-----------+---------+
</pre>

<p>Вот значения, для которых Вы можете использовать
<em><code>module_name</code></em> с опцией
<a href="#sysvar_innodb_monitor_enable"><code>
innodb_monitor_enable</code></a> и связанные параметры конфигурации, наряду с
передачей имен <code>SUBSYSTEM</code>:</p>

<ul><li><p><code>module_adaptive_hash</code> (subsystem =
<code>adaptive_hash_index</code>)</li>
<li><code>module_buffer</code> (subsystem = <code>buffer</code>)</li>
<li><code>module_buffer_page</code> (subsystem = <code>buffer_page_io</code>)
</li>

<li><code>module_compress</code> (subsystem = <code>compression</code>)</li>
<li><code>module_ddl</code> (subsystem = <code>ddl</code>)</li>
<li><code>module_dml</code> (subsystem = <code>dml</code>)</li>
<li><code>module_file</code> (subsystem = <code>file_system</code>)</li>
<li><code>module_ibuf_system</code> (subsystem = <code>change_buffer</code>)
</li>
<li><code>module_icp</code> (subsystem = <code>icp</code>)</li>
<li><code>module_index</code> (subsystem = <code>index</code>)</li>
<li><code>module_innodb</code> (subsystem = <code>innodb</code>)</li>
<li><code>module_lock</code> (subsystem = <code>lock</code>)</li>
<li><code>module_log</code> (subsystem = <code>recovery</code>)</li>
<li><code>module_metadata</code> (subsystem = <code>metadata</code>)</li>
<li><code>module_os</code> (subsystem = <code>os</code>)</li>
<li><code>module_purge</code> (subsystem = <code>purge</code>)</li>
<li><code>module_trx</code> (subsystem = <code>transaction</code>)</li></ul>

<a name="innodb-information-schema-metrics-table-example"></a>
<p><b>Пример 16.20. Работа с табличными счетчиками INNODB_METRICS</b></p>
<p>Этот пример демонстрирует включение, отключение, сброс счетчика и запрос
данных счетчика в таблице <a href="inform.htm#innodb-metrics-table"><code>
INNODB_METRICS</code></a>.</p>

<ol type="1"><li><p>Создайте простую таблицу:
<pre>
mysql&gt; USE test;
Database changed

mysql&gt; CREATE TABLE t1 (c1 INT) ENGINE=INNODB;
Query OK, 0 rows affected (0.02 sec)
</pre></li>

<li>Включите счетчик <code>dml_inserts</code>.
<pre>
mysql&gt; SET GLOBAL innodb_monitor_enable = dml_inserts;
Query OK, 0 rows affected (0.01 sec)
</pre>

<p>Описание <code>dml_inserts</code> может быть найдено в столбце
<code>COMMENT</code> таблицы <code>INNODB_METRICS</code>:
<pre>
mysql&gt; SELECT NAME, COMMENT FROM INFORMATION_SCHEMA.INNODB_METRICS
                 WHERE NAME="dml_inserts";
+-------------+-------------------------+
| NAME        | COMMENT                 |
+-------------+-------------------------+
| dml_inserts | Number of rows inserted |
+-------------+-------------------------+
</pre></li>

<li>Запросите <a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS
</code></a> для данных счетчика <code>dml_inserts</code>.
Поскольку никакие операции DML не были выполнены, значения ноль или NULL.
<code>TIME_ENABLED</code> и <code>TIME_ELAPSED</code>
указывают, когда счетчик был последний раз включен и сколько секунд
прошло с этого времени.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS
                   WHERE NAME="dml_inserts" \G
*************************** 1. row ***************************
 NAME: dml_inserts
  SUBSYSTEM: dml
COUNT: 0
  MAX_COUNT: 0
  MIN_COUNT: NULL
  AVG_COUNT: 0
COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 28
 TIME_RESET: NULL
 STATUS: enabled
 TYPE: status_counter
COMMENT: Number of rows inserted
</pre></li>

<li>Вставьте три строки данных в таблицу.
<pre>
mysql&gt; INSERT INTO t1 values(1);
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO t1 values(2);
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO t1 values(3);
Query OK, 1 row affected (0.00 sec)
</pre></li>

<li>Запросите <a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS
</code></a> снова для данных счетчика <code>dml_inserts</code>.
Много значений теперь постепенно увеличились, включая
<code>COUNT</code>, <code>MAX_COUNT</code>, <code>AVG_COUNT</code> и
<code>COUNT_RESET</code>. Обратитесь к определению таблицы
<a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS</code></a>
для описаний этих значений.
<pre>
mysql&gt;  SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS
                    WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
 NAME: dml_inserts
  SUBSYSTEM: dml
COUNT: 3
  MAX_COUNT: 3
  MIN_COUNT: NULL
  AVG_COUNT: 0.046153846153846156
COUNT_RESET: 3
MAX_COUNT_RESET: 3
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 65
 TIME_RESET: NULL
 STATUS: enabled
 TYPE: status_counter
COMMENT: Number of rows inserted
</pre></li>

<li>Сбросьте счетчик <code>dml_inserts</code> и запросите
<a href="inform.htm#innodb-metrics-table"><code>INNODB_METRICS</code></a>
для данных счетчика <code>dml_inserts</code>. Значения <code>%_RESET</code>,
о которых сообщили ранее, <code>COUNT_RESET</code> и <code>MAX_RESET</code>,
сброшены к нолю. Значения <code>COUNT</code>, <code>MAX_COUNT</code> и
<code>AVG_COUNT</code>, которые кумулятивно собирают данные со времени
включения счетчика, сбросом не затронуты.
<pre>
mysql&gt; SET GLOBAL innodb_monitor_reset = dml_inserts;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS
                   WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
 NAME: dml_inserts
  SUBSYSTEM: dml
COUNT: 3
  MAX_COUNT: 3
  MIN_COUNT: NULL
  AVG_COUNT: 0.03529411764705882
COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: NULL
   TIME_ELAPSED: 85
 TIME_RESET: 2014-12-04 14:19:44
 STATUS: enabled
 TYPE: status_counter
COMMENT: Number of rows inserted
</pre></li>

<li>Чтобы сбросить все значения, Вы должны сначала отключить счетчик.
Отключение счетчика устанавливает
значение <code>STATUS</code> в <code>disbaled</code>.
<pre>
mysql&gt; SET GLOBAL innodb_monitor_disable = dml_inserts;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS
                   WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
 NAME: dml_inserts
  SUBSYSTEM: dml
COUNT: 3
  MAX_COUNT: 3
  MIN_COUNT: NULL
  AVG_COUNT: 0.030612244897959183
COUNT_RESET: 0
MAX_COUNT_RESET: 0
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: 0
   TIME_ENABLED: 2014-12-04 14:18:28
  TIME_DISABLED: 2014-12-04 14:20:06
   TIME_ELAPSED: 98
 TIME_RESET: NULL
 STATUS: disabled
 TYPE: status_counter
COMMENT: Number of rows inserted
</pre>

<p>Подстановочное соответствие поддержано для счетчика и имен модуля.
Например, вместо того, чтобы определить полное имя <code>dml_inserts</code>,
Вы можете определить <code>dml_i%</code>. Вы можете также включить, отключить
или сбросить много счетчиков или модулей, используя подстановочное
соответствие. Например, определите <code>dml_%</code> для всех счетчиков,
имена которых начинаются на <code>dml_</code>.</p></li>

<li><p>После того, как счетчик отключен, Вы можете сбросить все значения,
используя <a href="#sysvar_innodb_monitor_reset_all"><code>
innodb_monitor_reset_all</code></a>. Все значения установлены в ноль или NULL.
<pre>
mysql&gt; SET GLOBAL innodb_monitor_reset_all = dml_inserts;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_METRICS
                   WHERE NAME="dml_inserts"\G
*************************** 1. row ***************************
 NAME: dml_inserts
  SUBSYSTEM: dml
COUNT: 0
  MAX_COUNT: NULL
  MIN_COUNT: NULL
  AVG_COUNT: NULL
COUNT_RESET: 0
MAX_COUNT_RESET: NULL
MIN_COUNT_RESET: NULL
AVG_COUNT_RESET: NULL
   TIME_ENABLED: NULL
  TIME_DISABLED: NULL
   TIME_ELAPSED: NULL
 TIME_RESET: NULL
 STATUS: disabled
 TYPE: status_counter
COMMENT: Number of rows inserted
</pre></li></ol>

<h3><a name="innodb-information-schema-temp-table-info"></a>16.14.7.
Информация о временных таблицах в InnoDB INFORMATION_SCHEMA</h3>
<p><a href="inform.htm#innodb-temp-table-info-table"><code>
INNODB_TEMP_TABLE_INFO</code></a> предоставляет пользователям снимок активных
временные таблицы. Таблица содержит метаданные обо всех создаваемых
пользователями и системой временных таблицах, которые являются активными в
пределах <code>InnoDB</code>.
<pre>
mysql&gt; SHOW TABLES FROM INFORMATION_SCHEMA LIKE 'INNODB_TEMP%';
+---------------------------------------------+
| Tables_in_INFORMATION_SCHEMA (INNODB_TEMP%) |
+---------------------------------------------+
| INNODB_TEMP_TABLE_INFO                      |
+---------------------------------------------+
</pre>
<p>См. <a href="inform.htm#innodb-temp-table-info-table">раздел 22.30.27</a>.
</p>

<a name="innodb-information-schema-temp-table-info-example"></a><p><b>
Пример 16.21. INNODB_TEMP_TABLE_INFO</b></p>
<p>Этот пример демонстрирует характеристики
<a href="inform.htm#innodb-temp-table-info-table"><code>
INNODB_TEMP_TABLE_INFO</code></a> table.
</p>

<ol type="1"><li><p>Создайте простую временную
таблицу с единственным столбцом:
<pre>
mysql&gt; CREATE TEMPORARY TABLE t1 (c1 INT PRIMARY KEY) ENGINE=INNODB;
Query OK, 0 rows affected (0.00 sec)
</pre></li>

<li>Запросите <a href="inform.htm#innodb-temp-table-info-table"><code>
INNODB_TEMP_TABLE_INFO</code></a>, чтобы рассмотреть
метаданные временной таблицы.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G
*************************** 1. row ***************************
  TABLE_ID: 194
  NAME: #sql7a79_1_0
N_COLS: 4
 SPACE: 182
</pre>

<p><code>TABLE_ID</code> уникальный идентификатор для временной таблицы.
<code>NAME</code> выводит на экран произведенное системой название временной
таблицы с префиксом <span><span>#sql</span></span>. Число столбцов
(<code>N_COLS</code>) 4 вместо 1, потому что <code>InnoDB</code>
всегда создает три скрытых столбца таблицы (<code>DB_ROW_ID</code>,
<code>DB_TRX_ID</code> и <code>DB_ROLL_PTR</code>).</li>

<li>Перезапустите MySQL и запросите
<a href="inform.htm#innodb-temp-table-info-table"><code>
INNODB_TEMP_TABLE_INFO</code></a>.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G
Empty set (0.00 sec)
</pre>

<p>Пустой набор возвращен потому, что таблица
<a href="inform.htm#innodb-temp-table-info-table"><code>
INNODB_TEMP_TABLE_INFO</code></a> и данные в пределах нее не сохранены на
диск при завершении работы сервера.</li>

<li>Составьте новую временную таблицу.
<pre>
mysql&gt; CREATE TEMPORARY TABLE t1 (c1 INT PRIMARY KEY) ENGINE=INNODB;
Query OK, 0 rows affected (0.00 sec)
</pre></li>

<li>Запросите <a href="inform.htm#innodb-temp-table-info-table"><code>
INNODB_TEMP_TABLE_INFO</code></a>, чтобы рассмотреть
метаданные временной таблицы.
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.INNODB_TEMP_TABLE_INFO\G
*************************** 1. row ***************************
  TABLE_ID: 196
  NAME: #sql7b0e_1_0
N_COLS: 4
 SPACE: 184
</pre>
<p>ID <code>SPACE</code> новый, потому что динамически произведен
при перезапуске сервера.</p></li></ol>

<h3><a name="innodb-information-schema-files-table"></a>16.14.8.
Получение метаданных о табличном пространстве из INFORMATION_SCHEMA.FILES</h3>
<p><a href="inform.htm#files-table"><code>INFORMATION_SCHEMA.FILES</code></a>
обеспечивает метаданные обо всех типах табличного пространства, включая
<a href="glossary.htm#glos_file_per_table">file-per-table</a>,
<a href="glossary.htm#glos_general_tablespace">общие табличные пространства
</a>, <a href="glossary.htm#glos_system_tablespace">системное табличное
пространство</a>, <a href="glossary.htm#glos_temporary_tablespace">
временные табличные пространства</a> и
<a href="glossary.htm#glos_undo_tablespace">табличные пространства отмены
</a> (если есть).</p>

<p>The <a href="inform.htm#innodb-sys-tablespaces-table"><code>
INNODB_SYS_TABLESPACES</code></a> и
<a href="inform.htm#innodb-sys-datafiles-table"><code>INNODB_SYS_DATAFILES
</code></a> также обеспечивают метаданные о табличных пространствах, но
данные ограничены file-per-table и общими табличными пространствами.</p>

<p>Этот запрос получает метаданные о системном табличном пространстве от
полей <a href="inform.htm#files-table"><code>INFORMATION_SCHEMA.FILES</code>
</a>, которые являются подходящими для табличных пространств. Поля
<a href="inform.htm#files-table"><code>INFORMATION_SCHEMA.FILES</code></a>,
которые не подходят, всегда возвращают NULL и исключены из запроса.
<pre>
mysql&gt; SELECT FILE_ID, FILE_NAME, FILE_TYPE, TABLESPACE_NAME, FREE_EXTENTS,
                 TOTAL_EXTENTS, EXTENT_SIZE, INITIAL_SIZE, MAXIMUM_SIZE,
                 AUTOEXTEND_SIZE, DATA_FREE, STATUS ENGINE
                 FROM INFORMATION_SCHEMA.FILES WHERE TABLESPACE_NAME
                 LIKE 'innodb_system' \G
*************************** 1. row ***************************
FILE_ID: 0
  FILE_NAME: ./ibdata1
  FILE_TYPE: TABLESPACE
TABLESPACE_NAME: innodb_system
   FREE_EXTENTS: 0
  TOTAL_EXTENTS: 12
EXTENT_SIZE: 1048576
   INITIAL_SIZE: 12582912
   MAXIMUM_SIZE: NULL
AUTOEXTEND_SIZE: 67108864
  DATA_FREE: 4194304
 ENGINE: NORMAL
</pre>

<p>Этот запрос получает <code>FILE_ID</code> (эквивалентный ID пространства)
и <code>FILE_NAME</code> (который включает информацию о пути) для
file-per-table и общих табличных пространств. У File-per-table и общих
табличных пространств есть расширение файла <code>.ibd</code>.
<pre>
mysql&gt; SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES
                 WHERE FILE_NAME LIKE '%.ibd%' ORDER BY FILE_ID;
+---------+---------------------------------------+
| FILE_ID | FILE_NAME                             |
+---------+---------------------------------------+
|   2     | ./mysql/plugin.ibd                    |
|   3     | ./mysql/servers.ibd                   |
|   4     | ./mysql/help_topic.ibd                |
|   5     | ./mysql/help_category.ibd             |
|   6     | ./mysql/help_relation.ibd             |
|   7     | ./mysql/help_keyword.ibd              |
|   8     | ./mysql/time_zone_name.ibd            |
|   9     | ./mysql/time_zone.ibd                 |
|  10     | ./mysql/time_zone_transition.ibd      |
|  11     | ./mysql/time_zone_transition_type.ibd |
|  12     | ./mysql/time_zone_leap_second.ibd     |
|  13     | ./mysql/innodb_table_stats.ibd        |
|  14     | ./mysql/innodb_index_stats.ibd        |
|  15     | ./mysql/slave_relay_log_info.ibd      |
|  16     | ./mysql/slave_master_info.ibd         |
|  17     | ./mysql/slave_worker_info.ibd         |
|  18     | ./mysql/gtid_executed.ibd             |
|  19     | ./mysql/server_cost.ibd               |
|  20     | ./mysql/engine_cost.ibd               |
|  21     | ./sys/sys_config.ibd                  |
|  23     | ./test/t1.ibd                         |
|  26     | /home/user/test/test/t2.ibd           |
+---------+---------------------------------------+
</pre>

<p>Этот запрос получает <code>FILE_ID</code> и <code>FILE_NAME</code> для
временных табличных пространств. Временные имена файла табличного
пространства имеют префикс <code>ibtmp</code>.
<pre>
mysql&gt; SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES
                 WHERE FILE_NAME LIKE '%ibtmp%';
+---------+-----------+
| FILE_ID | FILE_NAME |
+---------+-----------+
|  22     | ./ibtmp1  |
+---------+-----------+
</pre>

<p>Точно так же имена файла табличного пространства отмены имеют префикс
<code>undo</code>. Следующий запрос возвращает <code>FILE_ID</code> и
<code>FILE_NAME</code> для табличных пространств отмены, если отдельные
табличные пространства отмены сконфигурированы.
<pre>
mysql&gt; SELECT FILE_ID, FILE_NAME FROM INFORMATION_SCHEMA.FILES
                 WHERE FILE_NAME LIKE '%undo%';
</pre>

<h2><a name="innodb-performance-schema"></a>16.15.
Интеграция с MySQL Performance Schema</h2>
<p>Этот раздел обеспечивает краткое введение в интеграцию с Performance
Schema. См. <a href="perfor.htm">главу 23</i></a>.</p>

<p>Вы можете профилировать внутренние операции, использующие MySQL
<a href="perfor.htm">Performance Schema</a>.
Этот тип настройки прежде всего для опытных пользователей, которые оценивают
стратегии оптимизации, чтобы преодолеть исполнительные узкие места. DBA
может также использовать эту функцию для планирования мощностей, чтобы
видеть, сталкивается ли их типичная рабочая нагрузка с какими-либо
исполнительными узкими местами с особой комбинацией центрального процессора,
RAM и дискового хранения, и если так, чтобы судить, может ли работа быть
улучшена, увеличивая параметры некоторой части системы.</p>

<p>Используйте эту функцию, чтобы исследовать:</p>
<ul><li><p>Вы должны быть вообще знакомыми с тем, как использовать
<a href="perfor.htm">Performance Schema</a>.
Например, Вы должны знать, как включают инструменты и потребителей и как
запросить таблицы <code>performance_schema</code>.
Для вводного краткого обзора см.
<a href="perfor.htm#performance-schema-quick-start">раздел 23.1</a>.</li>

<li>Вы должны быть знакомыми с инструментами Performance Schema, которые
доступны для <code>InnoDB</code>. Чтобы посмотреть связанные инструменты, Вы
можете запросить таблицу <a href="perfor.htm#setup-instruments-table"><code>
setup_instruments</code></a> для инструментальных имен,
которые содержат '<code>innodb</code>'.
<pre>
mysql&gt; SELECT * FROM setup_instruments WHERE NAME LIKE '%innodb%';
+------------------------------------------------------+---------+-------+
| NAME                                                 | ENABLED | TIMED |
+------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/innobase_share_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_mutex           | NO      | NO    |
| wait/synch/mutex/innodb/cache_last_read_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/dict_foreign_err_mutex       | NO      | NO    |
| wait/synch/mutex/innodb/dict_sys_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/recalc_pool_mutex            | NO      | NO    |
...
| wait/io/file/innodb/innodb_data_file                 | YES     | YES   |
| wait/io/file/innodb/innodb_log_file                  | YES     | YES   |
| wait/io/file/innodb/innodb_temp_file                 | YES     | YES   |
| stage/innodb/alter table (end)                       | YES     | YES   |
| stage/innodb/alter table (flush)                     | YES     | YES   |
| stage/innodb/alter table (insert)                    | YES     | YES   |
| stage/innodb/alter table (log apply index)           | YES     | YES   |
| stage/innodb/alter table (log apply table)           | YES     | YES   |
| stage/innodb/alter table (merge sort)                | YES     | YES   |
| stage/innodb/alter table (read PK and internal sort) | YES     | YES   |
| stage/innodb/buffer pool load                        | YES     | YES   |
| memory/innodb/buf_buf_pool                           | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t            | NO      | NO    |
| memory/innodb/dict_stats_index_map_t                 | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level             | NO      | NO    |
| memory/innodb/other                                  | NO      | NO    |
| memory/innodb/row_log_buf                            | NO      | NO    |
| memory/innodb/row_merge_sort                         | NO      | NO    |
| memory/innodb/std                                    | NO      | NO    |
| memory/innodb/sync_debug_latches                     | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids                  | NO      | NO    |
...
+------------------------------------------------------+---------+-------+
155 rows in set (0.00 sec)
</pre>

<p>Для дополнительной информации об инструментованном объекте Вы можете
запросить <a href="perfor.htm#performance-schema-instance-tables">
таблицы случаев</a>, которые обеспечивают дополнительную информацию об
инструментованных объектах. Таблицы случая, относящиеся к <code>InnoDB</code>:
</p>

<ul><li><p><a href="perfor.htm#mutex-instances-table"><code>mutex_instances
</code></a></li>
<li><a href="perfor.htm#rwlock-instances-table"><code>rwlock_instances</code>
</a></li>
<li><a href="perfor.htm#cond-instances-table"><code>cond_instances</code></a>
</li>
<li><a href="perfor.htm#file-instances-table"><code>file_instances</code></a>
</p></li></ul>

<p>Mutexes и RW-locks имеют отношение к буферному пулу, но не включены в
этот список, то же самое относится к выводу команды
<code>SHOW ENGINE INNODB MUTEX</code>.</p>

<p>Например, чтобы рассмотреть информацию об инструментованных объектах
файлов, запуская инструментовку ввода/вывода файла, Вы могли бы
выпустить следующий запрос:
<pre>
mysql&gt; SELECT * FROM file_instances WHERE EVENT_NAME LIKE '%innodb%'\G
*************************** 1. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/ibdata1
EVENT_NAME: wait/io/file/innodb/innodb_data_file
OPEN_COUNT: 3
*************************** 2. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/ib_logfile0
EVENT_NAME: wait/io/file/innodb/innodb_log_file
OPEN_COUNT: 2
*************************** 3. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/ib_logfile1
EVENT_NAME: wait/io/file/innodb/innodb_log_file
OPEN_COUNT: 2
*************************** 4. row ***************************
 FILE_NAME: /path/to/mysql-8.0/data/mysql/engine_cost.ibd
EVENT_NAME: wait/io/file/innodb/innodb_data_file
OPEN_COUNT: 3
...
</pre></li>

<li>Вы должны быть знакомы с таблицами
<code>performance_schema</code>, которые хранят данные событий.
Таблицы, относящиеся к событиям <code>InnoDB</code>:</p>

<ul><li><p><a href="perfor.htm#performance-schema-wait-tables">События
ожидания</a>.</li>

<li><a href="perfor.htm#performance-schema-summary-tables">Сводные таблицы
</a>, которые предоставляют соединенную информацию для законченных событий в
течение долгого времени. Сводные таблицы включают
<a href="perfor.htm#file-summary-tables">сводные таблицы ввода/вывода файла
</a>, которые хранят совокупную информацию об операциях ввода/вывода.</li>

<li><a href="perfor.htm#performance-schema-stage-tables">Этапы событий</a>,
которые хранят данные событий для <code>InnoDB</code>
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> и операции
загрузки буферного пула. См.
<a href="#monitor-alter-table-performance-schema">раздел 16.15.1
</a>.</p></li></ul>

<p>Если Вы интересуетесь только объектами <code>InnoDB</code>, используйте
<code>WHERE EVENT_NAME LIKE '%innodb%'</code> или <code>WHERE NAME LIKE
'%innodb%'</code> (как требуется), запрашивая эти таблицы.</p></li></ul>

<h3><a name="monitor-alter-table-performance-schema"></a>
16.15.1. Контроль ALTER TABLE для таблиц InnoDB, используя Performance Schema
</h3>
<p>Вы можете контролировать продвижение <a href="sql.htm#alter-table"><code>
ALTER TABLE</code></a> для таблиц <code>InnoDB</code>,
используя <a href="perfor.htm">Performance Schema</a>.</p>

<p>Есть семь событий этапа, которые представляют различные фазы
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
Каждый случай этапа сообщает о рабочем общем количестве
<code>WORK_COMPLETED</code> и <code>WORK_ESTIMATED</code> для полного
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, поскольку это
прогрессирует через свои различные фазы. <code>WORK_ESTIMATED</code>
вычислен, используя формулу, которая принимает во внимание всю работу
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
и может быть пересмотрен во время <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>. <code>WORK_COMPLETED</code> и <code>WORK_ESTIMATED</code>
абстрактное представление всей работы, выполненной
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<p>В порядке возникновения <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a> события этапа включают:</p>
<ul><li><p><code>stage/innodb/alter table (read PK and internal sort)</code>:
Этот этап является активным, когда
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
находится в фазе чтения первичного ключа. Это запускается с
<code>WORK_COMPLETED=0</code> и <code>WORK_ESTIMATED</code>, установленному
к предполагаемому числу страниц в первичном ключе. Когда этап завершен,
<code>WORK_ESTIMATED</code> обновлен к фактическому числу
страниц в первичном ключе.</li>

<li><code>stage/innodb/alter table (merge sort)</code>:
Этот этап повторен для каждого индекса, добавленного
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</li>

<li><code>stage/innodb/alter table (insert)</code>:
Этот этап повторен для каждого индекса, добавленного
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</li>

<li><code>stage/innodb/alter table (log apply index)</code>:
Этот этап включает применение журнала DML, произведенного в то время,
как работал <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</li>

<li><code>stage/innodb/alter table (flush)</code>:
Прежде, чем этот этап начинается, <code>WORK_ESTIMATED</code>
обновлен с более точной оценкой, основанной на длине списка.</li>

<li><code>stage/innodb/alter table (log apply table)</code>:
Этот этап включает применение параллельного журнала DML, произведенного в то
время, как работал <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>. Продолжительность этой фазы зависит от степени табличных изменений. Эта
фаза мгновенна, если никакой параллельный DML не был выполнен на таблице.</li>

<li><code>stage/innodb/alter table (end)</code>:
Включает любую остающуюся работу, которая появилась после фазы сброса,
например, повторное обращение DML, который был выполнен на таблице в то
время, как работал <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>.</p></li></ul>
<p>События этапа <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
в настоящее время не составляют добавление пространственных индексов.</p>

<h4><a name="idm139965316229104"></a>Пример мониторинга ALTER TABLE,
используя Performance Schema</h4>
<p>Следующий пример демонстрирует, как включить инструменты этапа событий
<code>stage/innodb/alter table%</code> и связанные потребительские таблицы,
чтобы контролировать ход <a href="sql.htm#alter-table"><code>ALTER TABLE
</code></a>. Для информации об исполнительных инструментах этапа Performance
Schema см. <a href="perfor.htm#performance-schema-stage-tables">раздел 23.9.5
</a>.</p>

<ol type="1"><li><p>Включите инструменты <code>stage/innodb/alter%</code>:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'YES'
                 WHERE NAME LIKE 'stage/innodb/alter%';
Query OK, 7 rows affected (0.00 sec)
Rows matched: 7  Changed: 7  Warnings: 0
</pre></li>

<li>Включите потребительским таблицам этапа событий, которые включают
<a href="perfor.htm#events-stages-current-table"><code>events_stages_current
</code></a>, <a href="perfor.htm#events-stages-history-table"><code>
events_stages_history</code></a> и
<a href="perfor.htm#events-stages-history-long-table"><code>
events_stages_history_long</code></a>.
<pre>
mysql&gt; UPDATE setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%stages%';
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0
</pre></li>

<li>Запустите <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
В этом примере столбец <code>middle_name</code> добавлен к таблице
базы данных образца.
<pre>
mysql&gt; ALTER TABLE employees.employees
                ADD COLUMN middle_name varchar(14)
                AFTER first_name;
Query OK, 0 rows affected (9.27 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre></li>

<li>Проверьте продвижение <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, запросив Performance Schema
<a href="perfor.htm#events-stages-current-table"><code>events_stages_current
</code></a>. Показанный случай этапа отличается в зависимости от текущей фазы
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Столбец
<code>WORK_COMPLETED</code> показывает завершенную работу.
<code>WORK_ESTIMATED</code> обеспечивает оценку остающейся работы.
<pre>
mysql&gt; SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED
                 FROM events_stages_current;
+------------------------------------------------------+----------------+----------------+
| EVENT_NAME                                           | WORK_COMPLETED | WORK_ESTIMATED |
+------------------------------------------------------+----------------+----------------+
| stage/innodb/alter table (read PK and internal sort) |  280           | 1245           |
+------------------------------------------------------+----------------+----------------+
1 row in set (0.01 sec)
</pre>

<p><a href="perfor.htm#events-stages-current-table"><code>
events_stages_current</code></a> возвращает пустой набор, если
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
завершилась. В этом случае Вы можете проверить
<a href="perfor.htm#events-stages-history-table"><code>events_stages_history
</code></a>, чтобы смотреть данные событий для завершенной работы. Например:
<pre>
mysql&gt; SELECT EVENT_NAME, WORK_COMPLETED, WORK_ESTIMATED
                 FROM events_stages_history;
+------------------------------------------------------+----------------+----------------+
| EVENT_NAME                                           | WORK_COMPLETED | WORK_ESTIMATED |
+------------------------------------------------------+----------------+----------------+
| stage/innodb/alter table (read PK and internal sort) |  886           | 1213           |
| stage/innodb/alter table (flush)                     | 1213           | 1213           |
| stage/innodb/alter table (log apply table)           | 1597           | 1597           |
| stage/innodb/alter table (end)                       | 1597           | 1597           |
| stage/innodb/alter table (log apply table)           | 1981           | 1981           |
+------------------------------------------------------+----------------+----------------+
5 rows in set (0.00 sec)
</pre>

<p>Как показано выше, <code>WORK_ESTIMATED</code> было пересмотрено во время
<code>ALTER TABLE</code>. Предполагаемая работа после завершения начальной
стадии 1213. Когда обработка <code>ALTER TABLE</code> завершалась,
<code>WORK_ESTIMATED</code> был установлен в фактическое
значение, которое является 1981.</p></li></ol>

<h3><a name="monitor-innodb-mutex-waits-performance-schema"></a>
16.15.2. Мониторинг InnoDB Mutex Waits с Performance Schema</h3>
<p>mutex это механизм синхронизации, используемый в коде, чтобы провести в
жизнь правило, что только один поток в установленный срок может иметь доступ
к общему ресурсу. Когда два или больше потоков в сервере должны получить
доступ к тому же самому ресурсу, потоки конкурируют друг против друга. Первый
поток, который получит блокировку на mutex, заставляет другие потоки ждать,
пока блокировка не выпущена.</p>

<p>Для <code>InnoDB</code> mutexes, которые инструментованы, mutex waits
может быть проверен, используя <a href="perfor.htm">Performance Schema</a>.
Данные событий ожидания, собранные в Performance Schema, могут помочь
идентифицировать mutexes с наибольшим ожиданием или самое большое общее
количество времени ожидания.</p>

<p>Следующий пример демонстрирует, как включить инструменты mutex wait,
как включить связанных потребителей и запросить данные событий.</p>
<ol type="1"><li><p>Чтобы видеть доступные инструменты mutex wait, запросите
Performance Schema <a href="perfor.htm#setup-instruments-table"><code>
setup_instruments</code></a>. Все инструменты mutex отключены по умолчанию.
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_instruments
    -&gt;          WHERE NAME LIKE '%wait/synch/mutex/innodb%';
+---------------------------------------------------------+---------+-------+
| NAME                                                    | ENABLED | TIMED |
+---------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/innobase_share_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/autoinc_persisted_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_flush_state_mutex      | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_LRU_list_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_free_list_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_free_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_hash_mutex         | NO      | NO    |
| wait/synch/mutex/innodb/buf_pool_zip_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/cache_last_read_mutex           | NO      | NO    |
| wait/synch/mutex/innodb/dict_foreign_err_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/dict_persist_dirty_tables_mutex | NO      | NO    |
| wait/synch/mutex/innodb/dict_sys_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/recalc_pool_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/fil_system_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/flush_list_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/fts_bg_threads_mutex            | NO      | NO    |
| wait/synch/mutex/innodb/fts_delete_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/fts_optimize_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/fts_doc_id_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/log_flush_order_mutex           | NO      | NO    |
| wait/synch/mutex/innodb/hash_table_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_bitmap_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_mutex                      | NO      | NO    |
| wait/synch/mutex/innodb/ibuf_pessimistic_insert_mutex   | NO      | NO    |
| wait/synch/mutex/innodb/log_sys_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/log_sys_write_mutex             | NO      | NO    |
| wait/synch/mutex/innodb/mutex_list_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/page_zip_stat_per_index_mutex   | NO      | NO    |
| wait/synch/mutex/innodb/purge_sys_pq_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/recv_sys_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/recv_writer_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/redo_rseg_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/noredo_rseg_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/rw_lock_list_mutex              | NO      | NO    |
| wait/synch/mutex/innodb/rw_lock_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/srv_dict_tmpfile_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/srv_innodb_monitor_mutex        | NO      | NO    |
| wait/synch/mutex/innodb/srv_misc_tmpfile_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/srv_monitor_file_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/buf_dblwr_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/trx_undo_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/trx_pool_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/trx_pool_manager_mutex          | NO      | NO    |
| wait/synch/mutex/innodb/srv_sys_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/lock_mutex                      | NO      | NO    |
| wait/synch/mutex/innodb/lock_wait_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/trx_mutex                       | NO      | NO    |
| wait/synch/mutex/innodb/srv_threads_mutex               | NO      | NO    |
| wait/synch/mutex/innodb/rtr_active_mutex                | NO      | NO    |
| wait/synch/mutex/innodb/rtr_match_mutex                 | NO      | NO    |
| wait/synch/mutex/innodb/rtr_path_mutex                  | NO      | NO    |
| wait/synch/mutex/innodb/rtr_ssn_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/trx_sys_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/zip_pad_mutex                   | NO      | NO    |
| wait/synch/mutex/innodb/master_key_id_mutex             | NO      | NO    |
+---------------------------------------------------------+---------+-------+
</pre></li>

<li>Некоторые mutex создаются при запуске сервера и инструментованы только,
если связанный инструмент также включен при запуске сервера. Чтобы
гарантировать, что все mutex инструментованы и включены, добавляют следующее
правило <code>performance-schema-instrument</code> к
конфигурационному файлу MySQL:
<pre>
performance-schema-instrument='wait/synch/mutex/innodb/%=ON'
</pre>

<p>Если Вы не требуете событий для всех mutexes,
Вы можете отключить определенные инструменты, добавляя дополнительные
правила <code>performance-schema-instrument</code> к Вашему конфигурационному
файлу MySQL. Например, чтобы отключить инструменты событий, связанные с
полнотекстовым поиском, добавляют следующее правило:
<pre>
performance-schema-instrument='wait/synch/mutex/innodb/fts%=OFF'
</pre>

<p>Правила с более длинным префиксом, например,
<code>wait/synch/mutex/innodb/fts%</code>
имеют приоритет перед правилами с более короткими префиксами, например,
<code>wait/synch/mutex/innodb/%</code>.</p>

<p>После добавления правил <code>performance-schema-instrument</code>
перезапустите сервер. Все <code>InnoDB</code> mutexes включены,
за исключением связанных с полнотекстовым поиском. Чтобы проверить, запросите
<a href="perfor.htm#setup-instruments-table"><code>setup_instruments</code>
</a>. Столбцы <code>ENABLED</code> и <code>TIMED</code> должны быть
установлены в <code>YES</code> для инструментов, которым Вы включали.
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_instruments
    -&gt;          WHERE NAME LIKE '%wait/synch/mutex/innodb%';
+-------------------------------------------------------+---------+-------+
| NAME                                                  | ENABLED | TIMED |
+-------------------------------------------------------+---------+-------+
| wait/synch/mutex/innodb/commit_cond_mutex             | YES     | YES   |
| wait/synch/mutex/innodb/innobase_share_mutex          | YES     | YES   |
| wait/synch/mutex/innodb/autoinc_mutex                 | YES     | YES   |
...
| wait/synch/mutex/innodb/master_key_id_mutex           | YES     | YES   |
+-------------------------------------------------------+---------+-------+
49 rows in set (0.00 sec)
</pre></li>

<li>Включите потребители событий, обновляя
<a href="perfor.htm#setup-consumers-table"><code>setup_consumers</code></a>.
Потребители событий отключены по умолчанию.
<pre>
mysql&gt; UPDATE performance_schema.setup_consumers SET enabled = 'YES'
    -&gt;        WHERE name like 'events_waits%';
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0
</pre>

<p>Вы можете проверить, что потребители событий включены, запрашивая
<a href="perfor.htm#setup-consumers-table"><code>setup_consumers</code></a>.
Потребителей <a href="perfor.htm#events-waits-current-table"><code>
events_waits_current</code></a>,
<a href="perfor.htm#events-waits-history-table"><code>events_waits_history
</code></a> и <a href="perfor.htm#events-waits-history-long-table"><code>
events_waits_history_long</code></a> нужно включить.
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | NO      |
| events_waits_current             | YES     |
| events_waits_history             | YES     |
| events_waits_history_long        | YES     |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
15 rows in set (0.00 sec)</pre></li>

<li>Как только инструменты и потребители включены, выполните рабочую
нагрузку, которую Вы хотите контролировать. В этом примере клиент
<a href="programs.htm#mysqlslap"><span><strong>mysqlslap</strong></span></a>
эмулирует загрузки, чтобы смоделировать рабочую нагрузку.
<pre>
shell&gt; ./mysqlslap --auto-generate-sql --concurrency=100 --iterations=10
    -&gt;             --number-of-queries=1000 --number-char-cols=6
                      --number-int-cols=6;
</pre></li>

<li>Запросите данные событий. В этом примере данные событий запрошены от
<a href="perfor.htm#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a>, которая агрегирует
данные в таблицах <a href="perfor.htm#events-waits-current-table"><code>
events_waits_current</code></a>,
<a href="perfor.htm#events-waits-history-table"><code>events_waits_history
</code></a> и <a href="perfor.htm#events-waits-history-long-table"><code>
events_waits_history_long</code></a>.
Данные получены в итоге именем событий (<code>EVENT_NAME</code>),
которое является названием инструмента, который произвел случай. Полученные в
итоге данные включают:</p>

<ul><li><p><code>COUNT_STAR</code></p>
<p>Число полученных в итоге событий.</li>
<li><code>SUM_TIMER_WAIT</code></p>
<p>Общее количество времени событий.</li>

<li><code>MIN_TIMER_WAIT</code></p>
<p>Минимум времени события.</li>
<li><code>AVG_TIMER_WAIT</code></p>
<p>Среднее время события.</li>
<li><code>MAX_TIMER_WAIT</code></p>
<p>Максимум времени события.</li></ul>

<p>Следующий запрос возвращает инструментальное имя
(<code>EVENT_NAME</code>), число событий (<code>COUNT_STAR</code>)
и общее время событий для этого инструмента (<code>SUM_TIMER_WAIT</code>).
Поскольку время рассчитано в пикосекундах по умолчанию, времена разделены на
1000000000, чтобы показать времена в миллисекундах. Данные представлены в
порядке убывания числа полученных событий (<code>COUNT_STAR</code>).
Вы можете корректировать <code>ORDER BY</code>, чтобы упорядочить данные
общим количеством времени ожидания.
<pre>
mysql&gt; SELECT EVENT_NAME, COUNT_STAR,
                 SUM_TIMER_WAIT/1000000000 SUM_TIMER_WAIT_MS
    -&gt;        FROM performance_schema.events_waits_summary_global_by_event_name
    -&gt;        WHERE SUM_TIMER_WAIT &gt; 0 AND EVENT_NAME
    -&gt;        LIKE 'wait/synch/mutex/innodb/%' ORDER BY COUNT_STAR DESC;
+---------------------------------------------------------+------------+-------------------+
| EVENT_NAME                                              | COUNT_STAR | SUM_TIMER_WAIT_MS |
+---------------------------------------------------------+------------+-------------------+
| wait/synch/mutex/innodb/trx_mutex                       | 201111     | 23.4719           |
| wait/synch/mutex/innodb/fil_system_mutex                |  62244     |  9.6426           |
| wait/synch/mutex/innodb/redo_rseg_mutex                 |  48238     |  3.1135           |
| wait/synch/mutex/innodb/log_sys_mutex                   |  46113     |  2.0434           |
| wait/synch/mutex/innodb/trx_sys_mutex                   |  35134     | 1068.1588         |
| wait/synch/mutex/innodb/lock_mutex                      |  34872     | 1039.2589         |
| wait/synch/mutex/innodb/log_sys_write_mutex             |  17805     | 1526.0490         |
| wait/synch/mutex/innodb/dict_sys_mutex                  |  14912     | 1606.7348         |
| wait/synch/mutex/innodb/trx_undo_mutex                  |  10634     |  1.1424           |
| wait/synch/mutex/innodb/rw_lock_list_mutex              |   8538     |  0.1960           |
| wait/synch/mutex/innodb/buf_pool_free_list_mutex        |   5961     |  0.6473           |
| wait/synch/mutex/innodb/trx_pool_mutex                  |   4885     | 8821.7496         |
| wait/synch/mutex/innodb/buf_pool_LRU_list_mutex         |   4364     |  0.2077           |
| wait/synch/mutex/innodb/innobase_share_mutex            |   3212     |  0.2650           |
| wait/synch/mutex/innodb/flush_list_mutex                |   3178     |  0.2349           |
| wait/synch/mutex/innodb/trx_pool_manager_mutex          |   2495     |  0.1310           |
| wait/synch/mutex/innodb/buf_pool_flush_state_mutex      |   1318     |  0.2161           |
| wait/synch/mutex/innodb/log_flush_order_mutex           |   1250     |  0.0893           |
| wait/synch/mutex/innodb/buf_dblwr_mutex                 | 951        |  0.0918           |
| wait/synch/mutex/innodb/recalc_pool_mutex               | 670        |  0.0942           |
| wait/synch/mutex/innodb/dict_persist_dirty_tables_mutex | 345        |  0.0414           |
| wait/synch/mutex/innodb/lock_wait_mutex                 | 303        |  0.1565           |
| wait/synch/mutex/innodb/autoinc_mutex                   | 196        |  0.0213           |
| wait/synch/mutex/innodb/autoinc_persisted_mutex         | 196        |  0.0175           |
| wait/synch/mutex/innodb/purge_sys_pq_mutex              | 117        |  0.0308           |
| wait/synch/mutex/innodb/srv_sys_mutex                   | 94         |  0.0077           |
| wait/synch/mutex/innodb/ibuf_mutex                      | 22         |  0.0086           |
| wait/synch/mutex/innodb/recv_sys_mutex                  | 12         |  0.0008           |
| wait/synch/mutex/innodb/srv_innodb_monitor_mutex        | 4          |        0.0009     |
| wait/synch/mutex/innodb/recv_writer_mutex               |   1        |  0.0005           |
+---------------------------------------------------------+------------+-------------------+
</pre>

<p>Предыдущий набор результатов включает данные событий, произведенные во
время процесса запуска. Чтобы исключить эти данные, Вы можете усечь
<a href="perfor.htm#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a>
немедленно после запуска прежде, чем выполнить Вашу рабочую нагрузку. Однако,
само усекание может произвести незначительное количество данных событий.
<pre>
mysql&gt; TRUNCATE performance_schema.events_waits_summary_global_by_event_name;
</pre></li></ol>

<h2><a name="innodb-monitors"></a>16.16. Мониторы InnoDB</h2>
<p>Мониторы <code>InnoDB</code> предоставляют информацию о внутреннем
состоянии. Эта информация полезна для исполнительной настройки.</p>

<h3><a name="innodb-monitor-types"></a>16.16.1. Типы мониторов InnoDB</h3>
<p>Есть два типа мониторов <code>InnoDB</code>:</p>
<ul><li><p>Стандартный <code>InnoDB</code> Monitor
выводит на экран следующие типы информации:</p>

<ul><li><p>Табличные и блокировки записей каждой активной транзакцией.</li>
<li>Блокировка ждет транзакции.</li>
<li>Семафор ждет потоков.</li>

<li>Запросы ввода/вывода файла на ожидании.</li>
<li>Статистика буферного пула.</li>
<li>Чистка и слияние буфера изменений основного потока.</p></li></ul></li>
<li><p><code>InnoDB</code> Lock Monitor печатает дополнительную информацию о
блокировке как часть <code>InnoDB</code> Monitor.</p></li></ul>

<h3><a name="innodb-enabling-monitors"></a>16.16.2.
Включение мониторов InnoDB</h3>
<p>Когда Вы включаете мониторы для периодического вывода, <code>InnoDB</code>
пишет их вывод в вывод ошибок сервера
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
(<code>stderr</code>). В этом случае, никакой вывод не посылают клиентам.
Когда включены, мониторы <code>InnoDB</code> печатают данные о каждых 15
секундах. Вывод сервера обычно направляется к журналу ошибок (см.
<a href="server.htm#error-log">раздел 6.4.2</a>). Эти данные полезны в
исполнительной настройке. В Windows запустите сервер из командной строки в
консоли с опцией <a href="server.htm#option_mysqld_console"><code>--console
</code></a>, если Вы хотите направить вывод в окно, а не в журнал ошибок.</p>

<p><code>InnoDB</code> посылает диагностический вывод в
<code>stderr</code> или к файлам, а не к <code>stdout</code>
или буферам памяти фиксированного размера, чтобы избежать потенциального
переполнения. Как побочный эффект, вывод
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>
написан в файл состояния в каталоге данных MySQL каждые пятнадцать секунд.
Название файла <code>innodb_status.<em><code>pid</code></em></code>, где
<em><code>pid</code></em> ID процесса сервера. <code>InnoDB</code>
удаляет этот файл при нормальном завершении работы. Если неправильные
завершения работы произошли, экземпляры этих файлов состояния могут
присутствовать и должны быть удалены вручную. Прежде, чем удалить их, Вы
могли бы исследовать их, чтобы видеть, содержат ли они полезную информацию о
причине неправильных завершений работы. Файл
<code>innodb_status.<em><code>pid</code></em></code>
создается только, если включен параметр конфигурации
<a href="#option_mysqld_innodb-status-file"><code>
innodb-status-file=1</code></a>.</p>

<p>Мониторы <code>InnoDB</code> нужно включить только, когда Вы фактически
хотите видеть информацию о мониторе, потому что вывод действительно приводит
к некоторому снижению работоспособности. Кроме того, если Вы включаете вывод
монитора, Ваш журнал ошибок может стать довольно большим, если Вы забываете
отключить это позже.</p>

<p>Чтобы помочь с поиском неисправностей, <code>InnoDB</code>
временно включает стандартный <code>InnoDB</code> Monitor
определенных условиях. Для получения дополнительной информации см.
<a href="#innodb-troubleshooting">раздел 16.20</a>.</p>

<p>Вывод монитора <code>InnoDB</code> начинается с заголовка, содержащего
метку времени и имя монитора. Например:
<pre>
=====================================
2014-10-16 18:37:29 0x7fc2a95c1700 INNODB MONITOR OUTPUT
=====================================
</pre>

<p>Заголовок для стандартного <code>InnoDB</code> Monitor
(<code>INNODB MONITOR OUTPUT</code>) также используется для монитора
блокировки потому, что последний дает тот же самый вывод с добавлением
дополнительной информации о блокировке.</p>

<p>Системные переменные <a href="#sysvar_innodb_status_output">
<code>innodb_status_output</code></a> и
<a href="#sysvar_innodb_status_output_locks"><code>
innodb_status_output_locks</code></a> используются, чтобы включить
стандартный <code>InnoDB</code> Monitor и <code>InnoDB</code> Lock Monitor.
</p>
<p>Чтобы включать и отключать мониторы <code>InnoDB</code> нужна привилегия
<a href="security.html#priv_process"><code>PROCESS</code></a>.</p>

<h4><a name="idm139965316044320"></a>Включение стандартного монитора InnoDB
</h4>
<p>Включите стандартный <code>InnoDB</code> Monitor, устанавливая
<a href="#sysvar_innodb_status_output"><code>innodb_status_output
</code></a> в <code>ON</code>.
<pre>
set GLOBAL innodb_status_output=ON;
</pre>

<p>Отключите стандартнычй <code>InnoDB</code> Monitor, устанавливая
<a href="#sysvar_innodb_status_output"><code>innodb_status_output
</code></a> в <code>OFF</code>.</p>

<p>Когда Вы закрываете сервер,
<a href="#sysvar_innodb_status_output"><code>innodb_status_output
</code></a> установлена в значение по умолчанию <code>OFF</code>.</p>

<h4><a name="idm139965316034240"></a>Получение вывода стандартного
InnoDB Monitor по требованию</h4>
<p>Как альтернатива включению стандартного <code>InnoDB</code> Monitor
для периодического вывода, Вы можете получить вывод стандартного
<code>InnoDB</code> Monitor по требованию использованием
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>,
который приносит вывод Вашей программе клиента. Если Вы используете
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>, вывод
более читаем, если Вы заменяете обычный разделитель запроса,
точку с запятой, на <code>\G</code>:
<pre>
mysql&gt; SHOW ENGINE INNODB STATUS\G
</pre>
<p><a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>
также включает данные <code>InnoDB</code> Lock Monitor, если он включен.</p>

<h4><a name="idm139965316023648"></a>Включение InnoDB Lock Monitor</h4>
<p>Данные <code>InnoDB</code>Lock Monitor напечатаны в вывод стандартного
<code>InnoDB</code> Monitor. Оба монитора нужно включить.</p>

<p>Чтобы включить <code>InnoDB</code> Lock Monitor, установите
<a href="#sysvar_innodb_status_output_locks"><code>
innodb_status_output_locks</code></a> в <code>ON</code>:
<pre>
set GLOBAL innodb_status_output=ON;
set GLOBAL innodb_status_output_locks=ON;
</pre>

<p>Когда Вы закрываете сервер, переменные
<a href="#sysvar_innodb_status_output"><code>innodb_status_output
</code></a> и <a href="#sysvar_innodb_status_output_locks"><code>
innodb_status_output_locks</code></a> установлены в значение
по умолчанию <code>OFF</code>.</p>

<p>Чтобы выключить <code>InnoDB</code> Lock Monitor, установите
<a href="#sysvar_innodb_status_output_locks"><code>
innodb_status_output_locks</code></a> в <code>OFF</code>. Установите
<a href="#sysvar_innodb_status_output"><code>innodb_status_output
</code></a> в OFF, чтобы также отключить
стандартный <code>InnoDB</code> Monitor.</p>

<p>Чтобы включить <code>InnoDB</code> Lock Monitor для
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB
STATUS</code></a>, Вы только включать обязаны
<a href="#sysvar_innodb_status_output_locks"><code>
innodb_status_output_locks</code></a>.</p>

<h3><a name="innodb-standard-monitor"></a>16.16.3.
Вывод InnoDB Standard Monitor и Lock Monitor</h3>
<p>Lock Monitor то же самое, как Standard Monitor за исключением того, что
он включает дополнительную информацию о блокировке. Включение любого монитора
для периодического вывода включает тот же самый выходной поток, но поток
включает дополнительную информацию, если включен Lock Monitor.
Например, если Вы включаете Standard Monitor и Lock Monitor,
это включает единственный выходной поток. Поток включает дополнительную
информацию о блокировке, пока Вы не отключаете Lock Monitor.</p>

<p>Вывод Standard Monitor ограничен 1 МБ, когда произведен, используя
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.
Этот предел не применяется к выводу, написанному в вывод ошибок сервера.</p>

<p>Пример вывода Standard Monitor:
<pre>
mysql&gt; SHOW ENGINE INNODB STATUS\G
*************************** 1. row ***************************
  Type: InnoDB
  Name:
Status:
=====================================
2014-10-16 18:37:29 0x7fc2a95c1700 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 20 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 38 srv_active, 0 srv_shutdown, 252 srv_idle
srv_master_thread log flush and writes: 290
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 119
OS WAIT ARRAY INFO: signal count 103
Mutex spin waits 0, rounds 0, OS waits 0
RW-shared spins 38, rounds 76, OS waits 38
RW-excl spins 2, rounds 9383715, OS waits 3
RW-sx spins 0, rounds 0, OS waits 0
Spin rounds per wait: 0.00 mutex, 2.00 RW-shared, 4691857.50 RW-excl,
0.00 RW-sx
------------------------
LATEST FOREIGN KEY ERROR
------------------------
2014-10-16 18:35:18 0x7fc2a95c1700 Transaction:
TRANSACTION 1814, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s), undo log entries 3
MySQL thread id 2, OS thread handle 140474041767680, query id 74 localhost
root update
INSERT INTO child VALUES
(NULL, 1)
, (NULL, 2)
, (NULL, 3)
, (NULL, 4)
, (NULL, 5)
, (NULL, 6)
Foreign key constraint fails for table `mysql`.`child`:
,
  CONSTRAINT `child_ibfk_1` FOREIGN KEY (`parent_id`) REFERENCES `parent`
  (`id`) ON DELETE CASCADE ON UPDATE CASCADE
Trying to add in child table, in index par_ind tuple:
DATA TUPLE: 2 fields;
 0: len 4; hex 80000003; asc ;;
 1: len 4; hex 80000003; asc ;;

But in parent table `mysql`.`parent`, in index PRIMARY,
the closest match we can find is record:
PHYSICAL RECORD: n_fields 3; compact format; info bits 0
 0: len 4; hex 80000004; asc ;;
 1: len 6; hex 00000000070a; asc   ;;
 2: len 7; hex aa0000011d0134; asc   4;;

------------------------
LATEST DETECTED DEADLOCK
------------------------
2014-10-16 18:36:30 0x7fc2a95c1700
*** (1) TRANSACTION:
TRANSACTION 1824, ACTIVE 9 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)
MySQL thread id 3, OS thread handle 140474041501440, query id 80 localhost
root updating
DELETE FROM t WHERE i = 1
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 3 n bits 72 index GEN_CLUST_INDEX of table
`mysql`.`t` trx id 1824 lock_mode X waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info
bits 0
 0: len 6; hex 000000000200; asc   ;;
 1: len 6; hex 00000000071f; asc   ;;
 2: len 7; hex b80000012b0110; asc +  ;;
 3: len 4; hex 80000001; asc ;;

*** (2) TRANSACTION:
TRANSACTION 1825, ACTIVE 29 sec starting index read
mysql tables in use 1, locked 1
4 lock struct(s), heap size 1136, 3 row lock(s)
MySQL thread id 2, OS thread handle 140474041767680, query id 81 localhost
root updating
DELETE FROM t WHERE i = 1
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 35 page no 3 n bits 72 index GEN_CLUST_INDEX of table
`mysql`.`t` trx id 1825 lock mode S
Record lock, heap no 1 PHYSICAL RECORD: n_fields 1; compact format; info
bits 0
 0: len 8; hex 73757072656d756d; asc supremum;;

Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info bits 0
 0: len 6; hex 000000000200; asc   ;;
 1: len 6; hex 00000000071f; asc   ;;
 2: len 7; hex b80000012b0110; asc +  ;;
 3: len 4; hex 80000001; asc ;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 35 page no 3 n bits 72 index GEN_CLUST_INDEX of table
`mysql`.`t` trx id 1825 lock_mode X waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 4; compact format; info
bits 0
 0: len 6; hex 000000000200; asc   ;;
 1: len 6; hex 00000000071f; asc   ;;
 2: len 7; hex b80000012b0110; asc +  ;;
 3: len 4; hex 80000001; asc ;;

*** WE ROLL BACK TRANSACTION (1)
------------
TRANSACTIONS
------------
Trx id counter 1950
Purge done for trx's n:o &lt; 1933 undo n:o &lt; 0 state: running but idle
History list length 23
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421949033065200, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421949033064280, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 1949, ACTIVE 0 sec inserting
mysql tables in use 1, locked 1
8 lock struct(s), heap size 1136, 1850 row lock(s), undo log entries 17415
MySQL thread id 4, OS thread handle 140474041235200, query id 176 localhost
root update
INSERT INTO `salaries` VALUES (55723,39746,'1997-02-25','1998-02-25'),
(55723,40758,'1998-02-25','1999-02-25'),(55723,44559,'1999-02-25','2000-02-25'),
(55723,44081,'2000-02-25','2001-02-24'),(55723,44112,'2001-02-24','2001-08-16'),
(55724,46461,'1996-12-06','1997-12-06'),(55724,48916,'1997-12-06','1998-12-06'),
(55724,51269,'1998-12-06','1999-12-06'),(55724,51932,'1999-12-06','2000-12-05'),
(55724,52617,'2000-12-05','2001-12-05'),(55724,56658,'2001-12-05','9999-01-01'),
(55725,40000,'1993-01-30','1994-01-30'),(55725,41472,'1994-01-30','1995-01-30'),
(55725,45293,'1995-01-30','1996-01-30'),(55725,473
--------
FILE I/O
--------
I/O thread 0 state: waiting for completed aio requests (insert buffer thread)
I/O thread 1 state: waiting for completed aio requests (log thread)
I/O thread 2 state: waiting for completed aio requests (read thread)
I/O thread 3 state: waiting for completed aio requests (read thread)
I/O thread 4 state: waiting for completed aio requests (read thread)
I/O thread 5 state: waiting for completed aio requests (read thread)
I/O thread 6 state: waiting for completed aio requests (write thread)
I/O thread 7 state: waiting for completed aio requests (write thread)
I/O thread 8 state: waiting for completed aio requests (write thread)
I/O thread 9 state: waiting for completed aio requests (write thread)
Pending normal aio reads: 0 [0, 0, 0, 0] , aio writes: 0 [0, 0, 0, 0] ,
 ibuf aio reads: 0, log i/o's: 0, sync i/o's: 0
Pending flushes (fsync) log: 0; buffer pool: 0
224 OS file reads, 5770 OS file writes, 803 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 264.84 writes/s, 23.05 fsyncs/s
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, node heap has 444 buffer(s)
68015.25 hash searches/s, 106259.24 non-hash searches/s
---
LOG
---
Log sequence number 165913808
Log flushed up to   164814979
Pages flushed up to 141544038
Last checkpoint at  130503656
0 pending log flushes, 0 pending chkp writes
258 log i/o's done, 6.65 log i/o's/second
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers   124908
Database pages 5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
----------------------
INDIVIDUAL BUFFER POOL INFO
----------------------
---BUFFER POOL 0
Buffer pool size   65536
Free buffers   62412
Database pages 2899
Old database pages 1050
Modified db pages  449
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 3, not young 0
0.05 youngs/s, 0.00 non-youngs/s
Pages read 107, created 2792, written 2586
0.00 reads/s, 92.65 creates/s, 122.89 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead
0.00/s
LRU len: 2899, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
---BUFFER POOL 1
Buffer pool size   65536
Free buffers   62496
Database pages 2821
Old database pages 1021
Modified db pages  461
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 1, not young 0
0.05 youngs/s, 0.00 non-youngs/s
Pages read 90, created 2731, written 2474
0.00 reads/s, 98.25 creates/s, 122.04 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead
0.00/s
LRU len: 2821, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
--------------
ROW OPERATIONS
--------------
0 queries inside InnoDB, 0 queries in queue
0 read views open inside InnoDB
Process ID=35909, Main thread ID=140471692396288, state: sleeping
Number of rows inserted 1526363, updated 0, deleted 3, read 11
52671.72 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s
----------------------------
END OF INNODB MONITOR OUTPUT
============================
</pre>

<h4><a name="innodb-standard-monitor-output-разделs"></a>
Разделы вывода Standard Monitor</h4>
<p>Для описания каждой метрики, о которой сообщает Standard Monitor см.
раздел <a href="../../../dev.mysql.com/doc/mysql-em-plugin/en/myoem-metrics.html"
target="_top">Metrics</a> в
<a href="../../../dev.mysql.com/doc/mysql-em-plugin/en/default.htm" target="_top">
Oracle Enterprise Manager for MySQL Database User's Guide</a>.</p>

<p><span>Status</span></p>
<p>Этот раздел показывает timestamp, имя монитора и число секунд, на котором
основаны средние числа. Число секунд время, прошедшее между текущим временем
и выводом монитора в прошлый раз.</p>

<p><span>BACKGROUND THREAD</span></p>
<p>Строки <code>srv_master_thread</code> показывают работу, сделанную
основным фоновым потоком.</p>

<p><span>SEMAPHORES</span></p>
<p>Этот раздел сообщает о потоках, ждущих семафора, и статистику по тому,
сколько раз потоки нуждались в mutex или rw-lock.
Большое количество потоков, ждущих семафоров, может быть результатом
дискового ввода/вывода или проблемами внутри <code>InnoDB</code>.
Это может произойти из-за тяжелого параллелизма запросов или проблем в
планировании потока операционной системы. Установка
<a href="#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a> меньше значения по умолчанию, могло бы
помочь в таких ситуациях. Строка <code>Spin rounds per wait</code>
показывает число спин-блокировки на ожидание OS mutex.</p>
<p>Метрики Mutex сообщает
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB MUTEX</code></a>.</p>

<p><span>LATEST FOREIGN KEY ERROR</span></p>
<p>Этот раздел предоставляет информацию о новой ошибке ограничения внешнего
ключа. Это не присутствует, если никакая такая ошибка не произошла.
Содержание включает запрос, который потерпел неудачу, информацию об
ограничении, которое потерпело неудачу и таблицах.</p>

<p><span>LATEST DETECTED DEADLOCK</span></p>
<p>Этот раздел предоставляет информацию о новом тупике. Это не присутствует,
если никакой тупик не произошел. Показывает, какие транзакции вовлечены,
запросы, которые каждая пыталась выполнить, блокировки, которые они имеют и
нуждаются, и которая транзакция откатывается, чтобы найти выход из тупика.
Режимы блокировки в этом разделе, объяснены в
<a href="#innodb-locking">разделе 16.5.1</a>.</p>

<p><span>TRANSACTIONS</span></p>
<p>Если этот раздел сообщает об ожидании блокировок, у Ваших приложений могло
бы быть утверждение блокировки. Вывод может также помочь проследить
причины операционных тупиков.</p>

<p><span>FILE I/O</span></p>
<p>Этот раздел предоставляет информацию о потоках, которые
<code>InnoDB</code> использует, чтобы выполнить различные типы ввода/вывода.
Первые из них посвящены общей обработке <code>InnoDB</code>.
Содержание также выводит на экран информацию для операций ввода/вывода в
ожидании и статистику для работы ввода/вывода.</p>

<p>Числом этих потоков управляют
<a href="#sysvar_innodb_read_io_threads"><code>
innodb_read_io_threads</code></a> и
<a href="#sysvar_innodb_write_io_threads"><code>
innodb_write_io_threads</code></a>. См.
<a href="#innodb-parameters">раздел 16.13</a>.</p>

<p><span>INSERT BUFFER AND ADAPTIVE HASH INDEX</span></p>
<p>Этот раздел показывает состояние буфер вставки (также называемого
<a href="glossary.htm#glos_change_buffer">буфером изменений</a>)
и адаптивный хеш индекса.</p>
<p>См. разделы <a href="#innodb-insert-buffering">16.4.2</a> и
<a href="#innodb-adaptive-hash">16.4.3</a>.</p>

<p><span>LOG</span></p>
<p>Этот раздел выводит на экран информацию о журнале. Содержание включает
текущий порядковый номер журнала, как давно журнал сброшен на диск и позицию,
в которой <code>InnoDB</code> последний раз взял контрольную точку. См.
<a href="#innodb-checkpoints">раздел 16.11.3</a>.
Раздел также выводит на экран информацию об ожидании записи и
исполнительную статистику записей.</p>

<p><span>BUFFER POOL AND MEMORY</span></p>
<p>Этот раздел дает Вам статистику по чтению и записи страниц. Вы можете
вычислить от этих чисел, сколько операций ввода/вывода файла с данными Ваши
запросы в настоящее время делают.</p>

<p>Для описаний статистики буферного пула см.
<a href="#innodb-buffer-pool-monitoring">
раздел 16.6.3.9</a>. Для дополнительной информации о работе буферного пула
см. <a href="#innodb-buffer-pool">раздел 16.6.3.1</a>.</p>

<p><span>ROW OPERATIONS</span></p>
<p>Этот раздел показывает то, что основной поток делает, включая число и
исполнительный уровень для каждого типа работы строки.</p>

<h2><a name="innodb-backup"></a>16.17. Резервирование и восстановление InnoDB
</h2>
<p>Ключ к безопасному управлению базой данных это регулярные резервные копии.
В зависимости от Вашего объема данных, числа серверов MySQL и рабочей
нагрузки базы данных, Вы можете использовать эти методы,
один или в комбинации:
<a href="glossary.htm#glos_hot_backup">hot backup</a> с MySQL
Enterprise Backup; <a href="glossary.htm#glos_cold_backup">cold backup</a>,
копируя файлы в то время, как сервер MySQL закрыт,
<a href="glossary.htm#glos_physical_backup">физическое резервное копирование
</a> для быстрой работы (специально для восстановления),
<a href="glossary.htm#glos_logical_backup">логическое резервное копирование
</a> с <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a> для малых объемов данных или чтобы сделать запись
структуры объектов схемы.</p>

<h3><a name="idm139965315912656"></a>Hot Backups</h3>
<p><span><strong>mysqlbackup</strong></span>, компонент MySQL Enterprise
Backup, позволяет Вам поддерживать рабочий сервер MySQL, включая таблицы
<code>InnoDB</code> и <a href="storage.htm#myisam-storage-engine"><code>
MyISAM</code></a>, с минимальными проблемами, производя последовательный
снимок базы данных. Когда <span><strong>mysqlbackup</strong></span>
копирует таблицы <code>InnoDB</code>, чтения и записи таблиц
<code>InnoDB</code> и <code>MyISAM</code> продолжаются.
Во время копирования <code>MyISAM</code> чтения (но не записи) тех таблиц
разрешены. Резервное копирование MySQL Enterprise может также создать сжатые
резервные файлы и поддержать подмножества таблиц и баз данных. В соединении с
двоичным журналом MySQL, пользователи могут выполнить восстановление момента
времени. Резервное копирование MySQL Enterprise это часть подписки MySQL
Enterprise. Для большего количества деталей см.
<a href="mysql.htm#mysql-enterprise-backup">раздел 27.2</a>.</p>

<h3><a name="idm139965315903632"></a>Cold Backups</h3>
<p>Если Вы можете закрыть свой сервер MySQL, Вы можете сделать двоичное
резервное копирование, которое состоит из всех файлов, используемых
<code>InnoDB</code>. Используйте следующую процедуру:</p>

<ol type="1"><li><p>Сделайте <a href="glossary.htm#glos_slow_shutdown">
медленное завершение работы</a> сервера MySQL и удостоверьтесь, что он
останавливается без ошибок.</li>

<li>Скопируйте все файлы с данными <code>InnoDB</code>
(<code>ibdata</code> и <code>.ibd</code>) в безопасное место.</li>
<li>Скопируйте все файлы журналов <code>InnoDB</code>
(<code>ib_logfile</code>).</li>
<li>Скопируйте Ваш конфигурационный файл или файлы.</p></li></ol>

<h3><a name="idm139965315892224"></a>Альтернативные типы резервирования</h3>
<p>В дополнение к созданию двоичных резервных копий как только что описано,
регулярно делайте дампы своих таблиц с помощью
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>.
Двоичный файл мог бы быть поврежден незаметно. Выведенные таблицы сохранены в
текстовые файлы, которые удобочитаемы, так табличное повреждение становится
легче найти. Кроме того, потому что формат более прост, шанс серьезного
повреждения данных меньше. <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> также имеет опцию
<a href="programs.htm#option_mysqldump_single-transaction"><code>
--single-transaction</code></a> для того, чтобы сделать последовательный
снимок без блокировки других клиентов. См.
<a href="backup-and-recovery.html#backup-policy">раздел 8.3.1</a>.</p>

<p>Репликация работает с таблицами <a href="innodb.htm"><code>InnoDB</code>
</a>, таким образом, Вы можете использовать способности репликации MySQL
сохранить копию Вашей базы данных на серверах базы данных,
требующих высокой доступности.</p>

<h3><a name="idm139965315884736"></a>Выполнение восстановления</h3>
<p>Чтобы вернуть базу данных к состоянию, в котором было сделано
резервное копирование, Вы должны выполнить свой сервер MySQL с включенным
двоичным журналированием прежде, чем взять резервное копирование. Чтобы
достигнуть восстановления момента времени после восстановления резервного
копирования, Вы можете применить изменения от двоичного журнала, которые
произошли после того, как резервное копирование было сделано. См.
<a href="backup-and-recovery.html#point-in-time-recovery">раздел 8.5</a>.</p>

<p>Чтобы оправиться от катастрофического отказа Вашего сервера MySQL,
единственное требование это его перезапустить.
<code>InnoDB</code> автоматически проверяет журналы и выполняет откат вперёд
базы данных. <code>InnoDB</code> автоматически откатывает до прежнего уровня
нейтральные транзакции, которые присутствовали во время катастрофического
отказа. Во время восстановления <a href="programs.htm#mysqld"><span><strong>
mysqld</strong></span></a> выводит что-то вроде этого:
<pre>
InnoDB: Database was not shut down normally.
InnoDB: Starting recovery from log files...
InnoDB: Starting log scan based on checkpoint at
InnoDB: log sequence number 0 13674004
InnoDB: Doing recovery: scanned up to log sequence number 0 13739520
InnoDB: Doing recovery: scanned up to log sequence number 0 13805056
InnoDB: Doing recovery: scanned up to log sequence number 0 13870592
InnoDB: Doing recovery: scanned up to log sequence number 0 13936128
...
InnoDB: Doing recovery: scanned up to log sequence number 0 20555264
InnoDB: Doing recovery: scanned up to log sequence number 0 20620800
InnoDB: Doing recovery: scanned up to log sequence number 0 20664692
InnoDB: 1 uncommitted transaction(s) which must be rolled back
InnoDB: Starting rollback of uncommitted transactions
InnoDB: Rolling back trx no 16745
InnoDB: Rolling back of trx no 16745 completed
InnoDB: Rollback of uncommitted transactions completed
InnoDB: Starting an apply batch of log records to the database...
InnoDB: Apply batch completed
InnoDB: Started
mysqld: ready for connections
</pre>

<p>Если Ваша база данных становится поврежденной, или дисковый отказ
происходит, Вы должны выполнить восстановление, используя резервное
копирование. В случае повреждения сначала найдите резервную копию, которая не
повреждено. После восстановления основной копии сделайте восстановление
момента времени после двоичных файлов системного журнала, используя
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong>
</span></a> и <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a>, чтобы восстановить изменения, которые произошли после того, как
резервное копирование было сделано.</p>

<p>В некоторых случаях повреждения базы данных достаточно только вывести,
удалить и обновить одну или несколько поврежденных таблиц. Вы можете
использовать <a href="sql.htm#check-table"><code>CHECK TABLE</code></a>,
чтобы проверить, повреждена ли таблица, хотя <a href="sql.htm#check-table">
<code>CHECK TABLE</code></a> не может обнаружить каждый
возможный вид повреждения.</p>

<p>В некоторых случаях очевидное повреждение страницы базы данных происходит
фактически из-за операционной системы, повреждающей ее собственный кэш файла,
и данные на диске могут быть в норме. Лучше всего попытаться перезапустить
Ваш компьютер. Это может устранить ошибки, которые, казалось, были
повреждением страницы базы данных. Если MySQL все еще испытывает затруднения,
запуска из-за проблемы последовательности <code>InnoDB</code>, см.
<a href="#forcing-innodb-recovery">раздел 16.20.2</a> для шагов,
чтобы запустить случай в диагностическом режиме, где Вы
можете вывести данные.</p>

<h3><a name="innodb-recovery"></a>16.17.1. Процесс восстановления InnoDB</h3>
<p><code>InnoDB</code> <a href="glossary.htm#glos_crash_recovery">
восстановление катастрофического отказа</a> состоит из нескольких шагов:</p>

<ul><li><p>Применение <a href="glossary.htm#glos_redo_log">журнала redo</a>:
Это первый шаг во время инициализации прежде, чем принять любые соединения.
Если все изменения сброшены из <a href="glossary.htm#glos_buffer_pool">
буферного пула</a> в <a href="glossary.htm#glos_tablespace">табличные
пространства</a> (файлы <code>ibdata*</code> и <code>*.ibd</code>)
во время завершения работы или катастрофического отказа, применение журнала
redo может быть пропущено. Если файлы системного журнала отсутствуют при
запуске, <code>InnoDB</code> пропустит этот шаг.</p>

<ul><li><p>Текущее максимальное значение счетчика auto-increment
записано в журнал redo каждый раз при изменении значения, что делает это
безопасным от катастрофического отказа. Во время восстановления
<code>InnoDB</code> сканирует журнал, чтобы собрать изменения значений.</p>
<p>См. <a href="#innodb-auto-increment-handling">раздел 16.8.5</a>.
</li>

<li>Когда поввреждено дерево индекса, <code>InnoDB</code> пишет
флаг повреждения в журнал redo, который делает флаг повреждения безопасным от
катастрофического отказа. <code>InnoDB</code> также пишет данные о флаге
повреждения в памяти механизма на каждой контрольной точке. Во время
восстановления <code>InnoDB</code> читает флаги повреждения от местоположений
и от результатов слияний прежде, чем отметить таблицу и
индекс как поврежденные.</li>

<li>Удаление журналов redo, чтобы убыстрить процесс восстановления, не
рекомендуется, даже если некоторая потеря данных является приемлемой.
Удаление считается опцией после того, как чистое завершение работы выполнено
с <a href="#sysvar_innodb_fast_shutdown"><code>innodb_fast_shutdown
</code></a>, установленной в <code>0</code> или <code>1</code>.
</p></li></ul></li>

<li><p><a href="glossary.htm#glos_rollback">Откат до прежнего уровня</a>
неполных <a href="glossary.htm#glos_transaction">транзакций</a>:
Любые транзакции, которые были активными во время катастрофического отказа
или <a href="glossary.htm#glos_fast_shutdown">быстрого завершения работы
</a>. Время, которое требуется, чтобы удалить неполную транзакцию, может быть
в три или четыре раза больше времени, которое транзакция была активной
прежде, чем это будет прервано, в зависимости от загрузки сервера.</p>

<p>Вы не можете отменить транзакции, которые находятся в процессе того, чтобы
быть откаченными до прежнего уровня. В крайних случаях, когда откат до
прежнего уровня транзакций, как ожидают, исключительно займет много времени,
может быть быстрее запустить <code>InnoDB</code> с
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a> = <code>3</code> или выше. См.
<a href="#forcing-innodb-recovery">раздел 16.20.2</a>.</li>

<li>Слияние <a href="glossary.htm#glos_change_buffer">буфера изменений</a>:
Применение изменений от буфера изменения (часть
<a href="glossary.htm#glos_system_tablespace">системного табличного
пространства</a>) к страницам листа вторичного индекса, когда индексные
страницы считаны в буферный пул.</li>

<li><a href="glossary.htm#glos_purge">Чистка</a>: Удаление отмеченных как
удаленные записей, которые больше не видимы для любой активной транзакции.
</p></li></ul>

<p>Шаги не зависят от журнала redo (кроме того, чтобы зарегистрировать
запись) и выполнены параллельно с нормальной обработкой. Из них только отмена
неполных транзакций является особенной. Буферное слияние вставки и чистка
выполнены во время нормальной обработки.</p>

<p>После применения журнала redo <code>InnoDB</code> пытается
принять соединения как можно раньше, уменьшить время простоя. Как часть
восстановления катастрофического отказа, <code>InnoDB</code>
откатывает любые транзакции, которые не были переданы или в статусе <code>XA
PREPARE</code>, когда сервер отказал. Отмена выполнена фоновым потоком,
выполненным параллельно с транзакциями от новых соединений. Пока работа
отмены не завершена, новые соединения могут столкнуться с конфликтами
блокировки с восстановленными транзакциями.</p>

<p>В большинстве ситуаций, даже если сервер MySQL был неожиданно уничтожен в
середине тяжелой деятельности, процесс восстановления происходит
автоматически, и никакое действие не требуется. Если отказ аппаратных средств
или серьезная системная ошибка повредили данные <code>InnoDB</code>, MySQL
мог бы отказаться запуститься. В этом случае см.
<a href="#forcing-innodb-recovery">раздел 16.20.2</a>.</p>
<p>См. <a href="server.htm#binary-log">раздел 6.4.4</a>.</p>

<h3><a name="innodb-recovery-tablespace-discovery"></a>16.17.2.
Открытие табличного пространства во время
восстановления катастрофического отказа</h3>
<p>Если во время восстановления катастрофического отказа <code>InnoDB</code>
находит журналы redo, записанные после последней контрольной точки, журналы
должны быть применены к затронутым табличным пространствам. Процесс, который
идентифицирует затронутые табличные пространства, упоминается как
<span><em>открытие табличного пространства</em></span>.</p>

<p>Открытие табличного пространства идентифицирует затронутые табличные
пространства, использующие на уровне файла записи <code>MLOG_FILE_NAME</code>
журнала redo, которые написаны в журнал, когда страница табличного
пространства изменена. <code>MLOG_FILE_NAME</code> содержит
<code>space_id</code> табличного пространства и имя файла.</p>

<p>На запуске <code>InnoDB</code> открывает системное табличное пространство
и журнал. Если в журнале redo есть записи, начиная с последней контрольной
точки, затронутые файлы табличного пространства открыты и восстановлены,
исходя из записей <code>MLOG_FILE_NAME</code>.</p>

<p>Записи <code>MLOG_FILE_NAME</code> внесены для всех постоянных типов
табличного пространства, включая табличные пространства file-per-table,
общее табличное пространство, системное табличное пространство и табличные
пространства журнала отмены.</p>

<p>Если записи <code>MLOG_FILE_NAME</code> для системного табличного
пространства не соответствуют конфигурации сервера, затрагивающей системные
имена файла с данными табличного пространства, восстановление терпит неудачу
с ошибкой прежде, чем журналы redo применены.</p>

<p>Во время восстановления журнал считан от последней контрольной точки до
обнаруженного логического конца журнала. Если файлы табличного пространства,
на которые ссылаются в просмотренной части журнала, отсутствуют,
запуск не происходит.</p>

<h2><a name="innodb-and-mysql-replication"></a>16.18.
InnoDB и репликация MySQL</h2>
<p>Возможно использовать репликацию в случае, где механизм хранения на
ведомом устройстве не тот же самый, как оригинальный механизм хранения на
ведущем устройстве. Например, Вы можете копировать модификации таблиц
<code>InnoDB</code> ведущего сервера в таблицы <code>MyISAM</code> на ведомом.
</p>
<p>См. раздел <a href="replica.htm#replication-setup-slaves">19.1.2.6</a> и
<a href="replica.htm#replication-snapshot-method">19.1.2.5</a>.</p>

<p>Чтобы сделать новое ведомое устройство, не снимая ведущее устройство или
существующее ведомое устройство, используйте
<a href="mysql.htm#mysql-enterprise-backup">MySQL Enterprise Backup</a>.</p>

<p>Транзакции, которые терпят неудачу на ведущем устройстве, не затрагивают
репликацию вообще. Репликация MySQL основана на двоичном журнале, где MySQL
пишет запросы SQL, которые изменяют данные. Транзакция, которая терпит
неудачу (например, из-за нарушения внешнего ключа или потому что она
откатилась до прежнего уровня) не написана в двоичный журнал, таким образом,
ее не посылают в ведомые устройства. См.
<a href="sql.htm#commit">раздел 14.3.1</a>.</p>

<p><b>Репликация и CASCADE. </b>
Расположенные каскадом действий для <code>InnoDB</code>
на ведущем устройстве копируются на ведомом устройстве
<span><em>только</em></span>, если таблицы, совместно использующие отношение
внешнего ключа, используют на ведущем и на ведомом устройствах. Это истина,
используете ли Вы основанную на запросе или на строке репликацию.
Предположите, что Вы запустили репликацию и затем составляете две таблицы на
ведущем устройстве, используя следующий
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE fc1 (i INT PRIMARY KEY, j INT) ENGINE = InnoDB;
CREATE TABLE fc2 (m INT PRIMARY KEY, n INT, FOREIGN KEY ni (n)
       REFERENCES fc1 (i) ON DELETE CASCADE) ENGINE = InnoDB;
</pre>

<p>Предположите, что ведомое устройство не имеет поддержки
<code>InnoDB</code>. Если это верно, тогда таблицы на ведомом устройстве
составлены, но они используют <code>MyISAM</code>, опция
<code>FOREIGN KEY</code> проигнорирована. Теперь мы вставляем некоторые
строки в таблицы на ведущем устройстве:
<pre>
master&gt; INSERT INTO fc1 VALUES (1, 1), (2, 2);
Query OK, 2 rows affected (0.09 sec)
Records: 2  Duplicates: 0  Warnings: 0

master&gt; INSERT INTO fc2 VALUES (1, 1), (2, 2), (3, 1);
Query OK, 3 rows affected (0.19 sec)
Records: 3  Duplicates: 0  Warnings: 0
</pre>

<p>В этот момент на ведущем и ведомом устройствах таблица
<code>fc1</code> содержит 2 строки, а <code>fc2</code> 3:
<pre>
master&gt; SELECT * FROM fc1;
+---+---+
| i | j |
+---+---+
| 1 | 1 |
| 2 | 2 |
+---+---+
2 rows in set (0.00 sec)

master&gt; SELECT * FROM fc2;
+---+---+
| m | n |
+---+---+
| 1 | 1 |
| 2 | 2 |
| 3 | 1 |
+---+---+
3 rows in set (0.00 sec)

slave&gt; SELECT * FROM fc1;
+---+---+
| i | j |
+---+---+
| 1 | 1 |
| 2 | 2 |
+---+---+
2 rows in set (0.00 sec)

slave&gt; SELECT * FROM fc2;
+---+---+
| m | n |
+---+---+
| 1 | 1 |
| 2 | 2 |
| 3 | 1 |
+---+---+
3 rows in set (0.00 sec)
</pre>

<p>Теперь предположите, что Вы выполняете следующий запрос
<a href="sql.htm#delete"><code>DELETE</code></a> на ведущем:
<pre>
master&gt; DELETE FROM fc1 WHERE i=1;
Query OK, 1 row affected (0.09 sec)
</pre>

<p>Из-за каскада таблица <code>fc2</code>
на ведущем устройстве теперь содержит только 1 строку:
<pre>
master&gt; SELECT * FROM fc2;
+---+---+
| m | n |
+---+---+
| 2 | 2 |
+---+---+
1 row in set (0.00 sec)
</pre>

<p>Однако, каскад не размножается на ведомом устройстве потому, что на
ведомом устройстве <a href="sql.htm#delete"><code>DELETE</code></a> для
<code>fc1</code> не удаляет строки из <code>fc2</code>.
Копия ведомого устройства <code>fc2</code> все еще содержит все строки,
которые были первоначально вставлены:
<pre>
slave&gt; SELECT * FROM fc2;
+---+---+
| m | n |
+---+---+
| 1 | 1 |
| 3 | 1 |
| 2 | 2 |
+---+---+
3 rows in set (0.00 sec)
</pre>

<p>Это различие следствие того, что расположеные каскадом удаления обработаны
внутренне <code>InnoDB</code>, что означает, что ни одно из
изменений не зарегистрировано.</p>

<h2><a name="innodb-memcached"></a>16.19. Плагин InnoDB memcached</h2>
<p>Плагин <code>InnoDB</code> <span><strong>memcached</strong></span>
(<code>daemon_memcached</code>) обеспечивает интегрированный демон
<span><strong>memcached</strong></span>, который автоматически хранит и
получает данные от <code>InnoDB</code> таблицы, превращая сервер MySQL в
быстрое хранилище <span><span>значений ключа</span></span>.
Вместо того, чтобы формулировать запросы в SQL, Вы можете использовать
простые операции <code>get</code>, <code>set</code> и <code>incr</code>,
которые избегают работы, связанной с парсингом SQL и построения плана
оптимизации запроса. Вы можете также получить доступ к тем же самым
таблицам <code>InnoDB</code> через SQL для удобства сложных запросов.</p>

<p>Этот <span><span>NoSQL-стиль</span></span> интерфейса использует
<span><strong>memcached</strong></span> API, чтобы ускорить операции базы
данных, позволяя <code>InnoDB</code> кэширование памяти дескриптора,
используя <a href="glossary.htm#glos_buffer_pool">буферный пул</a>.
Данные, изменные посредством команд <span><strong>memcached</strong></span>,
таких как <code>add</code>, <code>set</code> и <code>incr</code>,
сохранены на диск в таблицы <code>InnoDB</code>.
Комбинация простоты <span><strong>memcached</strong></span> с
надежностью и последовательностью <code>InnoDB</code>
предоставляют пользователям лучший вариант, как объяснено в
<a href="#innodb-memcached-benefits">разделе 16.19.1</a>. Для
краткого архитектурного обзора см.
<a href="#innodb-memcached-intro">раздел 16.19.2</a>.</p>

<h3><a name="innodb-memcached-benefits"></a>16.19.1.
Выгода от плагина InnoDB memcached</h3>
<p>Этот раздел способствует пониманию плагина
<code>daemon_memcached</code>. Комбинация
<code>InnoDB</code> таблиц и <span><strong>memcached</strong></span>
предлагает значительные преимущества.</p>

<ul><li><p>Прямой доступ к <code>InnoDB</code> избегает
парсинга и планирования SQL.</li>

<li>Запуск <span><strong>memcached</strong></span> в том же самом
пространстве процесса, в итоге сервер MySQL избегает накладных расходов сети
для прохождения запросов назад и вперед.</li>

<li>Данные, записанные через протокол <span><strong>memcached</strong>
</span>, прозрачно записаны в таблицу <code>InnoDB</code>,
не проходя MySQL уровень SQL. Вы можете управлять частотой записи, чтобы
достигнуть более высокой сырой производительности,
обновляя некритические данные.</li>

<li>Данные, запрошенные через <span><strong>memcached</strong></span>,
прозрачно запрошены от таблицы <code>InnoDB</code>,
не проходя MySQL уровень SQL.</li>

<li>Последующие запросы о тех же самых данных поданы от
буферного пула. Буферный пул обрабатывает кэширование в памяти. Вы можете
настроить исполнение информационно емкого использования операций через
параметры настройки <code>InnoDB</code>.</li>

<li>Данные могут быть неструктурированы или структурированы, в зависимости от
типа приложения. Вы можете составить новую таблицу для данных или
использовать существующие таблицы.</li>

<li><code>InnoDB</code> может обработать создание и разложение многократных
значений столбцов в единственное значение
<span><strong>memcached</strong></span>, уменьшая количество строкового
парсинга и связи, требуемой в Вашем приложении. Например, Вы можете сохранить
строковое значение <code>2|4|6|8</code> в
<span><strong>memcached</strong></span>, потом
разделить значение, основанное на символе разделителя, и сохраните результат
в четырех числовых столбцах.</li>

<li>Передача между памятью и диском обработана автоматически,
упрощая логику приложения.</li>
<li>Данные хранятся в базе данных MySQL, чтобы защитить от катастрофических
отказов, отключений электричества и повреждения.</li>

<li>Вы можете получить доступ к основной таблице
через SQL для сообщения, анализа, специальных запросов, оптовой загрузки,
многошаговых транзакционных вычислений и т.п.</li>

<li>Вы можете гарантировать высокую доступность при использовании
<code>daemon_memcached</code> на
<a href="glossary.htm#glos_master_server">главном сервере</a>
в комбинации с репликацией MySQL.</p></li></ul>

<ul><li><p>Интеграция <span><strong>memcached</strong></span> с MySQL
обеспечивает способ сделать данные в памяти постоянными, таким образом, Вы
можете использовать это для более существенных видов данных. Вы можете
использовать больше <code>add</code>, <code>incr</code> и подобных
операций записи в Вашем приложении без беспокойства, что данные могли быть
потеряны. Вы можете остановить и запустить
<span><strong>memcached</strong></span> не теряя обновления, сделанные к
кэшируемым данным. Чтобы принять меры против неожиданных отключений
электричества, Вы можете использовать в своих интересах
восстановление катастрофического отказа, репликацию и резервирование.</li>

<li>Прямой низкоуровневый путь доступа к базе данных, используемый
<span><strong>memcached</strong></span> намного более эффективен для поисков
значения ключа, чем эквивалентные запросы SQL.</li>

<li>Особенности преобразования в последовательную форму
<span><strong>memcached</strong></span>,
который может повернуть сложные структуры данных, двоичные файлы или даже
кодировать блоки в строки, предложить простой способ получить такие
объекты в базу данных.</li>

<li>Поскольку Вы можете получить доступ к основным данным через SQL, Вы
можете представить доклады, поиск или обновление через многократные ключи и
вызвать такие функции, как <code>AVG()</code> и <code>MAX()</code> на данных
<span><strong>memcached</strong></span>.
Все эти операции дороги или сложны при использовании
<span><strong>memcached</strong></span> отдельно.</li>

<li>Вы не должны вручную загрузить данные в
<span><strong>memcached</strong></span>.
Поскольку особые ключи требует приложение, значения получены от базы данных
автоматически, и кэшируются в памяти, используя
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>.</li>

<li>Поскольку <span><strong>memcached</strong></span> потребляет
относительно немного ресурсов центрального процессора и его памятью легко
управлять, это может работать удобно рядом с сервером MySQL на той
же самой системе.</li>

<li>Поскольку последовательность данных проведена в жизнь механизмами,
используемыми для таблиц <code>InnoDB</code>,
Вы не должны волноваться о несвежих данных
<span><strong>memcached</strong></span> или логике отступления, чтобы
запросить базу данных в случае недостающего ключа.</p></li></ul>

<h3><a name="innodb-memcached-intro"></a>16.19.2.
Архитектура InnoDB memcached</h3>
<p>Плагин <code>InnoDB</code> <span><strong>memcached</strong></span>
осуществляет <span><strong>memcached</strong></span> как плагин MySQL, к
которому получает доступ механизм хранения <code>InnoDB</code>, обходя
MySQL-уровень SQL.</p>

<p>Следующая диаграмма иллюстрирует данные о доступе приложения через
плагин <code>daemon_memcached</code> по сравнению с SQL.</p>
<img src="innodb.jpg" width="554" height="414"
alt="Architecture Diagram for MySQL Server with Integrated memcached Server">

<p>Особенности плагина <code>daemon_memcached</code>:</p>
<ul><li><p><span><strong>memcached</strong></span> как плагин
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a> и
<span><strong>memcached</strong></span> выполнены в том же самом пространстве
процесса с очень низким временем ожидания доступа к данным.</li>

<li>Прямой доступ к <code>InnoDB</code>, обходя анализатор SQL,
оптимизатор и даже уровень API.</li>
<li>Стандартные протоколы <span><strong>memcached</strong></span>,
включая основанный на тексте протокол и протокол двоичной синхронной передачи
данных. Плагин <code>daemon_memcached</code> проходит все 55
тестов совместимости <span><strong>memcapable</strong></span>.</li>

<li>Многоколонная поддержка. Вы можете отобразить много столбцов в
<span><span>значении</span></span> хранилища ключа/значения, со значениями
столбцов, разграниченными определенным пользователем символом разделителя.
</li>

<li>По умолчанию используется протокол
<span><strong>memcached</strong></span>, чтобы считать и записать данные
непосредственно в <code>InnoDB</code>, разрешая MySQL управлять кэшированием
в памяти, используя <a href="glossary.htm#glos_buffer_pool">буферный пул
</a>. Настройки по умолчанию представляют комбинацию высокой надежности и
наименьшего количества неожиданностей для приложений базы данных. Например,
настройки по умолчанию избегают нейтральных данных на стороне базы данных или
возврата устаревших данных
для <span><strong>memcached</strong></span> <code>get</code>.</li>

<li>Пользователи могут сконфигурировать систему как традиционный сервер
<span><strong>memcached</strong></span>, со всеми данными, кэшируемыми только
в памяти <span><strong>memcached</strong></span>, или использовать комбинацию
<span><span><span><strong>memcached</strong></span></span></span> и
<code>InnoDB</code>.</p></li></ul>

<ul><li><p>Управление тем, как часто данные передаются через опции
<a href="#sysvar_innodb_api_bk_commit_interval"><code>
innodb_api_bk_commit_interval</code></a>,
<a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a> и
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a>. Пакетное значение опций размера по
умолчанию 1 для максимальной надежности.</li>

<li>Способность определить опции <span><strong>memcached</strong></span>
через <a href="#sysvar_daemon_memcached_option"><code>
daemon_memcached_option</code></a>. Например, Вы можете изменить порт, на
котором слушает <span><strong>memcached</strong></span>,
уменьшить максимальное количество одновременных соединений, изменить
максимальный размер памяти для пары ключа/значения или позволить отладочные
сообщения для журнала ошибок.</li>

<li><a href="#sysvar_innodb_api_trx_level"><code>
innodb_api_trx_level</code></a> управляет операционным
<a href="glossary.htm#glos_isolation_level">уровнем изоляции</a>
запросов, обработанных <span><strong>memcached</strong></span>. Хотя у
<span><strong>memcached</strong></span> нет никакого понятия
<a href="glossary.htm#glos_transaction">транзакций</a>,
Вы можете использовать эту опцию, чтобы управлять, как скоро
<span><strong>memcached</strong></span> видит изменения, вызванные запросами
SQL, сделанными на таблице, используемой плагином
<span><strong>daemon_memcached</strong></span>. По умолчанию
<a href="#sysvar_innodb_api_trx_level"><code>innodb_api_trx_level
</code></a> = <a href="#isolevel_read-uncommitted"><code>
READ UNCOMMITTED</code></a>.</li>

<li><a href="#sysvar_innodb_api_enable_mdl"><code>
innodb_api_enable_mdl</code></a> может использоваться, чтобы заблокировать
таблицу на уровне MySQL, чтобы отображенная таблица не могла быть удалена или
изменена <a href="glossary.htm#glos_ddl">DDL</a> через интерфейс SQL. Без
блокировки таблица может быть исключена из уровня MySQL, но удержана
<code>InnoDB</code> до тех пор, пока
<span><strong>memcached</strong></span> или некоторый другой пользователь не
прекратит использовать это.</p></li></ul>

<h4><a name="innodb-memcached-compare-contrast"></a>Разница между InnoDB
memcached и обычным memcached</h4>
<p>Вы можете уже быть знакомы с использованием
<span><strong>memcached</strong></span> с MySQL, см.
<a href="ha.htm#ha-memcached">раздел 18.2</a>.
Этот раздел описывает как особенности интегрированного плагина
<code>InnoDB</code> <span><strong>memcached</strong></span>
отличаются от традиционного <code>memcached</code>.</p>

<ul><li><p>Установка: библиотека идет с сервером MySQL, делая
установку относительно легкой. Установка вовлекает выполнение скрипта
<code>innodb_memcached_config.sql</code>, чтобы создать таблицу
<code>demo_test</code>, чтобы использовать запрос
<a href="sql.htm#install-plugin"><code>INSTALL PLUGIN</code></a>, чтобы
включить плагин <code>daemon_memcached</code> и добавить опции
<span><strong>memcached</strong></span> к конфигурационному файлу MySQL.
Вы могли бы все еще установить традиционный
<span><strong>memcached</strong></span> для дополнительных утилит, таких как
<span><strong>memcp</strong></span>, <span><strong>memcat</strong></span> и
<span><strong>memcapable</strong></span>.</p>

<p>Для сравнения с традиционным <span><strong>memcached</strong></span> см.
<a href="ha.htm#ha-memcached-install">раздел 18.2.1</a>.</li>
<li>Развертывание: С традиционным <span><strong>memcached</strong></span>
типично выполнить большие количества серверов. Типичное развертывание
<code>daemon_memcached</code>, однако, вовлекает меньшее число умеренных или
мощных серверов, которые уже выполняют MySQL. Выгода этой конфигурации
в улучшении эффективности отдельных серверов базы данных вместо того, чтобы
эксплуатировать неиспользованную память или распределить поиски через большие
количества серверов. В конфигурации по умолчанию очень небольшая память
используется для <span><strong>memcached</strong></span>, поиски в памяти
поданы от <a href="glossary.htm#glos_buffer_pool">буферного пула</a>,
который автоматически кэширует последние и часто используемые данные. Как
с традиционным случаем сервера MySQL, сохраните значение опции
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> столь высоким, как можно (не вызывая
оповещение на уровне OS), чтобы такая большая работа насколько возможно
была выполнена в памяти.</p></li>

<li>По умолчанию (то есть, используя кэширование
<code>innodb_only</code>), последние данные от таблицы <code>InnoDB</code>
всегда возвращаются, таким образом, опции истечения не имеют никакого
практического эффекта. Если Вы изменяете политику кэширования на
<code>caching</code> или <code>cache-only</code>,
работа опций истечения идет как обычно, но запрошенные данные могут быть
несвежими, если обновлены в основной таблице прежде, чем
выдохнутся в кэш-памяти.</p></li>

<li>Пространства имен: <span><strong>memcached</strong></span>
походит на большой каталог, где Вы даете файлам тщательно продуманные имена
с приставками и суффиксами. <code>daemon_memcached</code> позволяет Вам
использовать подобные соглашения о присвоении имен для ключей, с одним
дополнением. Ключевые имена в формате
<code>@@<em><code>table_id</code></em>.<em><code>key</code></em></code>.
<em><code>table_id</code></em> расшифрованы, чтобы сослаться на определенную
таблица, используя отображающиеся данные от таблицы
<code>innodb_memcache.containers</code>. <em><code>key</code></em>
ищется в указанной таблице.</p>

<p>Нотация <code>@@</code> работает на отдельных вызовах
<code>get</code>, <code>add</code> и <code>set</code>,
но не других функций, например, <code>incr</code> или <code>delete</code>.
Чтобы определять таблицу значения по умолчанию для последующих действий
<span><strong>memcached</strong></span> в пределах сеанса, выполните
<code>get</code>, используя нотацию <code>@@</code> с
<code><em><code>table_id</code></em></code>, но без ключевой части. Например:
<pre>
get @@<em><code>table_id</code>
</em></pre>

<p>Последующие <code>get</code>, <code>set</code>,
<code>incr</code>, <code>delete</code> и другие операции используют таблицу,
определяемую <code><em><code>table_id</code></em></code> в столбце
<code>innodb_memcache.containers.name</code>.</p></li>

<li>Хеширование и распределение: конфигурация по умолчанию, которая
использует логику <code>innodb_only</code>, является подходящей для
традиционной конфигурации развертывания, где все данные доступны на всех
серверах, таких как ряд ведомых серверов репликации.</p>

<p>Если Вы физически делите данные, как в конфигурации sharded, Вы можете
разделить данные на несколько машин, работающих с плагином
<code>daemon_memcached</code>, и использовать традиционный хеширующий
механизм <span><strong>memcached</strong></span>, чтобы направить запросы к
особой машине. На стороне MySQL Вы, как правило, позволяли бы всем данным
быть вставленными запросом <code>add</code> в
<span><strong>memcached</strong></span>, чтобы соответствующие значения были
сохранены в базе данных по соответствующему серверу.</p></li>

<li>Использование памяти: По умолчанию (с логикой
<code>innodb_only</code>) <span><strong>memcached</strong></span>
передает информацию таблицам <code>InnoDB</code> и буферный пул обрабатывает
поиски дескрипторов в памяти вместо роста и сокращения использования памяти
<span><strong>memcached</strong></span>. Относительно маленькая память
используется на стороне <span><strong>memcached</strong></span>.</p>

<p>Если ереключить логику на <code>caching</code> или
<code>cache-only</code>, нормальные правила использования памяти
<span><strong>memcached</strong></span> применяются. Память для
значений данных <span><strong>memcached</strong></span> выделена с точки
зрения <span><span>плит</span></span>. Вы можете управлять размером плиты и
максимальной памятью, используемой для <span><strong>memcached</strong>
</span>.</p>

<p>Так или иначе, Вы можете контролировать и исследовать плагин
<code>daemon_memcached</code>, используя знакомую систему
<a href="ha.htm#ha-memcached-stats">статистики</a>,
к которой получают доступ через стандартный протокол, по сеансу
<span><strong>telnet</strong></span>.
Дополнительные утилиты не включены в плагин
<code>daemon_memcached</code>. Вы можете использовать скрипт
<a href="ha.htm#ha-memcached-stats-memcached-tool"><code>memcached-tool
</code></a>, чтобы установить полную версию <span><strong>memcached</strong>
</span>.</p></li>

<li>Использование потока: потоки MySQL и потоки
<span><strong>memcached</strong></span> сосуществуют на том же самом сервере.
Пределы, наложенные на потоки операционной системой, относятся к
общему количеству потоков.</p></li>

<li>Использование журнала: Поскольку
<span><strong>memcached</strong></span> выполнен рядом с сервером MySQL и
пишет в <code>stderr</code>, опции <code>-v</code>, <code>-vv</code> и
<code>-vvv</code> используются для того, чтобы зарегистрировать вывод
в <a href="glossary.htm#glos_error_log">журнал ошибок</a> MySQL.</p></li>

<li>Действия <span><strong>memcached</strong></span>: Знакомые операции
<span><strong>memcached</strong></span> такие, как
<code>get</code>, <code>set</code>, <code>add</code> и <code>delete</code>,
доступны. Преобразование в последовательную форму (то есть, точный строковый
формат, представляющий сложные структуры данных), зависит
от языкового интерфейса.</p></li>

<li>Используя <span><strong>memcached</strong></span>
как фронтэнд MySQL: Это основная цель плагина <code>InnoDB</code>
<span><strong>memcached</strong></span>. Интегрированный демон
<span><strong>memcached</strong></span>
улучшает потребительские свойства, и наличие передачи дескриптора данных
между памятью и диском упрощают логику приложения.</p></li>

<li>Утилиты: сервер MySQL включает библиотеку <code>libmemcached</code>,
но не дополнительные утилиты командной строки. Чтобы использовать такие
команды, как <span><strong>memcp</strong></span>,
<span><strong>memcat</strong></span> и
<span><strong>memcapable</strong></span>, устанавливают полную версию
<span><strong>memcached</strong></span>. Когда
<span><strong>memrm</strong></span> и <span><strong>memflush</strong></span>
удаляют элементы из кэша, элементы также удалены из основной таблицы.</p>
</li>

<li>Программирование интерфейсов: Вы можете получить доступ к серверу MySQL
через плагин <code>daemon_memcached</code>, используя все поддержанные языки:
<a href="ha.htm#ha-memcached-interfaces-libmemcached">C и C++</a>,
<a href="ha.htm#ha-memcached-interfaces-java">Java</a>,
<a href="ha.htm#ha-memcached-interfaces-perl">Perl</a>,
<a href="ha.htm#ha-memcached-interfaces-python">Python</a>,
<a href="ha.htm#ha-memcached-interfaces-php">PHP</a> и
<a href="ha.htm#ha-memcached-interfaces-ruby">Ruby</a>.
Определите имя узла сервера и порт как с традиционным
<span><strong>memcached</strong></span>. По умолчанию
<code>daemon_memcached</code> слушает на порту <code>11211</code>.
Вы можете использовать <a href="ha.htm#ha-memcached-interfaces-protocol">
текст и протоколы двоичной синхронной передачи данных</a>.
Вы можете настроить
<a href="ha.htm#ha-memcached-interfaces-libmemcached-behaviors">логику</a>
of <span><strong>memcached</strong></span> во время выполнения.
Преобразование в последовательную форму (то есть, точный строковый формат,
представляющий сложные структуры данных) зависит от языкового интерфейса.</p>
</li>

<li>У MySQL есть обширные часто задаваемые вопросы для традиционного
<span><strong>memcached</strong></span>. Часто задаваемые вопросы главным
образом применимы, за исключением того, что использование таблиц
как носителя данных для <span><strong>memcached</strong></span>
означает, что Вы можете использовать <span><strong>memcached</strong></span>
для приложений с интенсивной записью, а не как кэш только для чтения.</p>
<p>См. <a href="ha.htm#ha-memcached-faq">раздел 18.2.5</a>.</p></li></ul>

<h3><a name="innodb-memcached-setup"></a>16.19.3.
Установка плагина InnoDB memcached</h3>
<p>Этот раздел описывает, как настроить <code>daemon_memcached</code>
на сервере MySQL. Поскольку <span><strong>memcached</strong></span>
плотно объединен с сервером MySQL, чтобы избежать сетевого трафика и
минимизировать время ожидания, Вы выполняете этот процесс на каждом сервере
MySQL, который использует эту функцию.</p>

<p>Перед установкой плагина, изучите
<a href="#innodb-memcached-security">раздел 16.19.5</a>, чтобы
понять меры безопасности и предотвратить несанкционированный доступ.</p>

<h4><a name="innodb-memcached-prereqs"></a>Предпосылки</h4>
<ul><li><p>Плагин <code>daemon_memcached</code> поддержан только на
Linux, Solaris и OS X. Другие операционные системы не поддержаны.</li>

<li>Создавая MySQL из исходных текстов, Вы должны собрать с
<a href="install.htm#option_cmake_with_innodb_memcached"><code>
-DWITH_INNODB_MEMCACHED=ON</code></a>. Это производит две совместно
используемых библиотеки в каталоге плагина MySQL
(<a href="server.htm#sysvar_plugin_dir"><code>plugin_dir</code></a>),
которые нужны для плагина <code>daemon_memcached</code>:</p>

<ul><li><p><code>libmemcached.so</code>: плагин
<span><strong>memcached</strong></span> для MySQL.</li>
<li><code>innodb_engine.so</code>: плагин <code>InnoDB</code>
API для <span><strong>memcached</strong></span>.</p></li></ul></li>
<li><p><code>libevent</code> должна быть.</p>

<ul><li><p>Если Вы не создавали MySQL из исходных текстов, библиотека
<code>libevent</code> не включена в Вашу установку. Используйте метод
установки для своей операционной системы, чтобы установить
<code>libevent</code> 1.4.12 или выше. Например, в зависимости от
операционной системы, Вы могли бы использовать <code>apt-get</code>,
<code>yum</code> или <code>port install</code>. В Ubuntu Linux:
<pre>
sudo apt-get install libevent-dev
</pre></li>

<li>Если Вы устанавливали MySQL от выпуска исходного кода,
<code>libevent</code> 1.4.12 связана с пакетом и расположена на верхнем
уровне каталога исходного кода MySQL. Если Вы используете связанную версию
<code>libevent</code>, этого достаточно. Если Вы хотите использовать местную
системную версию <code>libevent</code>, Вы должны собрать MySQL с
опцией <a href="install.htm#option_cmake_with_libevent"><code>-DWITH_LIBEVENT
</code></a>, установленной в значение
<code>system</code> или <code>yes</code>.</p></li></ul></li></ul>

<h4><a name="innodb-memcached-installing"></a>
Установка и настройка плагина InnoDB memcached</h4>
<ol type="1"><li><p>Сконфигурируйте плагин <code>daemon_memcached</code>
таким образом, что это может взаимодействовать с таблицами
<code>InnoDB</code>. Запустите скрипт
<code>innodb_memcached_config.sql</code> в
<code><em><code>MYSQL_HOME</code></em>/share</code>. Скрипт установит
базу жанных <code>innodb_memcache</code> с тремя необходимыми таблицами
(<code>cache_policies</code>, <code>config_options</code> и
<code>containers</code>). Это также устанавливает типовую таблицу
<code>demo_test</code> в базу данных <code>test</code>.
<pre>
mysql&gt; source <em><code>MYSQL_HOME</code></em>/share/innodb_memcached_config.sql
</pre>

<p>Запуск скрипта <code>innodb_memcached_config.sql</code> это
одноразовая работа. Таблицы остаются в указанном месте, если Вы позже
удаляете и повторно устанавливаете плагин <code>daemon_memcached</code>.
<pre>
mysql&gt; USE innodb_memcache;
mysql&gt; SHOW TABLES;
+---------------------------+
| Tables_in_innodb_memcache |
+---------------------------+
| cache_policies            |
| config_options            |
| containers                |
+---------------------------+
mysql&gt; USE test;
mysql&gt; SHOW TABLES;
+----------------+
| Tables_in_test |
+----------------+
| demo_test      |
+----------------+
</pre>

<p>Из этих таблиц <code>innodb_memcache.containers</code>
является самой важной. Записи в <code>containers</code>
обеспечивают отображение на столбцы таблицы <code>InnoDB</code>. Каждая
таблица <code>InnoDB</code>, используемая с <code>daemon_memcached</code>,
требует записи в <code>containers</code>.</p>

<p>Скрипт <code>innodb_memcached_config.sql</code> вставляет единственную
запись в <code>containers</code>, которая обеспечивает отображение для
таблицы <code>demo_test</code>. Это также вставляет единственную строку
данных в <code>demo_test</code>. Эти данные позволяют Вам немедленно
проверить установку после того, как она завершена.
<pre>
mysql&gt; SELECT * FROM innodb_memcache.containers\G
*************************** 1. row ***************************
name: aaa
   db_schema: test
db_table: demo_test
 key_columns: c1
 value_columns: c2
   flags: c3
  cas_column: c4
expire_time_column: c5
unique_idx_name_on_key: PRIMARY

mysql&gt; SELECT * FROM test.demo_test;
+----+------------------+------+------+------+
| c1 | c2               | c3   | c4   | c5   |
+----+------------------+------+------+------+
| AA | HELLO, HELLO     |   8  |  0   | 0    |
+----+------------------+------+------+------+
</pre>

<p>Подробнее про таблицы <code>innodb_memcache</code> и
<code>demo_test</code> см. <a href="#innodb-memcached-internals">
раздел 16.19.8</a>.</li>

<li>Активируйте плагин <code>daemon_memcached</code> командой
<a href="sql.htm#install-plugin"><code>INSTALL PLUGIN</code></a>:
<pre>
mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";
</pre>
<p>Как только плагин установлен, он автоматически активирован каждый раз,
когда сервер MySQL перезапущен.</p></li></ol>

<h4><a name="innodb-memcached-snifftest"></a>Проверка InnoDB и memcached</h4>
<p>Чтобы проверить плагин <code>daemon_memcached</code>,
используйте сеанс <span><strong>telnet</strong></span>, чтобы выпустить
команды <span><strong>memcached</strong></span>. По умолчанию
<span><strong>memcached</strong></span> слушает порт 11211.</p>

<ol type="1"><li><p>Получите данные от таблицы <code>test.demo_test</code>.
Единственная строка данных в <code>demo_test</code> имеет ключ
<code>AA</code>.
<pre>
telnet localhost 11211
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
get AA
VALUE AA 8 12
HELLO, HELLO
END
</pre></li>

<li>Вставьте данные, используя команду <code>set</code>.
<pre>
set BB 10 0 16
GOODBYE, GOODBYE
STORED
</pre>

<p>здесь:</p>
<ul><li><p><code>set</code> команда, чтобы сохранить значение.</li>
<li><code>BB</code> ключ.</li>
<li><code>10</code> флаг для работы, проигнорирован
<span><strong>memcached</strong></span>, но может использоваться клиентом,
чтобы указать на любой тип информации, определите <code>0</code>,
если не использован.</li>

<li><code>0</code> время истечения срока (TTL), определите <code>0</code>,
если не использован.</li>
<li><code>16</code> длина поставляемого блока значения в байтах.</li>
<li><code>GOODBYE, GOODBYE</code> значение, которое сохранено.
</p></li></ul></li>

<li><p>Проверьте, что вставленные данные хранятся в MySQL, соединяясь с
сервером MySQL и запрашивая таблицу <code>test.demo_test</code>.
<pre>
mysql&gt; SELECT * FROM test.demo_test;
+----+------------------+----+----+----+
| c1 | c2               | c3 | c4 | c5 |
+----+------------------+----+----+----+
| AA | HELLO, HELLO     | 8  | 0  | 0  |
| BB | GOODBYE, GOODBYE | 10 | 1  | 0  |
+----+------------------+----+----+----+
</pre></li>

<li>Возвратитесь к сеансу telnet и получите данные, которые Вы вставили
раньше с ключом <code>BB</code>.
<pre>
get BB
VALUE BB 10 16
GOODBYE, GOODBYE
END
quit
</pre></li></ol>

<p>Если Вы закроете сервер MySQL, который также отключает интегрированный
сервер <span><strong>memcached</strong></span>, то дальнейшие попытки
получить доступ к <span><strong>memcached</strong></span>
потерпят неудачу с ошибкой соединения. Обычно данные
<span><strong>memcached</strong></span> также исчезают,
и Вы потребовали бы, чтобы логика приложения загрузила данные назад в
память, когда <span><strong>memcached</strong></span> перезапущен. Однако,
плагин <span><strong>memcached</strong></span> автоматизирует этот
процесс для Вас.</p>

<p>Когда Вы перезапускаете MySQL, операции <code>get</code>
возвращают пары ключа/значения, которые Вы сохранили ранее в сессии
<span><strong>memcached</strong></span>. Когда ключ требуют, и связанное
значение уже не находится в кэш-памяти, значение автоматически запрошено от
MySQL-таблицы <code>test.demo_test</code>.</p>

<h4><a name="innodb-memcached-new-table-setup"></a>
Составление нового таблицы и отображение столбца</h4>
<p>Этот пример показывает как установить таблицу с
плагином <code>daemon_memcached</code>.</p>

<ol type="1"><li><p>Создайте таблицу <code>InnoDB</code>.
У таблицы должен быть ключевой столбец с уникальным индексом. Ключевой
столбец таблицы <code>city_id</code> определен как первичный ключ. Таблица
должна также включать столбцы для значений <code>flags</code>,
<code>cas</code> и <code>expiry</code>. Могут быть один или более столбцов
значений. Таблица <code>city</code> имеет три столбца значений
(<code>name</code>, <code>state</code>, <code>country</code>).</p>

<p>Нет никакого особого требования относительно имен столбцов, поскольку
допустимое отображение добавлено к таблице
<code>innodb_memcache.containers</code>.</p>
<pre>
mysql&gt; CREATE TABLE city (city_id VARCHAR(32), name VARCHAR(1024),
    -&gt;        state VARCHAR(1024), country VARCHAR(1024),
    -&gt;        flags INT, cas BIGINT UNSIGNED, expiry INT,
    -&gt;        primary key(city_id)) ENGINE=InnoDB;
</pre></li>

<li>Добавьте запись в <code>innodb_memcache.containers</code>, чтобы
плагин <code>daemon_memcached</code> знал, как получить доступ
к таблице <code>InnoDB</code>. Запись должна удовлетворить
определению <code>innodb_memcache.containers</code>. Для описания каждого
поля см. <a href="#innodb-memcached-internals">раздел 16.19.8</a>.
<pre>
mysql&gt; DESCRIBE innodb_memcache.containers;
+------------------------+--------------+------+-----+---------+-------+
| Field                  | Type         | Null | Key | Default | Extra |
+------------------------+--------------+------+-----+---------+-------+
| name                   | varchar(50)  | NO   | PRI | NULL    |       |
| db_schema              | varchar(250) | NO   |     | NULL    |       |
| db_table               | varchar(250) | NO   |     | NULL    |       |
| key_columns            | varchar(250) | NO   |     | NULL    |       |
| value_columns          | varchar(250) | YES  |     | NULL    |       |
| flags                  | varchar(250) | NO   |     | 0       |       |
| cas_column             | varchar(250) | YES  |     | NULL    |       |
| expire_time_column     | varchar(250) | YES  |     | NULL    |       |
| unique_idx_name_on_key | varchar(250) | NO   |     | NULL    |       |
+------------------------+--------------+------+-----+---------+-------+
</pre>

<p>Запись в таблице <code>innodb_memcache.containers</code>
для таблицы определена как:
<pre>
mysql&gt; INSERT INTO `innodb_memcache`.`containers` (
    -&gt;    `name`, `db_schema`, `db_table`, `key_columns`, `value_columns`,
    -&gt;    `flags`, `cas_column`, `expire_time_column`, `unique_idx_name_on_key`)
    -&gt; VALUES ('default', 'test', 'city', 'city_id', 'name|state|country',
    -&gt;    'flags','cas','expiry','PRIMARY');
</pre>

<ul><li><p><code>default</code> определен для столбца
<code>containers.name</code>, чтобы сконфигурировать таблицу
<code>city</code> как таблицу <code>InnoDB</code> по умолчанию,
которая будет использоваться с <code>daemon_memcached</code>.</li>

<li>Несколько столбцов таблицы <code>InnoDB</code>
(<code>name</code>, <code>state</code>, <code>country</code>)
отображены на <code>containers.value_columns</code> с помощью разделителя
<span><span>|</span></span>.</li>

<li>Поля <code>flags</code>, <code>cas_column</code> и
<code>expire_time_column</code> таблицы
<code>innodb_memcache.containers</code> являются, как правило, не
существенными в приложениях, используя <code>daemon_memcached</code>.
Однако, определяемый столбец таблицы <code>InnoDB</code>
требуется для каждого. Вставляя данные, определите <code>0</code>
для этих столбцов, если они не использованы.</p></li></ul></li>

<li><p>После обновления <code>innodb_memcache.containers</code>
перезапустите <code>daemon_memcache</code>, чтобы применить изменения.
<pre>
mysql&gt; UNINSTALL PLUGIN daemon_memcached;
mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";
</pre></li>

<li>Используя telnet, вставьте данные в таблицу <code>city</code>,
используя команду <code>set</code>.
<pre>
telnet localhost 11211
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
set B 0 0 22
BANGALORE|BANGALORE|IN
STORED
</pre></li>

<li>Используя MySQL, запросите <code>test.city</code>, чтобы проверить, что
данные, которые Вы вставили, были сохранены.
<pre>
mysql&gt; SELECT * FROM test.city;
+---------+-----------+-----------+---------+-------+-----+--------+
| city_id | name      | state     | country | flags | cas | expiry |
+---------+-----------+-----------+---------+-------+-----+--------+
| B       | BANGALORE | BANGALORE | IN      | 0     | 3   |  0     |
+---------+-----------+-----------+---------+-------+-----+--------+
</pre></li>

<li>Используя MySQL, вставьте дополнительные данные в <code>test.city</code>.
<pre>
mysql&gt; INSERT INTO city VALUES ('C','CHENNAI','TAMIL NADU','IN', 0, 0 ,0);
mysql&gt; INSERT INTO city VALUES ('D','DELHI','DELHI','IN', 0, 0, 0);
mysql&gt; INSERT INTO city VALUES ('H','HYDERABAD','TELANGANA','IN', 0, 0, 0);
mysql&gt; INSERT INTO city VALUES ('M','MUMBAI','MAHARASHTRA','IN', 0, 0, 0);
</pre>

<p>Рекомендуется, чтобы Вы определили значение
<code>0</code> для полей <code>flags</code>, <code>cas_column</code> и
<code>expire_time_column</code>, если они не использованы.</p>

</li><li><p>Используя telnet, выполните команду
<span><strong>memcached</strong></span> <code>get</code>,
чтобы получить данные, которые Вы вставили с использованием MySQL.
<pre>
get H
VALUE H 0 22
HYDERABAD|TELANGANA|IN
END
</pre></li></ol>

<h4><a name="innodb-memcached-configuration"></a>
Настройка плагина InnoDB memcached</h4>
<p>Традиционные параметры конфигурации <code>memcached</code>
могут быть определены в конфигурационном файле MySQL или стартовой строке
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>,
закодированной в параметре <a href="#sysvar_daemon_memcached_option">
<code>daemon_memcached_option</code></a>. Параметры конфигурации
<code>memcached</code> вступают в силу, когда плагин загружен, что происходит
каждый раз, когда сервер MySQL запущен.</p>

<p>Например, чтобы заставить <span><strong>memcached</strong></span>
слушать на порту 11222 вместо порта значения по умолчанию 11211, определите
<code>-p11222</code> как параметр
<a href="#sysvar_daemon_memcached_option"><code>
daemon_memcached_option</code></a>:
<pre>
mysqld .... --daemon_memcached_option="-p11222"
</pre>

<p>Другие опции <span><strong>memcached</strong></span> могут быть
закодированы в <a href="#sysvar_daemon_memcached_option"><code>
daemon_memcached_option</code></a>. Например, Вы можете определить опции,
чтобы уменьшить максимальное количество одновременных соединений, изменить
максимальный размер памяти для пары ключа/значения или включить отладочные
сообщения для журнала ошибок.</p>

<p>Есть также параметры конфигурации, определенные для
плагина <code>daemon_memcached</code>:</p>
<ul><li><p><a href="#sysvar_daemon_memcached_engine_lib_name">
<code>daemon_memcached_engine_lib_name</code></a>:
Определяет совместно используемую библиотеку, которая осуществляет плагин
<span><strong>memcached</strong></span>. Настройка по умолчанию
<code>innodb_engine.so</code>.</li>

<li><a href="#sysvar_daemon_memcached_engine_lib_path"><code>
daemon_memcached_engine_lib_path</code></a>:
Путь каталога, содержащего совместно используемую библиотеку, которая
осуществляет плагин <span><strong>memcached</strong></span>. Настройка по
умолчанию NULL, представляя каталог плагинов.</li>

<li><a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a>: Определяет размер пакета передачи
для операций чтения (<code>get</code>). Это определяет число операций чтения
<span><strong>memcached</strong></span> после которых происходит
<a href="glossary.htm#glos_commit">commit</a>.
<a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a> установлен в 1 по умолчанию так,
чтобы каждый <code>get</code> запрашивал доступ к последним переданным данным
в таблице <code>InnoDB</code>, были ли данные обновлены через
<span><strong>memcached</strong></span> или SQL. Когда значение больше 1,
счетчик для операций чтения постепенно увеличен с каждым вызовом
<code>get</code>. Вызов <code>flush_all</code> сбросит
счетчики чтения и записи.</li>

<li><a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a>: Определяет размер пакета передачи
для операций записи (<code>set</code>, <code>replace</code>,
<code>append</code>, <code>prepend</code>,
<code>incr</code>, <code>decr</code> и т.п.).
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a> установлен в 1 по умолчанию, чтобы
никакие нейтральные данные не были потеряны в случае отключения
электричества, а запросы SQL на основной таблице получили доступ к новым
данным. Когда значение больше 1, счетчик постепенно увеличен для каждой
операции. Вызов <code>flush_all</code> сбросит счетчики чтения и записи.
</p></li></ul>

<p>По умолчанию, Вы не должны изменить
<a href="#sysvar_daemon_memcached_engine_lib_name"><code>
daemon_memcached_engine_lib_name</code></a> или
<a href="#sysvar_daemon_memcached_engine_lib_path"><code>
daemon_memcached_engine_lib_path</code></a>. Вы могли бы сконфигурировать эти
опции, если, например, Вы хотите использовать иной механизм хранения для
<span><strong>memcached</strong></span> (например, NDB
<span><strong>memcached</strong></span>).</p>

<p>Параметры плагина <code>daemon_memcached</code>
могут быть определены в конфигурационном файле MySQL или в строке запуска
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.
Они вступают в силу, когда Вы загружаете <code>daemon_memcached</code>.</p>

<p>Производя изменения в настройке <code>daemon_memcached</code>,
перезагрузите плагин, чтобы применить изменения. Чтобы сделать так,
сделайте следующие запросы:
<pre>
mysql&gt; UNINSTALL PLUGIN daemon_memcached;
mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";
</pre>

<p>Настройки конфигурации, требуемые таблицы и данные сохранены,
когда плагин перезапущен.</p>
<p>Подробности о плагинах см. в
<a href="server.htm#server-plugin-loading">разделе 6.6.2</a>.</p>

<h3><a name="innodb-memcached-multiple-get-range-query"></a>16.19.4.
Поддержка запроса диапазона и множественные memcached get</h3>
<p>С MySQL 8.0.0 плагин <code>daemon_memcached</code> поддерживает
множественные операции get (забирающие многократные пары
ключа/значения в единственном запросе <span><strong>memcached</strong>
</span>) и запросах диапазона.</p>

<h4><a name="idm139965315252688"></a>Множественные memcached get</h4>
<p>Способность забрать многократные пары ключа/значения в единственном
запросе <span><strong>memcached</strong></span>
улучшает работу чтения, уменьшая коммуникационный трафик между клиентом и
сервером. Для <code>InnoDB</code> это означает меньше транзакций и
операций открытия таблицы.</p>

<p>Следующий пример демонстрирует это. Пример использует таблицу
<code>test.city</code>, описанную
<a href="#innodb-memcached-new-table-setup">выше</a>.
<pre>
mysql&gt; USE test;
mysql&gt; SELECT * FROM test.city;
+---------+-----------+-------------+---------+-------+-----+--------+
| city_id | name      | state       | country | flags | cas | expiry |
+---------+-----------+-------------+---------+-------+-----+--------+
| B       | BANGALORE | BANGALORE   | IN      | 0     | 1   |  0     |
| C       | CHENNAI   | TAMIL NADU  | IN      | 0     | 0   |  0     |
| D       | DELHI     | DELHI       | IN      | 0     | 0   |  0     |
| H       | HYDERABAD | TELANGANA   | IN      | 0     | 0   |  0     |
| M       | MUMBAI    | MAHARASHTRA | IN      | 0     | 0   |  0     |
+---------+-----------+-------------+---------+-------+-----+--------+
</pre>

<p>Выполните команду <code>get</code>, чтобы получить все значения от
таблицы <code>city</code>. Результаты возвращены в последовательности
пар ключа/значения.
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
get B C D H M
VALUE B 0 22
BANGALORE|BANGALORE|IN
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
VALUE M 0 21
MUMBAI|MAHARASHTRA|IN
END
</pre>

<p>Получая многократные значения в одной команде <code>get</code>,
Вы можете переключить таблицы (с использованием формата
<code>@@<em><code>containers.name</code></em></code>),
чтобы получить значение для первого ключа, но Вы не можете переключить
таблицы для последующих ключей. Например, табличный переключатель в
этом примере допустим:
<pre>
get @@aaa.AA BB
VALUE @@aaa.AA 8 12
HELLO, HELLO
VALUE BB 10 16
GOODBYE, GOODBYE
END
</pre>
<p>Попытка переключить таблицы снова в том же самом запросе <code>get</code>,
чтобы получить значение ключа от другой таблицы не поддержана.</p>

<h4><a name="idm139965315235936"></a>Запросы диапазона</h4>
<p>Для запросов диапазона плагин  <code>daemon_memcached</code>
поддерживает следующие операторы сравнения:
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.
Оператор должен предваряться символом <code>@</code>.
Когда запрос диапазона находит многократные соответствия пар ключа/значения,
результаты возвращены в последовательности пар ключа/значения.</p>

<p>Следующие примеры демонстрируют поддержку запроса диапазона. Примеры
используют описанную ранее таблицу <code>test.city</code>.
<pre>
mysql&gt; SELECT * FROM test.city;
+---------+-----------+-------------+---------+-------+-----+--------+
| city_id | name      | state       | country | flags | cas | expiry |
+---------+-----------+-------------+---------+-------+-----+--------+
| B       | BANGALORE | BANGALORE   | IN      | 0     | 1   |  0     |
| C       | CHENNAI   | TAMIL NADU  | IN      | 0     | 0   |  0     |
| D       | DELHI     | DELHI       | IN      | 0     | 0   |  0     |
| H       | HYDERABAD | TELANGANA   | IN      | 0     | 0   |  0     |
| M       | MUMBAI    | MAHARASHTRA | IN      | 0     | 0   |  0     |
+---------+-----------+-------------+---------+-------+-----+--------+
</pre>

<p>Откройте сессию telnet:
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
</pre>

<p>Получить все значения, больше <code>B</code>:
<pre>
get @&gt;B
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
VALUE M 0 21
MUMBAI|MAHARASHTRA|IN
END
</pre>

<p>Получить все значения меньше <code>M</code>:
<pre>
get @&lt;M
VALUE B 0 22
BANGALORE|BANGALORE|IN
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
END
</pre>

<p>Получить все значения меньше чем и включая <code>M</code>:
<pre>
get @&lt;=M
VALUE B 0 22
BANGALORE|BANGALORE|IN
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
VALUE M 0 21
MUMBAI|MAHARASHTRA|IN
</pre>

<p>Получить значения, больше чем <code>B</code> но меньше <code>M</code>:
<pre>
get @&gt;B@&lt;M
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
END
</pre>

<p>Максимум двух операторов сравнения может быть разобран, один являющийся
любым 'меньше чем' (<code>@&lt;</code>) или 'меньше чем или равный'
(<code>@&lt;=</code>), другой являющийся любым 'больше чем'
(<code>@&gt;</code>) или или 'больше чем или равный' (<code>@&gt;=</code>).
Любые дополнительные операторы, как предполагается, являются частью ключа.
Например, если выполняете <code>get</code> с тремя операторами, третий
оператор (<code>@&gt;C</code>) обработан как часть ключа, и <code>get</code>
будет искать значения, меньшие чем <code>M</code>, но больше
<code>B@&gt;C</code>.
<pre>
get @&lt;M@&gt;B@&gt;C
VALUE C 0 21
CHENNAI|TAMIL NADU|IN
VALUE D 0 14
DELHI|DELHI|IN
VALUE H 0 22
HYDERABAD|TELANGANA|IN
</pre>

<h3><a name="innodb-memcached-security"></a>16.19.5.
Соображения безопасности для InnoDB memcached</h3>
<p>Консультируйтесь с этим разделом прежде, чем развернуть
<code>daemon_memcached</code> на производственном сервере или даже на
тестовом сервере, если MySQL содержит уязвимые данные.</p>

<p>Поскольку <span><strong>memcached</strong></span>
не использует механизм аутентификации по умолчанию, и дополнительная
аутентификация SASL не столь же сильна, как традиционная безопасность системы
управления базами данных, сохраните только несекретные данные в случае MySQL,
который использует <code>daemon_memcached</code>, и отгородите любые серверы,
которые используют эту конфигурацию, от потенциальных злоумышленников. Не
позволяйте доступ к этим серверам из Интернета,
позвольте доступ только изнутри интранет-сети, идеально от подсети, членство
в которой Вы можете ограничить.</p>

<h4><a name="innodb-memcached-sasl"></a>Защита паролем memcached с SASL</h4>
<p>Поддержка SASL обеспечивает способность защитить Вашу базу данных MySQL от
незаверенного доступа к <span><strong>memcached</strong></span>.
Этот раздел объясняет, как включить SASL с <code>daemon_memcached</code>.
Шаги почти идентичны включению SASL для традиционного
<span><strong>memcached</strong></span>.</p>

<p>SASL это стандарт для того, чтобы добавить поддержку аутентификации
основанным на соединении протоколам. <span><strong>memcached</strong></span>
добавил поддержку SASL в версии 1.4.3.</p>

<p>Аутентификация SASL поддержана только с протоколом двоичной
синхронной передачи данных.</p>
<p>Клиенты <span><strong>memcached</strong></span> в состоянии только
получить доступ к таблицам, которые зарегистрированы в
<code>innodb_memcache.containers</code>.
Даже при том, что DBA может установить ограничения доступа для таких таблиц,
доступом через <span><strong>memcached</strong></span> нельзя управлять.
Поэтому поддержка SASL оказана, чтобы управлять доступом к
таблицам, связанным с <code>daemon_memcached</code>.</p>
<p>Этот раздел показхывает, как создать, включить и проверить
SASL <code>daemon_memcached</code>.</p>

<h4><a name="innodb-memcached-sasl-enabling"></a>
Создание и включение SASL в InnoDB memcached</h4>
<p>По умолчанию SASL <code>daemon_memcached</code> не включен в пакеты
выпуска MySQL. SASL-<code>daemon_memcached</code> требует
сборки <span><strong>memcached</strong></span> с библиотеками SASL.
Чтобы включить поддержку SASL, загрузите исходный текст MySQL и пересоздайте
плагин <code>daemon_memcached</code> после загрузки библиотек SASL:</p>

<ol type="1"><li><p>Установите SASL и служебные библиотеки. Например, на
Ubuntu используйте <span><strong>apt-get</strong></span>:
<pre>
sudo apt-get -f install libsasl2-2 sasl2-bin libsasl2-2 libsasl2-dev libsasl2-modules
</pre></li>

<li>Соберите совместно используемые библиотеки с SASL, добавляя
<code>ENABLE_MEMCACHED_SASL=1</code> к опциям
<span><strong>cmake</strong></span>. <span><strong>memcached</strong></span>
также оказывает <span><em>simple cleartext password support</em></span>,
которая облегчает тестирование. Чтобы включить простую поддержку пароля
открытого текста, определите <code>ENABLE_MEMCACHED_SASL_PWDB=1</code> в
<span><strong>cmake</strong></span>.</p>

<p>В резюме, добавьте следующие три опции <span><strong>cmake</strong></span>:
<pre>
cmake ... -DWITH_INNODB_MEMCACHED=1 \
          -DENABLE_MEMCACHED_SASL=1 \
          -DENABLE_MEMCACHED_SASL_PWDB=1
</pre></li>

<li>Установите <code>daemon_memcached</code> согласно
<a href="#innodb-memcached-setup">разделу 16.19.3</a>.</li>
<li>Сконфигурируйте файл пароля и имя пользователя. Этот пример использует
поддержку <span><strong>memcached</strong></span> simple cleartext password.
</p>

<ol type="a"><li><p>В файле создайте пользователя <code>testname</code>
и определите пароль как <code>testpasswd</code>:
<pre>
echo "testname:testpasswd:::::::" &gt;/home/jy/memcached-sasl-db
</pre></li>

<li>Сконфигурируйте переменную <code>MEMCACHED_SASL_PWDB</code>, чтобы
сообщить <code>memcached</code> имя файла пользователей и паролей:
<pre>
export MEMCACHED_SASL_PWDB=/home/jy/memcached-sasl-db
</pre></li>

<li>Сообщите <code>memcached</code>, что используется
пароль открытого текста:
<pre>
echo "mech_list: plain" &gt; /home/jy/work2/msasl/clients/memcached.conf
export SASL_CONF_PATH=/home/jy/work2/msasl/clients
</pre></li></ol></li>

<li><p>Включите SASL, перезапуская сервер MySQL с опцией
<span><strong>memcached</strong></span> <code>-S</code>, закодированной в
параметре конфигурации <a href="#sysvar_daemon_memcached_option">
<code>daemon_memcached_option</code></a>:
<pre>
mysqld ... --daemon_memcached_option="-S"
</pre></li>

<li>Чтобы проверить установку, используйте SASL-клиент, например,
<a href="../../../https@code.launchpad.net/~trond-norbye/libmemcached/sasl"
target="_top">SASL-enabled libmemcached</a>.
<pre>
memcp --servers=localhost:11211 --binary  --username=testname
      --password=testpasswd myfile.txt

memcat --servers=localhost:11211 --binary --username=testname
       --password=testpasswd myfile.txt
</pre>

<p>Если Вы определяете неправильное имя пользователя или пароль, работа
отклонена с ошибкой <code>memcache error AUTHENTICATION FAILURE</code>.
В этом случае исследуйте пароль открытого текста в файле
<code>memcached-sasl-db</code>, чтобы проверить, что он правилен.
</p></li></ol>

<p>Есть другие методы, чтобы проверить аутентификацию SASL с
<span><strong>memcached</strong></span>,
но метод, описанный выше, является самым прямым.</p>

<h3><a name="innodb-memcached-developing"></a>16.19.6.
Написание приложений для плагина InnoDB memcached</h3>
<p>Написание приложений для плагина
<code>InnoDB</code> <span><strong>memcached</strong></span>
вовлекает определенную степень приспосабливания существующего кода, который
использует MySQL или <span><strong>memcached</strong></span> API.</p>

<ul><li><p>С плагином <code>daemon_memcached</code> вместо многих
традиционных серверов <span><strong>memcached</strong></span>, работающих на
маломощных машинах, у Вас будет то же самое число серверов
<span><strong>memcached</strong></span>, как серверов MySQL,
работающих на относительно мощных машинах с существенным диском и памятью. Вы
могли бы снова использовать некоторый существующий код, который работает с
<span><strong>memcached</strong></span> API, но адаптация, вероятно,
требуется из-за различной конфигурации сервера.</li>

<li>Данные, поступающие через плагин <code>daemon_memcached</code>,
в столбцы <a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>, должны быть преобразованы,
чтобы сделать числовые операции. Вы можете выполнить преобразование на
стороне приложения или при использовании <code>CAST()</code> в запросах.</li>

<li>Происходя из среды базы данных, Вы могли бы привыкнуть к таблицам SQL
общего назначения со многими столбцами. Таблицы, к которым получает доступ
<span><strong>memcached</strong></span>, вероятно, имеют только некоторые или
даже единственный столбец, содержащий значения данных.</li>

<li>Вы могли бы приспособить части своего приложения, которые выполняют
запросы единственной строки, вставки, обновления или удаления, чтобы улучшить
работу в критических разделах кода.
<a href="glossary.htm#glos_query">Запросы</a> и
<a href="glossary.htm#glos_dml">DML</a>
могут быть существенно быстрее, когда выполнены через
<code>InnoDB</code> <span><strong>memcached</strong></span>.
Исполнительное улучшение для записи, как правило, больше, чем для чтений,
таким образом, Вы могли бы сосредоточиться на том, чтобы приспосабливать код,
который выполняет журналирование или делает запись интерактивного выбора
на веб-сайте.</p></li></ul>
<p>Следующие разделы исследуют эти пункты более подробно.</p>

<h4><a name="innodb-memcached-porting-mysql"></a>16.19.6.1.
Приспосабливание существующей схемы MySQL для InnoDB memcached</h4>
<p>Полагайте, что эти аспекты <span><strong>memcached</strong></span>,
адаптируя существующую схему MySQL или приложение используют
плагин <code>daemon_memcached</code>:</p>

<ul><li><p>Ключи <span><strong>memcached</strong></span>
не могут содержать пробелы или новые строки, потому что эти символы
используются в качестве разделителей в протоколе ASCII. Если Вы используете
значения, которые содержат пробелы, преобразуйте или хешируйте их в значения
без пробелов перед использованием их как ключи в <code>add()</code>,
<code>set()</code>, <code>get()</code> и т.п.
Хотя теоретически эти символы позволены в ключах в программах, которые
используют протокол двоичной синхронной передачи данных, Вы должны ограничить
символы, используемые в ключах, чтобы гарантировать совместимость с
широким диапазоном клиентов.</li>

<li>Если есть короткий числовой столбец
<a href="glossary.htm#glos_primary_key">primary key</a> в таблице
<code>InnoDB</code>, используйте это в качестве уникального ключа поиска для
<span><strong>memcached</strong></span>,
преобразовывая целое число в строковое значение. Если
сервер <span><strong>memcached</strong></span> используется для многих
приложений, или больше, чем с одной таблицей <code>InnoDB</code>,
полагайте, что изменение имени гарантирует, что это уникально. Например,
предварительно ожидайте имя таблицы или имя базы данных и имя таблицы
перед числовым значением.</p>

<p>Плагин <code>daemon_memcached</code>
поддерживает вставляют и чтение на отображенных таблицах
<code>InnoDB</code>, которые имеют <code>INTEGER</code>,
определенный как первичный ключ.</p></li>

<li><p>Вы не можете использовать разделенную
таблицу с использованием <span><strong>memcached</strong></span>.</li>
<li>Протокол <span><strong>memcached</strong></span> раздает числовые
значения как строки. Чтобы сохранить числовые значения в основной таблице
<code>InnoDB</code>, чтобы осуществить счетчики, которые могут использоваться
в функциях SQL, например, <code>SUM()</code> или <code>AVG()</code>, надо:
</p>

<ul><li><p>Используйте столбцы <a href="types.htm#char"><code>VARCHAR</code>
</a> со многими символами, чтобы сохранить все цифры самого большого
ожидаемого числа (и дополнительные символы, если надо для знака минус,
десятичной запятой или обоих).</li>

<li>В любом запросе, который выполняет арифметику, используя значения
столбцов, используйте <code>CAST()</code>, чтобы преобразовать значения от
строки до целого числа, или к некоторому другому числовому типу. Например:
<pre>
-- Alphabetic entries are returned as zero.
select cast(c2 as unsigned integer) from demo_test;
-- Since there could be numeric values of 0, can't disqualify them.
-- Test the string values to find the ones that are integers, and average only those.
select avg(cast(c2 as unsigned integer)) from demo_test
  where c2 between '0' and '9999999999';
-- Views let you hide the complexity of queries. The results are already converted;
-- no need to repeat conversion functions and WHERE clauses each time.
create view numbers as select c1 key, cast(c2 as unsigned integer) val
  from demo_test where c2 between '0' and '9999999999';
select sum(val) from numbers;
</pre>

<p>Любые алфавитные значения в наборе результатов преобразованы в 0
вызовом <code>CAST()</code>. Используя функции вроде <code>AVG()</code>,
которые зависят от числа строк в наборе результатов, включают
<code>WHERE</code>, чтобы отфильтровать нечисловые значения.
</p></li></ul></li>

<li><p>Если столбец, используемый в качестве ключа, может иметь значения
больше 250 байт, надо хешировать значение меньше, чем к 250 байтам.</li>
<li>Чтобы использовать существующую таблицу с
<code>daemon_memcached</code>, определите запись для этого в
<code>innodb_memcache.containers</code>.
Чтобы сделать эту таблицу значением по умолчанию для всех запросов
<span><strong>memcached</strong></span>, определите значение
<code>default</code> в столбце <code>name</code>, затем перезапустите сервер
MySQL, чтобы изменения вступили в силу. Если Вы используете многократные
таблицы для различных классов данных
<span><strong>memcached</strong></span>, настройте много записей в
<code>innodb_memcache.containers</code> с подходящим значением
<code>name</code>, затем выпустите запрос
<span><strong>memcached</strong></span> в форме
<code>get @@<em><code>name</code></em></code> или
<code>set @@<em><code>name</code></em></code> в пределах приложения, чтобы
определить таблицу, которая будет использоваться для
последующих запросов <span><strong>memcached</strong></span>.</p>

<p>Для примера использования таблицы кроме предопределенной
<code>test.demo_test</code> см.
<a href="#innodb-memcached-tutorial-python">пример 16.22</a>.
Для необходимого табличного расположения см.
<a href="#innodb-memcached-internals">раздел 16.19.8</a>.</li>

<li>Чтобы использовать многократные значения столбца таблицы с
парами ключа/значения, определите имена столбцов, отделенные
запятой, точкой с запятой, пробелом или передайте символы по каналу в поле
<code>value_columns</code> записи <code>innodb_memcache.containers</code>
для таблицы <code>InnoDB</code>. Например, определите
<code>col1,col2,col3</code> или <code>col1|col2|col3</code> в
поле <code>value_columns</code>.</p>

<p>Свяжите значения столбцов в единственную строку, используя символ канала в
качестве разделителя прежде, чем передать строку функциям
<span><strong>memcached</strong></span> <code>add</code> или
<code>set</code>. Строка распакована автоматически в правильный столбец.
Каждый вызов <code>get</code> возвращает единственную строку, содержащую
значения столбцов, которые также разграничены символом канала. Вы можете
распаковать значения, используя соответствующий
языковой синтаксис приложения.</p></li></ul>

<a name="innodb-memcached-tutorial-python"></a><p><b>
Пример 16.22. Использование Вашей собственной таблицы с InnoDB memcached
</b></p>
<p>Этот пример показывает, как использовать Вашу собственную таблицу с
типовым приложением на Python, которое использует <code>memcached</code>.</p>

<p>Пример предполагает что плагин <code>daemon_memcached</code> уставновлен в
соответствии с <a href="#innodb-memcached-setup">разделом 16.19.3
</a>. Это также предполагает, что Ваша система сконфигурирована, чтобы
выполнить скрипт модуля <code>python-memcache</code>.</p>

<ol type="1"><li><p>Создайте таблицу <code>multicol</code>, которая хранит
информацию страны включая население, область и данные о водительской стороне
(<code>'R'</code> для правой и <code>'L'</code> для левой).
<pre>
mysql&gt; USE test;
mysql&gt; CREATE TABLE `multicol` (
    -&gt;    `country` varchar(128) NOT NULL DEFAULT '',
    -&gt;    `population` varchar(10) DEFAULT NULL,
    -&gt;    `area_sq_km` varchar(9) DEFAULT NULL,
    -&gt;    `drive_side` varchar(1) DEFAULT NULL,
    -&gt;    `c3` int(11) DEFAULT NULL,
    -&gt;    `c4` bigint(20) unsigned DEFAULT NULL,
    -&gt;    `c5` int(11) DEFAULT NULL,
    -&gt;    PRIMARY KEY (`country`)) ENGINE=InnoDB
    -&gt;    DEFAULT CHARSET=latin1;
</pre></li>

<li>Вставьте запись в <code>innodb_memcache.containers</code> так, чтобы
плагин <code>daemon_memcached</code> мог получить доступ к <code>multicol
</code>.
<pre>
mysql&gt; INSERT INTO innodb_memcache.containers
    -&gt;   (name,db_schema,db_table,key_columns,value_columns,flags,
    -&gt;    cas_column,expire_time_column,unique_idx_name_on_key)
    -&gt; VALUES
    -&gt;   ('bbb','test','multicol','country',
    -&gt;    'population,area_sq_km,drive_side','c3','c4','c5','PRIMARY');
mysql&gt; COMMIT;
</pre>

<ul><li><p>Запись в <code>innodb_memcache.containers</code> для
<code>multicol</code> определяет для <code>name</code> значение
<code>'bbb'</code>, которое является табличным идентификатором.</p>

<p>Если одна таблица <code>InnoDB</code> используется для всех
приложений, <code>name</code> может быть установлено в <code>default</code>,
чтобы избежать использования <code>@@</code>, чтобы переключить таблицы.
</p></li>

<li><p>Столбец <code>db_schema</code> установлен в <code>test</code>,
название базы данных, где находится таблица <code>multicol</code>.</li>
<li>Столбец <code>db_table</code> установлен в <code>multicol</code>,
имя таблицы <code>InnoDB</code>.</li>

<li><code>key_columns</code> установлен в уникальный столбец
<code>country</code>. Столбец <code>country</code> определен как
первичный ключ в <code>multicol</code>.</li>

<li>Вместо одного столбца таблицы <code>InnoDB</code>, чтобы держать сложное
значение, данные разделены среди трех столбцов таблицы
(<code>population</code>, <code>area_sq_km</code> и <code>drive_side</code>).
Чтобы приспособить много столбцов значений, список разделенных запятой
значений столбцов определен в поле <code>value_columns</code>.
Столбцы, определенные в <code>value_columns</code> это столбцы, используемые,
храня или получая значения.</li>

<li>Значения для полей <code>flags</code>, <code>expire_time</code> и
<code>cas_column</code> основаны на значениях, используемых в таблице
<code>demo.test</code>. Эти поля являются, как правило, не существенными в
приложениях, которые используют <code>daemon_memcached</code>,
потому что MySQL сохраняет данные синхронизированными, и нет никакой
потребности волноваться об истечении данных или несвежем статусе.</li>

<li>Поле <code>unique_idx_name_on_key</code> установлено в
<code>PRIMARY</code>, что ссылается на первичный индекс, определенный на
уникальном столбце <code>country</code> таблицы <code>multicol</code>.
</p></li></ul></li>

<li><p>Скопируйте типовое приложение Питона в файл. В этом примере типовой
скрипт скопирован к файлу <code>multicol.py</code>.</p>
<p>Типовое приложение Питона вставляет данные в таблицу
<code>multicol</code> и получает данные для всех ключей, демонстрируя, как
получить доступ к таблице <code>InnoDB</code> через
плагин <code>daemon_memcached</code>.
<pre>
import sys, os
import memcache

def connect_to_memcached():
  memc = memcache.Client(['127.0.0.1:11211'], debug=0);
  print "Connected to memcached."
  return memc

def banner(message):
  print
  print "=" * len(message)
  print message
  print "=" * len(message)

country_data = [("Canada","34820000","9984670","R"),
   ("USA","314242000","9826675","R"),
   ("Ireland","6399152","84421","L"),
   ("UK","62262000","243610","L"),
   ("Mexico","113910608","1972550","R"),
   ("Denmark","5543453","43094","R"),
   ("Norway","5002942","385252","R"),
   ("UAE","8264070","83600","R"),
   ("India","1210193422","3287263","L"),
   ("China","1347350000","9640821","R"),]

def switch_table(memc,table):
  key = "@@" + table
  print "Switching default table to '" + table + "' by issuing GET for '" +
        key + "'."
  result = memc.get(key)

def insert_country_data(memc):
  banner("Inserting initial data via memcached interface")
  for item in country_data:
country = item[0]
population = item[1]
area = item[2]
drive_side = item[3]

key = country
value = "|".join([population,area,drive_side])
print "Key = " + key
print "Value = " + value

if memc.add(key,value):
   print "Added new key, value pair."
else:
  print "Updating value for existing key."
  memc.set(key,value)

def query_country_data(memc):
  banner("Retrieving data for all keys (country names)")
  for item in country_data:
key = item[0]
result = memc.get(key)
print "Here is the result retrieved from the database for key " + key + ":"
print result(m_population, m_area, m_drive_side) = result.split("|")
print "Unpacked population value: " + m_population
print "Unpacked area value  : " + m_area
print "Unpacked drive side value: " + m_drive_side

if __name__ == '__main__':
   memc = connect_to_memcached()
switch_table(memc,"bbb")
insert_country_data(memc)
query_country_data(memc)
sys.exit(0)
</pre>

<p>Типовые указания по применению Питона:</p>
<ul><li><p>Никакое разрешение базы данных не обязано запускать приложение,
так как манипуляция данных выполнена через интерфейс
<span><strong>memcached</strong></span>. Единственная запрошенная информация
этономер порта на местной системе, где слушает
<span><strong>memcached</strong></span>.</li>

<li>Чтобы удостовериться, что приложение использует таблицу
<code>multicol</code>, вызвана функция <code>switch_table()</code>,
которая выполняет <code>get</code> или <code>set</code>, используя форму
<code>@@</code>. Значение <code>name</code> в запросе <code>bbb</code>,
которое является табличным идентификатором <code>multicol</code>,
определенным в поле <code>innodb_memcache.containers.name</code>.</p>

<p>Более описательное значение <code>name</code> могло бы использоваться в
приложении реального мира. Этот пример просто иллюстрирует, что табличный
идентификатор определен, а не имя таблицы в <code>get @@...</code>.</li>

<li>Служебные функции демонстрируют, как превратить структуру данных Питона в
отделенные от канала значения для того, чтобы послать данные в MySQL с
помощью <code>add</code> или <code>set</code>
и как распаковать отделенные от канала значения, возвращенные
<code>get</code>. Эта дополнительная обработка требуется только, когда идет
отображение единственного значения <span><strong>memcached</strong></span>
на несколько столбцов таблицы в MySQL.</p></li></ul></li>

<li><p>Запустите типовое приложение Питона.
<pre>
shell&gt; python multicol.py
</pre>

<p>В случае успеха пример приложения возвращает этот вывод:
<pre>
Connected to memcached.
Switching default table to 'bbb' by issuing GET for '@@bbb'.
==============================================
Inserting initial data via memcached interface
==============================================
Key = Canada
Value = 34820000|9984670|R
Added new key, value pair.
Key = USA
Value = 314242000|9826675|R
Added new key, value pair.
Key = Ireland
Value = 6399152|84421|L
Added new key, value pair.
Key = UK
Value = 62262000|243610|L
Added new key, value pair.
Key = Mexico
Value = 113910608|1972550|R
Added new key, value pair.
Key = Denmark
Value = 5543453|43094|R
Added new key, value pair.
Key = Norway
Value = 5002942|385252|R
Added new key, value pair.
Key = UAE
Value = 8264070|83600|R
Added new key, value pair.
Key = India
Value = 1210193422|3287263|L
Added new key, value pair.
Key = China
Value = 1347350000|9640821|R
Added new key, value pair.

============================================
Retrieving data for all keys (country names)
============================================
Here is the result retrieved from the database for key Canada:
34820000|9984670|R
Unpacked population value: 34820000
Unpacked area value  : 9984670
Unpacked drive side value: R
Here is the result retrieved from the database for key USA:
314242000|9826675|R
Unpacked population value: 314242000
Unpacked area value  : 9826675
Unpacked drive side value: R
Here is the result retrieved from the database for key Ireland:
6399152|84421|L
Unpacked population value: 6399152
Unpacked area value  : 84421
Unpacked drive side value: L
Here is the result retrieved from the database for key UK:
62262000|243610|L
Unpacked population value: 62262000
Unpacked area value  : 243610
Unpacked drive side value: L
Here is the result retrieved from the database for key Mexico:
113910608|1972550|R
Unpacked population value: 113910608
Unpacked area value  : 1972550
Unpacked drive side value: R
Here is the result retrieved from the database for key Denmark:
5543453|43094|R
Unpacked population value: 5543453
Unpacked area value  : 43094
Unpacked drive side value: R
Here is the result retrieved from the database for key Norway:
5002942|385252|R
Unpacked population value: 5002942
Unpacked area value  : 385252
Unpacked drive side value: R
Here is the result retrieved from the database for key UAE:
8264070|83600|R
Unpacked population value: 8264070
Unpacked area value  : 83600
Unpacked drive side value: R
Here is the result retrieved from the database for key India:
1210193422|3287263|L
Unpacked population value: 1210193422
Unpacked area value  : 3287263
Unpacked drive side value: L
Here is the result retrieved from the database for key China:
1347350000|9640821|R
Unpacked population value: 1347350000
Unpacked area value  : 9640821
Unpacked drive side value: R
dtprice@ubuntu:~$
</pre></li>

<li>Запросите <code>innodb_memcache.containers</code>, чтобы рассмотреть
запись, которую Вы вставили ранее для <code>multicol</code>.
Первый отчет это типовая запись для таблицы <code>demo_test</code>, которая
составлена во время начальной установки <code>daemon_memcached</code>.
Второй отчет это запись, которую Вы вставили для <code>multicol</code>.
<pre>
mysql&gt; SELECT * FROM innodb_memcache.containers\G
*************************** 1. row ***************************
name: aaa
   db_schema: test
db_table: demo_test
 key_columns: c1
 value_columns: c2
   flags: c3
  cas_column: c4
expire_time_column: c5
unique_idx_name_on_key: PRIMARY
*************************** 2. row ***************************
name: bbb
   db_schema: test
db_table: multicol
 key_columns: country
 value_columns: population,area_sq_km,drive_side
   flags: c3
  cas_column: c4
expire_time_column: c5
unique_idx_name_on_key: PRIMARY
</pre></li>

<li>Запросите <code>multicol</code>, чтобы рассмотреть данные, вставленные
типовым приложением Питона. Данные доступны для
<a href="glossary.htm#glos_query">запроса</a> MySQL,
который демонстрирует, как к тем же самым данным можно получить доступ,
используя SQL или через приложения (использующуя соответствующий
<a href="connect.htm">MySQL Connector или API</a>).
<pre>
mysql&gt; SELECT * FROM test.multicol;
+---------+------------+------------+------------+------+------+------+
| country | population | area_sq_km | drive_side | c3   | c4   | c5   |
+---------+------------+------------+------------+------+------+------+
| Canada  | 34820000   | 9984670    | R          | 0    |   11 | 0    |
| China   | 1347350000 | 9640821    | R          | 0    |   20 | 0    |
| Denmark | 5543453    | 43094      | R          | 0    |   16 | 0    |
| India   | 1210193422 | 3287263    | L          | 0    |   19 | 0    |
| Ireland | 6399152    | 84421      | L          | 0    |   13 | 0    |
| Mexico  | 113910608  | 1972550    | R          | 0    |   15 | 0    |
| Norway  | 5002942    | 385252     | R          | 0    |   17 | 0    |
| UAE     | 8264070    | 83600      | R          | 0    |   18 | 0    |
| UK      | 62262000   | 243610     | L          | 0    |   14 | 0    |
| USA     | 314242000  | 9826675    | R          | 0    |   12 | 0    |
+---------+------------+------------+------------+------+------+------+
</pre>

<p>Всегда используйте достаточный размер, чтобы держать необходимые цифры,
десятичные запятые, символы знака, начальные нули и так далее, определяя
длину для столбцов, которые обработаны как числа. Слишком длинные значения в
строковом столбце, такие как <code>VARCHAR</code>, являются усеченными,
удаляя некоторые символы, которые могли произвести
бессмысленные числовые значения.</p></li>

<li><p>Произвольно, выполненный тип отчета запрашивает из таблицы
<code>InnoDB</code>, которая хранит данные
<span><strong>memcached</strong></span>.</p>

<p>Вы можете представить доклады через запросы SQL, выполняя вычисления и
тесты через любые столбцы, не только <code>country</code>.
Поскольку следующие примеры используют данные только из нескольких стран,
числа только в целях иллюстрации. Следующие запросы возвращают среднее
население стран, где люди управляют справа, и средний размер стран, имена
которых начинаются на <span><span>U</span></span>:
<pre>
mysql&gt; SELECT AVG(population) FROM multicol WHERE drive_side = 'R';
+-------------------+
| avg(population)   |
+-------------------+
| 261304724.7142857 |
+-------------------+

mysql&gt; SELECT SUM(area_sq_km) FROM multicol WHERE country LIKE 'U%';
+-----------------+
| sum(area_sq_km) |
+-----------------+
|10153885 |
+-----------------+
</pre>

<p>Поскольку <code>population</code> и <code>area_sq_km</code>
хранят символьные, а не числовые данные, функции
<code>AVG()</code> и <code>SUM()</code> работают, преобразовывая каждое
значение в число сначала. Этот подход
<span><em>не работает</em></span> на операторах
<code>&lt;</code> или <code>&gt;</code>,
например, сравнивая символьно-ориентированные значения,
<code>9 &gt; 1000</code>, которые не ожидаются от такого запроса, как
<code>ORDER BY population DESC</code>. Для самого точного обращения типа,
выполните запросы для представлений, которые приводят числовые столбцы к
соответствующим типам. Этот метод позволяет Вам использовать простые запросы
<code>SELECT *</code> от приложений базы данных, гарантируя, что
фильтр и упорядочивание правильны. Следующий пример показывает представление,
которое может быть запрошено, чтобы найти лучшие три страны в порядке
убывания населения, с результатами, отражающими
последние данные в <code>multicol</code>:
<pre>
mysql&gt; CREATE VIEW populous_countries AS
    -&gt; SELECT country, cast(population as unsigned integer) population,
    -&gt;        cast(area_sq_km as unsigned integer) area_sq_km,
    -&gt;        drive_side FROM multicol
    -&gt;        ORDER BY CAST(population as unsigned integer) DESC LIMIT 3;

mysql&gt; SELECT * FROM populous_countries;
+---------+------------+------------+------------+
| country | population | area_sq_km | drive_side |
+---------+------------+------------+------------+
| China   | 1347350000 |9640821     | R          |
| India   | 1210193422 |3287263     | L          |
| USA     |  314242000 |9826675     | R          |
+---------+------------+------------+------------+

mysql&gt; DESC populous_countries;
+------------+---------------------+------+-----+---------+-------+
| Field      | Type                | Null | Key | Default | Extra |
+------------+---------------------+------+-----+---------+-------+
| country    | varchar(128)        |  NO  |     |         |       |
| population | bigint(10) unsigned | YES  |     | NULL    |       |
| area_sq_km | int(9) unsigned     | YES  |     | NULL    |       |
| drive_side | varchar(1)          | YES  |     | NULL    |       |
+------------+---------------------+------+-----+---------+-------+
</pre></li></ol>

<h4><a name="innodb-memcached-porting-memcached"></a>16.19.6.2.
Приспосабливание приложения memcached для InnoDB memcached</h4>
<p>Рассмотрите эти аспекты MySQL и таблиц <code>InnoDB</code>, адаптируя
существующие приложения <span><strong>memcached</strong></span>, чтобы
использовать плагин <code>daemon_memcached</code>:</p>

<ul><li><p>Если есть значения ключа больше чем несколько байтов, может быть
более эффективно использовать числовой столбец auto-increment в качестве
<a href="glossary.htm#glos_primary_key">primary key</a> таблицы
<code>InnoDB</code> и создать уникальный
<a href="glossary.htm#glos_secondary_index">вторичный индекс</a>
на столбце, который содержит значения ключа <span><strong>memcached</strong>
</span>. Поэтому <code>InnoDB</code> выступает лучше всего для
крупномасштабных вставок, если значения первичного ключа добавлены в
сортированном порядке (как со значениями auto-increment).
Значения первичного ключа включены во вторичный индекс, который занимает
ненужное место, если первичный ключ длинное строковое значение.</li>

<li>Если Вы храните несколько различных классов информации, используя
<span><strong>memcached</strong></span>, рассмотрите установку отдельной
таблицы <code>InnoDB</code> для каждого типа данных. Определите
дополнительные табличные идентификаторы в
<code>innodb_memcache.containers</code> и используйте форму
<code>@@<em><code>table_id</code></em>.<em><code>key</code></em></code>,
чтобы сохранить и получить элементы от различных таблиц. Физически деление
различных типов информации позволяет Вам настраивать характеристики каждой
таблицы для оптимального использования пространства, работы и надежности.
Например, Вы могли бы включить <a href="glossary.htm#glos_compression">
сжатие</a> для таблицы, которая содержит сообщения в блоге, но не для
таблицы, которая содержит изображения миниатюр. Вы могли бы резервировать
одну таблицу более часто, чем другую потому, что она содержит критические
данные. Вы могли бы создать дополнительный
<a href="glossary.htm#glos_secondary_index">вторичный индекс</a>
на таблицах, которые часто используются, чтобы произвести
отчеты, используя SQL.</li>

<li>Предпочтительно, сконфигурируйте устойчивый набор табличных определений
для использования с плагином <span><strong>daemon_memcached</strong></span>.
Изменения <code>innodb_memcache.containers</code> вступают в силу, когда
<code>innodb_memcache.containers</code> запрошена в следующий раз.
Записи в таблице контейнеров обработаны при запуске и проверяются всякий раз,
когда непризнанный табличный идентификатор (как определено в
<code>containers.name</code>) требуется, используя форму <code>@@</code>.
Таким образом, новые записи видимы, как только Вы используете связанный
табличный идентификатор, но изменения существующих записей требуют
перезапуска сервера прежде, чем они вступят в силу.</li>

<li>Когда Вы используете значение по умолчанию <code>innodb_only</code>,
вызовы <code>add()</code>, <code>set()</code>, <code>incr()</code> и т.п.
может работать, но все еще вызвать сообщения отладки вроде
<code>while expecting 'STORED', got unexpected response 'NOT_STORED</code>.
Сообщения отладки происходят, потому что новые и обновленные значения
посылаются непосредственно в таблицу <code>InnoDB</code>, не будучи
сохраненными в кэш-памяти, из-за логики <code>innodb_only</code>.
</p></li></ul>

<h4><a name="innodb-memcached-tuning"></a>16.19.6.3.
Тюнинг InnoDB memcached</h4>
<p>Поскольку использование <code>InnoDB</code> в комбинации с
<span><strong>memcached</strong></span> вовлекает запись всех данных на диск
немедленно или когда-то позже, сырая работа, как ожидают, будет несколько
медленнее, чем использование <span><strong>memcached</strong></span>
отдельно. Используя <code>InnoDB</code> плагин
<span><strong>memcached</strong></span>, надо максимально ускорить
операции <span><strong>memcached</strong></span> при достижении лучшей
работы, чем эквивалентные операции SQL.</p>

<p>Точки отсчета предполагают, что запросы и операции
<a href="glossary.htm#glos_dml">DML</a> (вставки, обновления и удаления),
которые используют интерфейс <span><strong>memcached</strong></span>, быстрее
чем традиционный SQL. Операции DML, как правило, видят большие
усовершенствования. Поэтому полагайте, что приспосабливание
приложений с интенсивной записью, чтобы использовать
интерфейс <span><strong>memcached</strong></span>, лучше.</p>

<h5><a name="idm139965314887440"></a>Приспосабливание запросов SQL</h5>
<p>Типы запросов, которые больше всего подходят для простых
<code>GET</code> это запросы с единственным условием или
набором <code>AND</code> в <code>WHERE</code>:
<pre>
SQL:
SELECT col FROM tbl WHERE key = 'key_value';

memcached:
GET key_value

SQL:
SELECT col FROM tbl WHERE col1 = val1 and col2 = val2 and col3 = val3;

memcached:
# Since you must always know these 3 values to look up the key,
# combine them into a unique string and use that as the key
# for all ADD, SET, and GET operations.
key_value = val1 + ":" + val2 + ":" + val3
GET key_value

SQL:
SELECT 'key exists!' FROM tbl
       WHERE EXISTS (SELECT col1 FROM tbl WHERE KEY = 'key_value') LIMIT 1;

memcached:
# Test for existence of key by asking for its value and checking if the call succeeds,
# ignoring the value itself. For existence checking, you typically only store a very
# short value such as "1".
GET key_value
</pre>

<h5><a name="idm139965314882736"></a>Используя системную память</h5>
<p>Для лучшей работы разверните плагин <code>daemon_memcached</code>
на машинах, которые сконфигурированы как типичные серверы базы данных, где
большинство системной RAM передано
<a href="glossary.htm#glos_buffer_pool">буферному пулу</a> через опцию
<a href="#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>. Для систем с буферными пулами в
несколько гигабайт рассмотрите подъем значения
<a href="#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a> для максимальной пропускной
способности, когда большинство операций вовлекает данные, которые
уже кэшируются в памяти.</p>

<h5><a name="idm139965314876480"></a>Сокращение избыточного ввода/вывода</h5>
<p><code>InnoDB</code> имеет много настроек, которые позволяют Вам выбирать
баланс между высокой надежностью, в случае катастрофического отказа и
количеством издержек ввода/вывода во время высоких рабочих нагрузок записи.
Например, рассмотрите установку
<a href="#sysvar_innodb_doublewrite"><code>innodb_doublewrite
</code></a> в <code>0</code> и
<a href="#sysvar_innodb_flush_log_at_trx_commit"><code>
innodb_flush_log_at_trx_commit</code></a> в <code>2</code>.
Определите эксплуатационные качества с различными настройками
<a href="#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a>.</p>
<p>Подробности в <a href="optimiz.htm#optimizing-innodb-diskio">разделе
9.5.8</a>.</p>

<h5><a name="idm139965314868032"></a>Сокращение издержек транзакций</h5>
<p>Значение по умолчанию 1 для
<a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a> и
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a>
предназначено для максимальной надежности результатов и безопасности
хранимых или обновленных данных.</p>

<p>В зависимости от типа приложения, Вы могли бы увеличить одну или обе из
этих настроек, чтобы уменьшить издержки частых операций
<a href="glossary.htm#glos_commit">commit</a>.
На занятой системе Вы могли бы увеличить
<a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a> зная, что
изменения данных, сделанные через SQL, возможно, не становится видимы
<span><strong>memcached</strong></span> немедленно (то есть, пока
обработано не больше <em><code>N</code></em> запросов <code>get</code>).
Обрабатывая данные, где каждая запись должна быть достоверно сохранена,
установите <a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a> в <code>1</code>.
Увеличьте установку, обрабатывая большие количества обновлений,
предназначенных только для статистического анализа, где потеря последних
<em><code>N</code></em> обновлений при катастрофическом отказе
является приемлемым риском.</p>

<p>Например, вообразите систему, которая контролирует трафик, пересекающий
оживленный мост, делая запись данных приблизительно для 100000 транспортных
средств каждый день. Если приложение считает различные типы транспортных
средств, чтобы проанализировать образцы трафика, измените
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a> на <code>100</code>, уменьшив
ввод/вывод на 99%. В случае отключения электричества потеряно максимум 100
отчетов, что может быть приемлемым пределом погрешности. Если бы вместо этого
приложение выполнило автоматизированный сбор данных для каждого автомобиля,
то Вы установили бы <a href="#sysvar_daemon_memcached_w_batch_size">
<code>daemon_memcached_w_batch_size</code></a> в <code>1</code>, чтобы
гарантировать, что каждый отчет был немедленно сохранен на диск.</p>

<p>Из-за пути, которым <code>InnoDB</code> организует
значения ключа на диске, если у Вас есть большое количество ключей, которые
надо создать, может быть быстрее сортировать элементы данных значением ключа
в приложении и затем <code>add</code> их в сортированном порядке, вместо
того, чтобы создать ключи в произвольном порядке.</p>

<p>Команда <span><strong>memslap</strong></span>, часть дистрибутива
<span><strong>memcached</strong></span>, не входит в плагин
<code>daemon_memcached</code>, может быть полезна для сопоставительного
анализа различных конфигураций. Это может также использоваться, чтобы
произвести типовые пары ключа/значения, чтобы использовать в Ваших
собственных точках отсчета. См.
<a href="ha.htm#ha-memcached-interfaces-libmemcached-utilities">раздел
18.2.3.3.6</a>.</p>

<h4><a name="innodb-memcached-txn"></a>16.19.6.4.
Управление транзакционным поведением InnoDB memcached</h4>
<p>В отличие от традиционного <span><strong>memcached</strong></span>,
<code>daemon_memcached</code> позволяет Вам управлять длительностью значений
данных, произведенных посредством <code>add</code>, <code>set</code>,
<code>incr</code> и т.п. По умолчанию, данные, написанные через интерфейс
<span><strong>memcached</strong></span> хранятся на диске, и <code>get</code>
возвратит новое значение с диска. Хотя поведение по умолчанию не предлагает
самую лучшую работу, это все еще быстро по сравнению с интерфейсом SQL для
таблиц <code>InnoDB</code>.</p>

<p>Поскольку Вы приобретаете опыт, используя <code>daemon_memcached</code>,
Вы можете рассмотреть настройки длительности для некритических классов
данных, рискуя тем, чтобы терять некоторые обновленные значения в случае
отключения электричества или возвратить данные, которые
являются немного устаревшими.</p>

<h5><a name="idm139965314835936"></a>Частота Commit</h5>
<p>Важно понимать, как часто новые и измененные данные
<a href="glossary.htm#glos_commit">commit</a>.
Если данные важны, они должны быть немедленно переданы, чтобы это было
безопасно в случае катастрофического отказа или отключения электричества.
Если данные менее важные, такие как счетчики, которые сброшены после
катастрофического отказа или данные о журналировании, которые Вы можете
позволить себе потерять, Вы могли бы предпочесть более высокую пропускную
способность, которая доступна с менее частыми сохранениями.</p>

<p>Когда <span><strong>memcached</strong></span> вставляет, обновляет
или удаляет данные в основной таблице <code>InnoDB</code>, они меняются
немедленно (если <a href="#sysvar_daemon_memcached_w_batch_size">
<code>daemon_memcached_w_batch_size=1</code></a>) или некоторое время спустя
(если <a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a> больше 1).
В любом случае изменение не может быть откачено. Если Вы увеличиваете
значение <a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a>, чтобы избежать большого
ввода/вывода в течение напряженного времени, передача может стать редкой,
когда рабочая нагрузка уменьшается. Как мера по безопасности, фоновый поток
автоматически передает изменения, произведенные через
<span><strong>memcached</strong></span> API равномерно. Интервалом управляет
опция <a href="#sysvar_innodb_api_bk_commit_interval"><code>
innodb_api_bk_commit_interval</code></a>, у которой есть настройка
по умолчанию <code>5</code> секунд.</p>

<p>Когда <span><strong>memcached</strong></span>
вставляет или обновляет данные в основной таблице <code>InnoDB</code>,
измененные данные немедленно видимы другим запросам
<span><strong>memcached</strong></span>, потому что новое значение остается в
кэш-памяти, даже если это еще не передано на сторону MySQL.</p>

<h5><a name="idm139965314821088"></a>Операционная изоляция</h5>
<p>Когда <span><strong>memcached</strong></span> выполняет запрос
<code>get</code> или <code>incr</code> или DML на основной таблице
<code>InnoDB</code>, Вы можете управлять, видит ли работа самые последние
данные, написанные в таблицу, только данные, которые были переданы, или
другие изменения операционного
<a href="glossary.htm#glos_isolation_level">уровня изоляции</a>. Используйте
опцию <a href="#sysvar_innodb_api_trx_level"><code>
innodb_api_trx_level</code></a>, чтобы управлять этой особенностью. Числовые
значения, определенные для этой опции, соответствуют уровням изоляции,
например, <a href="#isolevel_repeatable-read"><code>REPEATABLE READ
</code></a>.</p>

<p>Строгий уровень изоляции гарантирует, что данные, которые Вы получаете, не
откачены или не изменились внезапно, чтобы заставлять последующие запросы
возвратить различные значения.
Однако, строгие уровни изоляции требуют больших издержек
<a href="glossary.htm#glos_locking">блокировки</a>, что может вызвать
ожидание. Для приложения NoSQL-стиля, которое не использует продолжительные
транзакции, Вы можете, как правило, использовать уровень изоляции значения по
умолчанию или переключаться на менее строгий уровень изоляции.</p>

<h5><a name="idm139965314810352"></a>
Отключение блокировок строки для memcached DML</h5>
<p>Опция <a href="#sysvar_innodb_api_disable_rowlock"><code>
innodb_api_disable_rowlock</code></a>
может использоваться, чтобы отключить блокировки строки, когда
<span><strong>memcached</strong></span> просит DML через
<code>daemon_memcached</code>. По умолчанию
<code>innodb_api_disable_rowlock</code> = <code>OFF</code>,
что означает, что <span><strong>memcached</strong></span>
просит блокировки строки для <code>get</code> и <code>set</code>. Когда
<code>innodb_api_disable_rowlock</code> = <code>ON</code>,
<span><strong>memcached</strong></span> просит табличную блокировку
вместо блокировок строки.</p>

<p>Опция <code>innodb_api_disable_rowlock</code> не является динамичной. Это
должно быть определено при запуске в командной строке
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
или введено в конфигурационный файл MySQL.</p>

<h5><a name="idm139965314798144"></a>Разрешение или запрет DDL</h5>
<p>По умолчанию Вы можете выполнить операции
<a href="glossary.htm#glos_ddl">DDL</a>, например,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
на таблицах, используемых <code>daemon_memcached</code>.
Чтобы избежать потенциального замедления, когда эти таблицы используются для
приложений высокой пропускной способности, отключите операции DDL на этих
таблицах, включая при запуске опцию
<a href="#sysvar_innodb_api_enable_mdl"><code>innodb_api_enable_mdl
</code></a>. Эта опция является менее подходящей, если Вы получаете доступ к
тем же самым таблицам через <span><strong>memcached</strong></span> и SQL,
потому что это блокирует <a href="sql.htm#create-index"><code>CREATE INDEX
</code></a> на таблицах, которые могли быть важными для выполнения запросов.
</p>

<h5><a name="idm139965314790624"></a>
Хранить жанные на диске, в памяти или везде</h5>
<p>Таблица <code>innodb_memcache.cache_policies</code>
определяет, хранить ли данные, написанные через интерфейс
<span><strong>memcached</strong></span> на диске
(<code>innodb_only</code>, по умолчанию), только в памяти, как с традиционным
<span><strong>memcached</strong></span>
(<code>cache-only</code>) или в обоих местах (<code>caching</code>).</p>

<p>При значении <code>caching</code>, если
<span><strong>memcached</strong></span> не может найти ключ в памяти, он ищет
значение в таблице <code>InnoDB</code>. Значения из <code>get</code>
при <code>caching</code> могут быть устаревшими, если значения были обновлены
на диске в таблице <code>InnoDB</code>, но еще не выдохлись в кэш-памяти.</p>

<p>Кэширующая политика может быть установлена независимо для
<code>get</code>, <code>set</code> (включая <code>incr</code> и
<code>decr</code>), <code>delete</code> и <code>flush</code>.</p>

<p>Например, Вы могли бы позволить <code>get</code> и <code>set</code>, чтобы
запросить или обновить таблицу и кэш-память <span><strong>memcached</strong>
</span> в то же самое время (используя <code>caching</code>),
делая <code>delete</code>, <code>flush</code> или обе операции
только на копии в памяти (используя <code>cache_only</code>).
Этот путь, удаляя или сбрасывая элемент только вычеркивает элемент от кэша, и
последнее значение возвращено из таблицы <code>InnoDB</code>
в следующий раз, когда элемент требуют.
<pre>
mysql&gt; SELECT * FROM innodb_memcache.cache_policies;
+--------------+-------------+-------------+---------------+--------------+
| policy_name  | get_policy  | set_policy  | delete_policy | flush_policy |
+--------------+-------------+-------------+---------------+--------------+
| cache_policy | innodb_only | innodb_only | innodb_only   | innodb_only  |
+--------------+-------------+-------------+---------------+--------------+

mysql&gt; UPDATE innodb_memcache.cache_policies SET set_policy = 'caching'
    -&gt;        WHERE policy_name = 'cache_policy';
</pre>

<p>Значения <code>innodb_memcache.cache_policies</code> считаны только при
запуске. После изменения значений в этой таблице, удалите и повторно
установите плагин <code>daemon_memcached</code>, чтобы гарантировать, что
изменения вступают в силу.
<pre>
mysql&gt; UNINSTALL PLUGIN daemon_memcached;
mysql&gt; INSTALL PLUGIN daemon_memcached soname "libmemcached.so";
</pre>

<h4><a name="innodb-memcached-dml"></a>16.19.6.5.
Приспосабливание запроса DML к memcached</h4>
<p>Точки отсчета предполагают, что <code>daemon_memcached</code>
ускоряет <a href="glossary.htm#glos_dml">DML</a>
(вставки, обновения и удаления) больше, чем он ускоряет запросы.</p>

<p>Единственная строка запроса DML является самыми легким типом запросов,
чтобы использовать операции <code>memcached</code>.
<code>INSERT</code> вместо <code>add</code>,
<code>UPDATE</code> вместо <code>set</code>,
<code>incr</code> или <code>decr</code>,
<code>DELETE</code> вместо <code>delete</code>.
Эти операции, как гарантируют, затронут только одну строку, когда запущены
через интерфейс <span><strong>memcached</strong></span>, потому что
<em><code>key</code></em> уникален в пределах таблицы.</p>

<p>В следующих примерах SQL <code>t1</code> обращается к таблице,
используемой для операциях <span><strong>memcached</strong></span>,
основанных на конфигурации в <code>innodb_memcache.containers</code>.
<code>key</code> обращается к столбцу, перечисленному под
<code>key_columns</code>, <code>val</code>
обращается к столбцу, перечисленному как <code>value_columns</code>.
<pre>
INSERT INTO t1 (key,val) VALUES (<em><code>some_key</code></em>,
                                 <em><code>some_value</code></em>);
SELECT val FROM t1 WHERE key = <em><code>some_key</code></em>;
UPDATE t1 SET val = <em><code>new_value</code></em>
          WHERE key = <em><code>some_key</code></em>;
UPDATE t1 SET val = val + x WHERE key = <em><code>some_key</code></em>;
DELETE FROM t1 WHERE key = <em><code>some_key</code></em>;
</pre>

<p>Следующие <a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
и <a href="sql.htm#delete"><code>DELETE</code></a>, которые удаляют все
строки из таблицы, соответствуют <code>flush_all</code>, где
<code>t1</code> сконфигурирована как таблица для операций
<span><strong>memcached</strong></span>, как в предыдущем примере.
<pre>
TRUNCATE TABLE t1;
DELETE FROM t1;
</pre>

<h4><a name="innodb-memcached-ddl"></a>16.19.6.6.
Выполнение DML и запроса DDL об основной таблице InnoDB</h4>
<p>Вы можете получить доступ к основной таблице <code>InnoDB</code>
(по умолчанию <code>test.demo_test</code>)
через стандартные интерфейсы SQL. Однако, есть некоторые ограничения:</p>

<ul><li><p>Запрашивая таблицу, к которой также получают доступ через
интерфейс <span><strong>memcached</strong></span>, помните, что
действия <span><strong>memcached</strong></span> могут быть сконфигурированы,
чтобы передаваться периодически, а не после каждой записи. Этим поведением
управляет опция <a href="#sysvar_daemon_memcached_w_batch_size">
<code>daemon_memcached_w_batch_size</code></a>. Если она установлена в
значение больше <code>1</code>, надо использовать
<a href="#isolevel_read-uncommitted"><code>READ UNCOMMITTED</code>
</a>, чтобы найти строки, которые были только что вставлены.
<pre>
mysql&gt; SET SESSSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
mysql&gt; SELECT * FROM demo_test;
+------+------+------+------+-----------+------+------+------+------+------+------+
| cx   | cy   | c1   | cz   | c2        | ca   | CB   | c3   | cu   | c4   | C5   |
+------+------+------+------+-----------+------+------+------+------+------+------+
| NULL | NULL | a11  | NULL | 123456789 | NULL | NULL |   10 | NULL |    3 | NULL |
+------+------+------+------+-----------+------+------+------+------+------+------+
</pre></li>

<li>Изменяя таблицу, используя SQL, к которой также получают доступ через
интерфейс <span><strong>memcached</strong></span>, Вы можете сконфигурировать
операции <span><strong>memcached</strong></span> запускать новую транзакцию
периодически, а не для каждого чтения. Этим поведением управляет опция
<a href="#sysvar_daemon_memcached_r_batch_size">
<code>daemon_memcached_r_batch_size</code></a>. Если она
установлена в значение больше <code>1</code>, изменения, произведенные в
таблице, используя SQL, не видимы немедленно для <span><strong>memcached
</strong></span>.</li>

<li>Таблица <code>InnoDB</code> заблокирована как IS (intention shared) или
IX (intention exclusive) для всех операций в транзакции. Если Вы увеличиваете
<a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a> и
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a>
существенно от их значения по умолчанию <code>1</code>,
таблица наиболее вероятно заблокирована, предотвращая запросы
<a href="glossary.htm#glos_ddl">DDL</a>.</p></li></ul>

<h3><a name="innodb-memcached-replication"></a>16.19.7.
Репликация и плагин InnoDB memcached</h3>
<p>Поскольку <code>daemon_memcached</code> поддерживает
<a href="glossary.htm#glos_binary_log">двоичный журнал</a> MySQL,
обновления, сделанные на <a href="glossary.htm#glos_master_server">
главном сервере</a> через интерфейс <span><strong>memcached</strong></span>
могут копироваться для резервного копирования, балансируя интенсивные рабочие
нагрузки чтения и высокую доступность. Все команды <span><strong>memcached
</strong></span> поддержаны с двоичным журналированием.</p>

<p>Вы не должны настроить <code>daemon_memcached</code>
на <a href="glossary.htm#glos_slave_server">ведомых серверах</a>.
Основное преимущество этой конфигурации это увеличение пропускной способности
на ведущем устройстве. Скорость механизма репликации не затронута.</p>

<p>Следующие разделы показывают, как использовать двоичный журнал, используя
<code>daemon_memcached</code> с репликацией MySQL.
Предполагается, что Вы завершили установку, описанную в
<a href="#innodb-memcached-setup">разделе 16.19.3</a>.</p>

<h4><a name="innodb-memcached-replication-enable-binlog"></a>
Включение двоичного журнала InnoDB memcached</h4>
<ol type="1"><li><p>Чтобы использовать <code>daemon_memcached</code> с
<a href="glossary.htm#glos_binary_log">двоичным журналом</a>, включите
опцию <a href="#sysvar_innodb_api_enable_binlog"><code>
innodb_api_enable_binlog</code></a> на
<a href="glossary.htm#glos_master_server">главном сервере</a>.
Эта опция может быть установленатолько  при запуске сервера. Вы должны также
включить двоичный журнал на главном сервере опцией
<a href="replica.htm#sysvar_log_bin"><code>--log-bin</code></a>.
Вы можете добавить эти опции к конфигурационному файлу MySQL или в
командную строку <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a>.
<pre>
mysqld ... --log-bin -Б─⌠innodb_api_enable_binlog=1
</pre></li>

<li>Сконфигурируйте основной и ведомый серверы, как описано в
<a href="replica.htm#replication-howto">разделе 19.1.2</a>.</li>
<li>Используйте <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a>, чтобы создать основной снимок данных и синхронизировать
снимок с ведомым сервером.
<pre>
master shell&gt; mysqldump --all-databases --lock-all-tables &gt; dbdump.db
slave shell&gt; mysql &lt; dbdump.db
</pre></li>

<li>На главном сервере скомандуйте <a href="sql.htm#show-master-status">
<code>SHOW MASTER STATUS</code></a>, чтобы получить координаты
основного двоичного журнала.
<pre>
mysql&gt; SHOW MASTER STATUS;
</pre></li>

<li>На ведомом сервере используйте <a href="sql.htm#change-master-to"><code>
CHANGE MASTER TO</code></a>, чтобы настроить ведомый сервер, используя
координаты из основного двоичного журнала.
<pre>
mysql&gt; CHANGE MASTER TO MASTER_HOST='localhost', MASTER_USER='root',
                           MASTER_PASSWORD='', MASTER_PORT = 13000,
                           MASTER_LOG_FILE='0.000001, MASTER_LOG_POS=114;
</pre></li>

<li>Запустите ведомое устройство.
<pre>
mysql&gt; START SLAVE;
</pre>

<p>Если журнал ошибок выводит что-то, подобное следующему,
ведомое устройство готово.
<pre>
2013-09-24T13:04:38.639684Z 49 [Note] Slave I/O thread: connected to
master 'root@localhost:13000', replication started in log '0.000001'
at position 114
</pre></li></ol>

<h4><a name="innodb-memcached-replication-testing"></a>
Тестирование конфигурации репликации InnoDB memcached</h4>
<p>Этот пример демонстрирует, как проверить конфигурацию
<code>InnoDB</code> <span><strong>memcached</strong></span>, используя
<span><strong>memcached</strong></span> и telnet, чтобы вставить, обновить и
удалить данные. Клиент MySQL используется, чтобы проверить результаты на
основном и ведомом серверах.</p>

<p>Пример использует таблицу <code>demo_test</code>,
которая была составлена скриптом <code>innodb_memcached_config.sql</code>
во время начальной установки <code>daemon_memcached</code>. Таблица
<code>demo_test</code> содержит единственную запись в качестве примера.</p>

<ol type="1"><li><p>Используйте команду <code>set</code>, чтобы вставить
запись с ключом <code>test1</code>, значение флага <code>10</code>,
значение истечения <code>0</code>, значение cas 1 и значение <code>t1</code>.
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
set test1 10 0 1
t1
STORED
</pre></li>

<li>На главном сервере проверьте, что запись была вставлена в
<code>demo_test</code>. Учитывая, что <code>demo_test</code> не была ранее
изменена, должно быть две записи. Запись в качестве примера с ключом
<code>AA</code> и запись, которую Вы только что вставили, с ключом
<code>test1</code>. Столбец <code>c1</code> отображается на ключ,
<code>c2</code> значение, <code>c3</code> флаг, <code>c4</code> cas и
<code>c5</code> ко времени истечения срока. Время истечения срока было
установлено в 0, так как это не использовано.
<pre>
mysql&gt; SELECT * FROM test.demo_test;
+-------+--------------+----+----+----+
| c1    | c2           | c3 | c4 | c5 |
+-------+--------------+----+----+----+
| AA    | HELLO, HELLO | 8  | 0  | 0  |
| test1 | t1           | 10 | 1  | 0  |
+-------+--------------+----+----+----+
</pre></li>

<li>Проверьте, что та же самая запись копировалась к ведомому серверу.
<pre>
mysql&gt; SELECT * FROM test.demo_test;
+-------+--------------+----+----+----+
| c1    | c2           | c3 | c4 | c5 |
+-------+--------------+----+----+----+
| AA    | HELLO, HELLO | 8  | 0  | 0  |
| test1 | t1           | 10 | 1  | 0  |
+-------+--------------+----+----+----+
</pre></li>

<li>Используйте <code>set</code>, чтобы обновить
ключ к значению <code>new</code>.
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
set test1 10 0 2
new
STORED
</pre>

<p>Обновление копируется к ведомому серверу (заметьте, что
<code>cas</code> также обновлено).
<pre>
mysql&gt; SELECT * FROM test.demo_test;
+-------+--------------+----+----+----+
| c1    | c2           | c3 | c4 | c5 |
+-------+--------------+----+----+----+
| AA    | HELLO, HELLO |  8 | 0  | 0  |
| test1 | new          | 10 | 2  | 0  |
+-------+--------------+----+----+----+
</pre></li>

<li>Удалите запись <code>test1</code> командой <code>delete</code>.
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
delete test1
DELETED
</pre>

<p>Когда <code>delete</code> копируется к ведомому устройству, запись
<code>test1</code> на ведомом устройстве также удалена.
<pre>
mysql&gt; SELECT * FROM test.demo_test;
+----+--------------+----+----+----+
| c1 | c2           | c3 | c4 | c5 |
+----+--------------+----+----+----+
| AA | HELLO, HELLO | 8  | 0  | 0  |
+----+--------------+----+----+----+
</pre></li>

<li>Удалите все строки из таблицы, используя <code>flush_all</code>.
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
flush_all
OK

mysql&gt; SELECT * FROM test.demo_test;
Empty set (0.00 sec)
</pre></li>

<li>Подключитесь к главному серверу и введите две новых записи.
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'
set test2 10 0 4
again
STORED
set test3 10 0 5
again1
STORED
</pre></li>

<li>Подтвердите, что две записи копировались к ведомому серверу.
<pre>
mysql&gt; SELECT * FROM test.demo_test;
+-------+--------+----+----+----+
| c1    | c2     | c3 | c4 | c5 |
+-------+--------+----+----+----+
| test2 | again  | 10 | 4  | 0  |
| test3 | again1 | 10 | 5  | 0  |
+-------+--------+----+----+----+
</pre></li>

<li>Удалите все строки из таблицы, используя <code>flush_all</code>.
<pre>
telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
flush_all
OK
</pre></li>

<li>Проверьте, что <code>flush_all</code> скопировалась на ведомом сервере.
<pre>
mysql&gt; SELECT * FROM test.demo_test;
Empty set (0.00 sec)
</pre></li></ol>

<h4><a name="innodb-memcached-binlog-notes"></a>
Примечания о двоичном журнале и InnoDB memcached</h4>
<p>Формат двоичного журнала:</p>
<ul><li><p>Большинство операций <span><strong>memcached</strong></span>
отображено на запросы <a href="glossary.htm#glos_dml">DML</a>
(аналоги вставки, удаления, обновления). С тех пор нет никакого фактического
запроса SQL, обрабатываемого сервером MySQL, все команды
<span><strong>memcached</strong></span> (кроме <code>flush_all</code>)
используют журналирование Row-Based Replication (RBR), которое независимо от
любого значения <a href="replica.htm#sysvar_binlog_format"><code>
binlog_format</code></a> сервера.</li>

<li><span><strong>memcached</strong></span> <code>flush_all</code>
отображена на <a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code>
</a> в MySQL 5.7 и ранее. Так как команды
<a href="glossary.htm#glos_ddl">DDL</a>
могут использовать только основанное на запросе журналирование,
<code>flush_all</code> копируется, посылая
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>. В
MySQL 8.0 и позже <code>flush_all</code> отображена на <code>DELETE</code>,
но все еще копируется, посылая <a href="sql.htm#truncate-table">
<code>TRUNCATE TABLE</code></a>.</p></li></ul>

<p>Транзакции:</p>
<ul><li><p>Понятие <a href="glossary.htm#glos_transaction">транзакций</a>
не было частью <span><strong>memcached</strong></span>. Для исполнительных
соображений <a href="#sysvar_daemon_memcached_r_batch_size"><code>
daemon_memcached_r_batch_size</code></a> и
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a>
используются, чтобы управлять пакетным размером для чтения и записи.
Эти настройки не затрагивают репликацию. Каждая работа SQL на основной
таблице <code>InnoDB</code> копируется после успешного завершения.</li>

<li>Значение по умолчанию
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a> = <code>1</code>,
что означает, что каждая запись <span><strong>memcached</strong></span>
немедленно передана. Эта настройка по умолчанию подвергается определенному
количеству издержек, чтобы избежать несогласованностей в данных, которые
видимы на основных и ведомых серверах. Копируемые отчеты немедленно всегда
доступны на ведомом сервере. Если Вы устанавливаете
<a href="#sysvar_daemon_memcached_w_batch_size"><code>
daemon_memcached_w_batch_size</code></a> к значению больше <code>1</code>,
записи, вставленные или обновленные через
<span><strong>memcached</strong></span>, не видимы немедленно на
главном сервере, чтобы смотреть на главном сервере записи прежде, чем они
будут переданы, используйте <a href="sql.htm#set-transaction"><code>SET
TRANSACTION ISOLATION LEVEL READ UNCOMMITTED</code></a>.
</p></li></ul>

<h3><a name="innodb-memcached-internals"></a>16.19.8.
Внутренности плагина InnoDB memcached</h3>
<h4><a name="innodb-memcached-api"></a>InnoDB API для InnoDB memcached</h4>
<p><code>InnoDB</code> <span><strong>memcached</strong></span>
обращается к <code>InnoDB</code> через <code>InnoDB</code> API,
большинство которых непосредственно принято от встроенного
<code>InnoDB</code>. Функции API передаются механизму
<code>InnoDB</code> <span><strong>memcached</strong></span> как callback.
Функции <code>InnoDB</code> API получают доступ к таблицам
<code>InnoDB</code> непосредственно и являются главным образом операциями
DML, за исключением <a href="sql.htm#truncate-table"><code>TRUNCATE TABLE
</code></a>.</p>

<p>Команды <span><strong>memcached</strong></span> осуществлены через
<code>InnoDB</code> <span><strong>memcached</strong></span> API.
Следующая таблица обрисовывает в общих чертах, как команды
<span><strong>memcached</strong></span> отображены на DML или операции DDL.
</p>

<a name="idm139965314558944"></a><p><b>Таблица 16.13. Команды memcached и
связанные операции DML или DDL</b></p>
<table border="1">
<thead><tr><th>Команда memcached</th><th>DML или DDL</th></tr></thead>
<tbody><tr><td><code>get</code></td><td>Команда чтения</td></tr>
<tr><td><code>set</code></td><td>Поиск, сопровождаемый <code>INSERT</code>
или <code>UPDATE</code> (в зависимости от того, существует ли ключ)</td></tr>
<tr><td><code>add</code></td><td>Поиск, сопровождаемый <code>INSERT</code>
или <code>UPDATE</code></td></tr>
<tr><td><code>replace</code></td><td>Поиск, сопровождаемый
<code>UPDATE</code></td></tr>
<tr><td><code>append</code></td><td>Поиск, сопровождаемый
<code>UPDATE</code> (добавляет данные к результату прежде
<code>UPDATE</code>)</td></tr>
<tr><td><code>prepend</code></td><td>Поиск, сопровождаемый
<code>UPDATE</code> (добавляет данные к результату прежде
<code>UPDATE</code>)</td></tr>
<tr><td><code>incr</code></td><td>Поиск, сопровождаемый
<code>UPDATE</code></td></tr>
<tr><td><code>decr</code></td><td>Поиск, сопровождаемый
<code>UPDATE</code></td></tr>
<tr><td><code>delete</code></td><td>Поиск, сопровождаемый
<code>DELETE</code></td></tr>
<tr><td><code>flush_all</code></td><td><code>TRUNCATE TABLE</code> (DDL)</td>
</tr></tbody></table>

<h4><a name="innodb-memcached-config-tables"></a>
Таблицы конфигурации InnoDB memcached</h4>
<p>Этот раздел описывает таблицы конфигурации, используемые
<code>daemon_memcached</code>. Таблицы <code>cache_policies</code>,
<code>config_options</code> и <code>containers</code> составлены
скриптом <code>innodb_memcached_config.sql</code> в базе
данных <code>innodb_memcache</code>.
<pre>
mysql&gt; USE innodb_memcache;
Database changed
mysql&gt; SHOW TABLES;
+---------------------------+
| Tables_in_innodb_memcache |
+---------------------------+
| cache_policies            |
| config_options            |
| containers                |
+---------------------------+
</pre>

<h4><a name="innodb-memcached-cache-policies-table"></a>Таблица
cache_policies</h4>
<p>Таблица <code>cache_policies</code> определяет политику кэша для
<code>InnoDB</code> <code>memcached</code>. Вы можете определить отдельную
политику для <code>get</code>, <code>set</code>, <code>delete</code> и
<code>flush</code> в пределах единственной политики кэша. Настройка по
умолчанию для всех операций <code>innodb_only</code>.</p>

<ul><li><p><code>innodb_only</code>: Использовать <code>InnoDB</code>
как хранилище данных.</li>
<li><code>cache-only</code>: Использовать
<span><strong>memcached</strong></span> как хранилище данных.</li>

<li><code>caching</code>: Использовать <code>InnoDB</code> и
<span><strong>memcached</strong></span> как хранилище данных.
В этом случае, если <span><strong>memcached</strong></span> не
может найти ключ в памяти, он ищет значение в <code>InnoDB</code>.</li>
<li><code>disable</code>: Отключить кэширование.</p></li></ul>

<a name="idm139965314497536"></a><p><b>Таблица 16.14. Столбцы cache_policies
</b></p>
<table border="1">
<thead><tr><th>Столбец</th><th>Описание</th></tr></thead>
<tbody><tr><td><code>policy_name</code></td><td>
Название политики кэша. Значение по умолчанию
<code>cache_policy</code>.</td></tr>
<tr><td><code>get_policy</code></td><td>Политика кэша для операции
get. Допустимые значения <code>innodb_only</code>, <code>cache-only</code>,
<code>caching</code> или <code>disabled</code>. Значение по умолчанию
<code>innodb_only</code>.</td></tr>

<tr><td><code>set_policy</code></td><td>
Политика кэша для операции set. Допустимые значения
<code>innodb_only</code>, <code>cache-only</code>,
<code>caching</code> или <code>disabled</code>. Значение по умолчанию
<code>innodb_only</code>.</td></tr>

<tr><td><code>delete_policy</code></td><td>
Политика кэша для операции delete. Допустимые значения
<code>innodb_only</code>, <code>cache-only</code>,
<code>caching</code> или <code>disabled</code>. Значение по умолчанию
<code>innodb_only</code>.</td></tr>

<tr><td><code>flush_policy</code></td><td>
Политика кэша для операции flush. Допустимые значения
<code>innodb_only</code>, <code>cache-only</code>,
<code>caching</code> или <code>disabled</code>. Значение по умолчанию
<code>innodb_only</code>.</td></tr></tbody></table>

<h4><a name="innodb-memcached-config-options-table"></a>
Таблица config_options</h4>
<p>Таблица <code>config_options</code> хранит настройки
<span><strong>memcached</strong></span>, которые могут быть изменены во
время выполнения, используя SQL. Поддержанные параметры конфигурации
<code>separator</code> и <code>table_map_delimiter</code>.</p>

<a name="idm139965314463840"></a><p><b>Таблица 16.15. Столбцы config_options
</b></p>
<table border="1">
<thead><tr><th>Столбец</th><th>Описание</th></tr></thead>
<tbody><tr><td><code>Name</code></td><td>
Название опции <span><strong>memcached</strong></span>. Следующие параметры
конфигурации поддержаны в таблице <code>config_options</code>:

<ul><li><p><code>separator</code>: Используется, чтобы разделить значения
длинной строки на отдельные значения, когда там много значений
<code>value_columns</code>. По умолчанию <code>separator</code> символ
<code>|</code>. Например, если Вы определяете <code>col1, col2</code>
как столбцы значений, и Вы определяете <code>|</code>
как разделитель, Вы можете выпустить следующую команду
<span><strong>memcached</strong></span>, чтобы вставить значения в
<code>col1</code> и <code>col2</code>:
<pre>
set keyx 10 0 19
valuecolx|valuecoly
</pre>
<p><code>valuecol1x</code> сохранен в <code>col1</code>, а
<code>valuecoly</code> сохранен в <code>col2</code>.</li>

<li><code>table_map_delimiter</code>: Символ, отделяющий имя схемы и имя
таблицы, когда Вы используете формат <code>@@</code>, чтобы получить доступ к
ключу в определенной таблице. Например,
<code>@@t1.some_key</code> и <code>@@t2.some_key</code>
имеют то же самое значение ключа, но сохранены в различных таблицах.
</p></li></ul></td></tr>

<tr><td><code>Value</code></td>
<td>Значение опции <span><strong>memcached</strong></span>.
</td></tr></tbody></table>

<h4><a name="innodb-memcached-containers-table"></a>Таблица containers</h4>
<p>Таблица <code>containers</code> является самой важной из трех таблиц
конфигурации. Каждая таблица <code>InnoDB</code>, которая используется, чтобы
сохранить значения <span><strong>memcached</strong></span> должна иметь
запись в таблице <code>containers</code>. Запись обеспечивает отображение
между столбцом таблицы <code>InnoDB</code> и столбцами таблицы container,
которые требуются для работы <code>memcached</code> с <code>InnoDB</code>.</p>

<p>Таблица <code>containers</code> содержит запись по умолчанию для
<code>test.demo_test</code>, которая составлена скриптом
<code>innodb_memcached_config.sql</code>. Чтобы использовать плагин
<code>daemon_memcached</code> с Вашей собственной таблицей
<code>InnoDB</code>, Вы должны создать запись в <code>containers</code>.</p>

<p><b>Таблица 16.16. Столбцы containers</b></p>
<table border="1">
<thead><tr><th>Столбец</th><th>Описание</th></tr></thead>
<tbody><tr><td><code>name</code></td>
<td>Имя, данное контейнеру. Если таблица <code>InnoDB</code>
не требуется по имени, используя форму <code>@@</code>, плагин
<code>daemon_memcached</code> применяет таблицу <code>InnoDB</code> с
<code>containers.name</code> = <code>default</code>.
Если нет такой записи, применяется первая запись в <code>containers</code>,
упорядоченная в алфавитном порядке по <code>name</code>, определяющая
таблицу <code>InnoDB</code> по умолчанию.</td></tr>

<tr><td><code>db_schema</code></td><td>Название базы данных, где находится
таблица <code>InnoDB</code>. Это необходимое значение.</td></tr>
<tr><td><code>db_table</code></td><td>Название таблицы <code>InnoDB</code>,
которая хранит значения <span><strong>memcached</strong></span>.
Это необходимое значение.</td></tr>

<tr><td><code>key_columns</code></td><td>Столбец в таблице
<code>InnoDB</code>, которая содержит значения ключа поиска для
<span><strong>memcached</strong></span>. Это необходимое значение.</td></tr>

<tr><td><code>value_columns</code></td><td>Столбцы (один или больше)
таблицы <code>InnoDB</code> для хранения данных <code>memcached</code>.
Много столбцов может быть определено, используя символ разделителя,
определенный в <code>innodb_memcached.config_options</code>.
По умолчанию разделитель это символ канала (<span><span>|</span></span>).
Чтобы определить много столбцов, отделите их определенным символом
разделителя. Например: <code>col1|col2|col3</code>.
Это необходимое значение.</td></tr>

<tr><td><code>flags</code></td><td>Столбцы таблицы <code>InnoDB</code>,
которые используются в качестве флагов (определяемое пользователем числовое
значение, которое сохранено и получено наряду с основным значением) для
<span><strong>memcached</strong></span>. Значение флага может использоваться
в качестве спецификатора столбца для некоторых операций (таких, как
<code>incr</code>, <code>prepend</code>), если значение
<span><strong>memcached</strong></span> отображено на много столбцов, чтобы
работа была выполнена на указанном столбце. Например, если Вы отобразили
<code>value_columns</code> на три столбца <code>InnoDB</code>,
и надо увеличить только один столбце, используют <code>flags</code>, чтобы
определить столбец. Если Вы не используете <code>flags</code>, задайте
значение <code>0</code>, чтобы указать, что это не использовано.</td></tr>

<tr><td><code>cas_column</code></td><td>Столбец таблицы, который хранит
значение compare-and-swap (cas). <code>cas_column</code> связано с путем,
которым <span><strong>memcached</strong></span> обращается
к различным серверам и данным о кэшах в памяти. Поскольку
<span><strong>memcached</strong></span> плотно объединен с единственным
сервером <span><strong>memcached</strong></span>,
механизм кэширования в памяти обработан MySQL и
<a href="glossary.htm#glos_buffer_pool">буферным пулом</a>,
этот столбец редко необходим. Если Вы не используете этот столбец, установите
значение <code>0</code>, чтобы указать, что это не использовано.</td></tr>

<tr><td><code>expire_time_column</code></td><td>Столбец таблицы, который
хранит значение истечения. <code>expire_time_column</code> связано с путем,
которым <span><strong>memcached</strong></span> обращается
к различным серверам и данным о кэшах в памяти. Поскольку
<span><strong>memcached</strong></span> плотно объединен с единственным
сервером <span><strong>memcached</strong></span>,
механизм кэширования в памяти обработан MySQL и
<a href="glossary.htm#glos_buffer_pool">буферным пулом</a>, этот столбец
редко необходим. Если Вы не используете этот столбец, установите
значение <code>0</code>, чтобы указать, что это не использовано. Максимум
определен как <code>INT_MAX32</code> или 2147483647 секунд.</td></tr>

<tr><td><code>unique_idx_name_on_key</code></td><td>
Название индекса на ключевом столбце. Это должно быть уникальным индексом.
Это может быть <a href="glossary.htm#glos_primary_key">primary key</a> или
<a href="glossary.htm#glos_secondary_index">вторичным индексом</a>.
Предпочтительно используйте первичный ключ таблицы <code>InnoDB</code>.
Использование первичного ключа избегает поиска, который выполнен, когда
используется вторичный индекс. Вы не можете создать
<a href="glossary.htm#glos_covering_index">покрывающий индекс</a>
для поисков в <span><strong>memcached</strong></span>: <code>InnoDB</code>
возвращает ошибку, если Вы пытаетесь определить композитный вторичный индекс
по ключам и по столбцам значений.</td></tr></tbody></table>

<h5><a name="idm139965314364192"></a>Ограничения столбца таблицы containers
</h5>
<ul><li><p>Вы должны поставлять значение для <code>db_schema</code>,
<code>db_name</code>, <code>key_columns</code>, <code>value_columns</code> и
<code>unique_idx_name_on_key</code>. Определите <code>0</code> для
<code>flags</code>, <code>cas_column</code> и <code>expire_time_column
</code>, если они не использованы.</li>

<li><code>key_columns</code>: Максимальный предел для ключа
<span><strong>memcached</strong></span> 250 символов, который проведен в
жизнь <span><strong>memcached</strong></span>. Отображенный ключ должен быть
не-Null <a href="types.htm#char"><code>CHAR</code></a> или
<a href="types.htm#char"><code>VARCHAR</code></a>.</li>

<li><code>value_columns</code>: Должен быть отображен на
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>.
Нет никакого ограничения длины, и значение может быть NULL.</li>

<li><code>cas_column</code>: <code>cas</code> это
целое число на 64 бита. Это должно быть отображено на
<a href="types.htm#integer-types"><code>BIGINT</code></a>
по крайней мере из 8 байтов. Если Вы не используете этот столбец, установите
значение <code>0</code>, чтобы указать, что это не использовано.</li>

<li><code>expiration_time_column</code>: Должен быть отображен на
<a href="types.htm#integer-types"><code>INTEGER</code></a>
по крайней мере из 4 байтов. Время истечения срока определено как 32-битовое
целое число в течение времени Unix (число секунд с 1 января 1970 как
32-битовое значение), или число секунд с текущего времени. Для последнего
число секунд, возможно, не превышает 60*60*24*30 (число секунд через 30
дней). Если число, посланное клиентом, больше, сервер полагает, что это
реальное значение времени Unix, а не смещение с текущего времени. Если Вы не
используете этот столбец, установите значение <code>0</code>, чтобы указать,
что это не использовано.</li>

<li><code>flags</code>: Должен быть отображен на
<a href="types.htm#integer-types"><code>INTEGER</code></a>
по крайней мере из 32 битов и может быть NULL.
Если Вы не используете этот столбец, установите значение <code>0</code>,
чтобы указать, что это не использовано.</p></li></ul>

<p>Предварительная проверка выполнена во время загрузки, чтобы провести в
жизнь ограничения столбца. Если несоответствия будут найдены, то плагин
не будет загружаться.</p>

<h5><a name="idm139965314332576"></a>Отображение значений нескольких cтолбцов
</h5>
<ul><li><p>Во время инициализации, когда <code>InnoDB</code>
<span><strong>memcached</strong></span>
сконфигурирован с информацией, определенной в <code>containers</code>,
каждый отображенный столбец, определенный в
<code>containers.value_columns</code>, проверен для отображения в
<code>InnoDB</code>. Если несколько столбцов <code>InnoDB</code>
отображены, есть проверка, чтобы гарантировать, что каждый столбец
существует с правильным типом.</li>

<li>Во время выполнения для операций <code>memcached</code>, если есть больше
значений, чем число отображенных столбцов, только число отображенных значений
взято. Например, если есть шесть отображенных столбцов и семь разграниченных
значений обеспечены, только первые шесть разграниченных значений взяты.
Седьмое значение проигнорировано.</li>

<li>Если есть меньше разграниченных значений, чем отображено столбцов,
незаполненные столбцы установлены в NULL. Если незаполненный столбец не может
быть установлен в NULL, вставка провалится.</li>
<li>Если у таблицы есть больше столбцов, чем отображено значений,
дополнительные столбцы не затрагивают результаты.</p></li></ul>

<h4><a name="innodb-memcached-demo-test-table"></a>
Пример таблицы demo_test</h4>
<p>Скрипт <code>innodb_memcached_config.sql</code> создает таблицу
<code>demo_test</code> в базе данных <code>test</code>,
которая может использоваться, чтобы проверить
<span><strong>memcached</strong></span> немедленно после установки.</p>

<p>Скрипт <code>innodb_memcached_config.sql</code>
также создает запись для таблицы <code>demo_test</code> в
<code>innodb_memcache.containers</code>.
<pre>
mysql&gt; SELECT * FROM innodb_memcache.containers\G
*************************** 1. row ***************************
name: aaa
   db_schema: test
db_table: demo_test
 key_columns: c1
 value_columns: c2
   flags: c3
  cas_column: c4
expire_time_column: c5
unique_idx_name_on_key: PRIMARY

mysql&gt; SELECT * FROM test.demo_test;
+----+--------------+----+----+----+
| c1 | c2           | c3 | c4 | c5 |
+----+--------------+----+----+----+
| AA | HELLO, HELLO | 8  | 0  | 0  |
+----+--------------+----+----+----+
</pre>

<h3><a name="innodb-memcached-troubleshoot"></a>16.19.9.
Проблемы с InnoDB memcached</h3>
<p>Этот раздел описывает проблемы, с которыми Вы можете столкнуться,
используя <code>InnoDB</code> <span><strong>memcached</strong></span>.</p>

<ul><li><p>Если Вы сталкиваетесь со следующей ошибкой в журнале ошибок MySQL,
сервер может быть не в состоянии запуститься:</p>
<p><span>failed to set rlimit for open files. Try running as
root or requesting smaller maxconns value.</span></p>

<p>Сообщение об ошибке от <span><strong>memcached</strong></span>.
Одно решение состоит в том, чтобы поднять предел OS для числа открытых
файлов. Команды для проверки и увеличения предела файла зависят от ОС.
Этот пример показывает команды для Linux и OS X:
<pre>
# Linux
shell&gt; ulimit -n
1024
shell&gt; ulimit -n 4096
shell&gt; ulimit -n
4096

# OS X
shell&gt; ulimit -n
256
shell&gt; ulimit -n 4096
shell&gt; ulimit -n
4096
</pre>

<p>Другое решение состоит в том, чтобы сократить количество параллельных
соединений, разрешенных для <span><strong>memcached</strong></span>.
Чтобы сделать так, закодируйте опцию <code>-c</code>
<span><strong>memcached</strong></span> в параметре
<a href="#sysvar_daemon_memcached_option"><code>
daemon_memcached_option</code></a> в конфигурационном файле MySQL.
Значение по умолчанию 1024.
<pre>
[mysqld]
...
loose-daemon_memcached_option='-c 64'
</pre></li>

<li>Расследовать проблемы, где <span><strong>memcached</strong></span>
не способен сохранить или получить данные таблиц <code>InnoDB</code> удобно,
задав опцию <code>-vvv</code> <span><strong>memcached</strong></span> в
параметре <a href="#sysvar_daemon_memcached_option"><code>
daemon_memcached_option</code></a> в конфигурационном файле MySQL.
Исследуйте журнал ошибок MySQL на вывод отладки, связанный с
<span><strong>memcached</strong></span>.
<pre>
[mysqld]
...
loose-daemon_memcached_option='-vvv'
</pre></li>

<li>Если столбцы, определенные, чтобы держать значения
<span><strong>memcached</strong></span>, будут с неправильным типом данных,
например, числовой тип вместо строкового типа, то попытки сохранить пары
ключа/значения потерпят неудачу без определенного кода ошибки или сообщения.
</li>

<li>Если плагин <code>daemon_memcached</code>
вызывает проблемы запуска сервера MySQL, Вы можете временно отключить
<code>daemon_memcached</code>, добавляя эту строку в группу
<code>[mysqld]</code> в конфигурационном файле MySQL:
<pre>
daemon_memcached=OFF
</pre>

<p>Например, если Вы запускаете <a href="sql.htm#install-plugin"><code>
INSTALL PLUGIN</code></a> прежде, чем вызвать скрипт
<code>innodb_memcached_config.sql</code>, чтобы настроить необходимую базу
данных и таблицы, сервер мог быть не в состоянии запуститься.
Сервер мог также быть не в состоянии запуститься, если Вы неправильно
конфигурируете запись в <code>innodb_memcache.containers</code>.</p>

<p>Чтобы удалить плагин <span><strong>memcached</strong></span>,
сделайте следующее запрос:
<pre>
mysql&gt; UNINSTALL PLUGIN daemon_memcached;
</pre></li>

<li>Если Вы выполняете больше, чем один сервер MySQL на той же самой машине с
<code>daemon_memcached</code> в каждом случае, используйте
<a href="#sysvar_daemon_memcached_option"><code>
daemon_memcached_option</code></a>, чтобы определить уникальный порт
<span><strong>memcached</strong></span> для каждого
плагина <code>daemon_memcached</code>.</li>

<li>Если запрос SQL не может найти таблицу <code>InnoDB</code>
или не находит данных в таблице, но
<span><strong>memcached</strong></span> API
получает ожидаемые данные, врщможно, пропущена запись для таблицы в
<code>innodb_memcache.containers</code>,
или Вы, возможно, не переключились на правильную таблицу при
<code>get</code> или <code>set</code>, используя формат
<code>@@<em><code>table_id</code></em></code>.
Эта проблема могла также произойти, если Вы изменяете существующую запись в
<code>innodb_memcache.containers</code>, не перезапуская сервер MySQL позже.
Механизм хранения свободной формы достаточно гибок, чтобы сохранить или
получить значение из нескольких столбцов, такое как
<code>col1|col2|col3</code> все еще работает, даже если демон использует
<code>test.demo_test</code>, которая хранит значения в единственном столбце.
</li>

<li>Определяя Вашу собственную таблицу <code>InnoDB</code>
для использования с <code>daemon_memcached</code>,
и столбцы в таблице определены как <code>NOT NULL</code>,
гарантируйте, что значения поставляются для столбцов <code>NOT NULL</code>,
вставляя запись для таблицы в <code>innodb_memcache.containers</code>. Если
<a href="sql.htm#insert"><code>INSERT</code></a> для
<code>innodb_memcache.containers</code>
содержит меньше разграниченных значений, чем есть отображенных столбцов,
незаполненные столбцы установлены в <code>NULL</code>.
Попытка вставить <code>NULL</code> в столбец <code>NOT NULL</code>
вызывает сбой <a href="sql.htm#insert"><code>INSERT</code></a>,
что может только стать очевидным после того, как Вы повторно инициализируете
<code>daemon_memcached</code>, чтобы применить изменения таблицы
<code>innodb_memcache.containers</code>.</li>

<li>Если <code>cas_column</code> и
<code>expire_time_column</code> в таблице
<code>innodb_memcached.containers</code> установлены в <code>NULL</code>,
следующая ошибка будет возвращена, пытаясь загрузить плагин
<span><strong>memcached</strong></span>:
<pre>
InnoDB_Memcached: column 6 in the entry for config table 'containers' in
database 'innodb_memcache' has an invalid NULL value.
</pre>

<p><span><strong>memcached</strong></span> отклоняет использование
<code>NULL</code> в <code>cas_column</code> и
<code>expire_time_column</code>. Установите значение этих столбцов к
<code>0</code>, когда столбцы не использованы.</li>

<li>При увеличении длины ключа и значений <span><strong>memcached</strong>
</span> Вы можете столкнуться с пределами размеров и длины.</p>
<ul><li><p>Когда ключ превышает 250 байтов,
<span><strong>memcached</strong></span> возвращают ошибку. Это в настоящее
время неподвижный предел в пределах <span><strong>memcached</strong></span>.
</li>

<li>С табличными пределами <code>InnoDB</code>
можно столкнуться, если значения превышают 768 байтов, 3072 байта в размере
или половину <a href="#sysvar_innodb_page_size"><code>
innodb_page_size</code></a>. Эти пределы прежде всего применяются, если Вы
намереваетесь создать индекс на столбце значений, чтобы выполнить
производящие отчет запросы на том столбце, используя SQL. См.
<a href="#innodb-restrictions">раздел 16.8.7</a>.</li>
<li>Максимальный размер для комбинации значения ключа составляет 1 MB.
</p></li></ul></li>

<li><p>Если Вы совместно используете конфигурационные файлы на серверах MySQL
различных версий, используя последние параметры конфигурации для
<code>daemon_memcached</code> может вызвать ошибки запуска на более старых
версиях MySQL. Чтобы избежать проблем совместимости, используйте префикс
<code>loose</code> с именами опции. Например, можно использовать
<code>loose-daemon_memcached_option='-c 64'</code> вместо
<code>daemon_memcached_option='-c 64'</code>.</li>

<li>Нет никакого ограничения или регистрации места, чтобы утвердить настройки
набора символов. <span><strong>memcached</strong></span>
хранит и получает ключи и значения в байтах и является поэтому не
чувствительным к набору символов. Однако, Вы должны гарантировать, что
клиент <span><strong>memcached</strong></span>
и таблица MySQL используют тот же самый набор символов.</li>

<li>Соединения <span><strong>memcached</strong></span>
заблокированы на доступ к таблицам, которые содержат индексированный
виртуальный столбец. Доступ к индексированному виртуальному столбцу требует
отзыва к серверу, но у соединения <span><strong>memcached</strong></span>
нет доступа к коду сервера.</p></li></ul>

<h2><a name="innodb-troubleshooting"></a>16.20. Проблемы с InnoDB</h2>
<p>Следующие общие руководящие принципы относятся к поиску
неисправностей <code>InnoDB</code>:</p>

<ul><li><p>Когда работа терпит неудачу, или Вы подозреваете ошибку, см.
журнал ошибок сервера MySQL (см. <a href="server.htm#error-log">раздел 6.4.2
</a>). <a href="error.htm#error-messages-server">Раздел B.3</a>
предоставляет информацию о поиске неисправностей для некоторых из общих
ошибок, с которыми Вы можете столкнуться.</li>

<li>Если отказ связан с <a href="glossary.htm#glos_deadlock">тупиком</a>,
включите опцию <a href="#sysvar_innodb_print_all_deadlocks"><code>
innodb_print_all_deadlocks</code></a>, чтобы детали о каждом тупике
<code>InnoDB</code> выводились в журнал ошибок сервера MySQL.</li>

<li>Если проблема связана со словарем данных, см.
<a href="#innodb-troubleshooting-datadict">раздел 16.20.3</a>.</li>
<li>Расследуя, обычно лучше выполнить сервер MySQL из командной строки, а не
через <a href="programs.htm#mysqld-safe"><span><strong>mysqld_safe</strong>
</span></a> или как службу Windows. Вы можете тогда видеть вывод
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>. В
Windows запустите <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> с опцией <a href="server.htm#option_mysqld_console"><code>
--console</code></a>, чтобы направить вывод к консоли.</li>

<li>Включите <code>InnoDB</code> Monitors, чтобы получить информацию о
проблеме (см. <a href="#innodb-monitors">раздел 16.16</a>).
Если проблема с блокировками, включите Lock Monitor.</p>

<p><code>InnoDB</code> временно включает стандартный
<code>InnoDB</code> Monitor при следующих условиях:</p>
<ul><li><p>Ждет длинный семафор.</li>
<li><code>InnoDB</code> не может найти свободные блоки в буферном пуле.</li>
<li>Более чем 67 % буферного пула заняты блокировки или
адаптивным хешем индекса.</p></li></ul></li>
<li><p>Если Вы подозреваете, что таблица повреждена, выполните
<a href="sql.htm#check-table"><code>CHECK TABLE</code></a>.</p></li></ul>

<h3><a name="error-creating-innodb"></a>16.20.1. Проблемы с InnoDB I/O</h3>
<p>Поиск неисправностей для <code>InnoDB</code> I/O
зависят от того, когда проблема происходит: во время запуска сервера MySQL
или во время нормального функционирования, когда DML или запрос DDL терпят
неудачу из-за проблем на уровне файловой системы.</p>

<h4><a name="idm139965314183072"></a>Проблемы инициализации</h4>
<p>Если что-то идет не так, как надо, когда <code>InnoDB</code>
пытается инициализировать табличное пространство или файлы системного
журнала, удалите все файлы, создаваемые <code>InnoDB</code>: все файлы
<code>ibdata</code> и <code>ib_logfile</code>.
Если Вы уже создали некоторые таблицы <code>InnoDB</code>,
также удалите любые файлы <code>.ibd</code> из каталогов базы данных MySQL.
Тогда попробуйте создание базы данных снова. Для самого легкого поиска
неисправностей, запустите сервер MySQL из командной строки так, чтобы Вы
видели то, что происходит.</p>

<h4><a name="idm139965314176608"></a>Проблемы во время выполнения</h4>
<p>Если <code>InnoDB</code> печатает ошибку операционной системы во время
работы с файлом, обычно у проблемы есть одно из следующих решений:</p>

<ul><li><p>Удостоверьтесь, что каталог файлов с данными и
каталог журналов <code>InnoDB</code> существуют.</li>
<li>Удостоверьтесь, что у <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> есть права доступа, чтобы создать файлы в тех каталогах.
</li>

<li>Удостоверьтесь, что <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> может считать файлы опций
<code>my.cnf</code> или <code>my.ini</code>, чтобы это запустилось с опциями,
которые Вы определили.</li>

<li>Удостоверьтесь, что диск не полон, и Вы не превышаете дисковой квоты.
</li>
<li>Удостоверьтесь, что имена, которые Вы определяете для подкаталогов и
файлов с данными, не сталкиваются.</li>

<li>Перепроверьте синтаксис переменных
<a href="#sysvar_innodb_data_home_dir"><code>innodb_data_home_dir
</code></a> и <a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a>. В частности любое значение <code>MAX</code>
в опции <a href="#sysvar_innodb_data_file_path"><code>
innodb_data_file_path</code></a> это жесткий предел, превышение ограничения
вызывает фатальную ошибку.</p></li></ul>

<h3><a name="forcing-innodb-recovery"></a>16.20.2. Восстановление InnoDB</h3>
<p>Чтобы исследовать повреждение страницы базы данных, Вы могли бы вывести
свои таблицы из базы данных с помощью
<a href="sql.htm#select-into"><code>SELECT ... INTO OUTFILE</code></a>.
Обычно большинство данных, полученных таким образом, не повреждено. Серьезное
повреждение могло бы вызвать
<code>SELECT * FROM <em><code>tbl_name</code></em></code> или фоновые
процессы. В таких случаях Вы можете использовать опцию
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a>, чтобы запустить механизм хранения, препятствуя фоновым работам,
чтобы Вы могли вывести свои таблицы. Например, Вы можете добавить следующую
строку к разделу <code>[mysqld]</code>
Вашего файла опции прежде, чем перезапустить сервер:
<pre>
[mysqld]
innodb_force_recovery = 1
</pre>

<p>Установите <a href="#sysvar_innodb_force_recovery"><code>
innodb_force_recovery</code></a> к значению больше 0 только в чрезвычайной
ситуации, чтобы Вы могли запустить <code>InnoDB</code>
и вывести свои таблицы. Прежде чем сделать так, гарантируйте, что у Вас есть
резервная копия Вашей базы данных в случае, если Вы должны обновить ее.
Значения 4 или больше могут надолго повредить файлы с данными. Используйте
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a> 4 или больше на производственном случае сервера только после
того, как Вы успешно проверили установку на отдельной физической копии Вашей
базы данных. Вызывая восстановление <code>InnoDB</code>, Вы должны всегда
запускать с <a href="#sysvar_innodb_force_recovery"><code>
innodb_force_recovery=1</code></a> и увеличьте значение только
по мере необходимости.</p>

<p><a href="#sysvar_innodb_force_recovery"><code>
innodb_force_recovery</code></a> = 0 по умолчанию (нормальный запуск без
принудительного восстановления). Допустимые ненулевые значения для
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a> от 1 до 6. Большее значение включает функциональность меньших
значений. Например, значение 3 включает всю функциональность значений 1 и 2.
</p>

<p>Если Вы в состоянии вывести свои таблицы с
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a> = 3 или меньше, тогда Вы относительно защищены от того, что
только некоторые данные на поврежденных отдельных страницах потеряны.
Значение 4 или больше считают опасным, потому что файлы с данными могут быть
надолго повреждены. Значение 6 считают решительным, потому что страницы базы
данных оставляют в устаревшем состоянии, которое в свою очередь может ввести
больше повреждений в <a href="glossary.htm#glos_b_tree">B-trees</a>
и другие структуры базы данных.</p>

<p>Как мера по безопасности, <code>InnoDB</code> блокирует
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>, если
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a> больше 0. <a href="#sysvar_innodb_force_recovery">
<code>innodb_force_recovery</code></a> = 4 или выше запускает
<code>InnoDB</code> в режиме только для чтения.</p>

<ul><li><p><code>1</code> (<code>SRV_FORCE_IGNORE_CORRUPT</code>)</p>
<p>Позволяет серверу работать, даже если он обнаруживает поврежденную
<a href="glossary.htm#glos_page">страницу</a>. Попытки сделать
<code>SELECT * FROM <em><code>tbl_name</code></em></code>
перепрыгивают поврежденные записи индекса и страницы, что
помогает в дампе таблиц.</li>

<li><code>2</code> (<code>SRV_FORCE_NO_BACKGROUND</code>)</p>
<p>Предотвращает работу <a href="glossary.htm#glos_master_thread">основного
потока</a> и любых <a href="glossary.htm#glos_purge_thread">потоки чистки
</a>. Если бы катастрофический отказ произошел во время работы
<a href="glossary.htm#glos_purge">чистки</a>, это значение восстановления
предотвращает такую ситуацию.</li>

<li><code>3</code> (<code>SRV_FORCE_NO_TRX_UNDO</code>)</p>
<p>Не выполняет операционные <a href="glossary.htm#glos_rollback">отмены</a>
после <a href="glossary.htm#glos_crash_recovery">
восстановления катастрофического отказа</a>.</li>

<li><code>4</code> (<code>SRV_FORCE_NO_IBUF_MERGE</code>)</p>
<p>Не сливает <a href="glossary.htm#glos_insert_buffer">буферы вставки</a>.
Если они вызвали бы катастрофический отказ, не делает их. Не вычисляет
табличную <a href="glossary.htm#glos_statistics">статистику</a>.
Это значение может надолго повредить файлы с данными. После использования
этого значения будьте готовы удалить и обновить все вторичные индексы.
Переключает <code>InnoDB</code> в режим только для чтения.</li>

<li><code>5</code> (<code>SRV_FORCE_NO_UNDO_LOG_SCAN</code>)</p>
<p>Не смотрит <a href="glossary.htm#glos_undo_log">журналы отмены</a>,
запуская базу данных: <code>InnoDB</code> обработает даже неполные
транзакции как передано. Это значение может надолго повредить файлы с
данными. Переключает <code>InnoDB</code> в режим только для чтения.</li>

<li><code>6</code> (<code>SRV_FORCE_NO_LOG_REDO</code>)</p>
<p>Не делает накат <a href="glossary.htm#glos_redo_log">журналов redo</a>
в соединении с восстановлением. Это значение может надолго повредить файлы с
данными. Страницы базы данных листьев в устаревшем статусе, который в свою
очередь может ввести больше повреждения в B-деревья и другие структуры базы
данных. Переключает <code>InnoDB</code> в режим только для чтения.</li></ul>

<p>Вы можете <a href="sql.htm#select"><code>SELECT</code></a>
из таблиц, чтобы вывести их. С
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a> = 3 или меньше Вы можете выполнить для таблиц <code>DROP</code>
или <code>CREATE</code>. <a href="sql.htm#drop-table"><code>DROP TABLE</code>
</a> также поддержан с <a href="#sysvar_innodb_force_recovery">
<code>innodb_force_recovery</code></a> больше 3.</p>

<p>Если Вы знаете, что данная таблица вызывает катастрофический отказ на
отмене, Вы можете удалить это. Если Вы сталкиваетесь с безудержной отменой,
вызванной отменом массового импорта или
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
Вы можете уничтожить процесс <a href="programs.htm#mysqld"><span><strong>
mysqld</strong></span></a> и установить
<a href="#sysvar_innodb_force_recovery"><code>innodb_force_recovery
</code></a> = <code>3</code>, поднять базу данных без отмены, а затем
<code>DROP</code> таблицу, которая вызывает безудержную отмену.</p>

<p>Если повреждение в пределах табличных данных препятствует тому, чтобы Вы
вывели все табличное содержание, запрос c <code>ORDER BY
<em><code>primary_key</code></em> DESC</code>
может быть в состоянии вывести часть таблицы после поврежденной части.</p>

<p>Если верхний уровень <a href="#sysvar_innodb_force_recovery">
<code>innodb_force_recovery</code></a> нужен для запуска
<code>InnoDB</code>, могут быть поврежденные структуры данных, которые могли
вызвать сбои сложных запросов (запросы, содержащие <code>WHERE</code>,
<code>ORDER BY</code> или нечто подобное). В этом случае Вы можете быть в
состоянии использовать только обычные запросы <code>SELECT * FROM t</code>.
</p>

<h3><a name="innodb-troubleshooting-datadict"></a>16.20.3.
Проблемы словаря данных InnoDB</h3>
<p>Информация о табличных определениях хранится в
<a href="glossary.htm#glos_data_dictionary">словаре данных</a> InnoDB.
Если Вы перемещаете файлы с данными, или если катастрофический отказ сервера
был в середине работы со словарем данных, данные словаря
могут стать непоследовательными.</p>

<p>Если повреждение словаря данных или проблема последовательности
препятствуют тому, чтобы Вы запустили <code>InnoDB</code>, см.
<a href="#forcing-innodb-recovery">раздел 16.20.2</a>.</p>

<h4><a name="innodb-cannot-open-file-error"></a>Не может открыть файл данных
</h4>
<p>При включении <a href="#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a> (значение по умолчанию), следующие
сообщения могут появиться при запуске если файл табличного пространства
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
(файл <code>.ibd</code>) отсутствует:
<pre>
[ERROR] InnoDB: Operating system error number 2 in a file operation.
[ERROR] InnoDB: The error means the system cannot find the path specified.
[ERROR] InnoDB: Cannot open datafile for read-only: './test/t1.ibd' OS error: 71
[Warning] InnoDB: Ignoring tablespace `test/t1` because it could not be opened.
</pre>
<p>Используйте запрос <a href="sql.htm#drop-table"><code>DROP TABLE</code>
</a>, чтобы удалить данные о недостающей таблице из словаря данных.</p>

<h4><a name="restoring-orphaned-idb-files"></a>Восстановление висячей строки
файлов File-Per-Table ibd</h4>
<p>Эта процедура описывает, как восстановить висячие строки
в файлах <a href="glossary.htm#glos_file_per_table">file-per-table</a>
<code>.ibd</code> к другому случаю MySQL. Вы могли бы использовать эту
процедуру, если системное табличное пространство потеряно или неисправимо, и
Вы хотите восстановить копию <code>.idb</code> на новом сервере MySQL.</p>

<p>Процедура не поддержана для файлов <code>.ibd</code>
<a href="glossary.htm#glos_general_tablespace">
общего табличного пространства</a>.</p>

<p>Процедура предполагает, что Вы имеете только резервные копии файла
<code>.ibd</code> и восстанавливаете к той же самой версии MySQL, которая
первоначально создала файлы. См.
<a href="#innodb-migration">раздел 16.8.3</a>
для информации о создании чистых резервных копий.</p>

<p>Ограничения копирования табличного пространства, обрисованные в общих
чертах в <a href="#tablespace-copying">разделе 16.7.6</a>,
применимы к этой процедуре.</p>

<ol type="1"><li><p>На новом случае MySQL, создайте таблицу в базе данных
с тем же самым именем.
<pre>
mysql&gt; CREATE DATABASE sakila;
mysql&gt; USE sakila;
mysql&gt; CREATE TABLE actor (
    -&gt;        actor_id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
    -&gt;        first_name VARCHAR(45) NOT NULL,
    -&gt;        last_name VARCHAR(45) NOT NULL,
    -&gt;        last_update TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
    -&gt;        ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (actor_id),
    -&gt;        KEY idx_actor_last_name (last_name)) ENGINE=InnoDB
    -&gt;        DEFAULT CHARSET=utf8;
</pre></li>

<li>Откажитесь от табличного пространства недавно составленной таблицы.
<pre>
mysql&gt; ALTER TABLE sakila.actor DISCARD TABLESPACE;
</pre></li>

<li>Скопируйте файл <code>.idb</code> из
Вашего резервного каталога в новый каталог базы данных.
<pre>
shell&gt; cp /<code>backup_directory</code>/actor.ibd <em><code>path/to/mysql-5.7/data</code></em>/sakila/
</pre></li>

<li>Гарантируйте, что у файла <code>.ibd</code>
есть необходимые разрешения.</li>
<li>Импортируйте файл <code>.ibd</code>. Предупреждение выпущено, указывая,
что <code>InnoDB</code> попытается импортировать файл без проверки схемы.
<pre>
mysql&gt; ALTER TABLE sakila.actor IMPORT TABLESPACE; SHOW WARNINGS;
Query OK, 0 rows affected, 1 warning (0.15 sec)

Warning | 1810 | InnoDB: IO Read error: (2, No such file or directory)
Error opening './sakila/actor.cfg', will attempt to import
without schema verification
</pre></li>

<li>Запросите таблицу, чтобы проверить, что файл <code>.ibd</code>
был успешно восстановлен.
<pre>
mysql&gt; SELECT COUNT(*) FROM sakila.actor;
+----------+
| count(*) |
+----------+
|  200     |
+----------+
</pre></li></ol>

<h3><a name="innodb-error-handling"></a>16.20.4. Обработка ошибок InnoDB</h3>
<p>Следующие элементы описывают, как <code>InnoDB</code>
выполняет обработку ошибок. <code>InnoDB</code> иногда откатывает
только запрос, который потерпел неудачу, в других ситуациях
откатывает всю транзакцию.</p>

<ul><li><p>Если Вы исчерпываете пространство файла, происходит ошибка
<code>Table is full</code>, <code>InnoDB</code> откатывает запрос SQL.</li>
<li>Операционный <a href="glossary.htm#glos_deadlock">тупик</a>
вызывает <a href="glossary.htm#glos_rollback">откат</a> всей
<a href="glossary.htm#glos_transaction">транзакции</a>.
Повторите транзакцию, когда это происходит.</p>

<p>Блокировка тайм-аута откатывает только единственный запрос,
который ждал блокировки и столкнулся с тайм-аутом. Чтобы откатить всю
транзакцию, запускают сервер с опцией
<a href="#sysvar_innodb_rollback_on_timeout"><code>
--innodb_rollback_on_timeout</code></a>.
Повторите запрос, используя текущее поведение, или всю транзакцию, если
используется <a href="#sysvar_innodb_rollback_on_timeout"><code>
--innodb_rollback_on_timeout</code></a>.</p>

<p>Тупики и тайм-ауты нормальны на занятых серверах, и приложению необходимо
знать, что они могут произойти и обработать их, повторяя. Вы можете сделать
их менее вероятными, делая настолько маленькую работу, насколько возможно,
между первым изменением данных во время транзакции и передачей, таким
образом, блокировки проводятся в течение самого короткого времени и для
самого маленького числа строк. Иногда разделение работы между различными
транзакциями может быть практичным и полезным.</p>

<p>Когда операционная отмена происходит из-за тупика или тайм-аута
блокировки, это отменяет эффект запросов в пределах транзакции. Но если
запросом запуска транзакции был
<a href="sql.htm#commit"><code>START TRANSACTION</code></a> или
<a href="sql.htm#commit"><code>BEGIN</code></a>,
отмена не отменяет этот запрос. Далее запросы SQL становятся частью
транзакции до возникновения <a href="sql.htm#commit"><code>COMMIT</code></a>,
<a href="sql.htm#commit"><code>ROLLBACK</code></a> или некоторого запроса
SQL, который вызывает неявное закрытие транзакции.</li>

<li>Ошибка дублирования ключа откатывает запрос SQL, если Вы не определили
в нем опцию <code>IGNORE</code>.</li>
<li><code>row too long error</code> откатывает запрос SQL.</li>

<li>Другие ошибки главным образом обнаружены уровнем кода MySQL (выше
уровня механизма хранения <code>InnoDB</code>), они откатывают
соответствующий запрос SQL. Блокировки не выпущены при отмене
единственного запроса SQL.</p></li></ul>

<p>Во время неявных отмен, так же как во время выполнения явного
<a href="sql.htm#commit"><code>ROLLBACK</code></a>,
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
показывает <code>Rolling back</code> в столбце <code>State</code>
для соответствующего соединения.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
