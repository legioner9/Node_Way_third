<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 9. Оптимизация</title>
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="optimization"></a>Глава 9. Оптимизация</h1>
<p>Эта глава объясняет, как оптимизировать работу MySQL и обеспечивает
примеры. Оптимизация вовлекает конфигурирование, настройку и определение
эксплуатационных качеств на нескольких уровнях. В зависимости от Вашей роли
(разработчик, DBA или комбинация обоих), Вы могли бы оптимизировать на уровне
отдельных запросов SQL, всех приложений, единственного сервера базы данных
или многих сетевых серверов базы данных. Иногда Вы можете запланировать
заранее работу в то время, как в других случаях Вы могли бы расследовать
конфигурацию или кодировать проблему после того, как проблема происходит.
Оптимизация центрального процессора и использования памяти может также
улучшить масштабируемость, позволяя базе данных обработать большие
нагрузки без замедления.</p>

<h2><a name="optimize-overview"></a>9.1. Краткий обзор оптимизации</h2>
<p>Работа базы данных зависит от нескольких факторов на уровне базы данных,
таких как таблицы, запросы и настройки конфигурации. Это результат
конструкций программного обеспечения в центральном процессоре и операциях
ввода/вывода на уровне аппаратных средств, который Вы должны минимизировать и
сделать настолько эффективным, насколько возможно. Поскольку Вы работаете над
работой базы данных, Вы начинаете, изучая высокоуровневые правила и
направляющие линии для стороны программного обеспечения, и измеряя работу,
используя время. По мере того, как Вы становитесь экспертом, Вы узнаете
больше о том, что происходит внутренне, и начинаете измерять вещи, такие как
циклы центрального процессора и операции ввода/вывода.</p>

<p>Типичные пользователи стремятся вытаскивать лучшую работу базы данных из
своих существующих конфигураций программного и аппаратного обеспечения.
Усовершенствованные пользователи ищут возможности улучшить программное
обеспечение MySQL непосредственно или развить их собственные механизмы
хранения и аппаратные средства, чтобы расширить экосистему MySQL.</p>

<h3><a name="idm139965374673680"></a>Оптимизация на уровне базы данных</h3>
<p>Наиболее важным фактором в создании приложения базы данных
является базовая конструкция:</p>

<ul><li><p>Таблицы структурированы должным образом? В частности, у столбцов
есть правильные типы данных, и действительно каждая таблица имеет
соответствующие столбцы для типа работы? Например, у приложений, которые
выполняют частые обновления, есть много таблиц с малым числом столбцов в то
время, как у приложений, которые анализируют большие объемы данных, есть
немного таблиц со многими столбцами.</li>

<li>Правильные индексы сделают запросы эффективными.</li>
<li>Вы используете соответствующий механизм хранения для каждой таблицы,
и используете в своих интересах силы и особенности каждого механизма
хранения, который Вы используете? В частности, выбор такого механизма
хранения, как <code><a href="#optimizing-innodb">InnoDB</a>
</code> или <code><a href="#optimizing-myisam">MyISAM</a></code>
может быть очень важным для работы и масштабируемости.</p>

<p><code>InnoDB</code> механизм хранения по умолчанию для новых таблиц.
Практически, усовершенствованные технические характеристики означают, что
таблицы <code>InnoDB</code> часто выигрывают у более простого
<code>MyISAM</code>, специально для занятой базы данных.</p></li>

<li>Каждая таблица использует соответствующий формат строки? Этот выбор также
зависит от механизма хранения, используемого для таблицы. В частности, сжатые
таблицы используют меньше дискового пространства и требуют меньше дискового
ввода/вывода. Сжатие доступно для всех видов рабочих нагрузок с
<code>InnoDB</code> и <code>MyISAM</code> только для чтения.</li>

<li>Приложение использует соответствующую
<a href="#locking-issues">стратегию блокировки</a>?
Например, позволяя совместный доступ, когда возможно, чтобы операции базы
данных могли работать одновременно, и требуя эксклюзивного доступа, когда
надо, чтобы критические операции получили высший приоритет. Снова выбор
механизма хранения является существенным. <code>InnoDB</code> обрабатывает
большинство проблем блокировки без Вашего участия, ведет учет лучшего
параллелизма в базе данных и сокращает количество экспериментирования и
настройки для Вашего кода.</li>

<li>Все <a href="#buffering-caching">области памяти для кэшей
</a> измерены правильно? Они должны быть достаточно большими, чтобы содержать
нужные данные, но не настолько большими, чтобы перегружали физическую память.
Основные области памяти, чтобы сконфигурировать буферный пул
<code>InnoDB</code>, кэш ключей <code>MyISAM</code> и кэш запросов MySQL.
</p></li></ul>

<h3><a name="idm139965374652144"></a>Оптимизация на уровне аппаратных средств
</h3>
<p>Любое приложение базы данных в конечном счете упирается в пределы
аппаратных средств, поскольку база данных становится более занятой. DBA
должен оценить, возможно ли настроить приложение или реконфигурировать
сервер, чтобы избежать этих проблем или требуется больше ресурсов аппаратных
средств. Системные узкие места, как правило, являются
результатом этих источников:</p>

<ul><li><p>Диск поиски. Это занимает время, чтобы найти часть данных. С
современными дисками среднее время для этого обычно ниже 10 миллисекунд,
таким образом, мы можем в теории делать, приблизительно 100 поисков в
секунду. Это время медленно улучшается с новыми дисками и очень трудно
оптимизировать для единственной таблицы. Способ оптимизировать время поиска,
это распределить данные больше, чем на один диск.</li>

<li>Дисковое чтение. Когда диск в правильной позиции, мы должны читать или
писать данные. С современными дисками один диск поставляет, по крайней мере,
10-20 MB/сек. Это легче оптимизировать, чем поиск, потому что Вы можете
читать параллельно с многих дисков.</li>

<li>Циклы центрального процессора. Когда данные находятся в основной памяти,
мы должны обработать это, чтобы получить наш результат. Наличие больших
таблиц по сравнению с объемом памяти является наиболее распространенным
ограничивающим фактором. Но с маленькими таблицами, скорость
обычно не проблема.</li>

<li>Пропускная способность памяти. Когда центральный процессор нуждается в
большем количестве данных, чем может поместиться в кэш центрального
процессора, основная пропускная способность памяти становится узким местом.
Это необычное узкое место для большинства систем, но оно есть.</p></li></ul>

<h3><a name="portability"></a>Балансирование мобильности и работы</h3>
<p>Чтобы использовать ориентируемый на работу на расширения SQL в портируемой
программе MySQL, Вы можете обернуть MySQL-определенные ключевые слова в
запросе в пределах комментария <code>/*! */</code>.
Другие SQL-серверы игнорируют прокомментированные ключевые слова.
Для информации об использовании комментариев см.
<a href="lang.htm#comments">раздел 10.6</a>.</p>

<h2><a name="statement-optimization"></a>9.2.
Оптимизация запросов SQL</h2>
<p>Основная логика приложения базы данных выполнена через запросы SQL.</p>

<h3><a name="select-optimization"></a>9.2.1. Оптимизация SELECT</h3>
<p>Запросы в форме <a href="sql.htm#select"><code>SELECT</code></a>
выполняют все операции поиска в базе данных. Настройка этих запросов
является высшим приоритетом.</p>

<p>Кроме того <code>SELECT</code> также относятся к таким конструкциям, как
<code>CREATE TABLE...AS SELECT</code>, <code>INSERT INTO...SELECT</code> и
<code>WHERE</code> в <a href="sql.htm#delete"><code>DELETE</code></a>.
У этих запросов есть дополнительные исполнительные соображения, потому что
они объединяют операции записи с ориентируемыми на чтение операциями запроса.
</p>

<h4><a name="select-speed"></a>9.2.1.1. Скорость SELECT</h4>
<p>Основные соображения для того, чтобы оптимизировать запросы:</p>
<ul><li><p>Чтобы ускорить <code>SELECT ... WHERE</code>,
первая вещь, которую надо проверить, состоит в том, можете ли Вы добавить
<a href="glossary.htm#glos_index">индекс</a>.
Настроенный индекс на столбцах, используемых в <code>WHERE</code>, нужен,
чтобы ускорить оценку, фильтрацию и заключительное извлечение результатов.
Чтобы избежать потраченного впустую дискового пространства, создайте
маленький набор индексов, которые ускоряют много связанных запросов,
используемых в Вашем приложении.</p>

<p>Индексы особенно важны для запросов, которые обращаются к
различным таблицам, используя функции, такие как
<a href="glossary.htm#glos_join">joins</a> и
<a href="glossary.htm#glos_foreign_key">внешние ключи</a>.
Вы можете использовать <a href="sql.htm#explain"><code>EXPLAIN</code></a>,
чтобы определить, который индекс используется для
<a href="sql.htm#select"><code>SELECT</code></a>. См. разделы
<a href="#mysql-indexes">9.3.1</a> и
<a href="#using-explain">9.8.1</a>.</li>

<li>Изолируйте и настройте любую часть запроса, такую как вызов функции,
которая занимает время. В зависимости от того, как структурирован запрос,
функция могла быть вызвана однажды для каждой строки в наборе результатов
или даже однажды для каждой строки в таблице, очень
увеличивая любую эффективность.</li>

<li>Минимизируйте число <a href="glossary.htm#glos_full_table_scan">полных
сканирований таблицы</a> в Ваших запросах, особенно для больших таблиц.</li>
<li>Усовершенствуйте табличную статистику при использовании
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
периодически, таким образом, оптимизатор получит информацию, чтобы создать
эффективный план выполнения.</li>

<li>Изучите методы настройки и индексирования и параметры конфигурации,
которые являются определенными для механизма хранения для каждой таблицы.
<code>InnoDB</code> и <code>MyISAM</code> имеют наборы
для включения и поддержки высокой производительности в запросах. Для деталей
см. разделы <a href="#optimizing-innodb-queries">9.5.6</a> и
<a href="#optimizing-queries-myisam">9.6.1</a>.</li>

<li>Вы можете оптимизировать транзакции единственного запроса для
<code>InnoDB</code>, используя метод в
<a href="#innodb-performance-ro-txn">разделе 9.5.3</a>.</li>

<li>Избегайте преобразовывать запрос способами, которые делают его трудным в
понимании, особенно если оптимизатор делает некоторые из тех же
самых преобразований автоматически.</li>

<li>Если исполнительная проблема легко не решена одной из основных
направляющих линий, исследуйте внутренние детали определенного запроса, читая
план <a href="sql.htm#explain"><code>EXPLAIN</code></a> и корректируя Ваши
индекс, <code>WHERE</code>, join и т.д. Когда Вы достигаете определенного
уровня экспертизы, чтение плана <a href="sql.htm#explain"><code>EXPLAIN
</code></a> может быть Вашим первым шагом для каждого запроса.</li>

<li>Скорректируйте размер и свойства областей памяти, которые MySQL
использует для того, чтобы кэшировать. С эффективным использованием
<a href="glossary.htm#glos_buffer_pool">буферного пула</a> <code>InnoDB
</code>, кэша ключей <code>MyISAM</code> и кэша запроса MySQL, повторенные
запросы работают быстрее, потому что результаты получены из
памяти в последующие разы.</li>

<li>Даже для запроса, который выполняет быстрое использование областей
кэш-памяти, Вы могли бы все еще оптимизировать далее так, чтобы он требовал
меньшего количества кэш-памяти. Масштабируемость означает, что Ваше
приложение может обработать больше одновременных пользователей, больше
запросов и так далее, не испытывая большое замедление работы.</li>

<li>Разберитесь с проблемой блокировок, где скорость Вашего запроса могла бы
быть затронута другими сеансами, получающими доступ к таблицам в то
же самое время.</p></li></ul>

<h4><a name="where-optimizations"></a>9.2.1.2.
Как MySQL оптимизирует WHERE</h4>
<p>Этот раздел обсуждает оптимизацию, которая может быть сделана для того,
чтобы обработать <code>WHERE</code>. Используем в качестве примера
<a href="sql.htm#select"><code>SELECT</code></a>, но та же самая оптимизация
<code>WHERE</code> работает в <a href="sql.htm#delete"><code>DELETE</code>
</a> и <a href="sql.htm#update"><code>UPDATE</code></a>.</p>

<p>Поскольку работа над оптимизатором MySQL продолжается, не вся оптимизация,
которую выполняет MySQL, зарегистрирована здесь.</p>
<p>Вы могли бы испытать желание переписать свои запросы, чтобы сделать
арифметические операции быстрее, жертвуя удобочитаемостью. Поскольку MySQL
делает подобную оптимизацию автоматически, Вы можете часто избегать этой
работы, и оставлять запрос в более понятной форме.
Часть оптимизации, выполненной MySQL:</p>

<ul><li><p>Удаление ненужных круглых скобок:
<pre>
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&gt; (a AND b AND c) OR (a AND b AND c AND d)
</pre></li>

<li><p>Постоянное сворачивание:
<pre>
   (a&lt;b AND b=c) AND a=5
-&gt; b&gt;5 AND b=c AND a=5
</pre></li>

<li><p>Постоянное удаление условия
(необходимо из-за постоянного сворачивания):
<pre>
   (B&gt;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&gt; B=5 OR B=6
</pre></li>

<li><p>Постоянные выражения, использующие индексы,
оценены только однажды.</li>
<li><a href="funct.htm#function_count"><code>COUNT(*)</code></a>
на единственной таблице без <code>WHERE</code>
получен непосредственно от информации о таблице для <code>MyISAM</code> и
<code>MEMORY</code>. Это также сделано для любого выражения <code>NOT NULL
</code>, когда используется только с одной таблицей.</li>

<li>Раннее обнаружение недопустимых постоянных выражений. MySQL быстро
обнаруживает что некоторые <a href="sql.htm#select"><code>SELECT</code></a>
невозможны и не возвращает строки.</li>

<li><code>HAVING</code> слит с <code>WHERE</code>,
если Вы не используете <code>GROUP BY</code> или совокупные функции
(<a href="funct.htm#function_count"><code>COUNT()</code></a>,
<a href="funct.htm#function_min"><code>MIN()</code></a> и т.д.).</li>

<li>Для каждой таблицы в соединении более простой <code>WHERE</code>
создан, чтобы получить быструю оценку <code>WHERE</code>
для таблицы и пропускать строки как можно скорее.</li>

<li>Все постоянные таблицы считаны сначала перед любыми другими таблицами в
запросе. Постоянная таблица это любое из следующего:</p>
<ul><li><p>Пустая таблица или таблица с одной строкой.</li>

<li>Таблица, которая используется с <code>WHERE</code> в
<code>PRIMARY KEY</code> или индексе <code>UNIQUE</code>,
где все индексные части сравниваются с постоянными выражениями и определены
как <code>NOT NULL</code>.</p></li></ul>

<p>Все следующие таблицы используются в качестве постоянных таблиц:
<pre>
SELECT * FROM t WHERE <em><code>primary_key</code></em>=1;
SELECT * FROM t1,t2 WHERE t1.<em><code>primary_key</code></em>=1 AND
         t2.<em><code>primary_key</code></em>=t1.id;
</pre></li>

<li><p>Лучшая комбинация соединения для того, чтобы присоединиться к таблицам
найдена, пробуя все возможности. Если все столбцы в
<code>ORDER BY</code> и <code>GROUP BY</code>
прибывают из той же самой таблицы, та таблица предпочтена.</li>

<li>Если есть <code>ORDER BY</code> и отличающийся
<code>GROUP BY</code>, или если <code>ORDER BY</code> или <code>GROUP BY
</code> содержит столбцы от таблиц кроме первой таблицы в очереди соединения,
временная таблица составлена.</li>

<li>Если Вы используете опцию <code>SQL_SMALL_RESULT</code>,
MySQL использует временную таблицу в памяти.</li>
<li>Каждый индекс таблицы запрошен, и лучший индекс используется,
если оптимизатор не полагает, что более эффективно использовать сканирование
таблицы. Когда-то просмотр использовался, основываясь на том, индексирует ли
лучший индекс больше 30% таблицы, но неподвижный процент больше не определяет
выбор между использованием индексирования или просмотра. Оптимизатор теперь
более сложен и базирует свою оценку на дополнительных факторах, таких как
табличный размер, число строк и размер блока ввода/вывода.</li>

<li>В некоторых случаях MySQL может считать строки из индекса, даже не
консультируясь с файлом с данными. Если все столбцы, используемые в
индексе, являются числовыми, только индексное дерево используется,
чтобы решить запрос.</li>

<li>Прежде, чем каждая строка выведена, те, которые не
соответствуют <code>HAVING</code> пропущены.</p></li></ul>
<p>Некоторые примеры запросов, которые очень быстры:
<pre>
SELECT COUNT(*) FROM <em><code>tbl_name</code></em>;
SELECT MIN(<em><code>key_part1</code></em>),
       MAX(<em><code>key_part1</code></em>)
       FROM <em><code>tbl_name</code></em>;
SELECT MAX(<em><code>key_part2</code></em>)
       FROM <em><code>tbl_name</code></em>
       WHERE <em><code>key_part1</code></em>=<em><code>constant</code></em>;
SELECT ... FROM <em><code>tbl_name</code></em>
       ORDER BY <em><code>key_part1</code></em>,
       <em><code>key_part2</code></em>,... LIMIT 10;
SELECT ... FROM <em><code>tbl_name</code></em>
       ORDER BY <em><code>key_part1</code></em> DESC,
       <em><code>key_part2</code></em> DESC, ... LIMIT 10;
</pre>

<p>MySQL решает следующие запросы, используя только индексное
дерево, предполагая, что индексированные столбцы являются числовыми:
<pre>
SELECT <em><code>key_part1</code></em>,<em><code>key_part2</code></em>
       FROM <em><code>tbl_name</code></em>
       WHERE <em><code>key_part1</code></em>=<em><code>val</code></em>;
SELECT COUNT(*) FROM <em><code>tbl_name</code></em>
       WHERE <em><code>key_part1</code></em>=<em><code>val1</code></em> AND
       <em><code>key_part2</code></em>=<em><code>val2</code></em>;
SELECT <em><code>key_part2</code></em> FROM <em><code>tbl_name</code></em>
       GROUP BY <em><code>key_part1</code></em>;
</pre>

<p>Следующая индексация использования запросов, чтобы получить строки в
сортированном порядке без отдельного прохода сортировки:
<pre>
SELECT ... FROM <em><code>tbl_name</code></em>
       ORDER BY <em><code>key_part1</code></em>,
       <em><code>key_part2</code></em>,... ;
SELECT ... FROM <em><code>tbl_name</code></em>
       ORDER BY <em><code>key_part1</code></em> DESC,
       <em><code>key_part2</code></em> DESC, ... ;
</pre>

<h4><a name="range-optimization"></a>9.2.1.3. Оптимизация диапазона</h4>
<p>Метод доступа <a href="#jointype_range"><code>диапазона
</code></a> использует один индекс, чтобы получить подмножество строк
таблицы, которые содержатся в пределах одного или нескольких индексных
интервалов. Это может использоваться для единственной или нескольких частей
индекса. Следующие разделы дают описания условий, при которых оптимизатор
использует доступ диапазона.</p>

<h5><a name="range-access-single-part"></a>9.2.1.3.1.
Метод доступа диапазона для единственной части индекса</h5>
<p>Интервалы значения могут быть удобно представлены соответствующими
условиями в <code>WHERE</code>, обозначенный как <span>условия диапазона
</span> вместо <span><span>интервалов</span></span>.</p>

<p>Определение условия диапазона для единственной части индекса:</p>
<ul><li><p>Для индексов <code>BTREE</code> и <code>HASH</code> сравнение
части ключа с постоянной величиной условия диапазона сделано, используя
операторы <a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_equal-to"><code>&lt;=&gt;</code></a>,
<a href="funct.htm#function_in"><code>IN()</code></a>,
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a> или
<a href="funct.htm#operator_is-not-null"><code>IS NOT NULL</code></a>.</li>

<li>Дополнительно для индексов <code>BTREE</code> сравнение
части ключа с постоянной величиной условия диапазона сделано, используя
операторы <a href="funct.htm#operator_greater-than"><code>&gt;</code></a>,
<a href="funct.htm#operator_less-than"><code>&lt;</code></a>,
<a href="funct.htm#operator_greater-than-or-equal"><code>&gt;=</code></a>,
<a href="funct.htm#operator_less-than-or-equal"><code>&lt;=</code></a>,
<a href="funct.htm#operator_between"><code>BETWEEN</code></a>,
<a href="funct.htm#operator_not-equal"><code>!=</code></a>,
<a href="funct.htm#operator_not-equal"><code>&lt;&gt;</code></a> или
<a href="funct.htm#operator_like"><code>LIKE</code></a>,
если параметр <a href="funct.htm#operator_like"><code>LIKE</code></a>
постоянная строка, которая не начинается с подстановочного символа.</li>

<li>Для всех индексных типов многократные условия диапазона, объединены с
<a href="funct.htm#operator_or"><code>OR</code></a> или
<a href="funct.htm#operator_and"><code>AND</code></a>.</p></li></ul>

<p><span><span>Постоянная величина</span></span>
в предыдущих описаниях означает одно из следующего:</p>
<ul><li><p>Константа от строки запроса.</li>

<li>Столбец таблицы <a href="#jointype_const"><code>const</code>
</a> или <a href="#jointype_system"><code>system</code></a> из
того же самого соединения.</li>

<li>Результат некоррелированого подзапроса.</li>
<li>Любое выражение, составленное полностью из подвыражений предыдущих типов.
</p></li></ul>

<p>Вот некоторые примеры запросов с условиями диапазона в <code>WHERE</code>:
<pre>
SELECT * FROM t1 WHERE <em><code>key_col</code></em> &gt; 1 AND
         <em><code>key_col</code></em> &lt; 10;
SELECT * FROM t1 WHERE <em><code>key_col</code></em> = 1
         OR <em><code>key_col</code></em> IN (15,18,20);
SELECT * FROM t1 WHERE <em><code>key_col</code></em> LIKE 'ab%' OR
         <em><code>key_col</code></em> BETWEEN 'bar' AND 'foo';
</pre>

<p>Некоторые непостоянные величины могут быть преобразованы в
константы во время постоянной фазы оптимизации.</p>
<p>MySQL пытается извлечь условия диапазона из <code>WHERE</code>
для каждого из возможных индексов. Во время процесса извлечения удалены
условия, которые не могут использоваться для того, чтобы создать условие
диапазона, условия, которые производят накладывающиеся диапазоны, объединены,
а условия, которые производят пустые диапазоны, удалены.</p>

<p>Рассмотрите следующий запрос, где <code>key1</code>
индексированный столбец и <code>nonkey</code> не индексирован:
<pre>
SELECT * FROM t1 WHERE (key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR
         key1 LIKE '%b')) OR (key1 &lt; 'bar' AND nonkey = 4) OR
         (key1 &lt; 'uux' AND key1 &gt; 'z');
</pre>

<p>Процесс извлечения для ключа <code>key1</code>:</p>
<ol type="1"><li><p>Начнем с оригинального <code>WHERE</code>:
<pre>
(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR key1 LIKE '%b')) OR
(key1 &lt; 'bar' AND nonkey = 4) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li>

<li><p>Удалим <code>nonkey = 4</code> и <code>key1 LIKE '%b'</code>
потому что они не могут использоваться для просмотра диапазона. Правильный
способ удалить их состоит в том, чтобы заменить их <code>TRUE</code>,
так, чтобы мы не пропустили строк соответствия, делая просмотр диапазона.
Заменив их <code>TRUE</code>, получим:
<pre>
(key1 &lt; 'abc' AND (key1 LIKE 'abcde%' OR TRUE)) OR
(key1 &lt; 'bar' AND TRUE) OR
(key1 &lt; 'uux' AND key1 &gt; 'z')
</pre></li>

<li><p>Уберем условия, которые всегда являются истиной или ложью:</p>
<ul><li><p><code>(key1 LIKE 'abcde%' OR TRUE)</code> всегда true.</li>
<li><code>(key1 &lt; 'uux' AND key1 &gt; 'z')</code> всегда false.
</p></li></ul>

<p>Заменяя эти условия константами, получим:
<pre>
(key1 &lt; 'abc' AND TRUE) OR (key1 &lt; 'bar' AND TRUE) OR (FALSE)
</pre>

<p>Удалим ненужные константы <code>TRUE</code> и <code>FALSE</code>:
<pre>
(key1 &lt; 'abc') OR (key1 &lt; 'bar')
</pre></li>

<li><p>Комбинируя накладывающиеся интервалы получим заключительное условие,
которое будет использоваться для просмотра диапазона:
<pre>
(key1 &lt; 'bar')
</pre></li></ol>

<p>Вообще (и как демонстрируется предыдущим примером) условие,
используемое для просмотра диапазона, является менее строгим, чем
<code>WHERE</code>. MySQL выполняет дополнительную проверку, чтобы
отфильтровать строки, которые удовлетворяют условие диапазона, но
не полный <code>WHERE</code>.</p>

<p>Алгоритм извлечения условия диапазона может обработать вложенные
<a href="funct.htm#operator_and"><code>AND</code></a>/
<a href="funct.htm#operator_or"><code>OR</code></a> произвольной глубины, и
ее вывод не зависят от порядка, в котором
условия появляются в <code>WHERE</code>.</p>

<p>MySQL не поддерживает сливающиеся многократные диапазоны для
метода доступа <a href="#jointype_range"><code>диапазона</code>
</a> для пространственного индекса. Чтобы работать вокруг этого ограничения,
Вы можете использовать <a href="sql.htm#union"><code>UNION</code></a> с
идентичным <a href="sql.htm#select"><code>SELECT</code></a>,
за исключением того, что Вы помещаете каждый пространственный предикат в
различный <a href="sql.htm#select"><code>SELECT</code></a>.</p>

<h5><a name="range-access-multi-part"></a>9.2.1.3.2.
Метод доступа диапазона для нескольких частей индексов</h5>
<p>Условия диапазона для нескольких частей индексов это расширение условий
диапазона для единственной части индекса. Условие диапазона для нескольких
частей индексов ограничивает индексируемые строки, чтобы они были в пределах
одного или нескольких ключевых интервалов кортежа. Ключевые интервалы кортежа
определены по ряду ключевых кортежей, используя упорядочивание из индекса.
</p>

<p>Например, полагайте, что многократная часть индекса определена как
<code>key1(<em><code>key_part1</code></em>,
<em><code>key_part2</code></em>, <em><code>key_part3</code></em>)</code>,
и следующий набор ключевых кортежей перечислен в ключевом порядке:
<pre>
<em><code>key_part1</code></em>  <em><code>key_part2</code></em>
<em><code>key_part3</code></em>
  NULL 1'abc'
  NULL 1'xyz'
  NULL 2'foo'
   1 1'abc'
   1 1'xyz'
   1 2'abc'
   2 1'aaa'
</pre>

<p>Выражение <code><em><code>key_part1</code></em> = 1</code>
определяет этот интервал:
<pre>
(1,-inf,-inf) &lt;= (<em><code>key_part1</code></em>,
<em><code>key_part2</code></em>,<em><code>key_part3</code></em>) &lt;
(1,+inf,+inf)
</pre>

<p>Интервал покрывает 4-ые, 5-ые, и 6-ые кортежи в предыдущем наборе данных
и может использоваться методом доступа диапазона.</p>
<p>В отличие от этого, условие <code><em><code>key_part3</code></em> =
'abc'</code> не определяет единственный интервал и не может использоваться
методом доступа диапазона.</p>

<p>Следующие описания указывают более подробно, как работает условие
диапазона для многократной части индексов.</p>
<ul><li><p>Для <code>HASH</code> каждый интервал, содержащий идентичные
значения, может использоваться. Это означает, что интервал может быть
произведен только для условий в следующей форме:
<pre>
<em><code>key_part1</code></em> <em><code>cmp</code></em> <em><code>const1</code></em>
AND <em><code>key_part2</code></em> <em><code>cmp</code></em> <em><code>const2</code></em>
AND ...
AND <em><code>key_partN</code></em> <em><code>cmp</code></em> <em><code>constN</code></em>;
</pre>

<p>Здесь <em><code>const1</code></em>, <em><code>const2</code></em>
являются константами, <em><code>cmp</code></em> один из операторов сравнения
<a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_equal-to"><code>&lt;=&gt;</code></a> или
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a>, а
условия покрывают все индексные части. Таким образом, есть
<em><code>N</code></em> условий, одно для каждой части индекса из
<em><code>N</code></em> частей. Например, следующее условие диапазона для
трехчастного индекса <code>HASH</code>:
<pre>
<em><code>key_part1</code></em> = 1 AND <em><code>key_part2</code></em>
IS NULL AND <em><code>key_part3</code></em> = 'foo'
</pre>
<p>Для определения константы см.
<a href="#range-access-single-part">раздел 9.2.1.3.1</a>.</li>

<li>Для индекса <code>BTREE</code> интервал мог бы быть применимым для
условий, объединенных с <a href="funct.htm#operator_and"><code>AND</code>
</a>, где каждое условие сравнивает ключевую часть с постоянной величиной
с использованием
<a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_equal-to"><code>&lt;=&gt;</code></a>,
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a>,
<a href="funct.htm#operator_greater-than"><code>&gt;</code></a>,
<a href="funct.htm#operator_less-than"><code>&lt;</code></a>,
<a href="funct.htm#operator_greater-than-or-equal"><code>&gt;=</code></a>,
<a href="funct.htm#operator_less-than-or-equal"><code>&lt;=</code></a>,
<a href="funct.htm#operator_not-equal"><code>!=</code></a>,
<a href="funct.htm#operator_not-equal"><code>&lt;&gt;</code></a>,
<a href="funct.htm#operator_between"><code>BETWEEN</code></a> или
<a href="funct.htm#operator_like"><code>LIKE '<em><code>pattern</code>
</em>'</code></a> (здесь <code>'<em><code>pattern</code></em>'</code>
не начинается с подстановочного знака). Интервал может использоваться, пока
возможно определить единственный ключевой кортеж, содержащий все строки,
которые соответствуют условию (или два интервала, если используется
<a href="funct.htm#operator_not-equal"><code>&lt;&gt;</code></a> или
<a href="funct.htm#operator_not-equal"><code>!=</code></a>).</p>

<p>Оптимизатор пытается использовать дополнительные части ключей, чтобы
определить интервал, пока оператор сравнения
<a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_equal-to"><code>&lt;=&gt;</code></a> или
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a>. Если оператор
<a href="funct.htm#operator_greater-than"><code>&gt;</code></a>,
<a href="funct.htm#operator_less-than"><code>&lt;</code></a>,
<a href="funct.htm#operator_greater-than-or-equal"><code>&gt;=</code></a>,
<a href="funct.htm#operator_less-than-or-equal"><code>&lt;=</code></a>,
<a href="funct.htm#operator_not-equal"><code>!=</code></a>,
<a href="funct.htm#operator_not-equal"><code>&lt;&gt;</code></a>,
<a href="funct.htm#operator_between"><code>BETWEEN</code></a> или
<a href="funct.htm#operator_like"><code>LIKE</code></a>, оптимизатор
использует это, но не рассматривает больше частей ключа. Для следующего
выражения оптимизатор использует
<a href="funct.htm#operator_equal"><code>=</code></a> из первого сравнения.
Это также использует <a href="funct.htm#operator_greater-than-or-equal">
<code>&gt;=</code></a> из второго сравнения, но не рассматривает дальнейших
ключевых частей и не использует третье сравнение для конструкции интервала:
<pre>
<em><code>key_part1</code></em> = 'foo' AND <em><code>key_part2</code></em>
&gt;= 10 AND <em><code>key_part3</code></em> &gt; 10
</pre>

<p>Единственный интервал:
<pre>
('foo',10,-inf) &lt; (<em><code>key_part1</code></em>,
<em><code>key_part2</code></em>,<em><code>key_part3</code></em>) &lt;
('foo',+inf,+inf)
</pre>

<p>Возможно, что создаваемый интервал содержит больше строк,
чем начальное условие. Например, предыдущий интервал включает значение
<code>('foo', 11, 0)</code>, которое не удовлетворяет оригинальное условие.
</li>

<li>Если условия, которые покрывают наборы строк, содержавшихся в пределах
интервалов, объединены с
<a href="funct.htm#operator_or"><code>OR</code></a>, они формируют условие,
которое покрывает ряд строк, содержавшихся в пределах союза их интервалов.
Если условия объединены с
<a href="funct.htm#operator_and"><code>AND</code></a>, они формируют условие,
которое покрывает ряд строк, содержавшихся в пересечении их интервалов.
Например, для этого условия с двумя частями индекса:
<pre>
(<em><code>key_part1</code></em> = 1 AND <em><code>key_part2</code></em> &lt; 2) OR
(<em><code>key_part1</code></em> &gt; 5)
</pre>

<p>Интервалы:
<pre>
(1,-inf) &lt; (<em><code>key_part1</code></em>,<em><code>key_part2</code></em>) &lt; (1,2)
(5,-inf) &lt; (<em><code>key_part1</code></em>,<em><code>key_part2</code></em>)
</pre>

<p>В этом примере интервал на первой строке использует одну ключевую часть
для левой границы и две ключевых части для правой.
Интервал на второй строке использует только одну ключевую часть.
Столбец <code>key_len</code> в выводе <a href="sql.htm#explain"><code>EXPLAIN
</code></a> указывает на максимальную длину ключевой используемого префикса.
</p>

<p>В некоторых случаях <code>key_len</code> может указать, что ключевая
часть использовалась, но это могло бы быть не то, что Вы будете ожидать.
Предположите, что <em><code>key_part1</code></em> и
<em><code>key_part2</code></em> могут быть <code>NULL</code>.
Тогда столбец <code>key_len</code> выводит на экран две длины ключевой части
для следующего условия:
<pre>
<em><code>key_part1</code></em> &gt;= 1 AND <em><code>key_part2</code></em> &lt; 2
</pre>

<p>Но, фактически, условие преобразовано в это:
<pre>
<em><code>key_part1</code></em> &gt;= 1 AND <em><code>key_part2</code></em> IS NOT NULL
</pre></li></ul>

<p><a href="#range-access-single-part">Раздел 9.2.1.3.1</a>
описывает, как оптимизация выполнена, чтобы объединить или устранить
интервалы для условий диапазона на единственной части индекса. Аналогичные
шаги выполнены для условий диапазона на многих частях индекса.</p>

<h5><a name="equality-range-optimization"></a>9.2.1.3.3.
Оптимизация диапазона равенства сравнений</h5>
<p>Рассмотрите эти выражения, где
<em><code>col_name</code></em> индексированный столбец:
<pre>
<em><code>col_name</code></em> IN(<em><code>val1</code></em>, ...,
<em><code>valN</code></em>)

<em><code>col_name</code></em> = <em><code>val1</code></em> OR
... OR <em><code>col_name</code></em> = <em><code>valN</code></em>
</pre>

<p>Каждое выражение истина, если <em><code>col_name</code></em>
равно любому из нескольких значений. Это сравнения диапазона равенства (где
<span><span>диапазон</span></span> является единственным значением).
Оптимизатор оценивает стоимость чтения готовящихся строк для сравнений
диапазона равенства следующим образом:</p>

<ul><li><p>Если есть уникальный индекс на
<em><code>col_name</code></em>, оценка строки для каждого диапазона 1, потому
что самое большее у одной строки может быть данное значение.</li>

<li>Иначе любой индекс на <em><code>col_name</code></em>
является групповым, и оптимизатор может оценить счет строки для каждого
диапазона, используя погружения в индексирование или индексную статистику.
</p></li></ul>

<p>Оптимизатор делает погружение в каждом конце диапазона и использует число
строк в диапазоне как оценка. Например, выражение
<code><em><code>col_name</code></em> IN (10, 20, 30)</code>
имеет три диапазона равенства, и оптимизатор делает два погружения на
диапазон, чтобы произвести оценку строки. Каждая пара погружений приводит к
оценке числа строк, у которых есть данное значение.</p>

<p>Погружения обеспечивают точные оценки строки, но поскольку число
сравнительных значений в выражении увеличивается, оптимизатор тратит больше
времени, чтобы произвести оценку строки. Использование индексной
статистики менее точно, чем индексные погружения, но разрешает более быструю
оценку строки для больших списков значений.</p>

<p><a href="server.htm#sysvar_eq_range_index_dive_limit"><code>
eq_range_index_dive_limit</code></a> позволяет Вам сконфигурировать число
значений, при которых оптимизатор переключается от одной стратегии оценки
строки на другую. Чтобы разрешить использование погружения для сравнений до
<em><code>N</code></em> диапазонов равенства, установите
<a href="server.htm#sysvar_eq_range_index_dive_limit"><code>
eq_range_index_dive_limit</code></a> в <em><code>N</code></em> + 1.
Чтобы отключить использование статистики и всегда использовать
погружения независимо от <em><code>N</code></em>, задайте
<a href="server.htm#sysvar_eq_range_index_dive_limit">
<code>eq_range_index_dive_limit</code></a> = 0.</p>
<p>Чтобы обновить таблицу индексную статистику для наилучших оценок
используют <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
</p>

<h5><a name="range-optimization-memory-use"></a>9.2.1.3.4.
Ограничение использования памяти для оптимизации диапазона</h5>
<p>Чтобы управлять памятью, доступной оптимизатору, используйте
<a href="server.htm#sysvar_range_optimizer_max_mem_size">
<code>range_optimizer_max_mem_size</code></a>:</p>

<ul><li><p>0 значит отсутствие ограничений.</li>
<li>Со значением больше 0 оптимизатор отслеживает память, потребляемую,
рассматривая метод доступа диапазона. Если указанный предел превышен,
метод доступа диапазона оставлен, и другие методы, включая полное
сканирование таблицы, рассматриваются вместо этого.
Это могло быть менее оптимальным. Если это происходит, следующее
предупреждение происходит (где <em><code>N</code></em> текущее значение
<a href="server.htm#sysvar_range_optimizer_max_mem_size">
<code>range_optimizer_max_mem_size</code></a>):
<pre>
Warning 3170 Memory capacity of <em><code>N</code></em> bytes for
        'range_optimizer_max_mem_size' exceeded. Range
        optimization was not done for this query.
</pre></li></ul>

<p>Для отдельных запросов, которые превышают доступную память оптимизации
диапазона и для которого оптимизатор отступает к менее оптимальным планам,
увеличение <a href="server.htm#sysvar_range_optimizer_max_mem_size"><code>
range_optimizer_max_mem_size</code></a> может улучшить работу.</p>

<p>Чтобы оценить объем памяти, надо использовать эти направляющие линии:</p>
<ul><li><p>Для простого запроса, где есть один возможный ключ для для метода
доступа диапазона, каждый предикат, объединенный с
<a href="funct.htm#operator_or"><code>OR</code></a>,
использует приблизительно 230 байтов:
<pre>
SELECT COUNT(*) FROM t
       WHERE a=1 OR a=2 OR a=3 OR .. . a=<em><code>N</code></em>;
</pre></li>

<li><p>Так же для запроса каждый предикат, объединенный с
<a href="funct.htm#operator_and"><code>AND</code></a>
использует приблизительно 125 байтов:
<pre>
SELECT COUNT(*) FROM t WHERE a=1 AND b=1 AND c=1 ... <em><code>N</code></em>;
</pre></li>

<li><p>Для запроса с <a href="funct.htm#function_in">
<code>IN()</code></a> предикаты:
<pre>
SELECT COUNT(*) FROM t
       WHERE a IN (1,2, ..., <em><code>M</code></em>) AND b
       IN (1,2, ..., <em><code>N</code></em>);
</pre>

<p>Каждое буквальное значение в списке
<a href="funct.htm#function_in"><code>IN()</code></a> считается как предикат,
объединенный с <a href="funct.htm#operator_or"><code>OR</code></a>.
Если есть два списка <a href="funct.htm#function_in"><code>IN()</code></a>,
число предикатов, объединных с <a href="funct.htm#operator_or"><code>OR
</code></a>, это произведение числа буквальных значений в каждом списке.
Таким образом, число предикатов с
<a href="funct.htm#operator_or"><code>OR</code></a> в предыдущем случае
<em><code>M</code></em>*<em><code>N</code></em>.</p></li></ul>

<h5><a name="row-constructor-range-optimization"></a>9.2.1.3.5.
Оптимизация диапазона выражений конструктора строки</h5>
<p>Оптимизатор в состоянии применить метод доступа просмотра диапазона
для запросов этой формы:
<pre>
SELECT ... FROM t1 WHERE ( col_1, col_2 ) IN (( 'a', 'b' ), ( 'c', 'd' ));
</pre>

<p>Ранее для просмотра диапазона было необходимо написать запрос как:
<pre>
SELECT ... FROM t1 WHERE (col_1 = 'a' AND col_2 = 'b') OR
           (col_1 = 'c' AND col_2 = 'd');
</pre>

<p>Для оптимизатора, чтобы использовать просмотр диапазона, запросы должны
удовлетворить этим условиям:</p>
<ul><li><p>Используются только предикаты
<a href="funct.htm#function_in"><code>IN()</code></a>, не
<a href="funct.htm#function_not-in"><code>NOT IN()</code></a>.</li>

<li>На левой стороне
<a href="funct.htm#function_in"><code>IN()</code></a>
конструктор строки содержит только ссылки столбца.</li>

<li>На правой стороне
<a href="funct.htm#function_in"><code>IN()</code></a>
конструкторы строки содержат только константы во время выполнения, которые
являются литералами или местными ссылками столбца, которые связаны с
константами во время выполнения.</li>

<li>На правой стороне
<a href="funct.htm#function_in"><code>IN()</code></a>
есть больше, чем один конструктор строки.</p></li></ul>
<p>См. <a href="#row-constructor-optimization">раздел 9.2.1.20
</a>.</p>

<h4><a name="index-merge-optimization"></a>9.2.1.4.
Оптимизация слияния индекса</h4>
<p>Метод <span>слияния индекса</span>
используется, чтобы получить строки с несколькими
<a href="#jointype_range"><code>диапазонами</code></a>
и слить их результаты в один. Слияние может произвести союзы, пересечения или
союзы пересечений его основных просмотров. Этот метод доступа слияния
индексирует просмотры от единственной таблицы,
это не сливает просмотры через многократные таблицы.</p>

<p>В выводе <a href="sql.htm#explain"><code>EXPLAIN</code></a> метод
слияния появляется как <a href="#jointype_index_merge"><code>
index_merge</code></a> в столбце <code>type</code>. В этом случае столбец
<code>key</code> содержит список используемых индексов, а
<code>key_len</code> содержит список самых длинных ключевых частей
для тех индексов.</p>

<p>Примеры:
<pre>
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>key1</code></em> = 10 OR
         <em><code>key2</code></em> = 20;
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE (<em><code>key1</code></em> = 10 OR
         <em><code>key2</code></em> = 20) AND
         <em><code>non_key</code></em>=30;
SELECT * FROM t1, t2 WHERE (t1.<em><code>key1</code></em> IN (1,2) OR
         t1.<em><code>key2</code></em> LIKE '<em><code>value</code></em>%')
         AND t2.<em><code>key1</code></em>=t1.<em><code>some_col</code></em>;
SELECT * FROM t1, t2 WHERE t1.<em><code>key1</code></em>=1 AND
         (t2.<em><code>key1</code></em>=t1.<em><code>some_col</code></em> OR
         t2.<em><code>key2</code></em>=t1.<em><code>some_col2</code></em>);
</pre>

<p>У метода слияния есть несколько алгоритмов доступа (отмечено в поле
<code>Extra</code> вывода <a href="sql.htm#explain"><code>EXPLAIN</code>
</a>):</p>

<ul><li><p><code>Using intersect(...)</code></li>
<li><code>Using union(...)</code></li>
<li><code>Using sort_union(...)</code></p></li></ul>
<p>Следующие разделы описывают эти методы более подробно.</p>

<p>У алгоритма оптимизации Слияния есть следующие известные недостатки:</p>
<ul><li><p>Если у Вашего запроса есть сложный <code>WHERE</code> с глубоким
вложением <a href="funct.htm#operator_and"><code>AND</code></a>/
<a href="funct.htm#operator_or"><code>OR</code></a> и MySQL
не выбирает оптимальный план, пытается распределить сроки, используя
следующие законы об идентичности:
<pre>
(<em><code>x</code></em> AND <em><code>y</code></em>) OR
<em><code>z</code></em> = (<em><code>x</code></em> OR
<em><code>z</code></em>) AND (<em><code>y</code></em> OR
<em><code>z</code></em>)

(<em><code>x</code></em> OR <em><code>y</code></em>) AND
<em><code>z</code></em> = (<em><code>x</code></em> AND
<em><code>z</code></em>) OR (<em><code>y</code></em> AND
<em><code>z</code></em>)
</pre></li>
<li>Слияние неприменимо к полнотекстовому индексу. Мы планируем расширить
это, чтобы покрыть их в будущем выпуске MySQL.</p></li></ul>

<p>Выбор между различными возможными разновидностями метода доступа
слияния и других методов доступа основан на сметах
различных доступных параметров.</p>

<h5><a name="index-merge-interраздел"></a>9.2.1.4.1.
Перекрестный алгоритм доступа слияния</h5>
<p>Этот алгоритм доступа может использоваться, когда <code>WHERE</code>
был преобразован в несколько условий диапазона на различных ключах,
объединенных с <a href="funct.htm#operator_and"><code>AND</code></a>,
и каждое условие одно из следующего:</p>

<ul><li><p>В этой форме, где индексирование имеет точно
<em><code>N</code></em> частей (то есть, все индексные части покрыты):
<pre>
<em><code>key_part1</code></em>=<em><code>const1</code></em> AND
<em><code>key_part2</code></em>=<em><code>const2</code></em> ... AND
<em><code>key_partN</code></em>=<em><code>constN</code></em>
</pre></li>
<li>Любой диапазон условия на первичном ключе <code>InnoDB</code>.
</p></li></ul>

<p>Примеры:
<pre>
SELECT * FROM <em><code>innodb_table</code></em> WHERE
         <em><code>primary_key</code></em> &lt; 10 AND
         <em><code>key_col1</code></em>=20;
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE (<em><code>key1_part1</code></em>=1 AND
         <em><code>key1_part2</code></em>=2) AND
         <em><code>key2</code></em>=2;
</pre>

<p>Перекрестный алгоритм слияния использует одновременные просмотры на всех
используемых индексах и производит пересечение последовательностей строки,
которые получает от слияния просмотров индекса.</p>

<p>Если все столбцы, используемые в запросе, покрыты используемым индексом,
полные строки таблицы не получены
(вывод <a href="sql.htm#explain"><code>EXPLAIN</code></a> включает
<code>Using index</code> в поле <code>Extra</code>).
Вот пример такого запроса:
<pre>
SELECT COUNT(*) FROM t1 WHERE key1=1 AND key2=1;
</pre>

<p>Если используемый индекс не покрывают все столбцы, используемые в запросе,
все строки получены только, когда условия диапазона для всех
используемых ключей удовлетворены.</p>

<p>Если одно из слитых условий это условие по первичному ключу
<code>InnoDB</code>, это не используется для извлечения строки, но
используется, чтобы отфильтровать полученные с использованием
других условий строки.</p>

<h5><a name="index-merge-union"></a>9.2.1.4.2.
Алгоритм доступа союза слияния</h5>
<p>Критерии применимости для этого алгоритма подобны критериям для
перекрестного алгоритма. Алгоритм может использоваться когда
<code>WHERE</code> был преобразован в несколько условий диапазона на
различных ключах, объединенных с <a href="funct.htm#operator_or"><code>OR
</code></a>, и каждое условие одно из следующего:</p>

<ul><li><p>В этой форме, где индексирование имеет точно
<em><code>N</code></em> частей (то есть, все индексные части покрыты):
<pre>
<em><code>key_part1</code></em>=<em><code>const1</code></em> AND
<em><code>key_part2</code></em>=<em><code>const2</code></em> ... AND
<em><code>key_partN</code></em>=<em><code>constN</code></em>
</pre></li>

<li>Любой диапазон условия на первичном ключе <code>InnoDB</code>.</li>
<li>Условие, для которого перекрестный алгоритм метода слияния применим.
</p></li></ul>

<p>Примеры:
<pre>
SELECT * FROM t1 WHERE <em><code>key1</code></em>=1 OR
         <em><code>key2</code></em>=2 OR <em><code>key3</code></em>=3;
SELECT * FROM <em><code>innodb_table</code></em> WHERE
         (<em><code>key1</code></em>=1 AND <em><code>key2</code></em>=2) OR
         (<em><code>key3</code></em>='foo' AND
         <em><code>key4</code></em>='bar') AND <em><code>key5</code></em>=5;
</pre>

<h5><a name="index-merge-sort-union"></a>9.2.1.4.3.
Алгоритм доступа сортировки слиянием</h5>
<p>Этот алгоритм доступа используется, когда <code>WHERE</code>
был преобразован в несколько условий диапазона, объединенных
<a href="funct.htm#operator_or"><code>OR</code></a>,
но для которого алгоритм союза неприменим.</p>

<p>Примеры:
<pre>
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>key_col1</code></em> &lt; 10 OR
         <em><code>key_col2</code></em> &lt; 20;
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE (<em><code>key_col1</code></em> &gt; 10 OR
         <em><code>key_col2</code></em> = 20) AND
         <em><code>nonkey_col</code></em>=30;
</pre>

<p>Различие между алгоритмом сортировки союза и алгоритмом союза в том, что
алгоритм сортировки союза должен сначала принести ID строки для всех строк и
сортировать их прежде, чем возвратить любые строки.</p>

<h4><a name="condition-pushdown-optimization"></a>9.2.1.5.
Механизм оптимизации выражении</h4>
<p>Эта оптимизация улучшает эффективность прямых сравнений между
неиндексированным столбцом и константой. В таких случаях условие
<span><span>передано</span></span> механизму хранения для оценки. Эта
оптимизация может использоваться только
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>.</p>

<p><a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a> в настоящее время не доступен в MySQL 8.0.
Если Вы интересуетесь использованием MySQL Cluster, см.
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top">MySQL Cluster NDB 7.5</a>.</p>

<p>Для MySQL Cluster эта оптимизация может избавить от необходимости посылать
несоответствие строк по сети между узлами данных кластера и MySQL Server,
который выпустил запрос, и может ускорить запросы, где
это используется, в 5-10 раз.</p>

<p>Предположите, что таблица MySQL Cluster определена следующим образом:
<pre>
CREATE TABLE t1 (a INT, b INT, KEY(a)) ENGINE=NDB;
</pre>

<p>Условие может использоваться с такими запросами, как один показанный
здесь, который включает сравнение между
неиндексированным столбцом и константой:
<pre>
SELECT a, b FROM t1 WHERE b = 10;
</pre>

<p>Использование условия может быть замечено в выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a>:
<pre>
mysql&gt; EXPLAIN SELECT a,b FROM t1 WHERE b = 10\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: t1
 type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
 rows: 10
Extra: Using where with pushed condition
</pre>

<p>Однако, условие не <span><em>может</em></span> использоваться ни с одним
из этих двух запросов:
<pre>
SELECT a,b FROM t1 WHERE a = 10;
SELECT a,b FROM t1 WHERE b + 1 = 10;
</pre>

<p>Это неприменимо к первому запросу, потому что индексирование существует на
столбце <code>a</code>. Метод доступа к индексу был бы более эффективным и
будет выбран. Это также не может использоваться и для второго запроса потому,
что сравнение, вовлекающее неиндексированный столбец <code>b</code>
является косвенным. Однако, условие могло быть применено, если Вы должны были
уменьшить <code>b + 1 = 10</code> до <code>b = 9</code> в <code>WHERE</code>.
</p>

<p>Условие может также использоваться, когда индексированный столбец сравнен
с постоянной с помощью оператора <code>&gt;</code> или <code>&lt;</code>:
<pre>
mysql&gt; EXPLAIN SELECT a, b FROM t1 WHERE a &lt; 2\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: t1
 type: range
possible_keys: a
key: a
key_len: 5
ref: NULL
 rows: 2
Extra: Using where with pushed condition
</pre>

<p>Другие поддержанные сравнения включают следующее:</p>
<ul><li><p><code><em><code>column</code></em> [NOT] LIKE
<em><code>pattern</code></em></code></p>
<p><em><code>pattern</code></em> должна быть строка, буквально
содержащий образец, который будет соответствующим, см.
<a href="funct.htm#string-comparison-functions">раздел 13.5.1</a>.</li>

<li><code><em><code>column</code></em> IS [NOT] NULL</code></li>
<li><code><em><code>column</code></em> IN
(<em><code>value_list</code></em>)</code></p>
<p>Каждый элемент в <em><code>value_list</code></em>
должен быть константой, литеральным значением.</li>

<li><code><em><code>column</code></em> BETWEEN
<em><code>constant1</code></em> AND
<em><code>constant2</code></em></code></p>
<p><em><code>constant1</code></em> и <em><code>constant2</code></em>
должны быть константами.</p></li></ul>

<p>Во всех случаях в предыдущем списке для условия возможно быть
преобразованным в форму одного или более прямых сравнений
между столбцом и константой.</p>

<p>Условие механизма включено по умолчанию. Чтобы отключить это при запуске
сервера, установите <a href="server.htm#sysvar_optimizer_switch"><code>
optimizer_switch</code></a>. Например, в файле <code>my.cnf</code>
используйте эти строки:
<pre>
[mysqld]
optimizer_switch=engine_condition_pushdown=off
</pre>

<p>Во время выполнения включите условие:
<pre>
SET optimizer_switch='engine_condition_pushdown=off';
</pre>

<p><b>Ограничения. </b>Условие механизма
подвергается следующим ограничениям:</p>
<ul><li><p>Поддержано только <a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>.</li>

<li>Столбцы могут быть сравнены только с константами, однако, это включает
выражения, которые оцениваются к постоянным величинам.</li>
<li>Столбцы, используемые в сравнениях, не могут иметь ни одного из
типов <a href="types.htm#blob"><code>BLOB</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>.</li>

<li>Строковое значение, чтобы быть сравнено со столбцом, должно использовать
то же самое сопоставление, как столбец.</li>
<li>Соединения непосредственно не поддержаны,
условия, вовлекающие многократные таблицы, продвинуты отдельно где только
возможно. Надо использовать <a href="#explain-extended"><code>
EXPLAIN EXTENDED</code></a>, чтобы определить, какие
условия фактически применены.</p></li></ul>

<h4><a name="index-condition-pushdown-optimization"></a>9.2.1.6.
Оптимизация Index Condition Pushdown</h4>
<p>Index Condition Pushdown (ICP) оптимизация для случая, где MySQL получает
строки от таблицы, используя индексирование. Без ICP механизм хранения
не применяет индексирование, чтобы определить местонахождение строк в базовой
таблице и возвращает их к серверу MySQL, который оценивает условие
<code>WHERE</code> для строк. С ICP, если части <code>WHERE</code>
могут быть оценены при использовании только областей от индекса, сервер MySQL
продвигает эту часть <code>WHERE</code> к механизму хранения. Механизм
хранения тогда оценивает индексное условие при использовании индексной
записи и только если это удовлетворено, строка считана из таблицы. ICP может
уменьшить число раз, которое механизм хранения должен получить доступ к
базовой таблице, и число раз, которое сервер MySQL должен получить
доступ к механизму хранения.</p>

<p>Index Condition Pushdown используется для методов доступа
<a href="#jointype_range"><code>диапазона</code></a>,
<a href="#jointype_ref"><code>ref</code></a>,
<a href="#jointype_eq_ref"><code>eq_ref</code></a> и
<a href="#jointype_ref_or_null"><code>ref_or_null</code></a>,
когда есть потребность получить доступ к полным строкам таблицы. Эта
стратегия может использоваться для <a href="innodb.htm"><code>InnoDB</code>
</a> и <a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>,
включая разделенные таблицы <code>InnoDB</code> и <code>MyISAM</code>. Для
<code>InnoDB</code> ICP используется только для вторичного индекса.
Цель ICP состоит в том, чтобы сократить количество чтений полных записей
и таким образом уменьшить операции IO. Для кластеризируемого индекса
<code>InnoDB</code> полная запись уже считана в буфер <code>InnoDB</code>.
ICP в этом случае не уменьшает IO.</p>

<p>Оптимизация ICP не поддержана со вторичным индексом
на произведенных виртуальных столбцах.</p>
<p>Чтобы видеть, как эта оптимизация работает, рассмотрите сначала, как
работает просмотр индекса, когда Index Condition Pushdown выключена:</p>

<ol type="1"><li><p>Получите следующую строку, читая индексный кортеж, а
затем при использовании индексного кортежа определите местонахождение и
считайте полную строку таблицы.</li>
<li>Проверьте часть <code>WHERE</code>, которая относится к этой таблице.
Примите или отклоните строку.</p></li></ol>

<p>С Index Condition Pushdown просмотра идет так:</p>
<ol type="1"><li><p>Получите следующую строку индексного
кортежа (но не полную строку таблицы).</li>

<li>Проверьте часть <code>WHERE</code>, которая относится к этой таблице
и может быть проверена, используя только индексированные столбцы. Если
условие не удовлетворено, перейдите к индексному кортежу
для следующей строки.</li>

<li>Если условие удовлетворено, используйте индексный кортеж, чтобы
определить местонахождение и считать полную строку таблицы.</li>
<li>Проверьте остающуюся часть <code>WHERE</code>, которая относится к
этой таблице. Примите или отклоните строку.</p></li></ol>

<p>Когда Index Condition Pushdown включен, столбец <code>Extra</code> в
<a href="sql.htm#explain"><code>EXPLAIN</code></a> показывает
<code>Using index condition</code>. Это не будет показывать
<code>Index only</code>, потому что это не применяется, когда полные строки
таблицы должны быть считаны.</p>

<p>Предположите, что у нас есть таблица, содержащая информацию о людях и их
адресах и что таблице определили индексирование как <code>INDEX (zipcode,
lastname, firstname)</code>. Если мы знаем <code>zipcode</code>, но не
уверены в фамилии, мы можем искать так:
<pre>
SELECT * FROM people WHERE zipcode='95054' AND lastname LIKE '%etrunia%' AND
         address LIKE '%Main Street%';
</pre>

<p>MySQL может использовать индексирование, чтобы просмотреть людей с
<code>zipcode='95054'</code>. Вторая часть
(<code>lastname LIKE '%etrunia%'</code>) не может использоваться, чтобы
ограничить число строк, которые должны быть просмотрены, таким образом, без
Index Condition Pushdown этот запрос должен получить полные строки таблицы
для всех людей, которые имеют <code>zipcode='95054'</code>.</p>

<p>С Index Condition Pushdown MySQL проверит часть
<code>lastname LIKE '%etrunia%'</code> прежде, чем считать полную строку
таблицы. Это избегает читать все строки, соответствующие всем индексным
кортежам, которые не соответствуют <code>lastname</code>.</p>

<p>Index Condition Pushdown включен по умолчанию, этим можно управлять с
помощью <a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch
</code></a> установкой флага <code>index_condition_pushdown</code>, см.
<a href="#switchable-optimizations">раздел 9.9.2</a>.</p>

<h4><a name="index-extensions"></a>9.2.1.7.
Использование индексного расширения</h4>
<p><a href="innodb.htm"><code>InnoDB</code></a>
автоматически расширяет каждый вторичный индекс, прилагая столбцы первичного
ключа к этому. Рассмотрите это табличное определение:
<pre>
CREATE TABLE t1 (i1 INT NOT NULL DEFAULT 0, i2 INT NOT NULL DEFAULT 0,
                 d DATE DEFAULT NULL, PRIMARY KEY (i1, i2),
                 INDEX k_d (d)) ENGINE = InnoDB;
</pre>

<p>Эта таблица определяет первичный ключ на столбцах <code>(i1, i2)</code>.
Это также определяет вторичный индекс
<code>k_d</code> на столбце <code>(d)</code>,
но внутренне <code>InnoDB</code> расширяет этот индекс
и обрабатывает это как столбцы <code>(d, i1, i2)</code>.</p>

<p>Оптимизатор принимает во внимание, что столбцы первичного ключа
добавлены во вторичный индекс, определяя, как и использовать ли индекс.
Это может привести к более эффективным планам выполнения
запроса и лучшей работе.</p>

<p>Оптимизатор может использовать расширенный вторичный индекс для
доступа <code>ref</code>, <code>range</code> и
<code>index_merge</code>, свободных индексных просмотров, соединения и
оптимизации сортировки и для оптимизации
<a href="funct.htm#function_min"><code>MIN()</code></a>/
<a href="funct.htm#function_max"><code>MAX()</code></a>.</p>

<p>Следующий пример показывает, как планы выполнения затронуты тем,
использовал ли оптимизатор расширенные вторичные индексы. Предположите, что
<code>t1</code> заполнен с этими строками:
<pre>
INSERT INTO t1 VALUES
       (1, 1, '1998-01-01'), (1, 2, '1999-01-01'),
       (1, 3, '2000-01-01'), (1, 4, '2001-01-01'),
       (1, 5, '2002-01-01'), (2, 1, '1998-01-01'),
       (2, 2, '1999-01-01'), (2, 3, '2000-01-01'),
       (2, 4, '2001-01-01'), (2, 5, '2002-01-01'),
       (3, 1, '1998-01-01'), (3, 2, '1999-01-01'),
       (3, 3, '2000-01-01'), (3, 4, '2001-01-01'),
       (3, 5, '2002-01-01'), (4, 1, '1998-01-01'),
       (4, 2, '1999-01-01'), (4, 3, '2000-01-01'),
       (4, 4, '2001-01-01'), (4, 5, '2002-01-01'),
       (5, 1, '1998-01-01'), (5, 2, '1999-01-01'),
       (5, 3, '2000-01-01'), (5, 4, '2001-01-01'), (5, 5, '2002-01-01');
</pre>

<p>Теперь рассмотрите этот запрос:
<pre>
EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'
</pre>

<p>Оптимизатор не может использовать первичный ключ в этом случае, потому что
это включает столбцы <code>(i1, i2)</code> и запрос не обращается к
<code>i2</code>. Вместо этого оптимизатор может использовать вторичный индекс
<code>k_d</code> на <code>(d)</code>, и план выполнения зависит от того,
используется ли расширение индекса.</p>

<p>Когда оптимизатор не рассматривает индексные расширения, он обрабатывает
индекс <code>k_d</code> только как <code>(d)</code>.
<a href="sql.htm#explain"><code>EXPLAIN</code></a>
приводит к этому результату:
<pre>
mysql&gt; EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: t1
 type: ref
possible_keys: PRIMARY,k_d
key: k_d
key_len: 4
ref: const
 rows: 5
Extra: Using where; Using index
</pre>

<p>Когда оптимизатор берет индексные расширения во внимание, он обрабатывает
<code>k_d</code> как <code>(d, i1, i2)</code>.
В этом случае это может использовать начальный индексный префикс
<code>(d, i1)</code>, чтобы произвести лучший план выполнения:
<pre>
mysql&gt; EXPLAIN SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01'\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: t1
 type: ref
possible_keys: PRIMARY,k_d
key: k_d
key_len: 8
ref: const,const
 rows: 1
Extra: Using index
</pre>

<p>В обоих случаях <code>key</code> указывает, что оптимизатор будет
использовать вторичный индекс <code>k_d</code>, но
<a href="sql.htm#explain"><code>EXPLAIN</code></a> показывает эти
усовершенствования от использования расширенного индекса:</p>

<ul><li><p><code>key_len</code> идет от 4 байтов до 8 байтов, указывая, что
ключевые поиски используют столбцы <code>d</code> и <code>i1</code>, а
не просто <code>d</code>.</li>

<li><code>ref</code> изменяется с <code>const</code> на
<code>const,const</code>, потому что ключевой поиск использует две ключевых
части, не одну.</li>

<li><code>rows</code> уменьшается от 5 до 1, указывая на то, что
<code>InnoDB</code> должен исследовать меньше строк.</li>
<li><code>Extra</code> меняется с <code>Using where; Using index</code> на
<code>Using index</code>. Это означает, что строки могут быть считаны,
используя только индексирование, без консультационных
столбцов в строке данных.</p></li></ul>

<p>Различия в поведении оптимизатора для использования расширенных индексов
могут также быть замечены с <a href="sql.htm#show-status"><code>SHOW STATUS
</code></a>:
<pre>
FLUSH TABLE t1;
FLUSH STATUS;
SELECT COUNT(*) FROM t1 WHERE i1 = 3 AND d = '2000-01-01';
SHOW STATUS LIKE 'handler_read%'
</pre>

<p>Предыдущие запросы включают
<a href="sql.htm#flush"><code>FLUSH TABLE</code></a> и
<a href="sql.htm#flush"><code>FLUSH STATUS</code></a> для сброса
табличного кэша и очистки счетчиков состояния.</p>

<p>Без индексного расширения <a href="sql.htm#show-status"><code>SHOW
STATUS</code></a> приводит к этому результату:
<pre>
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 5     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre>

<p>С индексным расширением <a href="sql.htm#show-status"><code>SHOW
STATUS</code></a> приводит к этому результату.
<a href="server.htm#statvar_Handler_read_next"><code>Handler_read_next</code>
</a> уменьшается от 5 до 1, указывая на более
эффективное использование индексирования:
<pre>
+-----------------------+-------+
| Variable_name         | Value |
+-----------------------+-------+
| Handler_read_first    | 0     |
| Handler_read_key      | 1     |
| Handler_read_last     | 0     |
| Handler_read_next     | 1     |
| Handler_read_prev     | 0     |
| Handler_read_rnd      | 0     |
| Handler_read_rnd_next | 0     |
+-----------------------+-------+
</pre>

<p>Флаг <code>use_index_extensions</code> в
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> разрешает управление, принимает ли оптимизатор столбцы первичного ключа
во внимание, определяя, как использовать вторичные индексы таблицы
<code>InnoDB</code>. По умолчанию <code>use_index_extensions</code>
включен. Чтолыб проверить, улучшит ли работу отключение использования
расширения, надо использовать этот запрос:
<pre>
SET optimizer_switch = 'use_index_extensions=off';
</pre>
<p>Использование расширения подвергается обычным пределам на число ключевых
частей в индексировании (16) и максимальную длину ключа (3072 байт).</p>

<h4><a name="is-null-optimization"></a>9.2.1.8. Оптимизация IS NULL</h4>
<p>MySQL может выполнить ту же самую оптимизацию на
<em><code>col_name</code></em> <a href="funct.htm#operator_is-null"><code>IS
NULL</code></a>, которую может использовать для
<em><code>col_name</code></em> <code>=</code>
<em><code>constant_value</code></em>. Например, MySQL
может использовать индекс и диапазоны, чтобы искать <code>NULL</code> с
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a>.</p>

<p>Примеры:
<pre>
SELECT * FROM <em><code>tbl_name</code></em> WHERE
         <em><code>key_col</code></em> IS NULL;
SELECT * FROM <em><code>tbl_name</code></em> WHERE
         <em><code>key_col</code></em> &lt;=&gt; NULL;
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>key_col</code></em>=<em><code>const1</code></em> OR
         <em><code>key_col</code></em>=<em><code>const2</code></em> OR
         <em><code>key_col</code></em> IS NULL;
</pre>

<p>Если <code>WHERE</code> включает <em><code>col_name</code></em>
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a>
для столбца, который объявлен как <code>NOT NULL</code>,
то выражение оптимизировано. Эта оптимизация не происходит в случаях, когда
столбец мог бы произвести <code>NULL</code> так или иначе, например, если это
прибывает из таблицы на правой стороне <code>LEFT JOIN</code>.</p>

<p>MySQL может также оптимизировать комбинацию
<code><em><code>col_name</code></em> = <em><code>expr</code></em> OR
<em><code>col_name</code></em> IS NULL</code>,
форма, которая распространена в решенных подзапросах.
<a href="sql.htm#explain"><code>EXPLAIN</code></a> показывает
<a href="#jointype_ref_or_null"><code>ref_or_null</code></a>,
когда эта оптимизация используется.</p>

<p>Эта оптимизация может обработать <a href="funct.htm#operator_is-null">
<code>IS NULL</code></a> для любой ключевой части.</p>
<p>Некоторые примеры запросов, которые оптимизированы, предполагая, что есть
индексирование на столбцах <code>a</code> и <code>b</code> таблицы
<code>t2</code>:
<pre>
SELECT * FROM t1 WHERE t1.a=<em><code>expr</code></em> OR t1.a IS NULL;
SELECT * FROM t1, t2 WHERE t1.a=t2.a OR t2.a IS NULL;
SELECT * FROM t1, t2 WHERE (t1.a=t2.a OR t2.a IS NULL) AND t2.b=t1.b;
SELECT * FROM t1, t2 WHERE t1.a=t2.a AND (t2.b=t1.b OR t2.b IS NULL);
SELECT * FROM t1, t2 WHERE (t1.a=t2.a AND t2.a IS NULL AND ...) OR
         (t1.a=t2.a AND t2.a IS NULL AND ...);
</pre>

<p><a href="#jointype_ref_or_null"><code>ref_or_null</code></a>
выполняет чтение на ссылочном ключе, а затем отдельный поиск строк со
значением ключа <code>NULL</code>.</p>

<p>Оптимизация может обработать только один уровень
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a>.
В следующем запросе MySQL использует ключевые поиски только по выражению
<code>(t1.a=t2.a AND t2.a IS NULL)</code>
и не в состоянии использовать ключевую часть на <code>b</code>:
<pre>
SELECT * FROM t1, t2 WHERE (t1.a=t2.a AND t2.a IS NULL) OR
         (t1.b=t2.b AND t2.b IS NULL);
</pre>

<h4><a name="left-join-optimization"></a>9.2.1.9.
Оптимизация LEFT JOIN и RIGHT JOIN</h4>
<p>MySQL осуществляет <code><em><code>A</code></em> LEFT JOIN
<em><code>B</code></em> join_condition</code> следующим образом:</p>

<ul><li><p>Таблица <em><code>B</code></em> установлена в зависимости от
таблицы <em><code>A</code></em> и всех таблиц, от которых зависит
<em><code>A</code></em>.</li>

<li>Таблица <em><code>A</code></em> установлена в зависимости от всех
таблиц (кроме <em><code>B</code></em>), которые используются в
выражении <code>LEFT JOIN</code>.</li>

<li><code>LEFT JOIN</code> используется, чтобы решить, как получить строки от
таблицы <em><code>B</code></em>. Другими словами, любое условие в
<code>WHERE</code> не используется.</li>

<li>Вся стандартная оптимизация соединения выполнена за исключением того, что
таблица всегда читается после всех таблиц, от которых она зависит.
Если есть круговая зависимость, MySQL выпускает ошибку.</li>

<li>Вся стандартная оптимизация <code>WHERE</code> выполнена.</li>
<li>Если есть строка в <em><code>A</code></em>, которая соответствует
<code>WHERE</code>, но нет никакой строки в <em><code>B</code></em>,
которая соответствует выражению <code>ON</code>, дополнительная строка в
<em><code>B</code></em> произведена со всем
набором столбцов в <code>NULL</code>.</li>

<li>Если Вы используете <code>LEFT JOIN</code>, чтобы найти строки, которые
не существуют в некоторой таблице, и у Вас есть следующий тест:
<code><em><code>col_name</code></em> IS NULL</code> в
<code>WHERE</code>, где <em><code>col_name</code></em>
столбец, который объявлен как <code>NOT NULL</code>, MySQL
прекращает искать больше строк (для особого сочетания ключей) после того, как
он нашел одну строку, которая соответствует <code>LEFT JOIN</code>.
</p></li></ul>

<p>Выполнение <code>RIGHT JOIN</code> походит на
<code>LEFT JOIN</code> с тем, что роли таблиц поменялись местами.</p>
<p>Оптимизатор соединения вычисляет порядок, в котором нужно присоединить
таблицы. Табличный порядок чтения, вызванный <code>LEFT JOIN</code> или
<code>STRAIGHT_JOIN</code> помогает оптимизатору, делая его работу намного
более быстрой, потому что есть меньше табличных перестановок, чтобы
проверить. Отметьте, что это означает, что, если Вы делаете запрос следующего
типа, MySQL делает полный просмотр на <code>b</code> так как <code>LEFT
JOIN</code> предписывает, чтобы это было считано прежде <code>d</code>:
<pre>
SELECT * FROM a JOIN b LEFT JOIN c ON (c.key=a.key)
         LEFT JOIN d ON (d.key=a.key)
         WHERE b.key=d.key;
</pre>

<p>Затруднительное положение в этом случае является обратным порядком, в
котором <code>a</code> и <code>b</code> перечислены в <code>FROM</code>:
<pre>
SELECT * FROM b JOIN a LEFT JOIN c ON (c.key=a.key)
         LEFT JOIN d ON (d.key=a.key)
         WHERE b.key=d.key;
</pre>

<p>Для <code>LEFT JOIN</code>, если <code>WHERE</code>
всегда ложно для произведенной строки <code>NULL</code>,
<code>LEFT JOIN</code> изменен на нормальное соединение. Например,
<code>WHERE</code> был бы ложен в следующем запросе, если
<code>t2.column1</code> <code>NULL</code>:
<pre>
SELECT * FROM t1 LEFT JOIN t2 ON (column1) WHERE t2.column2=5;
</pre>

<p>Поэтому безопасно преобразовать запрос в нормальное соединение:
<pre>
SELECT * FROM t1, t2 WHERE t2.column2=5 AND t1.column1=t2.column1;
</pre>

<p>Это может быть сделано быстрее, потому что MySQL может использовать
таблицу <code>t2</code> до <code>t1</code>, если выполнение привело бы к
лучшему плану запроса. Чтобы обеспечить подсказку о табличном порядке
соединения, надо использовать <code>STRAIGHT_JOIN</code>, см.
<a href="sql.htm#select">раздел 14.2.9</a>. Но <code>STRAIGHT_JOIN</code>
может не дать использовать индекс, потому что это отключает преобразования
полусоединения. См. <a href="#semi-joins">раздел 9.2.1.18.1</a>.
</p>

<h4><a name="nested-loop-joins"></a>9.2.1.10.
Алгоритмы соединения вложенной петли</h4>
<p>MySQLвыполняет соединения между таблицами, используя
алгоритм вложенной петли.</p>

<p><span><strong>Алгоритм соединения вложенной петли</strong></span></p>
<p>Простой алгоритм nested-loop join (NLJ) читает строки из первой таблицы
в петле по одной, передавая каждую строку к вложенной петле, которая
обрабатывает следующую таблицу в соединении. Этот процесс повторен так много
раз, пока там остаются таблицы, к которым присоединятся.</p>

<p>Предположите, что соединение между тремя таблицами <code>t1</code>,
<code>t2</code> и <code>t3</code> должно быть выполнено, используя
следующие типы соединения:
<pre>
Table   Join Type
t1      range
t2      ref
t3      ALL
</pre>

<p>Если простой алгоритм NLJ используется, соединение обработано так:
<pre>
for each row in t1 matching range {
  for each row in t2 matching reference key {
    for each row in t3 {
      if row satisfies join conditions,
         send to client
    }
  }
}
</pre>

<p>Поскольку алгоритм NLJ передает строки по одной от внешних петель
внутренним, он как правило читает таблицы, обработанные во внутренних
петлях, много раз.</p>

<p><span><strong>Алгоритм Block Nested-Loop Join</strong></span></p>
<p>Алгоритм Block Nested-Loop (BNL) присоединяется к буферизации
использования алгоритма чтения строк во внешних петлях, чтобы уменьшить число
раз, которое таблицы во внутренних петлях должны быть считаны.
Например, если 10 строк считаны в буфер, и буфер передают к следующей
внутренней петле, каждое чтение строки во внутренней петле может быть
сравнено со всеми 10 строками в буфере.</p>

<p>MySQL использует буферизацию соединения при этих условиях:</p>
<ul><li><p><a href="server.htm#sysvar_join_buffer_size"><code>
join_buffer_size</code></a> определяет размер каждого буфера соединения.</li>

<li>Буферизация соединения может использоваться, когда соединение имеет тип
<a href="#jointype_all"><code>ALL</code></a> или
<a href="#jointype_index"><code>index</code></a>
(другими словами, когда никакие возможные ключи не могут использоваться, и
полный просмотр сделан, данных или индексных строки, соответственно), или
<a href="#jointype_range"><code>range</code></a>.
Использование буферизации также применимо к внешним соединениям, как описано
в <a href="#bnl-bka-optimization">разделе 9.2.1.14</a>.</li>

<li>Один буфер выделен для каждого соединения, которое может быть
буферизовано, таким образом, данный запрос мог бы быть обработан, используя
многократные буферы соединения.</li>

<li>Буфер соединения никогда не выделяется для первой непостоянной
таблицы, даже если это имело бы тип
<a href="#jointype_all"><code>ALL</code></a> или
<a href="#jointype_index"><code>index</code></a>.</li>

<li>Буфер соединения выделен до выполнения соединения и освобожден после
того, как запрос сделан.</li>
<li>Только столбцы для соединения сохранены в буфере соединения,
не целые строки.</p></li></ul>

<p>Для соединения в качестве примера, описанного ранее для алгоритма NLJ (не
буферизуя), сделано соединение с использованием буферизации соединения:
<pre>
for each row in t1 matching range {
  for each row in t2 matching reference key {
    store used columns from t1, t2 in join buffer
    if buffer is full {
       for each row in t3 {
         for each t1, t2 combination in join buffer {
           if row satisfies join conditions,
           send to client
         }
       }
       empty buffer
    }
  }
}
if buffer is not empty {
   for each row in t3 {
     for each t1, t2 combination in join buffer {
       if row satisfies join conditions,
       send to client
     }
   }
}
</pre>

<p>Если <em><code>S</code></em> размер каждого сохраненного <code>t1</code>,
<code>t2</code> комбинация буфера соединения и <em><code>C</code></em>, числа
комбинаций в буфере, сколько раз таблица <code>t3</code> просмотрена:
<pre>
(<em><code>S</code></em> * <em><code>C</code></em>)/join_buffer_size + 1
</pre>

<p>Число <code>t3</code> уменьшается по мере того, как значение
<a href="server.htm#sysvar_join_buffer_size"><code>join_buffer_size</code>
</a> растет, пока <a href="server.htm#sysvar_join_buffer_size"><code>
join_buffer_size</code></a> является достаточно большим, чтобы содержать все
предыдущие комбинации строки. В этом пункте нет никакой скорости, которая
будет получена, делая это больше.</p>

<h4><a name="nested-join-optimization"></a>9.2.1.11. Оптимизация Nested Join
</h4>
<p>Синтаксис для выражений разрешает вложенные соединения. Следующее
обсуждение обращается к синтаксису соединения, описанному в
<a href="sql.htm#join">разделе 14.2.9.2</a>.</p>

<p>Синтаксис <em><code>table_factor</code></em> расширен по сравнению со
стандартом SQL. Последний принимает только <em><code>table_reference</code>
</em>, но не список их в паре круглых скобок. Это консервативное расширение,
если мы рассматриваем каждую запятую в списке элементов
<em><code>table_reference</code></em> как эквивалент
внутреннему соединению. Например:
<pre>
SELECT * FROM t1 LEFT JOIN (t2, t3, t4)
         ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre>

<p>эквивалентно вот этому:
<pre>
SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)
         ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
</pre>

<p>В MySQL <code>CROSS JOIN</code> эквивалентно
<code>INNER JOIN</code> (они могут заменить друг друга). В стандартном SQL
они не эквивалентны. <code>INNER JOIN</code> используется с
<code>ON</code>, иначе используется <code>CROSS JOIN</code>.</p>

<p>Вообще, круглые скобки могут быть проигнорированы в выражениях соединения,
содержащих только внутренние операции соединения. После удаления круглых
скобок и группировки операций выражение соединения:
<pre>
t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
   ON t1.a=t2.a
</pre>

<p>преобразовывается в выражение:
<pre>
(t1 LEFT JOIN t2 ON t1.a=t2.a) LEFT JOIN t3
    ON t2.b=t3.b OR t2.b IS NULL
</pre>

<p>Все же эти два выражения не эквивалентны. Чтобы видеть это, предположите,
что таблицы <code>t1</code>, <code>t2</code> и <code>t3</code>
имеют следующее состояние:</p>

<ul><li><p>Таблица <code>t1</code> содержит строки
<code>(1)</code>, <code>(2)</code></li>
<li>Таблица <code>t2</code> содержит строки <code>(1,101)</code>.</li>
<li>Таблица <code>t3</code> содержит строки <code>(101)</code>.</p></li></ul>

<p>В этом случае первое выражение возвращает набор результатов, включая
строки <code>(1,1,101,101)</code>, <code>(2,NULL,NULL,NULL)</code>,
тогда как второе выражение возвращает строки <code>(1,1,101,101)</code>,
<code>(2,NULL,NULL,101)</code>:
<pre>
mysql&gt; SELECT * FROM t1 LEFT JOIN
    -&gt;          (t2 LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL)
    -&gt;          ON t1.a=t2.a;
+---+------+------+------+
| a | a    | b    | b    |
+---+------+------+------+
| 1 | 1    |  101 |  101 |
| 2 | NULL | NULL | NULL |
+---+------+------+------+

mysql&gt; SELECT * FROM (t1 LEFT JOIN t2 ON t1.a=t2.a)
    -&gt;          LEFT JOIN t3 ON t2.b=t3.b OR t2.b IS NULL;
+---+------+------+-----+
| a | a    | b    | b   |
+---+------+------+-----+
| 1 | 1    |  101 | 101 |
| 2 | NULL | NULL | 101 |
+---+------+------+-----+
</pre>

<p>В следующем примере внешняя работа соединения используется вместе с
внутренней работой соединения:
<pre>
t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
</pre>

<p>Это выражение не может быть преобразовано в следующее выражение:
<pre>
t1 LEFT JOIN t2 ON t1.a=t2.a, t3.
</pre>

<p>Для данных табличных состояний
эти два выражения возвращают различные наборы строк:
<pre>
mysql&gt; SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a;
+---+------+------+------+
| a | a    | b    | b    |
+---+------+------+------+
| 1 | 1    |  101 |  101 |
| 2 | NULL | NULL | NULL |
+---+------+------+------+

mysql&gt; SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.a, t3;
+---+------+------+-----+
| a | a    | b    | b   |
+---+------+------+-----+
| 1 | 1    |  101 | 101 |
| 2 | NULL | NULL | 101 |
+---+------+------+-----+
</pre>

<p>Поэтому, если мы опускаем круглые скобки в выражении соединения с внешними
операторами соединения, мы могли бы изменить набор результатов
для оригинального выражения.</p>

<p>Более точно, мы не можем проигнорировать круглые скобки в правом
операнде соединения left outer и в левом операнде соединения right join.
Другими словами, мы не можем проигнорировать круглые скобки для внутренних
табличных выражений внешних операций соединения. Круглые скобки для другого
операнда (операнд для внешней таблицы) могут быть проигнорированы.</p>

<p>Следующее выражение:
<pre>
(t1,t2) LEFT JOIN t3 ON P(t2.b,t3.b)
</pre>

<p>эквивалентно этому выражению:
<pre>
t1, t2 LEFT JOIN t3 ON P(t2.b,t3.b)
</pre>
<p>для любых таблиц <code>t1,t2,t3</code> и любого условия
<code>P</code> по признакам <code>t2.b</code> и <code>t3.b</code>.</p>

<p>Всякий раз, когда порядок выполнения операций соединения в выражении
(<em><code>join_table</code></em>) не слева направо, мы говорим о вложенных
соединениях. Рассмотрите следующие запросы:
<pre>
SELECT * FROM t1 LEFT JOIN (t2 LEFT JOIN t3 ON t2.b=t3.b) ON t1.a=t2.a
         WHERE t1.a &gt; 1
SELECT * FROM t1 LEFT JOIN (t2, t3) ON t1.a=t2.a
         WHERE (t2.b=t3.b OR t2.b IS NULL) AND t1.a &gt; 1
</pre>

<p>Те запросы, как полагают, содержат эти вложенные соединения:
<pre>
t2 LEFT JOIN t3 ON t2.b=t3.b
t2, t3
</pre>

<p>Вложенное соединение сформировано в первом запросе с left join, тогда как
во втором запросе это сформировано с inner join.</p>
<p>В первом запросе могут быть опущены круглые скобки: грамматическая
структура выражения соединения продиктует тот же самый порядок выполнения для
операций соединения. Для второго запроса не могут быть опущены круглые
скобки, хотя выражение соединения здесь может интерпретироваться однозначно
без них. В нашем расширенном синтаксисе круглые скобки в <code>(t2, t3)
</code> из второго запроса требуются, хотя теоретически запрос мог быть
разобран без них: у нас все еще была бы однозначная синтаксическая структура
для запроса, потому что <code>LEFT JOIN</code> и <code>ON</code> играл бы
роль левых и правых разделителей для выражения <code>(t2,t3)</code>.</p>

<p>Предыдущие примеры демонстрируют эти пункты:</p>
<ul><li><p>Для выражений соединения, вовлекающих только внутренние соединения
(но не outer join), могут быть удалены круглые скобки. Вы можете удалить
круглые скобки и оценить слева направо (или, фактически, Вы можете оценить
таблицы в любом порядке).</li>

<li>То же самое не истина для внешних соединений или для внешних соединений,
смешанных с внутренними соединениями. Удаление круглых скобок
может изменить результат.</p></li></ul>

<p>Запросы с вложенными внешними соединениями выполнены в той же самой манере
трубопровода как запросы с внутренними соединениями. Более точно,
эксплуатируется изменение алгоритма соединения вложенной петли.
Предположите, что у нас есть запрос соединения более, чем 3 таблиц
<code>T1,T2,T3</code>:
<pre>
SELECT * FROM T1 INNER JOIN T2 ON P1(T1,T2) INNER JOIN T3 ON P2(T2,T3)
         WHERE P(T1,T2,T3).
</pre>

<p>Здесь <code>P1(T1,T2)</code> и <code>P2(T3,T3)</code>
некоторые условия соединения (по выражениям), тогда как
<code>P(T1,T2,T3)</code> условие по столбцам таблиц <code>T1,T2,T3</code>.
</p>

<p>Алгоритм соединения вложенной петли выполнил бы этот
запрос в следующей манере:
<pre>
FOR each row t1 in T1 {
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3)
      {
         t:=t1||t2||t3;
         OUTPUT t;
      }
    }
  }
}
</pre>

<p>Запись <code>t1||t2||t3</code> значит <span><span>строка, созданная,
связывая столбцы строк <code>t1</code>, <code>t2</code> и
<code>t3</code></span></span>. В некоторых из следующих примеров
<code>NULL</code> где имя строки означает, что <code>NULL</code>
используется для каждого столбца той строки. Например,
<code>t1||t2||NULL</code> значит <span><span>строка, созданная, связывая
столбцы строк <code>t1</code>, <code>t2</code> и <code>NULL</code>
для каждого столбца <code>t3</code></span></span>.</p>

<p>Теперь давайте рассматривать запрос с вложенными внешними соединениями:
<pre>
SELECT * FROM T1 LEFT JOIN (T2 LEFT JOIN T3 ON P2(T2,T3)) ON P1(T1,T2)
         WHERE P(T1,T2,T3).
</pre>

<p>Для этого запроса мы изменяем образец вложенной петли:
<pre>
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3;
         OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
       IF P(t1,t2,NULL) {
          t:=t1||t2||NULL;
          OUTPUT t;
       }
       f1=TRUE;
    }
  }
  IF (!f1) {
     IF P(t1,NULL,NULL) {
        t:=t1||NULL||NULL;
        OUTPUT t;
     }
  }
}
</pre>

<p>Вообще для любой вложенной петли для первой внутренней таблицы в
outer join флаг введен, который выключен перед петлей и проверен после петли.
Флаг включен, когда для текущей строки из внешней таблицы, найдено
соответствие из таблицы, представляющей внутренний операнд.
Если в конце петли циклически повторяются, флаг все еще выключен, никакое
соответствие не было найдено для текущей строки внешней таблицы.
В этом случае строка дополнена значениями <code>NULL</code>
для столбцов внутренних таблиц. Строку результата передают к последней
проверке для вывода или в следующую вложенную петлю, но только если строка
удовлетворяет условие соединения всех встроенных внешних соединений.</p>

<p>В нашем примере встроена внешняя таблица соединения,
выраженная следующим выражением:
<pre>
(T2 LEFT JOIN T3 ON P2(T2,T3))
</pre>

<p>Для запроса с внутренними соединениями оптимизатор мог выбрать различный
порядок вложенных петель, такой как этот:
<pre>
FOR each row t3 in T3 {
  FOR each row t2 in T2 such that P2(t2,t3) {
    FOR each row t1 in T1 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3;
         OUTPUT t;
      }
    }
  }
}
</pre>

<p>Для запросов с внешними соединениями оптимизатор может выбрать только
такой порядок, где петли для внешних таблиц предшествуют петлям для
внутренних таблиц. Таким образом, для нашего запроса с внешними
соединениями, только один порядок вложения возможен. Для следующего запроса
оптимизатор оценит два различных вложения:
<pre>
SELECT * T1 LEFT JOIN (T2,T3) ON P1(T1,T2) AND P2(T1,T3)
         WHERE P(T1,T2,T3)
</pre>

<p>Вложения будут такие:
<pre>
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) {
    FOR each row t3 in T3 such that P2(t1,t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3;
         OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
     IF P(t1,NULL,NULL) {
        t:=t1||NULL||NULL;
        OUTPUT t;
     }
  }
}
</pre>

<p>и:
<pre>
FOR each row t1 in T1 {
  BOOL f1:=FALSE;
  FOR each row t3 in T3 such that P2(t1,t3) {
    FOR each row t2 in T2 such that P1(t1,t2) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3;
         OUTPUT t;
      }
      f1:=TRUE
    }
  }
  IF (!f1) {
     IF P(t1,NULL,NULL) {
        t:=t1||NULL||NULL;
        OUTPUT t;
     }
  }
}
</pre>

<p>В обоих вложениях <code>T1</code> должен быть обработан во внешней петле,
потому что она используется во внешнем соединении. <code>T2</code> и
<code>T3</code> используются во внутреннем соединении так, чтобы соединение
было обработано во внутренней петле. Однако, потому что соединение
внутреннее, <code>T2</code> и <code>T3</code> могут быть
обработаны в любом порядке.</p>

<p>Обсуждая алгоритм вложенной петли для внутренних соединений, мы опустили
некоторые детали, воздействие которых на исполнение запроса может быть
огромным. Мы не упоминали так называемый
<span><span>pushed-down</span></span>. Предположите, что в нашем
<code>WHERE</code> условие
<code>P(T1,T2,T3)</code> может быть представлено соединительной формулой:
<pre>
P(T1,T2,T2) = C1(T1) AND C2(T2) AND C3(T3).
</pre>

<p>В этом случае MySQL фактически использует следующую схему вложенной петли
для выполнения запроса с внутренними соединениями:
<pre>
FOR each row t1 in T1 such that C1(t1) {
  FOR each row t2 in T2 such that P1(t1,t2) AND C2(t2)  {
    FOR each row t3 in T3 such that P2(t2,t3) AND C3(t3) {
      IF P(t1,t2,t3) {
         t:=t1||t2||t3;
         OUTPUT t;
      }
    }
  }
}
</pre>

<p>Вы видите, что каждый из <code>C1(T1)</code>,
<code>C2(T2)</code>, <code>C3(T3)</code> продвинуты из самой внутренней петли
к самой внешней петле, где это может быть оценено. Если <code>C1(T1)</code>
очень строгое условие, это условие может очень сократить количество строк от
таблицы <code>T1</code> к внутренним петлям. В результате время выполнения
для запроса может улучшиться.</p>

<p>Для запроса с внешними соединениями <code>WHERE</code>
состоит в том, чтобы быть проверенным только после того, как было найдено,
что у текущей строки от внешней таблицы есть соответствие во внутренних
таблицах. Таким образом, оптимизация продвижения условий из внутренних
вложенных петель не может быть применена непосредственно к запросам
с внешними соединениями. Здесь мы должны ввести условные вниз продвинутые
предикаты, которые охраняют флаги, которые включены,
когда столкнулись с соответствием.</p>

<p>Для нашего примера с внешними соединениями:
<pre>
P(T1,T2,T3)=C1(T1) AND C(T2) AND C3(T3)
</pre>

<p>схема вложенной петли, используя продвинутые вниз условия, похожа на это:
<pre>
FOR each row t1 in T1 such that C1(t1) {
  BOOL f1:=FALSE;
  FOR each row t2 in T2 such that P1(t1,t2) AND (f1?C2(t2):TRUE) {
    BOOL f2:=FALSE;
    FOR each row t3 in T3 such that P2(t2,t3) AND
        (f1&amp;&amp;f2?C3(t3):TRUE) {
      IF (f1&amp;&amp;f2?TRUE:(C2(t2) AND C3(t3))) {
         t:=t1||t2||t3;
         OUTPUT t;
      }
      f2=TRUE;
      f1=TRUE;
    }
    IF (!f2) {
       IF (f1?TRUE:C2(t2) &amp;&amp; P(t1,t2,NULL)) {
          t:=t1||t2||NULL;
          OUTPUT t;
       }
       f1=TRUE;
    }
  }
  IF (!f1 &amp;&amp; P(t1,NULL,NULL)) {
     t:=t1||NULL||NULL;
     OUTPUT t;
  }
}
</pre>

<p>Вообще, вниз продвинутые предикаты могут быть извлечены из условий
соединения <code>P1(T1,T2)</code> и <code>P(T2,T3)</code>.
В этом случае вниз продвинутый предикат охраняет также флаг, который
предотвращает проверку предиката для <code>NULL</code>-дополненной строки,
произведенной соответствующей внешней операцией outer join.</p>

<p>Доступ ключом от одной внутренней таблицы к другой
в том же самом вложенном соединении запрещен, если это вызвано предикатом от
<code>WHERE</code>. Мы могли использовать условный ключевой доступ в этом
случае, но этот метод еще не используется в MySQL.</p>

<h4><a name="outer-join-simplification"></a>9.2.1.12.
Упрощение Outer Join</h4>
<p>Табличные выражения в <code>FROM</code> упрощены во многих случаях.</p>

<p>На этапе анализа запросы с правильными внешними операциями соединений
преобразованы в эквивалентные запросы, содержащие только left join.
В общем случае преобразование выполнено согласно следующему правилу:
<pre>
(T1, ...) RIGHT JOIN (T2,...) ON P(T1,...,T2,...) =
(T2, ...) LEFT JOIN (T1,...) ON P(T1,...,T2,...)
</pre>

<p>Все внутренние выражения соединения формы <code>T1 INNER JOIN
T2 ON P(T1,T2)</code> заменены списком
<code>T1,T2</code>, <code>P(T1,T2)</code>
будучи присоединенным как соединенное к <code>WHERE</code>
(или к условию соединения встраивания, если есть).</p>

<p>Когда оптимизатор оценивает планы относительно запросов с outer join, он
учитывает только планы, где для каждой такой работы к внешним таблицам
получают доступ перед внутренними таблицами. Опции ограничены, потому что
только такие планы позволяют нам выполнить запросы с внешними операциями
соединений вложенной схемой петли.</p>

<p>Предположите, что у нас есть запрос формы:
<pre>
SELECT * T1 LEFT JOIN T2 ON P1(T1,T2) WHERE P(T1,T2) AND R(T2)
</pre>

<p>с <code>R(T2)</code> очень сужающим число соответствия строк от таблицы
<code>T2</code>. Если бы мы выполняли запрос, как это, то у оптимизатор не
было бы никакого другого выбора, кроме доступа к таблице <code>T1</code> до
<code>T2</code>, что может привести к очень неэффективному плану выполнения.
</p>

<p>MySQL преобразовывает такой запрос в запрос без outer join,
если условие <code>WHERE</code> отклонено null.
Условие называют отклоненным нулем для outer join,
если оно оценивается к <code>FALSE</code> или <code>UNKNOWN</code> для
любой <code>NULL</code>-дополненной строки для работы.</p>

<p>Таким образом, для этого внешнего соединения:
<pre>
T1 LEFT JOIN T2 ON T1.A=T2.A
</pre>

<p>Такие условия отклонены нулем:
<pre>
T2.B IS NOT NULL,
T2.B &gt; 3,
T2.C &lt;= T1.C,
T2.B &lt; 2 OR T2.C &gt; 1
</pre>

<p>Такие условия не отклонены нулем:
<pre>
T2.B IS NULL,
T1.B &lt; 3 OR T2.B IS NOT NULL,
T1.B &lt; 3 OR T2.B &gt; 3
</pre>

<p>Общие правила для того, чтобы проверить, отклонено ли условие нулем для
outer join просты. Условие отклонено нулем в следующих случаях:</p>
<ul><li><p>Если это имеет форму <code>A IS NOT NULL</code>, где
<code>A</code> признак любой из внутренних таблиц.</li>

<li>Если это предикат, содержащий ссылку на внутреннюю таблицу, которая
оценивается к <code>UNKNOWN</code>, когда один
из параметров <code>NULL</code>.</li>

<li>Если это соединение, содержащее отклоненное нулем
условие как соединенное.</li>
<li>Если это дизъюнкция отклоненных нулем условий.</p></li></ul>

<p>Условие может быть отклонено нулем для одной внешней работы соединения в
запросе и не отклонено нулем для другой. В запросе:
<pre>
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A LEFT JOIN T3 ON T3.B=T1.B
         WHERE T3.C &gt; 0
</pre>
<p><code>WHERE</code> отклонено нулем для второго outer join, но не отклонено
нулем для первого.</p>

<p>Если <code>WHERE</code> отклонено нулем для outer join в запросе, outer
join соединения заменен inner join.</p>
<p>Например, предыдущий запрос заменен запросом:
<pre>
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A INNER JOIN T3 ON T3.B=T1.B
         WHERE T3.C &gt; 0
</pre>

<p>Для оригинального запроса оптимизатор оценил бы планы, совместимые только
с одним порядком доступа <code>T1,T2,T3</code>.
Для запроса замены это дополнительно рассматривает последовательность доступа
<code>T3,T1,T2</code>.</p>

<p>Преобразование одного outer join может вызвать преобразование другого.
Таким образом, запрос:
<pre>
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A LEFT JOIN T3 ON T3.B=T2.B
         WHERE T3.C &gt; 0
</pre>

<p>будет сначала преобразован в запрос:
<pre>
SELECT * FROM T1 LEFT JOIN T2 ON T2.A=T1.A INNER JOIN T3 ON T3.B=T2.B
         WHERE T3.C &gt; 0
</pre>

<p>который эквивалентен запросу:
<pre>
SELECT * FROM (T1 LEFT JOIN T2 ON T2.A=T1.A), T3
         WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre>

<p>Теперь остающийся outer join может быть заменен inner join,
потому что условие <code>T3.B=T2.B</code>
отклонено нулем и мы получаем запрос без внешних соединений вообще:
<pre>
SELECT * FROM (T1 INNER JOIN T2 ON T2.A=T1.A), T3
         WHERE T3.C &gt; 0 AND T3.B=T2.B
</pre>

<p>Иногда мы преуспеваем в том, чтобы заменить встроенный outer join,
но не можем преобразовать встраивающий outer join. Следующий запрос:
<pre>
SELECT * FROM T1 LEFT JOIN (T2 LEFT JOIN T3 ON T3.B=T2.B) ON T2.A=T1.A
         WHERE T3.C &gt; 0
</pre>

<p>преобразован в:
<pre>
SELECT * FROM T1 LEFT JOIN (T2 INNER JOIN T3 ON T3.B=T2.B)
         ON T2.A=T1.A WHERE T3.C &gt; 0,
</pre>

<p>Это может быть переписано только к форме, все еще содержащей
встроенный outer join:
<pre>
SELECT * FROM T1 LEFT JOIN (T2,T3) ON (T2.A=T1.A AND T3.B=T2.B)
         WHERE T3.C &gt; 0.
</pre>

<p>Пытаясь преобразовать встроенный outer join в запросе, мы должны принять
во внимание, что условие соединения для внешнего встраивания
объединяется с <code>WHERE</code>. В запросе:
<pre>
SELECT * FROM T1 LEFT JOIN (T2 LEFT JOIN T3 ON T3.B=T2.B) ON T2.A=T1.A AND
         T3.C=T1.C WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre>

<p><code>WHERE</code> не отклонено нулем для встроенного outer join, но
но условия соединения outer join <code>T2.A=T1.A AND T3.C=T1.C</code>
отклонено нулем. Таким образом, запрос может быть преобразован в:
<pre>
SELECT * FROM T1 LEFT JOIN (T2, T3) ON T2.A=T1.A AND T3.C=T1.C AND
         T3.B=T2.B WHERE T3.D &gt; 0 OR T1.D &gt; 0
</pre>

<h4><a name="mrr-optimization"></a>9.2.1.13.
Оптимизация мультидиапазонного чтения</h4>
<p>Чтение строк, используя просмотр диапазона на вторичном индексе, может
привести ко многим случайным дисковым доступам к базовой таблице, когда
таблица является большой и не сохранена в кэше механизма хранения. С
оптимизацией Disk-Sweep Multi-Range Read (MRR) MySQL
пытается сократить количество случайного дискового доступа для просмотров
диапазона первым только просмотром индекса и сбором ключей для
соответствующих строк. Тогда ключи сортированы, и строки получены из базовой
таблицы, используя порядок первичного ключа. Побуждение для Disk-sweep MRR
должно сократить количество случайных дисковых доступов и вместо этого
достигнуть более последовательного просмотра данных базовой таблицы.</p>

<p>Оптимизация Multi-Range Read обеспечивает эту выгоду:</p>
<ul><li><p>MRR позволяет строкам данных быть полученными доступ
последовательно, а не в случайном порядке, основанном на индексных кортежах.
Сервер получает ряд индексных кортежей, которые удовлетворяют условиям
запроса, сортирует их согласно порядку ID строк данных и использует
сортированные кортежи, чтобы получить строки данных в этом порядке. Это
делает доступ к данным более эффективным и менее дорогим.</li>

<li>MRR включает пакетную обработку данных запросов о ключевом доступе
для операций, которые требуют доступ к строкам данных через индексные
кортежи, например, просмотры индексного диапазона и equi-соединения, которые
используют индексирование для признака соединения. MRR повторяет по
последовательности диапазоны, чтобы получить индексные кортежи. Поскольку эти
результаты накапливаются, они используются, чтобы получить доступ к
соответствующим строкам данных. Не надо собирать все индексные кортежи
прежде, чем начать читать строки данных.</p></li></ul>

<p>Оптимизация MRR не поддержана со вторичным индексом
на произведенных виртуальных столбцах.</p>
<p>Следующие примеры иллюстрируют, когда оптимизация MRR может быть выгодной:
</p>

<p>Сценарий A: MRR может использоваться для таблиц
<code>InnoDB</code> и <code>MyISAM</code>
для просмотра индексного диапазона и операции equi-соединения.</p>

<ol type="1"><li><p>Часть индексных кортежей накоплена в буфере.</li>
<li>Кортежи в буфере сортированы по их ID строки данных.</li>
<li>К строкам данных получают доступ согласно сортированной
последовательности индексных кортежей.</p></li></ol>

<p>Сценарий B: MRR может использоваться для
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a> для мультидиапазонного индексного
просмотра или выполняя equi-соединение.</p>

<ol type="1"><li><p>Часть диапазонов, возможно, одноключевые диапазоны,
накоплена в буфере на центральном узле, где запрос представлен.</li>
<li>Диапазоны посылают в узлы выполнения, которые обращаются к строке.</li>

<li>Строки, к которым получают доступ, упакованы в пакеты и отосланы
назад к центральному узлу.</li>
<li>Полученные пакеты со строками данных помещены в буфер.</li>
<li>Строки данных считаны из буфера.</p></li></ol>

<p>Когда MRR используется, столбец <code>Extra</code> в выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a> показывает <code>Using MRR
</code>.</p>

<p><code>InnoDB</code> и <code>MyISAM</code> не используют
MRR, если к полным строкам таблицы нельзя получить доступ, чтобы привести к
результату запроса. Дело обстоит так, если к результатам можно привести
полностью на основе информации в индексных кортежах (посредством
<a href="glossary.htm#glos_covering_index">покрытия индекса</a>), MRR
не обеспечивает выгоды.</p>

<p>Запрос в качестве примера, для которого MRR может использоваться,
предполагая, что есть индексирование на <code>(<em><code>key_part1</code>
</em>, <em><code>key_part2</code></em>)</code>:
<pre>
SELECT * FROM t WHERE <em><code>key_part1</code></em> &gt;= 1000 AND
         <em><code>key_part1</code></em> &lt; 2000 AND
         <em><code>key_part2</code></em> = 10000;
</pre>

<p>Индексирование состоит из кортежей <code>(<em><code>key_part1</code></em>,
<em><code>key_part2</code></em>)</code>, упорядоченных сначала по
<em><code>key_part1</code></em>, затем по <em><code>key_part2</code></em>.
</p>

<p>Без MRR индексный просмотр покрывает все индексные кортежи для
<em><code>key_part1</code></em> в диапазоне 1000-2000, независимо от
<em><code>key_part2</code></em> в этих кортежах. Просмотр делает
дополнительную работу до такой степени, что кортежи в диапазоне содержат
значения <em><code>key_part2</code></em> кроме 10000.</p>

<p>С MRR просмотр разбит на многократные диапазоны, каждый
для единственного значения <em><code>key_part1</code></em> (1000, 1001, ...,
1999). Каждый из этих просмотров должен искать только кортежи с
<em><code>key_part2</code></em> = 10000.
Если индексирование содержит много кортежей для которых
<em><code>key_part2</code></em> не 10000, результаты MRR
MRR во многом меньше считанных индексных кортежей.</p>

<p>Чтобы выразить это примечание интервала использования, не-MRR просмотр
должен исследовать индексный диапазон <code>[{1000, 10000}, {2000, MIN_INT})
</code>, который может включать много кортежей кроме тех, для которых
<em><code>key_part2</code></em> = 10000. Просмотр MRR
исследует многократные интервалы <code>[{1000, 10000}]</code>, ...,
<code>[{1999, 10000}]</code>, которые включают только кортежи с
<em><code>key_part2</code></em> = 10000.</p>

<p>Два флага в <a href="server.htm#sysvar_optimizer_switch"><code>
optimizer_switch</code></a> обеспечивают интерфейс к использованию
оптимизации MRR. Флаг <code>mrr</code> управляет, включен ли MRR. Если
<code>mrr</code> = <code>on</code>, флаг <code>mrr_cost_based</code>
управляет, пытается ли оптимизатор сделать выбор на основе издержек между
использованием и не использованием MRR (<code>on</code>) или использование
MRR возможно когда бы ни было (<code>off</code>). По умолчанию
<code>mrr</code> = <code>on</code> и <code>mrr_cost_based</code> =
<code>on</code>. См. <a href="#switchable-optimizations">раздел
9.9.2</a>.</p>

<p>Для MRR механизм хранения использует значение
<a href="server.htm#sysvar_read_rnd_buffer_size"><code>read_rnd_buffer_size
</code></a> как направляющую линию для того, сколько памяти это может
выделить для буфера. Механизм использует до
<a href="server.htm#sysvar_read_rnd_buffer_size"><code>read_rnd_buffer_size
</code></a> байт и определяет число диапазонов, чтобы
обработать в единственном проходе.</p>

<h4><a name="bnl-bka-optimization"></a>9.2.1.14.
Вложенная петля блока и пакетные ключевые соединения доступа</h4>
<p>В MySQL алгоритм Batched Key Access (BKA) Join
доступен, который использует индексный доступ к таблице, к которой
присоединяются, и буфер соединения. Алогритм BKA поддерживает внутреннее
соединение, внешнее соединение, и операции полусоединения, включая вложенные
внешние соединения. Выгода BKA включает улучшенную работу соединения из-за
более эффективного табличного просмотра. Кроме того, алгоритм Block
Nested-Loop (BNL) Join, ранее используемый только для внутренних соединений,
расширен и может использоваться для внешнего соединения и операций
полусоединения, включая вложенные внешние соединения.</p>

<p>Следующие разделы обсуждают буферное управление соединением, которое лежит
в основе расширения оригинального алгоритма BNL, расширенного алгоритма BNL,
и алгоритма BKA. См. <a href="#semi-joins">раздел 9.2.1.18.1</a>.
</p>

<h5><a name="join-buffer-management"></a>9.2.1.14.1.
Буферное управление соединением для алгоритмов
Block Nested-Loop и Batched Key Access</h5>
<p>MySQL Server может использовать буферы соединения, чтобы выполнить не
только внутренние соединения без индексного доступа к внутренней таблице, но
также внешние соединения и полусоединения, которые появляются после
выравнивания подзапроса. Кроме того, буфер соединения может эффективно
использоваться, когда есть индексный доступ к внутренней таблице.</p>

<p>Буферный управленческий код соединения немного более эффективно использует
буферное пространство соединения, храня значения интересных столбцов строки:
никакие дополнительные байты не выделены в буферах для столбца строки, если
его значение <code>NULL</code>, и минимальное число байтов выделено для
любого значения типа <a href="types.htm#char"><code>VARCHAR</code></a>.</p>

<p>Код поддерживает два типа буферов, регулярные и возрастающие.
Предположите, что буфер соединения <code>B1</code> используется, чтобы
присоединиться к таблицам <code>t1</code> и  <code>t2</code> и к результату
этой работы присоединяются с таблицей <code>t3</code> с
использованием буфера соединения <code>B2</code>:</p>

<ul><li><p>Регулярный буфер соединения содержит столбцы от каждого операнда
соединения. Если <code>B2</code> регулярный буфер соединения, каждая строка
<em><code>r</code></em>, помещенная в <code>B2</code>,
составлен из столбцов строки <em><code>r1</code></em> из <code>B1</code> и
интересные столбцы соответствующей строки это <em><code>r2</code></em> из
<code>t3</code>.</li>

<li>Возрастающий буфер соединения содержит только столбцы от строк таблицы,
произведенной вторым операндом соединения. Таким образом, это является
возрастающим к строке от первого буфера операнда. Если <code>B2</code>
возрастающий буфер соединения, это содержит интересные столбцы строки
<em><code>r2</code></em> вместе со ссылкой к строке
<em><code>r1</code></em> из <code>B1</code>.</p></li></ul>

<p>Возрастающие буферы соединения являются всегда возрастающими относительно
буфера соединения от более ранней работы соединения, таким образом, буфер от
первой работы соединения всегда регулярный. В этом примере буфер
<code>B1</code> используемый, чтобы присоединиться к таблицам <code>t1</code>
и <code>t2</code>, должен быть регулярным.</p>

<p>Каждая строка возрастающего буфера, используемого для работы соединения,
содержит только интересные столбцы строки от таблицы, к которой
присоединятся. Эти столбцы увеличены со ссылкой на интересные столбцы
соответствующей строки от таблицы, произведенной первым операндом соединения.
Несколько строк в возрастающем буфере могут обратиться к той же самой строке
<em><code>r</code></em>, чьи столбцы сохранены в предыдущих буферах
соединения, поскольку все эти строки соответствуют строке
<em><code>r</code></em>.</p>

<p>Возрастающие буферы включают менее частое копирование столбцов от буферов,
используемых для предыдущих операций соединения. Это обеспечивает сбережения
в буферном пространстве, потому что в общем случае строка, произведенная
первым операндом соединения, может быть соответствующей нескольким строкам,
произведенным вторым операндом соединения. Не надо делать несколько копий
строки от первого операнда. Возрастающие буферы также обеспечивают сбережения
во время обработки из-за сокращения времени копирования.</p>

<p>Флаги <code>block_nested_loop</code> и
<code>batched_key_access</code> переменной
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> управляют, как оптимизатор использует алгоритмы Block Nested-Loop и
Batched Key Access join. По умолчанию <code>block_nested_loop</code> =
<code>on</code> и <code>batched_key_access</code> = <code>off</code>. См.
<a href="#switchable-optimizations">раздел 9.9.2</a>.</p>
<p>См. <a href="#semi-joins">раздел 9.2.1.18.1</a>.</p>

<h5><a name="bnl-optimization"></a>9.2.1.14.2.
Алгоритм Block Nested-Loop для Outer Join и Semi-Join</h5>
<p>Оригинальное выполнение MySQL алгоритма BNL расширено, чтобы поддержать
внешнее соединение и операции полусоединения.</p>

<p>Когда эти операции выполнены с буфером соединения, каждая строка,
помещенная в буфер, поставляется с флагом соответствия.</p>
<p>Если outer join выполнен, используя буфер соединения, каждая строка
таблицы, произведенной вторым операндом, проверена на соответствие против
каждой строки в буфере соединения. Когда соответствие найдено, новая
расширенная строка сформирована (оригинальная строка плюс столбцы от второго
операнда) и послана на дальнейшие расширения остающимися операциями
соединения. Кроме того, флаг соответствия соответствующей строки в буфере
включен. После того, как все строки таблицы, к которой присоединятся, были
исследованы, буфер соединения просмотрен. Каждая строка от буфера, которой
не включили флаг соответствия, расширена дополнениями <code>NULL</code>
(значения <code>NULL</code> для каждого столбца во втором операнде), и
послана за дальнейшими расширениями остающимися операциями соединения.</p>

<p>Флаг <code>block_nested_loop</code> переменной
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> управляет, как оптимизатор использует алгоритм Block Nested-Loop.
По умолчанию <code>block_nested_loop</code> = <code>on</code>. См.
<a href="#switchable-optimizations">раздел 9.9.2</a>.</p>

<p>В выводе <a href="sql.htm#explain"><code>EXPLAIN</code></a>
использование BNL для таблицы показано, когда <code>Extra</code>
содержит <code>Using join buffer (Block Nested Loop)</code> и
<code>type</code> = <a href="#jointype_all"><code>ALL</code></a>,
<a href="#jointype_index"><code>index</code></a> или
<a href="#jointype_range"><code>range</code></a>.</p>
<p>См. <a href="#semi-joins">раздел 9.2.1.18.1</a>.</p>

<h5><a name="bka-optimization"></a>9.2.1.14.3. Batched Key Access</h5>
<p>MySQL Server осуществляет метод присоединяющихся таблиц, названный
Batched Key Access (BKA). BKA может быть применен, когда есть индексированный
доступ к таблице, произведенной вторым операндом соединения. Как алгоритм
соединения BNL, алгоритм соединения BKA использует буфер соединения, чтобы
накопить интересные столбцы строк, произведенных первым операндом работы
соединения. Тогда алгоритм BKA создает ключи, чтобы получить доступ к
таблице, к которой присоединятся для всех строк в буфере, и отправляет эти
ключи в пакете к механизму базы данных для индексных поисков.
Ключи представлены механизму посредством интерфейса Multi-Range Read (MRR)
(см. <a href="#mrr-optimization">раздел 9.2.1.13</a>).
После представления ключей функции механизма MRR выполняют поиски в
индексе оптимальным способом, принося строки таблицы, к которой
присоединяются, найденные этими ключами, и начинают снабжать алгоритм
соединения BKA соответствием строк. Каждая строка соответствия идет вместе со
ссылкой на строку в буфере соединения.</p>

<p>При применении BKA значение
<a href="server.htm#sysvar_join_buffer_size"><code>join_buffer_size</code>
</a> определяет, насколько большой пакет ключей находится в каждом запросе к
механизму хранения. Чем больше буфер, тем более последовательный доступ будет
к правой таблице работы соединения, что может значительно улучшить работу.
</p>

<p>При применении BKA флаг <code>batched_key_access</code> в переменной
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> должен быть установлен в <code>on</code>. BKA использует MRR,
таким образом, флаг <code>mrr</code> должен также быть <code>on</code>.
В настоящее время, оценка стоимости для MRR слишком пессимистична.
Следовательно, также необходимо <code>mrr_cost_based</code> = <code>off
</code> для использования BKA. Следующая установка включает BKA:
<pre>
mysql&gt; SET optimizer_switch='mrr=on,mrr_cost_based=off,batched_key_access=on';
</pre>

<p>Есть два сценария, которые выполняют функции MRR:</p>
<ul><li><p>Первый сценарий используется для обычных основанных на диске
механизмов хранения, таких как <a href="innodb.htm"><code>InnoDB</code></a> и
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>.
Для этих механизмов обычно ключи для всех строк буфера соединения
представлены интерфейсу MRR сразу. Определенные для механизма функции MRR
делают индексные поиски для представленных ключей, получают ID
строки (или первичные ключи) от них, и затем приносят строки для всех этих
выбранных ID строк одну за другой по запросу от алгоритма BKA.
Каждая строка возвращена со ссылкой ассоциации, которая включает доступу к
соответствующей строке в буфере соединения. Строки принесены функциями MRR
оптимальным способом: они забраны в порядке ID строк (primary key).
Это улучшает работу, потому что чтения находятся в дисковом порядке,
а не случайном порядке.</li>

<li>Второй сценарий используется для отдаленных механизмов хранения, таких
как <a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>. Пакет ключей для части строк от буфера
соединения, вместе с их ассоциациями, посылает MySQL Server (узел SQL) узлам
данных MySQL Cluster. В свою очередь, узел SQL получает пакет (или несколько
пакетов) соответствия строк вместе с соответствующими ассоциациями. Алгоритм
соединения BKA берет эти строки и создает новые строки, к которым
присоединяются. Тогда новый набор ключей посылают в узлы данных, и строки от
возвращенных пакетов используются, чтобы создать новые строки, к которым
присоединяются. Процесс продолжается, пока последние ключи от буфера
соединения не посылают в узлы данных, и узел SQL не получит и не
присоединится ко всем строкам, соответствующим этим ключам. Это улучшает
работу, потому что меньше имеющих ключ пакетов, посланных узлом SQL в узлы
данных, означает меньше путешествий туда и обратно между нем и узлами данных.
</p></li></ul>

<p>С первым сценарием часть буфера соединения сохранена, чтобы сохранить
ID строки (первичные ключи), выбранные индексными
поисками и прошедшими в качестве параметра к функциям MRR.</p>

<p>Нет никакого специального буфера, чтобы сохранить ключи, созданные для
строк из буфера соединения. Вместо этого функцию, которая создает ключ для
следующей строки в буфере, передают в качестве параметра к функциям MRR.</p>

<p>В выводе <a href="sql.htm#explain"><code>EXPLAIN</code></a> использование
BKA для таблицы показано, когда значение <code>Extra</code> содержит
<code>Using join buffer (Batched Key Access)</code> и <code>type</code>
<a href="#jointype_ref"><code>ref</code></a> или
<a href="#jointype_eq_ref"><code>eq_ref</code></a>.</p>

<h4><a name="order-by-optimization"></a>9.2.1.15. Оптимизация ORDER BY</h4>
<p>В некоторых случаях MySQL может использовать индексирование, чтобы
удовлетворить <code>ORDER BY</code>, не делая дополнительную сортировку.</p>

<p>Индексирование может также использоваться даже если <code>ORDER BY</code>
не соответствует индексу точно, пока все неиспользованные части индекса
и всех дополнительных столбцов <code>ORDER BY</code> это константы в
<code>WHERE</code>. Следующие запросы используют индексирование, чтобы решить
часть <code>ORDER BY</code>:
<pre>
SELECT * FROM t1 ORDER BY <em><code>key_part1</code></em>,
         <em><code>key_part2</code></em>,... ;
SELECT * FROM t1
         WHERE <em><code>key_part1</code></em> = <em><code>constant</code></em>
         ORDER BY <em><code>key_part2</code></em>;
SELECT * FROM t1 ORDER BY <em><code>key_part1</code></em> DESC,
         <em><code>key_part2</code></em> DESC;
SELECT * FROM t1 WHERE <em><code>key_part1</code></em> = 1
         ORDER BY <em><code>key_part1</code></em> DESC,
         <em><code>key_part2</code></em> DESC;
SELECT * FROM t1 WHERE <em><code>key_part1</code></em> &gt; <em><code>constant</code></em>
         ORDER BY <em><code>key_part1</code></em> ASC;
SELECT * FROM t1 WHERE <em><code>key_part1</code></em> &lt; <em><code>constant</code></em>
         ORDER BY <em><code>key_part1</code></em> DESC;
SELECT * FROM t1
         WHERE <em><code>key_part1</code></em> = <em><code>constant1</code></em>
         AND <em><code>key_part2</code></em> &gt; <em><code>constant2</code></em>
         ORDER BY <em><code>key_part2</code></em>;
</pre>

<p>В некоторых случаях MySQL не <span><em>может</em></span> использовать
индекс, чтобы решить <code>ORDER BY</code>, хотя это все еще использует
индекс, чтобы найти строки, которые соответствуют <code>WHERE</code>.
Эти случаи включают следующее:</p>

<ul><li><p>Использование запроса <code>ORDER BY</code> на различных индексах:
<pre>
SELECT * FROM t1 ORDER BY <em><code>key1</code></em>,
         <em><code>key2</code></em>;
</pre></li>

<li>Использование запроса <code>ORDER BY</code> на
непоследовательных частях индекса:
<pre>
SELECT * FROM t1 WHERE <em><code>key2</code></em>=<em><code>constant</code></em>
         ORDER BY <em><code>key_part2</code></em>;
</pre></li>

<li>Смесь запросов <code>ASC</code> и <code>DESC</code>:
<pre>
SELECT * FROM t1 ORDER BY <em><code>key_part1</code></em> DESC,
         <em><code>key_part2</code></em> ASC;
</pre></li>

<li>Индексирование, которое используется, чтобы принести строки,
отличается от используемого в <code>ORDER BY</code>:
<pre>
SELECT * FROM t1 WHERE <em><code>key2</code></em>=<em><code>constant</code></em>
         ORDER BY <em><code>key1</code></em>;
</pre></li>

<li>Использование запроса <code>ORDER BY</code> с выражением, которое
включает термины, кроме имени столбца индекса:
<pre>
SELECT * FROM t1 ORDER BY ABS(<em><code>key</code></em>);
SELECT * FROM t1 ORDER BY -<em><code>key</code></em>;
</pre></li>

<li>Запрос присоединяется ко многим таблицам, и столбцы в
<code>ORDER BY</code> не все от первой непостоянной таблицы, которая
используется, чтобы получить строки. Это первая таблица в выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a>, у которой нет
типа соединения <a href="#jointype_const"><code>const</code></a>.
</li>

<li>Запрос имеет отличающиеся выражения
<code>ORDER BY</code> и <code>GROUP BY</code>.</li>
<li>Есть индексирование на только приставке столбца, названного в
<code>ORDER BY</code>. В этом случае индексирование не может использоваться,
чтобы полностью решить порядок сортировки. Например, если только первые 10
байтов столбца <a href="types.htm#char"><code>CHAR(20)</code></a>
индексированы, индекс не может отличить значения после 10-го байта и
будет необходим <code>filesort</code>.</li>
<li>Индексирование не хранит строки в порядке. Например, это истина для
индекса <code>HASH</code> в таблице <code>MEMORY</code>.</p></li></ul>

<p>Доступность индексирования для того, чтобы сортировать может быть
затронута при помощи псевдонимов столбца. Предположите, что столбец
<code>t1.a</code> индексирован. В этом запросе название столбца в
избранном списке <code>a</code>.Это обращается к <code>t1.a</code>, так
что для ссылки на <code>a</code> в <code>ORDER BY</code>
индексирование может использоваться:
<pre>
SELECT a FROM t1 ORDER BY a;
</pre>

<p>В этом запросе название столбца в избранном списке также <code>a</code>,
но это имя псевдонима. Это обращается к <code>ABS(a)</code>, так что для
ссылки на <code>a</code> в <code>ORDER BY</code> индекс
не может использоваться:
<pre>
SELECT ABS(a) AS a FROM t1 ORDER BY a;
</pre>

<p>В следующем запросе <code>ORDER BY</code> обращается к имени, которое не
является названием столбца в избранном списке. Но есть столбец в
<code>t1</code> с именем <code>a</code>, так что <code>ORDER BY</code>
использует это, и индекс может использоваться. Получающийся порядок
сортировки может абсолютно отличаться от порядка для <code>ABS(a)</code>.
<pre>
SELECT ABS(a) AS b FROM t1 ORDER BY a;
</pre>

<p>По умолчанию MySQL сортирует все запросы <code>GROUP BY
<em><code>col1</code></em>, <em><code>col2</code></em>, ...</code>
как будто Вы определили <code>ORDER BY <em><code>col1</code></em>,
<em><code>col2</code></em>, ...</code> в запросе. Если Вы включаете явный
<code>ORDER BY</code>, который содержит тот же самый список столбца, MySQL
оптимизирует это без потери скорости, хотя сортировка все еще происходит.</p>

<p>Доверие неявному <code>GROUP BY</code> устарело.
Чтобы достигнуть определенного порядка сортировки сгруппированных
результатов, предпочтительно использовать явный <code>ORDER BY</code>.
<code>GROUP BY</code> это расширение MySQL, которое может измениться в
будущем выпуске, например, чтобы позволить оптимизатору упорядочить
группировки в любой манере, которую это считает самым эффективной и
избегать издержек сортировки.</p>

<p>Если запрос включает <code>GROUP BY</code>, но Вы хотите избежать
сортировки результата, Вы можете подавить сортировку, определяя
<code>ORDER BY NULL</code>. Например:
<pre>
INSERT INTO foo
SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL;
</pre>

<p>Оптимизатор может все еще хотеть использовать сортировку, чтобы
осуществить группирующиеся операции. <code>ORDER BY NULL</code>
подавляет сортировку результата, но не предшествующую сортировку, сделанную,
группируя операции, чтобы определить результат.</p>

<p>С <a href="sql.htm#explain"><code>EXPLAIN SELECT ... ORDER BY</code></a>
Вы можете проверить, может ли MySQL использовать индекс, чтобы решить запрос.
Не может, если Вы видите <code>Using filesort</code> в столбце <code>Extra
</code>, см. <a href="#using-explain">раздел 9.8.1</a>. Filesort
использует формат хранения строки фиксированной длины, подобный используемому
механизмом хранения <a href="storage.htm#memory-storage-engine"><code>MEMORY
</code></a>. Типы переменной длины, такие как
<a href="types.htm#char"><code>VARCHAR</code></a>,
сохранены, используя фиксированную длину.</p>

<p>MySQL имеет два алгоритма <code>filesort</code>
для сортировки и получения результатов. Оригинальный метод использует только
столбцы <code>ORDER BY</code>. Измененный метод использует не только столбцы
<code>ORDER BY</code>, а все столбцы в запросе.</p>

<p>Оптимизатор выбирает, который алгоритм <code>filesort</code>
использовать. Это обычно использует измененный алгоритм кроме тех случаев,
когда вовлечены столбцы <a href="types.htm#blob"><code>BLOB</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>, тогда это использует
оригинальный алгоритм. Для обоих алгоритмов размер буфера сортировки это
<a href="server.htm#sysvar_sort_buffer_size"><code>sort_buffer_size</code>
</a>.</p>

<p>Оригинальный алгоритм работает следующим образом:</p>
<ol type="1"><li><p>Считать все строки согласно ключу или табличному
просмотру. Пропустить строки, которые не соответствуют <code>WHERE</code>.
</li>

<li>Для каждой строки в буфере сортировки хранится кортеж, состоящий из пары
значений (значение ключа сортировки и ID строки).</li>
<li>Если все пары вписываются в буфер, никакой временный файл не создается.
Иначе, когда буфер становится полным, выполняется qsort (quicksort)
в памяти и пишется результат во временный файл. Сохраняется указатель
на отсортированный блок.</li>

<li>Повторите предыдущие шаги, пока все строки не считаны.</li>
<li>Сделайте мультислияние до <code>MERGEBUFF</code> (7) к одному блоку в
другом временном файле. Повторите, пока все блоки от первого файла не будут
во втором файле.</li>

<li>Повторите пока нет меньше, чем <code>MERGEBUFF2</code> (15) блоков.</li>
<li>На последнем мультислиянии только ID строки (последняя часть пары
значения) написано в файл результата.</li>

<li>Считайте строки в сортированном порядке, используя ID
строки в файле результата. Чтобы оптимизировать это, читайте в большом блоке
ID строки, сортируйте их, и используйте их, чтобы считать строки в
сортированном порядке в буфер строки. Размер буфера строки
<a href="server.htm#sysvar_read_rnd_buffer_size"><code>read_rnd_buffer_size
</code></a>. Код для этого шага находится в исходном файле
<code>sql/records.cc</code>.</p></li></ol>

<p>Одна проблема с этим подходом состоит в том, что он читает строки дважды:
во время оценки <code>WHERE</code> и снова после сортировки пар значения. И
даже если к строкам получили доступ последовательно в первый раз (например,
если сканирование таблицы сделано), во второй раз к ним получают доступ
беспорядочно. Ключи сортировки упорядочены, но позиции строк нет.</p>

<p>Измененный алгоритм <code>filesort</code>
включает оптимизацию, чтобы избежать читать строки дважды:
это делает запись значения ключа сортировки, но вместо ID
строки, это делает запись столбцов, на которые ссылается запрос. Измененный
<code>filesort</code> работает так:</p>

<ol type="1"><li><p>Считайте строки, которые соответствуют <code>WHERE
</code>.</li>
<li>Для каждой строки в буфере сортировки хранится кортеж, состоящий из
значения ключа сортировки и столбцов, на которые ссылается запрос.</li>

<li>Когда буфер становится полным, кортежи сортируются значением ключа
в памяти, и это пишется во временный файл.</li>
<li>После сортировки слияния временного файла получите строки в сортированном
порядке, но считайте столбцы, требуемые запросом непосредственно от
сортированных кортежей, а не получая доступ к таблице во второй раз.
</p></li></ol>

<p>Кортежи, используемые измененным <code>filesort</code>
длинней, чем пары, используемые оригинальным алгоритмом, и меньше их
помещается в буфер. В результате для дополнительного ввода/вывода возможно
сделать измененный подход медленнее. Чтобы избежать замедления, оптимизатор
использует измененный алгоритм, только если полный размер дополнительных
столбцов в кортеже не превышает значения
<a href="server.htm#sysvar_max_length_for_sort_data"><code>
max_length_for_sort_data</code></a>. Признаком установки значения этой
переменной слишком высоко является комбинация высокой дисковой деятельности и
низкой деятельности центрального процессора.</p>

<p>Измененный алгоритм <code>filesort</code>
включает дополнительную оптимизацию, разработанную, чтобы позволить большему
количеству кортежей вписаться в буфер: для дополнительных столбцов типа
<code>CHAR</code>, <code>VARCHAR</code> или любого nullable типа данных
фиксированного размера, значения упакованы. Например, без упаковки
значение столбца <code>VARCHAR(255)</code>, содержащее только 3 символа,
берет 255 символов в буфере сортировки. С упаковкой значение требует только 3
символов плюс двухбайтовый индикатор длины. Значения <code>NULL</code>
требуют только битовой маски.</p>

<p>Для данных, содержащих пакуемые строки короче, чем максимальная длина
столбца или многие значения <code>NULL</code>, больше записей вписывается в
буфер сортировки. Это улучшает сортировку буфера в памяти
и исполнение основанной на диске временной сортировки слияния файла.</p>

<p>В случаях края упаковка может быть невыгодной: если пакуемая строка это
максимальная длина столбца или есть немного значений <code>NULL</code>,
место, требуемое для индикаторов длины, сокращает количество записей, которые
вписываются в буфер, и сортировка медленнее в памяти и на диске.</p>

<p>Есои <code>filesort</code> сделан, вывод
<a href="sql.htm#explain"><code>EXPLAIN</code></a> включает
<code>Using filesort</code> в столбце <code>Extra</code>. Кроме того, вывод
трассировки оптимизатора включает блок <code>filesort_summary</code>:
<pre>
"filesort_summary": {"rows": 100, "examined_rows": 100,
                     "number_of_tmp_files": 0, "sort_buffer_size": 25192,
                     "sort_mode": "&lt;sort_key,
                     packed_additional_fields&gt;"}
</pre>

<p><code>sort_mode</code> предоставляет информацию об используемом алгоритме
<code>filesort</code> и содержании кортежей в буфере:</p>
<ul><li><p><code>&lt;sort_key, rowid&gt;</code>: Это указывает на
использование оригинального алгоритма. Буферные кортежи сортировки это
пары, которые содержат значение ключа и ID оригинальной строки таблицы.
Кортежи сортированы значением ключа сортировки, и
ID строки используется, чтобы считать строку из таблицы.</li>

<li><code>&lt;sort_key, additional_fields&gt;</code>:
Это указывает на использование измененного алгоритма.
Буферные кортежи содержат значение ключа
и столбцы, на которые ссылается запрос. Кортежи сортированы значением ключа,
и значения столбцов считаны непосредственно из кортежа.</li>

<li><code>&lt;sort_key, packed_additional_fields&gt;</code>:
Это указывает на использование измененного алгоритма. Буферные кортежи
содержат значение ключа и упакованные столбцы, на которые ссылается запрос.
Кортежи сортированы значением ключа, и значения столбцов считаны
непосредственно из кортежа.</p></li></ul>

<p>Предположите, что таблица <code>t1</code> имеет четыре столбца
<code>VARCHAR</code>: <code>a</code>, <code>b</code>, <code>c</code> и
<code>d</code>, и что оптимизатор использует для
этого запроса <code>filesort</code>:
<pre>
SELECT * FROM t1 ORDER BY a, b;
</pre>

<p>Запрос сортируется по <code>a</code> и <code>b</code>,
но возвращает все столбцы, таким образом, столбцы, на которые ссылается
запрос, это <code>a</code>, <code>b</code>, <code>c</code> и
<code>d</code>. В зависимости от алгоритма <code>filesort</code>,
запрос выполняется следующим образом:</p>

<p>Для оригинального алгоритма у буферных кортежей
есть это содержание:
<pre>
(фиксированный размер значения a, фиксированный размер
значения b, ID строки в t1)
</pre>

<p>Оптимизатор сортирует на значениях фиксированного размера. После
сортировки оптимизатор читает кортежи в порядке и использует ID строки
в каждом кортеже, чтобы считать строки из <code>t1</code>, чтобы
получить избранные значения столбцов списка.</p>

<p>Для измененного алгоритма без упаковки у буферных кортежей
есть это содержание:
<pre>
(фиксированный размер значения a, фиксированный размер значения b,
значение a, значение b, значение c, значение d)
</pre>

<p>Оптимизатор сортирует на значениях фиксированного размера. После
сортировки оптимизатор читает кортежи в порядке и использует значения для
<code>a</code>, <code>b</code>, <code>c</code> и <code>d</code>, чтобы
получить избранные значения столбцов списка без чтения <code>t1</code>.</p>

<p>Для измененного алгоритма с упаковкой у буферных кортежей
есть это содержание:
<pre>
(фиксированный размер значения a, фиксированный размер значения b,
длина a, упакованное значение a, длина b, упакованное значение b,
длина c, упакованное значение c, длина d, упакованное значение d)
</pre>

<p>Если что-то из <code>a</code>, <code>b</code>,
<code>c</code> или <code>d</code> <code>NULL</code>,
они не занимают места в буфере, кроме как в битовой маске.</p>

<p>Оптимизатор сортирует на значениях фиксированного размера. После
сортировки оптимизатор читает кортежи в порядке и использует значения для
<code>a</code>, <code>b</code>, <code>c</code> и <code>d</code>, чтобы
получить избранные значения столбцов списка без чтения <code>t1</code>.</p>

<p>Для медленных запросов, для которых <code>filesort</code>
не используется, попытайтесь понизить
<a href="server.htm#sysvar_max_length_for_sort_data"><code>
max_length_for_sort_data</code></a>, к значению, которое является
соответствующим, чтобы вызвать <code>filesort</code>.</p>

<p>Чтобы ускорить <code>ORDER BY</code>, проверьте, можете ли Вы заставить
MySQL использовать индекс, а не дополнительную фазу сортировки.
Если это невозможно, Вы можете попробовать следующие стратегии:</p>

<ul><li><p>Увеличьте <a href="server.htm#sysvar_sort_buffer_size"><code>
sort_buffer_size</code></a>. Идеально, значение должно быть достаточно
большим для всего набора результатов, чтобы поместиться в буфер, но в
минимуме значение должно быть достаточно большим, чтобы
приспособить пятнадцать кортежей.</p>

<p>Примите во внимание, что размер значений столбцов, сохраненных в буфере,
затронут <a href="server.htm#sysvar_max_sort_length"><code>max_sort_length
</code></a>. Например, если кортежи хранят значения длинных строковых
столбцов, и Вы увеличиваете значение
<a href="server.htm#sysvar_max_sort_length"><code>max_sort_length</code></a>,
размер буферных кортежей также может потребовать, чтобы Вы увеличили и
<a href="server.htm#sysvar_sort_buffer_size"><code>sort_buffer_size</code>
</a>. Для значений столбцов, вычисленных в результате строковых выражений
(таких как те, которые вызывают оцененную к строке функцию), алгоритм
<code>filesort</code> не может сказать максимальную длину значений выражения,
таким образом, это должно выделить
<a href="server.htm#sysvar_max_sort_length"><code>max_sort_length</code></a>
байт для каждого кортежа.</p>

<p>Чтобы контролировать число проходов слияния, проверьте
<a href="server.htm#statvar_Sort_merge_passes"><code>Sort_merge_passes</code>
</a>.</li>

<li>Увеличьте <a href="server.htm#sysvar_read_rnd_buffer_size"><code>
read_rnd_buffer_size</code></a>.</li>
<li>Используйте меньше RAM на строку, объявляя столбцы строго столь большими,
как они должны хранить значения. Например, <code>CHAR(16)</code> лучше, чем
<code>CHAR(200)</code>, если значения никогда не превышают 16 символов.</li>

<li>Измените <a href="server.htm#sysvar_tmpdir"><code>tmpdir</code></a>,
чтобы указать на специализированную файловую систему с большим количеством
свободного пространства. Переменное значение может перечислить несколько
путей, которые используются круговым способом, Вы можете использовать эту
функцию, чтобы распространить загрузку на несколько каталогов. Пути должны
быть отделены символами двоеточия (<code>:</code>) в Unix и символами
точки с запятой (<code>;</code>) в Windows. Пути должны назвать каталоги в
файловых системах, расположенных на
различных <span><em>физических</em></span> дисках.</p></li></ul>

<p>Если индексирование не используется для <code>ORDER BY</code>, но
<code>LIMIT</code> также присутствует, оптимизатор может быть в состоянии
избегать использования файла слияния и сортировать строки в памяти. См.
<a href="#limit-optimization">раздел 9.2.1.19</a>.</p>

<h4><a name="group-by-optimization"></a>9.2.1.16. Оптимизация GROUP BY</h4>
<p>Самый общий способ удовлетворить <code>GROUP BY</code>
должен просмотреть целую таблицу и составить новую временную таблицу, где
все строки от каждой группы последовательны, а затем использовать эту
временную таблицу, чтобы обнаружить группы и применить совокупные функции
(если есть). В некоторых случаях MySQL в состоянии сделать намного лучше
и избежать создания временных таблиц при использовании индекса.</p>

<p>Самые важные предварительные условия для того, чтобы использовать индекс
для <code>GROUP BY</code> это все ссылочные признаки столбцов
<code>GROUP BY</code> от того же самого индекса, и что ключи индекса
хранятся в порядке (например, это индекс <code>BTREE</code>, но не
<code>HASH</code>). Может ли использование временных таблиц быть заменено
индексным доступом, также зависит от того, на которой части индексирования
используются в запросе условия, определенные для этих частей
и выбранных совокупных функций.</p>

<p>Есть два способа выполнить запрос <code>GROUP BY</code>
через индексный доступ, как детализировано в следующих разделах. В первом
методе группировка применена вместе со всеми предикатами диапазона (если
есть). Второй метод сначала выполняет просмотр диапазона, затем
группирует получающиеся кортежи.</p>

<p>В MySQL <code>GROUP BY</code> используется для того, чтобы сортировать,
таким образом, сервер может также применить <code>ORDER BY</code>
к группировке. Однако, доверие неявному <code>GROUP BY</code> устарело, см.
<a href="#order-by-optimization">раздел 9.2.1.15</a>.</p>

<h5><a name="loose-index-scan"></a>9.2.1.16.1. Свободный индексный просмотр
</h5>
<p>Самый эффективный способ обработать <code>GROUP BY</code>, когда
индексирование используется, чтобы непосредственно получить группирующиеся
столбцы. С этим методом доступа MySQL использует свойство некоторых типов
индекса, что ключи упорядочены (например, <code>BTREE</code>).
Это свойство включает использование групп поиска в индексировании, не имея
необходимость рассматривать все ключи в индексировании, которые удовлетворяют
все выражения <code>WHERE</code>. Этот метод доступа рассматривает только
фракцию ключей в индексировании, таким образом, это называют
<span>свободный просмотр индекса</span>. Когда нет <code>WHERE</code>,
свободный просмотр читает столько ключей, сколько имеется групп, что
может быть намного меньшим числом, чем все ключи. Если <code>WHERE</code>
содержит предикаты диапазона (см. обсуждение
<a href="#jointype_range"><code>range</code></a> в
<a href="#using-explain">разделе 9.8.1</a>), свободный просмотр
ищет первый ключ каждой группы, которая удовлетворяет условиям диапазона, и
снова читает наименее возможное число ключей.
Это возможно при следующих условиях:</p>

<ul><li><p>Запрос по единственной таблице.</li>
<li><code>GROUP BY</code> называет только столбцы, которые формируют крайний
левый префикс индекса и никаких других столбцов. Если вместо
<code>GROUP BY</code> у запроса есть <code>DISTINCT</code>,
все отличные признаки обращаются к столбцам, которые формируют крайний левый
префикс индекса. Например, если таблица <code>t1</code>
имеет индексирование на <code>(c1,c2,c3)</code>, свободный просмотр
применим, если запрос имеет <code>GROUP BY c1, c2,</code>.
Это не применимо, если запрос имеет <code>GROUP BY c2, c3</code> (столбцы не
крайний левый префикс) или <code>GROUP BY c1, c2, c4</code> (<code>c4</code>
не находится в индексировании).</li>

<li>Единственные совокупные функции в избранном списке (если есть) это
<a href="funct.htm#function_min"><code>MIN()</code></a> и
<a href="funct.htm#function_max"><code>MAX()</code></a>,
все они обращаются к тому же самому столбцу. Столбец должен быть в индексе и
должен немедленно следовать за столбцами в <code>GROUP BY</code>.</li>

<li>Любые другие части индексирования чем от <code>GROUP BY</code>
должны быть константами (то есть, на них нужно сослаться в равенствах с
константами), за исключением параметра функций
<a href="funct.htm#function_min"><code>MIN()</code></a> или
<a href="funct.htm#function_max"><code>MAX()</code></a>.</li>

<li>Для столбцов в индексировании полные значения столбцов должны быть
индексированы, не только префикс. Например, с
<code>c1 VARCHAR(20), INDEX (c1(10))</code> индекс не может использоваться
для свободного просмотра.</p></li></ul>

<p>Если свободный просмотр, применим к запросу,
<a href="sql.htm#explain"><code>EXPLAIN</code></a> показывает
<code>Using index for group-by</code> в столбце <code>Extra</code>.</p>

<p>Предположите, что есть индекс <code>idx(c1,c2,c3)</code> на таблице
<code>t1(c1,c2,c3,c4)</code>. Свободный просмотр может использоваться
для следующих запросов:
<pre>
SELECT c1, c2 FROM t1 GROUP BY c1, c2;
SELECT DISTINCT c1, c2 FROM t1;
SELECT c1, MIN(c2) FROM t1 GROUP BY c1;
SELECT c1, c2 FROM t1 WHERE c1 &lt; <em><code>const</code></em>
       GROUP BY c1, c2;
SELECT MAX(c3), MIN(c3), c1, c2 FROM t1
       WHERE c2 &gt; <em><code>const</code></em> GROUP BY c1, c2;
SELECT c2 FROM t1 WHERE c1 &lt; <em><code>const</code></em> GROUP BY c1, c2;
SELECT c1, c2 FROM t1 WHERE c3 = <em><code>const</code></em> GROUP BY c1, c2;
</pre>

<p>Следующие запросы не могут быть выполнены с этим методом
по приведенным причинам:</p>
<ul><li><p>Есть совокупные функции кроме
<a href="funct.htm#function_min"><code>MIN()</code></a> или
<a href="funct.htm#function_max"><code>MAX()</code></a>:
<pre>
SELECT c1, SUM(c2) FROM t1 GROUP BY c1;
</pre></li>

<li>Столбцы в <code>GROUP BY</code> не формируют крайний левый
префикс из индекса:
<pre>
SELECT c1, c2 FROM t1 GROUP BY c2, c3;
</pre></li>

<li><p>Запрос обращается к части ключа, которая после
<code>GROUP BY</code> и для которой нет никакого равенства с константой:
<pre>
SELECT c1, c3 FROM t1 GROUP BY c1, c2;
</pre>
<p>Если был запрос, чтобы включать <code>WHERE c3=<em><code>const</code></em>
</code>, свободный индексный просмотр мог использоваться.</p></li></ul>

<p>Метод доступа может быть применен к другим формам совокупных
функциональных ссылок в избранном списке, в дополнение к
<a href="funct.htm#function_min"><code>MIN()</code></a> и
<a href="funct.htm#function_max"><code>MAX()</code></a>:</p>

<ul><li><p><a href="funct.htm#function_avg"><code>AVG(DISTINCT)</code></a>,
<a href="funct.htm#function_sum"><code>SUM(DISTINCT)</code></a> и
<a href="funct.htm#function_count"><code>COUNT(DISTINCT)</code></a>
поддерживаются. <a href="funct.htm#function_avg"><code>AVG(DISTINCT)</code>
</a> и <a href="funct.htm#function_sum"><code>SUM(DISTINCT)</code></a>
берут единственный параметр. <a href="funct.htm#function_count"><code>
COUNT(DISTINCT)</code></a> может иметь в параметре больше одного столбца.
</li>

<li>Не должно быть <code>GROUP BY</code> или <code>DISTINCT</code> в запросе.
</li>
<li>Ограничения просмотра, описанные ранее, все еще применяются.
</p></li></ul>

<p>Предположите, что есть индекс <code>idx(c1,c2,c3)</code> на таблице
<code>t1(c1,c2,c3,c4)</code>. Свободный просмотр может использоваться
для следующих запросов:
<pre>
SELECT COUNT(DISTINCT c1), SUM(DISTINCT c1) FROM t1;
SELECT COUNT(DISTINCT c1, c2), COUNT(DISTINCT c2, c1) FROM t1;
</pre>

<p>Свободный просмотр не может использоваться для следующих запросов:
<pre>
SELECT DISTINCT COUNT(DISTINCT c1) FROM t1;
SELECT COUNT(DISTINCT c1) FROM t1 GROUP BY c1;
</pre>

<h5><a name="tight-index-scan"></a>9.2.1.16.2. Трудный индексный просмотр
</h5>
<p>Трудный индексный просмотр может быть полным просмотром
или просмотром диапазона, в зависимости от условий запроса.</p>

<p>Когда условия для свободного индексного просмотра не встречены,
все еще может быть возможно избежать создания временных таблиц для
<code>GROUP BY</code>. Если есть условия диапазона в <code>WHERE</code>,
этот метод читает только ключи, которые удовлетворяют этим условиям.
Иначе это выполняет индексный просмотр. Поскольку этот метод читает все ключи
в каждом диапазоне, определенном <code>WHERE</code>, или просматривает
весь индекс, если нет никаких условий диапазона, мы называем это
<span>трудный индексный просмотр</span>. С трудным индексным просмотром
группировка выполнена только после того, как все ключи, которые удовлетворяют
условиям диапазона, были найдены.</p>

<p>Для этого метода достаточно, что есть постоянное условие равенства для
всех столбцов в запросе, обращающемся к частям ключа,
прежде или между частями ключа <code>GROUP BY</code>.
Константы от условий равенства заполняют любой
<span><span>промежуток</span></span> в ключах поиска так, чтобы было возможно
сформировать полные префиксы индекса. Эти префиксы могут использоваться для
индексных поисков. Если мы требуем сортировки результата
<code>GROUP BY</code> и возможно сформировать ключи поиска, которые являются
префиксами индекса, MySQL также избегает дополнительных операций сортировки,
потому что поиск с префиксами в упорядоченном индексе уже получает все
ключи в нужном порядке.</p>

<p>Предположите, что есть индекс <code>idx(c1,c2,c3)</code> на таблице
<code>t1(c1,c2,c3,c4)</code>. Следующие запросы не работают со свободным
просмотром, описанный ранее, но работают с трудным индексным просмотром.</p>

<ul><li><p>Есть промежуток в <code>GROUP BY</code>, но это покрыто условием
<code>c2 = 'a'</code>:
<pre>
SELECT c1, c2, c3 FROM t1 WHERE c2 = 'a' GROUP BY c1, c3;
</pre></li>

<li><code>GROUP BY</code> не начинается с первой части ключа, но есть
условие, которое обеспечивает константу для той части:
<pre>
SELECT c1, c2, c3 FROM t1 WHERE c1 = 'a' GROUP BY c2, c3;
</pre></li></ul>

<h4><a name="distinct-optimization"></a>9.2.1.17. Оптимизация DISTINCT</h4>
<p><code>DISTINCT</code> с <code>ORDER BY</code>
нуждается во временной таблице во многих случаях.</p>

<p>Поскольку <code>DISTINCT</code> может использовать <code>GROUP BY</code>,
изучите, как MySQL работает со столбцами в
<code>ORDER BY</code> или <code>HAVING</code>, которые не являются частью
выбранных столбцов. См. <a href="funct.htm#group-by-handling">раздел 13.19.3
</a>.</p>

<p>В большинстве случаев <code>DISTINCT</code>
можно рассмотреть как особый случай <code>GROUP BY</code>.
Например, следующие два запроса эквивалентны:
<pre>
SELECT DISTINCT c1, c2, c3 FROM t1 WHERE c1 &gt; <em><code>const</code></em>;
SELECT c1, c2, c3 FROM t1 WHERE c1 &gt; <em><code>const</code></em>
       GROUP BY c1, c2, c3;
</pre>

<p>Из-за этой эквивалентности, оптимизация, применимая к
<code>GROUP BY</code>, может быть также применена к запросам с
<code>DISTINCT</code>. Таким образом, для большего количества деталей о
возможностях оптимизации для <code>DISTINCT</code> см.
<a href="#group-by-optimization">раздел 9.2.1.16</a>.</p>

<p>Объединяя <code>LIMIT <em><code>row_count</code></em></code> с
<code>DISTINCT</code>, MySQL останавливается, как только находит
<em><code>row_count</code></em> уникальных строк.</p>

<p>Если Вы не используете столбцы от всех таблиц, названных в запросе, MySQL
прекращает просматривать любые неиспользованные таблицы, как только он
находит первое соответствие. В следующем случае, предполагая что
<code>t1</code> используется прежде <code>t2</code>
(с чем Вы можете свериться с помощью
<a href="sql.htm#explain"><code>EXPLAIN</code></a>), MySQL
прекращает читать из <code>t2</code> (для любой особой строки в
<code>t1</code>), когда это находит первую строку в <code>t2</code>:
<pre>
SELECT DISTINCT t1.a FROM t1, t2 where t1.a=t2.a;
</pre>

<h4><a name="subquery-optimization"></a>9.2.1.18. Оптимизация подзапроса</h4>
<p>Оптимизатор запроса MySQL имеет различные стратегии, чтобы
оценить подзапросы. Для <code>IN</code> (или <code>=ANY</code>)
у оптимизатора есть этот выбор:</p>

<ul><li><p>Semi-join</li>
<li>Материализация</li>
<li><code>EXISTS</code></p></li></ul>

<p>Для <code>NOT IN</code> (или <code>&lt;&gt;ALL</code>)
у оптимизатора есть этот выбор:</p>
<ul><li><p>Материализация</li>
<li><code>EXISTS</code></p></li></ul>

<p>Для полученных таблиц (подзапросы в <code>FROM</code>)
и ссылок представления у оптимизатора есть этот выбор:</p>
<ul><li><p>Слить полученную таблицу или представление во
внешний блок запроса.</li>

<li>Осуществить полученную таблицу или представление о
внутренней временной таблице.</p></li></ul>
<p>Следующее обсуждение предоставляет больше информации об
этих стратегиях оптимизации.</p>

<p>Ограничение <a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>, которые используют
подзапрос, чтобы изменить единственную таблицу, это когда оптимизатор не
использует полусоединение или оптимизацию подзапроса материализации.
Как обходное решение, попытайтесь переписать их как многотабличный
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>, которые используют
соединение, а не подзапрос.</p>

<h5><a name="semi-joins"></a>9.2.1.18.1.
Оптимизация подзапросов с преобразованиями полусоединения</h5>
<p>Оптимизатор использует стратегии полусоединения, чтобы улучшить выполнение
подзапроса, как описано в этом разделе.</p>

<p>Для внутреннего соединения между двумя таблицами соединение возвращает
строку из одной таблицы так много раз, сколько есть соответствий в другой
таблице. Но для некоторых запросов, единственная информация, это есть ли
соответствие, а не число соответствий. Предположите, что есть таблицы
<code>class</code> и <code>roster</code>, перечисляющие классы в
программе курса и спискм класса (студенты, зарегистрированные в каждом
классе), соответственно.Чтобы перечислить классы, которым фактически
зарегистрировали студентов, Вы могли бы использовать это соединение:
<pre>
SELECT class.class_num, class.class_name
       FROM class INNER JOIN roster
       WHERE class.class_num = roster.class_num;
</pre>

<p>Однако, результат перечисляет каждый класс однажды для каждого
зарегистрированного студента. Для вопроса, который задают, это
ненужное дублирование информации.</p>

<p>Будем считать, что <code>class_num</code> это primary key в таблице
<code>class</code>, подавление дубликатов могло быть достигнуто при
использовании <a href="sql.htm#select"><code>SELECT DISTINCT</code></a>,
но это неэффективно, чтобы произвести все строки соответствия сначала только,
чтобы устранить дубликаты позже.</p>

<p>Тот же самый результат может быть получен при использовании подзапроса:
<pre>
SELECT class_num, class_name FROM class
       WHERE class_num IN (SELECT class_num FROM roster);
</pre>

<p>Здесь, оптимизатор может признать, что <code>IN</code>
требует, чтобы подзапрос возвратил только один случай каждого
классификационного индекса от таблицы <code>roster</code>.
В этом случае запрос может быть выполнен как <span>semi-join</span>,
то есть, работа, которая возвращает только один случай каждой строки в
<code>class</code>, который является
соответствующим строкам в <code>roster</code>.</p>

<p>Outer join и inner join разрешены во внешней спецификации запроса, и
табличные ссылки могут быть базовыми таблицами или представлениями.</p>
<p>В MySQL подзапрос должен удовлетворить эти критерии, которые будут
обработаны как полусоединение:</p>

<ul><li><p>Это должно быть <code>IN</code> (или <code>=ANY</code>), который
появляется на верхнем уровне <code>WHERE</code> или <code>ON</code>,
возможно, как термин в <code>AND</code>:
<pre>
SELECT ...
FROM ot1, ...
WHERE (oe1, ...) IN (SELECT ie1, ... FROM it1, ... WHERE ...);
</pre>

<p>Здесь <code>ot_<em><code>i</code></em></code> и
<code>it_<em><code>i</code></em></code>
представляют таблицы во внешних и внутренних частях запроса, а
<code>oe_<em><code>i</code></em></code> и
<code>ie_<em><code>i</code></em></code> представляют выражения, которые
обращаются к столбцам во внешних и внутренних таблицах.</li>

<li>Это должен быть единственный
<a href="sql.htm#select"><code>SELECT</code></a> без
<a href="sql.htm#union"><code>UNION</code></a>.</li>
<li>Это не должно содержать <code>GROUP BY</code> или <code>HAVING</code>.
</li>

<li>Это не должно быть неявно сгруппировано (это не должно
содержать совокупные функции).</li>
<li>Это не должно иметь <code>ORDER BY</code> с <code>LIMIT</code>.</li>

<li>Это не должно иметь <code>STRAIGHT_JOIN</code> во внешнем запросе.</li>
<li>Число внешних и внутренних таблиц вместе должно быть меньше,
чем максимальное количество таблиц, разрешенных в соединении.</li>
<li><code>STRAIGHT_JOIN</code> не присутствует.</p></li></ul>

<p>Подзапрос может быть коррелированый или некоррелированый.
<code>DISTINCT</code> разрешен, как <code>LIMIT</code>, если
также используется и <code>ORDER BY</code>.</p>

<p>Если подзапрос соответствует предыдущим критериям, MySQL преобразовывает
его в полусоединение и делает выбор на основе издержек из этих стратегий:</p>
<ul><li><p>Преобразуйте подзапрос в соединение или используйте табличное
отступление и выполните запрос как внутреннее соединение между таблицами
подзапроса и внешними таблицами. Табличное отступление вытягивает таблицу из
подзапроса к внешнему запросу.</li>

<li>Выполните полусоединение, как будто это было соединение, и удалите
дубликаты записей, используя временную таблицу.</li>
<li>FirstMatch: Когда внутренние таблицы просматриваются для комбинаций
строки и там есть много случаев данной группы значения, выбирается одна
вместо того, чтобы возвратить их все. Этот просмотр &quot;ярлыков&quot; и
устраняет производство ненужных строк.</li>

<li>LooseScan: Просмотрите таблицу подзапроса, используя индексирование, что
позволяет единственному значению быть выбранным из группы
значений каждого подзапроса.</li>

<li>Осуществите подзапрос во временную таблицу с индексированием
и используйте временную таблицу, чтобы выполнить соединение. Индексирование
используется, чтобы удалить дубликаты. Индексирование могло бы также
использоваться позже для поисков, присоединяясь к временной таблице с
внешними таблицами, в противном случае таблица просмотрена.</p></li></ul>

<p>Каждая из этих стратегий может быть включена с использованием переменной
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a>. Флаг <code>semijoin</code> управляет, используются ли полусоединения.
Если это установлено в <code>on</code>, то флаги <code>firstmatch</code>,
<code>loosescan</code>, <code>duplicateweedout</code> и
<code>materialization</code> включают более гладкое управление разрешенными
стратегиями полусоединения. Эти флаги <code>on</code> по умолчанию. См.
<a href="#switchable-optimizations">раздел 9.9.2</a>.</p>

<p>Если стратегия <code>duplicateweedout</code> выключена, она не
используется, если все другие применимые стратегии также не отключены.</p>
<p>Если <code>duplicateweedout</code> выключена, при случае оптимизатор может
произвести план запроса, который совсем не оптимален. Это происходит из-за
эвристического сокращения во время поиска, которого можно избежать,
устанавливая <a href="server.htm#sysvar_optimizer_prune_level"><code>
optimizer_prune_level=0</code></a>.</p>

<p>Оптимизатор минимизирует различия в обработке представлений и
подзапросов в <code>FROM</code>. Это затрагивает запросы с
<code>STRAIGHT_JOIN</code> и представления с подзапросом <code>IN</code>,
которые могут быть преобразованы в полусоединение. Следующий запрос
иллюстрирует это, потому что изменение в обработке причина изменений в
преобразовании, и таким образом применена иная стратегия выполнения:
<pre>
CREATE VIEW v AS SELECT * FROM t1 WHERE a IN (SELECT b FROM t2);
SELECT STRAIGHT_JOIN * FROM t3 JOIN v ON t3.x = v.a;
</pre>

<p>Оптимизатор сначала смотрит представление и конвертирует подзапрос
<code>IN</code> в полусоединение, затем проверяет, возможно ли слить
представление во внешний запрос. Поскольку <code>STRAIGHT_JOIN</code>
во внешнем запросе предотвращает полусоединение, оптимизатор отказывается от
слияния, заставляя полученную таблицу быть оцененной,
используя осуществленную таблицу.</p>

<p>Использование стратегий полусоединения обозначено в выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a> так:</p>
<ul><li><p>Таблицы, к которым полуприсоединяются, обнаруживаются во внешнем
select. <a href="#explain-extended"><code>EXPLAIN EXTENDED</code>
</a> и <a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a>
показывает переписанный запрос, который выводит структуру полусоединения. От
этого Вы можете понять, которые таблицы были вытащены из полусоединения.
Если подзапрос был преобразован в полусоединение, Вы будете видеть, что
предиката подзапроса не стало, и его таблицы и <code>WHERE</code>
были слиты во внешний список соединения запроса и <code>WHERE</code>.</li>

<li>Временное табличное использование для Duplicate Weedout обозначено
<code>Start temporary</code> и <code>End temporary</code> в столбце
<code>Extra</code>. Таблицы, которые не были вытащены и находятся в диапазоне
выходных строк <a href="sql.htm#explain"><code>EXPLAIN</code></a>, покрытые
<code>Start temporary</code> и <code>End temporary</code>,
будет иметь их <code>rowid</code> во временной таблице.</li>

<li><code>FirstMatch(<em><code>tbl_name</code></em>)</code>
в столбце <code>Extra</code> указывает на сокращенное соединение.</li>
<li><code>LooseScan(<em><code>m</code></em>..<em><code>n</code></em>)</code>
в столбце <code>Extra</code> указывает на использование стратегии LooseScan.
<em><code>m</code></em> и <em><code>n</code></em> номера ключевой части.</li>

<li>Временное табличное использование для материализации обозначено строками
с <code>select_type</code> = <code>MATERIALIZED</code> и
<code>table</code> = <code>&lt;subquery<em><code>N</code></em>&gt;</code>.
</p></li></ul>

<h5><a name="subquery-materialization"></a>9.2.1.18.2.
Оптимизация подзапросов с материализацией подзапроса</h5>
<p>Оптимизатор использует материализацию подзапроса в качестве стратегии,
которая включает более эффективную обработку подзапроса. Материализация
ускоряет выполнение запроса, производя результат подзапроса как временную
таблицу, обычно в памяти. В первый раз, когда MySQL нуждается в результате
подзапроса, он осуществляет этот результат во временную таблицу.
Когда позже результат необходим, MySQL обращается снова к временной таблице.
Таблица индексирована с хешем, чтобы сделать поиски быстрыми и недорогими.
Индексирование уникально, что делает таблицу меньше,
потому что у этого нет никаких дубликатов.</p>

<p>Материализация подзапроса пытается использовать временную таблицу в
памяти, когда возможно отступая к хранению на диске, если таблица становится
слишком большой. См. <a href="#internal-temporary-tables">раздел
9.4.4</a>.</p>

<p>Если материализация не используется, оптимизатор иногда переписывает
некоррелированый подзапрос как коррелированый подзапрос.
Например, следующий подзапрос <code>IN</code> некоррелирован
(<em><code>where_condition</code></em> вовлекает только столбцы от
<code>t2</code>, но не от <code>t1</code>):
<pre>
SELECT * FROM t1 WHERE t1.a IN (SELECT t2.b FROM t2
         WHERE <em><code>where_condition</code></em>);
</pre>

<p>Оптимизатор мог бы переписать это как
коррелированый подзапрос <code>EXISTS</code>:
<pre>
SELECT * FROM t1 WHERE EXISTS (SELECT t2.b FROM t2
         WHERE <em><code>where_condition</code></em> AND t1.a=t2.b);
</pre>

<p>Материализация подзапроса, используя временную таблицу, избегает таких
перезаписей и позволяет выполнить подзапрос только однажды, а не однажды на
строку внешнего запроса.</p>

<p>Для материализации подзапроса, которая будет использоваться в MySQL,
флаг <code>materialization</code> в переменной
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> должен быть <code>on</code>. Материализация тогда применяется к
предикатам подзапроса, которые появляются где угодно (в избранном списке,
<code>WHERE</code>, <code>ON</code>, <code>GROUP BY</code>,
<code>HAVING</code> или <code>ORDER BY</code>)
для предикатов, которые попадают в любой из этих случаев использования:</p>

<ul><li><p>У предиката есть эта форма, когда никакое внешнее выражение
<em><code>oe_i</code></em> или внутреннее выражение
<em><code>ie_i</code></em> может быть null.
<em><code>N</code></em> = 1 или больше.
<pre>
(<em><code>oe_1</code></em>, <em><code>oe_2</code></em>, ...,
<em><code>oe_N</code></em>) [NOT] IN (SELECT <em><code>ie_1</code></em>,
<em><code>i_2</code></em>, ..., <em><code>ie_N</code></em> ...)
</pre></li>

<li>У предиката есть эта форма, когда есть единственное внешнее выражение
<em><code>oe</code></em> и внутреннее выражение <em><code>ie</code></em>.
Выражения могут быть null.
<pre>
<em><code>oe</code></em> [NOT] IN (SELECT <em><code>ie</code></em> ...)
</pre></li>

<li>Предикат <code>IN</code> или <code>NOT IN</code> и результат
<code>UNKNOWN</code> (<code>NULL</code>) имеет то же самое
значение в результате <code>FALSE</code>.</p></li></ul>

<p>Следующие примеры иллюстрируют как требование для эквивалентности
оценки предиката <code>UNKNOWN</code> и <code>FALSE</code>
затрагивает, может ли материализация подзапроса использоваться. Примите, что
<em><code>where_condition</code></em> вовлекает столбцы только от
<code>t2</code>, но не из <code>t1</code> так, чтобы
подзапрос был некоррелирован.</p>

<p>Этот запрос подвергается материализации:
<pre>
SELECT * FROM t1 WHERE t1.a IN (SELECT t2.b FROM t2
         WHERE <em><code>where_condition</code></em>);
</pre>

<p>Здесь не имеет значения, возвращает предикат <code>IN</code>
<code>UNKNOWN</code> или <code>FALSE</code>. Так или иначе, строка от
<code>t1</code> не включена в результат запроса.</p>

<p>Примером, где материализация подзапроса не будет использоваться, является
следующий запрос, где <code>t2.b</code> столбец nullable.
<pre>
SELECT * FROM t1 WHERE (t1.a,t1.b) NOT IN (SELECT t2.a,t2.b FROM t2
         WHERE <em><code>where_condition</code></em>);
</pre>

<p>Следующие ограничения относятся к использованию материализации подзапроса:
</p>
<ul><li><p>Типы внутренних и внешних выражений должны соответствовать.
Например, оптимизатор может быть в состоянии использовать материализацию,
если оба выражения integer или оба являются decimal. Оптимизатор не может
использовать материализацию, если одно выражение integer, а другое decimal.
</li>
<li>Внутреннее выражение не может быть
<a href="types.htm#blob"><code>BLOB</code></a>.</p></li></ul>

<p>Применение <a href="sql.htm#explain"><code>EXPLAIN</code></a> с
запросом может дать некоторый признак того, использует ли оптимизатор
материализацию подзапроса. Сравненный с выполнением запроса, которое не
использует материализацию, <code>select_type</code> может измениться с
<code>DEPENDENT SUBQUERY</code> на <code>SUBQUERY</code>.
Это указывает, что для подзапроса, который был бы выполнен однажды на внешнюю
строку, материализация позволяет подзапросу быть выполненным только однажды.
Кроме того, для <a href="#explain-extended"><code>EXPLAIN
EXTENDED</code></a> текст, выведенный на экран
<a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a>, включает
<code>materialize</code> и <code>materialized-subquery</code>.</p>

<h5><a name="derived-table-optimization"></a>9.2.1.18.3.
Оптимизация полученных таблиц и ссылок представления</h5>
<p>Оптимизатор может обработать полученные таблицы (подзапросы в
<code>FROM</code>) и ссылки представления, используя две стратегии: </p>

<ul><li><p>Слить полученную таблицу или представление во
внешний блок запроса.</li>
<li>Осуществить полученную таблицу или представление во
внутренней временной таблице.</p></li></ul>

<p>Пример 1:
<pre>
SELECT * FROM (SELECT * FROM t1) AS derived_t1;
</pre>

<p>Со слиянием этот запрос выполнен так:
<pre>
SELECT * FROM t1;
</pre>

<p>Пример 2:
<pre>
SELECT * FROM t1 JOIN (SELECT t2.f1 FROM t2) AS derived_t2 ON
         t1.f2=derived_t2.f1 WHERE t1.f1 &gt; 0;
</pre>

<p>Со слиянием этот запрос выполнен так:
<pre>
SELECT t1.*, t2.f1 FROM t1 JOIN t2 ON t1.f2=t2.f1 WHERE t1.f1 &gt; 0;
</pre>
<p>С материализацией <code>derived_t1</code> и <code>derived_t2</code>
обработаны как отдельная таблица в пределах их соответствующих запросов.</p>

<p>Оптимизатор обрабатывает полученные таблицы и представления
тем же самым путем: это избегает ненужной материализации когда бы ни было
возможно, которая позволяет оттолкнуть условия от внешнего запроса до
полученных таблиц и производит более эффективные планы выполнения. Для
примера см. <a href="#subquery-materialization">раздел 9.2.1.18.2
</a>.</p>

<p>Если слияние привело бы к внешнему блоку запроса, который ссылается
больше, чем на 61 базовую таблицу, оптимизатор выбирает
материализацию вместо этого.</p>

<p>Оптимизатор обрабатывает распространение <code>ORDER BY</code>
в полученной таблице или ссылке представления на блок внешнего запроса,
размножая <code>ORDER BY</code>, если следующие условия применяются: внешний
запрос не сгруппирован или соединен, не определяет
<code>DISTINCT</code>, <code>HAVING</code> или <code>ORDER BY</code>,
имеет эту полученную таблицу или ссылку представления как единственный
источник в <code>FROM</code>. Иначе оптимизатор игнорирует <code>ORDER BY
</code>.</p>

<p>Подсказки оптимизатора <code>MERGE</code> и <code>NO_MERGE</code>
могут использоваться, чтобы влиять, пытается ли оптимизатор слить полученные
таблицы и представления во внешний блок запроса, предполагая, что никакое
другое правило не предотвращает слияние. См.
<a href="#optimizer-hints">раздел 9.9.3</a>. Флаг
<code>derived_merge</code> переменной
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> может также использоваться для этого. По умолчанию флаг
<code>on</code>, чтобы позволять слиться. Установка флага в <code>off</code>
предотвращает слияние и избегает ошибок
<a href="error.htm#error_er_update_table_used"><code>ER_UPDATE_TABLE_USED
</code></a>. Также возможно отключить слияние при использовании в подзапросе
любых конструкций, которые предотвращают слияние, хотя они не являются столь
явными в их эффекте на материализацию. Конструкции, которые предотвращают
слияние, являются теми же самыми, которые предотвращают слияние в
представлениях. Примеры <code>SELECT DISTINCT</code> или <code>LIMIT</code>
в подзапросе. Для деталей см.
<a href="stored.htm#view-algorithms">раздел 21.5.2</a>.</p>

<p>Флаг <code>derived_merge</code> также относится к представлениям, которые
не содержат параметр <code>ALGORITHM</code>. Таким образом, если ошибка
<a href="error.htm#error_er_update_table_used"><code>ER_UPDATE_TABLE_USED
</code></a> происходит для ссылки представления, которая использует
выражение, эквивалентное подзапросу, добавляя
<code>ALGORITHM=TEMPTABLE</code> к представлению, определение предотвращает
слияние и имеет приоритет пеед текущим значением <code>derived_merge</code>.
</p>

<p>Если оптимизатор выбирает стратегию материализации полученной таблицы,
это обрабатывает запрос следующим образом:</p>

<ul><li><p>Оптимизатор откладывает материализацию подзапросов в
<code>FROM</code> до того, как их содержание будет необходимо во время
выполнения запроса. Это улучшает работу, потому что задержка материализации
может привести к отсутствию необходимости сделать это вообще. Рассмотрите
запрос, который присоединяется к результату подзапроса в
<code>FROM</code> к другой таблице: если оптимизатор обрабатывает другую
таблицу сначала и находит, что та не возвращает строк, соединение не должно
быть выполнено далее, и оптимизатор может полностью
пропустить осуществление подзапроса.</li>
<li>Во время выполнения запроса оптимизатор может добавить индекс
к полученной таблице, чтобы ускорить извлечение строки.</p></li></ul>

<p>Рассмотрите следующий <a href="sql.htm#explain"><code>EXPLAIN</code></a>
для которого подзапрос появляется в <code>FROM</code> запроса
a <a href="sql.htm#select"><code>SELECT</code></a>:
<pre>
EXPLAIN SELECT * FROM (SELECT * FROM t1) AS derived_t1;
</pre>

<p>Оптимизатор избегает осуществлять подзапрос, задерживая это, пока
результат не станет необходим во время <a href="sql.htm#select"><code>SELECT
</code></a>. В этом случае запрос не выполнен, таким образом, результат
никогда не будет необходим.</p>

<p>Даже для запросов, которые выполнены, задержка материализации подзапроса
может позволить оптимизатору избежать материализации полностью.
Когда это происходит, выполнение запроса более быстро к тому времени, когда
необходимо выполнить материализацию. Рассмотрите следующий запрос,
который присоединяется к результату подзапроса в
<code>FROM</code> к другой таблице:
<pre>
SELECT * FROM t1 JOIN (SELECT t2.f1 FROM t2) AS derived_t2
         ON t1.f2=derived_t2.f1 WHERE t1.f1 &gt; 0;
</pre>

<p>Если оптимизация обрабатывает <code>t1</code> сначала и
<code>WHERE</code> приводит к пустому результату, соединение должно
обязательно быть пустым, и подзапрос не должен быть осуществлен.</p>

<p>Для случаев, когда полученная таблица требует материализации, оптимизатор
может ускорить доступ к результату, добавляя индекс к осуществленной таблице.
Если такой индекс включает доступ <a href="#jointype_ref"><code>
ref</code></a> к таблице, это может очень уменьшить объем данных, который
должен быть считан во время выполнения запроса. Рассмотрите следующий запрос:
<pre>
SELECT * FROM t1 JOIN (SELECT DISTINCT f1 FROM t2) AS derived_t2
         ON t1.f1=derived_t2.f1;
</pre>

<p>Оптимизатор создает индекс по столбцу <code>f1</code> от
<code>derived_t2</code>, если выполнение включило бы использование доступа
<a href="#jointype_ref"><code>ref</code></a>
для самого низкого по стоимости плана выполнения. После добавления индекса
оптимизатор может обработать осуществленную полученную таблицу, как
регулярную таблицу с индексом, и это извлекает выгоду из произведенного
индекса. Если доступ <a href="#jointype_ref"><code>ref</code></a>
привел бы к более высокой стоимости, чем некоторый другой метод доступа,
оптимизатор не создает индекс и ничего не теряет.</p>

<h5><a name="subquery-optimization-with-exists"></a>9.2.1.18.4.
Оптимизация подзапросов со стратегией EXISTS</h5>
<p>Определенная оптимизация применима к сравнениям, которые используют
оператор <code>IN</code>, чтобы проверить результаты подзапроса (или
использующие <code>=ANY</code>). Этот раздел обсуждает эту оптимизацию,
особенно относительно проблем со значениями <code>NULL</code>.
Последняя часть обсуждения включает предложения о том, что Вы можете сделать,
чтобы помочь оптимизатору.</p>

<p>Рассмотрите следующее сравнение подзапроса:
<pre>
<em><code>outer_expr</code></em> IN (SELECT <em><code>inner_expr</code></em>
FROM ... WHERE <em><code>subquery_where</code></em>)
</pre>

<p>MySQL оценивает запросы <span><span>снаружи внутрь</span></span>.
Таким образом, это сначала получает значение внешнего выражения
<em><code>outer_expr</code></em>, затем выполняет подзапрос и получает
строки, которые он производит.</p>

<p>Очень полезная оптимизация <span><span>информировать</span></span>
подзапрос, что единственные интересные строки это те, где внутреннее
выражение <em><code>inner_expr</code></em> равно <em><code>outer_expr</code>
</em>. Это сделано, отталкивая соответствующее равенство в подзапрос
<code>WHERE</code>. Таким образом, сравнение преобразовано в это:
<pre>
EXISTS (SELECT 1 FROM ... WHERE <em><code>subquery_where</code></em> AND
       <em><code>outer_expr</code></em>=<em><code>inner_expr</code></em>)
</pre>

<p>После преобразования MySQL может использовать продвинутое вниз равенство,
чтобы ограничить число строк, которые это должно
исследовать, оценивая подзапрос.</p>

<p>Более широко, сравнение <em><code>N</code></em> значений с
подзапросом, который возвращает <em><code>N</code></em> строк,
подвергается тому же самому преобразованию. Если <em><code>oe_i</code></em> и
<em><code>ie_i</code></em> представляют соответствующие внешние и внутренние
значения выражения, это сравнение подзапроса:
<pre>
(<em><code>oe_1</code></em>, ..., <em><code>oe_N</code></em>) IN
   (SELECT <em><code>ie_1</code></em>, ..., <em><code>ie_N</code></em>
   FROM ... WHERE <em><code>subquery_where</code></em>)
</pre>

<p>становится:
<pre>
EXISTS (SELECT 1 FROM ... WHERE <em><code>subquery_where</code></em> AND
       <em><code>oe_1</code></em> = <em><code>ie_1</code></em> AND ... AND
       <em><code>oe_N</code></em> = <em><code>ie_N</code></em>)
</pre>

<p>Для простоты следующее обсуждение принимает единственную пару внешних и
внутренних значений выражения.</p>
<p>У только что описанного преобразования есть свои ограничения.
Это допустимо, только если мы игнорируем возможный <code>NULL</code>.
Таким образом, стратегия <span><span>pushdown</span></span> работает,
пока оба эти условия являются истиной:</p>

<ul><li><p><em><code>outer_expr</code></em> и
<em><code>inner_expr</code></em> не <code>NULL</code>.</li>
<li>Вы не должны различать <code>NULL</code> и <code>FALSE</code> в
результатах подзапроса. Если подзапрос часть <a href="funct.htm#operator_or">
<code>OR</code></a> или <a href="funct.htm#operator_and"><code>AND</code></a>
в <code>WHERE</code>, MySQL предполагает, что Вы их не различаете.
Другой случай, где оптимизатор замечает, что результаты подзапроса
<code>NULL</code> и <code>FALSE</code> нельзя отличить, это конструкция:
<pre>
... WHERE <em><code>outer_expr</code></em> IN (<em><code>subquery</code></em>)
</pre>

<p>В этом случае <code>WHERE</code> отклоняет строку
<code>IN (<em><code>subquery</code></em>)</code> независимо от того, вернет
она <code>NULL</code> или <code>FALSE</code>.</p></li></ul>

<p>Когда одно или оба из этих условий не выполнены, оптимизация более сложна.
</p>
<p>Предположите, что <em><code>outer_expr</code></em> значение не
<code>NULL</code>, но подзапрос не производит строку таким образом, что
<em><code>outer_expr</code></em> = <em><code>inner_expr</code></em>.
<code><em><code>outer_expr</code></em> IN (SELECT ...)</code>
оценивается следующим образом:</p>

<ul><li><p><code>NULL</code>, если <a href="sql.htm#select"><code>SELECT
</code></a> производит любую строку, где
<em><code>inner_expr</code></em> = <code>NULL</code>.</li>

<li><code>FALSE</code>, если <a href="sql.htm#select"><code>SELECT</code></a>
производит значения только не <code>NULL</code> или не производит вовсе.
</p></li></ul>

<p>В этой ситуации поиск строк с
<code><em><code>outer_expr</code></em> =
<em><code>inner_expr</code></em></code> больше не действителен. Необходимо
искать такие строки, но если ни одна не найдена, также искать строки, где
<em><code>inner_expr</code></em> = <code>NULL</code>.
Примерно говоря, подзапрос может быть преобразован во что-то вроде этого:
<pre>
EXISTS (SELECT 1 FROM ... WHERE <em><code>subquery_where</code></em> AND
(<em><code>outer_expr</code></em>=<em><code>inner_expr</code></em> OR
<em><code>inner_expr</code></em> IS NULL))
</pre>

<p>Потребность оценить дополнительно <a href="funct.htm#operator_is-null">
<code>IS NULL</code></a> причина того, почему MySQL имеет метод доступа
<a href="#jointype_ref_or_null"><code>ref_or_null</code></a>:
<pre>
mysql&gt; EXPLAIN SELECT <em><code>outer_expr</code></em> IN
    -&gt;         (SELECT t2.maybe_null_key FROM t2, t3 WHERE ...)
    -&gt;         FROM t1;
*************************** 1. row ***************************
 id: 1
  select_type: PRIMARY
table: t1
...
*************************** 2. row ***************************
 id: 2
  select_type: DEPENDENT SUBQUERY
table: t2
 type: ref_or_null
possible_keys: maybe_null_key
key: maybe_null_key
key_len: 5
ref: func
 rows: 2
Extra: Using where; Using index
...
</pre>

<p>У определенных для подзапроса методов доступа
<a href="#jointype_unique_subquery"><code>unique_subquery
</code></a> и <a href="#jointype_index_subquery"><code>
index_subquery</code></a> также есть версия <span><span>or <code>NULL</code>
</span></span>.</p>

<p>Дополнительное условие <code>OR ... IS NULL</code>
делает выполнение запроса немного более сложным (и некоторая оптимизация в
пределах подзапроса становится неподходящей), но вообще это терпимо.</p>

<p>Ситуация намного хуже, когда
<em><code>outer_expr</code></em> может быть <code>NULL</code>.
Согласно интерпретации SQL <code>NULL</code> как <span><span>неизвестная
величина</span></span>, <code>NULL IN (SELECT <em><code>inner_expr</code>
</em> ...)</code> должен оцениться как:</p>

<ul><li><p><code>NULL</code>, если <a href="sql.htm#select"><code>SELECT
</code></a> производит любые строки.</li>
<li><code>FALSE</code>, если <a href="sql.htm#select"><code>SELECT</code></a>
строк не производит.</p></li></ul>

<p>Для надлежащей оценки необходимо быть в состоянии проверить, произвел ли
<a href="sql.htm#select"><code>SELECT</code></a> любые строки вообще, таким
образом, <code><em><code>outer_expr</code></em> =
<em><code>inner_expr</code></em></code> не может быть оттолкнут в подзапрос.
Это проблема, потому что много подзапросов реального мира становятся очень
медленными, если равенство не может быть оттолкнуто.</p>

<p>По существу должны быть различные способы выполнить подзапрос в
зависимости от значения <em><code>outer_expr</code></em>.</p>
<p>Оптимизатор предпочитает согласие SQL скорости, таким образом, это
составляет возможность, что <em><code>outer_expr</code></em>
может быть <code>NULL</code>.</p>

<p>Если <em><code>outer_expr</code></em> = <code>NULL</code>,
чтобы оценить следующее выражение, необходимо выполнить
<a href="sql.htm#select"><code>SELECT</code></a>, чтобы
определить, производит ли это какие-либо строки:
<pre>
NULL IN (SELECT <em><code>inner_expr</code></em> FROM ...
     WHERE <em><code>subquery_where</code></em>)
</pre>

<p>Необходимо выполнить оригинал
<a href="sql.htm#select"><code>SELECT</code></a>
без любых продвинутых вниз равенств, упомянутых ранее.</p>

<p>С другой стороны, когда
<em><code>outer_expr</code></em> не <code>NULL</code>,
абсолютно важно, что это сравнение:
<pre>
<em><code>outer_expr</code></em> IN (SELECT <em><code>inner_expr</code></em>
FROM ... WHERE <em><code>subquery_where</code></em>)
</pre>

<p>будет преобразовано в это выражение, которое использует
продвинутое вниз условие:
<pre>
EXISTS (SELECT 1 FROM ... WHERE <em><code>subquery_where</code></em> AND
       <em><code>outer_expr</code></em>=<em><code>inner_expr</code></em>)
</pre>

<p>Без этого преобразования подзапросы будут медленными. Чтобы решить дилемму
того, оттолкнуть или не оттолкнуть условия в подзапрос, условия обернуты в
функции <span><span>триггера</span></span>.
Таким образом, выражение следующей формы:
<pre>
<em><code>outer_expr</code></em> IN (SELECT <em><code>inner_expr</code></em>
FROM ... WHERE <em><code>subquery_where</code></em>)
</pre>

<p>преобразовано в:
<pre>
EXISTS (SELECT 1 FROM ... WHERE <em><code>subquery_where</code></em> AND
       trigcond(<em><code>outer_expr</code></em>=<em><code>inner_expr</code></em>))
</pre>

<p>Более широко, если сравнение подзапроса основано на нескольких парах
внешних и внутренних выражений, преобразование берет это сравнение:
<pre>
(<em><code>oe_1</code></em>, ..., <em><code>oe_N</code></em>) IN
(SELECT <em><code>ie_1</code></em>, ..., <em><code>ie_N</code></em>
        FROM ... WHERE <em><code>subquery_where</code></em>)
</pre>

<p>и приводит к этому выражению:
<pre>
EXISTS (SELECT 1 FROM ... WHERE <em><code>subquery_where</code></em> AND
       trigcond(<em><code>oe_1</code></em>=<em><code>ie_1</code></em>) AND
       ... AND trigcond(<em><code>oe_N</code></em>=<em><code>ie_N</code></em>))
</pre>

<p><code>trigcond(<em><code>X</code></em>)</code> это специальная функция,
которая оценивается к следующим значениям:</p>
<ul><li><p><em><code>X</code></em>, когда
<span><span>связанное</span></span> внешнее выражение
<em><code>oe_i</code></em> не <code>NULL</code>.</li>

<li><code>TRUE</code>, когда <span><span>связанное</span></span>
внешнее выражение <em><code>oe_i</code></em> <code>NULL</code>.</p></li></ul>
<p>Триггерные функции это <span><em>не</em></span> триггеры в смысле
запроса <a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a>.</p>

<p>Равенства, которые обернуты в <code>trigcond()</code>, это
не предикаты первого класса для оптимизатора. Большинство оптимизации не
может иметь дело с предикатами, которые могут быть включены во время
выполнения запроса, таким образом, они принимают любую
<code>trigcond(<em><code>X</code></em>)</code> как
неизвестную функцию и проигнорируют это. В настоящее время вызванные
равенства могут использоваться этой оптимизацией:</p>

<ul><li><p>Ссылочная оптимизация: <code>trigcond(<em><code>X</code></em>=
<em><code>Y</code></em> [OR <em><code>Y</code></em> IS NULL])</code>
может использоваться, чтобы создать табличные доступы
<a href="#jointype_ref"><code>ref</code></a>,
<a href="#jointype_eq_ref"><code>eq_ref</code></a> или
<a href="#jointype_ref_or_null"><code>ref_or_null</code></a>.</li>

<li>Основанные на поиске в индексе механизмы выполнения подзапроса:
<code>trigcond(<em><code>X</code></em>=<em><code>Y</code></em>)</code>
может использоваться, чтобы создать доступы
<a href="#jointype_unique_subquery"><code>unique_subquery</code>
</a> или <a href="#jointype_index_subquery"><code>index_subquery
</code></a>.</li>
<li>Генератор табличного условия: если подзапрос будет соединением нескольких
таблиц, то вызванное условие будет проверено как можно скорее.</p></li></ul>

<p>Когда оптимизатор использует вызванное условие, чтобы создать некоторый
основанный на индексном поиске доступ (что касается первых двух элементов
предыдущего списка), у этого должна быть стратегия отступления для случая,
когда условие выключено. Эта стратегия отступления всегда сделать полное
сканирование таблицы. В выводе <a href="sql.htm#explain"><code>EXPLAIN</code>
</a> это обнаруживается как <code>Full scan on NULL key</code> в столбце
<code>Extra</code>:
<pre>
mysql&gt; EXPLAIN SELECT t1.col1, t1.col1 IN
    -&gt;         (SELECT t2.key1 FROM t2 WHERE t2.col2=t1.col2) FROM t1\G
*************************** 1. row ***************************
 id: 1
  select_type: PRIMARY
table: t1
...
*************************** 2. row ***************************
 id: 2
  select_type: DEPENDENT SUBQUERY
table: t2
 type: index_subquery
possible_keys: key1
key: key1
key_len: 5
ref: func
 rows: 2
Extra: Using where; Full scan on NULL key
</pre>

<p>Если Вы выполняете <a href="#explain-extended"><code>EXPLAIN
EXTENDED</code></a> и <a href="sql.htm#show-warnings"><code>SHOW WARNINGS
</code></a>, Вы можете видеть вызванное условие:
<pre>
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: select `test`.`t1`.`col1` AS `col1`,
 &lt;in_optimizer&gt;(`test`.`t1`.`col1`,
 &lt;exists&gt;(&lt;index_lookup&gt;(&lt;cache&gt;(`test`.`t1`.`col1`) in t2
 on key1 checking NULL
 where (`test`.`t2`.`col2` = `test`.`t1`.`col2`) having
 trigcond(&lt;is_not_null_test&gt;(`test`.`t2`.`key1`))))) AS
 `t1.col1 IN (select t2.key1 from t2 where t2.col2=t1.col2)` from `test`.`t1`
</pre>

<p>У использования вызванных условий есть некоторые исполнительные значения.
Выражение <code>NULL IN (SELECT ...)</code> теперь может вызвать полное
сканирование таблицы (которое является медленным), когда оно ранее не
сделало. Это цена, заплаченная за правильные результаты (цель стратегии более
аккуратного условия состояла в том, чтобы улучшить согласие, а не скорость).
</p>

<p>Для многотабличных подзапросов выполнение <code>NULL IN (SELECT ...)
</code> будет особенно медленным, потому что соединение оптимизатор не
оптимизирует для случая, где внешнее выражение <code>NULL</code>.
Это принимает, что такие подзапросы с <code>NULL</code> на левой стороне
очень редки, даже если есть статистические данные, которые указывают иное.
С другой стороны, если внешнее выражение могло бы быть <code>NULL</code>,
но никогда фактически не будет, нет никакого исполнительного штрафа.</p>

<p>Чтобы помочь оптимизатору лучше выполнять Ваши запросы,
используют эти подсказки:</p>
<ul><li><p>Объявите столбец как <code>NOT NULL</code>, если это действительно
так. Это также помогает другим аспектам оптимизатора, упрощая тестирование
условия для столбца.</li>

<li>Если Вы не должны отличить <code>NULL</code> от <code>FALSE</code>,
Вы можете легко избежать медленного пути выполнения. Замените сравнение,
которое похоже на это:
<pre>
<em><code>outer_expr</code></em> IN (SELECT <em><code>inner_expr</code></em> FROM ...)
</pre>

<p>вот на такое:
<pre>
(<em><code>outer_expr</code></em> IS NOT NULL) AND (<em><code>outer_expr</code></em>
IN (SELECT <em><code>inner_expr</code></em> FROM ...))
</pre>

<p>Тогда <code>NULL IN (SELECT ...)</code>
никогда не будет оцениваться, потому что MySQL прекращает оценивать часть
<a href="funct.htm#operator_and"><code>AND</code></a>
как только результат выражения ясен.</p>

<p>Другая возможная перезапись:
<pre>
EXISTS (SELECT <em><code>inner_expr</code></em> FROM ...
       WHERE <em><code>inner_expr</code></em>=<em><code>outer_expr</code></em>)
</pre>

<p>Это применилось бы, когда Вы не должны различить <code>NULL</code> и
<code>FALSE</code>, когда Вы можете фактически хотеть <code>EXISTS</code>.
</p></li></ul>

<p>Флаг <code>subquery_materialization_cost_based</code>
включает управление выбором между материализацией подзапроса и
преобразованием подзапроса <code>IN</code>-to-<code>EXISTS</code>. См.
<a href="#switchable-optimizations">раздел 9.9.2</a>.</p>

<h4><a name="limit-optimization"></a>9.2.1.19. Оптимизация запроса LIMIT</h4>
<p>Если Вы нуждаетесь только в конкретном количестве строк от набора
результатов, используйте <code>LIMIT</code> в запросе, вместо того, чтобы
принести целый набор результатов и выбросить дополнительные данные.</p>

<p>MySQL иногда оптимизирует запрос, у которого есть <code>LIMIT
<em><code>row_count</code></em></code>, но нет <code>HAVING</code>:</p>
<ul><li><p>Если Вы выбираете только несколько строк с <code>LIMIT</code>,
MySQL использует индексы в некоторых случаях, когда обычно это предпочло бы
делать полное сканирование таблицы.</li>

<li>Если Вы объединяете <code>LIMIT <em><code>row_count</code></em></code> с
<code>ORDER BY</code>, MySQL заканчивает сортировку, как только это нашло
первые <em><code>row_count</code></em> строк сортированного результата
вместо того, чтобы сортировать весь результат. Если упорядочивание сделано
при использовании индексирования, это очень быстро.
Если filesort должен быть сделан, все строки, которые соответствуют запросу
без <code>LIMIT</code>, выбраны и часть (или все они) отсортированы до того,
как найдутся первые <em><code>row_count</code></em>.
После того, как начальные строки были найдены, MySQL не сортирует
остаток набора результатов.</p>

<p>Одно проявление этого поведения то, что <code>ORDER BY</code>
с и без <code>LIMIT</code> может возвратить строки в различном порядке, как
описано позже в этом разделе.</li>

<li>Если Вы объединяете <code>LIMIT <em><code>row_count</code></em></code> с
<code>DISTINCT</code>, MySQL останавливается, как только он находит
<em><code>row_count</code></em> уникальных строк.</li>

<li>В некоторых случаях <code>GROUP BY</code>
может быть решен, читая индексирование в порядке (или делая сортировку на
индексе) и затем вычисляя резюме до изменений значения индекса. В этом случае
<code>LIMIT <em><code>row_count</code></em></code> не вычисляет
значения <code>GROUP BY</code>.</li>

<li>Как только MySQL послал необходимое число строк клиенту, это прерывает
запрос, если Вы не используете <code>SQL_CALC_FOUND_ROWS</code>.
Число строк может тогда быть получено с <code>SELECT FOUND_ROWS()</code>. См.
<a href="funct.htm#information-functions">раздел 13.14</a>.</li>

<li><code>LIMIT 0</code> быстро возвращает пустой набор. Это может быть
полезно для проверки законности запроса. Это может также использоваться,
чтобы получить типы столбцов результата, если Вы используете MySQL API,
который делает доступными метаданные набора результатов. С
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
Вы можете использовать опцию
<a href="programs.htm#option_mysql_column-type-info"><code>--column-type-info
</code></a>, чтобы вывести на экран типы столбца результата.</li>

<li>Если сервер использует временные таблицы, чтобы решить запрос, он
использует <code>LIMIT <em><code>row_count</code></em></code>, чтобы
вычислить, сколько пространства требуется.</p></li></ul>

<p>Если у многих строк есть идентичные значения в <code>ORDER BY</code>,
сервер свободен возвратить те строки в любом порядке, и может сделать
по-другому в зависимости от полного плана выполнения. Другими словами,
порядок сортировки тех строк недетерминирован
относительно неупорядоченных столбцов.</p>

<p>Один фактор, который затрагивает план выполнения,
<code>LIMIT</code>, так что <code>ORDER BY</code> с или без
<code>LIMIT</code> может возвратить строки в различных порядках.
Рассмотрите этот запрос, который отсортирован по столбцу
<code>category</code>, но недетерминирован относительно
столбцов <code>id</code> и <code>rating</code>:
<pre>
mysql&gt; SELECT * FROM ratings ORDER BY category;
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 | 1        | 4.5    |
|  5 | 1        | 3.2    |
|  3 | 2        | 3.7    |
|  4 | 2        | 3.5    |
|  6 | 2        | 3.5    |
|  2 | 3        | 5.0    |
|  7 | 3        | 2.7    |
+----+----------+--------+
</pre>

<p>Включение <code>LIMIT</code> может затронуть порядок строк в пределах
каждого значения <code>category</code>.
Например, это допустимый результат запроса:
<pre>
mysql&gt; SELECT * FROM ratings ORDER BY category LIMIT 5;
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 | 1        | 4.5    |
|  5 | 1        | 3.2    |
|  4 | 2        | 3.5    |
|  3 | 2        | 3.7    |
|  6 | 2        | 3.5    |
+----+----------+--------+
</pre>

<p>В каждом случае строки отсортированы по столбцу <code>ORDER BY</code>,
который является всем, что требуется стандартом SQL.</p>
<p>Если важно гарантировать тот же самый порядок строк и без
<code>LIMIT</code>, включайте дополнительные столбцы в <code>ORDER BY</code>,
чтобы сделать детерминированный порядок. Например, если значения
<code>id</code> уникальны, Вы можете сделать строки для данного
<code>category</code>, сортируя их по <code>id</code>:
<pre>
mysql&gt; SELECT * FROM ratings ORDER BY category, id;
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 | 1        | 4.5    |
|  5 | 1        | 3.2    |
|  3 | 2        | 3.7    |
|  4 | 2        | 3.5    |
|  6 | 2        | 3.5    |
|  2 | 3        | 5.0    |
|  7 | 3        | 2.7    |
+----+----------+--------+

mysql&gt; SELECT * FROM ratings ORDER BY category, id LIMIT 5;
+----+----------+--------+
| id | category | rating |
+----+----------+--------+
|  1 | 1        | 4.5    |
|  5 | 1        | 3.2    |
|  3 | 2        | 3.7    |
|  4 | 2        | 3.5    |
|  6 | 2        | 3.5    |
+----+----------+--------+
</pre>

<p>Оптимизатор действительно обрабатывает запросы
(и подзапросы) следующей формы:
<pre>
SELECT ... FROM <em><code>single_table</code></em> ...
       ORDER BY <em><code>non_index_column</code></em>
       [DESC] LIMIT [<em><code>M</code></em>,]<em><code>N</code></em>;
</pre>

<p>Эот тип запроса распространен в веб-приложениях, которые выводят на экран
только несколько строк от большего набора результатов. Например:
<pre>
SELECT col1, ... FROM t1 ... ORDER BY name LIMIT 10;
SELECT col1, ... FROM t1 ... ORDER BY RAND() LIMIT 15;
</pre>

<p>У буфера сортировки есть размер
<a href="server.htm#sysvar_sort_buffer_size"><code>sort_buffer_size</code>
</a>. Если элементы для <em><code>N</code></em> строк
являются достаточно небольшими, чтобы поместиться в буфер
(<em><code>M</code></em>+<em><code>N</code></em> строк, если
<em><code>M</code></em> указан), сервер может избегать использования файла
слияния и выполнить сортировку полностью в памяти, обрабатывая буфер вида
как приоритетную очередь:</p>

<ul><li><p>Просмотрите таблицу, вставляя избранные столбцы списка от каждой
выбранной строки в сортированном порядке в очередь. Если очередь полна,
выталкивается последняя строка в порядке сортировки.</li>

<li>Возвратите первые <em><code>N</code></em> строк от очереди. Если
задан <em><code>M</code></em>, пропустите первые <em><code>M</code></em>
строк и возвращайте следующие <em><code>N</code></em> строк.</p></li></ul>

<p>Ранее сервер выполнил эту работу при использовании файла
слияния для сортировки:</p>
<ul><li><p>Просмотрите таблицу, повторяя эти шаги до конца таблицы:</p>
<ul><li><p>Выберите строки, пока буфер не заполнен.</li>

<li>Запишите первые <em><code>N</code></em> строк в буфере
(<em><code>M</code></em>+<em><code>N</code></em>
строк, если задан <em><code>M</code></em>) в файл слияния.</p></li></ul></li>

<li>Сортируйте файл слияния и возвратите первые <em><code>N</code></em>
строк. Если задан <em><code>M</code></em>, пропустите <em><code>M</code></em>
строк и верните следующие <em><code>N</code></em> строк.</p></li></ul>

<p>Стоимость сканирования таблицы та же самая для методов очереди и файла
слияния, таким образом, оптимизатор выбирает между методами, основанными
на других затратах:</p>

<ul><li><p>Метод очереди вовлекает больше ресурсов центрального процессора
для того, чтобы вставить строки в очередь в нужном порядке.</li>
<li>У метода файла слияния есть затраты ввода/вывода, чтобы написать и
считать файл и ресурсы центрального процессора, чтобы сортировать это.
</p></li></ul>
<p>Оптимизатор рассматривает баланс между этими факторами для особых
значений <em><code>N</code></em> и размера строки.</p>

<h4><a name="row-constructor-optimization"></a>9.2.1.20.
Оптимизация выражения конструктора строки</h4>
<p>Конструкторы строки разрешают одновременные сравнения многократных
значений. Например, эти два запроса семантически эквивалентны:
<pre>
SELECT * FROM t1 WHERE (column1,column2) = (1,1);
SELECT * FROM t1 WHERE column1 = 1 AND column2 = 1;
</pre>

<p>Кроме того, оптимизатор обрабатывает оба выражения одинаково.</p>
<p>Оптимизатор, менее вероятно, будет использовать доступ к индексу, если
столбцы конструктора строки не покрывают префикс индекса. Рассмотрите
следующую таблицу, у которой есть первичный ключ на
<code>(c1, c2, c3)</code>:
<pre>
CREATE TABLE t1 (c1 INT, c2 INT, c3 INT, c4 CHAR(100),
       PRIMARY KEY(c1,c2,c3));
</pre>

<p>В этом запросе <code>WHERE</code> использует все столбцы в
индексировании. Однако, конструктор самой строки не покрывает префикс
индекса, так что в итоге оптимизатор использует только
<code>c1</code> (<code>key_len=4</code>, размер <code>c1</code>):
<pre>
mysql&gt; EXPLAIN SELECT * FROM t1
    -&gt;         WHERE c1=1 AND (c2,c3) &gt; (1,1)\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: t1
   partitions: NULL
 type: ref
possible_keys: PRIMARY
key: PRIMARY
key_len: 4
ref: const
 rows: 3
 filtered: 100.00
Extra: Using where
</pre>

<p>В таких случаях перезапись выражения конструктора строки, используя
эквивалентное выражение неконструктора может привести к более полному
использованию индекса. Для данного запроса конструктор строки и
эквивалентные выражения неконструктора:
<pre>
(c2,c3) &gt; (1,1)
c2 &gt; 1 OR ((c2 = 1) AND (c3 &gt; 1))
</pre>

<p>Перезапись запроса, чтобы использовать выражение неконструктора приводит
к оптимизатору, использующему все три столбца в индексе
(<code>key_len=12</code>):
<pre>
mysql&gt; EXPLAIN SELECT * FROM t1 WHERE c1 = 1 AND (c2 &gt; 1 OR
    -&gt;         ((c2 = 1) AND (c3 &gt; 1)))\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: t1
   partitions: NULL
 type: range
possible_keys: PRIMARY
key: PRIMARY
key_len: 12
ref: NULL
 rows: 3
 filtered: 100.00
Extra: Using where
</pre>

<p>Таким образом, для лучших результатов, избегите смешивать конструктор
строки с выражениями <a href="funct.htm#operator_and"><code>AND</code></a>/
<a href="funct.htm#operator_or"><code>OR</code></a>.</p>

<p>При определенных условиях оптимизатор может применить метод доступа
диапазона для <a href="funct.htm#function_in"><code>IN()</code></a>, у
которых есть параметры конструктора строки. См.
<a href="#row-constructor-range-optimization">раздел 9.2.1.3.5
</a>.</p>

<h4><a name="how-to-avoid-table-scan"></a>9.2.1.21.
Как избежать полного сканирования таблицы</h4>
<p>Вывод <a href="sql.htm#explain"><code>EXPLAIN</code></a> показывает
<a href="#jointype_all"><code>ALL</code></a> в столбце
<code>type</code>, когда MySQL использует
<a href="glossary.htm#glos_full_table_scan">полный просмотр таблицы</a>,
чтобы решить запрос. Это обычно происходит при следующих условиях:</p>

<ul><li><p>Таблица является настолько маленькой, что быстрее
выполнить сканирование таблицы чем обеспокоиться ключевым поиском.
Это характерно для таблиц меньше чем с 10 строками и короткой длиной строки.
</li>

<li>Нет никаких применимых ограничений в
<code>ON</code> или <code>WHERE</code> для индексированных столбцов.</li>
<li>Вы сравниваете индексированные столбцы с постоянными величинами, и MySQL
вычислил (основываясь на индексном дереве), что константы покрывают слишком
большую часть таблицы и сканирование таблицы было бы быстрее. См.
<a href="#where-optimizations">раздел 9.2.1.2</a>.</li>

<li>Вы используете ключ с низким количеством элементов (много строк
соответствуют значению ключа) через другой столбец. В этом случае MySQL
предполагает, что при использовании ключа, вероятно, сделает много ключевых
поисков и сканирование таблицы было бы быстрее.</p></li></ul>

<p>Для маленьких таблиц сканирование таблицы часто является соответствующим,
и исполнительное воздействие незначительно. Для больших таблиц
попробуйте следующие методы, чтобы избежать того, что оптимизатор
неправильно выбирает сканирование таблицы:</p>

<ul><li><p>Используйте <code>ANALYZE TABLE <em><code>tbl_name</code></em>
</code>, чтобы обновить ключевые распределения для просмотренной таблицы. См.
<a href="sql.htm#analyze-table">раздел 14.7.2.1</a>.</li>

<li>Используйте <code>FORCE INDEX</code> для просмотренной таблицы, чтобы
сказать MySQL, что сканирование таблицы очень дорого по сравнению с
использованием данного индекса:
<pre>
SELECT * FROM t1, t2 FORCE INDEX (<em><code>index_for_column</code></em>)
         WHERE t1.<em><code>col_name</code></em>=t2.<em><code>col_name</code></em>;
</pre>
<p>См. <a href="#index-hints">раздел 9.9.4</a>.</li>

<li>Запустите <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> с опцией <a href="server.htm#sysvar_max_seeks_for_key"><code>
--max-seeks-for-key=1000</code></a> или примените
<code>SET max_seeks_for_key=1000</code>, чтобы сказать оптимизатору
предполагать, что никакой ключевой просмотр не вызывает больше, чем 1000
ключевых поисков, см. <a href="server.htm#server-system-variables">раздел
6.1.5</a>.</p></li></ul>

<h3><a name="data-change-optimization"></a>9.2.2.
Оптимизация запросов изменения данных</h3>
<p>Этот раздел объясняет, как ускорить запросы изменения данных:
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>.
Традиционные приложения OLTP и современные веб-приложения, как правило,
делают много маленьких операций изменения данных, где параллелизм жизненно
важен. Анализ данных, как правило, выполняет операции изменения данных,
которые затрагивают много строк сразу, где основные соображения это
ввод/вывод, чтобы написать большие объемы данных и сохранить индекс
современным. Для вставки и обновления больших объемов данных (известный в
промышленности как ETL, от <span><span>extract-transform-load</span></span>),
иногда Вы используете другие запросы SQL или внешние команды, которые
имитируют эффекты <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>.</p>

<h4><a name="insert-speed"></a>9.2.2.1. Скорость INSERT</h4>
<p>Чтобы оптимизировать скорость вставок, комбинируют много маленьких
операций в единственную большую работу. Идеально, Вы делаете единственное
соединение, посылаете данные многих новых строк сразу и задерживаете все
индексные обновления и проверку последовательности до самого конца.</p>

<p>Время, требуемое для того, чтобы вставить строку, определено следующими
факторами, где числа указывают на приблизительные пропорции:</p>
<ul><li><p>Соединение: (3)</li>
<li>Посылка запроса к серверу: (2)</li>
<li>Парсинг запроса: (2)</li>
<li>Вставка строки: (размер строки)</li>
<li>Вставка индексов: (число индексов)</li>
<li>Закрытие: (1)</p></li></ul>

<p>Это не учитывает начальные издержки, чтобы открыть таблицы, которые
сделаны однажды для каждого одновременно работающего запроса.</p>
<p>Размер таблицы замедляет вставку индексов на
log <em><code>N</code></em> для индексов B-tree.</p>

<p>Вы можете использовать следующие методы, чтобы убыстрить вставку:</p>
<ul><li><p>Если Вы вставляете много строк от того же самого клиента в то же
самое время, стоит использовать <a href="sql.htm#insert"><code>INSERT</code>
</a> со списком <code>VALUES</code>, чтобы вставить несколько строк за один
раз. Это значительно быстрее (во много раз быстрее в некоторых случаях), чем
использование отдельного однострочного запроса
<a href="sql.htm#insert"><code>INSERT</code></a>.
Если Вы добавляете данные к непустой таблице, Вы можете настроить переменную
<a href="server.htm#sysvar_bulk_insert_buffer_size"><code>
bulk_insert_buffer_size</code></a>, чтобы сделать вставку данных еще быстрее.
См. <a href="server.htm#server-system-variables">раздел 6.1.5</a>.</li>

<li>Загружая таблицу из текстового файла, лучше использовать
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>.
Это обычно в 20 раз быстрее, чем использование
<a href="sql.htm#insert"><code>INSERT</code></a> в любом виде.
См. <a href="sql.htm#load-data">раздел 14.2.6</a>.</li>

<li>Используйте в своих интересах факт, что у столбцов есть значения по
умолчанию. Вставьте значения явно только, когда значение, которое будет
вставлено, отличается от значения по умолчанию. Это уменьшает парсинг,
который MySQL должен сделать и улучшает скорость вставки.</li>

<li>См. <a href="#optimizing-innodb-bulk-data-loading">раздел
9.5.5</a> для подсказок, определенных для таблиц <code>InnoDB</code>.</li>

<li>См. <a href="#optimizing-myisam-bulk-data-loading">раздел
9.6.2</a> для подсказок, определенных для таблиц <code>MyISAM</code>.
</p></li></ul>

<h4><a name="update-speed"></a>9.2.2.2. Скорость UPDATE</h4>
<p>Запрос обновления оптимизирован как
<a href="sql.htm#select"><code>SELECT</code></a>. Скорость записи зависит от
обновляемого объема данных и числа индексов, которые обновлены. Индексы,
которые не изменены, не становятся обновленными.</p>

<p>Другой способ получить быстрые обновления состоит в том, чтобы задержать
обновления и затем сделать много обновлений подряд позже. Выполнение
многократных обновлений вместе намного более быстро, чем выполнение
по одному, если Вы блокируете таблицу.</p>

<p>Для таблицы <code>MyISAM</code>, которая использует динамический формат
строки, обновление строку к большей полной длине может разделить строку. Если
Вы часто делаете это, очень важно использовать
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.
См. <a href="sql.htm#optimize-table">раздел 14.7.2.4</a>.</p>

<h4><a name="delete-speed"></a>9.2.2.3. Скорость DELETE</h4>
<p>Время, требуемое, чтобы удалить отдельные строки в
<code>MyISAM</code>, точно пропорционально числу индексов. Чтобы удалить
строки более быстро, Вы можете увеличить размер ключевого кэша, увеличивая
<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code></a>.
См. <a href="server.htm#server-configuration">раздел 6.1.1</a>.</p>

<p>Чтобы удалить все строки из <code>MyISAM</code>,
<code>TRUNCATE TABLE <em><code>tbl_name</code></em></code> быстрей, чем
<code>DELETE FROM <em><code>tbl_name</code></em></code>.
Усечение не безопасно для транзакции; ошибка происходит в ходе активной
транзакции или активной табличной блокировки. См.
<a href="sql.htm#truncate-table">раздел 14.1.30</a>.</p>

<h3><a name="permission-optimization"></a>9.2.3.
Оптимизация привилегий базы данных</h3>
<p>Чем более сложна Ваша установка привилегии, тем больше издержек
относится ко всем запросам SQL. Упрощение привилегий, установленных
<a href="sql.htm#grant"><code>GRANT</code></a>,
позволяет MySQL уменьшить издержки проверки разрешения, когда клиенты
выполняют запросы. Например, если Вы не предоставляете привилегий на уровне
столбца или на уровне таблицы, сервер никогда не должен проверять содержание
таблиц <code>tables_priv</code> и <code>columns_priv</code>.
Точно так же, если Вы не устанавливаете границ ресурса для каких-либо учетных
записей, сервер не должен выполнять подсчет ресурса. Если Вы имеете очень
высокую обрабатывающую запрос загрузку, рассмотрите использование упрощенной
структуры полномочий, чтобы уменьшить проверку разрешений.</p>

<h3><a name="information-schema-optimization"></a>9.2.4.
Оптимизация запросов INFORMATION_SCHEMA</h3>
<p>Приложения, которые контролируют базы данных, могут сделать частое
использование таблиц <code>INFORMATION_SCHEMA</code>.
Чтобы написать запросы для этих таблиц наиболее эффективно, используйте
следующие общие руководящие принципы:</p>

<ul><li><p>Попытайтесь запросить только таблицы <code>INFORMATION_SCHEMA
</code>, которые являются представлениями о таблицах словаря данных.</li>
<li>Попытайтесь запросить только для статических метаданных.
Выбор столбцов или использование условий извлечения для динамических
метаданных наряду со статическими метаданными добавляют издержки, чтобы
обработать динамические метаданные.</p></li></ul>

<p>Поведение сравнения для имен базы данных и имен таблиц в
<code>INFORMATION_SCHEMA</code> могут отличаться от того, что Вы ожидаете.
Для деталей см. <a href="global.htm#charset-collation-information-schema">
раздел 11.1.8.7</a>.</p>

<p>Эти таблицы <code>INFORMATION_SCHEMA</code> осуществлены как представления
о таблицах словаря данных, таким образом, запросы к ним получают информацию
из словаря данных:
<pre>
CHARACTER_SETS
COLLATIONS
COLLATION_CHARACTER_SET_APPLICABILITY
COLUMNS
KEY_COLUMN_USAGE
SCHEMATA
STATISTICS
TABLES
TABLE_CONSTRAINTS
VIEWS
</pre>

<p>Некоторые типы значений, даже не для представлений
<code>INFORMATION_SCHEMA</code>, получены поисками из словаря данных. Это
включает такие значения, как имена базы данных и имена таблиц, табличные
типы и механизмы хранения.</p>

<p>Некоторые таблицы <code>INFORMATION_SCHEMA</code>
содержат столбцы, которые обеспечивают табличную статистику:
<pre>
STATISTICS.CARDINALITY
TABLES.AUTO_INCREMENT
TABLES.AVG_ROW_LENGTH
TABLES.CHECKSUM
TABLES.CHECK_TIME
TABLES.CREATE_TIME
TABLES.DATA_FREE
TABLES.DATA_LENGTH
TABLES.INDEX_LENGTH
TABLES.MAX_DATA_LENGTH
TABLES.TABLE_ROWS
TABLES.UPDATE_TIME
</pre>

<p>Те столбцы представляют динамические табличные метаданные, то есть,
информация, которая изменяется как табличное содержание, изменяется.</p>
<p>У сервера есть два источника, из которых можно получить табличную
статистику. Переменная <a href="server.htm#sysvar_information_schema_stats">
<code>information_schema_stats</code></a> управляет тем, который табличный
источник статистики использует сервер:</p>

<ul><li><p>Когда <a href="server.htm#sysvar_information_schema_stats"><code>
information_schema_stats</code></a> <code>CACHED</code> (по умолчанию),
сервер использует кэшируемую статистику, сохраненную в табьлицах
<a href="inform.htm#statistics-table"><code>STATISTICS</code></a> и
<a href="inform.htm#tables-table"><code>TABLES</code></a>.</li>

<li>Когда <a href="server.htm#sysvar_information_schema_stats"><code>
information_schema_stats</code></a> <code>LATEST</code>,
сервер получает статистику непосредственно из механизмов хранения.
В этом случае сервер обрабатывает запросы к
<a href="inform.htm#statistics-table"><code>STATISTICS</code></a> и
<a href="inform.htm#tables-table"><code>TABLES</code></a>
как запросы для последней статистики, сохраненной в
<a href="inform.htm#statistics-table"><code>STATISTICS_DYNAMIC</code></a> и
<a href="inform.htm#tables-table"><code>TABLES_DYNAMIC</code></a>.
Сервер выполняет эту замену внутренне, Вы должны написать запросы, используя
имя таблицы без сйффикса <code>_DYNAMIC</code>. Например, когда
<a href="server.htm#sysvar_information_schema_stats"><code>
information_schema_stats</code></a> <code>LATEST</code>,
сервер обрабатывает этот запрос:
<pre>
SELECT * FROM INFORMATION_SCHEMA.TABLES;
</pre>

<p>как если бы Вы написали этот запрос:
<pre>
SELECT * FROM INFORMATION_SCHEMA.TABLES_DYNAMIC;
</pre></li></ul>

<p>Чтобы определить, как установлена
<a href="server.htm#sysvar_information_schema_stats"><code>
information_schema_stats</code></a>, рассмотрите обмены:</p>

<ul><li><p>Когда сервер запускается, кэшируемые статистические данные
<code>NULL</code>. Чтобы обновить их для данной таблицы, надо использовать
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
Это подвергается одноразовой стоимости вычисления статистики, но кэшируемые
статистические данные остаются современными пока таблица медленно изменяется.
Чтобы обновить кэшируемую статистику в любое время после этого, надо снова
использовать <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>.
</li>

<li>Для использования последней статистики
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
не необходим, но каждый запрос, который получает статистику, подвергается
несколько более высокой стоимости выполнения, чем для
использования кэшируемой статистики.</p></li></ul>

<p>Установите глобальное значение
<a href="server.htm#sysvar_information_schema_stats"><code>
information_schema_stats</code></a>, чтобы определить значение по умолчанию,
используемое первоначально всеми сеансами. Отдельные сеансы могут установить
сеансовое значение <a href="server.htm#sysvar_information_schema_stats">
<code>information_schema_stats</code></a>, чтобы переопределить глобальное
значение как надо.</p>

<p>Для таблиц <code>INFORMATION_SCHEMA</code>, осуществленных как
представления о таблицах словаря данных, индексы на основных таблицах
разрешают оптимизатору создать эффективные планы выполнения запроса.
Чтобы видеть выбор, сделанный оптимизатором, надо использовать
<a href="sql.htm#explain"><code>EXPLAIN</code></a>. Чтобы также видеть
запрос, используемый сервером, чтобы выполнить запрос
<code>INFORMATION_SCHEMA</code>, используйте <a href="sql.htm#show-warnings">
<code>SHOW WARNINGS</code></a> сразу после
<a href="sql.htm#explain"><code>EXPLAIN</code></a>.</p>

<p>Рассмотрите этот запрос, который идентифицирует сопоставления для
набора символов <code>utf8mb4</code>:
<pre>
mysql&gt; SELECT COLLATION_NAME
    -&gt;        FROM INFORMATION_SCHEMA.COLLATION_CHARACTER_SET_APPLICABILITY
    -&gt;        WHERE CHARACTER_SET_NAME = 'utf8mb4';
+----------------------+
| COLLATION_NAME       |
+----------------------+
| utf8mb4_general_ci   |
| utf8mb4_bin          |
| utf8mb4_unicode_ci   |
| utf8mb4_icelandic_ci |
| utf8mb4_latvian_ci   |
| utf8mb4_romanian_ci  |
| utf8mb4_slovenian_ci |
...
</pre>

<p>Как сервер обрабатывает этот запрос? Чтобы узнать, надо использовать
<a href="sql.htm#explain"><code>EXPLAIN</code></a>:
<pre>
mysql&gt; EXPLAIN SELECT COLLATION_NAME
    -&gt;         FROM INFORMATION_SCHEMA.COLLATION_CHARACTER_SET_APPLICABILITY
    -&gt;         WHERE CHARACTER_SET_NAME = 'utf8mb4'\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: cs
   partitions: NULL
 type: const
possible_keys: PRIMARY,name
key: name
key_len: 194
ref: const
 rows: 1
 filtered: 100.00
Extra: Using index
*************************** 2. row ***************************
 id: 1
  select_type: SIMPLE
table: col
   partitions: NULL
 type: ref
possible_keys: character_set_id
key: character_set_id
key_len: 8
ref: const
 rows: 68
 filtered: 100.00
Extra: NULL
2 rows in set, 1 warning (0.01 sec)
</pre>

<p>Чтобы видеть запрос, используемый для статистики, примените
<a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a>:
<pre>
mysql&gt; SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `mysql`.`col`.`name` AS `COLLATION_NAME`
 from `mysql`.`character_sets` `cs`
 join `mysql`.`collations` `col`
 where ((`mysql`.`col`.`character_set_id` = '45') and
 ('utf8mb4' = 'utf8mb4'))
</pre>

<p>Как обозначено <a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code>
</a>, сервер обрабатывает запрос на
<a href="inform.htm#collation-character-set-applicability-table">
<code>COLLATION_CHARACTER_SET_APPLICABILITY</code></a>
как запрос на таблицах <code>character_sets</code> и <code>collations</code>
словаря данных в системной базе данных <code>mysql</code>.</p>

<h3><a name="performance-schema-optimization"></a>9.2.5.
Оптимизация запросов Performance Schema</h3>
<p>Приложения, которые контролируют базы данных, могут сделать частое
использование таблиц Performance Schema. Чтобы написать запросы для этих
таблиц наиболее эффективно, используйте в своих интересах их индекс.
Например, включайте <code>WHERE</code>, который ограничивает полученные
строки, основанные на сравнении с определенными
значениями в индексированном столбце.</p>

<p>Большинство таблиц Performance Schema имеют индекс. Таблицы, которые не
имеют, обычно содержат немного строк или вряд ли будут часто запрашиваться.
Индексы Performance Schema предоставляют оптимизатору доступ к планам
выполнения, кроме полного сканирования таблицы. Они также улучшают работу для
связанных объектов, таких как представления схемы
<a href="sys.htm"><code>sys</code></a>, которые используют те таблицы.</p>

<p>Чтобы видеть, имеет ли данная таблица индексы и каковы они, надо
использовать <a href="sql.htm#show-index"><code>SHOW INDEX</code></a> или
<a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE</code></a>:
<pre>
mysql&gt; SHOW INDEX FROM performance_schema.accounts\G
*************************** 1. row ***************************
Table: accounts
   Non_unique: 0
 Key_name: ACCOUNT
 Seq_in_index: 1
  Column_name: USER
Collation: NULL
  Cardinality: NULL
 Sub_part: NULL
 Packed: NULL
 Null: YES
   Index_type: HASH
Comment:
Index_comment:
Visible: YES
*************************** 2. row ***************************
Table: accounts
   Non_unique: 0
 Key_name: ACCOUNT
 Seq_in_index: 2
  Column_name: HOST
Collation: NULL
  Cardinality: NULL
 Sub_part: NULL
 Packed: NULL
 Null: YES
   Index_type: HASH
Comment:
Index_comment:
Visible: YES

mysql&gt; SHOW CREATE TABLE performance_schema.rwlock_instances\G
*************************** 1. row ***************************
 Table: rwlock_instances
Create Table: CREATE TABLE `rwlock_instances` (
  `NAME` varchar(128) NOT NULL,
  `OBJECT_INSTANCE_BEGIN` bigint(20) unsigned NOT NULL,
  `WRITE_LOCKED_BY_THREAD_ID` bigint(20) unsigned DEFAULT NULL,
  `READ_LOCKED_BY_COUNT` int(10) unsigned NOT NULL,
  PRIMARY KEY (`OBJECT_INSTANCE_BEGIN`),
  KEY `NAME` (`NAME`),
  KEY `WRITE_LOCKED_BY_THREAD_ID` (`WRITE_LOCKED_BY_THREAD_ID`))
  ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8
</pre>

<p>Чтобы видеть план выполнения для запроса к Performance Schema
и использует ли это любой индекс, стоит использовать
<a href="sql.htm#explain"><code>EXPLAIN</code></a>:
<pre>
mysql&gt; EXPLAIN SELECT * FROM performance_schema.accounts
    -&gt;         WHERE (USER,HOST) = ('root','localhost')\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: accounts
   partitions: NULL
 type: const
possible_keys: ACCOUNT
key: ACCOUNT
key_len: 278
ref: const,const
 rows: 1
 filtered: 100.00
Extra: NULL
</pre>

<p>Вывод <a href="sql.htm#explain"><code>EXPLAIN</code></a>
указывает, что оптимизатор использует индекс <code>ACCOUNT</code> таблицы
<a href="perfor.htm#accounts-table"><code>accounts</code></a>, который
включает столбцы <code>USER</code> и <code>HOST</code>.</p>

<p>Индексы Performance Schema являются виртуальными: они конструкция
механизма хранения Performance Schema и не используют памяти или дискового
хранения. Исполнительные отчеты о Performance Schema
индексируют информацию оптимизатору так, чтобы это могло создать эффективные
планы выполнения. Performance Schema в свою очередь использует информацию
оптимизатора о том, что искать (например, особое значение ключа), так чтобы
это могло организовать эффективные поиски, не создавая фактической индексной
структуры. Это выполнение обеспечивает две важных выгоды:</p>

<ul><li><p>Это полностью избегает стоимости обслуживания, обычно понесенной
для таблиц, которые подвергаются частым обновлениям.</li>
<li>Это уменьшает на ранней стадии выполнения запроса полученный
объем данных. Для условий на индексированных столбцах Performance Schema
эффективно возвращает только строки таблицы, которые удовлетворяют условиям
запроса. Без индексирования Performance Schema возвратила бы все строки в
таблице, требуя, чтобы оптимизатор позже оценил условия для каждой строки,
чтобы произвести окончательный результат.</p></li></ul>

<p>Индексы Performance Schema предопределены и не могут быть удалены,
добавлены или изменены.</p>
<p>Индексы Performance Schema подобны хеш-индексам, например:</p>

<ul><li><p>Они используются только для сравнений равенства, которые
используют операторы <code>=</code> или <code>&lt;=&gt;</code>.</li>
<li>Если у результата запроса должны быть определенные характеристики
упорядочивания строки, включайте <code>ORDER BY</code>.</p></li></ul>
<p>См. <a href="#index-btree-hash">раздел 9.3.8</a>.</p>

<h3><a name="miscellaneous-optimization-tips"></a>9.2.6.
Другие подсказки по оптимизации</h3>
<p>Этот раздел перечисляет много разных подсказок для того, чтобы улучшить
скорость обработки запроса:</p>

<ul><li><p>Если Ваше приложение обращается с несколькими запросами, чтобы
выполнить связанные обновления, комбинирование запросов в сохраненную
подпрограмму может помочь работе. Точно так же, если Ваше приложение
вычисляет единственный результат, основанный на нескольких значениях
столбцов, или большие объемы данных, комбинирование вычислений в UDF
(определяемая пользователем функция) может помочь работе. Получающиеся
быстрые операции базы данных тогда доступны, чтобы быть снова использованными
другими запросами, приложениями и даже программам, написанным на различных
языках программирования. См. разделы
<a href="stored.htm#stored-routines">21.2</a> и
<a href="extend.htm#adding-functions">26.4</a>.</li>

<li>Установить любые проблемы сжатия, которые происходят с таблицами
<code>ARCHIVE</code>, используйте <a href="sql.htm#optimize-table"><code>
OPTIMIZE TABLE</code></a>. См. <a href="storage.htm#archive-storage-engine">
раздел 17.5</a>.</li>

<li>Если возможно, классифицируйте отчеты как <span><span>live</span></span>
или как <span><span>statistical</span></span>, где данные, необходимые для
статистических отчетов, создаются только из сводных таблиц, которые
периодически производятся от живых данных.</li>

<li>Если у Вас есть данные, которые не соответствуют хорошо структуре
таблицы строк-и-столбцов, Вы можете упаковать и хранить данные в столбце
<a href="types.htm#blob"><code>BLOB</code></a>. В этом случае Вы должны
обеспечить код в своем приложении, чтобы упаковать и распаковать информацию,
но это могло бы сохранить операции ввода/вывода, чтобы считать и написать
наборы связанных значений.</li>

<li>С веб-серверами, архивами изображений и другими двоичными активами
храните их как файлы с путем, сохраненным в базе данных. Большинство
веб-серверов лучше в кэшируемых файлах, чем в содержании базы данных, так как
использование файлов вообще быстрее. Хотя Вы должны обработать резервные
копии и проблемы хранения самостоятельно в этом случае.</li>

<li>Если Вы нуждаетесь в действительно высокой скорости, смотрите на низкий
уровень интерфейсов MySQL. Например, получая доступ к механизмам хранения
<code>InnoDB</code> или <code>MyISAM</code> напрямую, Вы можете получить
существенное увеличение скорости по сравнению с
использованием интерфейса SQL.</li>

<li>Репликация может обеспечить исполнительную выгоду для некоторых операций.
Вы можете распределить извлечения клиента среди серверов, чтобы разделить
загрузку. Чтобы избежать замедлять ведущее устройство, делая резервные копии,
Вы можете сделать резервные копии, используя ведомый сервер. См.
<a href="replica.htm">главу 19</a>.</p></li></ul>

<h2><a name="optimization-indexes"></a>9.3. Оптимизация и индексы</h2>
<p>Лучший способ улучшить исполнение
<a href="sql.htm#select"><code>SELECT</code></a> это
создать индексы на одном или больше столбцов, которые проверены в запросе.
Индексированные записи действуют как указатели на строки таблицы, позволяя
запросу быстро определить, какие строки соответствуют условию в
<code>WHERE</code> и получить другие значения столбцов для тех строк. Все
типы данных MySQL могут быть индексированы.</p>

<p>Хотя может быть заманчиво создать индексирование для каждого возможного
столбца, используемого в запросе, не нужный индекс тратит ненужное
пространство и напрасно тратит время для MySQL, чтобы определить, который
индекс использовать. Индексирование также добавляет свой вклад к стоимости
вставок, обновлений и удалений, потому что каждый индекс должен быть
обновлен. Вы должны найти правильный баланс, чтобы достигнуть быстрых
запросов, используя оптимальный набор индексов.</p>

<h3><a name="mysql-indexes"></a>9.3.1. Как MySQL использует индексы</h3>
<p>Индекс используются, чтобы найти строки с определенными значениями
столбцов быстро. Без индексирования MySQL должен начать с первой строки и
затем прочитать всю таблицу, чтобы найти соответствующие строки. Чем больше
таблица, тем больше это стоит. Если у таблицы есть индексирование для
рассматриваемых столбцов, MySQL может быстро определить позицию, чтобы искать
в середине файла с данными, не имея необходимости смотреть на все данные.
Это намного быстрее, чем чтение каждой строки последовательно.</p>

<p>Большинство индексов MySQL  (<code>PRIMARY KEY</code>,
<code>UNIQUE</code>, <code>INDEX</code> и <code>FULLTEXT</code>)
сохранены в <a href="glossary.htm#glos_b_tree">B-tree</a>.
Исключения: индексы на пространственных типах данных применяют R-tree,
таблицы <code>MEMORY</code> также поддерживают
<a href="glossary.htm#glos_hash_index">hash-индексы</a>, <code>InnoDB</code>
использует инвертированные списки для индексов <code>FULLTEXT</code>.</p>

<p>Вообще, индексы используются как описано в следующем обсуждении.
Характеристики, определенные для хеш-индекса (как используется в таблицах
<code>MEMORY</code>), описаны в
<a href="#index-btree-hash">разделе 9.3.8</a>.</p>

<p>MySQL применяет индексы для этих операций:</p>
<ul><li><p>Найти строки, соответствующие <code>WHERE</code>.</li>
<li>Устранить строки из соображения. Если есть выбор между многими индексами,
MySQL обычно использует индексирование, которое находит самое маленькое число
строк (самый <a href="glossary.htm#glos_selectivity">отборный</a> индекс).
</li>

<li>Если у таблицы есть многостолбцовый индекс, любой левый префикс
индексирования может использоваться оптимизатором, чтобы искать строки.
Например, если у Вас есть индекс на трех столбцах
<code>(col1, col2, col3)</code>, Вы можете искать по индексу на
<code>(col1)</code>, <code>(col1, col2)</code> и <code>(col1, col2, col3)
</code>. См. <a href="#multiple-column-indexes">раздел 9.3.5</a>.
</li>

<li>Получать строки от других таблиц, выполняя соединения. MySQL может
использовать индекс на столбцах более эффективно, если они объявлены как тот
же самый тип и размер. В этом контексте
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#char"><code>CHAR</code></a>
считаются тем же самым, если они объявлены как тот же самый размер. Например,
<code>VARCHAR(10)</code> и <code>CHAR(10)</code> имеют тот же самый размер,
но <code>VARCHAR(10)</code> и <code>CHAR(15)</code> нет.</p>

<p>Для сравнений между недвоичными строковыми столбцами оба столбца должны
использовать тот же самый набор символов. Например, сравнение столбцов
<code>utf8</code> и <code>latin1</code> устраняет использование индекса.</p>

<p>Сравнение несходных столбцов (сравнение строкового столбца с
временным или числовым столбцу, например) может предотвратить использование
индекса, если значения не могут быть сравнены непосредственно без
преобразования. Для данного значения <code>1</code>
в числовом столбце это могло бы сравниться с любым числом значений в
строковом столбце, таких как <code>'1'</code>, <code>' 1'</code>,
<code>'00001'</code> или <code>'01.e1'</code>.
Это исключает использование любого индекса для строкового столбца.</li>

<li>Найти <a href="funct.htm#function_min"><code>MIN()</code></a> или
<a href="funct.htm#function_max"><code>MAX()</code></a>
для определенного индексированного столбца <em><code>key_col</code></em>.
Это оптимизировано препроцессором, который проверяет, используете ли Вы
<code>WHERE <em><code>key_part_N</code></em> =
<em><code>constant</code></em></code> на всех ключевых частях, которые
происходят прежде <em><code>key_col</code></em>
в индексировании. В этом случае MySQL делает единственный ключевой поиск для
каждого выражения <a href="funct.htm#function_min"><code>MIN()</code></a> или
<a href="funct.htm#function_max"><code>MAX()</code></a>
и заменяет это константой. Если все выражения заменены константами, запрос
возвращается сразу. Например:
<pre>
SELECT MIN(<em><code>key_part2</code></em>),MAX(<em><code>key_part2</code></em>)
       FROM <em><code>tbl_name</code></em> WHERE <em><code>key_part1</code></em>=10;
</pre></li>

<li><p>Чтобы сортировать или сгруппировать таблицу, если сортировка или
группировка сделаны на левом префиксе применимого индексирования (например,
<code>ORDER BY <em><code>key_part1</code></em>,
<em><code>key_part2</code></em></code>). Если все ключевые части
сопровождаются <code>DESC</code>, ключ считан в обратном порядке. См. разделы
<a href="#order-by-optimization">9.2.1.15</a> и
<a href="#group-by-optimization">9.2.1.16</a>.</li>

<li>В некоторых случаях запрос может быть оптимизирован, чтобы получить
значения, не консультируясь со строками данных. Индексирование, которое
обеспечивает все необходимые результаты для запроса, называют
<a href="glossary.htm#glos_covering_index">покрывающим</a>.
Если запрос использует от таблицы только столбцы, которые включены в
некоторые индексы, выбранные значения могут быть получены от индексного
дерева для большей скорости:
<pre>
SELECT <em><code>key_part3</code></em> FROM <em><code>tbl_name</code></em>
       WHERE <em><code>key_part1</code></em>=1
</pre></li></ul>

<p>Индексы менее важны для запросов на маленьких таблицах или больших
таблицах, где запросы обрабатывают больше всего или все строки. Когда запрос
должен получить доступ к большинству строк, читать последовательно быстрее,
чем работа посредством индексирования. Последовательные чтения минимизируют
дисковый поиск, даже если не все строки необходимы для запроса. См.
<a href="#how-to-avoid-table-scan">раздел 9.2.1.21</a>.</p>

<h3><a name="optimizing-primary-keys"></a>9.3.2. Используя первичные ключи
</h3>
<p>Первичный ключ для таблицы представляет столбец или набор столбцов,
которые Вы используете в своих самых жизненных запросах. У этого есть
связанный индекс для быстрой работы запроса. Работа запроса извлекает выгоду
из оптимизации <code>NOT NULL</code>, поскольку это не может включать
значения <code>NULL</code>. С <code>InnoDB</code> табличные данные физически
организованы, чтобы сделать ультрабыстрые поиски и сортировки, основанные на
столбце или столбцах первичного ключа.</p>

<p>Если Ваша таблица является большой и важной, но не имеет очевидного
столбца или набора столбцов, чтобы использовать в качестве первичного ключа,
Вы могли бы создать отдельный столбец со значениями auto-increment, чтобы
использовать в качестве первичного ключа. Эти уникальные ID могут служить
указателями на соответствующие строки в других таблицах, когда Вы
присоединяетесь к таблицам, используя внешние ключи.</p>

<h3><a name="optimizing-foreign-keys"></a>9.3.3.
Используя внешние ключи</h3>
<p>Если у таблицы есть много столбцов, и Вы запрашиваете много различных
комбинаций столбцов, могло бы быть эффективно разделить менее часто
используемые данные на отдельные таблицы с несколькими столбцами
и связать их с основной таблицей, дублируя числовой столбец ID
от основной таблицы. Таким путем у каждой маленькой таблицы может быть
первичный ключ для быстрых поисков данных, и Вы можете запросить только набор
столбцов, в котором Вы нуждаетесь при использовании работы соединения.
В зависимости от того, как распределены данные, запросы могли бы выполнить
меньше ввода/вывода и занять меньше кэш-памяти, потому что соответствующие
столбцы упакованы вместе на диске. Чтобы максимизировать работу, запросы
пытаются читать так мало блоков данных, насколько возможно с диска, таблицы
только с несколькими столбцами могут приспособить больше строк в
каждом блоке данных.</p>

<h3><a name="column-indexes"></a>9.3.4. Столбец индекса</h3>
<p>Наиболее распространенный тип индекса вовлекает единственный столбец,
храня копии значений от того столбца в структуре данных, позволяя быстрые
поиски для строк с соответствующими значениями столбцов. Структура данных
B-tree позволяет индексированию быстро находить определенное значение, ряд
значений или диапазона значений, соответствуя таким операторам, как
<code>=</code>, <code>&gt;</code>, <code>BETWEEN</code>, <code>IN</code> и
т.д. в <code>WHERE</code>.</p>

<p>Максимальное количество индексов на таблицу и максимум длины
индекса определены механизмом хранения. См. главы
<a href="innodb.htm">16</a> и <a href="storage.htm">17</a>.
Все механизмы хранения поддерживают, по крайней мере, 16 индексов на таблицу
и общая длина по крайней мере 256 байтов.
У большинства механизмов хранения есть более высокие пределы.</p>
<p>См. <a href="sql.htm#create-index">раздел 14.1.12</a>.</p>

<h4><a name="idm139965372422944"></a>Префиксы индексов</h4>
<p>С <code><em><code>col_name</code></em>(<em><code>N</code></em>)</code> в
определении индекса для строкового столбца, Вы можете создать индексирование,
которое использует только первые
<em><code>N</code></em> символов столбца. Индексация только префикса
значений столбцов таким образом может сделать индексный файл намного меньшим.
Когда Вы индексируете столбец <a href="types.htm#blob"><code>BLOB</code></a>
или <a href="types.htm#blob"><code>TEXT</code></a>, Вы <span><em>должны</em>
</span> определить длину префикса для индексирования. Например:
<pre>
CREATE TABLE test (blob_col BLOB, INDEX(blob_col(10)));
</pre>

<p>Префиксы могут составить до 767 байтов для <code>InnoDB</code>,
которые используют формат строки
<code><a href="glossary.htm#glos_redundant_row_format">REDUNDANT</a></code>
или <code><a href="glossary.htm#glos_compact_row_format">COMPACT</a></code>.
Предел длины поднят до 3072 байтов для <code>InnoDB</code>, которые
используют формат строки <code><a href="glossary.htm#glos_dynamic_row_format">
DYNAMIC</a></code> или <code><a href="glossary.htm#glos_compressed_row_format">
COMPRESSED</a></code>. Для MyISAM размер префикса составляет 1000 байт.</p>

<p>Пределы измерены в байтах, тогда как длина префикса в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> и
<a href="sql.htm#create-index"><code>CREATE INDEX</code></a>
интерпретируется как число символов для недвоичных строковых типов
(<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#blob"><code>TEXT</code></a>)
и число байтов для двоичных строковых типов
(<a href="types.htm#binary-varbinary"><code>BINARY</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a>).
Примите это во внимание, определяя длину префикса для недвоичного строкового
столбца, который использует многобайтовый набор символов.</p>
<p>См. <a href="sql.htm#create-index">раздел 14.1.12</a>.</p>

<h4><a name="idm139965372389104"></a>Индексы FULLTEXT</h4>
<p>Индексы <code>FULLTEXT</code> используются для полнотекстовых поисков.
Только <a href="innodb.htm"><code>InnoDB</code></a> и
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>
поддерживают индексы <code>FULLTEXT</code> и только для столбцов
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>.
Индексация всегда имеет место по всему столбцу, префикс не используется.
См. <a href="funct.htm#fulltext-search">раздел 13.9</a>.</p>

<p>Оптимизация применена к определенным видам запросов <code>FULLTEXT</code>.
Запросы с этими характеристиками особенно эффективны:</p>
<ul><li><p>Запросы <code>FULLTEXT</code>, которые возвращают только
ID документа или ID документа и разряд поиска.</li>

<li>Запросы <code>FULLTEXT</code>, которые сортируют соответствующие строки в
порядке убывания счета и применяют <code>LIMIT</code>, чтобы взять первые N
соответствий строк. Для этой оптимизации не должно быть <code>WHERE</code> и
только один <code>ORDER BY</code> в порядке убывания.</li>

<li>Запросы <code>FULLTEXT</code>, которые получают только значение
<code>COUNT(*)</code> строк, соответствующих критерию поиска, без
дополнительного <code>WHERE</code>. Кодируйте <code>WHERE</code> как
<code>WHERE MATCH(<em><code>text</code></em>) AGAINST ('<em><code>other_text
</code></em>')</code>, без любых операторов сравнения <code>&gt; 0</code>.
</p></li></ul>

<h4><a name="idm139965372365568"></a>Пространственный индекс</h4>
<p>Вы можете создать индексы на пространственных типах данных.
<code>MyISAM</code> и <code>InnoDB</code> понимают индексы R-tree
на пространственных типах. Другие механизмы хранения используют B-деревья для
того, чтобы индексировать пространственные типы (за исключением
<code>ARCHIVE</code>, который не поддерживает пространственную индексацию).
</p>

<h4><a name="idm139965372362080"></a>Индексы в механизме хранения MEMORY</h4>
<p><code>MEMORY</code> применяет по умолчанию индексы
<code>HASH</code>, но также и <code>BTREE</code>.</p>

<h3><a name="multiple-column-indexes"></a>9.3.5. Многостолбцовые индексы</h3>
<p>MySQL может создать сводные индексы (то есть, индекс на многих столбцах).
Индексирование может состоять из 16 столбцов. Для определенных типов данных
Вы можете индексировать префикс столбца (см.
<a href="#column-indexes">раздел 9.3.4</a>).</p>

<p>MySQL может использовать многостолбцовый индекс для запросов, которые
проверяют все столбцы в индексировании или запросы, которые проверяют только
первый столбец, первые два столбца, первые три столбца и так далее. Если Вы
определяете столбцы в правильном порядке в определении индекса, единственный
сводный индекс может ускорить несколько видов запросов на той
же самой таблице.</p>

<p>Многостолбцовый индекс может считаться сортированным массивом, строки
которого содержат значения, которые созданы, связывая
значения индексированных столбцов.</p>

<p>Как альтернатива сводному индексу, Вы можете ввести столбец, который
является <span><span>хэшем</span></span>, основанный на информации от других
столбцов. Если этот столбец короток, разумно уникален и индексирован, это
могло бы быть быстрее, чем <span><span>широкий</span></span> индекс
на многих столбцах. В MySQL очень удобен этот дополнительный столбец:
<pre>
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>hash_col</code></em>=MD5(CONCAT(<em><code>val1</code></em>,
         <em><code>val2</code></em>)) AND
         <em><code>col1</code></em>=<em><code>val1</code></em> AND
         <em><code>col2</code></em>=<em><code>val2</code></em>;
</pre>

<p>Предположите, что у таблицы есть следующая спецификация:
<pre>
CREATE TABLE test (id INT NOT NULL, last_name CHAR(30) NOT NULL,
                   first_name CHAR(30) NOT NULL, PRIMARY KEY (id),
                   INDEX name (last_name, first_name));
</pre>

<p>Индекс <code>name</code> создан на столбцах
<code>last_name</code> и <code>first_name</code>.
Индексирование может использоваться для поисков в запросах, которые
определяют значения в известном диапазоне для комбинаций
<code>last_name</code> и <code>first_name</code>.
Это может также использоваться для запросов, которые определяют только
<code>last_name</code>, потому что этот столбец префикс
индексирования (как описано позже в этом разделе). Поэтому индекс
<code>name</code> используется для поисков в следующих запросах:
<pre>
SELECT * FROM test WHERE last_name='Widenius';
SELECT * FROM test WHERE last_name='Widenius' AND first_name='Michael';
SELECT * FROM test WHERE last_name='Widenius' AND (first_name='Michael' OR
         first_name='Monty');
SELECT * FROM test WHERE last_name='Widenius' AND first_name &gt;='M' AND
         first_name &lt; 'N';
</pre>

<p>Однако, <code>name</code> <span><em>не</em></span> используется для
поисков в следующих запросах:
<pre>
SELECT * FROM test WHERE first_name='Michael';
SELECT * FROM test WHERE last_name='Widenius' OR first_name='Michael';
</pre>

<p>Предположите, что Вы создаете такой
<a href="sql.htm#select"><code>SELECT</code></a>:
<pre>
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE col1=<em><code>val1</code></em> AND
         col2=<em><code>val2</code></em>;
</pre>

<p>Если многостолбцовый индекс существует на <code>col1</code> и
<code>col2</code>, соответствующие строки могут быть принесены
непосредственно. Если отдельный одностолбцовый индекс существует на
<code>col1</code> и <code>col2</code>, оптимизатор пытается использовать
оптимизацию Index Merge (см. <a href="#index-merge-optimization">
раздел 9.2.1.4</a>) или пытается найти самые строгие индексы, решая, который
индекс исключает больше строк и используя этот индекс, чтобы принести строки.
</p>

<p>Если у таблицы есть многостолбцовый индекс, любой префикс может
использоваться оптимизатором, чтобы искать строки. Например, если у Вас есть
индекс на три столбца <code>(col1, col2, col3)</code>, Вы имеете возможности
поиска на <code>(col1)</code>, <code>(col1, col2)</code> и
<code>(col1, col2, col3)</code>.</p>

<p>MySQL не может использовать индексирование, чтобы выполнить поиски, если
столбцы не формируют префикс индексирования. Предположите, что Вы имеете
<a href="sql.htm#select"><code>SELECT</code></a>, как показано:
<pre>
SELECT * FROM <em><code>tbl_name</code></em> WHERE col1=<em><code>val1</code></em>;
SELECT * FROM <em><code>tbl_name</code></em> WHERE col1=<em><code>val1</code></em> AND
         col2=<em><code>val2</code></em>;
SELECT * FROM <em><code>tbl_name</code></em> WHERE col2=<em><code>val2</code></em>;
SELECT * FROM <em><code>tbl_name</code></em> WHERE col2=<em><code>val2</code></em> AND
         col3=<em><code>val3</code></em>;
</pre>

<p>Если индексирование существует на <code>(col1, col2, col3)</code>,
только первые два запроса используют индексирование. Третий и четвертый
запросы действительно вовлекают индексированные столбцы, но
<code>(col2)</code> и <code>(col2, col3)</code> не префиксы для
<code>(col1, col2, col3)</code>.</p>

<h3><a name="verifying-index-usage"></a>9.3.6.
Подтверждение использования индекса</h3>
<p>Всегда проверяйте, используют ли все Ваши запросы действительно
индексирование, которое Вы создали в таблицах. Используйте
<a href="sql.htm#explain"><code>EXPLAIN</code></a>, как описано в
<a href="#using-explain">разделе 9.8.1</a>.</p>

<h3><a name="index-statistics"></a>9.3.7. Набор индексной статистики
InnoDB и MyISAM</h3>
<p>Механизмы хранения собирают статистические данные о таблицах для
использования оптимизатором. Табличные статистические данные основаны на
группах значения, где группа значения это ряд строк с тем же самым ключевым
значением префикса. В целях оптимизатора важная статистическая величина это
групповой размер среднего значения.</p>

<p>MySQL использует групповой размер среднего значения следующими способами:
</p>
<ul><li><p>Чтобы оценить, как строки должны быть считаны для каждого
доступа <a href="#jointype_ref"><code>ref</code></a>.</li>

<li>Оценить, сколько произведет строка частичных соединений,
то есть, число строк, которые произведет работа этой формы:
<pre>
(...) JOIN <em><code>tbl_name</code></em> ON
<em><code>tbl_name</code></em>.<em><code>key</code></em> = <em><code>expr</code></em>
</pre></li></ul>

<p>Как групповой размер среднего значения для увеличения индекса,
индексирование менее полезно в этих двух целях, потому что среднее число
строк за поиск увеличивается: для хорошего индексирования в целях
оптимизации лучше, чтобы каждый индекс обрабатывал небольшое количество строк
в таблице. Когда данный индекс приводит к большому количеству строк,
индексирование менее полезно, и MySQL, менее вероятно,
будет использовать это.</p>

<p>Групповой размер среднего значения связан с табличным количеством
элементов, которое является числом групп значения.
<a href="sql.htm#show-index"><code>SHOW INDEX</code></a>
выводит на экран значение количества элементов, основанное на
<em><code>N/S</code></em>, где <em><code>N</code></em> число строк в таблице
и <em><code>S</code></em> групповой размер среднего значения. Это отношение
приводит к приблизительному количеству групп значения в таблице.</p>

<p>Для соединения, основанного на операторе сравнения
<code>&lt;=&gt;</code>, <code>NULL</code>
не обработан по-другому ни от какого другого значения:
<code>NULL &lt;=&gt; NULL</code> так же, как
<code><em><code>N</code></em> &lt;=&gt; <em><code>N</code></em></code>
для любого другого <em><code>N</code></em>.</p>

<p>Однако, для соединения, основанного на операторе <code>=</code>,
<code>NULL</code> отличается от не-<code>NULL</code>:
<code><em><code>expr1</code></em> = <em><code>expr2</code></em></code>
не истина, когда <em><code>expr1</code></em> или
<em><code>expr2</code></em> (или оба) <code>NULL</code>. Это затрагивает
доступы <a href="#jointype_ref"><code>ref</code></a>
для сравнений формы <code><em><code>tbl_name.key</code></em> =
<em><code>expr</code></em></code>: MySQL не будет получать доступ к таблице,
если текущее значение <em><code>expr</code></em> = <code>NULL</code>,
потому что сравнение не может быть истиной.</p>

<p>Для сравнения <code>=</code> не имеет значения, сколько
<code>NULL</code> находятся в таблице. В целях оптимизации соответствующее
значение это средний размер группы значения не-<code>NULL</code>.
Однако, MySQL в настоящее время не позволяет этому среднему размеру быть
собранным или использоваться.</p>

<p>Для <code>InnoDB</code> и <code>MyISAM</code> Вы имеете некоторый контроль
над сбором табличной статистики посредством переменных
<a href="innodb.htm#sysvar_innodb_stats_method"><code>innodb_stats_method
</code></a> и <a href="server.htm#sysvar_myisam_stats_method"><code>
myisam_stats_method</code></a>, соответственно. У этих переменных есть три
возможных значения, которые отличаются следующим образом:</p>

<ul><li><p>Когда переменная установлена в <code>nulls_equal</code>,
значения <code>NULL</code> обработаны как идентичные (то есть, они все
формируют единственную группу значения).</p>

<p>Если групповой размер значения <code>NULL</code>
намного выше, чем среднее число значений не-<code>NULL</code>,
этот метод искажает групповой размер среднего значения вверх. Это делает
индекс менее полезным оптимизатору, чем это действительно для соединений,
которые ищут значения не-<code>NULL</code>. Следовательно, метод
<code>nulls_equal</code> может заставить оптимизатор не использовать
индексирование для доступов <a href="#jointype_ref"><code>ref
</code></a>, когда должен бы.</li>

<li>Когда переменная установлена в <code>nulls_unequal</code>,
<code>NULL</code> не считают теми же самыми. Вместо этого каждый
<code>NULL</code> формирует отдельную группу значения размера 1.</p>

<p>Если у Вас есть много <code>NULL</code>, этот метод искажает групповой
размер среднего значения вниз. Если среднее число не-<code>NULL</code>
является большим, рассчет каждого значения <code>NULL</code> как группы
размера 1 заставляет оптимизатор оценить слишком высоко значение
индексирования для соединений, которые ищут не-<code>NULL</code>.
Следовательно, метод <code>nulls_unequal</code>
может заставить оптимизатор использовать этот индекс для поиска
<a href="#jointype_ref"><code>ref</code></a>, когда другие методы
могут быть лучше.</li>
<li>Когда переменная установлена в <code>nulls_ignored</code>,
значения <code>NULL</code> проигнорированы.</p></li></ul>

<p>Если Вы склонны использовать много соединений то используйте
<code>&lt;=&gt;</code> виесто <code>=</code>, значения <code>NULL</code>
не являются особенными в сравнениях и один <code>NULL</code> равен другим.
В этом случае <code>nulls_equal</code> соответствующий метод статистики.</p>

<p>Переменная <a href="innodb.htm#sysvar_innodb_stats_method"><code>
innodb_stats_method</code></a> имеет глобальное значение,
<a href="server.htm#sysvar_myisam_stats_method"><code>myisam_stats_method
</code></a> имеет глобальное и значение сеанса. Установка глобального
значения затрагивает сбор статистики для таблиц от соответствующего
механизма хранения. Установка сеанса оценивает сбор статистики
только для текущего соединения клиента. Это означает, что Вы можете вынудить
статистику таблицы быть собранной с данным методом, не затрагивая других
клиентов, устанавливая значение сеанса
<a href="server.htm#sysvar_myisam_stats_method"><code>myisam_stats_method
</code></a>.</p>

<p>Восстановить табличную статистику <code>MyISAM</code> можно любым
из следующих методов:</p>
<ul><li><p>Выполнить <a href="programs.htm#myisamchk"><span><strong>myisamchk
--stats_method=<em><code>method_name</code></em> --analyze</strong></span>
</a>.</li>

<li>Изменить таблицу, чтобы заставить ее статистику устареть
(например, вставить строку и затем удалить ее), а затем установить
<a href="server.htm#sysvar_myisam_stats_method"><code>myisam_stats_method
</code></a> и скомандовать <a href="sql.htm#analyze-table"><code>ANALYZE
TABLE</code></a>.</p></li></ul>

<p>Некоторые протесты относительно использования
<a href="innodb.htm#sysvar_innodb_stats_method"><code>innodb_stats_method
</code></a> и <a href="server.htm#sysvar_myisam_stats_method"><code>
myisam_stats_method</code></a>:</p>

<ul><li><p>Вы можете вынудить табличную статистику быть собранной явно, как
только что описано. Однако, MySQL может также собрать статистические данные
автоматически. Например, если в течение выполнения запросов для таблицы,
некоторые из тех запросов изменяют таблицу, MySQL может собрать
статистические данные. Это может произойти для большей части вставок или
удалений или некоторых <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>. Если это происходит, статистические данные собраны, используя любое
значение <a href="innodb.htm#sysvar_innodb_stats_method"><code>
innodb_stats_method</code></a> или
<a href="server.htm#sysvar_myisam_stats_method"><code>myisam_stats_method
</code></a>. Таким образом, если Вы соберете статистические данные, используя
один метод, но системная переменная установлена в другой метод, когда
статистические данные таблицы будут собраны автоматически позже, то другой
метод будет использоваться.</li>

<li>Нет никакого способа сказать, какой метод использовался, чтобы произвести
статистику для данной таблицы.</li>
<li>Эти переменные применяются только к <code>InnoDB</code> и
<code>MyISAM</code>. У других механизмов хранения есть только один метод для
того, чтобы собрать табличные статистические данные. Обычно это ближе к
методу <code>nulls_equal</code>.</p></li></ul>

<h3><a name="index-btree-hash"></a>9.3.8.
Сравнение B-дерева и хеш-индекса</h3>
<p>Понимание B-дерева и структур данных хеша может помочь предсказать, как
различные запросы выступают на различных механизмах хранения, которые
используют эти структуры данных, особенно для механизма хранения
<code>MEMORY</code>, который позволяет Вам выбирать B-дерево или хеш-индекс.
</p>

<h4><a name="idm139965372219856"></a>Характеристики B-Tree</h4>
<p>B-tree может использоваться для сравнений столбца в выражениях, которые
используют операторы <a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_greater-than"><code>&gt;</code></a>,
<a href="funct.htm#operator_greater-than-or-equal"><code>&gt;=</code></a>,
<a href="funct.htm#operator_less-than"><code>&lt;</code></a>,
<a href="funct.htm#operator_less-than-or-equal"><code>&lt;=</code></a> или
<a href="funct.htm#operator_between"><code>BETWEEN</code></a>.
Индексирование также может использоваться для
<a href="funct.htm#operator_like"><code>LIKE</code></a>, если параметр
<a href="funct.htm#operator_like"><code>LIKE</code></a> постоянная строка,
которая не начинается с подстановочного символа. Например, следующий
<a href="sql.htm#select"><code>SELECT</code></a> использует индекс:
<pre>
SELECT * FROM <em><code>tbl_name</code></em> WHERE <em><code>key_col</code></em> LIKE 'Patrick%';
SELECT * FROM <em><code>tbl_name</code></em> WHERE <em><code>key_col</code></em> LIKE 'Pat%_ck%';
</pre>

<p>В первом запросе только строки с <code>'Patrick' &lt;=
<em><code>key_col</code></em> &lt; 'Patricl'</code>
рассмотрены. Во втором запросе только строки с <code>'Pat' &lt;= <em><code>
key_col</code></em> &lt; 'Pau'</code> рассмотрены.</p>

<p>Следующие <a href="sql.htm#select"><code>SELECT</code></a>
не используют индексы:
<pre>
SELECT * FROM <em><code>tbl_name</code></em> WHERE <em><code>key_col</code></em>
         LIKE '%Patrick%';
SELECT * FROM <em><code>tbl_name</code></em> WHERE <em><code>key_col</code></em>
         LIKE <em><code>other_col</code></em>;
</pre>

<p>В первом запросе <a href="funct.htm#operator_like"><code>LIKE</code></a>
начинается с с подстановочного символа. Во втором запросе значение
<a href="funct.htm#operator_like"><code>LIKE</code></a> не константа.</p>

<p>Если Вы используете <code>... LIKE '%<em><code>string</code></em>%'</code>
и <em><code>string</code></em> более длинно чем три символа, MySQL использует
алгоритм <span>Turbo Boyer-Moore</span>, чтобы инициализировать образец для
строки и затем использует этот образец, чтобы выполнить поиск более быстро.
</p>

<p>Использование поиска <code><em><code>col_name</code></em> IS NULL</code>
использует индекс, если <em><code>col_name</code></em> индексирован.</p>
<p>Любой индекс, который не охватывает все уровни
<a href="funct.htm#operator_and"><code>AND</code></a> в <code>WHERE</code>,
не используется, чтобы оптимизировать запрос. Другими словами, чтобы быть в
состоянии использовать индексирование, префикс должен использоваться в каждой
группе <a href="funct.htm#operator_and"><code>AND</code></a>.</p>

<p>Следующий <code>WHERE</code> использует индекс:
<pre>
... WHERE <em><code>index_part1</code></em>=1 AND
<em><code>index_part2</code></em>=2 AND <em><code>other_column</code></em>=3
/* <em><code>index</code></em> = 1 OR <em><code>index</code></em> = 2 */
... WHERE <em><code>index</code></em>=1 OR A=10 AND <em><code>index</code></em>=2

/* optimized like "<em><code>index_part1</code></em>='hello'" */
... WHERE <em><code>index_part1</code></em>='hello' AND
<em><code>index_part3</code></em>=5

/* Can use index on <em><code>index1</code></em> but not on
   <em><code>index2</code></em> or <em><code>index3</code></em> */
... WHERE <em><code>index1</code></em>=1 AND <em><code>index2</code></em>=2 OR
<em><code>index1</code></em>=3 AND <em><code>index3</code></em>=3;
</pre>

<p>Эти <code>WHERE</code> <span><em>не</em></span> используют индекс:
<pre>
/* <em><code>index_part1</code></em> is not used */
... WHERE <em><code>index_part2</code></em>=1 AND <em><code>index_part3</code></em>=2
/*  Index is not used in both parts of the WHERE clause  */
... WHERE <em><code>index</code></em>=1 OR A=10
/* No index spans all rows  */
... WHERE <em><code>index_part1</code></em>=1 OR
<em><code>index_part2</code></em>=10
</pre>

<p>Иногда MySQL не использует индексирование, даже если можно.
Одно обстоятельство, при котором это происходит, когда оптимизатор оценивает,
что использование индексирования потребовало бы, чтобы MySQL получил доступ к
очень большому проценту строк в таблице. В этом случае сканирование таблицы,
вероятно, будет намного быстрее, потому что оно требует меньше поисков.
Однако, если такой запрос использует <code>LIMIT</code>, чтобы получить
только некоторые из строк, MySQL использует индексирование так или иначе,
потому что он может намного более быстро найти немного строк.</p>

<h4><a name="idm139965372160672"></a>Характеристики Hash-индекса</h4>
<p>Hash-индекс имеет несколько иные характеристики:</p>
<ul><li><p>Они используются только для сравнений равенства, которые
используют операторы <code>=</code> или <code>&lt;=&gt;</code>
(зато <span><em>очень</em></span> быстро).
Они не используются для таких операторов сравнения, как <code>&lt;</code>,
для диапазона значений. Системы, которые полагаются на этот тип поиска
единственного значения, известны как <span><span>значение ключа</span>
</span>.</li>

<li>Оптимизатор не может использовать хеш-индекс, чтобы ускорить операции
<code>ORDER BY</code>. Этот тип индекса не может использоваться, чтобы искать
следующую запись в порядке.</li>

<li>MySQL не может определить приблизительно, сколько строк между двумя
значениями (это используется оптимизатором диапазона, чтобы решить, который
индекс использовать). Это может затронуть некоторые запросы, если Вы
изменяете <code>MyISAM</code> или <code>InnoDB</code> на <code>MEMORY</code>.
</li>

<li>Только целые ключи могут использоваться, чтобы искать строку. С
B-tree любой префикс ключа может использоваться, чтобы найти строки.
</p></li></ul>

<h3><a name="generated-column-index-optimizations"></a>9.3.9.
Использование оптимизатором произведенного столбца индекса</h3>
<p>MySQL понимает индексы на произведенных столбцах. Например:
<pre>
CREATE TABLE t1 (f1 INT, gc INT AS (f1 + 1) STORED, INDEX (gc));
</pre>

<p>Произведенный столбец <code>gc</code> определен как выражение
<code>f1 + 1</code>. Столбец также индексирован, и оптимизатор может взять
индекс во внимание во время конструкции плана выполнения. В следующем запросе
<code>WHERE</code> относится к <code>gc</code>, а оптимизатор рассматривает,
приводит ли индексирование на том столбце к более эффективному плану:
<pre>
SELECT * FROM t1 WHERE gc &gt; 9;
</pre>

<p>Оптимизатор может использовать индекс на произведенных столбцах, чтобы
произвести планы выполнения, даже в отсутствие прямых ссылок в запросах к тем
столбцам по имени. Это происходит, если <code>WHERE</code>,
<code>ORDER BY</code> или <code>GROUP BY</code> относится к выражению,
которое соответствует определению некоторого индексированного произведенного
столбца. Следующий запрос не обращается непосредственно к <code>gc</code>,
но действительно использует выражение, которое
соответствует определению <code>gc</code>:
<pre>
SELECT * FROM t1 WHERE f1 + 1 &gt; 9;
</pre>

<p>Оптимизатор признает что выражение <code>f1 + 1</code>
соответствует определению <code>gc</code>, и что <code>gc</code>
индексирован, таким образом, это учитывает индекс во время конструкции плана
выполнения. Вы можете видеть это через использование
<a href="sql.htm#explain"><code>EXPLAIN</code></a>:
<pre>
mysql&gt; EXPLAIN SELECT * FROM t1 WHERE f1 + 1 &gt; 9\G
*************************** 1. row ***************************
 id: 1
  select_type: SIMPLE
table: t1
   partitions: NULL
 type: range
possible_keys: gc
key: gc
key_len: 5
ref: NULL
 rows: 1
 filtered: 100.00
Extra: Using index condition
</pre>

<p>В действительности, оптимизатор заменил выражение <code>f1 + 1</code>
названием произведенного столбца, который соответствует выражению. Это также
очевидно в переписанном запросе, доступном в расширенном
<a href="sql.htm#explain"><code>EXPLAIN</code></a> с помощью
<a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a>:
<pre>
mysql&gt; SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t1`.`f1` AS `f1`,`test`.`t1`.`gc`
 AS `gc` from `test`.`t1` where (`test`.`t1`.`gc` &gt; 9)
</pre>

<p>Следующие ограничения и условия относятся к использованию
оптимизатором произведенного столбца:</p>
<ul><li><p>Для выражения запроса, чтобы соответствовать произведенному
определению столбца, выражение должно быть идентичным, и у него должен быть
тот же самый тип результата. Например, если произведенное выражение столбца
<code>f1 + 1</code>, оптимизатор не будет признавать соответствия, если
запрос будет использовать <code>1 + f1</code>, или если <code>f1 + 1</code>
(выражение целого числа) по сравнению со строкой.</li>

<li>Оптимизация относится к этим операторам:
<a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_less-than"><code>&lt;</code></a>,
<a href="funct.htm#operator_less-than-or-equal"><code>&lt;=</code></a>,
<a href="funct.htm#operator_greater-than"><code>&gt;</code></a>,
<a href="funct.htm#operator_greater-than-or-equal"><code>&gt;=</code></a>,
<a href="funct.htm#operator_between"><code>BETWEEN</code></a> и
<a href="funct.htm#function_in"><code>IN()</code></a>.</p>

<p>Для операторов кроме
<a href="funct.htm#operator_between"><code>BETWEEN</code></a> и
<a href="funct.htm#function_in"><code>IN()</code></a>
любой операнд может быть заменен произведенным столбцом соответствия. Для
<a href="funct.htm#operator_between"><code>BETWEEN</code></a> и
<a href="funct.htm#function_in"><code>IN()</code></a>
только первый параметр может быть заменен произведенным столбцом
соответствия, и у других параметров должен быть тот же самый тип результата.
<a href="funct.htm#operator_between"><code>BETWEEN</code></a> и
<a href="funct.htm#function_in"><code>IN()</code></a>
еще не поддержаны для сравнений, вовлекающих значения JSON.</li>

<li>Произведенный столбец должен быть определен как выражение, которое
содержит, по крайней мере, вызов функции или один из операторов, упомянутых в
предыдущем элементе. Выражение не может состоять из простой ссылки на другой
столбец. Например, <code>gc INT AS (f1) STORED</code>
состоит только из ссылки столбца, поэтому индекс на
<code>gc</code> не рассмотрен.</li>

<li>Для сравнений строк с индексированным произведенным столбцом,
которые вычисляют значение от функции JSON, которая возвращает заключенную в
кавычки строку, <a href="funct.htm#function_json-unquote"><code>
JSON_UNQUOTE()</code></a> необходим в определении столбца, чтобы удалить
дополнительные кавычки из функционального значения. Для прямого сравнения
строки с функциональным результатом JSON обрабтывает удаление кавычки, но
для индексного это не происходит. Например, вместо того, чтобы писать
определение столбца так:
<pre>
doc_name TEXT AS (JSON_EXTRACT(jdoc, '$.name')) STORED
</pre>

<p>Напишите это так:
<pre>
doc_name TEXT AS (JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name'))) STORED
</pre>

<p>С последним определением оптимизатор может обнаружить совпадение
обоих этих сравнений:
<pre>
... WHERE JSON_EXTRACT(jdoc, '$.name') = '<em><code>some_string</code></em>' ...
... WHERE JSON_UNQUOTE(JSON_EXTRACT(jdoc, '$.name')) = '<em><code>some_string</code></em>' ...
</pre>

<p>Ьез <a href="funct.htm#function_json-unquote"><code>JSON_UNQUOTE()</code>
</a> в определении столбца оптимизатор обнаруживает соответствие только для
первого из этих сравнений.</li>

<li>Если оптимизатор выбрал неверный индекс, индексные подсказки
могут использоваться, чтобы отключить его и вынудить оптимизатор
сделать иной выбор.</p></li></ul>

<h3><a name="invisible-indexes"></a>9.3.10. Невидимый индекс</h3>
<p>MySQL поддерживает невидимый индекс, то есть, индекс,
который не используется оптимизатором. Особенность относится к индексам,
кроме первичных ключей.</p>

<p>Индексы видимы по умолчанию. Чтобы управлять невидимостью явно для нового
индекса, используют <code>VISIBLE</code> или <code>INVISIBLE</code> как
часть индексного определения для <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a>, <a href="sql.htm#create-index"><code>CREATE INDEX</code>
</a> или <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>:
<pre>
CREATE TABLE t1 (i INT, j INT, k INT, INDEX i_idx (i) INVISIBLE)
       ENGINE = InnoDB;
CREATE INDEX j_idx ON t1 (j) INVISIBLE;
ALTER TABLE t1 ADD INDEX k_idx (k) INVISIBLE;
</pre>

<p>Чтобы изменить невидимость существующего индекса используют
<code>VISIBLE</code> или <code>INVISIBLE</code> в
<code>ALTER TABLE ... ALTER INDEX</code>:
<pre>
ALTER TABLE t1 ALTER INDEX i_idx INVISIBLE;
ALTER TABLE t1 ALTER INDEX i_idx VISIBLE;
</pre>

<p>Информация о том, видимо ли индексирование или нет, доступна из таблицы
<a href="inform.htm#statistics-table"><code>INFORMATION_SCHEMA.STATISTICS
</code></a> или вывода <a href="sql.htm#show-index"><code>SHOW INDEX</code>
</a>:
<pre>
mysql&gt; SELECT INDEX_NAME, IS_VISIBLE
    -&gt;        FROM INFORMATION_SCHEMA.STATISTICS
    -&gt;        WHERE TABLE_SCHEMA = 'db1' AND TABLE_NAME = 't1';
+------------+------------+
| INDEX_NAME | IS_VISIBLE |
+------------+------------+
| i_idx      | YES        |
| j_idx      |  NO        |
| k_idx      |  NO        |
+------------+------------+
</pre>

<p>Невидимый индекс позволяют проверить эффект удаления индексирования на
работе запроса, не производя разрушительное изменение. Передобавление
индексирования может быть дорогим для большой таблицы, тогда как переключение
невидимости индекса является быстрыми оперативными операциями.</p>

<p>Если невидимый индекс фактически необходим или используется оптимизатором,
есть несколько способов заметить эффект его отсутствия на
запросах для таблицы:</p>

<ul><li><p>Ошибки происходят для запросов, которые включают индексные
подсказки, которые обращаются к невидимому индексу.</li>
<li>Performance Schema показывает увеличение рабочей нагрузки
для затронутых запросов.</li>

<li>Запросы имеют отличающийся план выполнения
<a href="sql.htm#explain"><code>EXPLAIN</code></a>.</li>
<li>Запросы появляются в медленном журнале запроса, хотя
не появлялись там ранее.</p></li></ul>

<p>Невидимость не затрагивает обслуживание. Например, индексирование
продолжает обновляться при изменении строк таблицы, и уникальный индекс
предотвращает вставку дубликатов в столбец, независимо от того, видимо ли
индексирование или невидимо.</p>

<p>У таблицы без явного первичного ключа может все еще быть
эффективный неявный первичный ключ, если у этого есть индекс
<code>UNIQUE</code> на столбцах <code>NOT NULL</code>.
В этом случае первый такой индекс имеет то же самое ограничение на строки
таблицы как явный первичный ключ и индекс не может быть сделан невидимым.
Рассмотрите следующее табличное определение:
<pre>
CREATE TABLE t2 (i INT NOT NULL, j INT NOT NULL, UNIQUE j_idx (j))
       ENGINE = InnoDB;
</pre>

<p>Определение не включает явного первичного ключа, но индекс на
столбце <code>j</code> <code>NOT NULL</code> помещает то же самое ограничение
на строки, как первичный ключ и не может быть сделан невидимым:
<pre>
mysql&gt; ALTER TABLE t2 ALTER INDEX j_idx INVISIBLE;
ERROR 3522 (HY000): A primary key index cannot be invisible.
</pre>

<p>Теперь предположите, что явный первичный ключ добавлен к таблице:
<pre>
ALTER TABLE t2 ADD PRIMARY KEY (i);
</pre>

<p>Явный первичный ключ не может быть сделан невидимым. Кроме того,
уникальные индексы на <code>j</code> действуют как неявный
первичный ключ и в результате не могут быть сделаны невидимыми:
<pre>
mysql&gt; ALTER TABLE t2 ALTER INDEX j_idx INVISIBLE;
Query OK, 0 rows affected (0.03 sec)
</pre>

<h2><a name="optimizing-database-structure"></a>9.4.
Оптимизация структуры базы данных</h2>
<p>В Вашей роли проектировщика базы данных, ищите самый эффективный способ
организовать Ваши схемы, таблицы и столбцы. Настраивая код программы, Вы
минимизируете ввод/вывод, держите связанные элементы вместе и планируете
заранее, чтобы работа осталась высокой, когда объем данных увеличивается.</p>

<h3><a name="data-size"></a>9.4.1. Оптимизация размера данных</h3>
<p>Разработайте свои таблицы, чтобы минимизировать их место на диске. Это
может привести к огромным усовершенствованиям, уменьшая объем данных,
написанный и прочитанный с диска. Меньшие таблицы обычно требуют менее
основной памяти, в то время как их содержание активно обрабатывается во время
выполнения запроса. Любое сокращение пространства для табличных данных также
приводит к меньшему индексу, который может быть обработан быстрее.</p>

<p>MySQL поддерживает много различных механизмов хранения (табличные типы) и
форматов строк. Для каждой таблицы Вы можете решить, который метод хранения и
индексации использовать. Выбор надлежащего формата таблицы для Вашего
приложения может дать Вам большой прирост производительности. См. главы
<a href="innodb.htm">16</a> и <a href="storage.htm">17</a>.</p>
<p>Вы можете получить лучшую работу для таблицы и минимизировать место для
хранения при использовании методов, перечисленных здесь:</p>

<h4><a name="idm139965372039248"></a>Столбцы таблицы</h4>
<ul><li><p>Используйте самые эффективные (самые маленькие) возможные типы
данных. У MySQL есть много специализированных типов, которые сохраняют
дисковое пространство и память. Например, используйте меньшие типы целого
числа если возможно, чтобы получить меньшие таблицы.
<a href="types.htm#integer-types"><code>MEDIUMINT</code></a>
часто лучший выбор, чем
<a href="types.htm#integer-types"><code>INT</code></a>, поскольку столбец
<a href="types.htm#integer-types"><code>MEDIUMINT</code></a>
использует на 25% меньше пространства.</li>

<li>Объявите, что столбцы <code>NOT NULL</code>, если возможно.
Это делает операции SQL быстрее, включая лучшее использование индексов
и устранение издержек для того, чтобы проверить, является ли каждое значение
<code>NULL</code>. Вы также сохраняете некоторое место для хранения, один бит
на столбец. Если Вы действительно нуждаетесь в <code>NULL</code>
в Ваших таблицах, используйте их. Только избегайте настройки по умолчанию,
которая позволяет <code>NULL</code> в каждом столбце.</p></li></ul>

<h4><a name="idm139965372029376"></a>Формат строки</h4>
<ul><li><p><code>InnoDB</code> составлены, используя формат строки
<code>DYNAMIC</code> по умолчанию, и формат строки значения по умолчанию
конфигурируем с применением опции
<a href="innodb.htm#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a>.</p>

<p>Чтобы запросить формат строки не <code>DYNAMIC</code>, Вы можете
сконфигурировать <a href="innodb.htm#sysvar_innodb_default_row_format"><code>
innodb_default_row_format</code></a> или указать опцию <code>ROW_FORMAT
</code> явно в <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
или <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</p>

<p>Компактная строка уменьшает место для хранения строки приблизительно на
20% за счет увеличивающегося использования центрального процессора для
некоторых операций. Если Ваша рабочая нагрузка будет типичной, которая
ограничена частотами успешных обращений кэша и дисковой скоростью, то это,
вероятно, будет быстрее. Если это редкий случай, который ограничен скоростью
центрального процессора, это могло бы быть медленнее.</p>

<p>Компактный формат также изменяет, как столбцы
<a href="types.htm#char"><code>CHAR</code></a> хранят
<code>utf8</code> или <code>utf8mb4</code>. С <code>ROW_FORMAT=REDUNDANT
</code> столбец <code>utf8</code> или <code>utf8mb4</code>
<code>CHAR(<em><code>N</code></em>)</code> занимает максимальную символьную
длину в байтах*<em><code>N</code></em> байт.
Много языков могут быть написаны, используя однобайтовые символы
<code>utf8</code> или <code>utf8mb4</code>, таким образом, фиксированная
длина хранения часто тратит впустую пространство. С
<code>ROW_FORMAT=COMPACT</code> <code>InnoDB</code>
выделяет переменное количество места для этих столбцов, отрезая конечные
пробелы в случае необходимости. Минимальная длина хранения сохранена как
<em><code>N</code></em> байт, чтобы облегчить оперативные обновления в
типичных случаях. Для получения дополнительной информации см.
<a href="innodb.htm#innodb-physical-record">раздел 16.8.2</a>.</li>

<li>Чтобы минимизировать пространство, храня табличные данные в сжатой
форме, надо определить <code>ROW_FORMAT=COMPRESSED</code> при создании
таблицы <code>InnoDB</code> или выполнить
<a href="programs.htm#myisampack"><span><strong>myisampack</strong></span>
</a> на существующей таблице <code>MyISAM</code>. Сжатые таблицы
<code>InnoDB</code> читаемы и перезаписываемы в то время, как сжатые таблицы
<code>MyISAM</code> только для чтения.</li>

<li>Для таблиц <code>MyISAM</code>, если у Вас нет никаких столбцов
переменной длины (<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>), формат строки фиксированного
размера используется. Это быстрее, но может потратить впустую некоторое
пространство. См. <a href="storage.htm#myisam-table-formats">раздел 17.2.3
</a>. Вы можете подсказать, что хотите иметь строки фиксированной длины, даже
если Вы имеете столбцы <a href="types.htm#char"><code>VARCHAR</code></a>,
опцией <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
<code>ROW_FORMAT=FIXED</code>.</p></li></ul>

<h4><a name="idm139965371990704"></a>Индексы</h4>
<ul><li><p>Первичный индекс таблицы, должен быть настолько коротким,
насколько возможно. Это делает идентификацию каждой строки легкой и
эффективной. Для <code>InnoDB</code> столбцы primary key
дублированы в каждом вторичном индексе, таким образом, короткий первичный
ключ оставляет значительное свободное место, если Вы имеете
много вторичных индексов.</li>

<li>Создайте только индексирование, которое улучшит работу запроса.
Индексы хороши для извлечения, но замедляют вставки и обновления.
Если Вы получаете доступ к таблице главным образом, ища на комбинации
столбцов, создайте единственный сводный индекс на них, а не отдельный индекс
для каждого столбца. Первая часть индекса должна быть наиболее используемым
столбцом. Если Вы <span><em>всегда</em></span> используете много столбцов,
выбирая из таблицы, первый столбец в индексировании должен быть с
большинством дубликатов, чтобы получить лучшее сжатие индексирования.</li>

<li>Если вероятно, что у длинного строкового столбца есть уникальный префикс
на первом числе символов, лучше индексировать только этот префикс, используя
поддержку MySQL создания индексирования на префиксе столбца (см.
<a href="sql.htm#create-index">раздел 14.1.12</a>).
Короткий индекс быстрее не только потому, что он требует меньшего количества
дискового пространства, но и потому что он также дает Вам больше хитов в
индексном кэше, и таким образом меньше дисковых поисков. См.
<a href="server.htm#server-configuration">раздел 6.1.1</a>.</p></li></ul>

<h4><a name="idm139965371983280"></a>Joins</h4>
<ul><li><p>При некоторых обстоятельствах может быть выгодно
разделить на две таблицу, которая просматривается очень часто.
Это особенно верно, если это таблица динамического формата, и возможно
использовать меньшую статическую таблицу, которая может использоваться, чтобы
найти соответствующие строки, просматривая таблицу.</li>

<li>Объявите столбцы с идентичной информацией в различных таблицах с
идентичными типами данных, чтобы ускорить соединения, основанные
на соответствующих столбцах.</li>

<li>Сохраните имена столбцов простыми, так, чтобы Вы могли использовать то же
самое имя через различные таблицы и упростить запросы соединения. Например, в
таблице <code>customer</code> используйте столбец
<code>name</code> вместо <code>customer_name</code>.
Чтобы сделать Ваши имена переносимыми к другим SQL-серверам, рассмотрите
их сохранение короче 18 символов.</p></li></ul>

<h4><a name="idm139965371976816"></a>Нормализация</h4>
<ul><li><p>Обычно попытайтесь сохранить все данные безызбыточными
(то, что упомянуто в теории базы данных как <span>third normal form</span>).
Вместо того, чтобы повторить длинные значения, такие как имена и адреса,
назначьте им уникальные ID, повторите эти ID где надо через меньшие таблицы
и присоединитесь к таблицам в запросах, ссылаясь на ID в join.</li>

<li>Если скорость более важна, чем дисковое пространство и затраты на
обслуживание хранения многократных копий данных, например в скрипте
бизнес-анализа, откуда Вы анализируете все данные больших таблиц, Вы можете
ослабить правила нормализации, дублируя информацию или создавая сводные
таблицы, чтобы получить больше скорости.</p></li></ul>

<h3><a name="optimize-data-types"></a>9.4.2.
Оптимизация типов данных MySQL</h3>
<h4><a name="optimize-numeric"></a>9.4.2.1.
Оптимизация для числовых данных</h4>
<ul><li><p>Для уникальных ID или других значений, которые могут быть
представлены как строки или как числа, предпочтите, чтобы числовые столбцы
представили столбцы в виде строки. Так как большие числовые значения могут
быть сохранены в меньшем количестве байтов чем соответствующие строки, это
быстрее и берет меньше памяти, чтобы передать и сравнить их.</li>

<li>Если Вы используете числовые данные, во многих случаях быстрее запросить
базу данных, чем получить доступ к текстовому файлу. Информация в базе
данных, вероятно, будет храниться в более компактном формате, чем в текстовом
файле, так чир доступ вовлекает меньше дисковых поисков. Вы также сохраняете
код в своем приложении, потому что Вы можете избежать разбирать текстовый
файл, чтобы найти границы столбца и строки.</p></li></ul>

<h4><a name="optimize-character"></a>9.4.2.2.
Оптимизация для типов символа и строки</h4>
<ul><li><p>Используйте двоичный порядок сопоставления для быстрого сравнения
и сортировки, когда Вы не нуждаетесь в определенных для языка особенностях
сопоставления. Вы можете использовать оператор
<a href="funct.htm#operator_binary"><code>BINARY</code></a>, чтобы
использовать двоичное сопоставление в пределах особого запроса.</li>

<li>Сравнивая значения от различных столбцов, объявите те столбцы с тем же
самым набором символов и сопоставлением везде, где возможно, чтобы избежать
строковых преобразований, выполняя запрос.</li>

<li>Для значений столбцов меньше 8 КБ в размере, используйте двоичный
<code>VARCHAR</code> вместо <code>BLOB</code>. <code>GROUP BY</code> и
<code>ORDER BY</code> могут произвести временные таблицы, и эти временные
таблицы могут использовать <code>MEMORY</code>,
если оригинальная таблица не содержит <code>BLOB</code>.</li>

<li>Если таблица содержит строковые столбцы, такие как имя и адрес, но много
запросов не получают те столбцы, рассмотрите выделение строковых столбцов в
отдельную таблицу и использование запросов соединения с внешним ключом, когда
необходимо. Когда MySQL получает любое значение от строки, он читает блок
данных, содержащий все столбцы той строки (и возможно других смежных строк).
Хранение каждой небольшой строки, с только наиболее часто используемыми
столбцами, позволяет большему количеству строк помещаться в каждый блок
данных. Такие компактные таблицы уменьшают дисковый ввод/вывод и
использование памяти для общих запросов.</li>

<li>Когда Вы используете беспорядочно произведенное значение в качестве
первичного ключа в <code>InnoDB</code>, примените префикс
со значением возрастания, таким как текущая дата и время, если возможно.
Когда последовательные основные значения физически сохранены друг около
друга, <code>InnoDB</code> может вставить и получить их быстрее.</li>
<li>См. <a href="#optimize-numeric">раздел 9.4.2.1</a>.
</p></li></ul>

<h4><a name="optimize-blob"></a>9.4.2.3. Оптимизация для BLOB</h4>
<ul><li><p>Храня большой blob, содержащий текстовые данные, рассмотрите
сжатие этого сначала. Не используйте этот метод, когда вся таблица сжата
<code>InnoDB</code> или <code>MyISAM</code>.</li>

<li>Для таблицы с несколькими столбцами, чтобы уменьшить требования к памяти
для запросов, которые не используют столбец BLOB, рассмотрите выделение
столбца BLOB в отдельную таблицу и ссылку на него с
соединением при необходимости.</li>

<li>Так как эксплуатационные требования, чтобы получить и вывести на экран
значение BLOB могли бы очень отличаться от других типов данных, Вы могли
поместить спецтаблицу на иное устройство хранения данных или даже отдельный
экземпляр базы данных. Например, получение BLOB могло бы потребовать большого
последовательного чтения с диска, что лучше подходит для традиционного
жесткого диска, чем для <a href="glossary.htm#glos_ssd">SSD device</a>.</li>
<li>См. <a href="#optimize-character">раздел 9.4.2.2</a>.</li>

<li>Вместо того, чтобы проверять на равенство против очень длинной текстовой
строки, Вы можете сохранить хеш значения столбца в отдельном столбце,
индексировать тот столбец и проверить хешированное значение в запросах.
Используйте функции <code>MD5()</code> или <code>CRC32()</code>, чтобы
произвести значение хеша. Так как функции хеша могут привести к двойным
результатам для различных вводов, Вы все еще включаете пункт
<code>AND <em><code>blob_column</code></em> =
<em><code>long_string_value</code></em></code> в запрос, чтобы принять меры
против ложных соответствий, исполнительная выгода прибывает из меньшего,
легко просматриваемого индекса для хешированных значений.</p></li></ul>

<h4><a name="procedure-analyse"></a>9.4.2.4. Применение PROCEDURE ANALYSE</h4>
<p><code>ANALYSE([<em><code>max_elements</code></em>[,<em><code>max_memory
</code></em>]])</code></p>

<p><code>ANALYSE()</code> исследует следствие запроса и возвращает анализ
результатов, который предлагает оптимальные типы данных для каждого столбца,
который может помочь уменьшить табличные размеры.
Чтобы получить этот анализ, добавьте <code>PROCEDURE ANALYSE</code>
к концу запроса <a href="sql.htm#select"><code>SELECT</code></a>:
<pre>
SELECT ... FROM ... WHERE ...
PROCEDURE ANALYSE([<em><code>max_elements</code></em>,[<em><code>max_memory</code></em>]])
</pre>

<p>Например:
<pre>
SELECT col1, col2 FROM table1 PROCEDURE ANALYSE(10, 2000);
</pre>

<p>Результаты показывают немного статистики для значений, возвращенных
запросом, и предлагают оптимальный тип данных для столбцов. Это может быть
полезно для того, чтобы проверить Ваши существующие таблицы, или после
импортирования новых данных. Вы, возможно, должны попробовать различные
настройки так, чтобы <code>PROCEDURE ANALYSE()</code> не предлагал тип данных
<a href="types.htm#enum"><code>ENUM</code></a>, когда это
не является соответствующим.</p>

<p>Параметры являются дополнительными и используются следующим образом:</p>
<ul><li><p><em><code>max_elements</code></em> (по умолчанию 256)
максимальное количество отличных значений уведомлений <code>ANALYSE()</code>
на столбец. Это используется <code>ANALYSE()</code>, чтобы
проверять, должен ли оптимальный тип данных иметь тип
<a href="types.htm#enum"><code>ENUM</code></a>, если есть больше, чем
<em><code>max_elements</code></em> отличных значений, тогда
<a href="types.htm#enum"><code>ENUM</code></a> не подходит.</li>

<li><em><code>max_memory</code></em> (по умолчанию 8192) задает
максимальный объем памяти, который <code>ANALYSE()</code>
должен выделить столбцу, пытаясь найти все отличные значения.</p></li></ul>

<h3><a name="optimize-multi-tables"></a>9.4.3.
Оптимизация для многих таблиц</h3>
<p>Некоторые методы для того, чтобы сохранить отдельные запросы быстрыми,
вовлекают данные о разделении через многие таблицы. Когда число таблиц
сталкивается с тысячами или даже миллионами, издержки контакта со всеми этими
таблицами становятся новым исполнительным соображением.</p>

<h4><a name="table-cache"></a>9.4.3.1.
Как MySQL открывает и закрывает таблицы</h4>
<p>Когда Вы выполняете <a href="programs.htm#mysqladmin"><span><strong>
mysqladmin status</strong></span></a>, Вы должны видеть что-то вроде этого:
<pre>
Uptime: 426 Running threads: 1 Questions: 11082
Reloads: 1 Open tables: 12
</pre>

<p><code>Open tables</code> = 12 может быть несколько озадачивающим, если у
Вас есть только шесть таблиц.</p>
<p>MySQL мультипоточен, таким образом может быть много клиентов, выпускающих
запросы для данной таблицы одновременно. Чтобы минимизировать проблему с
многократными сеансами клиента, имеющими различные состояния на той же самой
таблице, таблица открыта независимо каждым параллельным сеансом.
Это использует дополнительную память, но обычно ускоряет работу. С
<code>MyISAM</code> один дополнительный описатель файла требуется для файла с
данными для каждого клиента, у которого есть открытая таблица. В отличие от
этого, описатель индексного файла совместно использован всеми сеансами.</p>

<p>Переменные <a href="server.htm#sysvar_table_open_cache"><code>
table_open_cache</code></a> и <a href="server.htm#sysvar_max_connections">
<code>max_connections</code></a> затрагивают максимальное количество файлов,
которые сервер сохраняет открытыми. Если Вы увеличиваете одно или оба из этих
значений, Вы можете столкнуться с пределом, наложенным Вашей операционной
системой на число открытых описателей файла на процесс. Много операционных
систем разрешают Вам увеличивать предел открытых файлов, хотя метод
значительно различается от системы к системе. Консультируйтесь со своей
документацией операционной системы, чтобы определить, возможно ли увеличить
предел, и как это сделать.</p>

<p><a href="server.htm#sysvar_table_open_cache"><code>table_open_cache</code>
</a> относится к <a href="server.htm#sysvar_max_connections"><code>
max_connections</code></a>. Например, для 200 параллельных рабочих
соединений, определите табличный размер кэша, по крайней мере, в <code>200 *
<em><code>N</code></em></code>, где <em><code>N</code></em> это
максимальное количество таблиц, участвующих в любом из запросов, который Вы
выполняете. Вы должны также зарезервировать некоторые дополнительные
описатели файла для временных таблиц и файлов.</p>

<p>Удостоверьтесь, что Ваша операционная система может обработать число
открытых описателей файла, подразумеваемых
<a href="server.htm#sysvar_table_open_cache"><code>table_open_cache</code>
</a>. Если <a href="server.htm#sysvar_table_open_cache"><code>
table_open_cache</code></a> установлен слишком высоко, MySQL может исчерпать
описатели файла и отказаться от соединений или быть не в состоянии выполнить
запросы, и быть очень ненадежным.</p>

<p>Вы должны также принять во внимание факт, что <code>MyISAM</code>
нуждается в двух описателях файла для каждой уникальной открытой таблицы. Для
разделенной таблицы <code>MyISAM</code> два описателя файла требуются для
каждого раздела открытой таблицы. Отметьте что, когда
<code>MyISAM</code> открывает разделенную таблицу, это открывает каждый
раздел этой таблицы, используется ли данный раздел фактически. См.
<a href="../../../dev.mysql.com/doc/refman/5.7/en/partitioning-limitations.html#partitioning-limitations-myisam-file-descriptors"
target="_top">MyISAM and partition file descriptor usage</a>.
Вы можете увеличить число описателей файла, доступных MySQL, используя опцию
<a href="server.htm#option_mysqld_open-files-limit"><code>--open-files-limit
</code></a> при запуске <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a>. См. <a href="error.htm#not-enough-file-handles">раздел
B.5.2.17</a>.</p>

<p>Кэш открытых таблиц сохранен на уровне
<a href="server.htm#sysvar_table_open_cache"><code>table_open_cache</code>
</a>. Сервер автоматически меняет размер кэша при запуске. Чтобы установить
размер явно, установите <a href="server.htm#sysvar_table_open_cache"><code>
table_open_cache</code></a> при запуске. Отметьте, что MySQL может временно
открыть больше таблиц, чем это значение, чтобы выполнить запросы.</p>

<p>MySQL закрывает неиспользованную таблицу и удаляет это из табличного кэша
при следующих обстоятельствах:</p>
<ul><li><p>Когда кэш полон, и поток пытается открыть таблицу, которая не
находится в кэше.</li>

<li>Когда кэш содержит больше, чем
<a href="server.htm#sysvar_table_open_cache"><code>table_open_cache</code>
</a> записей, и таблица в кэше больше не используются никакими потоками.</li>

<li>Когда табличная работа сброса происходит. Это происходит, когда кто-то
вызывает <a href="sql.htm#flush"><code>FLUSH TABLES</code></a> или
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-tables
</strong></span></a> (или <a href="programs.htm#mysqladmin"><span><strong>
mysqladmin refresh</strong></span></a>).</p></li></ul>

<p>Когда табличный кэш заполняется, сервер использует следующую процедуру,
чтобы определить местонахождение использумой записи кэша:</p>
<ul><li><p>Таблицы, которые не используются в настоящее время, выпущены,
начиная с последней использованной таблицы.</li>

<li>Если новая таблица должна быть открыта, но кэш полон, и никакие таблицы
не могут быть выпущены, кэш временно расширен по мере необходимости. Когда
кэш находится во временно расширенном статусе, и таблица переходит от
используемого состояния в неиспользуемое, таблица закрыта и выпущена из кэша.
</p></li></ul>

<p><code>MyISAM</code> открыта для каждого параллельного доступа.
Это означает потребность открыть таблицу дважды, если два потока получают
доступ к той же самой таблице, или если поток получает доступ к таблице
дважды в том же самом запросе (например, соединяя таблицу с собой). Каждое
параллельное открытие требует записи в табличном кэше. Первое открытие любой
<code>MyISAM</code> берет два описателя файла: один для файла с данными и
один для индексного файла. Каждое дополнительное использование таблицы берет
только один описатель файла для файла с данными. Описатель индексного файла
совместно использован среди всех потоков.</p>

<p>Если Вы открываете таблицу с <code>HANDLER
<em><code>tbl_name</code></em> OPEN</code>, специализированный табличный
объект выделен для потока. Этот табличный объект не использован совместно
другими потоками и не закрыт до требований потока <code>HANDLER
<em><code>tbl_name</code></em> CLOSE</code> или завершения потока.
Когда это происходит, таблица отложена в табличном кэше (если кэш не полон).
См. <a href="sql.htm#handler">раздел 14.2.4</a>.</p>

<p>Вы можете определить, является ли Ваш табличный кэш слишком маленьким,
проверяя переменную <a href="server.htm#statvar_Opened_tables"><code>
Opened_tables</code></a>, которая указывает на число открывающих таблицу
операций с момента запуска сервера:
<pre>
mysql&gt; SHOW GLOBAL STATUS LIKE 'Opened_tables';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Opened_tables | 2741  |
+---------------+-------+
</pre>

<p>Если значение является очень большим или увеличивается быстро, даже когда
Вы не выполняли много <a href="sql.htm#flush"><code>FLUSH TABLES</code></a>,
увеличьте размер табличного кэша. См. разделы
<a href="server.htm#server-system-variables">6.1.5</a> и
<a href="server.htm#server-status-variables">6.1.7</a>.</p>

<h4><a name="creating-many-tables"></a>9.4.3.2.
Недостатки составления многих таблиц в той же самой базе данных</h4>
<p>Если у Вас есть много таблиц <code>MyISAM</code>
в том же самом каталоге базы данных, операции открытия, создания и закрытия
являются медленными. Если Вы выполняете <a href="sql.htm#select"><code>SELECT
</code></a> на многих различных таблицах, добавляется небольшая издержка,
когда табличный кэш полон, потому что для каждой таблицы, которая должна быть
открыта, другая должна быть закрыта. Вы можете уменьшить эти издержки,
увеличивая число записей, разрешенных в табличном кэше.</p>

<h3><a name="internal-temporary-tables"></a>9.4.4.
Внутренние временные таблицы в MySQL</h3>
<p>В некоторых случаях сервер составляет внутренние временные таблицы,
обрабатывая запросы. У пользователей нет никакого прямого управления,
когда это происходит.</p>

<p>Сервер составляет временные таблицы при таких условиях:</p>
<ul><li><p>Оценка <a href="sql.htm#union"><code>UNION</code></a>
с некоторыми исключениями, описанными позже.</li>

<li>Оценка некоторых представлений, как те, которые используют алгоритм
<code>TEMPTABLE</code>, <a href="sql.htm#union"><code>UNION</code></a>
или разную агрегацию.</li>

<li>Оценка полученных таблиц (подзапросы в <code>FROM</code>).</li>
<li>Таблицы, составленные для подзапроса или материализации полусоединения
(см. <a href="#subquery-optimization">раздел 9.2.1.18</a>).</li>

<li>Оценка запросов, которые содержат <code>ORDER
BY</code> и разные <code>GROUP BY</code> или для которых
<code>ORDER BY</code> или <code>GROUP BY</code>
содержит столбцы из таблиц, кроме первой таблицы в очереди соединения.</li>

<li>Оценка <code>DISTINCT</code> объединенный с <code>ORDER BY</code>
может потребовать временной таблицы.</li>
<li>Для запросов, которые используют опцию <code>SQL_SMALL_RESULT</code>,
MySQL использует временную таблицу в памяти, если запрос также не содержит
элементов (описаны позже), которые требуют хранения на диске.</li>

<li>Оценка многотабличного <a href="sql.htm#update"><code>UPDATE</code></a>.
</li>
<li>Оценка <a href="funct.htm#function_group-concat"><code>GROUP_CONCAT()
</code></a> или <a href="funct.htm#function_count"><code>COUNT(DISTINCT)
</code></a>.</p></li></ul>

<p>Чтобы определить, требует ли запрос временной таблицы, надо использовать
<a href="sql.htm#explain"><code>EXPLAIN</code></a> и проверьте столбец
<code>Extra</code>, чтобы видеть, говорит ли это
<code>Using temporary</code> (см. <a href="#using-explain">раздел
9.8.1</a>). <code>EXPLAIN</code> не обязательно скажет <code>Using temporary
</code> для полученных или осуществленных временных таблиц.</p>

<p>Когда сервер составляет внутреннюю временную таблицу (в памяти или на
диске), это постепенно увеличивает переменную
<a href="server.htm#statvar_Created_tmp_tables"><code>Created_tmp_tables
</code></a>. Если сервер составляет таблицу на диске (первоначально или
преобразовывая таблицу в памяти), это постепенно увеличивает переменную
<a href="server.htm#statvar_Created_tmp_disk_tables"><code>
Created_tmp_disk_tables</code></a>.</p>

<p>Некоторые условия запроса предотвращают использование временной таблицы в
памяти, когда сервер использует таблицу на диске вместо этого:</p>
<ul><li><p>Присутствие столбца <a href="types.htm#blob"><code>BLOB</code></a>
или <a href="types.htm#blob"><code>TEXT</code></a> в таблице.</li>

<li>Присутствие любого строкового столбца с максимальной длиной больше
512 (байт для двоичных строк, символов для недвоичных строк) в списке
<a href="sql.htm#select"><code>SELECT</code></a>, если применено
<a href="sql.htm#union"><code>UNION</code></a> или
<a href="sql.htm#union"><code>UNION ALL</code></a>.</li>

<li><a href="sql.htm#show-columns"><code>SHOW COLUMNS</code></a> и
<a href="sql.htm#describe"><code>DESCRIBE</code></a> используют
<code>BLOB</code> как тип столбца, таким образом временная таблица,
используемая для результатов, является таблицей на диске.</p></li></ul>

<p>Сервер не использует временную таблицу для
<a href="sql.htm#union"><code>UNION</code></a>, которые встречают
определенные квалификации. Вместо этого это сохраняет из временной таблицы
только структуры данных, необходимые, чтобы выполнить подбор типов.
Таблица не полностью инстанцирует, и никакие строки не написаны или считаны
из нее, строки посылают непосредственно клиенту. Результат уменьшение
требований к памяти и диску и меньшая задержка прежде, чем первую строку
пошлют клиенту, потому что сервер не должен ждать, пока последний блок
запроса будет выполнен. <a href="sql.htm#explain"><code>EXPLAIN</code></a> и
трассировка оптимизатора отражают эту стратегию выполнения: блок запроса
<code>UNION RESULT</code> не присутствует, потому что тот блок соответствует
части, которая читает из временной таблицы.</p>

<p>Эти условия квалифицируют <code>UNION</code>
для оценки без временной таблицы:</p>

<ul><li><p>Союз <code>UNION ALL</code>, но не
<code>UNION</code> или <code>UNION DISTINCT</code>.</li>
<li>Нет глобального <code>ORDER BY</code>.</li>
<li>Союз не высокоуровневый блок запроса
<code>{INSERT | REPLACE} ... SELECT ...</code>.</p></li></ul>

<h4><a name="internal-temporary-tables-engines"></a>
Механизмы хранения, используемые для временных таблиц</h4>
<p>Внутренняя временная таблица может быть проведена в памяти и обработана
<code>MEMORY</code> или сохранена на диске как
<code>InnoDB</code> или <code>MyISAM</code>.</p>

<p>Если внутренняя временная таблица составлена как таблица в памяти,
но становится слишком большой, MySQL автоматически преобразовывает ее в
таблицу на диске. Максимальный размер для временных таблиц в памяти определен
от значений переменных <a href="server.htm#sysvar_tmp_table_size"><code>
tmp_table_size</code></a> и
<a href="server.htm#sysvar_max_heap_table_size"><code>max_heap_table_size
</code></a> (какое меньше). Это отличается от <code>MEMORY</code>, явно
составленных с <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
для таких таблиц, только переменная
<a href="server.htm#sysvar_max_heap_table_size"><code>max_heap_table_size
</code></a> определяет, как сильно разрешают вырасти большой таблице и нет
никакого преобразования в формат на диске.</p>

<p>Переменная <a href="server.htm#sysvar_internal_tmp_disk_storage_engine">
<code>internal_tmp_disk_storage_engine</code></a> определяет, который
механизм хранения использует сервер, чтобы управлять внутренними временными
таблицами на диске. Разрешенные значения <code>INNODB</code>
(по умолчанию) и <code>MYISAM</code>.</p>

<p>Используя <a href="server.htm#sysvar_internal_tmp_disk_storage_engine">
<code>internal_tmp_disk_storage_engine=INNODB</code></a>,
запросы, которые производят временное табличное превышение
<a href="innodb.htm#innodb-restrictions">лимита строк или столбцов в
<code>InnoDB</code></a> вернут ошибку <span>Row size too large</span> или
<span>Too many columns</span>. Обходное решение должно установить
<a href="server.htm#sysvar_internal_tmp_disk_storage_engine">
<code>internal_tmp_disk_storage_engine</code></a> в <code>MYISAM</code>.</p>

<h4><a name="internal-temporary-tables-storage"></a>
Временный табличный формат хранения</h4>
<p>В памяти временными таблицами управляет механизм хранения
<code>MEMORY</code>, который использует формат строки фиксированной длины.
<code>VARCHAR</code> и <code>VARBINARY</code>
дополнены к максимальной длине столбца, в действительности храня их как
столбцы <code>CHAR</code> и <code>BINARY</code>.</p>

<p>На диске временными таблицами управляют
<code>InnoDB</code> или <code>MyISAM</code> (в зависимости от
<a href="server.htm#sysvar_internal_tmp_disk_storage_engine"><code>
internal_tmp_disk_storage_engine</code></a>).
Оба механизма хранят временные таблицы, используя формат строки динамической
ширины. Столбцы берут только столько места, сколько надо, что уменьшает
дисковый ввод/вывод, требования пространства и время обработки по сравнению с
таблицами на диске с использованием фиксированной длины строки.</p>

<p>Для запросов, которые первоначально составляют внутреннюю временную
таблицу в памяти, затем преобразуют ее в таблицу на диске, лучшая работа
могла бы быть достигнута, пропуская конверсионный шаг и составляя таблицу на
диске для начала. Системная переменная
<a href="server.htm#sysvar_big_tables"><code>big_tables</code></a> может
использоваться, чтобы вызвать дисковое хранение внутренних временных таблиц.
</p>

<h2><a name="optimizing-innodb"></a>9.5. Оптимизация таблиц InnoDB</h2>
<p><a href="innodb.htm"><code>InnoDB</code></a> это механизм хранения,
который клиенты MySQL, как правило, используют в производственных базах
данных, где надежность и параллелизм важны. Это механизм хранения по
умолчанию в MySQL. Этот раздел объясняет, как оптимизировать операции базы
данных для <code>InnoDB</code>.</p>

<h3><a name="optimizing-innodb-storage-layout"></a>9.5.1.
Оптимизация расположения хранения для таблиц InnoDB</h3>
<ul><li><p>Как только Ваши данные достигают устойчивого размера
или растущая таблица увеличилась на десятки или сотни мегабайтов,
рассмотрите использование <code>OPTIMIZE TABLE</code>, чтобы реорганизовать
таблицу и сжать любое потраченное впустую пространство. Реорганизованные
таблицы требуют меньше дискового ввода/вывода для полного сканирования
таблицы. Это прямой метод, который может улучшить работу, когда другие
методы, такие как улучшение индекса или настраивающийся код
программы не практичны.</p>

<p><code>OPTIMIZE TABLE</code> копирует часть данных таблицы и
восстанавливает индексирование. Выгода прибывает из улучшенной упаковки
данных в пределах индекса и уменьшения фрагментации в пределах табличных
пространств и на диске. Выгода изменяется в зависимости от данных по каждой
таблице. Вы можете найти, что есть существенная прибыль для некоторых, а не
для других, или что прибыль уменьшается в течение долгого времени, пока Вы
затем не оптимизируете таблицу. Эта работа может быть медленной, если таблица
большая или индекс не вписывается в буферный пул. Первый раз после добавления
большого количества данных к таблице часто намного медленнее, чем
более поздние выполнения.</li>

<li>В <code>InnoDB</code> наличие длинного <code>PRIMARY KEY</code>
(единственный столбец с длинным значением или несколько столбцов, которые
формируют длинное сложное значение) тратит впустую много дискового
пространства. Значение первичного ключа для строки дублировано во всех
вторичных индексах, которые указывают на ту же самую строку. См.
<a href="innodb.htm#innodb-index-types">раздел 16.8.8</a>.
Создайте столбец <code>AUTO_INCREMENT</code> как первичный ключ, если Ваш
первичный ключ длинен, или индексируйте префикс <code>VARCHAR</code>
вместо всего столбца.</li>

<li>Используйте <a href="types.htm#char"><code>VARCHAR</code></a> вместо
<a href="types.htm#char"><code>CHAR</code></a>, чтобы
сохранить строки переменной длины или для столбцов со многими
<code>NULL</code>. <a href="types.htm#char"><code>CHAR(<em><code>N</code>
</em>)</code></a> всегда берет <em><code>N</code></em> символов, чтобы
хранить данные, даже если строка короче или ее значение <code>NULL</code>.
</p>

<p>Используя формат строки <code>COMPACT</code> (значение по умолчанию в
<code>InnoDB</code>) и наборы символов переменной длины, например,
<code>utf8</code> или <code>sjis</code>,
<a href="types.htm#char"><code>CHAR(<em><code>N</code></em>)</code></a>
занимают переменное количество пространства, но все еще по крайней мере,
<em><code>N</code></em> байт.</li>

<li>Для таблиц, которые являются большими, или содержат много повторного
текста или числовых данных, стоит рассмотреть использование
формата строки <code>COMPRESSED</code>. Меньше дискового ввода/вывода
нужно, чтобы приносить данные в буферный пул или выполнять полное
сканирование таблицы. Прежде, чем принять постоянное решение, измерьте
коэффициент сжатия, при использовании фората <code>COMPRESSED</code>.
</p></li></ul>

<h3><a name="optimizing-innodb-transaction-management"></a>9.5.2.
Оптимизирующее операционное управление InnoDB</h3>
<p>Чтобы оптимизировать обработку транзакций, найдите идеальный баланс между
издержками транзакционных особенностей и рабочей нагрузкой Вашего сервера.
Например, приложение могло бы столкнуться с исполнительными проблемами, если
оно передает тысячи раз в секунду и совсем другими проблемами, если оно
передает только каждые 2-3 часа.</p>

<ul><li><p>Установка MySQL значения по умолчанию <code>AUTOCOMMIT=1</code>
может наложить исполнительные ограничения на занятый сервер базы данных.
Где практично, оберните несколько связанных операций изменения данных в
единственную транзакцию через <code>SET AUTOCOMMIT=0</code> или <code>START
TRANSACTION</code>, сопровождаемый <code>COMMIT</code>.</p>

<p><code>InnoDB</code> должен сбросить журнал на диск в каждой передаче
транзакции, если та транзакция сделала модификации базы данных. Когда каждое
изменение сопровождается передачей, пропускная способность ввода/вывода
устройства хранения данных имеет решающее значение.</li>

<li>Альтернативно, для транзакций, которые состоят только из одного
<a href="sql.htm#select"><code>SELECT</code></a>, включение
<code>AUTOCOMMIT</code> помогает <code>InnoDB</code>
признать транзакции только для чтения и оптимизировать их. См.
<a href="#innodb-performance-ro-txn">раздел 9.5.3</a>.</li>

<li>Избегайте выполнять обратные перемотки после вставки, обновления или
удаления огромных количеств строк. Если большая транзакция замедляет работу
сервера, ее откат может сделать проблему хуже, потенциально беря в несколько
раз больше времени, чем оригинальные операции изменения данных. Уничтожение
процесса базы данных не помогает, потому что обратная перемотка запускается
снова при запуске сервера.</p>

<p>Минимизировать шанс этого проявления проблемы:</p>
<ul><li><p>Увеличьте размер
<a href="glossary.htm#glos_buffer_pool">буферного пула</a> так, чтобы все
изменения изменения данных могли кэшироваться, а не немедленно были
записаны на диск.</li>

<li>Установите <a href="innodb.htm#sysvar_innodb_change_buffering"><code>
innodb_change_buffering=all</code></a> так, чтобы операции обновления и
удаления были буферизованы в дополнение к вставкам.</li>

<li>Рассмотрите запросы <code>COMMIT</code>
периодически во время большой работы изменения данных, возможно деля
одиночный запрос на несколько, которые воздействуют на меньшее число строк.
</p></li></ul>

<p>Чтобы избавиться от безудержной обратной перемотки, как только это
происходит, увеличьте буферный пул так, чтобы обратная перемотка стала
ограничиваться центральным процессором и работала быстро, или уничтожьте
сервер и перезапустите его с
<a href="innodb.htm#sysvar_innodb_force_recovery"><code>
innodb_force_recovery=3</code></a>, см.
<a href="innodb.htm#innodb-recovery">раздел 16.17.1</a>.</p>

<p>Эта проблема, как ожидают, будет нечастой с настройкой по умолчанию
<a href="innodb.htm#sysvar_innodb_change_buffering"><code>
innodb_change_buffering=all</code></a>, которая позволяет операции
обновления и удаления, которые будут кэшироваться в памяти, делая их быстрее,
и также быстрее откатиться, если нужно. Удостоверьтесь, что использовали эту
установку параметра на серверах, которые обрабатывают продолжительные
транзакции со многими вставками, обновлениями или удалениями.</li>

<li>Если Вы можете допустить потерю некоторых из последних переданных
транзакций, если катастрофический отказ происходит, Вы можете установить
<a href="innodb.htm#sysvar_innodb_flush_log_at_trx_commit"><code>
innodb_flush_log_at_trx_commit</code></a> в 0. <code>InnoDB</code> будет
пытаться сбросить журнал однажды в секунду, хотя сброс не гарантируется.</li>

<li>Когда строки изменены или удалены, строки и связанные
<a href="glossary.htm#glos_undo_log">журналы отмены</a>
физически не удалены немедленно или даже немедленно после того, как
транзакция передается. Старые данные сохранены до завершения транзакций,
которые запускались ранее или одновременно, чтобы те транзакции могли
получить доступ к предыдущему состоянию измененных или удаленных строк.
Таким образом, продолжительная транзакция может предотвратить
чистку данных, которые были изменены иной транзакцией.</li>

<li>Когда строки изменены или удалены в пределах продолжительной транзакции,
другие транзакции, используя уровни изоляции
<a href="innodb.htm#isolevel_read-committed"><code>READ COMMITTED</code></a>
и <a href="innodb.htm#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a> должны сделать больше работы, чтобы восстановить более старые данные,
если они читают те же самые строки.</li>

<li>Когда продолжительная транзакция изменяет таблицу, запросы против той
таблицы от других транзакций не используют
<a href="glossary.htm#glos_covering_index">покрывающий индекс</a>.
Запросы, которые обычно могли получать все столбцы результата от вторичного
индекса, вместо этого ищут соответствующие значения от табличных данных.</p>

<p>Если у вторичных индексных страниц есть
<code>PAGE_MAX_TRX_ID</code>, который слишком новый, или
если записи во вторичном индексе отмечены как удаленные, <code>InnoDB</code>,
возможно, должен искать записи, используя кластеризируемый индекс.
</p></li></ul>

<h3><a name="innodb-performance-ro-txn"></a>9.5.3.
Оптимизация транзакций только для чтения</h3>
<p><code>InnoDB</code> может избежать издержек, связанных с
<a href="glossary.htm#glos_transaction_id">transaction ID</a>
(поле <code>TRX_ID</code>) для транзакций, которые только для чтения.
Операционный ID необходим для <a href="glossary.htm#glos_transaction">
транзакции</a>, которая могла бы выполнить записи или
<a href="glossary.htm#glos_locking_read">блокирующие чтения</a>, например,
<code>SELECT ... FOR UPDATE</code>. Устранение ненужных операционных ID
уменьшает размер внутренних структур данных, с которыми консультируются
каждый раз, когда запрос изменения запроса или данных
создает <a href="glossary.htm#glos_read_view">представление чтения</a>.</p>

<p><code>InnoDB</code> обнаруживает транзакции только для чтения когда:</p>
<ul><li><p>Транзакция запущена с <a href="sql.htm#commit"><code>START
TRANSACTION READ ONLY</code></a>. В этом случае попытка произвести изменения
в базе данных (для <code>InnoDB</code>, <code>MyISAM</code> или других типов
таблиц) вызывает ошибку, и транзакция продолжается в статусе
только для чтения:
<pre>
ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.
</pre>

<p>Вы можете все еще произвести изменения в определенных для сеанса временных
таблицах в транзакции только для чтения или запросить блокировки для них,
потому что те изменения и блокировки невидимы любой другой транзакции.</li>

<li><a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>
включен, чтобы транзакция точно была единственным запросм, а единственный
запрос, составляющий транзакцию, является <span><span>неблокирующим</span>
</span> <a href="sql.htm#select"><code>SELECT</code></a>. Таким образом,
этот <code>SELECT</code> не использует <code>FOR UPDATE</code> или
<code>LOCK IN SHARED MODE</code>.</li>

<li>Транзакция запущена без <code>READ ONLY</code>,
но никакие обновления или запросы, которые явно блокируют строки, не были
выполнены. Пока обновления или явные блокировки не требуются, транзакция
остается в режиме только для чтения.</p></li></ul>

<p>Таким образом, для интенсивного чтения, такого как генератор отчетов, Вы
можете настроить последовательность запросов, группируя их в
<a href="sql.htm#commit"><code>START TRANSACTION READ ONLY</code></a> и
<a href="sql.htm#commit"><code>COMMIT</code></a> или включая
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>
прежде, чем выполнить <code>SELECT</code>, или просто избегая любых
изменяющих данные запросов между ними.</p>
<p>См. <a href="sql.htm#commit">раздел 14.3.1</a>.</p>

<p>Транзакции, которые готовятся, как auto-commit без блокировки и только для
чтения (AC-NL-RO), не допущены к внутренней структуре данных
<code>InnoDB</code> и поэтому не перечислены в выводе
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>.</p>

<h3><a name="optimizing-innodb-logging"></a>9.5.4.
Оптимизация журнала InnoDB Redo</h3>
<ul><li><p>Сделайте файлы журнала redo размером как
<a href="glossary.htm#glos_buffer_pool">буферный пул</a>. Когда
<code>InnoDB</code> пишет в полные файлы системного журнала, это должно
записать измененное содержание буферного пула на диск в
<a href="glossary.htm#glos_checkpoint">контрольную точку</a>.
Маленький файл приводит к большому числу лишних дисковых записей.
Хотя исторически большой файл вызывал долгое время восстановления файлов
системного журнала, восстановление теперь намного быстрее, и Вы можете
уверенно использовать большой файл системного журнала.</p>

<p>Размер и число файлов системного журнала сконфигурированы, используя
опции <a href="innodb.htm#sysvar_innodb_log_file_size"><code>
innodb_log_file_size</code></a> и
<a href="innodb.htm#sysvar_innodb_log_files_in_group"><code>
innodb_log_files_in_group</code></a>, см.
<a href="innodb.htm#innodb-data-log-reconfiguration">раздел 16.7.2</a>.</li>

<li>Рассмотрите увеличение размера
<a href="glossary.htm#glos_log_buffer">буфера журнала</a>.
Большой буфер журнала позволяет большим
<a href="glossary.htm#glos_transaction">транзакциям</a>
работать без потребности записать журнал на диск прежде
<a href="glossary.htm#glos_commit">commit</a>.
Таким образом, если у Вас есть транзакции, которые обновляют, вставляют или
удаляют много строк, большой буфер журнала сохраняет дисковый ввод/вывод.
Размер буфера журнала сконфигурирован, используя опцию
<a href="innodb.htm#sysvar_innodb_log_buffer_size">
<code>innodb_log_buffer_size</code></a>.</p></li></ul>

<h3><a name="optimizing-innodb-bulk-data-loading"></a>9.5.5.
Оптовые данные для таблиц InnoDB</h3>
<p>Эти исполнительные подсказки добавляют общие руководящие принципы для
быстрых вставок в <a href="#insert-speed">разделе 9.2.2.1</a>.</p>

<ul><li><p>Импортируя данные в <code>InnoDB</code>, выключите autocommit,
потому что он выполняет сброс данных журнала на диск для каждой вставки.
Чтобы отключить autocommit во время Вашей работы импорта, используйте
<a href="sql.htm#commit"><code>SET autocommit</code></a> и
<a href="sql.htm#commit"><code>COMMIT</code></a>:
<pre>
SET autocommit=0;
<em><code>... SQL import statements ...</code></em>
COMMIT;
</pre>

<p><a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span>
</a> с опцией <a href="programs.htm#option_mysqldump_opt"><code>--opt</code>
</a> создает файлы дампа, которые быстры, чтобы импортировать в
<code>InnoDB</code>, даже не обертывая их с
<a href="sql.htm#commit"><code>SET autocommit</code></a> и
<a href="sql.htm#commit"><code>COMMIT</code></a>.</li>

<li>Если Вы имеете ограничения <code>UNIQUE</code> на вторичные ключи, Вы
можете ускорить табличный импорт, временно выключая проверки уникальности во
время сеанса импорта:
<pre>
SET unique_checks=0;
<em><code>... SQL import statements ...</code></em>
SET unique_checks=1;
</pre>

<p>Для больших таблиц это сохраняет много дискового ввода/вывода, потому что
<code>InnoDB</code> может использовать его буфер изменения, чтобы написать
вторичные индексные записи в пакете. Будьте уверенны, что данные не
содержат дубликаты ключей.</li>

<li>Если Вы имеете ограничения <code>FOREIGN KEY</code>
в Ваших таблицах, Вы можете ускорить табличный импорт, выключая проверки
внешнего ключа на продолжительность сеанса импорта:
<pre>
SET foreign_key_checks=0;
<em><code>... SQL import statements ...</code></em>
SET foreign_key_checks=1;
</pre>
<p>Для больших таблиц это может сохранить много дискового ввода/вывода.</li>

<li>Используйте многострочный <a href="sql.htm#insert"><code>INSERT</code>
</a>, чтобы уменьшить издержки связи между клиентом и сервером, если Вы
должны вставить много строк:
<pre>
INSERT INTO yourtable VALUES (1,2), (5,5), ...;
</pre>
<p>Эта подсказка допустима для вставок в любую таблицу, не только
<code>InnoDB</code>.</li>

<li>Когда выполняется большая вставка в таблицы со столбцами auto-increment,
установите <a href="innodb.htm#sysvar_innodb_autoinc_lock_mode"><code>
innodb_autoinc_lock_mode</code></a> в 2 вместо значения по умолчанию 1. См.
<a href="innodb.htm#innodb-auto-increment-handling">раздел 16.8.5</a>.</li>

<li>Когда выполняется большая вставка, быстрее вставить строки в
порядке <code>PRIMARY KEY</code>. Таблицы <code>InnoDB</code>
используют <a href="glossary.htm#glos_clustered_index">кластеризируемый
индекс</a>,который делает относительно быстрым использование данных в порядке
<code>PRIMARY KEY</code>. Выполнение большой вставки в порядке
<code>PRIMARY KEY</code> особенно важно для таблиц, которые не помещаются
полностью в буферном пуле.</li>

<li>Для оптимальной работы, загружая данные в индекс
<code>InnoDB</code> <code>FULLTEXT</code>,
следуйте за этим набором шагов:</p>

<ol type="1"><li><p>Определите столбец <code>FTS_DOC_ID</code> при создании
таблицы, тип <code>BIGINT UNSIGNED NOT NULL</code>, с уникальным индексом
<code>FTS_DOC_ID_INDEX</code>:
<pre>
CREATE TABLE t1 (FTS_DOC_ID BIGINT unsigned NOT NULL AUTO_INCREMENT,
                 title varchar(255) NOT NULL DEFAULT ,
                 text mediumtext NOT NULL, PRIMARY KEY (`FTS_DOC_ID`))
                 ENGINE=InnoDB DEFAULT CHARSET=latin1;
CREATE UNIQUE INDEX FTS_DOC_ID_INDEX on t1(FTS_DOC_ID);
</pre></li>

<li>Загрузите данные в таблицу.</li>
<li>Создайте индекс <code>FULLTEXT</code> после того, как данные загружены.
</p></li></ol>

<p>Добавляя столбец <code>FTS_DOC_ID</code>
во время создания таблиы, гарантируйте, что столбец <code>FTS_DOC_ID</code>
обновлен, когда индексированный <code>FULLTEXT</code> столбец обновлен.
<code>FTS_DOC_ID</code> должен увеличиться монотонно с каждым вызовом
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>.
Если Вы хотите не добавлять <code>FTS_DOC_ID</code> при создании таблицы
и имеете управление <code>InnoDB</code> DOC ID, <code>InnoDB</code> добавит
<code>FTS_DOC_ID</code> как скрытый столбец со следующим вызовом
<a href="sql.htm#create-index"><code>CREATE FULLTEXT INDEX</code></a>. Этот
подход, однако, требует пересоздания таблицы, что будет
воздействовать на работу.</p></li></ul>

<h3><a name="optimizing-innodb-queries"></a>9.5.6.
Оптимизация запросов InnoDB</h3>
<p>Чтобы настроить запросы для <code>InnoDB</code>,
создайте соответствующий набор индексов на каждой таблице. См.
<a href="#mysql-indexes">раздел 9.3.1</a>.</p>

<ul><li><p>Поскольку у каждой таблицы <code>InnoDB</code> есть
<a href="glossary.htm#glos_primary_key">первичный ключ</a> (запрашиваете его
или нет), определите ряд столбцов первичного ключа для каждой таблицы,
столбцы которой используются в самых важных и срочных запросах.</li>

<li>Не определяйте слишком много или слишком длинные столбцы в первичном
ключе, потому что эти значения столбцов дублированы в каждом вторичном
индексе. Когда индексирование содержит ненужные данные, ввод/вывод, чтобы
считать эти данные и память, чтобы их кэшировать, уменьшает
работу и масштабируемость сервера.</li>

<li>Не создавайте отдельный
<a href="glossary.htm#glos_secondary_index">вторинчый индекс</a>,
для каждого столбца, потому что каждый запрос может использовать только один
индекс. Индексы на редко проверяемых столбцах или столбцы только с
несколькими различными значениями не могли бы быть полезными для любых
запросов. Если у Вас есть много запросов для той же самой таблицы, проверяя
различные комбинации столбцов, попытайтесь создать небольшое количество
<a href="glossary.htm#glos_concatenated_index">связанных индексов</a>, а не
большое количество индексов из одного столбца. Если индекс содержит
все столбцы, необходимые для набора результатов (известный как
<a href="glossary.htm#glos_covering_index">покрывающий</a>),
запрос может быть в состоянии избежать читать табличные данные вообще: он все
берет из индекса.</li>

<li>Если индексированный столбец не может содержать <code>NULL</code>,
определите его как <code>NOT NULL</code>, когда Вы составляете таблицу.
Оптимизатор может лучше определить, который индекс является самым
эффективным, чтобы использовать для запроса, когда он знает, содержит ли
каждый столбец <code>NULL</code>.</li>

<li>Вы можете оптимизировать транзакции единственного запроса для
<code>InnoDB</code>, используя метод в
<a href="#innodb-performance-ro-txn">разделе 9.5.3</a>.</li>

<li>Если у Вас часто есть возвращающиеся запросы для таблиц, которые
часто не обновляются, включите кэш запроса:
<pre>
[mysqld]
query_cache_type = 1
query_cache_size = 10M
</pre></li></ul>

<h3><a name="optimizing-innodb-ddl-operations"></a>9.5.7.
Оптимизация InnoDB DDL</h3>
<ul><li><p>Для операций DDL на таблицах и индексах
(<code>CREATE</code>, <code>ALTER</code> и <code>DROP</code>),
очень значащий аспект для таблиц <code>InnoDB</code> то, что создание и
удаление вторичных индексов намного быстрее в MySQL 5.5 и выше, чем в более
ранних выпусках. См. <a href="innodb.htm#innodb-create-index-overview">раздел
16.12.1</a>.</li>

<li><span><span>Быстрое создание индексов</span></span>
делает это быстрее в некоторых случаях, чтобы удалить индекс перед
загрузкой данных в таблицу, затем обновить индекс после загрузки данных.</li>

<li>Используйте <a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code>
</a>, чтобы освободить таблицу, а не <code>DELETE FROM
<em><code>tbl_name</code></em></code>. Ограничения внешнего ключа могут
сделать <code>TRUNCATE</code> похожим на <code>DELETE</code>, когда
последовательность команд <a href="sql.htm#drop-table"><code>DROP TABLE
</code></a> и <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
могло бы быть самым быстрым решением.</li>

<li>Поскольку первичный ключ является неотъемлемой частью расположения
хранения каждой таблицы <code>InnoDB</code> и изменение определения
первичного ключа вовлекает реорганизацию целой таблицы, всегда настраивайте
первичный ключ как часть <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a> и планируйте заранее так, чтобы Вы не нуждались в
<code>ALTER</code> или <code>DROP</code> для primary key.</p></li></ul>

<h3><a name="optimizing-innodb-diskio"></a>9.5.8.
Оптимизация дискового ввода/вывода InnoDB</h3>
<p>Если Вы следуете за лучшими методами для проектирования баз данных и
настройки операций SQL, но Вашу базу данных все еще замедляет тяжелая
дисковая деятельность ввода/вывода, исследуйте эти низкоуровневые методы,
связанные с дисковым вводом/выводом. Если в Unix команда <code>top</code> или
Windows Task Manager показывают, что процент использования центрального
процессора с Вашей рабочей нагрузкой составляет меньше 70%,
Ваша рабочая нагрузка является, вероятно, связанной с диском.</p>

<ul><li><p>Когда табличные данные кэшируются в буферном пуле
<code>InnoDB</code>, к этому могут неоднократно получать доступ запросы, не
требуя никакого дискового ввода/вывода. Определите размер буферного пула с
опцией <a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>. Эта область памяти достаточно важна, что,
как правило, рекомендуют установить
<a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> от 50 до 75
процентов системной памяти. Для получения дополнительной информации см.
<a href="#memory-use">раздел 9.12.3.1</a>.</li>

<li>В некоторых версиях GNU/Linux и Unix сброс файлов
на диск с Unix <code>fsync()</code> (<code>InnoDB</code> использует его по
умолчанию) и подобные методы является удивительно медленным.
Если запись базы данных проблема, проверьте, не поможет ли изменение
<a href="innodb.htm#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a> на <code>O_DSYNC</code>.</li>

<li>Используя <code>InnoDB</code> на
Solaris 10 для x86_64 (AMD Opteron), используйте direct
I/O для файлов <code>InnoDB</code>, чтобы избежать деградации
производительности <code>InnoDB</code>. Чтобы использовать прямой ввод/вывод
для всей файловой системы UFS, используемой для того, чтобы сохранить
файлы <code>InnoDB</code>, смонтируйте ее с опцией
<code>forcedirectio</code>, см. <code>mount_ufs(1M)</code>. Значение по
умолчанию на Solaris 10/x86_64 <span><em>не</em></span>
использует эту опцию. Чтобы применить прямой ввод/вывод только к файлам
<code>InnoDB</code>, а не целой файловой системе, установите
<a href="innodb.htm#sysvar_innodb_flush_method"><code>innodb_flush_method =
O_DIRECT</code></a>. С этой установкой <code>InnoDB</code> вызывает
<code>directio()</code> вместо <code>fcntl()</code> для ввода/вывода к
файлам с данными (не для ввода/вывода к файлам системного журнала).</li>

<li>Используя <code>InnoDB</code> с большим значением
<a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> на Solaris 2.6 и выше на любой платформе
(sparc/x86/x64/amd64), проведите точки отсчета с файлами <code>InnoDB</code>
на сырых устройствах или на отдельном прямом вводе/выводе файловой системы
UFS, используя опцию монтирования <code>forcedirectio</code>.
Необходимо использовать опцию вместо установки
<a href="innodb.htm#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a>, если Вы хотите прямой ввод/вывод для файлов системного журнала.
Пользователи файловой системы Veritas VxFS должны использовать опцию
монтирования <code>convosync=direct</code>.</p>

<p>Не помещайте другие файлы с данными MySQL на файловой системе
прямого ввода/вывода.</li>
<li>Если Вы имеете дополнительные устройства хранения данных в наличии, чтобы
настроить конфигурацию RAID или символические ссылки к различным дискам, см.
<a href="#disk-issues">раздел 9.12.1</a>.</li>

<li>Если пропускная способность периодически проваливается из-за
<a href="glossary.htm#glos_checkpoint">контрольной точки</a>
<code>InnoDB</code>, рассмотрите увеличение значения
<a href="innodb.htm#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>. Более высокие значения вызывают более частый
<a href="glossary.htm#glos_flush">сброс</a>, избегая отставания в работе,
которое может вызвать падения в пропускной способности.</li>

<li>Если система не запаздывает со
<a href="glossary.htm#glos_flush">сбросами</a> <code>InnoDB</code>,
рассмотрите понижение значения
<a href="innodb.htm#sysvar_innodb_io_capacity"><code>innodb_io_capacity
</code></a>. Как правило, Вы сохраняете это значение опции столь низким, как
практично, но не настолько низким, что оно вызывает периодические падения
пропускной способности, как упомянуто выше. В типичном скрипте, где Вы могли
понизить значение опции, Вы могли бы видеть это в выводе
<a href="sql.htm#show-engine"><code>SHOW ENGINE INNODB STATUS</code></a>:</p>

<ul><li><p>Длина списка истории низкая, ниже нескольких тысяч.</li>
<li>Буферные слияния близки к вставленным строкам.</li>
<li>Измененные страницы в буферном пуле последовательно значительно ниже
<a href="innodb.htm#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a> из буферного пула в то время, когда
сервер не делает больших вставок, это нормально во время большой вставки.
</li>

<li><code>Log sequence number - Last checkpoint</code> меньше, чем 7/8 или
идеально меньше, чем 6/8 полного размера
<a href="glossary.htm#glos_log_file">файлов системного журнала</a>
<code>InnoDB</code>.</p></li></ul></li>

<li>Вы можете использовать в своих интересах doublewrite буфер, храня
системные файлы табличного пространства
(<span><span>ibdata</span></span>) на устройствах Fusion-io,
которые поддерживают атомную запись. В этом случае буфер doublewrite
(<a href="innodb.htm#sysvar_innodb_doublewrite"><code>innodb_doublewrite
</code></a>) автоматически отключен и используется атомная запись Fusion-io
для всех файлов с данными. Эта функция поддерживается только на аппаратных
средствах Fusion-io и включена только для Fusion-io NVMFS в Linux.
Чтобы в полной мере воспользоваться этой особенностью, рекомендуется
<a href="innodb.htm#sysvar_innodb_flush_method"><code>innodb_flush_method
</code></a> <code>O_DIRECT</code>.</p>

<p>Поскольку буферная установка doublewrite глобальна, буферизация
doublewrite также отключена для файлов с данными, находящихся на устройствах
не-Fusion-io.</p></li>

<li>Используя <code>InnoDB</code> <a href="glossary.htm#glos_compression">
сжатие таблиц</a>, образы пересжатых
<a href="glossary.htm#glos_page">страниц</a> написаны в
<a href="glossary.htm#glos_redo_log">журнал redo</a>, когда изменения
произведены в сжатых данных. Этим поведением управляет параметр
<a href="innodb.htm#sysvar_innodb_log_compressed_pages"><code>
innodb_log_compressed_pages</code></a>, который включен по умолчанию, чтобы
предотвратить повреждение, которое может произойти, если различная версия
<code>zlib</code> используется во время восстановления. Если Вы уверены, что
версия <code>zlib</code> не будет изменяться, отключите
<a href="innodb.htm#sysvar_innodb_log_compressed_pages"><code>
innodb_log_compressed_pages</code></a>, чтобы уменьшить журнал redo
для рабочих нагрузок, которые изменяют сжатые данные.</li>

<li>Другие параметры конфигурации <code>InnoDB</code>, которые стоит
рассмотреть, настраивая рабочие нагрузки I/O, включают
<a href="innodb.htm#sysvar_innodb_adaptive_flushing"><code>
innodb_adaptive_flushing</code></a>,
<a href="innodb.htm#sysvar_innodb_change_buffer_max_size"><code>
innodb_change_buffer_max_size</code></a>,
<a href="innodb.htm#sysvar_innodb_change_buffering"><code>
innodb_change_buffering</code></a>,
<a href="innodb.htm#sysvar_innodb_flush_neighbors"><code>
innodb_flush_neighbors</code></a>,
<a href="innodb.htm#sysvar_innodb_log_buffer_size"><code>
innodb_log_buffer_size</code></a>,
<a href="innodb.htm#sysvar_innodb_log_file_size"><code>innodb_log_file_size
</code></a>,
<a href="innodb.htm#sysvar_innodb_lru_scan_depth"><code>innodb_lru_scan_depth
</code></a>,
<a href="innodb.htm#sysvar_innodb_max_dirty_pages_pct"><code>
innodb_max_dirty_pages_pct</code></a>,
<a href="innodb.htm#sysvar_innodb_max_purge_lag"><code>innodb_max_purge_lag
</code></a>,
<a href="innodb.htm#sysvar_innodb_open_files"><code>innodb_open_files</code>
</a>,
<a href="innodb.htm#sysvar_innodb_page_size"><code>innodb_page_size</code>
</a>,
<a href="innodb.htm#sysvar_innodb_random_read_ahead"><code>
innodb_random_read_ahead</code></a>,
<a href="innodb.htm#sysvar_innodb_read_ahead_threshold"><code>
innodb_read_ahead_threshold</code></a>,
<a href="innodb.htm#sysvar_innodb_read_io_threads"><code>
innodb_read_io_threads</code></a>,
<a href="innodb.htm#sysvar_innodb_rollback_segments"><code>
innodb_rollback_segments</code></a>,
<a href="innodb.htm#sysvar_innodb_write_io_threads"><code>
innodb_write_io_threads</code></a> и
<a href="replica.htm#sysvar_sync_binlog"><code>sync_binlog</code></a>.
</p></li></ul>

<h3><a name="optimizing-innodb-configuration-variables"></a>9.5.9.
Оптимизация переменных конфигурации InnoDB</h3>
<p>Различные настройки работают лучше всего на серверах
с легкими и предсказуемыми загрузками.</p>

<p>Поскольку <code>InnoDB</code> многие из своих оптимизаций автоматически,
много настраивающих работу задач вовлекают контроль, чтобы гарантировать, что
база данных работает хорошо и изменять параметры конфигурации, когда работа
нарушается. См. <a href="innodb.htm#innodb-performance-schema">раздел 16.15
</a>.</p>

<p>Основные шаги конфигурации, которые Вы можете выполнить, включают:</p>
<ul><li><p>Управление типами данных изменяет операции для которых
<code>InnoDB</code> буферизует измененные данные, чтобы избежать
частых маленьких операций записи на диск. См.
<a href="innodb.htm#innodb-performance-change_buffering">раздел 16.6.4</a>.
Поскольку значение по умолчанию должно буферизовать все типы операций
изменения данных, надо изменить только эти настройки, если Вы должны
уменьшить объем буферизации.</li>

<li>Включение адаптивной индексации хеша и использование опции
<a href="innodb.htm#sysvar_innodb_adaptive_hash_index"><code>
innodb_adaptive_hash_index</code></a>. См.
<a href="innodb.htm#innodb-adaptive-hash">раздел 16.4.3</a>.
Вы могли бы изменить эти настройки во время периодов необычной
деятельности, затем восстановить к оригинальной установке.</li>

<li>Установка предела для числа параллельных потоков, которые обрабатывает
<code>InnoDB</code>, если переключение контекста узкое место. См.
<a href="innodb.htm#innodb-performance-thread_concurrency">раздел 16.6.5</a>.
</li>

<li>Управление количеством предварительной выборки <code>InnoDB</code>.
Когда у системы есть неиспользованная способность ввода/вывода, чтение вперед
может улучшить исполнение запросов. Слишком большая предвыборка может вызвать
периодические падения работы на сильно загруженной системе. См.
<a href="innodb.htm#innodb-performance-read_ahead">раздел 16.6.3.5</a>.</li>

<li>Увеличивание числа фоновых потоков для чтения или записи, если у Вас есть
подсистема ввода/вывода высокого уровня, которая не полностью используется
значениями по умолчанию. См.
<a href="innodb.htm#innodb-performance-multiple_io_threads">раздел 16.6.6
</a>.</li>

<li>Управление, сколько ввода/вывода <code>InnoDB</code> идет в фоне. См.
<a href="innodb.htm#innodb-performance-thread_io_rate">раздел 16.6.7</a>.
Вы могли бы вычислить эту установку, если Вы наблюдаете
периодические падения работы.</li>

<li>Управление алгоритмом, который определяет, когда <code>InnoDB</code>
использует определенные типы фоновой записи. См.
<a href="innodb.htm#innodb-performance-adaptive_flushing">раздел 16.6.3.6
</a>. Алгоритм для некоторых типов рабочих нагрузок, но не других, мог бы
выключить эту установку, если Вы наблюдаете периодические падения работы.
</li>

<li>Использование в своих интересах мультиядерных процессоров и конфигурации
их кэш-памяти, чтобы минимизировать задержки переключения контекста. См.
<a href="innodb.htm#innodb-performance-spin_lock_polling">раздел 16.6.8</a>.
</li>

<li>Предотвращение одноразовых операций, таких как сканирование таблицы,
с данными, к которым часто получают доступ, находящимися в буфере
<code>InnoDB</code>. См. подробности в
<a href="innodb.htm#innodb-performance-midpoint_insertion">разделе 16.6.3.4
</a>.</li>

<li>Корректировка файлов системного журнала к размеру, который имеет смысл
для восстановления надежности и катастрофического отказа. Файлы системного
журнала <code>InnoDB</code> часто сохранялись маленькими, чтобы избежать
долгих времен запуска после катастрофического отказа. Оптимизация, введенная
в MySQL 5.5, ускоряет определенные шаги процесса
<a href="glossary.htm#glos_crash_recovery">восстановления</a>. В частности,
просмотр и применение <a href="glossary.htm#glos_redo_log">журнала redo</a>
происходят быстрее из-за улучшенных алгоритмов для управления памятью. Если
Вы сохранили свои файлы системного журнала искусственно маленькими, чтобы
избежать долгих времен запуска, Вы можете теперь полагать, что
увеличивающийся размер файла системного журнала уменьшает ввод/вывод.</li>

<li>Конфигурирование размера и числа копий буферного пула
<code>InnoDB</code>, особенно важно для систем с буферными пулами в
несколько гигабайт. См.
<a href="innodb.htm#innodb-multiple-buffer-pools">раздел 16.6.3.3</a>.</li>

<li>Увеличение максимального количества параллельных транзакций, которое
резко улучшает масштабируемость для самых занятых баз данных. См.
<a href="innodb.htm#innodb-undo-logs">раздел 16.4.7</a>.</li>

<li>Перемещение операций чистки в фоновый поток. См.
<a href="innodb.htm#innodb-improved-purge-scheduling">раздел 16.6.9</a>.
Чтобы эффективно измерить результаты этой установки, настройте
связанные с потоком настройки конфигурации сначала.</li>

<li>Сокращение количества переключений, которые <code>InnoDB</code>
делает между параллельными потоками, так, чтобы операции SQL на занятом
сервере не стояли в очереди и сформировали <span><span>поток трафика</span>
</span>. Установите значение для опции
<a href="innodb.htm#sysvar_innodb_thread_concurrency"><code>
innodb_thread_concurrency</code></a>
до приблизительно 32 для мощной современной системы. Увеличьте значение
опции <a href="innodb.htm#sysvar_innodb_concurrency_tickets"><code>
innodb_concurrency_tickets</code></a>, как правило к 5000 или около этого.
Эта комбинация опций устанавливает ограничение на число потоков, которые
<code>InnoDB</code> обрабатывает в любой момент и позволяет каждому потоку
сделать существенную работу прежде, чем быть переключенным, чтобы число
потоков ожидания осталось низким, и операции могут завершиться без
чрезмерного переключения контекста.</p></li></ul>

<h3><a name="optimizing-innodb-many-tables"></a>9.5.10.
Оптимизация InnoDB для систем со многими таблицами</h3>
<ul><li><p><code>InnoDB</code> вычисляет индексные значения
<a href="glossary.htm#glos_cardinality">количества элементов</a>
для таблицы в первый раз, когда к таблице получают доступ после запуска,
вместо того, чтобы хранить такие значения в таблице. Этот шаг может занять
время на системах, которые делят данные на многие таблицы. Так как это
относится только к начальной работе открытия таблицы, к
<span><span>нагретым</span></span> для более позднего использования таблицам
немедленно получают доступ после запуска, делая такой запрос, как
<code>SELECT 1 FROM <em><code>tbl_name</code></em> LIMIT 1</code>.
</p></li></ul>

<h2><a name="optimizing-myisam"></a>9.6.
Оптимизация для таблиц MyISAM</h2>
<p><a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>
выступает лучше всего с данными главным образом для чтения или с операциями
низкого параллелизма, потому что табличные блокировки ограничивают
способность выполнить одновременные обновления. В MySQL
<a href="innodb.htm"><code>InnoDB</code></a>
механизм хранения по умолчанию, а не <code>MyISAM</code>.</p>

<h3><a name="optimizing-queries-myisam"></a>9.6.1.
Оптимизация запросов MyISAM</h3>
<p>Некоторые общие советы для того, чтобы ускорить запросы
на таблицах <code>MyISAM</code>:</p>

<ul><li><p>Чтобы помочь MySQL лучше оптимизировать запросы, стоит
использовать <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>
или <a href="programs.htm#myisamchk"><span><strong>myisamchk --analyze
</strong></span></a> на таблице после того, как это было загружено данными.
Это обновляет значение для каждой части индекса, которая указывает на среднее
число строк, у которых есть то же самое значение, поскольку уникальный индекс
это всегда 1. MySQL использует это, чтобы решить, который индекс выбрать,
когда Вы присоединяетесь к двум таблицам, основанным на непостоянном
выражении. Вы можете проверить следствие табличного анализа при использовании
<code>SHOW INDEX FROM <em><code>tbl_name</code></em></code> и исследуя
значение <code>Cardinality</code>. <a href="programs.htm#myisamchk"><span>
<strong>myisamchk --description --verbose</strong></span></a> показывает
информацию о распределении индекса.</li>

<li>Чтобы сортировать индекс и данные согласно индексированию, используйте
<a href="programs.htm#myisamchk"><span><strong>myisamchk --sort-index
--sort-records=1</strong></span></a> (предполагается, что Вы хотите
сортировать на индексе 1). Это хороший способ сделать запросы быстрее, если у
Вас есть уникальный индекс, из которого Вы хотите считать все строки в
порядке согласно индексированию. В первый раз, когда Вы сортируете большую
таблицу этим путем, может потребоваться много времени.</li>

<li>Попытайтесь избежать сложных <a href="sql.htm#select"><code>SELECT</code>
</a> на <code>MyISAM</code>, которые часто обновляются, чтобы избежать
проблем с блокировкой таблицы.</li>

<li><code>MyISAM</code> допускает параллельные вставки: если у таблицы нет
никаких свободных блоков в середине файла с данными, Вы можете
<a href="sql.htm#insert"><code>INSERT</code></a> новые строки в то же самое
время, когда другие потоки читают из таблицы. Если важно быть в состоянии
сделать это, рассмотрите использование таблицы способами, которые избегают
удалять строки. Другая возможность состоит в том, чтобы выполнить
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>, чтобы
дефрагментировать таблицу после того, как Вы удалили много строк.
Это поведение изменено, устанавливая
<a href="server.htm#sysvar_concurrent_insert"><code>concurrent_insert</code>
</a>. Вы можете вынудить новые строки быть добавленными
(и поэтому разрешить параллельные вставки), даже в таблицах, которые удалили
строки. См. <a href="#concurrent-inserts">раздел 9.11.3</a>.</li>

<li>Для <code>MyISAM</code> таблицы, которые часто изменяются, пытаются
избежать всех столбцов переменной длины
(<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>).
Таблица использует динамический формат строки, если это включает даже
единственный столбец переменной длины. См. <a href="storage.htm">главу 17
</a>.</li>

<li>Обычно не стоит делить таблицу на различные таблицы только потому, что
строки становятся большими. В доступе к строке самая большая проблема это
дисковые поиски, чтобы найти первый байт строки. После обнаружения данных
самые современные диски могут считать всю строку достаточно быстро для
большинства приложений. Единственные случаи, где разделение таблицы имеет
заметное значение, это если применен динамический формат строки, который Вы
можете изменить на фиксированный размер строки, или если Вы очень часто
должны просматривать таблицу, но не нуждаетесь в большинстве столбцов. См.
columns. See <a href="storage.htm">главу 17</a>.</li>

<li>Используйте <code>ALTER TABLE ... ORDER BY <em><code>expr1</code></em>,
<em><code>expr2</code></em>, ...</code>, если Вы обычно получаете строки в
порядке <code><em><code>expr1</code></em>,
<em><code>expr2</code></em>, ...</code>. При использовании этой опции после
обширных изменений таблицы Вы можете быть в состоянии получить
более высокую работу.</li>

<li>Если Вы часто должны вычислять результаты, такие как количество,
основанные на информации от большого количества строк, может быть
предпочтительно ввести новую таблицу и обновить счетчик в режиме реального
времени. Обновление следующей формы очень быстро:
<pre>
UPDATE <em><code>tbl_name</code></em> SET <em><code>count_col</code></em>=<em><code>count_col</code></em>+1
       WHERE <em><code>key_col</code></em>=<em><code>constant</code></em>;
</pre>

<p>Это очень важно, когда Вы используете механизмы хранения MySQL, такие как
<code>MyISAM</code>, у которых есть только блокировка на уровне таблицы.
Это также дает лучшую работу с большинством систем базы данных, потому что
менеджер блокировки строк в этом случае загружен меньше.</li>

<li>Используйте регулярно <a href="sql.htm#optimize-table"><code>OPTIMIZE
TABLE</code></a>, чтобы избегать фрагментации с динамическим форматом
таблиц <code>MyISAM</code>, см.
<a href="storage.htm#myisam-table-formats">раздел 17.2.3</a>.</li>

<li>Объявление <code>MyISAM</code> с опцией
<code>DELAY_KEY_WRITE=1</code> делает индексные обновления быстрее, потому
что они не сбрасываются на диск, пока таблица не закрыта. Проблема в
том, что если что-то уничтожает сервер в то время как, такая таблица открыта,
Вы должны гарантировать, что таблица в порядке, выполняя сервер с опцией
<a href="server.htm#option_mysqld_myisam-recover-options"><code>
--myisam-recover-options</code></a> или выполняя
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
прежде, чем перезапустить сервер. Однако, даже в этом случае, Вы ничего не
должны потерять при использовании <code>DELAY_KEY_WRITE</code>, потому что
ключевая информация может всегда производиться от строк данных.</li>

<li>Вы можете увеличить производительность, кэшируя запросы или ответы в
Вашем приложении, и затем выполняя многие вставки или обновления вместе.
Блокировка таблицы во время этой работы гарантирует, что индексный кэш
сброшен только однажды после всех обновлений. Вы можете также использовать в
своих интересах кэш запроса MySQL, чтобы достигнуть подобных результатов, см.
<a href="#query-cache">раздел 9.10.3</a>.</p></li></ul>

<h3><a name="optimizing-myisam-bulk-data-loading"></a>9.6.2.
Оптовые загрузки данных для MyISAM</h3>
<p>Эти исполнительные подсказки добавляют общие руководящие принципы
для быстрых вставок в <a href="#insert-speed">разделе 9.2.2.1</a>.
</p>

<ul><li><p>Для <code>MyISAM</code> Вы можете использовать параллельные
вставки, чтобы добавить строки в то же самое время, когда работает
<a href="sql.htm#select"><code>SELECT</code></a>,
если нет никаких удаленных строк в середине файла с данными. См.
<a href="#concurrent-inserts">раздел 9.11.3</a>.</li>

<li>С некоторой дополнительной работой возможно сделать
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a> еще быстрее для
<code>MyISAM</code>, когда у таблицы есть много индексов.
Используйте следующую процедуру:</p>

<ol type="1"><li><p>Выполните <a href="sql.htm#flush"><code>FLUSH
TABLES</code></a> или <a href="programs.htm#mysqladmin"><span><strong>
mysqladmin flush-tables</strong></span></a>.</li>

<li>Используйте <a href="programs.htm#myisamchk"><span><strong>myisamchk
--keys-used=0 -rq <em><code>/path/to/db/tbl_name</code></em></strong></span>
</a>, чтобы удалить все индексы для таблицы.</li>

<li>Вставьте данные в таблицу с
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>.
Это не обновляет индексы и поэтому очень быстро.</li>

<li>Если Вы намереваетесь только читать из таблицы в будущем, используйте
<a href="programs.htm#myisampack"><span><strong>myisampack</strong></span>
</a>, см. <a href="storage.htm#compressed-format">раздел 17.2.3.3</a>.</li>

<li>Обновите индексирование с <a href="programs.htm#myisamchk"><span><strong>
myisamchk -rq <em><code>/path/to/db/tbl_name</code></em></strong></span></a>.
Это создает индексное дерево в памяти прежде, чем написать на диск, что
намного быстрее, чем обновление индексирования во время
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>,
потому что это избегает многих дисковых поисков. Получающиеся индексное
дерево также отлично сбалансировано.</li>

<li>Выполните <a href="sql.htm#flush"><code>FLUSH TABLES</code></a> или
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-tables
</strong></span></a>.</p></li></ol>

<p><a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>
выполняет предыдущую оптимизацию автоматически, если таблица, в которую Вы
вставляете данные, пуста. Основное различие между автоматической оптимизацией
и использованием процедуры явно то, что Вы можете позволить
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
выделять намного больше временной памяти для создания индекса, чем Вы могли
бы хотеть, чтобы сервер выделил для воссоздания индекса, когда это выполняет
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>.</p>

<p>Вы можете также отключить или включить групповые индексы для таблиц
<code>MyISAM</code> при использовании следующих запросов, а не
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>.
Если Вы используете эти запросы, Вы можете пропустить шаг
<a href="sql.htm#flush"><code>FLUSH TABLE</code></a>:
<pre>
ALTER TABLE <em><code>tbl_name</code></em> DISABLE KEYS;
ALTER TABLE <em><code>tbl_name</code></em> ENABLE KEYS;
</pre></li>

<li>Чтобы ускорить <a href="sql.htm#insert"><code>INSERT</code></a>, которые
выполнены с многими запросами для нетранзакционных таблиц,
блокируйте Ваши таблицы:
<pre>
LOCK TABLES a WRITE;
INSERT INTO a VALUES (1,23),(2,34),(4,33);
INSERT INTO a VALUES (8,26),(6,29);
...
UNLOCK TABLES;
</pre>

<p>Это приносит пользу работе, потому что индексный буфер сбрасывается на
диск только однажды, в конце всех
<a href="sql.htm#insert"><code>INSERT</code></a>.
Обычно было бы так много индексных буферных сбросов, сколько
<a href="sql.htm#insert"><code>INSERT</code></a>.
Явные запросы блокировки не необходимы, если Вы можете вставить все строки
одним вызовом <a href="sql.htm#insert"><code>INSERT</code></a>.</p>

<p>Блокировка также удаляет полное время для тестов многократного соединения,
хотя максимум ожидания для отдельных соединений могло бы повыситься,
потому что они ждут блокировок. Предположите, что пять клиентов пытаются
вставлять одновременно следующим образом:</p>

<ul><li><p>Соединение 1 делает 1000 вставок.</li>
<li>Соединения 2, 3 и 4 делают 1 вставку.</li>
<li>Соединение 5 делает 1000 вставок.</p></li></ul>

<p>Если Вы не используете блокировку, соединения 2, 3 и 4 закончат до 1 и 5.
Если Вы используете блокировку, соединения 2, 3 и 4, вероятно, не
заканчиваются прежде 1 или 5, но полное время должно быть
приблизительно на 40% быстрее.</p>

<p><a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>
очень быстры в MySQL, но Вы можете получить лучшую эффективность работы,
добавляя блокировки вокруг всего, что делает больше, чем приблизительно пять
последовательных вставок или обновлений. Если Вы делаете очень много
последовательных вставок, Вы могли бы сделать <a href="sql.htm#lock-tables">
<code>LOCK TABLES</code></a>, сопровождаемый
<a href="sql.htm#lock-tables"><code>UNLOCK TABLES</code></a>
время от времени (приблизительно каждые 1000 строк), чтобы разрешить другим
потокам получать доступ к таблице. Это все еще привело бы к
хорошему приросту производительности.</p>

<p><a href="sql.htm#insert"><code>INSERT</code></a>
все еще намного медленнее для того, чтобы загрузить данные, чем
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>,
даже когда использование стратегий только обрисовано в общих чертах.</li>

<li>Чтобы ускорить работу для <code>MyISAM</code>, для обоих
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a> и
<a href="sql.htm#insert"><code>INSERT</code></a>, увеличьте ключевой кэш,
увеличивая переменную <a href="server.htm#sysvar_key_buffer_size"><code>
key_buffer_size</code></a>, см. <a href="server.htm#server-configuration">
раздел 6.1.1</a>.</p></li></ul>

<h3><a name="repair-table-speed"></a>9.6.3. Скорость REPAIR TABLE</h3>
<p><a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a> для
<code>MyISAM</code> подобен использованию
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
для операций ремонта, и часть той же самой
исполнительной оптимизации применяется:</p>

<ul><li><p><a href="programs.htm#myisamchk"><span><strong>myisamchk</strong>
</span></a> имеет переменные для управления распределением памяти.
Вы можете быть в состоянии улучшить работу, устанавливая эти переменные, как
описано в <a href="programs.htm#myisamchk-memory">разделе 5.6.4.6</a>.</li>

<li>Для <a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>
тот же самый принцип применяется, но потому что ремонт сделан сервером, Вы
устанавливаете системные переменные сервера вместо
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>.
Кроме того, в дополнение к установке переменных распределения памяти,
увеличение <a href="server.htm#sysvar_myisam_max_sort_file_size"><code>
myisam_max_sort_file_size</code></a>
увеличивает вероятность, что ремонт будет использовать быстрый метод filesort
и избегать более медленного ремонта методом ключевого кэша.
Установите переменную в максимальный размер файла для Вашей системы, после
проверки, что есть достаточное свободное пространство, чтобы разместить копию
табличных файлов. Свободное пространство должно быть доступным в файловой
системе, содержащей оригинальные табличные файлы.</p></li></ul>

<p>Предположите, что <a href="programs.htm#myisamchk"><span><strong>myisamchk
</strong></span></a> работает, используя следующие опции, чтобы установить
переменные распределения памяти:
<pre>
--key_buffer_size=128M --myisam_sort_buffer_size=256M
--read_buffer_size=64M --write_buffer_size=64M
</pre>

<p>Некоторые из тех переменных <a href="programs.htm#myisamchk"><span>
<strong>myisamchk</strong></span></a> соответствуют переменным сервера:</p>
<table border="1">
<thead><tr><th scope="col">Переменная <a href="programs.htm#myisamchk"><span>
<strong>myisamchk</strong></span></a></th><th scope="col">
Системная переменная</th></tr></thead>
<tbody><tr><td scope="row"><code>key_buffer_size</code></td>
<td><a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code>
</a></td></tr>
<tr><td scope="row"><code>myisam_sort_buffer_size</code></td><td>
<a href="server.htm#sysvar_myisam_sort_buffer_size"><code>
myisam_sort_buffer_size</code></a></td></tr>
<tr><td scope="row"><code>read_buffer_size</code></td><td>
<a href="server.htm#sysvar_read_buffer_size"><code>read_buffer_size</code>
</a></td></tr>
<tr><td scope="row"><code>write_buffer_size</code></td><td>Нет</td>
</tr></tbody></table>

<p>Каждая из системных переменных сервера может быть установлена во время
выполнения, и некоторые из них
(<a href="server.htm#sysvar_myisam_sort_buffer_size"><code>
myisam_sort_buffer_size</code></a>,
<a href="server.htm#sysvar_read_buffer_size"><code>read_buffer_size</code>
</a>) имеют значение сеанса в дополнение к глобальному значению. Установка
значения сеанса ограничивает эффект изменения Вашего текущего сеанса и не
затрагивает других пользователей. Замена глобальной переменной
(<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code>
</a>, <a href="server.htm#sysvar_myisam_max_sort_file_size"><code>
myisam_max_sort_file_size</code></a>)
затрагивает других пользователей также. Для
<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code></a>
Вы должны принять во внимание, что буфер совместно использован с теми
пользователями. Например, если Вы устанавливаете переменную
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
<code>key_buffer_size</code> в 128MB, Вы могли установить
<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code></a>
больше чем это (если это еще не установлено больше), чтобы разрешить ключевое
буферное использование деятельностью в других сеансах. Однако, изменение
глобального ключевого размера буфера лишает законной силы буфер, вызывая
увеличенный дисковый ввод/вывод и замедление для других сеансов.
Альтернатива, которая избегает этой проблемы, должна использовать отдельный
ключевой кэш для индексов из восстанавливаемой таблицы, который надо
освободить, когда ремонт закончен. См.
<a href="#multiple-key-caches">раздел 9.10.2.2</a>.</p>

<p>Основанный на предыдущих замечаниях, <a href="sql.htm#repair-table"><code>
REPAIR TABLE</code></a> может быть сделан следующим образом, чтобы
использовать настройки, подобные <a href="programs.htm#myisamchk"><span>
<strong>myisamchk</strong></span></a>. Здесь отдельный ключевой буфер 128 МБ
выделен, и файловая система, как предполагается, разрешает размер файла по
крайней мере 100 GB.
<pre>
SET SESSION myisam_sort_buffer_size = 256*1024*1024;
SET SESSION read_buffer_size = 64*1024*1024;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
SET GLOBAL repair_cache.key_buffer_size = 128*1024*1024;
CACHE INDEX <em><code>tbl_name</code></em> IN repair_cache;
LOAD INDEX INTO CACHE <em><code>tbl_name</code></em>;
REPAIR TABLE <em><code>tbl_name</code></em> ;
SET GLOBAL repair_cache.key_buffer_size = 0;
</pre>

<p>Если Вы намереваетесь заменить глобальную переменную, но хотите
сделать это только для работы <a href="sql.htm#repair-table"><code>REPAIR
TABLE</code></a>, чтобы минимально затронуть других пользователей, сохраните
ее значение в пользовательской переменной и восстановите ее позже:
<pre>
SET @old_myisam_sort_buffer_size = @@global.myisam_max_sort_file_size;
SET GLOBAL myisam_max_sort_file_size = 100*1024*1024*1024;
REPAIR TABLE tbl_name;
SET GLOBAL myisam_max_sort_file_size = @old_myisam_max_sort_file_size;
</pre>

<p>Системные переменные, влияющие на <a href="sql.htm#repair-table"><code>
REPAIR TABLE</code></a>, может быть установлен глобально при запуске сервера,
если Вы хотите, чтобы значения были заданы по умолчанию. Например, добавьте
эти строки к файлу <code>my.cnf</code>:
<pre>
[mysqld]
myisam_sort_buffer_size=256M
key_buffer_size=1G
myisam_max_sort_file_size=100G
</pre>

<p>Эти настройки не включают
<a href="server.htm#sysvar_read_buffer_size"><code>read_buffer_size</code>
</a>. Установка <a href="server.htm#sysvar_read_buffer_size"><code>
read_buffer_size</code></a> глобально к большому значению делает это для всех
сеансов и может заставить работу пострадать из-за чрезмерного распределения
памяти для сервера с многими одновременными сеансами.</p>

<h2><a name="optimizing-memory-tables"></a>9.7. Оптимизация таблиц MEMORY</h2>
<p>Рассмотрите использование <code>MEMORY</code> для некритических данных, к
которым часто получают доступ только для чтения (или они редко обновлены).
</p>

<p>Для лучшей работы с <code>MEMORY</code> исследуйте виды запросов каждой
таблицы и определите тип для каждого связанного индекса, B-tree или hash.
В <a href="sql.htm#create-index"><code>CREATE INDEX</code></a> используйте
<code>USING BTREE</code> или <code>USING HASH</code>. B-tree
быстры для запросов, которые делают сравнения через такие операторы, как
<code>&gt;</code> или <code>BETWEEN</code>. Хеш-индексы быстры для запросов,
которые ищут единственные значения через <code>=</code> или ограниченный
набор значений через <code>IN</code>. <code>USING BTREE</code> часто лучший
выбор, чем значение по умолчанию <code>USING HASH</code>, см.
<a href="#how-to-avoid-table-scan">раздел 9.2.1.21</a>.
Для деталей выполнения различных типов индексов в <code>MEMORY</code> см.
<a href="#index-btree-hash">раздел 9.3.8</a>.</p>

<h2><a name="execution-plan-information"></a>9.8.
Понимание плана выполнения запроса</h2>
<p>В зависимости от деталей Ваших таблиц, столбцов, индексов и условий в
Вашем <code>WHERE</code>, оптимизатор MySQL имеет много методов эффективно
выполняют поиски, вовлеченные в запрос SQL. Запрос на огромной таблице может
быть выполнен, не читая все строки; соединение, вовлекающее несколько таблиц,
может быть выполнено, не сравнивая каждую комбинацию строк. Набор операций,
с помощью которых оптимизатор хочет выполнять самый эффективный запрос,
называют <span><span>планом выполнения запроса</span></span>, также он
известен как план <a href="sql.htm#explain"><code>EXPLAIN</code></a>.
Ваши цели состоят в том, чтобы признать аспекты плана
<a href="sql.htm#explain"><code>EXPLAIN</code></a>, которые указывают на то,
что запрос оптимизирован хорошо, и изучить синтаксис SQL и методы индексации,
чтобы улучшить план, если Вы видите некоторые неэффективные операции.</p>

<h3><a name="using-explain"></a>9.8.1. Оптимизация запросов с EXPLAIN</h3>
<p><a href="sql.htm#explain"><code>EXPLAIN</code></a> может использоваться,
чтобы получить информацию о том, как MySQL выполняет запрос:</p>

<ul><li><p>Разрешенные объяснимые запросы для
<a href="sql.htm#explain"><code>EXPLAIN</code></a>:
<a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#replace"><code>REPLACE</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>.</li>

<li>Когда <a href="sql.htm#explain"><code>EXPLAIN</code></a> используется
с объяснимым запросом, MySQL выводит на экран информацию от оптимизатора о
плане выполнения запроса. Таким образом, MySQL объясняет, как он обработал бы
запрос, включая информацию о том, как к таблицам присоединяются и в каком
порядке. Для информации об использовании
<a href="sql.htm#explain"><code>EXPLAIN</code></a>, чтобы получить информацию
о плане выполнения, см. <a href="#explain-output">раздел 9.8.2
</a>.</li>

<li>Когда <a href="sql.htm#explain"><code>EXPLAIN</code></a> используется с
<code>FOR CONNECTION <em><code>connection_id</code></em></code> вместо
объяснимого запроса, это выводит на экран план выполнения относительно
запроса в названном соединении. См.
<a href="#explain-for-connection">раздел 9.8.4</a>.</li>

<li>Опция <code>FORMAT</code> может использоваться, чтобы выбрать выходной
формат. <code>TRADITIONAL</code> представляет вывод в табличном формате. Это
значение по умолчанию, если нет опции <code>FORMAT</code>. Формат
<code>JSON</code> выводит на экран информацию в формате JSON. С
<code>FORMAT = JSON</code> вывод включает расширенные
данные и информацию о разделе</p></li></ul>

<p>С помощью <a href="sql.htm#explain"><code>EXPLAIN</code></a> Вы можете
видеть, где Вы должны добавить индекс к таблицам так, чтобы запрос выполнился
быстрее при использовании индекса, чтобы найти строки. Вы можете также
использовать <a href="sql.htm#explain"><code>EXPLAIN</code></a>, чтобы
проверить, присоединяется ли оптимизатор к таблицам в оптимальном порядке.
Чтобы дать подсказку оптимизатор, чтобы использовать порядок соединения,
соответствующий порядку, в котором таблицы называют в
<a href="sql.htm#select"><code>SELECT</code></a>, начните запрос с
<code>SELECT STRAIGHT_JOIN</code> вместо
<a href="sql.htm#select"><code>SELECT</code></a>, см.
<a href="sql.htm#select">раздел 14.2.9</a>. Однако,
<code>STRAIGHT_JOIN</code> может не дать использовать индексы, потому что это
отключает преобразования полусоединения. См.
<a href="#semi-joins">раздел 9.2.1.18.1</a>.</p>

<p>Оптимизатор может иногда предоставлять информацию, дополнительную к
<a href="sql.htm#explain"><code>EXPLAIN</code></a>.
Однако, формат трассировки оптимизатора и контент подвержены изменениям между
версиями. Для деталей см.
<a href="../../../dev.mysql.com/doc/internals/en/optimizer-tracing.html"
target="_top">MySQL Internals: Tracing the Optimizer</a>.</p>

<p>Если у Вас есть проблема с индексом, выполните
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>, чтобы
обновить табличную статистику, такую как количество элементов ключей, которые
могут затронуть выбор, который делает оптимизатор. См.
<a href="sql.htm#analyze-table">раздел 14.7.2.1</a>.</p>

<p><a href="sql.htm#explain"><code>EXPLAIN</code></a>
может также использоваться, чтобы получить информацию о столбцах в таблице.
<a href="sql.htm#explain"><code>EXPLAIN
<em><code>tbl_name</code></em></code></a> синоним
with <code>DESCRIBE <em><code>tbl_name</code></em></code> и
<code>SHOW COLUMNS FROM <em><code>tbl_name</code></em></code>. См. разделы
information, see <a href="sql.htm#describe">14.8.1</a> и
<a href="sql.htm#show-columns">14.7.5.5</a>.</p>

<h3><a name="explain-output"></a>9.8.2. Выходной формат EXPLAIN</h3>
<p><a href="sql.htm#explain"><code>EXPLAIN</code></a>
предоставляет информацию о плане выполнения относительно
<a href="sql.htm#select"><code>SELECT</code></a>.</p>

<p><a href="sql.htm#explain"><code>EXPLAIN</code></a>
возвращает строку информации для каждой таблицы, используемой в
<a href="sql.htm#select"><code>SELECT</code></a>.
Это перечисляет таблицы в выводе в порядке, в котором
MySQL считал бы их, обрабатывая запрос. MySQL решает все соединения,
используя метод соединения вложенной петли. Это означает, что MySQL читает
строку из первой таблицы, а затем находит соответствующую строку во второй
таблице, третьей и так далее. Когда все таблицы обработаны, MySQL выводит
выбранные столбцы и отступления через табличный список, пока таблица не
найдена, для которой более соответствуют строки. Следующая строка считана из
этой таблицы, и процесс продолжается со следующей таблицей.</p>

<p>Нельзя использовать устаревшие параметры <code>EXTENDED</code> и
<code>PARTITIONS</code> вместе в том же самом
<a href="sql.htm#explain"><code>EXPLAIN</code></a>. Кроме того, ни одно из
этих ключевых слов не может использоваться вместе с опцией
<code>FORMAT</code>. <code>FORMAT=JSON</code> предписывает
<code>EXPLAIN</code> вывести на экран расширенную информацию и данные о
разделении автоматически, использование <code>FORMAT=TRADITIONAL</code> не
влияет на вывод <code>EXPLAIN</code>.</p>

<ul><li><p>Столбцы вывода <a href="#explain-output-columns"><code>
EXPLAIN</code></a>.</li>
<li>Типы соединения <a href="#explain-join-types"><code>EXPLAIN
</code></a>.</li>

<li>Дополнительная информация <a href="#explain-extra-information">
<code>EXPLAIN</code></a>.</li>
<li>Интерпретация вывода <a href="#explain-output-interpretation">
<code>EXPLAIN</code></a>.</p></li></ul>

<h4><a name="explain-output-columns"></a>Столбцы вывода EXPLAIN</h4>
<p>Этот раздел описывает выходные столбцы, произведенные
<a href="sql.htm#explain"><code>EXPLAIN</code></a>.
Более поздние разделы обеспечивают дополнительную информацию о столбцах
<a href="#explain-join-types"><code>type</code></a> и
<a href="#explain-extra-information"><code>Extra</code></a>.</p>

<p>Каждая выходная строка <a href="sql.htm#explain"><code>EXPLAIN</code></a>
предоставляет информацию об одной таблице. Каждая строка содержит значения,
полученные в итоге в <a href="#explain-output-column-table">
таблице 9.1</a>, и описанные более подробно после таблицы. Имена столбцов
показывают в первом столбце таблицы, второй столбец обеспечивает
эквивалентное имя свойства, показанное в выводе, когда
используется <code>FORMAT=JSON</code>.</p>

<a name="explain-output-column-table"></a><p><b>
Таблица 9.1. Столбцы вывода EXPLAIN</b></p>
<table border="1">
<thead><tr><th scope="col">Столбец</th><th scope="col">Имя JSON</th>
<th scope="col">Значение</th></tr></thead>
<tbody><tr><td scope="row"><a href="#explain_id"><code>id</code>
</a></td><td><code>select_id</code></td><td>
Идентификатор <code>SELECT</code></td></tr>
<tr><td scope="row"><a href="#explain_select_type"><code>
select_type</code></a></td><td>Нет</td><td>Тип <code>SELECT</code></td></tr>
<tr><td scope="row"><a href="#explain_table"><code>table</code>
</a></td><td><code>table_name</code></td><td>Таблица для выходной строки
</td></tr>
<tr><td scope="row"><a href="#explain_partitions"><code>
partitions</code></a></td><td><code>partitions</code></td><td>
Соответствующее разделение</td></tr>
<tr><td scope="row"><a href="#explain_type"><code>type</code></a>
</td><td><code>access_type</code></td><td>Тип соединения</td></tr>
<tr><td scope="row"><a href="#explain_possible_keys"><code>
possible_keys</code></a></td><td><code>possible_keys</code></td><td>
Возможные индексы, чтобы выбрать</td></tr>
<tr><td scope="row"><a href="#explain_key"><code>key</code></a>
</td><td><code>key</code></td><td>Индекс, который фактически выбран</td></tr>
<tr><td scope="row"><a href="#explain_key_len"><code>key_len
</code></a></td><td><code>key_length</code></td><td>Длина выбранного ключа
</td></tr>
<tr><td scope="row"><a href="#explain_ref"><code>ref</code></a>
</td><td><code>ref</code></td><td>Столбцы по сравнению с индексом</td></tr>
<tr><td scope="row"><a href="#explain_rows"><code>rows</code></a>
</td><td><code>rows</code></td><td>Оценка строк, которые будут исследованы
</td></tr>
<tr><td scope="row"><a href="#explain_filtered"><code>filtered
</code></a></td><td><code>filtered</code></td><td>Процент строк, которые
фильтруются по табличному условию</td></tr>
<tr><td scope="row"><a href="#explain_extra"><code>Extra</code>
</a></td><td>Нет</td><td>Дополнительная информация</td></tr></tbody></table>
<p>Свойства JSON, которые являются <code>NULL</code>,
не выведены на экран в JSON-формате вывода <code>EXPLAIN</code>.</p>

<ul><li><p><a name="explain_id"></a><code>id</code> (Имя JSON:
<code>select_id</code>)</p>
<p>Идентификатор <a href="sql.htm#select"><code>SELECT</code></a>.
Это последовательное число
<a href="sql.htm#select"><code>SELECT</code></a> в запросе.
Значение может быть <code>NULL</code>, если строка обращается к результату
союза других строк. В этом случае столбец <code>table</code> показывает
значение как <code>&lt;union<em><code>M</code></em>,<em><code>N</code>
</em>&gt;</code>, чтобы указать, что строка обращается к союзу строк с
<code>id</code> <em><code>M</code></em> и <em><code>N</code></em>.</li>

<li><a name="explain_select_type"></a>
<code>select_type</code> (Имя JSON: нет)</p>
<p>Тип <a href="sql.htm#select"><code>SELECT</code></a>,
который может быть любым из показанных в следующей таблице.
JSON-отформатированный вывод <code>EXPLAIN</code> показывает тип
<code>SELECT</code> как свойство <code>query_block</code>, если это не
<code>SIMPLE</code> или <code>PRIMARY</code>. Имена JSON (где применимы)
также показываются в таблице.</p>

<table border="1">
<thead><tr><th scope="col"><code>select_type</code></th>
<th scope="col">Имя JSON</th><th scope="col">Смысл</th></tr></thead>
<tbody><tr><td scope="row"><code>SIMPLE</code></td><td>Нет</td>
<td>Простой <a href="sql.htm#select"><code>SELECT</code></a> (не использует
<a href="sql.htm#union"><code>UNION</code></a> или подзапросы).</td></tr>
<tr><td scope="row"><code>PRIMARY</code></td><td>Нет</td>
<td>Наиболее удаленный <a href="sql.htm#select"><code>SELECT</code></a>.
</td></tr>
<tr><td scope="row"><a href="sql.htm#union"><code>UNION</code></a></td>
<td>Нет</td><td>Второй или более дальний <a href="sql.htm#select"><code>
SELECT</code></a> в <a href="sql.htm#union"><code>UNION</code></a>.</td></tr>
<tr><td scope="row"><code>DEPENDENT UNION</code></td><td>
<code>dependent</code> (<code>true</code>)</td><td>
Второй или более дальний <a href="sql.htm#select"><code>SELECT</code></a> в
<a href="sql.htm#union"><code>UNION</code></a>, зависит от внешнего запроса.
</td></tr>
<tr><td scope="row"><code>UNION RESULT</code></td><td>
<code>union_result</code></td><td>Результат <a href="sql.htm#union"><code>
UNION</code></a>.</td></tr>
<tr><td scope="row"><code>SUBQUERY</code></td><td>Нет</td>
<td>Первый <a href="sql.htm#select"><code>SELECT</code></a> в подзапросе.
</td></tr>
<tr><td scope="row"><code>DEPENDENT SUBQUERY</code></td><td>
<code>dependent</code> (<code>true</code>)</td><td>
Первый <a href="sql.htm#select"><code>SELECT</code></a> в подзапросе,
зависит от внешнего запроса.</td></tr>
<tr><td scope="row"><code>DERIVED</code></td><td>Нет</td><td>
Полученная таблица <a href="sql.htm#select"><code>SELECT</code></a>
(подзапрос в <code>FROM</code>).</td></tr>
<tr><td scope="row"><code>MATERIALIZED</code></td><td><code>
materialized_from_subquery</code></td><td>Осуществленный подзапрос.</td></tr>
<tr><td scope="row"><code>UNCACHEABLE SUBQUERY</code></td><td>
<code>cacheable</code> (<code>false</code>)</td><td>
Подзапрос, для которого результат не может кэшироваться и должен быть
переоценен для каждой строки внешнего запроса.</td></tr>
<tr><td scope="row"><code>UNCACHEABLE UNION</code></td><td>
<code>cacheable</code> (<code>false</code>)</td><td>
Второй или более дальний select в <a href="sql.htm#union"><code>UNION</code>
</a>, который принадлежит некэшируемому подзапросу (см.
<code>UNCACHEABLE SUBQUERY</code>).</td></tr></tbody></table>

<p><code>DEPENDENT</code> как правило показывает использование
коррелированого подзапроса. См. <a href="sql.htm#correlated-subqueries">
раздел 14.2.10.7</a>.</p>

<p><code>DEPENDENT SUBQUERY</code> отличается от
<code>UNCACHEABLE SUBQUERY</code>. Для <code>DEPENDENT SUBQUERY</code>
подзапрос переоценен только однажды для каждого набора различных значений
переменных от его внешнего контекста. Для <code>UNCACHEABLE SUBQUERY</code>
подзапрос переоценен для каждой строки внешнего контекста.</p>

<p>Кэшируемость подзапросов отличается от кэширования результатов запроса в
кэше запроса (которое описано в
<a href="#query-cache-operation">разделе 9.10.3.1</a>).
Кэширование подзапроса происходит во время выполнения запроса, тогда как кэш
запроса используется, чтобы сохранить результаты только после того, как
выполнение запроса заканчивается.</p>

<p>Когда Вы определяете <code>FORMAT=JSON</code>,
у вывода нет никакого единственного свойства, непосредственно эквивалентного
<code>select_type</code>, свойство <code>query_block</code>
соответствует данному <code>SELECT</code>. Свойства, эквивалентные
большинству типов подзапросов <code>SELECT</code>, доступны (например,
<code>materialized_from_subquery</code> для <code>MATERIALIZED</code>). Нет
никаких эквивалентов JSON для <code>SIMPLE</code> или <code>PRIMARY</code>.
</p>

<p><code>select_type</code> для не-<a href="sql.htm#select"><code>SELECT
</code></a> выводят на экран тип запроса для затронутых таблиц. Например,
<code>select_type</code> это <code>DELETE</code> для запроса
<a href="sql.htm#delete"><code>DELETE</code></a>.</li>

<li><a name="explain_table"></a><code>table</code> (Имя JSON:
<code>table_name</code>)</p>
<p>Название таблицы, к которой обращается строка вывода.
Это может также быть одним из следующих значений:</p>

<ul><li><p><code>&lt;union<em><code>M</code></em>,<em><code>N</code></em>&gt;
</code>: Строка обращается к союзу строк с
<code>id</code> <em><code>M</code></em> и <em><code>N</code></em>.</li>

<li><code>&lt;derived<em><code>N</code></em>&gt;</code>:
Строка обращается к полученному табличному результату для строки с
<code>id</code> <em><code>N</code></em>. Полученная таблица может
закончиться, например, от подзапроса в <code>FROM</code>.</li>

<li><code>&lt;subquery<em><code>N</code></em>&gt;</code>:
Строка обращается к результату осуществленного подзапроса для строки с
<code>id</code> <em><code>N</code></em>. См.
<a href="#subquery-materialization">раздел 9.2.1.18.2</a>.
</p></li></ul></li>

<li><a name="explain_partitions"></a><code>partitions</code> (Имя JSON:
<code>partitions</code>)</p>
<p>Раздел, от которого записи были бы соответствующими запросу.
Этот столбец выведен на экран только, если использован параметр
<code>PARTITIONS</code>. <code>NULL</code> для неразделенных таблиц. См.
<a href="partit.htm#partitioning-info">раздел 20.3.5</a>.</li>

<li><a name="explain_type"></a><code>type</code> (Имя JSON:
<code>access_type</code>)</p>
<p>Тип соединения. Для описаний различных типов см.
<a href="#explain-join-types">Типы соединения <code>EXPLAIN</code>
</a>.</li>

<li><a name="explain_possible_keys"></a>
<code>possible_keys</code> (Имя JSON: <code>possible_keys</code>)</p>
<p>Столбец <code>possible_keys</code> указывает, который индекс MySQL
может использоваться, чтобы находить строки в этой таблице. Отметьте, что
этот столбец полностью независим от порядка таблиц, как выведено на экран в
выводе <a href="sql.htm#explain"><code>EXPLAIN</code></a>.
Это означает, что некоторые из ключей <code>possible_keys</code>
не могут быть применимы практически с произведенным табличным порядком.</p>

<p>Если этот столбец <code>NULL</code> (или неопределенный в JSON),
там нет релевантных индексов. В этом случае Вы можете быть в состоянии
улучшить исполнение своего запроса, исследуя <code>WHERE</code>, чтобы
проверить, обращается ли это к некоторому столбцу или столбцам, которые были
бы подходящими для того, чтобы индексировать. Если так, создайте
соответствующий индекс и проверьте запрос с
<a href="sql.htm#explain"><code>EXPLAIN</code></a>, см.
<a href="sql.htm#alter-table">раздел 14.1.7</a>.</p>
<p>Чтобы видеть все индексы таблицы, используйте
<code>SHOW INDEX FROM <em><code>tbl_name</code></em></code>.</li>

<li><a name="explain_key"></a>
<code>key</code> (Имя JSON: <code>key</code>)</p>
<p>Столбец <code>key</code> указывает ключ (индекс), который
MySQL фактически решил использовать. Если MySQL решает использовать один из
<code>possible_keys</code>, чтобы искать строки, индекс перечислен
как значение ключа.</p>

<p>Возможно, что <code>key</code> назовет индекс, который не присутствует в
<code>possible_keys</code>. Это может произойти, если ни один из
<code>possible_keys</code> не подходящий для того, чтобы искать строки, но
все столбцы, выбранные запросом, являются столбцами некоторого другого
индекса. Таким образом, названный индекс покрывает выбранные столбцы,
так что, хотя это не используется, чтобы определить, какие строки получить,
индексный просмотр более эффективен, чем просмотр строк данных.</p>

<p>Для <code>InnoDB</code> вторичный индекс мог бы
покрыть выбранные столбцы, даже если запрос также выбирает первичный ключ,
потому что <code>InnoDB</code> хранит значение первичного ключа в каждом
вторичном индексе. Если <code>key</code> = <code>NULL</code>, MySQL
не имеет индекса для того, чтобы выполнить запрос более эффективно.</p>

<p>Чтобы вынудить MySQL использовать или проигнорировать индекс
перечисленный в <code>possible_keys</code>, укажите в запросе <code>FORCE
INDEX</code>, <code>USE INDEX</code> или <code>IGNORE INDEX</code>, см.
<a href="#index-hints">раздел 9.9.4</a>.</p>

<p>Для <code>MyISAM</code> <a href="sql.htm#analyze-table"><code>ANALYZE
TABLE</code></a> помогает оптимизатору выбрать лучший индекс. Для
<code>MyISAM</code> <a href="programs.htm#myisamchk"><span><strong>myisamchk
--analyze</strong></span></a> делает то же самое. См. разделы
<a href="sql.htm#analyze-table">14.7.2.1</a> и
<a href="backup.htm#myisam-table-maintenance">8.6</a>.</li>

<li><a name="explain_key_len"></a>
<code>key_len</code> (Имя JSON: <code>key_length</code>)</p>
<p><code>key_len</code> указывает на длину ключа, который MySQL решил
использовать. Значение <code>key_len</code> позволяет Вам определить, сколько
частей ключа MySQL фактически использует. Если <code>key</code> = <code>NULL
</code>, <code>len_len</code> тоже <code>NULL</code>.</p>

<p>Из-за ключевого формата хранения, длина ключа
больше для столбца, который может быть <code>NULL</code>,
чем для <code>NOT NULL</code>.</li>

<li><a name="explain_ref"></a>
<code>ref</code> (Имя JSON: <code>ref</code>)</p>
<p><code>ref</code> показывает, которые столбцы или константы сравниваются с
индексом, названным в <code>key</code>, чтобы выбрать строки из таблицы.</p>

<p>Если значение равно <code>func</code>, используемое значение является
результатом некоторой функции. Чтобы видеть, которая это функция, надо
использовать <a href="#explain-extended"><code>EXPLAIN EXTENDED
</code></a> вместе с <a href="sql.htm#show-warnings"><code>SHOW WARNINGS
</code></a>. Функция могла бы фактически быть оператором, таким
как арифметический оператор.</li>

<li><a name="explain_rows"></a>
<code>rows</code> (Имя JSON: <code>rows</code>)</p>
<p><code>rows</code> указывает на число строк, которые MySQL должен
исследовать, чтобы выполнить запрос.</p>
<p>Для <a href="innodb.htm"><code>InnoDB</code></a> это число только
оценка и, возможно, всегда не точно.</li>

<li><a name="explain_filtered"></a>
<code>filtered</code> (Имя JSON: <code>filtered</code>)</p>
<p><code>filtered</code> указывает на предполагаемый процент строк таблицы,
которые будут фильтроваться по табличному условию. Таким образом,
<code>rows</code> показывает предполагаемое число исследованных строк, а
<code>rows</code> * <code>filtered</code>/<code>100</code> показывает
число строк, к которым присоединятся с предыдущими таблицами.</li>

<li><a name="explain_extra"></a>
<code>Extra</code> (Имя JSON: нет)</p>
<p>Этот столбец содержит дополнительную информацию о том, как MySQL решает
запрос. Для описания различных значений см.
<a href="#explain-extra-information">
<code>EXPLAIN</code>Extra Information</a>.</p>

<p>Нет никакого единственного свойства JSON, соответствующего
<code>Extra</code>, однако, значения, которые могут произойти в этом столбце,
выставлены как свойства JSON или как текст свойства <code>message</code>.
</p></li></ul>

<h4><a name="explain-join-types"></a>Типы соединения EXPLAIN</h4>
<p><code>type</code> <a href="sql.htm#explain"><code>EXPLAIN</code></a>
описывает, как присоединяются к таблицам. В формате JSON
они найдены как значения свойства <code>access_type</code>. Следующий список
описывает типы соединения, упорядоченные от лучшего типа до худшего:</p>

<ul><li><p><a name="jointype_system"></a>
<a href="#jointype_system"><code>system</code></a></p>
<p>У таблицы есть только одна строка (= системная таблица). Это особый случай
типа соединения <a href="#jointype_const"><code>const</code></a>.
</li>

<li><a name="jointype_const"></a>
<a href="#jointype_const"><code>const</code></a></p>
<p>У таблицы есть самое большее одна строка соответствия, которая считана
в начале запроса. Поскольку есть только одна строка, значения столбца в этой
строке могут быть расценены как константы остальной частью оптимизатора.
Таблицы <a href="#jointype_const"><code>const</code></a>
очень быстры, потому что они читаются только один раз.</p>

<p><a href="#jointype_const"><code>const</code></a>
используется, когда Вы сравниваете все части индекса <code>PRIMARY KEY</code>
или <code>UNIQUE</code> с постоянными величинами. В следующих запросах
<em><code>tbl_name</code></em> может использоваться в качестве таблицы
<a href="#jointype_const"><code>const</code></a>:
<pre>
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>primary_key</code></em>=1;
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>primary_key_part1</code></em>=1 AND
         <em><code>primary_key_part2</code></em>=2;
</pre></li>

<li><a name="jointype_eq_ref"></a>
<a href="#jointype_eq_ref"><code>eq_ref</code></a></p>
<p>Одна строка считана из этой таблицы для каждой комбинации строк от
предыдущих таблиц. Кроме типов
<a href="#jointype_system"><code>system</code></a> и
<a href="#jointype_const"><code>const</code></a>
это самый лучший тип соединения. Это используется, когда все части
индексирования используются соединением, и индексирование является индексом
<code>PRIMARY KEY</code> или <code>UNIQUE NOT NULL</code>.</p>

<p><a href="#jointype_eq_ref"><code>eq_ref</code></a>
может использоваться для индексированных столбцов, которые сравнены,
используя оператор <code>=</code>. Сравнительное значение может быть
константой или выражением, которое использует столбцы от таблиц, которые
считаны перед этой таблицей. В следующих примерах MySQL может использовать
соединение <a href="#jointype_eq_ref"><code>eq_ref</code></a>
для обработки <em><code>ref_table</code></em>:
<pre>
SELECT * FROM <em><code>ref_table</code></em>,<em><code>other_table</code></em>
         WHERE <em><code>ref_table</code></em>.<em><code>key_column</code></em>=
         <em><code>other_table</code></em>.<em><code>column</code></em>;

SELECT * FROM <em><code>ref_table</code></em>,<em><code>other_table</code></em>
         WHERE <em><code>ref_table</code></em>.<em><code>key_column_part1</code></em>=
         <em><code>other_table</code></em>.<em><code>column</code></em> AND
         <em><code>ref_table</code></em>.<em><code>key_column_part2</code></em>=1;
</pre></li>

<li><a name="jointype_ref"></a>
<a href="#jointype_ref"><code>ref</code></a></p>
<p>Все строки с соответствием индексу значения
считаны из этой таблицы для каждой комбинации строк от предыдущих таблиц.
<a href="#jointype_ref"><code>ref</code></a>
используется, если соединение использует только префикс
ключа или если ключ не индекс <code>PRIMARY KEY</code> или
<code>UNIQUE</code> (другими словами, если соединение не может выбрать
единственную строку, основанную на значении ключа). Если ключу, который
используется, соответствует только несколько строк, это
хороший тип соединения.</p>

<p><a href="#jointype_ref"><code>ref</code></a>
может использоваться для индексированных столбцов, которые сравнены,
используя <code>=</code> или <code>&lt;=&gt;</code>.
В следующих примерах MySQL может использовать соединение
<a href="#jointype_ref"><code>ref</code></a> для обработки
<em><code>ref_table</code></em>:
<pre>
SELECT * FROM <em><code>ref_table</code></em>
         WHERE <em><code>key_column</code></em>=<em><code>expr</code></em>;
SELECT * FROM <em><code>ref_table</code></em>,<em><code>other_table</code></em>
         WHERE <em><code>ref_table</code></em>.<em><code>key_column</code></em>=
         <em><code>other_table</code></em>.<em><code>column</code></em>;
SELECT * FROM <em><code>ref_table</code></em>,<em><code>other_table</code></em>
         WHERE <em><code>ref_table</code></em>.<em><code>key_column_part1</code>
         </em>=<em><code>other_table</code></em>.<em><code>column</code></em> AND
         <em><code>ref_table</code></em>.<em><code>key_column_part2</code></em>=1;
</pre></li>

<li><a name="jointype_fulltext"></a>
<a href="#jointype_fulltext"><code>fulltext</code></a></p>
<p>Соединение выполнено, используя индекс <code>FULLTEXT</code>.</li>

<li><a name="jointype_ref_or_null"></a>
<a href="#jointype_ref_or_null"><code>ref_or_null</code></a></p>
<p>Этот тип соединения похож на
<a href="#jointype_ref"><code>ref</code></a>,
но с дополнением, что MySQL делает дополнительный поиск строк, которые
содержат <code>NULL</code>. Эта оптимизация типа соединения используется чаще
всего в решении подзапросов. В следующих примерах MySQL может использовать
<a href="#jointype_ref_or_null"><code>ref_or_null</code></a>
для работы с <em><code>ref_table</code></em>:
<pre>
SELECT * FROM <em><code>ref_table</code></em>
         WHERE <em><code>key_column</code></em>=<em><code>expr</code></em> OR
         <em><code>key_column</code></em> IS NULL;
</pre>
<p>См. <a href="#is-null-optimization">раздел 9.2.1.8</a>.</li>

<li><a name="jointype_index_merge"></a>
<a href="#jointype_index_merge"><code>index_merge</code></a></p>
<p>Этот тип соединения указывает, что оптимизация Index Merge
используется. В этом случае <code>key</code> в выходной строке содержит
список используемых индексов, в <code>key_len</code>
содержит список самых длинных ключевых частей для используемого
индексирования. Для получения дополнительной информации см.
<a href="#index-merge-optimization">раздел 9.2.1.4</a>.</li>

<li><a name="jointype_unique_subquery"></a>
<a href="#jointype_unique_subquery"><code>unique_subquery</code>
</a></p>
<p>Этот тип заменяет <a href="#jointype_eq_ref">
<code>eq_ref</code></a> для некоторых подзапросов
for some <code>IN</code> следующей формы:
<pre>
<em><code>value</code></em> IN (SELECT <em><code>primary_key</code></em>
FROM <em><code>single_table</code></em> WHERE <em><code>some_expr</code></em>)
</pre>

<p><a href="#jointype_unique_subquery"><code>unique_subquery
</code></a> только индексная функция поиска, которая заменяет подзапрос
полностью для лучшей эффективности.</li>

<li><a name="jointype_index_subquery"></a>
<a href="#jointype_index_subquery"><code>index_subquery</code>
</a></p>
<p>Этот тип соединения подобен
<a href="#jointype_unique_subquery"><code>unique_subquery</code>
</a>. Заменяет подзапросы <code>IN</code>, но это работает на групповом
индексе в подзапросах следующей формы:
<pre>
<em><code>value</code></em> IN (SELECT <em><code>key_column</code></em>
FROM <em><code>single_table</code></em> WHERE <em><code>some_expr</code></em>)
</pre></li>

<li><a name="jointype_range"></a>
<a href="#jointype_range"><code>range</code></a></p>
<p>Только строки, которые находятся в данном диапазоне, получены,
используя индекс, чтобы выбрать строки. <code>key</code>
в выходной строке указывает, которые индексы используются.
<code>key_len</code> содержит самую длинную ключевую часть, которая
использовалась. <code>ref</code> = <code>NULL</code> для этого типа.</p>

<p><a href="#jointype_range"><code>range</code></a>
может использоваться, когда ключевой столбец сравнивается с постоянной с
использованием любого из операторов
<a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_not-equal"><code>&lt;&gt;</code></a>,
<a href="funct.htm#operator_greater-than"><code>&gt;</code></a>,
<a href="funct.htm#operator_greater-than-or-equal"><code>&gt;=</code></a>,
<a href="funct.htm#operator_less-than"><code>&lt;</code></a>,
<a href="funct.htm#operator_less-than-or-equal"><code>&lt;=</code></a>,
<a href="funct.htm#operator_is-null"><code>IS NULL</code></a>,
<a href="funct.htm#operator_equal-to"><code>&lt;=&gt;</code></a>,
<a href="funct.htm#operator_between"><code>BETWEEN</code></a> или
<a href="funct.htm#function_in"><code>IN()</code></a>:
<pre>
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>key_column</code></em> = 10;
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>key_column</code></em> BETWEEN 10 and 20;
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>key_column</code></em> IN (10,20,30);
SELECT * FROM <em><code>tbl_name</code></em>
         WHERE <em><code>key_part1</code></em> = 10 AND
         <em><code>key_part2</code></em> IN (10,20,30);
</pre></li>

<li><a name="jointype_index"></a>
<a href="#jointype_index"><code>index</code></a></p>
<p>Тип соединения <code>index</code> то же самое, как
<a href="#jointype_all"><code>ALL</code></a>
за исключением того, что индексное дерево просмотрено.
Это происходит двумя путями:</p>

<ul><li><p>Если индексирование является покрытием для запросов и
может использоваться, чтобы удовлетворить все данные, требуемые от таблицы,
только индексное дерево просмотрено. В этом случае столбец
<code>Extra</code> сообщает <code>Using index</code>.
Только индексированный просмотр обычно быстрее, чем
<a href="#jointype_all"><code>ALL</code></a>, поскольку
размер индексирования обычно меньше, чем табличные данные.</li>

<li>Полное сканирование таблицы выполнено, используя чтения
из индекса строк данных в индексном порядке. <code>Uses index</code>
не появляется в столбце <code>Extra</code>.</p></li></ul>
<p>MySQL может использовать этот тип соединения, когда запрос использует
только столбцы, которые являются частью одного индекса.</li>

<li><a name="jointype_all"></a>
<a href="#jointype_all"><code>ALL</code></a></p>
<p>Полное сканирование таблицы сделано для каждой комбинации строк от
предыдущих таблиц. Это обычно не хорошо, если таблица первая таблица,
не отмеченная как <a href="#jointype_const"><code>const</code>
</a> и обычно <span><em>очень плохо</em></span> во всех других случаях.
Обычно Вы можете избежать <a href="#jointype_all"><code>ALL</code>
</a> добавлением индексов, которые включают извлечение строки от таблицы,
основанной на постоянных величинах или значениях столбцов от
более ранних таблиц.</p></li></ul>

<h4><a name="explain-extra-information"></a>
Дополнительная информация EXPLAIN</h4>
<p>Столбец <code>Extra</code> в выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a>
содержит дополнительную информацию о том, как MySQL решает запрос. Следующий
список объясняет значения, которые могут появиться в этом столбце. Каждый
элемент также указывает для формата JSON, который выводит на экран свойство
<code>Extra</code>. Для некоторых из них есть определенное свойство. Другие
выводят на экран как текст свойства <code>message</code>.</p>

<p>Если Вы хотите сделать свои запросы с такой скоростью, как возможныо,
см. в <code>Extra</code> значения <code>Using
filesort</code> и <code>Using temporary</code> или для формата
JSON свойства <code>using_filesort</code> и
<code>using_temporary_table</code>, равные <code>true</code>.</p>

<ul><li><p><code>const row not found</code> (Свойство JSON:
<code>const_row_not_found</code>)</p>
<p>Для такого запроса, как <code>SELECT ... FROM <em><code>tbl_name</code>
</em></code>, таблица была пуста.</li>

<li><code>Deleting all rows</code> (Свойство JSON: <code>message</code>)</p>
<p>Для <a href="sql.htm#delete"><code>DELETE</code></a> некоторые механизмы
хранения, например, <a href="storage.htm#myisam-storage-engine"><code>MyISAM
</code></a> поддерживают метод обработчика, который удаляет все строки
таблицы простым и быстрым способом. Это значение <code>Extra</code>
выведено на экран, если механизм использует эту оптимизацию.</li>

<li><code>Distinct</code> (Свойство JSON: <code>distinct</code>)</p>
<p>MySQL ищет отличные значения, таким образом, он прекращает искать больше
строк для текущей комбинации строки после того, как только он нашел
первую строку соответствия.</li>

<li><code>FirstMatch(<em><code>tbl_name</code></em>)</code>
(Свойство JSON: <code>first_match</code>)</p>
<p>Полусоединение FirstMatch к сокращенной стратегии, используется для
<em><code>tbl_name</code></em>.</li>

<li><code>Full scan on NULL key</code> (Свойство JSON: <code>message</code>)
</p>
<p>Это происходит для оптимизации подзапроса как стратегия отступления,
когда оптимизатор не может использовать метод доступа поиска по индексу.</li>

<li><code>Impossible HAVING</code> (Свойство JSON: <code>message</code>)</p>
<p><code>HAVING</code> всегда false и не может выбрать строки.</li>
<li><code>Impossible WHERE</code> (Свойство JSON: <code>message</code>)</p>
<p><code>WHERE</code> всегда false и не может выбрать строки.</li>

<li><code>Impossible WHERE noticed after reading const tables</code>
(Свойство JSON: <code>message</code>)</p>
<p>MySQL считал все таблицы
<a href="#jointype_const"><code>const</code></a>
(и <a href="#jointype_system"><code>system</code></a>)
и уведомляет, что <code>WHERE</code> всегда ложен.</li>

<li><code>LooseScan(<em><code>m</code></em>..<em><code>n</code></em>)</code>
(Свойство JSON: <code>message</code>)</p>
<p>Стратегия LooseScan используется. <em><code>m</code></em> и
<em><code>n</code></em> номера частей ключа.</li>

<li><code>No matching min/max row</code> (Свойство JSON: <code>message
</code>)</p>
<p>Никакая строка не удовлетворяет условие для такого запроса, как
<code>SELECT MIN(...) FROM ... WHERE <em><code>condition</code></em></code>.
</li>

<li><code>no matching row in const table</code> (Свойство JSON:
<code>message</code>)</p>
<p>Для запроса с соединением была пустая таблица, или таблица без строк,
удовлетворяющих уникальное индексное условие.</li>

<li><code>No matching rows after partition pruning</code>
(Свойство JSON: <code>message</code>)</p>
<p>Для <a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>
оптимизатор не нашел ничего для удаления или обновления после сокращения
разделения. Это подобно значению <code>Impossible WHERE</code>
для <a href="sql.htm#select"><code>SELECT</code></a>.</li>

<li><code>No tables used</code> (Свойство JSON: <code>message</code>)</p>
<p>Запрос не имеет <code>FROM</code> или имеет <code>FROM DUAL</code>.</p>
<p>Для <a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#replace"><code>REPLACE</code></a>
<a href="sql.htm#explain"><code>EXPLAIN</code></a> покажет это значение,
когда нет части <a href="sql.htm#select"><code>SELECT</code></a>.
Например, это появляется для <code>EXPLAIN INSERT INTO t VALUES(10)</code>,
потому что это эквивалентно <code>EXPLAIN INSERT INTO t SELECT 10 FROM DUAL
</code>.</li>

<li><code>Not exists</code> (Свойство JSON: <code>message</code>)</p>
<p>MySQL смог сделать оптимизацию <code>LEFT JOIN</code>
на запросе и не исследует больше строк в этой таблице для предыдущей
комбинации строки после того, как это находит одну строку, которая
соответствует <code>LEFT JOIN</code>. Вот пример типа запроса, который может
быть оптимизирован так:
<pre>
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id
         WHERE t2.id IS NULL;
</pre>

<p>Предположим, <code>t2.id</code> определен как <code>NOT NULL</code>.
В этом случае MySQL просмотрит <code>t1</code> и ищет строки в
<code>t2</code>, используя <code>t1.id</code>.
Если MySQL находит соответствующую строку в <code>t2</code>,
это знает, что <code>t2.id</code> никогда не может быть <code>NULL</code>
и не просматривает через остальную часть строк в <code>t2</code>,
у которых есть тот же самый <code>id</code>. Другими словами, для каждой
строки в <code>t1</code> MySQL MySQL должен сделать только единственный
поиск в <code>t2</code> независимо от того, сколько строк фактически
соответствуют в <code>t2</code>.</li>

<li><code>Plan isn't ready yet</code> (Свойство JSON: нет)</p>
<p>Это значение происходит с <a href="#explain-for-connection">
<code>EXPLAIN FOR CONNECTION</code></a>, когда оптимизатор не закончил
создавать план выполнения относительно запроса в названном соединении.
Если вывод плана выполнения включает многократные строки, у любых из них
могло бы быть это значение <code>Extra</code>, в зависимости от продвижения
оптимизатора в определении полного плана выполнения.</li>

<li><code>Range checked for each record (index map:
<em><code>N</code></em>)</code> (Свойство JSON: <code>message</code>)</p>
<p>MySQL не нашел хороший индекс, но нашел, что часть из индексов могла бы
использоваться после того, как значения столбцов от предыдущих таблиц будут
известны. Для каждой комбинации строк в предыдущих таблицах MySQL проверяет,
возможно ли использовать метод доступа
<a href="#jointype_range"><code>range</code></a> или
<a href="#jointype_index_merge"><code>index_merge</code></a>,
чтобы получить строки. Это не очень быстро, но быстрее, чем выполнение
соединения без индексов вообще. Критерии применимости описаны в разделах
<a href="#range-optimization">9.2.1.3</a> и
<a href="#index-merge-optimization">9.2.1.4</a>
за исключением того, что все значения столбцов для предыдущей таблицы
известны и, как полагают, константы.</p>

<p>Индексы пронумерованы, начиная с 1, в том же самом порядке, как показано
<a href="sql.htm#show-index"><code>SHOW INDEX</code></a> для таблицы.
Значение индексной карты <em><code>N</code></em> это значение битовой маски,
которое указывает, который индекс кандидат. Например, значение
<code>0x19</code> (двоичное 11001) означает, что рассмотрят индексы 1, 4 и 5.
</li>

<li><code>Scanned <em><code>N</code></em>
databases</code> (Свойство JSON: <code>message</code>)</p>
<p>Это указывает, сколько просмотров каталога сервер выполняет, обрабатывая
запрос для таблиц <code>INFORMATION_SCHEMA</code>, см.
<a href="#information-schema-optimization">раздел 9.2.4</a>.
Значение <em><code>N</code></em> может быть 0, 1 или <code>all</code>.</li>

<li><code>Select tables optimized away</code> (Свойство JSON: <code>message
</code>)</p>
<p>Оптимизатор решил, что: 1) самое большее одна строка должна быть
возвращена, и 2) чтобы произвести эту строку, детерминированный набор строк
должен быть считан. Когда строки, которые будут считаны, могут быть считаны
во время фазы оптимизации (например, чтением индекса строк), нет никакой
потребности читать любые таблицы во время выполнения запроса.</p>

<p>Первое условие выполнено, когда запрос неявно сгруппирован
(содержит совокупную функцию, но нет <code>GROUP BY</code>).
Второе условие выполнено, когда один поиск строки выполнен на применение
индекса. Число прочитанных индексов определяет число строк, чтобы читать.</p>

<p>Рассмотрите следующий неявно сгруппированный запрос:
<pre>
SELECT MIN(c1), MIN(c2) FROM t1;
</pre>

<p>Предположите, что <code>MIN(c1)</code> может быть получен, читая одну
строку индекса и <code>MIN(c2)</code> может быть получен, читая одну строку
из другого индекса. Таким образом, для каждого столбца <code>c1</code> и
<code>c2</code> там существует индекс, где столбец это первый столбец
индекса. В этом случае одна строка возвращена (и произведена), читая
две детерминированных строки.</p>

<p>Это значение <code>Extra</code> не происходит, если строки для чтения не
детерминированы. Рассмотрите этот запрос:
<pre>
SELECT MIN(c2) FROM t1 WHERE c1 &lt;= 10;
</pre>

<p>Допустим, <code>(c1, c2)</code> покрывающий индекс. Используя этот индекс,
все строки с <code>c1 &lt;= 10</code> должны быть просмотрены, чтобы найти
минимум <code>c2</code>. В отличие от этого, рассмотрите этот запрос:
<pre>
SELECT MIN(c2) FROM t1 WHERE c1 = 10;
</pre>

<p>В этом случае первая индексная строка с <code>c1 = 10</code>
содержит минимум <code>c2</code>. Только одна строка должна быть считана,
чтобы произвести возвращенную строку.</p>

<p>Для механизмов хранения, которые поддерживают точное количество строк на
таблицу (такой как <code>MyISAM</code>, но не <code>InnoDB</code>), это
значение <code>Extra</code> может произойти для запросов
<code>COUNT(*)</code>, для которых <code>WHERE</code>
отсутствует или всегда истина и нет <code>GROUP BY</code>.
Это случай неявно сгруппированного запроса, где механизм хранения влияет на
то, может ли быть считано детерминированное число строк.</li>

<li><code>Skip_open_table</code>, <code>Open_frm_only</code>,
<code>Open_full_table</code> (Свойство JSON: <code>message</code>)</p>
<p>Эти значения указывают на открывающую файл оптимизацию, которая относится
к запросам к таблицам <code>INFORMATION_SCHEMA</code>.</p>

<ul><li><p><code>Skip_open_table</code>: Табличные файлы не должны быть
открыты. Информация уже доступна из словаря данных.</li>
<li><code>Open_frm_only</code>: Только словарь данных должен быть считан
для информации о таблице.</li>

<li><code>Open_full_table</code>: Неоптимизированный информационный поиск.
Информация о таблице должна быть считана из словаря данных и
читая табличные файлы.</p></li></ul></li>

<li><code>Start temporary</code>, <code>End temporary</code> (Свойство JSON:
<code>message</code>)</p>
<p>Это указывает на временное табличное использование для
стратегии Duplicate Weedout.</li>

<li><code>unique row not found</code> (Свойство JSON: <code>message</code>)
</p>
<p>Для такого запроса, как <code>SELECT ... FROM
<em><code>tbl_name</code></em></code>, никакие строки не удовлетворяют
условию для индекса <code>UNIQUE</code> или <code>PRIMARY
KEY</code> на таблице.</li>

<li><code>Using filesort</code> (Свойство JSON: <code>using_filesort</code>)
</p>
<p>MySQL должен сделать дополнительный проход, чтобы узнать, как получить
строки в сортированном порядке. Сортировка сделана, проходя все строки,
согласно типу соединения и храня ключ сортировки
и указатель на строку для всех строк, которые соответствуют
<code>WHERE</code>. Ключи тогда отсортированы, и строки получены в
сортированном порядке. См. <a href="#order-by-optimization">раздел
9.2.1.15</a>.</li>

<li><code>Using index</code> (Свойство JSON: <code>using_index</code>)</p>
<p>Информация о столбце получена от таблицы, используя только информацию в
индексном дереве, не имея необходимости делать дополнительный поиск, чтобы
читать фактическую строку. Эта стратегия может использоваться, когда запрос
использует только столбцы, которые являются частью одного индекса.</p>

<p>Для <code>InnoDB</code> с определяемым пользователем кластеризуемым
индексом могут использоваться, даже когда <code>Using index</code>
отсутствует в столбце <code>Extra</code>. Дело обстоит так, если
<code>type</code> = <a href="#jointype_index"><code>index</code>
</a>, а <code>key</code> = <code>PRIMARY</code>.</li>

<li><code>Using index condition</code> (Свойство JSON:
<code>using_index_condition</code>)</p>
<p>Таблицы считаны доступом к индексным кортежам и проводится тестирование их
сначала, чтобы определить, читать ли полные строки таблицы. Таким образом,
индексная информация используется, чтобы задержать (<span><span>push
down</span></span>) чтение полных строк таблицы, если это не необходимо. См.
<a href="#index-condition-pushdown-optimization">раздел 9.2.1.6
</a>.</li>

<li><code>Using index for group-by</code> (Свойство JSON:
<code>using_index_for_group_by</code>)</p>
<p>Подобно методу доступа <code>Using index</code>,
<code>Using index for group-by</code> указывает, что MySQL нашел индекс,
который может использоваться, чтобы получить все столбцы запроса
<code>GROUP BY</code> или <code>DISTINCT</code>
без любого дополнительного дискового доступа к фактической таблице.
Дополнительно, индексирование используется самым эффективным способом так,
чтобы для каждой группы были считаны только некоторые индексные записи.
Для деталей см. <a href="#group-by-optimization">раздел 9.2.1.16
</a>.</li>

<li><code>Using join buffer (Block Nested Loop)</code>,
<code>Using join buffer (Batched Key Access)</code>
(Свойство JSON: <code>using_join_buffer</code>)</p>
<p>Таблицы от более ранних соединений считаны
в буфер соединения, а затем их строки используются, чтобы выполнить
соединение с текущей таблицей. <code>(Block Nested Loop)</code>
указывает на использование алгоритма Block Nested-Loop и <code>(Batched Key
Access)</code> указывает на использование алгоритма Batched Key Access.
Таким образом, ключи от таблицы на предыдущей строке вывода
<a href="sql.htm#explain"><code>EXPLAIN</code></a>
будут буферизованы, и соответствующие строки будут принесены в пакетах от
таблицы, представленной строкой, в которой появляется
<code>Using join buffer</code>.</p>

<p>В JSON-отформатированном выводе значение
<code>using_join_buffer</code> всегда
<code>Block Nested Loop</code> или <code>Batched Key Access</code>.</li>

<li><code>Using MRR</code> (Свойство JSON: <code>message</code>)</p>
<p>Таблицы считаны, используя стратегию оптимизации Multi-Range Read, см.
<a href="#mrr-optimization">раздел 9.2.1.13</a>.</li>

<li><code>Using sort_union(...)</code>, <code>Using union(...)</code>,
<code>Using intersect(...)</code> (Свойство JSON: <code>message</code>)</p>
<p>Они указывают, как индексные просмотры слиты для типа соединения
<a href="#jointype_index_merge"><code>index_merge</code></a>.
См. <a href="#index-merge-optimization">раздел 9.2.1.4</a>.</li>

<li><code>Using temporary</code> (Свойство JSON:
<code>using_temporary_table</code>)</p>
<p>Чтобы решить запрос, MySQL должен составить временную таблицу, чтобы
держать результат. Это как правило происходит, если запрос содержит
<code>GROUP BY</code> и <code>ORDER BY</code>.</li>

<li><code>Using where</code> (Свойство JSON:
<code>attached_condition</code>)</p>
<p><code>WHERE</code> используется, чтобы ограничить, которые строки
соответствуют следующей таблице или посланы клиенту. Если Вы определенно не
намереваетесь принести или исследовать все строки от таблицы, у Вас может
быть что-то не так в Вашем запросе, если <code>Extra</code> не <code>Using
where</code> и табличный тип соединения
<a href="#jointype_all"><code>ALL</code></a> или
<a href="#jointype_index"><code>index</code></a>.</p>

<p><code>Using where</code> не имеет никакой прямой копии в
JSON-отформатированном выводе, свойство <code>attached_condition</code>
содержит любые условия <code>WHERE</code>.</li>

<li><code>Using where with pushed condition</code> (JSON
property: <code>message</code>)</p>
<p>Этот элемент относится <span><em>только</em></span> к
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>. Это означает, что MySQL Cluster
использует оптимизацию Condition Pushdown, чтобы улучшить эффективность
прямого сравнения между неиндексированным столбцом и константой. В таких
случаях условие <span><span>продвинуто вниз</span></span> узлам данных
кластера и оценено на всех узлах данных одновременно. Это избавляет от
необходимости посылать несоответствие строк по сети, и может ускорить такие
запросы в 5-10 раз. Для получения дополнительной информации см.
<a href="#condition-pushdown-optimization">раздел 9.2.1.5</a>.
</li>

<li><code>Zero limit</code> (Свойство JSON: <code>message</code>)</p>
<p>У запроса был <code>LIMIT 0</code>, невозможно выбрать строки.
</p></li></ul>

<h4><a name="explain-output-interpretation"></a>
Выходная интерпретация EXPLAIN</h4>
<p>Вы можете получить хороший признак того, насколько хорошо соединение,
принимая произведение значений в столбце <code>rows</code> вывода
<a href="sql.htm#explain"><code>EXPLAIN</code></a>. Это должно сказать Вам
примерно, сколько строк MySQL должен исследовать, чтобы выполнить запрос.
Если Вы ограничиваете запросы через
<a href="server.htm#sysvar_max_join_size"><code>max_join_size</code></a>,
это также используется, чтобы определить, который мультитабличный
<a href="sql.htm#select"><code>SELECT</code></a> выполнять. См.
<a href="server.htm#server-configuration">раздел 6.1.1</a>.</p>

<p>Следующий пример показывает, как многотабличное соединение может быть
оптимизировано прогрессивно, основываясь на информации, предоставленной
<a href="sql.htm#explain"><code>EXPLAIN</code></a>.</p>

<p>Предположите, что Вы имеете
<a href="sql.htm#select"><code>SELECT</code></a>, показанный здесь, и что Вы
планируете исследовать это с использованием
<a href="sql.htm#explain"><code>EXPLAIN</code></a>:
<pre>
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn, tt.ProjectReference,
        tt.EstimatedShipDate, tt.ActualShipDate, tt.ClientID,
        tt.ServiceCodes, tt.RepetitiveID, tt.CurrentProcess,
        tt.CurrentDPPerson, tt.RecordVolume, tt.DPPrinted, et.COUNTRY,
        et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do WHERE tt.SubmitTime IS NULL AND
        tt.ActualPC = et.EMPLOYID AND tt.AssignedPC = et_1.EMPLOYID AND
        tt.ClientID = do.CUSTNMBR;
</pre>

<p>Для этого примера, сделайте следующие предположения:</p>
<ul><li><p>Сравниваемые столбцы были объявлены следующим образом.</p>
<table border="1">
<thead><tr><th scope="col">Таблица</th><th scope="col">Столбец</th>
<th scope="col">Тип данных</th></tr></thead>
<tbody><tr><td scope="row"><code>tt</code></td><td><code>ActualPC</code></td>
<td><code>CHAR(10)</code></td></tr>
<tr><td scope="row"><code>tt</code></td><td><code>AssignedPC</code></td>
<td><code>CHAR(10)</code></td></tr>
<tr><td scope="row"><code>tt</code></td><td><code>ClientID</code></td>
<td><code>CHAR(10)</code></td></tr>
<tr><td scope="row"><code>et</code></td><td><code>EMPLOYID</code></td>
<td><code>CHAR(15)</code></td></tr>
<tr><td scope="row"><code>do</code></td><td><code>CUSTNMBR</code></td>
<td><code>CHAR(15)</code></td></tr></tbody></table></li>

<li>У таблиц есть следующие индексы.</p>
<table border="1">
<thead><tr><th scope="col">Таблица</th><th scope="col">Индекс</th>
</tr></thead>
<tbody><tr><td scope="row"><code>tt</code></td><td><code>ActualPC</code>
</td></tr>
<tr><td scope="row"><code>tt</code></td><td><code>AssignedPC</code></td></tr>
<tr><td scope="row"><code>tt</code></td><td><code>ClientID</code></td></tr>
<tr><td scope="row"><code>et</code></td><td><code>EMPLOYID</code>
(primary key)</td></tr>
<tr><td scope="row"><code>do</code></td><td><code>CUSTNMBR</code>
(primary key)</td></tr></tbody></table></li>
<li>Значения <code>tt.ActualPC</code> равномерно не распределены.
</p></li></ul>

<p>Первоначально, прежде, чем любая оптимизация была выполнена,
<a href="sql.htm#explain"><code>EXPLAIN</code></a>
производит следующую информацию:
<pre>
table type possible_keys key  key_len ref  rows  Extra
et    ALL  PRIMARY       NULL NULL    NULL 74
do    ALL  PRIMARY       NULL NULL    NULL 2135
et_1  ALL  PRIMARY       NULL NULL    NULL 74
tt    ALL  AssignedPC,   NULL NULL    NULL 3872
           ClientID,
           ActualPC
Range checked for each record (index map: 0x23)
</pre>

<p>Так как <code>type</code> = <a href="#jointype_all"><code>ALL
</code></a> для каждой таблицы этот вывод указывает, что MySQL производит
декартово произведение всех таблиц, то есть, каждой комбинация строк. Это
занимает длительное время, потому что произведение числа строк в каждой
таблице должно быть исследовано. Для данного случая это 74*2135*74*3872=
45268558720 строк. Если бы таблицы были больше, Вы можете только вообразить,
сколько времени это заняло бы...</p>

<p>Одна проблема здесь состоит в том, что MySQL может использовать индекс
на столбцах более эффективно, если они объявлены как тот же самый тип и
размер. В этом контексте <a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#char"><code>CHAR</code></a>
считаются тем же самым, если они объявлены как тот же самый размер.
<code>tt.ActualPC</code> объявлен как
<code>CHAR(10)</code> и <code>et.EMPLOYID</code> как <code>CHAR(15)</code>,
таким образом, есть несоответствие длины.</p>

<p>Чтобы устранить это неравенство между длинами столбца, надо использовать
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> и удлинить
<code>ActualPC</code> с 10 символов до 15:
<pre>
mysql&gt; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
</pre>

<p>Теперь <code>tt.ActualPC</code> и <code>et.EMPLOYID</code> оба
<code>VARCHAR(15)</code>. Выполнение
<a href="sql.htm#explain"><code>EXPLAIN</code></a>
приводит к этому результату:
<pre>
table type   possible_keys key     key_len ref         rows Extra
tt    ALL    AssignedPC,   NULL    NULL    NULL        3872 Using
             ClientID,                                      where
             ActualPC
do    ALL    PRIMARY       NULL    NULL    NULL        2135
Range checked for each record (index map: 0x1)
et_1  ALL    PRIMARY       NULL    NULL    NULL        74
Range checked for each record (index map: 0x1)
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC 1
</pre>

<p>Это не прекрасно, но намного лучше: произведение значений
<code>rows</code> меньше в 74 раза. Эта версия выполняется за пару секунд.
</p>
<p>Второе изменение может быть сделано, чтобы устранить несоответствия длины
столбца для <code>tt.AssignedPC = et_1.EMPLOYID</code> и
<code>tt.ClientID = do.CUSTNMBR</code>:
<pre>
mysql&gt; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
    -&gt;       MODIFY ClientID   VARCHAR(15);
</pre>

<p>После этой модификации <a href="sql.htm#explain"><code>EXPLAIN</code></a>
производит вывод, показанный здесь:
<pre>
table type   possible_keys key      key_len ref           rows Extra
et    ALL    PRIMARY       NULL     NULL    NULL          74
tt    ref    AssignedPC,   ActualPC 15      et.EMPLOYID   52   Using
             ClientID,                                         where
             ActualPC
et_1  eq_ref PRIMARY       PRIMARY  15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY  15      tt.ClientID   1
</pre>

<p>В этом пункте запрос оптимизирован почти так, как возможно. Остающаяся
проблема состоит в том, что по умолчанию MySQL предполагает, что значения в
<code>tt.ActualPC</code> равномерно распределены, но дело обстоит не так для
<code>tt</code>. К счастью, легко сказать MySQL
анализировать ключевое распределение:
<pre>
mysql&gt; ANALYZE TABLE tt;
</pre>

<p>С дополнительной индексной информацией соединение прекрасно и
<a href="sql.htm#explain"><code>EXPLAIN</code></a>
приводит к этому результату:
<pre>
table type   possible_keys key     key_len ref           rows Extra
tt    ALL    AssignedPC    NULL    NULL    NULL          3872 Using where
             ClientID,
             ActualPC
et    eq_ref PRIMARY       PRIMARY 15      tt.ActualPC   1
et_1  eq_ref PRIMARY       PRIMARY 15      tt.AssignedPC 1
do    eq_ref PRIMARY       PRIMARY 15      tt.ClientID   1
</pre>

<p>Столбец <code>rows</code> в выводе <a href="sql.htm#explain"><code>EXPLAIN
</code></a> образован предположением от оптимизатора соединения MySQL.
Проверьте, являются ли числа близко к правде, сравнивая произведение
<code>rows</code> с фактическим числом строк, которые возвращает запрос. Если
числа очень отличаются, Вы могли бы получить лучшую работу при использовании
<code>STRAIGHT_JOIN</code> в <a href="sql.htm#select"><code>SELECT</code></a>
и пытаясь перечислить таблицы в различном порядке в
<code>FROM</code>. Но <code>STRAIGHT_JOIN</code> может блокировать
использование индексов, потому что это отключает преобразования
полусоединения. См. <a href="#semi-joins">раздел 9.2.1.18.1</a>.
</p>

<p>Возможно в некоторых случаях выполнить запросы, которые изменяют данные,
когда <a href="sql.htm#explain"><code>EXPLAIN SELECT</code></a>
используется с подзапросом, для получения дополнительной информации см.
<a href="sql.htm#from-clause-subqueries">раздел 14.2.10.8</a>.</p>

<h3><a name="explain-extended"></a>9.8.3. Формат вывода EXPLAIN EXTENDED</h3>
<p>Когда <a href="sql.htm#explain"><code>EXPLAIN</code></a> используется с
<code>EXTENDED</code>, вывод включает столбец <code>filtered</code>.
Этот столбец указывает на предполагаемый процент строк таблицы, которые будут
фильтроваться по табличному условию. Кроме того, запрос производит
дополнительную информацию, которая может быть просмотрена через
<a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a> после
<a href="sql.htm#explain"><code>EXPLAIN</code></a>. Значение
<code>Message</code> в выводе <a href="sql.htm#show-warnings"><code>SHOW
WARNINGS</code></a> выводит на экран, как оптимизатор квалифицирует имена
таблиц и имена столбцов в <a href="sql.htm#select"><code>SELECT</code></a>,
на что <a href="sql.htm#select"><code>SELECT</code></a>
похож после применения правил перезаписи и оптимизации, и возможно другие
примечания о процессе оптимизации.</p>

<p>С MySQL 5.7.3 <a href="sql.htm#explain"><code>EXPLAIN</code></a>
изменено так, что эффект <code>EXTENDED</code> всегда включается.
Параметр <code>EXTENDED</code> все еще признан, но лишний и устарел.
Это будет удалено из <a href="sql.htm#explain"><code>EXPLAIN</code></a>
в будущем выпуске MySQL.</p>

<p>Вот пример расширенного вывода:
<pre>
mysql&gt; EXPLAIN EXTENDED SELECT t1.a, t1.a IN
    -&gt;         (SELECT t2.a FROM t2) FROM t1\G
*************************** 1. row ***************************
 id: 1
  select_type: PRIMARY
table: t1
 type: index
possible_keys: NULL
key: PRIMARY
key_len: 4
ref: NULL
 rows: 4
 filtered: 100.00
Extra: Using index
*************************** 2. row ***************************
 id: 2
  select_type: SUBQUERY
table: t2
 type: index
possible_keys: a
key: a
key_len: 5
ref: NULL
 rows: 3
 filtered: 100.00
Extra: Using index
2 rows in set, 1 warning (0.00 sec)

mysql&gt; SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `test`.`t1`.`a` AS `a`,
 &lt;in_optimizer&gt;(`test`.`t1`.`a`,`test`.`t1`.`a` in
 ( &lt;materialize&gt; (/* select#2 */ select `test`.`t2`.`a`
 from `test`.`t2` where 1 having 1 ),
 &lt;primary_index_lookup&gt;(`test`.`t1`.`a` in
 &lt;temporary table&gt; on &lt;auto_key&gt;
 where ((`test`.`t1`.`a` = `materialized-subquery`.`a`))))) AS `t1.a
 IN (SELECT t2.a FROM t2)` from `test`.`t1`
1 row in set (0.00 sec)
</pre>

<p><a href="sql.htm#explain"><code>EXPLAIN EXTENDED</code></a>
может использоваться с <a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#replace"><code>REPLACE</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>. Однако, следующий
<a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a>
выводит на экран непустой результат только для
<a href="sql.htm#select"><code>SELECT</code></a>.</p>

<p>Поскольку запрос, выведенный на экран <a href="sql.htm#show-warnings">
<code>SHOW WARNINGS</code></a>, может содержать специальные маркеры, чтобы
предоставить информацию о перезаписи запроса или действиях оптимизатора,
запрос не обязательно допустимый SQL и не предназначен, чтобы быть
выполненным. Вывод может также включать строки с <code>Message</code>,
который обеспечивает дополнительные не-SQL примечания о
мерах, предпринятых оптимизатором.</p>

<p>Следующий список описывает специальные маркеры, которые могут появиться в
выводе <code>EXTENDED</code> и <a href="sql.htm#show-warnings"><code>SHOW
WARNINGS</code></a>:</p>

<ul><li><p><code>&lt;auto_key&gt;</code></p>
<p>Автоматически произведенный ключ для временной таблицы.</li>
<li><code>&lt;cache&gt;(<em><code>expr</code></em>)</code></p>
<p>Выражение (такое как скалярный подзапрос) выполнено однажды, и
получающееся значение сохранено в памяти для более позднего использования.
Для результатов, состоящих из многократных значений, может быть составлена
временная таблица, и Вы будете видеть <code>&lt;temporary table&gt;</code>.
</li>

<li><code>&lt;exists&gt;(<em><code>query fragment</code></em>)</code></p>
<p>Предикат подзапроса преобразован в предикат <code>EXISTS</code>
и подзапрос преобразован так, чтобы это могло использоваться
вместе с предикатом <code>EXISTS</code>.</li>

<li><code>&lt;in_optimizer&gt;(<em><code>query fragment</code></em>)</code>
</p>
<p>Это внутренний объект оптимизатора без пользовательского значения.</li>
<li><code>&lt;index_lookup&gt;(<em><code>query fragment</code></em>)</code>
</p>
<p>Фрагмент запроса обработан, используя индексный
поиск, чтобы найти готовящиеся строки.</li>

<li><code>&lt;if&gt;(<em><code>condition</code></em>,
<em><code>expr1</code></em>, <em><code>expr2</code></em>)</code></p>
<p>Если условие истина, оценить к <em><code>expr1</code></em>, иначе к
<em><code>expr2</code></em>.</li>

<li><code>&lt;is_not_null_test&gt;(<em><code>expr</code></em>)</code></p>
<p>Тест, чтобы проверить, что выражение не оценивается к <code>NULL</code>.
</li>

<li><code>&lt;materialize&gt;(<em><code>query fragment</code></em>)</code>
</p>
<p>Материализация подзапроса используется.</li>
<li><code>`materialized-subquery`.<em><code>col_name</code></em></code></p>
<p>Ссылка на столбец <em><code>col_name</code></em> во внутренней временной
таблице, осуществленной, чтобы держать следствие оценки подзапроса.</li>

<li><code>&lt;primary_index_lookup&gt;(<em><code>query fragment</code></em>)
</code></p>
<p>Фрагмент запроса обработан, используя поиск первичного ключа,
чтобы найти готовящиеся строки.</li>

<li><code>&lt;ref_null_helper&gt;(<em><code>expr</code></em>)</code></p>
<p>Это внутренний объект оптимизатора без пользовательского значения.</li>
<li><code>/* select#<em><code>N</code></em> */
<em><code>select_stmt</code></em></code></p>
<p><code>SELECT</code> связан со строкой в не-<code>EXTENDED</code> выводе
<a href="sql.htm#explain"><code>EXPLAIN</code></a>, который имеет
<code>id</code> <em><code>N</code></em>.</li>

<li><code><em><code>outer_tables</code></em> semi join
(<em><code>inner_tables</code></em>)</code></p>

<p>Работа полусоединения. <em><code>inner_tables</code></em>
показывает таблицы, которые не были вытащены. См.
<a href="#semi-joins">раздел 9.2.1.18.1</a>.</li>

<li><code>&lt;temporary table&gt;</code></p>
<p>Это представляет внутреннюю временную таблицу, составленную, чтобы
кэшировать промежуточный результат.</p></li></ul>

<p>Когда некоторые таблицы имеют тип
<a href="#jointype_const"><code>const</code></a> или
<a href="#jointype_system"><code>system</code></a>,
столбцы вовлечения выражений от этих таблиц оценены оптимизатором рано и
не являются частью выведенного на экран запроса. Однако, с
<code>FORMAT=JSON</code> некоторые табличные доступы
<a href="#jointype_const"><code>const</code></a>
выведены на экран как <a href="#jointype_ref"><code>ref</code>
</a>, который использует значение константы.</p>

<h3><a name="explain-for-connection"></a>9.8.4.
Получение информации о плане выполнения для названного соединения</h3>
<p>Чтобы получить план выполнения относительно объяснимого выполнения запроса
в названном соединении, используйте это запрос:
<pre>
EXPLAIN [<em><code>options</code></em>] FOR CONNECTION <em><code>connection_id</code></em>;
</pre>

<p><a href="#explain-for-connection"><code>EXPLAIN FOR CONNECTION
</code></a> вернет данные <a href="sql.htm#explain"><code>EXPLAIN</code></a>,
которые в настоящее время используются, чтобы выполнить запрос в данном
соединении. Из-за изменений данных (и статистики) это может произвести
различное следствие выполнения <a href="sql.htm#explain"><code>EXPLAIN</code>
</a> на эквивалентном тексте запроса. Это различие в поведении может быть
полезным в диагностировании большего количества переходных исполнительных
проблем. Например, если Вы выполняете запрос в одном сеансе, который занимает
много времени, чтобы завершиться, использование
<a href="#explain-for-connection"><code>EXPLAIN FOR CONNECTION
</code></a> в другом сеансе может привести к полезной
информации о причине задержки.</p>

<p><em><code>connection_id</code></em> это идентификатор соединения, как
получено из таблицы <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a>
или из вывода <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a>. Если есть привилегия
<a href="security.html#priv_process"><code>PROCESS</code></a>,
Вы можете определить идентификатор для любого соединения. Иначе Вы можете
определить идентификатор только для Ваших собственных соединений.</p>

<p>Если названное соединение не выполняет запрос, результат пуст. Иначе
<code>EXPLAIN FOR CONNECTION</code> применяется только, если запрос,
выполняемый в названном соединении, объясним. Это включает
<a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#replace"><code>REPLACE</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>.
Но <code>EXPLAIN FOR CONNECTION</code> не работает на готовых запросах, даже
подготовленных запросах тех типов.</p>

<p>Если названное соединение выполняет объяснимый запрос,
вывод состоит в том, при использовании чего Вы получили бы
<code>EXPLAIN</code> на запрос непосредственно.</p>

<p>Если названное соединение выполняет запрос, который не объясним,
ошибка происходит. Например, Вы не можете назвать идентификатор соединения
для своего текущего сеанса, потому что <code>EXPLAIN</code> не объясним:
<pre>
mysql&gt; SELECT CONNECTION_ID();
+-----------------+
| CONNECTION_ID() |
+-----------------+
| 373             |
+-----------------+
1 row in set (0.00 sec)

mysql&gt; EXPLAIN FOR CONNECTION 373;
ERROR 1889 (HY000): EXPLAIN FOR CONNECTION command is supported
only for SELECT/UPDATE/INSERT/DELETE/REPLACE
</pre>
<p>Переменная <code>Com_explain_other</code> указывает на число выполненных
запросов <a href="sql.htm#explain"><code>EXPLAIN FOR CONNECTION</code></a>.
</p>

<h3><a name="estimating-performance"></a>9.8.5. Оценка работы запроса</h3>
<p>В большинстве случаев Вы можете оценить работу запроса, считая дисковые
поиски. Для маленьких таблиц Вы можете обычно находить строку в один дисковый
поиск (потому что индекс, вероятно, кэшируется). Для больших таблиц Вы можете
оценить, что, используя B-дерево, Вы нуждаетесь в нескольких поисках,
чтобы найти строку:
<code>log(<em><code>row_count</code></em>) /
log(<em><code>index_block_length</code></em> / 3 * 2 /
(<em><code>index_length</code></em> +
<em><code>data_pointer_length</code></em>)) + 1</code>.</p>

<p>В MySQL индексный блок обычно 1024 байт и указатель данных обычно 4 байта.
Для таблицы с 500000 строк с длиной значения ключа 3 байта (размер
<a href="types.htm#integer-types"><code>MEDIUMINT</code></a>),
формула указывает <code>log(500000)/log(1024/3*2/(3+4)) + 1</code> =
<code>4</code> поиска.</p>

<p>Этот индекс потребовал бы хранения приблизительно 500000 * 7 * 3/2 = 5.2MB
(считая, что типичный индексный буфер заполняется с отношением 2/3), таким
образом, у Вас, вероятно, есть большая часть индекса
в памяти и реально надо только один или два запроса чтения данных,
чтобы найти строку.</p>

<p>Для записи, однако, Вы нуждаетесь в четырех поисках, чтобы
найти, куда поместить новое индексное значение, и обычно два, чтобы
обновить индекс и написать строку.</p>

<p>Предыдущее обсуждение не означает, что Ваши потребительские
свойства медленно ухудшаются по log <em><code>N</code></em>.
Пока все кэшируется OS или сервером MySQL, операции становятся только
незначительно медленнее, поскольку таблица становится больше.
После того, как данные становятся слишком большими, чтобы кэшироваться, дела
начинают идти намного медленнее, пока Ваши приложения не связаны только
дисковы поиском (который увеличивается по log <em><code>N</code></em>).
Чтобы избежать этого, увеличьте размер ключевого кэша, поскольку данные
растут. Для <code>MyISAM</code> ключевым размером кэша управляет переменная
<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code></a>,
см. <a href="server.htm#server-configuration">раздел 6.1.1</a>.</p>

<h2><a name="controlling-optimizer"></a>9.9.
Управление оптимизатором запросов</h2>
<p>MySQL обеспечивает управление оптимизатором через системные переменные,
которые затрагивают, как планы запроса оценены, переключают оптимизацию,
подсказки оптимизатора и индекса и модель стоимости.</p>
<p>Сервер также поддерживает статистику о значениях столбцов, хотя
оптимизатор еще не использует эту информацию.</p>

<h3><a name="controlling-query-plan-evaluation"></a>9.9.1.
Управление оценкой плана запроса</h3>
<p>Задача оптимизатора состоит в том, чтобы найти оптимальный план
относительно выполнения запроса SQL. Поскольку разница в производительности
между <span><span>хорошим</span></span> и <span><span>плохом</span></span>
планами может быть порядками величины (то есть, секунды против часов или даже
дней), большинство оптимизаторов, включая MySQL, выполняют более или менее
исчерпывающий поиск оптимального плана среди всех возможных планов оценки
запроса. Для запросов соединения число возможных планов, исследованных MySQL,
растет по экспоненте с числом таблиц, на которые ссылаются в запросе.
Для небольших количеств таблиц (как правило, меньше 7-10) это не проблема.
Однако, когда большие запросы представлены, время, проведенное в оптимизации
запроса, может легко стать главным узким местом.</p>

<p>Более гибкий метод для оптимизации запроса позволяет пользователю
управлять, насколько исчерпывающе оптимизатор ищет оптимальный план оценки
запроса. Общее представление состоит в том, что чем меньше планов, которые
исследованы оптимизатор, тем меньше времени он тратит на компиляцию запроса.
С другой стороны, потому что оптимизатор пропускает некоторые планы, он
может не найти оптимальный план.</p>

<p>Поведением оптимизатор относительно числа планов, которые он
оценивает, можно управлять, используя две системных переменные:</p>
<ul><li><p><a href="server.htm#sysvar_optimizer_prune_level"><code>
optimizer_prune_level</code></a> говорит оптимизатору пропустить определенные
планы, основанные на оценках числа строк для каждой таблицы. Наш опыт
показывает, что этот вариант редко пропускает оптимальные планы и может резко
уменьшить времена компиляции запроса. Именно поэтому эта опция идет
по умолчанию (<code>optimizer_prune_level=1</code>).
Однако, если Вы полагаете, что оптимизатор пропустил лучший план запроса, эта
опция может быть выключена (<code>optimizer_prune_level=0</code>)
с риском, что компиляция запроса может занять намного больше времени.
Отметьте, что даже с использованием этой эвристики оптимизатор все еще
исследует примерно экспоненциальное число планов.</li>

<li><a href="server.htm#sysvar_optimizer_search_depth"><code>
optimizer_search_depth</code></a> говорит, как далеко в
<span><span>будущее</span></span> каждого неполного плана оптимизатор должен
оценивать, должно ли это быть расширено далее. Меньшие значения
<a href="server.htm#sysvar_optimizer_search_depth"><code>
optimizer_search_depth</code></a> могут привести к сильно меньшему времени
компиляции запроса. Например, запросы с 12, 13
или больше таблиц могут легко потребовать часы и даже дни анализа, если
<a href="server.htm#sysvar_optimizer_search_depth"><code>
optimizer_search_depth</code></a> близко к числу таблиц в запросе. В то же
самое время, если собрано с
<a href="server.htm#sysvar_optimizer_search_depth"><code>
optimizer_search_depth</code></a> = 3 или 4, оптимизатор может собрать
запрос меньше, чем через минуту для того же самого запроса. Если Вы не
уверены в том, какое значение разумно для
<a href="server.htm#sysvar_optimizer_search_depth"><code>
optimizer_search_depth</code></a>, эта переменная может быть установлена в 0,
чтобы сказать оптимизатору определить значение автоматически.</p></li></ul>

<h3><a name="switchable-optimizations"></a>9.9.2.
Управление переключаемой оптимизацией</h3>
<p><a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> включает управление поведением оптимизатора. Ее значение это ряд флагов,
у каждого из которых есть значение <code>on</code> или <code>off</code>,
чтобы указать, включено ли соответствующее поведение оптимизатора или
отключено. Эта переменная имеет глобальное и значение сеанса и может быть
изменена во время выполнения. Глобальное значение по умолчанию может быть
установлено при запуске сервера.</p>

<p>Чтобы видеть текущий набор флагов оптимизатор, выберите значение:
<pre>
mysql&gt; SELECT @@optimizer_switch\G
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
index_merge_sort_union=on,
index_merge_interраздел=on,
engine_condition_pushdown=on,
index_condition_pushdown=on,
mrr=on,mrr_cost_based=on,
block_nested_loop=on,batched_key_access=off,
materialization=on,semijoin=on,loosescan=on,
firstmatch=on,duplicateweedout=on,
subquery_materialization_cost_based=on,
use_index_extensions=on,
condition_fanout_filter=on,derived_merge=on
</pre>

<p>Чтобы изменить значение <a href="server.htm#sysvar_optimizer_switch">
<code>optimizer_switch</code></a>, назначьте значение, состоящее из списка
разделенных запятой значений одной или более команд:
<pre>
SET [GLOBAL|SESSION] optimizer_switch='<em><code>command</code></em>[,<em><code>command</code></em>]...';
</pre>

<p>Каждое значение <em><code>command</code></em>
должно быть одной из форм, показанных в следующей таблице.</p>
<table border="1">
<thead><tr><th scope="col">Синтаксис</th><th scope="col">Смысл</th>
</tr></thead>
<tbody><tr><td scope="row"><code>default</code></td><td>
Сбросьте каждую оптимизацию к ее значению по умолчанию.</td></tr>
<tr><td scope="row"><code><em><code>opt_name</code></em>=default</code></td>
<td>Установите названную оптимизацию в ее значение по умолчанию.</td></tr>
<tr><td scope="row"><code><em><code>opt_name</code></em>=off</code></td><td>
Отключите названную оптимизацию.</td></tr>
<tr><td scope="row"><code><em><code>opt_name</code></em>=on</code></td><td>
Включите названную оптимизацию.</td></tr></tbody></table>

<p>Порядок команд в значении не имеет значения, хотя
<code>default</code> выполнена сначала, если есть. Установка
<em><code>opt_name</code></em> в <code>default</code>
установит к <code>on</code> или <code>off</code>
по умолчанию. Определение любого <em><code>opt_name</code></em>
не раз в значении не разрешено и вызывает ошибку.
Любые ошибки в значении заставляют назначение терпеть неудачу с ошибкой,
оставляя значение <a href="server.htm#sysvar_optimizer_switch"><code>
optimizer_switch</code></a> прежним.</p>

<p>Следующая таблица приводит допустимые имена
<em><code>opt_name</code></em>, сгруппированные стратегией оптимизации.</p>
<table border="1">
<thead><tr><th scope="col">Оптимизация</th><th scope="col">Имя флага</th>
<th scope="col">Смысл</th><th scope="col">Значение по умолчанию</th>
</tr></thead>
<tbody><tr><td scope="row">Batched Key Access</td><td><code>
batched_key_access</code></td><td>Использование алгоритма BKA join</td>
<td><code>OFF</code></td></tr>
<tr><td scope="row">Block Nested-Loop</td><td><code>block_nested_loop</code>
</td><td>Использование алгоритма BNL join</td><td><code>ON</code></td></tr>
<tr><td scope="row">Condition Filtering</td><td><code>condition_fanout_filter
</code></td><td>Использование фильтрации условия</td><td><code>ON</code>
</td></tr>
<tr><td scope="row">Engine Condition Pushdown</td><td><code>
engine_condition_pushdown</code></td><td>Условие механизма pushdown</td>
<td><code>ON</code></td></tr>
<tr><td scope="row">Index Condition Pushdown</td><td><code>
index_condition_pushdown</code></td><td>Управление индексным pushdown</td>
<td><code>ON</code></td></tr>
<tr><td scope="row">Index Extensions</td><td><code>use_index_extensions
</code></td><td>Использование средств индексного расширения</td><td>
<code>ON</code></td></tr>
<tr><td scope="row">Index Merge</td><td><code>index_merge</code></td><td>
Управляет Index Merge</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>index_merge_intersection</code></td><td>
Управляет Index Merge Intersection Access</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>index_merge_sort_union</code></td><td>
Управляет Index Merge Sort-Union Access</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>index_merge_union</code></td><td>
Управляет Index Merge Union Access optimization</td><td><code>ON</code>
</td></tr>
<tr><td scope="row">Multi-Range Read</td><td><code>mrr</code></td><td>
Управляет стратегией Multi-Range Read</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>mrr_cost_based</code></td><td>
Управляет MRR на основе издержек, если <code>mrr=on</code></td><td>
<code>ON</code></td></tr>
<tr><td scope="row">Semi-join</td><td><code>semijoin</code></td><td>
Контролирует все стратегии полусоединения</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>firstmatch</code></td><td>
Управляет стратегией FirstMatch</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>loosescan</code></td><td>
Управляет стратегией LooseScan strategy (не путать с
LooseScan для <code>GROUP BY</code>)</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>duplicateweedout</code></td><td>
Управляет стратегией Duplicate Weedout</td><td><code>ON</code></td></tr>
<tr><td scope="row">Subquery materialization</td><td><code>materialization
</code></td><td>Управляет материализацией (включая материализацию
полусоединения)</td><td><code>ON</code></td></tr>
<tr><td scope="row"> </td><td><code>subquery_materialization_cost_based
</code></td><td>Используемый выбор материализации на основе издержек</td>
<td><code>ON</code></td></tr>
<tr><td scope="row">Derived table merging</td><td><code>derived_merge</code>
</td><td>Слияние полученных таблиц и представлений во внешний блок запроса
</td><td><code>ON</code></td></tr></tbody></table>

<p>Для <code>batched_key_access</code>, чтобы иметь любой эффект, когда
установлено в <code>on</code>, <code>mrr</code> должен также быть
<code>on</code>. В настоящее время оценка стоимости для MRR слишком
пессимистична. Следовательно, также необходимо установить
<code>mrr_cost_based</code> в <code>off</code> для BKA.</p>

<p><code>semijoin</code>, <code>firstmatch</code>,
<code>loosescan</code>, <code>duplicateweedout</code> и
<code>materialization</code> включают управление полусоединением и
подзапросами стратегии материализации. <code>semijoin</code> управляет,
используются ли полусоединения. Если <code>firstmatch</code> и
<code>loosescan</code> оба <code>on</code>,
полусоединения также используют материализацию, где применимо.
Эти флаги <code>on</code> по умолчанию.</p>

<p>Если стратегия <code>duplicateweedout</code> выключена, она не
используется, если все другие применимые стратегии также не отключены.</p>
<p><code>subquery_materialization_cost_based</code> управляет
выбором между материализацией подзапроса и преобразованием подзапроса
<code>IN</code>-to-<code>EXISTS</code>. Если <code>on</code> (по умолчанию),
оптимизатор выполняет выбор на основе издержек между материализацией
подзапроса и преобразованием подзапроса <code>IN</code>-to-<code>EXISTS
</code>, если любой метод мог бы использоваться. Если флаг <code>off</code>,
оптимизатор выбирает преобразование подзапроса <code>IN -&gt; EXISTS</code>.
</p>

<p><code>derived_merge</code> управляет, пытается ли оптимизатор слить
полученные таблицы и представления во внешний блок запроса, предполагая, что
никакое другое правило не предотвращает слияние, например,
<code>ALGORITHM</code> для представления имеет приоритет перед
<code>derived_merge</code>. По умолчанию флаг <code>on</code>, чтобы
позволять слиться. Для получения дополнительной информации см.
<a href="#derived-table-optimization">раздел 9.2.1.18.3</a>.</p>

<p>Для получения дополнительной информации об отдельных стратегиях
оптимизации см. следующие разделы:</p>
<ul><li><p><a href="#bnl-bka-optimization">раздел 9.2.1.14</a>
</li>
<li><a href="#condition-pushdown-optimization">раздел 9.2.1.5</a>
</li>

<li><a href="#index-extensions">раздел 9.2.1.7</a></li>
<li><a href="#index-condition-pushdown-optimization">
раздел 9.2.1.6</a></li>

<li><a href="#index-merge-optimization">раздел 9.2.1.4</a></li>
<li><a href="#mrr-optimization">раздел 9.2.1.13</a></li>
<li><a href="#subquery-optimization">раздел 9.2.1.18</a>
</p></li></ul>

<p>Когда Вы назначаете значение
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a>, флаги, которые не упомянуты, сохраняют свое текущее значение.
Это позволяет включить или отключить определенные поведения оптимизатора в
единственном запросе, не затрагивая другие поведения. Запрос не зависит от
того, что существуют другие флаги оптимизатора, и каковы их значения.
Предположите, что все оптимизации Index Merge включены:
<pre>
mysql&gt; SELECT @@optimizer_switch\G
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=on,
index_merge_sort_union=on,
engine_condition_pushdown=on,
index_condition_pushdown=on,
mrr=on,mrr_cost_based=on,
block_nested_loop=on,batched_key_access=off,
materialization=on,semijoin=on,loosescan=on,
firstmatch=on,
subquery_materialization_cost_based=on,
use_index_extensions=on,
condition_fanout_filter=on
</pre>

<p>Если сервер использует Index Merge Union или Index Merge Sort-Union
для определенных запросов, и Вы хотите проверить, выступит ли оптимизатор
лучше без них, установите значение:
<pre>
mysql&gt; SET optimizer_switch='index_merge_union=off,
              index_merge_sort_union=off';
mysql&gt; SELECT @@optimizer_switch\G
*************************** 1. row ***************************
@@optimizer_switch: index_merge=on,index_merge_union=off,
index_merge_sort_union=off,
index_merge_interраздел=on,
engine_condition_pushdown=on,
index_condition_pushdown=on,
mrr=on,mrr_cost_based=on,
block_nested_loop=on,batched_key_access=off,
materialization=on,semijoin=on,loosescan=on,
firstmatch=on,
subquery_materialization_cost_based=on,
use_index_extensions=on,
condition_fanout_filter=on
</pre>

<h3><a name="optimizer-hints"></a>9.9.3. Подсказки оптимизатору</h3>
<p>Одно средство контроля стратегий оптимизатора состоит в том, чтобы
установить <a href="server.htm#sysvar_optimizer_switch"><code>
optimizer_switch</code></a> (см.
<a href="#switchable-optimizations">раздел 9.9.2</a>).
Изменение этой переменной влияет на все последующие запросы, чтобы затронуть
только один запрос, необходимо изменить
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a> строго перед ним.</p>

<p>Другой способ управлять оптимизатором при использовании подсказок
, которые могут быть определены в пределах отдельных запросов. Поскольку
подсказки оптимизатор применяются на основе запроса, они обеспечивают более
гибкое управление планами выполнения запроса, чем можно достигнуть, используя
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a>. Например, Вы можете включить оптимизации для одной таблицы в запросе и
отключить для иной таблицы. Подсказки в пределах запроса имеют приоритет над
флагами <a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch
</code></a>.</p>

<p>Например:
<pre>
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
       FROM t3 WHERE f1 &gt; 30 AND f1 &lt; 33;
SELECT /*+ BKA(t1) NO_BKA(t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ NO_ICP(t1, t2) */ * FROM t1 INNER JOIN t2 WHERE ...;
SELECT /*+ SEMIJOIN(FIRSTMATCH, LOOSESCAN) */ * FROM t1 ...;
EXPLAIN SELECT /*+ NO_ICP(t1) */ * FROM t1 WHERE ...;
SELECT /*+ MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt;
</pre>

<p>Подсказки оптимизатора, описанные здесь, отличаются от индексных
подсказок, описанных в <a href="#index-hints">разделе 9.9.4</a>.
Оптимизаторные и индексные подсказки могут использоваться
отдельно или вместе.</p>

<h4><a name="optimizer-hints-overview"></a>
Краткий обзор подсказок оптимизатора</h4>
<p>Подсказки оптимизатора применяются на различных уровнях контекста:</p>

<ul><li><p>Глобальный: подсказка затрагивает весь запрос.</li>
<li>Блок запроса: подсказка затрагивает особый блок
запроса в пределах запроса.</li>
<li>На уровне таблицы: подсказка затрагивает особую таблицу в
пределах блока запроса.</li>
<li>Индекс: подсказка затрагивает индекс в пределах таблицы.</p></li></ul>

<p>Следующая таблица суммирует доступные подсказки оптимизатора,
стратегии, которые они затрагивают, и контекст или контексты, в которых они
применяются. Больше деталей дано позже.</p>

<a name="optimizer-hints-table"></a>
<p><b>Таблица 9.2. Доступные подсказки оптимизатора</b></p>
<table><thead><tr><td align="center">Имя подсказки</td>
<td align="center">Описание</td>
<td align="center">Применимые контексты</td></tr></thead>
<tbody><tr><td align="left"><a href="#optimizer-hints-table-level">
<code>BKA</code></a>, <a href="#optimizer-hints-table-level">
<code>NO_BKA</code></a></td>
<td align="left">Обработка Batched Key Access join</td>
<td>Блок запроса, таблица</td></tr>

<tr><td align="left"><a href="#optimizer-hints-table-level"><code>
BNL</code></a>, <a href="#optimizer-hints-table-level"><code>
NO_BNL</code></a></td>
<td align="left">Block Nested-Loop join</td>
<td>Блок запроса, таблица</td></tr>

<tr><td align="left"><a href="#optimizer-hints-execution-time">
<code>MAX_EXECUTION_TIME</code></a></td>
<td align="left">Время выполнения запроса</td><td>Глобально</td></tr>

<tr><td align="left"><a href="#optimizer-hints-table-level"><code>
MERGE</code></a>, <a href="#optimizer-hints-table-level"><code>
NO_MERGE</code></a></td>
<td align="left">Полученная таблица/представление, сливающяяся во
внешний блок запроса</td><td>Таблица</td></tr>

<tr><td align="left"><a href="#optimizer-hints-index-level"><code>
MRR</code></a>, <a href="#optimizer-hints-index-level"><code>
NO_MRR</code></a></td>
<td align="left">Оптимизация Multi-Range Read</td>
<td>Таблица, индекс</td></tr>

<tr><td align="left"><a href="#optimizer-hints-index-level"><code>
NO_ICP</code></a></td>
<td align="left">Оптимизация Index Condition Pushdown</td>
<td>Таблица, индекс</td></tr>

<tr><td align="left"><a href="#optimizer-hints-index-level">
<code>NO_RANGE_OPTIMIZATION</code></a></td>
<td align="left">Оптимизация range</td><td>Таблица, индекс</td></tr>

<tr><td align="left"><a href="#optimizer-hints-query-block-naming">
<code>QB_NAME</code></a></td>
<td align="left">Назначает имя блоку запроса</td><td>Блок запроса</td></tr>

<tr><td align="left"><a href="#optimizer-hints-subquery"><code>
SEMIJOIN</code></a>, <a href="#optimizer-hints-subquery"><code>
NO_SEMIJOIN</code></a></td>
<td align="left">Стратегии полуприсоединений</td><td>Блок запроса</td></tr>

<tr><td align="left"><a href="#optimizer-hints-subquery">
<code>SUBQUERY</code></a></td><td align="left">Материализация и стратегия
подзапросов <code>IN</code>-to-<code>EXISTS</code></td>
<td>Блок запроса</td></tr></tbody></table>

<p>Отключение оптимизации препятствует тому, чтобы оптимизатор использовал
ее. Включение оптимизации означает, что оптимизатор свободен использовать
стратегию, если это относится к выполнению запроса, а не то,
что оптимизатор обязательно будет использовать ее.</p>

<h4><a name="optimizer-hints-syntax"></a>Синтаксис подсказки оптимизатору
</h4>
<p>MySQL поддерживает комментарии в запросах SQL как описано в
<a href="lang.htm#comments">разделе 10.6</a>.
Подсказки оптимизатора используют разновидность <code>/* ... */</code>
C-комментария, который включает символ <code>+</code> после вводной
последовательности <code>/*</code>:
<pre>
/*+ BKA(t1) */
/*+ BNL(t1, t2) */
/*+ NO_RANGE_OPTIMIZATION(t4 PRIMARY) */
/*+ QB_NAME(qb2) */
</pre>

<p>Пробелы разрешаются после символа <code>+</code>.</p>
<p>Анализатор признает комментарии подсказки оптимизатора после начального
ключевого слова <a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#replace"><code>REPLACE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>.
Подсказки разрешены в этих контекстах:</p>

<ul><li><p>В начале запросов и операторов изменения данных:
<pre>
SELECT /*+ ... */ ...
INSERT /*+ ... */ ...
REPLACE /*+ ... */ ...
UPDATE /*+ ... */ ...
DELETE /*+ ... */ ...
</pre></li>

<li>В начале блока запросов:
<pre>
(SELECT /*+ ... */ ... )
(SELECT ... ) UNION (SELECT /*+ ... */ ... )
(SELECT /*+ ... */ ... ) UNION (SELECT /*+ ... */ ... )
UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
INSERT ... SELECT /*+ ... */ ...
</pre></li>

<li>В запросах, снабженных ключевым словом <a href="sql.htm#explain"><code>
EXPLAIN</code></a>:
<pre>
EXPLAIN SELECT /*+ ... */ ...
EXPLAIN UPDATE ... WHERE x IN (SELECT /*+ ... */ ...)
</pre>

<p>Значение то, что Вы можете использовать
<a href="sql.htm#explain"><code>EXPLAIN</code></a>, чтобы
видеть, как оптимизатор подсказывает планы выполнения.</p></li></ul>

<p>Комментарий подсказки может содержать многократные подсказки, но блок
запроса не может содержать многократные комментарии подсказки. Это допустимо:
<pre>
SELECT /*+ BNL(t1) BKA(t2) */ ...
</pre>

<p>Но не это:
<pre>
SELECT /*+ BNL(t1) */ /* BKA(t2) */ ...
</pre>

<p>Когда комментарий подсказки содержит многократные подсказки, возможность
дубликатов и конфликтов существует:</p>
<ul><li><p>Двойные подсказки: Для такой подсказки, как <code>/*+ MRR(idx1)
MRR(idx1) */</code>, MySQL использует первую подсказку и выпускает
предупреждение о двойной подсказке.</li>

<li>Противоречивые подсказки: Для такой подсказки, как <code>/*+ MRR(idx1)
NO_MRR(idx1) */</code>, MySQL использует первую подсказку и выпускает
предупреждение о второй противоречивой подсказке.</p></li></ul>

<p>Имена блока запроса это идентификаторы, они неотступно следуют обычным
правилам, какие имена допустимы и как заключить их в кавычки (см.
<a href="lang.htm#identifiers">раздел 10.2</a>).</p>

<p>Имена подсказки, имена блока запроса и имена стратегии не являются
чувствительными к регистру. Ссылки на имена таблицы и индекса следуют обычным
правилам чувствительности к регистру идентификатора (см.
<a href="lang.htm#identifier-case-sensitivity">раздел 10.2.2</a>).</p>

<h4><a name="optimizer-hints-table-level"></a>
Подсказки оптимизатора на уровне таблицы</h4>
<p>Эффект подсказок на уровне таблицы:</p>

<ul><li><p>Использование алгоритмов обработки соединения
Block Nested-Loop (BNL) и Batched Key Access (BKA)
(см. <a href="#bnl-bka-optimization">раздел 9.2.1.14</a>).</li>

<li>Должны ли полученные таблицы или представления быть слиты во внешний блок
запроса или осуществить использование внутренней временной таблицы.
</p></li></ul>

<p>Эти типы подсказки относятся к определенным таблицам или всем
таблицам в блоке запроса.</p>
<p>Синтаксис подсказок на уровне таблицы:
<pre>
<em><code>hint_name</code></em>([@<em><code>query_block_name</code></em>]
[<em><code>tbl_name</code></em> [, <em><code>tbl_name</code></em>] ...])
<em><code>hint_name</code></em>([<em><code>tbl_name</code></em>@<em><code>query_block_name</code></em>
[, <em><code>tbl_name</code></em>@<em><code>query_block_name</code></em>] ...])
</pre>

<p>Синтаксис ссылается на эти термины:</p>
<ul><li><p><em><code>hint_name</code></em>: Эти имена подсказки разрешены:
</p>
<ul><li><p><code>BKA</code>, <code>NO_BKA</code>:
Включите или отключите BKA для указанных таблиц.</li>
<li><code>BNL</code>, <code>NO_BNL</code>:
Включите или отключите BNL для указанных таблиц.</li>

<li><code>MERGE</code>, <code>NO_MERGE</code>:
Включите или отключите слияние для указанных таблиц или представлений.
</p></li></ul></li>

<li><em><code>tbl_name</code></em>: Название таблицы, которая используется в
запрос. Подсказка относится ко всем таблицам, которые она называет. Если
подсказка не называет таблицу, она относится ко всем таблицам блока запроса,
в котором она происходит.</p>

<p>Если у таблицы есть псевдоним, подсказки должны обратиться к псевдониму,
не к имени таблицы.</p>
<p>Имена таблиц в подсказках не могут быть квалифицированы с именами схемы.
</li>

<li><em><code>query_block_name</code></em>: Блок запроса, к которому
применяется подсказка. Если подсказка не включает
<code>@<em><code>query_block_name</code></em></code>,
подсказка относится к блоку запроса, в котором она происходит. Для формата
<code><em><code>tbl_name</code></em>@<em><code>query_block_name</code></em>
</code> подсказка относится к названной таблице в названном блоке запроса.
Чтобы назначить имя блоку запроса, см.
<a href="#optimizer-hints-query-block-naming">сюда</a>.
</p></li></ul>

<p>Примеры:
<pre>
SELECT /*+ NO_BKA(t1, t2) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT /*+ NO_BNL() BKA(t1) */ t1.* FROM t1 INNER JOIN t2 INNER JOIN t3;
SELECT /*+ NO_MERGE(dt) */ * FROM (SELECT * FROM t1) AS dt;
</pre>

<p>Подсказка на уровне таблицы относится к таблицам, которые получают
отчеты от предыдущих таблиц, а не таблиц отправителя.
Рассмотрите этот запрос:
<pre>
SELECT /*+ BNL(t2) */ FROM t1, t2;
</pre>

<p>Если оптимизатор хочет обрабатывать <code>t1</code>, это применяет
соединение Block Nested-Loop к <code>t2</code> буферизуя строки из
<code>t1</code> прежде, чем начать читать из <code>t2</code>.
Если оптимизатор вместо этого хочет обрабатывать сначала <code>t2</code>,
подсказка не имеет никакого эффекта, потому что <code>t2</code>
это таблица отправителя.</p>

<p>Для подсказок <code>MERGE</code> и <code>NO_MERGE</code>
эти правила приоритета применяются:</p>
<ul><li><p>Подсказка имеет приоритет перед любой эвристикой оптимизатора,
которая не является техническим ограничением. Если предложение подсказки
не имеет никакого эффекта, у оптимизатора есть причина игнорирования ее.</li>

<li>Подсказка имеет приоритет перед флагом <code>derived_merge</code> в
переменной <a href="server.htm#sysvar_optimizer_switch"><code>
optimizer_switch</code></a>.</li>

<li>Для представлений <code>ALGORITHM={MERGE|TEMPTABLE}</code> в
определении представления имеет приоритет перед подсказкой, определенной в
запросе, ссылающемся на представление.</p></li></ul>

<h4><a name="optimizer-hints-index-level"></a>
Подсказки оптимизатора уровня индекса</h4>
<p>Подсказки оптимизатора уровня индекса указывают, какие стратегии
обработки индекса оптимизатор использует для особых таблиц или индексов.
Это влияет на использование оптимизаций Index Condition Pushdown (ICP),
Multi-Range Read (MRR) и range (см.
<a href="#select-optimization">раздел 9.2.1</a>).</p>

<p>Синтаксис индексного уровня подсказки:
<pre>
<em><code>hint_name</code></em>([@<em><code>query_block_name</code></em>]
<em><code>tbl_name</code></em> [<em><code>index_name</code></em>
[, <em><code>index_name</code></em>] ...])
<em><code>hint_name</code></em>(<em><code>tbl_name</code></em>@<em><code>query_block_name</code></em>
[<em><code>index_name</code></em> [, <em><code>index_name</code></em>] ...])
</pre>

<p>Синтаксис ссылается на эти термины:</p>
<ul><li><p><em><code>hint_name</code></em>: Эти имена подсказки разрешены:
</p>
<ul><li><p><code>MRR</code>, <code>NO_MRR</code>:
Включите или отключите MRR для указанных таблиц или индексов. Подсказки MRR
применяются только к <code>InnoDB</code> и <code>MyISAM</code>.</li>

<li><code>NO_ICP</code>: Отключите ICP для указанных таблиц или индексов.
По умолчанию ICP стратегия оптимизации кандидата, таким образом нет никакой
подсказки для того, чтобы включить ее.</li>

<li><code>NO_RANGE_OPTIMIZATION</code>: Отключите индексный доступ диапазона
для указанных таблиц или индексов. Эта подсказка также отключает Index Merge
и Loose Index Scan для таблиц или индексов. По умолчанию доступ диапазона
стратегия оптимизации кандидата, таким образом нет никакой подсказки для
того, чтобы включить ее.</p>

<p>Эта подсказка может быть полезной, когда число диапазонов может быть
высоким, и оптимизация диапазона потребовала бы многих ресурсов.
</p></li></ul></li>

<li><em><code>tbl_name</code></em>: Таблица, к которой применяется подсказка.
</li>
<li><em><code>index_name</code></em>: Название индексирования в названной
таблице. Подсказка относится ко всем индексам, которые она называет. Если
подсказка не называет индекс, она относится ко всем индексам в таблице.</p>

<p>Чтобы обратиться к первичному ключу, используйте имя
<code>PRIMARY</code>. Чтобы посмотреть имена индексов, используйте
<a href="sql.htm#show-index"><code>SHOW INDEX</code></a>.</li>

<li><em><code>query_block_name</code></em>: Блок запроса, к которому
применяется подсказка. Если подсказка не включает
<code>@<em><code>query_block_name</code></em></code>, она
относится к блоку запроса, в котором она происходит. Для формата
<code><em><code>tbl_name</code></em>@<em><code>query_block_name</code></em>
</code> подсказка относится к названной таблице в названном блоке запроса.
Чтобы назначить имя блоку запроса, см.
<a href="#optimizer-hints-query-block-naming">сюда</a>.
</p></li></ul>

<p>Примеры:
<pre>
SELECT /*+ MRR(t1) */ * FROM t1 WHERE f2 &lt;= 3 AND 3 &lt;= f3;
SELECT /*+ NO_RANGE_OPTIMIZATION(t3 PRIMARY, f2_idx) */ f1
       FROM t3 WHERE f1 &gt; 30 AND f1 &lt; 33;
INSERT INTO t3(f1, f2, f3)
       (SELECT /*+ NO_ICP(t2) */ t2.f1, t2.f2, t2.f3 FROM t1,t2
        WHERE t1.f1=t2.f1 AND t2.f2 BETWEEN t1.f1 AND t1.f2 AND
        t2.f2 + 1 &gt;= t1.f1 + 1);
</pre>

<h4><a name="optimizer-hints-subquery"></a>Подсказки оптимизатора подзапросов
</h4>
<p>Подсказки оптимизатора подзапросов указывают, использовать ли
преобразования полусоединения и которые стратегии разрешить,
когда полусоединения не используются, использовать ли материализацию
подзапроса или преобразование <code>IN</code>-to-<code>EXISTS</code>.
См. <a href="#subquery-optimization">раздел 9.2.1.18</a>.</p>

<p>Синтаксис подсказок стратегии полусоединения такой:
<pre>
<em><code>hint_name</code></em>([@<em><code>query_block_name</code></em>]
[<em><code>strategy</code></em> [, <em><code>strategy</code></em>] ...])
</pre>

<p>Синтаксис ссылается на эти термины:</p>
<ul><li><p><em><code>hint_name</code></em>: Эти имена подсказки разрешены:
</p>
<ul><li><p><code>SEMIJOIN</code>, <code>NO_SEMIJOIN</code>:
Включите или отключите названные стратегии полусоединения.</p></li></ul></li>
<li><em><code>strategy</code></em>: Стратегия полусоединения, которая будет
включена или отключена. Эти имена стратегии разрешены:
<code>DUPSWEEDOUT</code>, <code>FIRSTMATCH</code>,
<code>LOOSESCAN</code>, <code>MATERIALIZATION</code>.</p>

<p>Для <code>SEMIJOIN()</code>, если никакие стратегии не называют,
полусоединение используются, если возможн, основаннон на стратегиях,
включенных согласно <a href="server.htm#sysvar_optimizer_switch"><code>
optimizer_switch</code></a>. Если стратегии называют, но неподходящие для
запроса, используется <code>DUPSWEEDOUT</code>.</p>

<p>Для <code>NO_SEMIJOIN()</code>, если если никакие стратегии не называют,
полусоединение не используются. Если стратегии называют, которые исключают
все применимые стратегии запроса, используются <code>DUPSWEEDOUT</code>.
</p></li></ul>

<p>Если один подзапрос вложен в пределах другого, и оба слиты в
полусоединение внешнего запроса, любая спецификация стратегий полусоединения
самого внутреннего запроса проигнорирована.
<code>SEMIJOIN()</code> и <code>NO_SEMIJOIN()</code>
могут все еще использоваться, чтобы включить или отключить преобразования
полусоединения для таких вложенных подзапросов.</p>

<p>Если выключена <code>DUPSWEEDOUT</code>, оптимизатор может произвести план
запроса, который совсем не оптимален. Это происходит из-за эвристического
сокращения во время поиска, которого можно избежать, устанавливая
<a href="server.htm#sysvar_optimizer_prune_level"><code>
optimizer_prune_level=0</code></a>.</p>

<p>Примеры:
<pre>
SELECT /*+ NO_SEMIJOIN(@subq1 FIRSTMATCH, LOOSESCAN) */ * FROM t2
       WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3);
SELECT /*+ SEMIJOIN(@subq1 MATERIALIZATION, DUPSWEEDOUT) */ * FROM t2
       WHERE t2.a IN (SELECT /*+ QB_NAME(subq1) */ a FROM t3);
</pre>

<p>Синтаксис подсказок, которые затрагивают, использовать ли материализацию
подзапроса или преобразования <code>IN</code>-to-<code>EXISTS</code>:
<pre>
SUBQUERY([@<em><code>query_block_name</code></em>] <em><code>strategy</code></em>)
</pre>

<p>Имя подсказки всегда <code>SUBQUERY</code>.</p>
<p>Для <code>SUBQUERY()</code> разрешены эти значения
<em><code>strategy</code></em>:
<code>INTOEXISTS</code>, <code>MATERIALIZATION</code>.</p>

<p>Примеры:
<pre>
SELECT id, a IN (SELECT /*+ SUBQUERY(MATERIALIZATION) */ a FROM t1) FROM t2;
SELECT * FROM t2 WHERE t2.a IN (SELECT /*+ SUBQUERY(INTOEXISTS) */ a FROM t1);
</pre>

<p>Для полусоединения и <code>SUBQUERY()</code>
<code>@<em><code>query_block_name</code></em></code>
определяет блок запроса, к которому применяется подсказка. Если подсказка не
включает <code>@<em><code>query_block_name</code></em></code>,
подсказка относится к блоку запроса, в котором она происходит.</p>

<p>Если комментарий подсказки содержит многократные подсказки подзапроса,
используется первая. Если есть другие после подсказок этого типа, они
производят предупреждение. Следующие подсказки других
типов тихо проигнорированы.</p>

<h4><a name="optimizer-hints-execution-time"></a>
Подсказки выполнения запроса</h4>
<p><code>MAX_EXECUTION_TIME()</code> разрешают только для
<a href="sql.htm#select"><code>SELECT</code></a>. Это устанавливает границу
<em><code>N</code></em> (значение тайм-аута в миллисекундах) на то, сколько
времени запросу разрешают выполняться:
<pre>
MAX_EXECUTION_TIME(<em><code>N</code></em>)
</pre>

<p>Пример с тайм-аутом в 1 секунду (1000 миллисекунд):
<pre>
SELECT /*+ MAX_EXECUTION_TIME(1000) */ * FROM t1 INNER JOIN t2 WHERE ...
</pre>

<p><code>MAX_EXECUTION_TIME(<em><code>N</code></em>)</code>
устанавливает тайм-аут выполнения запроса в
<em><code>N</code></em> миллисекунд. Если эта опция отсутствует или
<em><code>N</code></em> 0, тайм-аут запроса установлен
<a href="server.htm#sysvar_max_execution_time">
<code>max_execution_time</code></a>.</p>

<p><code>MAX_EXECUTION_TIME()</code> применима следующим образом:</p>
<ul><li><p>Для запросов с многократным <code>SELECT</code>, например,
союзы или запросы с подзапросами, <code>MAX_EXECUTION_TIME()</code>
относится ко всему запросу и должна появиться после первого
<a href="sql.htm#select"><code>SELECT</code></a>.</li>

<li>Это относится к <a href="sql.htm#select"><code>SELECT</code></a> только
для чтения. Запросы, которые не только для чтения, являются теми, которые
вызывают сохраненную функцию, которая изменяет данные как побочный эффект.
</li>
<li>Это не относится к запросам <a href="sql.htm#select"><code>SELECT</code>
</a> в сохраненных программах и проигнорировано.</p></li></ul>

<h4><a name="optimizer-hints-query-block-naming"></a>
Подсказки оптимизатору для обозначения блоков запроса</h4>
<p>На уровне таблицы, индекса и подзапроса определенные блоки разрешают
подсказки оптимизатора, которые включают имя как часть их синтаксиса
параметра. Чтобы создать эти имена, используйте подсказку
<code>QB_NAME()</code>, которая назначает имя блоку запроса, в
котором она происходит:
<pre>
QB_NAME(<em><code>name</code></em>)
</pre>

<p><code>QB_NAME()</code> могут использоваться, чтобы сделать явным
способ, которым запрашивают блоки, к которым относятся другие подсказки.
Они также разрешают, чтобы все имена блока были определены
в пределах единственного комментария подсказки для более легкого понимания
сложных запросов. Рассмотрите следующий запрос:
<pre>
SELECT ... FROM (SELECT ... FROM (SELECT ... FROM ...)) ...
</pre>

<p><code>QB_NAME()</code> назначает имена блокам в запросе:
<pre>
SELECT /*+ QB_NAME(qb1) */ ...
       FROM (SELECT /*+ QB_NAME(qb2) */ ...
       FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ...
</pre>

<p>Тогда другие подсказки могут использовать те имена, чтобы обратиться к
соответствующим блокам запроса:
<pre>
SELECT /*+ QB_NAME(qb1) MRR(@qb1 t1) BKA(@qb2) NO_MRR(@qb3t1 idx1, id2) */ ...
       FROM (SELECT /*+ QB_NAME(qb2) */ ...
       FROM (SELECT /*+ QB_NAME(qb3) */ ... FROM ...)) ...
</pre>

<p>Получающийся эффект следующий:</p>
<ul><li><p><code>MRR(@qb1 t1)</code> относится к таблице
<code>t1</code> в блоке запроса <code>qb1</code>.</li>

<li><code>BKA(@qb2)</code> относится к блоку запроса <code>qb2</code>.</li>
<li><code>NO_MRR(@qb3 t1 idx1, id2)</code> относится к индексам
<code>idx1</code> и <code>idx2</code> в таблице <code>t1</code> в
блоке запроса <code>qb3</code>.</p></li></ul>

<p>Имена блока запроса это идентификаторы, они неотступно следуют обычным
правилам, какие имена допустимы и как заключить их в кавычки (см.
<a href="lang.htm#identifiers">раздел 10.2</a>).
Например, имя блока запроса, которое содержит пробелы, должно быть заключено
в кавычки, что может быть сделан, например, так:
<pre>
SELECT /*+ BKA(@`my hint name`) */ ...
       FROM (SELECT /*+ QB_NAME(`my hint name`) */ ...) ...
</pre>

<p>Если включен режим SQL <a href="server.htm#sqlmode_ansi_quotes"><code>
ANSI_QUOTES</code></a>, также возможно заключить имена блока запроса в
кавычки в пределах двойных кавычек:
<pre>
SELECT /*+ BKA(@"my hint name") */ ...
       FROM (SELECT /*+ QB_NAME("my hint name") */ ...) ...
</pre>

<h3><a name="index-hints"></a>9.9.4. Индексные подсказки</h3>
<p>Индексные подсказки дают оптимизатору информацию о том, как выбрать индекс
во время обработки запроса. Индексные подсказки, описанные здесь, отличаются
от подсказок оптимизатора, описанных в
<a href="#optimizer-hints">разделе 9.9.3</a>. Индексные и
подсказки оптимизатора могут использоваться отдельно или вместе.</p>

<p>Индексные подсказки определены после имени таблицы. Для общего синтаксиса
для того, чтобы определить таблицы в
<a href="sql.htm#select"><code>SELECT</code></a> см.
<a href="sql.htm#join">раздел 14.2.9.2</a>.
Синтаксис для того, чтобы обратиться к отдельной таблице, включая индексные
подсказки, похож на это:
<pre>
<em><code>tbl_name</code></em> [[AS] <em><code>alias</code></em>]
[<em><code>index_hint_list</code></em>]
<em><code>index_hint_list</code></em>:
<em><code>index_hint</code></em> [, <em><code>index_hint</code></em>] ...
<em><code>index_hint</code></em>:
USE {INDEX|KEY}
[FOR {JOIN|ORDER BY|GROUP BY}] ([<em><code>index_list</code></em>])
     | IGNORE {INDEX|KEY}
[FOR {JOIN|ORDER BY|GROUP BY}] (<em><code>index_list</code></em>)
     | FORCE {INDEX|KEY}
[FOR {JOIN|ORDER BY|GROUP BY}] (<em><code>index_list</code></em>)
<em><code>index_list</code></em>:
<em><code>index_name</code></em> [, <em><code>index_name</code></em>] ...
</pre>

<p><code>USE INDEX (<em><code>index_list</code></em>)</code>
говорит MySQL использовать только один из названных индексов, чтобы найти
строки в таблице. Альтернативный синтаксис <code>IGNORE INDEX
(<em><code>index_list</code></em>)</code> говорит MySQL
не использовать некоторый индекс или индексы. Эти подсказки полезны, если
<a href="sql.htm#explain"><code>EXPLAIN</code></a> показывает, что MySQL
использует не тот индекс.</p>

<p><code>FORCE INDEX</code> похожа на <code>USE INDEX
(<em><code>index_list</code></em>)</code> с тем дополнением, что сканирование
таблицы очень дорого. Другими словами, сканирование таблицы используется,
только если нет никакого способа использовать один из названных индексов,
чтобы найти строки в таблице.</p>

<p>Каждая подсказка требует названия <span><em>индексов</em></span>, а не
названия столбцов. Чтобы обратиться к первичному ключу, используйте имя
<code>PRIMARY</code>. Чтобы посмотреть имена индексов, используйте
<a href="sql.htm#show-index"><code>SHOW INDEX</code></a>.</p>

<p><em><code>index_name</code></em> не должно быть полным именем индекса.
Это может быть однозначный префикс имени.
Если префикс неоднозначен, ошибка происходит.</p>

<p>Примеры:
<pre>
SELECT * FROM table1 USE INDEX (col1_index,col2_index)
         WHERE col1=1 AND col2=2 AND col3=3;
SELECT * FROM table1 IGNORE INDEX (col3_index)
         WHERE col1=1 AND col2=2 AND col3=3;
</pre>

<p>Синтаксис для индексных подсказок имеет следующие характеристики:</p>
<ul><li><p>Это синтаксически допустимо, чтобы опустить
<em><code>index_list</code></em> для <code>USE INDEX</code>,
что означает <span><span>не использовать индексы</span></span>. Исключение
<em><code>index_list</code></em> для <code>FORCE INDEX</code> или
<code>IGNORE INDEX</code> является ошибкой.</li>

<li>Вы можете определить контекст индексной подсказки, добавляя
<code>FOR</code>. Это обеспечивает более точное управление выбором
оптимизатором плана выполнения относительно различных фаз обработки запроса.
Чтобы затронуть только использование индекса, когда MySQL решает, как найти
строки в таблице и как обработать соединения, надо использовать
<code>FOR JOIN</code>. Чтобы влиять на использование индекса
для сортировки или группировки строк, используют <code>FOR ORDER BY</code>
или <code>FOR GROUP BY</code>.</li>

<li>Вы можете определить много подсказок:
<pre>
SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX FOR ORDER BY (i2) ORDER BY a;
</pre>

<p>Это не ошибка, назвать тот же самый индекс
в нескольких подсказках (даже в пределах той же самой подсказки):
<pre>
SELECT * FROM t1 USE INDEX (i1) USE INDEX (i1,i1);
</pre>

<p>Однако, ошибка смешать <code>USE INDEX</code> и
<code>FORCE INDEX</code> для той же самой таблицы:
<pre>
SELECT * FROM t1 USE INDEX FOR JOIN (i1) FORCE INDEX FOR JOIN (i2);
</pre></li></ul>

<p>Если индексная подсказка не включает <code>FOR</code>,
контекст подсказки должен относиться ко всем частям запроса.
Например, эта подсказка:
<pre>
IGNORE INDEX (i1)
</pre>

<p>эквивалентно этой комбинации подсказок:
<pre>
IGNORE INDEX FOR JOIN (i1)
IGNORE INDEX FOR ORDER BY (i1)
IGNORE INDEX FOR GROUP BY (i1)
</pre>

<p>В MySQL 5.0 контекст подсказки без <code>FOR</code>
должен был примениться только к извлечению строки. Заставить сервер
использовать это более старое поведение, когда нет <code>FOR</code>, можно,
включив переменную <a href="server.htm#sysvar_old"><code>old</code></a>
при запуске сервера. Заботьтесь о включении этой переменной в установке
репликации. С основанным на запрос двоичным журналированием различные режимы
для ведущего и ведомых устройств моут привести к ошибкам.</p>

<p>Когда индексные подсказки обработаны, они собраны в единственном списке
по типу (<a href="sql.htm#use"><code>USE</code></a>,
<code>FORCE</code>, <code>IGNORE</code>) и контексту
(<code>FOR JOIN</code>, <code>FOR ORDER BY</code>,
<code>FOR GROUP BY</code>):
<pre>
SELECT * FROM t1 USE INDEX () IGNORE INDEX (i2)
         USE INDEX (i1) USE INDEX (i2);
</pre>

<p>эквивалентно:
<pre>
SELECT * FROM t1 USE INDEX (i1,i2) IGNORE INDEX (i2);
</pre>

<p>Индексные подсказки применены для каждого контекста в следующем порядке:
</p>
<ol type="1"><li><p><code>{USE|FORCE} INDEX</code> применен, если есть.
В противном случае используется набор индексов, определенный оптимизатором.
</li>

<li><code>IGNORE INDEX</code> применен по результату предыдущего шага.
Например, следующие два запроса эквивалентны:
<pre>
SELECT * FROM t1 USE INDEX (i1) IGNORE INDEX (i2) USE INDEX (i2);
SELECT * FROM t1 USE INDEX (i1);
</pre></li></ol>

<p>Для <code>FULLTEXT</code> индексные подсказки работают так:</p>
<ul><li><p>Для поисков режима естественного языка подсказки, тихо
проигнорированы. Например, <code>IGNORE INDEX(i1)</code>
проигнорирована без предупреждения, а индекс все еще используется.</li>

<li>Для булевых поисков подсказки с <code>FOR ORDER BY</code> или
<code>FOR GROUP BY</code> тихо проигнорированы. Подсказки с
<code>FOR JOIN</code> или без <code>FOR</code> соблюдают. В отличие от того,
как подсказки применяются для не-<code>FULLTEXT</code>, здесь
подсказка используется для всех фаз выполнения запроса (поиск строк
и извлечение, группировка и упорядочивание). Это истина, даже если подсказка
дана для не-<code>FULLTEXT</code>.</p>

<p>Например, следующие два запроса эквивалентны:
<pre>
SELECT * FROM t USE INDEX (index1) IGNORE INDEX (index1) FOR ORDER BY
         IGNORE INDEX (index1) FOR GROUP BY WHERE ... IN BOOLEAN MODE ... ;
SELECT * FROM t USE INDEX (index1) WHERE ... IN BOOLEAN MODE ... ;
</pre></li></ul>

<h3><a name="cost-model"></a>9.9.5. Модель стоимости оптимизатора</h3>
<p>Чтобы произвести планы выполнения, оптимизатор использует модель
стоимости, которая основана на оценках стоимости различных операций, которые
происходят во время выполнения запроса. Оптимизатор имеет ряд <span><span>
констант стоимости</span></span> по умолчанию, чтобы принять решения
относительно планов выполнения.</p>

<p>У оптимизатора также есть база данных смет, чтобы использовать во время
конструкции плана выполнения. Эти оценки сохранены в таблицах
<code>server_cost</code> и <code>engine_cost</code> в системной базе данных
<code>mysql</code> и конфигурируемы в любое время. Намерение этих таблиц
состоит в том, чтобы позволить легко скорректировать сметы, которые
оптимизатор использует, когда пытается достичь планов выполнения запроса.</p>

<h4><a name="cost-model-operation"></a>Модель стоимости</h4>
<p>Конфигурируемые оптимизатором модели стоимости работают так:</p>
<ul><li><p>Сервер читает таблицы модели стоимости в память при запуске и
использует значения в памяти во время выполнения. Любая не-<code>NULL</code>
смета, определенная в таблицах, имеет приоритет перед
постоянной стоимостью по умолчанию. Любая <code>NULL</code>
оценка указывает оптимизатору использовать стоимость по умолчанию.</li>

<li>Во время выполнения сервер может перечитать таблицы стоимости.
Это происходит, когда механизм хранения динамически загружен или когда
выполнен <a href="sql.htm#flush"><code>FLUSH OPTIMIZER_COSTS</code></a>.</li>

<li>Таблицы стоимости позволяют администраторам сервера легко скорректировать
сметы, изменяя записи в таблицах. Также легко вернуться к
значению по умолчанию, устанавливая стоимость в <code>NULL</code>.
Оптимизатор использует значения стоимости в памяти, так что изменения таблиц
должны сопровождаться <a href="sql.htm#flush"><code>FLUSH OPTIMIZER_COSTS
</code></a>.</li>

<li>Сметы в памяти, которые актуальны, когда сеанс клиента начинается,
применяются всюду по этому сеансу, пока это не заканчивается. В частности,
если сервер перечитывает таблицы стоимости, любые измененные оценки
применяются только к впоследствии запущенным сеансам.
Существующие сеансы не затронуты.</li>

<li>Таблицы стоимости являются определенными для данного экземпляра сервера.
Сервер не копирует табличные изменения стоимости ведомым устройствам.
</p></li></ul>

<h4><a name="cost-model-database"></a>База данных модели стоимости</h4>
<p>Образцовая база данных стоимости оптимизатора состоит из двух таблиц в
базе данных <code>mysql</code>, которые содержат информацию о смете для
операций, которые происходят во время выполнения запроса:</p>

<ul><li><p><code>server_cost</code>: Сметы оптимизатора для
общих операций сервера.</li>
<li><code>engine_cost</code>: Сметы оптимизатора для операций, определенных
для особых механизмов хранения.</p></li></ul>

<p>Таблица <code>server_cost</code> содержит эти столбцы:</p>
<ul><li><p><code>cost_name</code></p>
<p>Название сметы используется в модели стоимости. Имя не является
чувствительным к регистру. Если сервер не признает имя стоимости,
когда читает эту таблицу, он пишет предупреждение в журнал ошибок.</li>

<li><code>cost_value</code></p>
<p>Значение сметы. Если значение не-<code>NULL</code>,
сервер использует это в качестве стоимости. Иначе это использует оценку
по умолчанию. DBA может изменить смету, обновляя этот столбец. Если сервер
находит, что значение стоимости недопустимо (неположительно), когда читает
эту таблицу, он пишет предупреждение в журнал ошибок.</p>

<p>Чтобы переопределить смету по умолчанию (для записи, которая определяет
<code>NULL</code>), установите стоимость в не-<code>NULL</code>.
Чтобы вернуться к значению по умолчанию, установите значение в
<code>NULL</code>. Тогда выполните <a href="sql.htm#flush"><code>FLUSH
OPTIMIZER_COSTS</code></a>, чтобы сказать серверу перечитать таблицы.</li>

<li><code>last_update</code></p>
<p>Время последнего обновления строки.</li>
<li><code>comment</code></p>
<p>Описательный комментарий. DBA может использовать этот столбец, чтобы
предоставить информацию о том, почему строка сметы хранит особое значение.
</p></li></ul>

<p>Первичный ключ для <code>server_cost</code> это столбец
<code>cost_name</code>, таким образом, невозможно создать многократные записи
для любой сметы.</p>

<p>Сервер признает значения <code>cost_name</code> для
<code>server_cost</code>:</p>
<ul><li><p><code>disk_temptable_create_cost</code> (по умолчанию 40.0),
<code>disk_temptable_row_cost</code> (1.0).</p>

<p>Сметы для внутренне составленных временных таблиц, сохраненных
в основанном на диске механизме хранения (<code>InnoDB</code> или
<code>MyISAM</code>). Увеличение этих значений увеличивает смету
использования внутренних временных таблиц и заставляет оптимизатор
предпочесть планы запроса с меньшим количеством их использования.
Для информации о таких таблицах см.
<a href="#internal-temporary-tables">раздел 9.4.4</a>.</p>

<p>Большие значения по умолчанию для этих дисковых параметров по
сравнению со значениями по умолчанию для соответствующих параметров памяти
(<code>memory_temptable_create_cost</code>,
<code>memory_temptable_row_cost</code>)
отражают большую стоимость обработки основанных на диске таблиц.</li>

<li><code>key_compare_cost</code> (по умолчанию 0.1).</p>
<p>Стоимость сравнения ключей. Увеличение этого значения вызывает план
запроса, который сравнивает много ключей, чтобы стать более дорогим.
Например, план запроса, который выполняет <code>filesort</code>
становится относительно более дорогим по сравнению с планом запроса, который
избегает сортировать при использовании индексирования.</li>

<li><code>memory_temptable_create_cost</code> (по умолчанию 2.0),
<code>memory_temptable_row_cost</code> (по умолчанию 0.2).</p>
<p>Сметы для внутренне составленных временных таблиц, сохраненных в
<code>MEMORY</code>. Увеличение этих значений увеличивает смету использования
внутренних временных таблиц и заставляет оптимизатор предпочесть планы
запроса с меньшим количеством их использования. Для информации о таких
таблицах см. <a href="#internal-temporary-tables">раздел 9.4.4
</a>.</p>

<p>Меньшие значения по умолчанию для этих параметров по сравнению со
значениями по умолчанию для соответствующих дисковых параметров
(<code>disk_temptable_create_cost</code>,
<code>disk_temptable_row_cost</code>) отражают меньшую стоимость обработки
основанных на памяти таблиц.</li>

<li><code>row_evaluate_cost</code> (по умолчанию 0.2).</p>
<p>Стоимость оценки условий. Увеличение этого значения вызывает план
запроса, который исследует много строк, чтобы стать более дорогим
по сравнению с планом запроса, который исследует меньше строк.
Например, сканирование таблицы становится относительно более дорогим по
сравнению с просмотром диапазона, который читает меньше строк.</p></li></ul>

<p>Таблица <code>engine_cost</code> содержит эти столбцы:</p>
<ul><li><p><code>engine_name</code></p>
<p>Название механизма хранения, к которому применяется эта смета. Имя не
является чувствительным к регистру. Если значение <code>default</code>,
это относится ко всем механизмам хранения, у которых нет никакой собственной
записи. Если сервер не признает имя механизма, когда читает эту таблицу, он
пишет предупреждение журналу ошибок.</li>

<li><code>device_type</code></p>
<p>Тип устройства, к которому применяется эта смета. Столбец предназначен для
того, чтобы определить различные сметы для различных типов устройства
хранения данных, таких как жесткие диски против SSD.
В настоящее время эта информация не используется, 0
единственное разрешенное значение.</li>

<li><code>cost_name</code></p>
<p>То же самое, как в таблице <code>server_cost</code>.</li>
<li><code>cost_value</code></p>
<p>То же самое, как в таблице <code>server_cost</code>.</li>

<li><code>last_update</code></p>
<p>То же самое, как в таблице <code>server_cost</code>.</li>
<li><code>comment</code></p>
<p>То же самое, как в таблице <code>server_cost</code>.</p></li></ul>

<p>Первичный ключ для <code>engine_cost</code> это кортеж, включающий
(<code>cost_name</code>, <code>engine_name</code>, <code>device_type</code>),
таким образом, невозможно создать многократные записи для любой комбинации
значений в тех столбцах.</p>

<p>Сервер признает эти значения <code>cost_name</code>
для <code>engine_cost</code>:</p>
<ul><li><p><code>io_block_read_cost</code> (по умолчанию 1.0)</p>
<p>Стоимость чтения индексирования или блока данных с
диска. Увеличение этого значения вызывает план запроса, который читает много
дисковых блоков, чтобы стать более дорогим по сравнению с планом запроса,
который читает меньше дисковых блоков. Например, сканирование таблицы
становится относительно более дорогим по сравнению с просмотром диапазона,
который читает меньше блоков.</li>

<li><code>memory_block_read_cost</code> (по умолчанию 1.0)</p>
<p>Подобно <code>io_block_read_cost</code>, но представляет стоимость чтения
индексирования или блока данных из буфера базы данных в памяти.</p></li></ul>

<h4><a name="cost-model-database-modifications"></a>
Произведение изменений в базе данных модели стоимости</h4>
<p>Для DBA, кто хочет изменить параметры модели стоимости,
попытайтесь удвоить или разделить на два значение и измерить эффект.</p>

<p>Изменения <code>io_block_read_cost</code> и
<code>memory_block_read_cost</code>, наиболее вероятно, приведут к стоящим
результатам. Эти значения параметра позволяют моделям стоимости для методов
доступа к данным принять во внимание затраты чтения информации из различных
источников, то есть, стоимость чтения информации с диска против чтения
информации уже в буфере памяти. Например, при прочих равных условиях,
установка <code>io_block_read_cost</code> к значению, больше чем
<code>memory_block_read_cost</code> заставляет оптимизатор предпочитать планы
запроса, которые читают информацию, уже имеющуюся в
памяти, планам, которые должны читать с диска.</p>

<p>Этот пример показывает, как изменить значение по умолчанию для
<code>io_block_read_cost</code>:
<pre>
UPDATE mysql.engine_cost SET cost_value = 2.0
       WHERE cost_name = 'io_block_read_cost';
FLUSH OPTIMIZER_COSTS;
</pre>

<p>Этот пример показывает, как изменить значение
<code>io_block_read_cost</code> только для <code>InnoDB</code>:
<pre>
INSERT INTO mysql.engine_cost
       VALUES ('InnoDB', 0, 'io_block_read_cost', 3.0,
               CURRENT_TIMESTAMP, 'Using a slower disk for InnoDB');
FLUSH OPTIMIZER_COSTS;
</pre>

<h3><a name="optimizer-statistics"></a>9.9.6. Статистика оптимизатора</h3>
<p>Таблица <code>column_stats</code> базы данных <code>mysql</code>
разработана, чтобы сохранить статистику о значениях столбцов.</p>

<p>В настоящее время оптимизатор еще не консультируется с
<code>column_stats</code> в ходе выполнения запроса.</p>
<p>У таблицы <code>column_stats</code> есть эти характеристики:</p>

<ul><li><p>Таблица содержит статистику для столбцов всех типов данных,
кроме типов геометрии (пространственные данные) и
<a href="types.htm#json"><code>JSON</code></a>.</li>

<li>Эта таблица делает статистику столбца постоянной так, чтобы они не были
созданы каждый раз, когда сервер запускается.</li>
<li>Таблица использует <code>InnoDB</code>.</li>

<li>Таблица подвергается репликации.</li>
<li>Это предназначено, что обновления <code>column_stats</code>
были выполнены сервером, не пользователями.</p></li></ul>

<p>У таблицы <code>column_stats</code> есть эти столбцы:</p>
<ul><li><p><code>database_name</code>, <code>table_name</code>,
<code>column_name</code>: Названия базы данных, таблицы и столбца, для
которого применяются статистические данные. Эти имена формируют первичный
ключ для строк в <code>column_stats</code>.</li>

<li><code>histogram</code>: Значение <a href="types.htm#json"><code>JSON
</code></a>, описывающее статистику для столбца,
сохраненного как гистограмма.</p></li></ul>

<p><code>column_stats</code> использует
<a href="types.htm#json"><code>JSON</code></a>, чтобы разрешить гибкость в
представлении статистики столбца. Статистические данные для столбца принимают
форму гистограммы, содержащей <span><span>buckets</span></span> для частей
диапазона значений, сохраненных в столбце.</p>

<h2><a name="buffering-caching"></a>9.10. Буферизация и кэширование</h2>
<p>MySQL использует несколько стратегий, которые кэшируют в памяти
информацию, чтобы увеличить производительность.</p>

<h3><a name="innodb-buffer-pool-optimization"></a>9.10.1.
Оптимизация буферного пула InnoDB</h3>
<p><a href="innodb.htm"><code>InnoDB</code></a> поддерживает область
хранения, названную <a href="glossary.htm#glos_buffer_pool">буферным пулом
</a> для того, чтобы кэшировать данные и индексы в памяти. Знание, как
работает пул и использование его в своих интересах, чтобы сохранить данные,
к которым часто получают доступ, в памяти, это важный аспект настройки MySQL.
</p>

<p>Для объяснения внутренних работ пула <code>InnoDB</code> см.
<a href="innodb.htm#innodb-buffer-pool">раздел 16.6.3.1</a>.</p>

<p>Для дополнительной конфигурации пула см. эти разделы:</p>
<ul><li><p><a href="innodb.htm#innodb-performance-read_ahead">16.6.3.5</a>.
</li>
<li><a href="innodb.htm#innodb-performance-adaptive_flushing">16.6.3.6</a>.
</li>

<li><a href="innodb.htm#innodb-performance-midpoint_insertion">16.6.3.4</a>.
</li>
<li><a href="innodb.htm#innodb-multiple-buffer-pools">16.6.3.3</a>.</li>
<li><a href="innodb.htm#innodb-preload-buffer-pool">16.6.3.8</a>.</li>
<li><a href="innodb.htm#innodb-lru-background-flushing">16.6.3.7</a>.</li>
<li><a href="innodb.htm#innodb-buffer-pool-resize">16.6.3.2</a>.</p></li></ul>

<h3><a name="myisam-key-cache"></a>9.10.2. Ключевой кэш MyISAM</h3>
<p>Чтобы минимизировать дисковый ввод/вывод, <code>MyISAM</code>
эксплуатирует стратегию, которая используется многими системами управления
базой данных. Это использует механизм кэша, чтобы сохранить табличные блоки,
к которым наиболее часто получают доступ, в памяти:</p>

<ul><li><p>Для индексных блоков специальная структура, названная
<span>ключевым кэшем</span> (или <span>ключевым буфером</span>)
поддержана. Структура содержит много буферов блоков, где наиболее
используемые индексные блоки помещены.</li>

<li>Для блоков данных MySQL не использует специального кэша.
Вместо этого это полагается на родной кэш файловой
системы операционной системы.</p></li></ul>

<p>Этот раздел сначала описывает основную работу ключевого кэша
<code>MyISAM</code>. Далее это обсуждает особенности, которые улучшают
работу ключевого кэша и позволяют Вам лучше управлять работой кэша:</p>

<ul><li><p>Многократные сеансы могут получить доступ к кэшу одновременно.
</li>
<li>Вы можете настроить многократные ключевые кэши и назначить табличные
индексы к определенным кэшам.</p></li></ul>

<p>Чтобы управлять размером ключевого кэша, используйте переменную
<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code></a>.
Если эта переменная установлена равной 0, никакой ключевой кэш не
используется. Ключевой кэш также не используется, если значение
<a href="server.htm#sysvar_key_buffer_size"><code>key_buffer_size</code></a>
является слишком маленьким, чтобы выделить минимальное число буферов блоков.
</p>

<p>Когда ключевой кэш не работает, к индексным файлам получают доступ,
используя только родную буферизацию файловой системы, обеспеченную
операционной системой. Другими словами, индексные блоки получены, используя
ту же самую стратегию, как для табличных блоков данных.</p>

<p>Индексный блок это непрерывный модуль доступа к индексным файлам
<code>MyISAM</code>. Обычно размер индексного блока равен размеру узлов
индексного B-дерева. Индексы представлены на диске, используя структуру
данных B-дерева. Узлы у основания дерева это узлы листа. Узлы выше узлов
листа это узлы нелиста.</p>

<p>Все блоки буферов в ключевой структуре кэша имеют тот же самый размер.
Этот размер может быть равным, больше чем, или меньше, чем размер индексного
блока таблицы. Обычно эти два значения кратны.</p>

<p>Когда к данным из индексного блока любой таблицы нужно получить доступ,
сервер сначала проверяет, доступно ли это в некотором буфере
ключевого кэша. Если это так, данные ищутся ключевом кэше, а не на диске.
Таким образом, это читает из кэша вместо того, чтобы читать с диска.
Иначе сервер выбирает кэш, содержащий иной индексный блок (или блоки) и
заменяет данные там копией необходимой информации. Как только новый индексный
блок находится в кэше, к индексным данным можно получить доступ.</p>

<p>Если происходит, что блок, выбранный для замены, был изменен, блок считают
<span><span>грязным</span></span>. В этом случае до замены его содержание
сбрасывается на диск.</p>

<p>Обычно сервер следует стратегии <span>LRU (Least Recently Used)</span>:
выбирая блок для замены, это выбирает последний использованный индексный
блок. Чтобы сделать этот выбор легче, ключевой модуль кэша поддерживает все
используемые блоки в специальном списке (<span>LRU chain</span>),
упорядоченный временем использования. Когда к блоку получают доступ, это
используется и помещено в конце списка. Когда блоки должны быть заменены,
блоки в начале списка использованы последними и становятся первыми
кандидатами на выгрузку.</p>

<p><code>InnoDB</code> тоже использует LRU,
чтобы управлять его буферным пулом. См.
<a href="innodb.htm#innodb-buffer-pool">раздел 16.6.3.1</a>.</p>

<h4><a name="shared-key-cache"></a>
9.10.2.1. Совместно используемый ключевой доступ</h4>
<p>Потоки могут обращаться к кэшу ключей одновременно,
согласно следующим условиям:</p>

<ul><li><p>К буферу, который не обновляется, могут получить
доступ много сеансов.</li>
<li>Буфер, который обновляется, заставляет ждать конца обновления.</li>
<li>Многократные сеансы могут начать запросы, которые приводят к заменам
блока кэша, пока они не вмешиваются друг в друга (то есть, пока они нуждаются
в отличающихся индексных блоках, и таким образом заставляют различные блоки
кэша быть замененными).</p></li></ul>
<p>Совместно используемый доступ к ключевому кэшу позволяет серверу
улучшить пропускную способность значительно.</p>

<h4><a name="multiple-key-caches"></a>9.10.2.2. Многократные ключевые кэши
</h4>
<p>Совместно используемый доступ к ключевому кэшу улучшает работу, но не
устраняет проблемы среди сеансов полностью. Они все еще конкурируют за
структуры управления, которые управляют доступом к ключевым буферам кэша.
Чтобы уменьшить проблемы доступа кэша далее, MySQL также обеспечивает
многократные ключевые кэши. Эта опция позволяет назначить
различные индексы различным ключевым кэшам.</p>

<p>Где есть многократные ключевые кэши, сервер должен знать,
который кэш использовать, обрабатывая запросы для данной таблицы
<code>MyISAM</code>. По умолчанию все индексы <code>MyISAM</code>
кэшируются в ключевом кэше значения по умолчанию. Чтобы назначить индекс
к определенному ключевому кэшу, используйте <a href="sql.htm#cache-index">
<code>CACHE INDEX</code></a> (см. <a href="sql.htm#cache-index">раздел
14.7.6.2</a>). Например, следующий запрос назначает индекс от таблиц
<code>t1</code>, <code>t2</code> и <code>t3</code>
к ключевому кэшу <code>hot_cache</code>:
<pre>
mysql&gt; CACHE INDEX t1, t2, t3 IN hot_cache;
+---------+--------------------+----------+----------+
| Table   | Op                 | Msg_type | Msg_text |
+---------+--------------------+----------+----------+
| test.t1 | assign_to_keycache | status   | OK       |
| test.t2 | assign_to_keycache | status   | OK       |
| test.t3 | assign_to_keycache | status   | OK       |
+---------+--------------------+----------+----------+
</pre>

<p>Ключевой кэш, упомянутый в <a href="sql.htm#cache-index"><code>CACHE
INDEX</code></a>, может быть создан, устанавливая его размер с
<a href="sql.htm#set-variable"><code>SET GLOBAL</code></a>
или при использовании опций запуска сервера. Например:
<pre>
mysql&gt; SET GLOBAL keycache1.key_buffer_size=128*1024;
</pre>

<p>Чтобы разрушить ключевой кэш, установите его размер в ноль:
<pre>
mysql&gt; SET GLOBAL keycache1.key_buffer_size=0;
</pre>

<p>Вы не можете разрушить ключевой кэш по умолчанию. Любая попытка сделать
это, будет проигнорирована:
<pre>
mysql&gt; SET GLOBAL key_buffer_size = 0;

mysql&gt; SHOW VARIABLES LIKE 'key_buffer_size';
+-----------------+---------+
| Variable_name   | Value   |
+-----------------+---------+
| key_buffer_size | 8384512 |
+-----------------+---------+
</pre>

<p>Ключевые переменные кэша это структурированные системные переменные, у
которых есть имя и компоненты. Для
<code>keycache1.key_buffer_size</code> <code>keycache1</code>
это имя переменной кэша и <a href="server.htm#sysvar_key_buffer_size"><code>
key_buffer_size</code></a> компонент кэша. См.
<a href="server.htm#structured-system-variables">раздел 6.1.6.1</a>.</p>

<p>По умолчанию индексы назначены на основной (по умолчанию)
ключевой кэш, создаваемый при запуске сервера. Когда ключевой кэш разрушен,
все индексы, назначенные на него, повторно назначены на ключевой
кэш по умолчанию.</p>

<p>Для занятого сервера Вы можете использовать стратегию, которая вовлекает
три ключевых кэша:</p>
<ul><li><p><span><span>hot</span></span>, который занимает 20% места,
выделенного для всех ключевых кэшей. Используйте это для таблиц, которые в
большой степени используются для поисков, но не обновлены.</li>

<li><span><span>cold</span></span>, который занимает 20% места, выделенного
для всех ключевых кэшей. Используйте этот кэш для интенсивно измененных
таблиц среднего размера, таких как временные таблицы.</li>

<li><span><span>warm</span></span>, который занимает 60%
ключевого пространства кэша. Используйте это как ключевой кэш по умолчанию,
чтобы использоваться по умолчанию для всех других таблиц.</p></li></ul>

<p>Одна причина использование трех ключевых кэшей
состоит в том, что доступ к одной ключевой структуре кэша не блокирует
доступ к другим. Запросы, назначенные на один кэш, не конкурируют с
запросами, назначенными на другой кэш. Прирост производительности происходит
также и по другим причинам:</p>

<ul><li><p>Горячий кэш используется только для запросов извлечения,
таким образом, его содержание никогда не изменяется.
Следовательно, всякий раз, когда индексный блок должен быть втянут с диска,
содержание блока кэша, выбранного для замены, не должно сбрасываться.</li>

<li>Для индексирования назначенного на горячий кэш, если нет никаких
запросов, требующих просмотра индекса, есть высокая вероятность, что
блоки, соответствующие узлам нелиста B-дерева, остаются в кэше.</li>

<li>Работа обновления, наиболее часто выполненная для временных таблиц,
выполнена намного быстрее, когда обновленный узел находится в кэше и не
должен быть считан с диска сначала. Если размер индексирования временных
таблиц сопоставим с размером холодного ключевого кэша, вероятность очень
высока, что обновленный узел находится в кэше.</p></li></ul>

<p><a href="sql.htm#cache-index"><code>CACHE INDEX</code></a>
настраивает ассоциацию между таблицей и ключевым кэшем, но ассоциация
потеряна каждый раз при перезапуске сервера. Если Вы хотите, чтобы ассоциация
вступила в силу каждый раз, когда сервер запускается, один способ достигнуть
этого в том, что это должно использовать файл опции: включите
настройки, которые конфигурируют Ваши ключевые кэши, и опцию
<code>init-file</code>, которая называет файл, содержащий
<a href="sql.htm#cache-index"><code>CACHE INDEX</code></a>:
<pre>
key_buffer_size = 4G
hot_cache.key_buffer_size = 2G
cold_cache.key_buffer_size = 2G
init_file=/<em><code>path</code></em>/<em><code>to</code></em>/<em><code>data-directory</code></em>/mysqld_init.sql
</pre>

<p>Запросы в <code>mysqld_init.sql</code> выполнены каждый раз, когда сервер
запускается. Файл должен содержать один запрос SQL на строку. Следующий
пример назначает нескольким таблицам <code>hot_cache</code> и
<code>cold_cache</code>:
<pre>
CACHE INDEX db1.t1, db1.t2, db2.t3 IN hot_cache
CACHE INDEX db1.t4, db2.t5, db2.t6 IN cold_cache
</pre>

<h4><a name="midpoint-insertion"></a>9.10.2.3. Стратегия вставки середины
</h4>
<p>По умолчанию ключевая система управления кэша использует простую
стратегию LRU выбора ключевых блоков кэша, которые будут вычеркнуты, но она
также поддерживает более сложный метод, названный
<span>стратегией вставки середины</span>.</p>

<p>Используя стратегию вставки середины, цепочка LRU разделена на две части:
горячий подсписок и теплый подсписок. Пункт подразделения между двумя частями
не установлен, но ключевая система управления кэша заботится,
что теплая часть не <span><span>слишком короткая</span></span>, всегда
содержащая, по крайней мере,
<a href="server.htm#sysvar_key_cache_division_limit"><code>
key_cache_division_limit</code></a> процент ключевых блоков кэша.
<a href="server.htm#sysvar_key_cache_division_limit"><code>
key_cache_division_limit</code></a> компонент структурированных ключевых
переменных кэша, таким образом, его значение это параметры, которые могут
быть установлены для кэша.</p>

<p>Когда индексный блок считан из таблицы в ключевой кэш, он помещен в конце
теплого подсписка. После определенного числа хитов (доступов к блоку), это
продвинуто в горячий подсписок. В настоящее время число хитов, требуемых,
чтобы продвинуть блок (3), является тем же самым для всех индексных блоков.
</p>

<p>Блок, продвинутый в горячий подсписок, помещен в конце списка. Блок
циркулирует в пределах этого подсписка. Если блок остается в начале подсписка
в течение достаточно долгого времени, это понижено к теплому подсписку. Это
время определено значением <a href="server.htm#sysvar_key_cache_age_threshold">
<code>key_cache_age_threshold</code></a> компонента ключевого кэша.</p>

<p>Пороговое значение предписывает что, для ключевого кэша, содержащего
<em><code>N</code></em> блоков, блок в начале горячего подсписка, не
получивший доступ в пределах последних
<code><em><code>N</code></em> * key_cache_age_threshold / 100</code>
хитов должен быть перемещен в начало теплого подсписка. Это становится первым
кандидатом на вычеркивание, потому что блоки для замены всегда берутся из
начала теплого подсписка.</p>

<p>Стратегия вставки середины позволяет Вам сохранить более ценные
блоки всегда в кэше. Если Вы предпочитаете использовать простую стратегию
LRU, установите <a href="server.htm#sysvar_key_cache_division_limit"><code>
key_cache_division_limit</code></a> к его значению по умолчанию 100.</p>

<p>Стратегия вставки середины помогает улучшить работу, когда выполнение
запроса, который требует эффективного просмотра индекса, продвигает из кэша
все индексные блоки, соответствующие ценным высокоуровневым узлам B-дерева.
Чтобы избежать этого, Вы должны использовать стратегию вставки середины с
<a href="server.htm#sysvar_key_cache_division_limit"><code>
key_cache_division_limit</code></a> намного меньше, чем 100. Тогда ценные
узлы сохранены в горячем подсписке во время работы просмотра индекса.</p>

<h4><a name="index-preloading"></a>9.10.2.4.
Предварительно загруженный индекс</h4>
<p>Если есть достаточно много блоков в ключевом кэше, чтобы разместить
блоки всего индекса или по крайней мере блоки, соответствующие его узлам
нелиста, имеет смысл предварительно загружать ключевой кэш индексными блоками
прежде, чем начать использовать это. Предварительная загрузка позволяет
поместить индексные блоки в ключевой буфер кэша самым эффективным способом:
читая индексные блоки с диска последовательно.</p>

<p>Без предварительной загрузки блоки все еще помещены в ключевой кэш как
необходимо запросам. Хотя блоки останутся в кэше, потому что есть достаточно
много буферов для всех них, они забраны с диска в случайном
порядке, а не последовательно.</p>

<p>Чтобы предварительно загрузить индексирование в кэш, используйте
<a href="sql.htm#load-index"><code>LOAD INDEX INTO CACHE</code></a>.
Например, следующий запрос предварительно загружает узлы индексов таблиц
<code>t1</code> и <code>t2</code>:
<pre>
mysql&gt; LOAD INDEX INTO CACHE t1, t2 IGNORE LEAVES;
+---------+--------------+----------+----------+
| Table   | Op           | Msg_type | Msg_text |
+---------+--------------+----------+----------+
| test.t1 | preload_keys | status   | OK       |
| test.t2 | preload_keys | status   | OK       |
+---------+--------------+----------+----------+
</pre>

<p><code>IGNORE LEAVES</code> заставляет только блоки для узлов нелиста
индекса быть предварительно загруженными. Таким образом, запрос
предварительно загрузит все индексные блоки из <code>t1</code>,
но только блоки для узлов нелиста из <code>t2</code>.</p>

<p>Если индексирование было назначено на ключевой кэш, используя
<a href="sql.htm#cache-index"><code>CACHE INDEX</code></a>, блоки
предварительно загружаются в этот кэш. Иначе индекс загружен в ключевой
кэш по умолчанию.</p>

<h4><a name="key-cache-block-size"></a>9.10.2.5. Ключевой размер блока кэша
</h4>
<p>Возможно определить размер буферов блоков для отдельного ключевого кэша,
используя <a href="server.htm#sysvar_key_cache_block_size"><code>
key_cache_block_size</code></a>. Это разрешает настраивать
исполнение операций ввода/вывода для индексных файлов.</p>

<p>Лучшая работа для операций ввода/вывода достигнута, когда размер буферов
чтения равен размеру родных буферов ввода/вывода операционной системы. Но
установка размера ключевых узлов, равных размеру буфера ввода/вывода, не
всегда гарантирует лучшую эффективность работы.
Читая большие узлы листа, сервер вытягивает в большом количестве ненужные
данные, эффективно предотвращая чтение других узлов листа.</p>

<p>Чтобы управлять размером блоков в индексных файлах <code>.MYI</code>,
используйте опцию <a href="server.htm#option_mysqld_myisam-block-size">
<code>--myisam-block-size</code></a> при запуске сервера.</p>

<h4><a name="key-cache-restructuring"></a>9.10.2.6.
Реструктурирование ключевого кэша</h4>
<p>Ключевой кэш может быть реструктурирован в любое время, обновляя
его значения. Например:
<pre>
mysql&gt; SET GLOBAL cold_cache.key_buffer_size=4*1024*1024;
</pre>

<p>Если Вы назначаете <a href="server.htm#sysvar_key_buffer_size"><code>
key_buffer_size</code></a> или
<a href="server.htm#sysvar_key_cache_block_size"><code>key_cache_block_size
</code></a> ключевому компоненту кэша значение, которое отличается от
текущего значения компонента, сервер разрушает старую структуру кэша и
создает новый, основанный на новых значениях. Если кэш содержит какие-либо
грязные блоки, сервер сохраняет их на диск прежде, чем разрушить и обновить
кэш. Реструктурирование не происходит, если Вы изменяете другие
ключевые параметры кэша.</p>

<p>Реструктурируя ключевой кэш, сервер сначала сбрасывает
содержание любых грязных буферов на диск.
После этого содержание кэша становится недоступным.
Однако, реструктурирование не блокирует запросы, которые должны
использовать индекс, назначенный на кэш. Вместо этого сервер непосредственно
получает доступ к индексам таблицы, используя родное кэширование файловой
системы. Кэширование файловой системы не столь же эффективно, как
использование ключевого кэша, хотя запросы выполняются, замедление может
ожидаться. После того, как кэш был реструктурирован,
это становится доступным снова для кэширования назначенных индексов,
и использование файловой системы для кэширования индексов прекращается.</p>

<h3><a name="query-cache"></a>9.10.3. Кэш запроса MySQL</h3>
<p>Кэш запроса хранит текст <a href="sql.htm#select"><code>SELECT</code></a>
вместе с соответствующим результатом, который послали клиенту.
Если идентичный запрос получен позже, сервер получает результат
запроса из кэша вместо того, чтобы разобрать и выполнить запрос снова.
Кэш запроса совместно использован сеансами, таким образом, набор результатов,
произведенный одним клиентом, можно послать в ответ на тот же самый запрос,
выпущенный другим клиентом.</p>

<p>Кэш запроса может быть полезным в окружающей среде, где у Вас есть
таблицы, которые не изменяются очень часто и для которых сервер получает
много идентичных запросов. Это типичная ситуация для многих веб-серверов,
которые производят много динамических страниц, основанных на
контенте базы данных.</p>

<p>Кэш запроса не возвращает устаревшие данные. Когда таблицы изменены, любые
соответствующие записи в кэше запроса сбрасываются.</p>
<p>Кэш запроса не работает в окружающей среде, где у Вас есть многократные
серверы <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span>
</a>, обновляющие те же самые таблицы <code>MyISAM</code>.</p>

<p>Кэш запроса используется для готовых запросов при условиях, описанных в
<a href="#query-cache-operation">разделе 9.10.3.1</a>.</p>
<p>Кэш запроса не поддержан для разделенных таблиц и автоматически отключен
для запросов, вовлекающих разделенные таблицы. Кэш запроса не может
быть включен для таких запросов.</p>

<p>Некоторые характеристики для кэша запроса приведены ниже.
Эти результаты были произведены, выполняя эталонный набор MySQL на Linux
Alpha 2*500MHz 2GB RAM с кэшем запроса в 64MB.</p>

<ul><li><p>Если все запросы, которые Вы выполняете, просты (такие как выбор
строки из таблицы с одной строкой), но все еще отличаются так, чтобы запросы
не могли кэшироваться, издержки для того, чтобы иметь активный кэш запроса
составляют 13%. Это может быть расценено как худший вариант развития событий.
В действительности запросы имеют тенденцию быть намного более сложными,
таким образом, издержки обычно значительно ниже.</li>

<li>Поиски единственной строки в таблице из единственной строки на 238%
быстрее с кэшем запроса, чем без него. Это может быть расценено как близкое к
минимальному ускорению, которое будет ожидаться для
запроса, который кэшируется.</p></li></ul>

<p>Чтобы отключить кэш запроса при запуске сервера, установите
<a href="server.htm#sysvar_query_cache_size"><code>query_cache_size</code>
</a> в 0.</p>

<p>Кэш запроса предлагает потенциал для существенного исполнительного
усовершенствования, но не предполагайте, что это сделает так при всех
обстоятельствах. С некоторыми конфигурациями кэша запроса или рабочими
нагрузками сервера, Вы могли бы фактически видеть
даже снижение производительности:</p>

<ul><li><p>Будьте осторожны с чрезмерно большим кэшем запроса,
который увеличивает издержки, требуемые, чтобы поддержать кэш, возможно,
сверх выгоды от его включения. Размеры в десятки мегабайтов обычно выгодны.
Размеры в сотни мегабайтов не нужны.</li>

<li>Рабочая нагрузка сервера имеет существенный эффект на эффективность кэша
запроса. Соединение запроса, состоящее почти полностью из фиксированного
набора <a href="sql.htm#select"><code>SELECT</code></a>, намного более
вероятно извлечет выгоду из включения кэшу, чем соединение, в котором частый
<a href="sql.htm#insert"><code>INSERT</code></a> вызывает непрерывное
аннулирование результатов в кэше. В некоторых случаях обходное решение должно
использовать опцию <code>SQL_NO_CACHE</code>, чтобы предотвратить загрузку
данных в кэш для <a href="sql.htm#select"><code>SELECT</code></a>, которые
используют часто изменяемые таблицы. См.
<a href="#query-cache-in-select">раздел 9.10.3.2</a>.
</p></li></ul>

<p>Чтобы проверить, что включение кэша запроса выгодно, проверьте работу
своего сервера MySQL с включенным и отключенным кэшем. Потом повторно
проверяйте периодически, потому что эффективность кэша запроса может
измениться в зависимости от того, как рабочая нагрузка сервера изменяется.
</p>

<h4><a name="query-cache-operation"></a>9.10.3.1. Как кэш запроса работает
</h4>
<p>Этот раздел описывает, как кэш запроса работает, когда это является
операционным. <a href="#query-cache-configuration">Раздел 9.10.3.3
</a> описывает, как управлять, является ли это операционным.</p>

<p>Поступающие запросы сравниваются с кэшем запроса перед парсингом,
таким образом, следующие два запроса расценены как отличающиеся:
<pre>
SELECT * FROM <em><code>tbl_name</code></em>
Select * from <em><code>tbl_name</code></em>
</pre>

<p>Запросы должны быть <span><em>точно</em></span> теми же самыми, чтобы
быть замеченными как идентичные. Кроме того, строки, которые идентичны, могут
быть обработаны как отличающиеся по другим причинам.
Запросы, которые используют различные базы данных, различные версии протокола
или различные наборы символов по умолчанию, считаются различными
запросами и кэшируются отдельно.</p>

<p>Кэш не используется для запросов следующих типов:</p>
<ul><li><p>Запросы, которые являются подзапросом внешнего запроса.</li>
<li>Запросы, выполненные в пределах тела сохраненной функции,
триггера или события.</p></li></ul>

<p>Прежде, чем результат запроса будет принесен из кэша запроса, MySQL
проверяет, имеет ли пользователь привилегию
<a href="sql.htm#select"><code>SELECT</code></a> для всех затронутых баз
данных и таблиц. Если дело обстоит не так, кэшируемый
результат не используется.</p>

<p>Если результат запроса возвращен из кэша запроса, сервер постепенно
увеличивает <a href="server.htm#statvar_Qcache_hits"><code>Qcache_hits</code>
</a>, но не <code>Com_select</code>. См.
<a href="#query-cache-status-and-maintenance">раздел 9.10.3.4</a>.
</p>

<p>Если таблица изменяется, все кэшируемые запросы, которые используют
таблицу, становятся недопустимыми и удалены из кэша. Это включает запросы,
которые используют таблицы <code>MERGE</code>, которые отображаются на
измененную таблицу. Таблица может быть изменена многими типами запросов,
например, <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#drop-table"><code>DROP TABLE</code></a> или
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>.</p>

<p>Кэш запроса также работает в пределах
транзакций, используя <code>InnoDB</code>.</p>
<p>Результат <a href="sql.htm#select"><code>SELECT</code></a>
на представлении кэшируется.</p>

<p>Кэш запроса работает на запросах <code>SELECT SQL_CALC_FOUND_ROWS ...
</code> и хранилит значение, которое возвращено следующим
<code>SELECT FOUND_ROWS()</code>. <a href="funct.htm#function_found-rows">
<code>FOUND_ROWS()</code></a> возвращает правильное значение, даже если
предыдущий запрос был принесен из кэша, потому что число найденных строк
также сохранено в кэше. <code>SELECT FOUND_ROWS()</code>
не может кэшироваться.</p>

<p>Готовые запросы, которые сделаны, используя протокол двоичной синхронной
передачи данных <a href="connect.htm#mysql-stmt-prepare"><code>
mysql_stmt_prepare()</code></a> и
<a href="connect.htm#mysql-stmt-execute"><code>mysql_stmt_execute()</code>
</a> (см. <a href="connect.htm#c-api-prepared-statements">раздел 25.8.8</a>),
подвергаются ограничениям на кэширование. Сравнение с запросами в кэше
запроса основано на тексте запроса после расширения маркеров параметра
<code>?</code>. Запрос сравнен только с другими кэшируемыми запросами,
которые были выполнены, используя протокол двоичной синхронной передачи
данных. Таким образом, в целях кэша запроса подготовленные запросы с
использованием протокола двоичной синхронной передачи данных отличны от
готовых запросов, сделанных, используя текстовый протокол (см.
<a href="sql.htm#sql-syntax-prepared-statements">раздел 14.5</a>).</p>

<p>Запрос не может кэшироваться, если он содержит какую-либо из функций,
показанных в следующей таблице.</p>
<table border="1">
<tbody><tr><td scope="row"><a href="funct.htm#function_aes-decrypt"><code>
AES_DECRYPT()</code></a></td><td><a href="funct.htm#function_aes-encrypt">
<code>AES_ENCRYPT()</code></a></td>
<td><a href="funct.htm#function_benchmark"><code>BENCHMARK()</code></a>
</td></tr>
<tr><td scope="row"><a href="funct.htm#function_connection-id"><code>
CONNECTION_ID()</code></a></td><td><a href="funct.htm#function_convert-tz">
<code>CONVERT_TZ()</code></a></td><td><a href="funct.htm#function_curdate">
<code>CURDATE()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_current-date"><code>
CURRENT_DATE()</code></a></td><td><a href="funct.htm#function_current-time">
<code>CURRENT_TIME()</code></a></td>
<td><a href="funct.htm#function_current-timestamp"><code>CURRENT_TIMESTAMP()
</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_current-user"><code>
CURRENT_USER()</code></a></td><td><a href="funct.htm#function_curtime"><code>
CURTIME()</code></a></td><td><a href="funct.htm#function_database"><code>
DATABASE()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_encrypt"><code>ENCRYPT()
</code></a> with one parameter</td>
<td><a href="funct.htm#function_found-rows"><code>FOUND_ROWS()</code></a>
</td><td><a href="funct.htm#function_get-lock"><code>GET_LOCK()</code></a>
</td></tr>
<tr><td scope="row"><a href="funct.htm#function_is-free-lock"><code>
IS_FREE_LOCK()</code></a></td><td><a href="funct.htm#function_is-used-lock">
<code>IS_USED_LOCK()</code></a></td>
<td><a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()</code>
</a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_load-file"><code>LOAD_FILE()
</code></a></td><td><a href="funct.htm#function_master-pos-wait"><code>
MASTER_POS_WAIT()</code></a></td><td><a href="funct.htm#function_now">
<code>NOW()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_password"><code>PASSWORD()
</code></a></td><td><a href="funct.htm#function_rand"><code>RAND()</code></a>
</td><td><a href="funct.htm#function_random-bytes"><code>RANDOM_BYTES()
</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_release-all-locks"><code>
RELEASE_ALL_LOCKS()</code></a></td>
<td><a href="funct.htm#function_release-lock"><code>RELEASE_LOCK()</code></a>
</td><td><a href="funct.htm#function_sleep"><code>SLEEP()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_sysdate"><code>SYSDATE()
</code></a></td><td><a href="funct.htm#function_unix-timestamp"><code>
UNIX_TIMESTAMP()</code></a> with no parameters</td>
<td><a href="funct.htm#function_user"><code>USER()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_uuid"><code>UUID()</code></a>
</td><td><a href="funct.htm#function_uuid-short"><code>UUID_SHORT()</code>
</a></td><td> </td></tr></tbody></table>

<p>Запрос также не кэшируется при этих условиях:</p>
<ul><li><p>Это обращается к определяемым пользователем функциям (UDF)
или сохраненным функциям.</li>

<li>Это обращается к пользовательским переменным или местным
сохраненным переменным программы.</li>
<li>Это обращается к таблицам в базе данных <code>mysql</code>,
<code>INFORMATION_SCHEMA</code> или <code>performance_schema</code>.</li>

<li>Это обращается к любым разделенным таблицам.</li>
<li>Это имеет любую из следующих форм:
<pre>
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
SELECT ... INTO OUTFILE ...
SELECT ... INTO DUMPFILE ...
SELECT * FROM ... WHERE autoincrement_col IS NULL
</pre>

<p>Последняя форма не кэшируется, потому что она используется в качестве
обходного решения ODBC для того, чтобы получить последнее ID вставки. См.
<a href="connect.htm">главу 25</a>.</p>

<p>Запросы в пределах транзакций с применением уровня изоляции
<a href="innodb.htm#isolevel_serializable"><code>SERIALIZABLE</code></a>
также не могут кэшироваться, потому что они используют блокировку <code>LOCK
IN SHARE MODE</code>.</li>

<li>Это использует таблицы <code>TEMPORARY</code>.</li>
<li>Это не использует таблиц.</li>
<li>Это производит предупреждения.</li>
<li>У пользователя есть привилегия на уровне столбца для любой
из вовлеченных таблиц.</p></li></ul>

<h4><a name="query-cache-in-select"></a>9.10.3.2.
Опции SELECT кэша запроса</h4>
<p>Два запроса, связанные с кэшем, могут быть определены в
<a href="sql.htm#select"><code>SELECT</code></a>:</p>

<ul><li><p><code>SQL_CACHE</code></p>
<p>Результат запроса кэшируется, если это кэшируемо и значение
<a href="server.htm#sysvar_query_cache_type"><code>query_cache_type</code>
</a> <code>ON</code> или <code>DEMAND</code>.</p></li>

<li><p><code>SQL_NO_CACHE</code></p>
<p>Сервер не использует кэш запроса. Это не проверяет кэш запроса,
чтобы видеть, кэшируется ли результат уже, и при этом это
не кэширует результат запроса.</p></li></ul>

<p>Примеры:
<pre>
SELECT SQL_CACHE id, name FROM customer;
SELECT SQL_NO_CACHE id, name FROM customer;
</pre>

<h4><a name="query-cache-configuration"></a>9.10.3.3.
Конфигурация кэша запроса</h4>
<p><a href="server.htm#sysvar_have_query_cache">
<code>have_query_cache</code></a> указывает, доступен ли кэш запроса:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'have_query_cache';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre>
<p>Используя стандартный MySQL, это значение всегда
<code>YES</code>, даже если кэширование запроса отключено.</p>

<p>Несколько других системных переменных управляют работой кэша запроса.
Они могут быть установлены в файле опции или в командной строке, запуская
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.
Системные переменные кэша запроса имеют имена, которые начинаются с
<code>query_cache_</code>. Они описаны кратко в
<a href="server.htm#server-system-variables">разделе 6.1.5</a>.</p>

<p>Чтобы установить размер кэша запроса, установите
<a href="server.htm#sysvar_query_cache_size"><code>query_cache_size</code>
</a>. Установка этого к 0 отключает кэш запроса, что делает установку
<a href="server.htm#sysvar_query_cache_type"><code>query_cache_type=0</code>
</a>. По умолчанию кэш запроса отключен. Это достигнуто, используя размер
значения по умолчанию 1M со значением по умолчанию для
<code>query_cache_type</code> 0.</p>

<p>Чтобы уменьшить издержки значительно, также запустите сервер с
<a href="server.htm#sysvar_query_cache_type"><code>query_cache_type=0</code>
</a>, если Вы не будете использовать кэш запроса.</p>

<p>Используя Windows Configuration Wizard, чтобы установить или
сконфигурировать MySQL, значение по умолчанию для
<a href="server.htm#sysvar_query_cache_size"><code>query_cache_size</code>
</a> будет сконфигурировано автоматически для Вас, основываясь на различных
доступных типах конфигурации. Используя Windows Configuration Wizard,
кэш запроса может быть включен (то есть, установлен в ненулевое значение),
из-за выбранной конфигурации. Кэшем запроса также управляет установка
<a href="server.htm#sysvar_query_cache_type"><code>query_cache_type</code>
</a>. Проверьте значения этих переменных в <code>my.ini</code>.</p>

<p>Когда Вы устанавливаете <a href="server.htm#sysvar_query_cache_size">
<code>query_cache_size</code></a> к ненулевому значению, имейте в виду, что
кэш запроса нуждается в минимальном размере приблизительно 40 КБ, чтобы
выделить его структуры. Точный размер зависит от системной архитектуры.
Если Вы устанавливаете слишком маленькое значение, Вы получите
предупреждение, как в этом примере:
<pre>
mysql&gt; SET GLOBAL query_cache_size = 40000;
Query OK, 0 rows affected, 1 warning (0.00 sec)

mysql&gt; SHOW WARNINGS\G
*************************** 1. row ***************************
  Level: Warning
   Code: 1282
Message: Query cache failed to set size 39936;
 new query cache size is 0

mysql&gt; SET GLOBAL query_cache_size = 41984;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SHOW VARIABLES LIKE 'query_cache_size';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| query_cache_size | 41984 |
+------------------+-------+
</pre>

<p>Для кэша запроса, чтобы фактически быть в состоянии содержать любые
результаты запроса, его размер должен быть установлен больше:
<pre>
mysql&gt; SET GLOBAL query_cache_size = 1000000;
Query OK, 0 rows affected (0.04 sec)

mysql&gt; SHOW VARIABLES LIKE 'query_cache_size';
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| query_cache_size | 999424 |
+------------------+--------+
1 row in set (0.00 sec)
</pre>

<p><a href="server.htm#sysvar_query_cache_size"><code>query_cache_size</code>
</a> выравнивается к самому близкому 1024-байтовому блоку. Значение может
поэтому отличаться от значения, которое Вы назначаете.</p>

<p>Если размер кэша запроса больше 0,
<a href="server.htm#sysvar_query_cache_type"><code>query_cache_type</code>
</a> влияет, как она работает. Эта переменная может быть
установлена в следующие значения:</p>

<ul><li><p><code>0</code> или <code>OFF</code>
предотвращает кэширование или извлечение кэшируемых результатов.</li>
<li><code>1</code> или <code>ON</code>
позволяет кэшировать кроме тех запросов, которые начинаются с
<code>SELECT SQL_NO_CACHE</code>.</li>

<li><code>2</code> или <code>DEMAND</code> включает
кэширование причин только тех запросов, которые начинаются с
<code>SELECT SQL_CACHE</code>.</p></li></ul>

<p>Если <a href="server.htm#sysvar_query_cache_size"><code>query_cache_size
</code></a> = 0, Вы должны также установить
<a href="server.htm#sysvar_query_cache_type"><code>query_cache_type</code>
</a> в 0. В этом случае сервер не приобретает mutex для кэша запроса вообще,
что означает, что кэш запроса не может быть включен во время выполнения.</p>

<p>Установка <code>GLOBAL</code> <a href="server.htm#sysvar_query_cache_type">
<code>query_cache_type</code></a> определяет поведение кэша запроса для всех
клиентов, которые соединяются после того, как изменение произведено.
Отдельные клиенты могут управлять поведением кэша для своего собственного
соединения, устанавливая <code>SESSION</code>
<a href="server.htm#sysvar_query_cache_type"><code>query_cache_type</code>
</a>. Например, клиент может отключить использование кэша запроса для его
собственных запросов так:
<pre>
mysql&gt; SET SESSION query_cache_type = OFF;
</pre>

<p>Если Вы устанавливаете <a href="server.htm#sysvar_query_cache_type"><code>
query_cache_type</code></a> при запуске сервера (а не во время выполнения с
помощью <a href="sql.htm#set-variable"><code>SET</code></a>),
только числовые значения разрешены.</p>

<p>Чтобы управлять максимальным размером отдельных результатов запроса,
которые могут кэшироваться,
<a href="server.htm#sysvar_query_cache_limit"><code>query_cache_limit</code>
</a>. Значение по умолчанию составляет 1 МБ.</p>

<p>Бойтесь устанавливать слишком большой размер кэша. Из-за потребности
потоков в блокировке кэша во время обновлений, Вы можете видеть проблемы
блокировки с очень большим кэшем.</p>

<p>Вы можете установить максимальный размер, который может быть определен для
кэша запроса во время выполнения с помощью
<a href="sql.htm#set-variable"><code>SET</code></a> при использовании
<code>--maximum-query_cache_size=<em><code>32M</code></em></code> в
командной строке или в конфигурационном файле.</p>

<p>Когда запрос должен кэшироваться, его результат (данные, посланные
клиенту), сохранен в кэше запроса во время извлечения результата. Поэтому
данные обычно не обрабатываются в одном большом куске. Кэш запроса выделяет
блоки для того, чтобы хранить эти данные по требованию, так что когда один
блок заполнен, новый блок выделен. Поскольку работа распределения памяти
является дорогостоящей, кэш запроса выделяет блоки с минимальным размером,
заданным <a href="server.htm#sysvar_query_cache_min_res_unit"><code>
query_cache_min_res_unit</code></a>. Когда запрос выполнен, последний блок
результата обрезан к фактическому размеру данных так, чтобы неиспользованная
память была освобождена. В зависимости от типов запросов, которые Ваш сервер
выполняет, Вы могли бы счесть полезным настроить значение
<a href="server.htm#sysvar_query_cache_min_res_unit"><code>
query_cache_min_res_unit</code></a>:</p>

<ul><li><p>Значение по умолчанию
<a href="server.htm#sysvar_query_cache_min_res_unit"><code>
query_cache_min_res_unit</code></a> 4KB.
Это должно быть достаточным для большинства случаев.</li>

<li>Если у Вас есть много запросов с маленькими результатами, размер блока
по умолчанию может привести к фрагментации памяти, как обозначено большим
количеством свободных блоков. Фрагментация может вынудить кэш запроса
сократить (удалять) запросы из кэша из-за нехватки памяти. В этом случае
уменьшите значение <a href="server.htm#sysvar_query_cache_min_res_unit">
<code>query_cache_min_res_unit</code></a>. Число свободных блоков и запросов,
удаленных из-за сокращения, дано значениями
<a href="server.htm#statvar_Qcache_free_blocks"><code>Qcache_free_blocks
</code></a> и <a href="server.htm#statvar_Qcache_lowmem_prunes"><code>
Qcache_lowmem_prunes</code></a>.</li>

<li>Если у большинства Ваших запросов есть большие результаты
(проверьте <a href="server.htm#statvar_Qcache_total_blocks"><code>
Qcache_total_blocks</code></a> и
<a href="server.htm#statvar_Qcache_queries_in_cache"><code>
Qcache_queries_in_cache</code></a>), Вы можете увеличить работу, увеличивая
<a href="server.htm#sysvar_query_cache_min_res_unit"><code>
query_cache_min_res_unit</code></a>. Однако, делайте все возможное не сделать
это слишком большим (см. предыдущий элемент).</p></li></ul>

<h4><a name="query-cache-status-and-maintenance"></a>9.10.3.4.
Состояние кэша запроса и обслуживание</h4>
<p>Чтобы проверить, присутствует ли кэш запроса в Вашем сервере MySQL,
используйте следующий запрос:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'have_query_cache';
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| have_query_cache | YES   |
+------------------+-------+
</pre>

<p>Вы можете дефрагментировать кэш запроса, чтобы лучше использовать его
память с <a href="sql.htm#flush"><code>FLUSH QUERY CACHE</code></a>.
Запрос не удаляет запросы из кэша.</p>

<p><code>RESET QUERY CACHE</code> удаляет все результаты запроса из кэша.
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a>
также делает это.</p>

<p>Чтобы контролировать работу кэша запроса, надо использовать
<a href="sql.htm#show-status"><code>SHOW STATUS</code></a>, чтобы
просмотреть переменные состояния кэша:
<pre>
mysql&gt; SHOW STATUS LIKE 'Qcache%';
+-------------------------+--------+
| Variable_name           | Value  |
+-------------------------+--------+
| Qcache_free_blocks      |     36 |
| Qcache_free_memory      | 138488 |
| Qcache_hits             | 79570  |
| Qcache_inserts          | 27087  |
| Qcache_lowmem_prunes    | 3114   |
| Qcache_not_cached       | 22989  |
| Qcache_queries_in_cache |   415  |
| Qcache_total_blocks     |   912  |
+-------------------------+--------+
</pre>

<p>Описания каждой из этих переменных даны в
<a href="server.htm#server-status-variables">разделе 6.1.7</a>.
Некоторое использование для них описано здесь.</p>

<p>Общее количество запросов <a href="sql.htm#select"><code>SELECT</code></a>
дано этой формулой:
<pre>
  Com_select
+ Qcache_hits
+ queries with errors found by parser
</pre>

<p><code>Com_select</code> дано этой формулой:
<pre>
  Qcache_inserts
+ Qcache_not_cached
+ queries with errors found during the column-privileges check
</pre>

<p>Кэш запроса использует блоки переменной длины, таким образом,
<a href="server.htm#statvar_Qcache_total_blocks"><code>Qcache_total_blocks
</code></a> и <a href="server.htm#statvar_Qcache_free_blocks"><code>
Qcache_free_blocks</code></a> может указать на фрагментацию кэш-памяти.
После <a href="sql.htm#flush"><code>FLUSH QUERY CACHE</code></a>
только единственный свободный блок остается.</p>

<p>Каждый кэшируемый запрос требует минимум двух блоков (один для текста
запроса и один или больше для результатов запроса). Кроме того, каждая
таблица, которая используется запросом, требует одного блока. Однако, если
два или больше запроса используют ту же самую таблицу, только один табличный
блок должен быть выделен.</p>

<p>Информация, предоставленная
<a href="server.htm#statvar_Qcache_lowmem_prunes"><code>
Qcache_lowmem_prunes</code></a>, может помочь Вам настроить размер кэша
запроса. Это считает число запросов, которые были удалены из кэша
для того, чтобы кэшировать новые запросы. Кэш запроса использует стратегию
LRU, чтобы решить, который запрос удалить из кэша. Настройка информации дана
в <a href="#query-cache-configuration">разделе 9.10.3.3</a>.</p>

<h3><a name="statement-caching"></a>9.10.4.
Кэширование готовых запросов и сохраненных программ</h3>
<p>Для определенных запросов, которые клиент мог бы выполнить многократно во
время сеанса, сервер преобразовывает запрос к внутренней структуре и кэширует
структуру, которая будет использоваться во время выполнения.
Кэширование позволяет серверу выступить более эффективно, потому что это
избегает издержек перепреобразования запроса, которое должно быть необходимо
снова во время сеанса. Преобразование и кэширование происходят
для этих запросов:</p>

<ul><li><p>Готовые запросы, обработанные на уровне SQL (используя
(<a href="sql.htm#prepare"><code>PREPARE</code></a>)
и обработанные с использование двоичного протокола клиент-сервер (используя
<a href="connect.htm#mysql-stmt-prepare"><code>mysql_stmt_prepare()</code>
</a> C API). Переменная <a href="server.htm#sysvar_max_prepared_stmt_count">
<code>max_prepared_stmt_count</code></a> управляет общим количеством
запросов, кэшируемых сервером. Это сумма числа готовых запросов всех сеансов.
</li>

<li>Сохраненные программы (хранимые процедуры и функции, триггеры
и события). В этом случае сервер конвертирует и кэширует все тело программы.
<a href="server.htm#sysvar_stored_program_cache"><code>stored_program_cache
</code></a> указывает на приблизительное количество сохраненных программ в
кэше на сеанс.</p></li></ul>

<p>Сервер поддерживает кэши для готовых запросов и сохраненных программ
на основе сеанса. Запросы, кэшируемые для одного сеанса, недоступны для
других сеансов. Когда сеанс заканчивается, сервер отказывается от любых
запросов, кэшируемых для него.</p>

<p>Когда сервер использует кэшируемую внутреннюю структуру запроса,
он должен заботиться, что структура современна. Изменения метаданных могут
произойти для объекта, используемого запросом, вызывая несоответствие между
текущим определением объекта и определением как представлено во внутренней
структуре запроса. Изменения метаданных происходят для запросов DDL, таких
как те, которые создают, удаляют, изменяют, переименовывают или усекают
таблицы, или которые анализируют, оптимизируют или ремонтируют таблицы.
Табличные изменения контента (например, с
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>) не изменяют метаданные и
не делают <a href="sql.htm#select"><code>SELECT</code></a>.</p>

<p>Вот иллюстрация проблемы. Предположите, что клиент готовит этот запрос:
<pre>
PREPARE s1 FROM 'SELECT * FROM t1';
</pre>

<p><code>SELECT *</code> расширяется во внутренней структуре до списка
столбцов в таблице. Если набор столбцов в таблице изменен с <code>ALTER
TABLE</code>, готовый запрос терет актуальность. Если сервер не обнаруживает
это изменение в следующий раз, когда клиент выполняет <code>s1</code>,
готовый запрос возвратит неправильные результаты.</p>

<p>Чтобы избегать проблем, вызванных метаданными,
сервер обнаруживает эти изменения и автоматически повторно готовит запрос,
когда это затем выполнено. Таким образом, сервер повторно разбирает запрос и
восстанавливает внутреннюю структуру. Перепарсинг также происходит
после того, как таблицы или представления, на которые ссылаются, сброшены
из табличного кэша определения неявно, чтобы создать место для новых записей
в кэше, или явно из-за <a href="sql.htm#flush"><code>FLUSH TABLES</code></a>.
</p>

<p>Точно так же, если изменения происходят с объектами, используемыми
сохраненной программой, сервер перепарсит
затронутые запросы в пределах программы.</p>

<p>Сервер также обнаруживает изменения метаданных для объектов в выражениях.
Они могли бы использоваться в запросах, определенных для сохраненных
программ, например, <code>DECLARE CURSOR</code>, или
запросы управления потоками, например,
<a href="sql.htm#if"><code>IF</code></a>,
<a href="sql.htm#case"><code>CASE</code></a> и
<a href="sql.htm#return"><code>RETURN</code></a>.</p>

<p>Чтобы избежать повторно разбирать все сохраненные программы, сервер
повторно разбирает затронутые запросы или выражения в пределах программы
только когда надо. Примеры:</p>

<ul><li><p>Предположите, что метаданные для таблицы или представления
изменены. Перепарсинг происходит для <code>SELECT *</code>
в пределах программы, которая получает доступ к таблице или представлению,
но не для <code>SELECT *</code>, который не получает доступ к
таблице или представлению.</li>

<li>Когда запрос затронут, сервер повторно разбирает его только частично,
если возможно. Рассмотрите этот <a href="sql.htm#case"><code>CASE</code></a>:
<pre>
CASE <em><code>case_expr</code></em>
     WHEN <em><code>when_expr1</code></em> ...
     WHEN <em><code>when_expr2</code></em> ...
     WHEN <em><code>when_expr3</code></em> ...
     ...
END CASE
</pre>

<p>Если изменение метаданных затрагивает только <code>WHEN
<em><code>when_expr3</code></em></code>, то выражение повторно разобрано.
<em><code>case_expr</code></em> и другие <code>WHEN</code>
повторно не разобраны.</p></li></ul>

<p>Перепарсинг использует базу данных значения по умолчанию и режим SQL,
которые были в действительности для оригинального преобразования
во внутреннюю форму.</p>

<p>Сервер пытается повторно разобрать до трех раз.
Ошибка происходит, если все попытки терпят неудачу.</p>
<p>Перепарсинг является автоматическим.</p>

<p>Для готовых запросов
<a href="server.htm#statvar_Com_xxx"><code>Com_stmt_reprepare</code></a>
отслеживает число переприготовлений.</p>

<h2><a name="locking-issues"></a>9.11. Оптимизации операций блокировки</h2>
<p>MySQL управляет контентом для таблиц с использованием
<a href="glossary.htm#glos_locking">блокировки</a>:</p>

<ul><li><p>Внутренняя блокировка выполнена в пределах сервера MySQL
непосредственно, чтобы управлять контентом для таблицы многократными
потоками. Этот тип блокировки является внутренним, потому что это выполнено
полностью сервером и не вовлекает никакие другие программы. См.
<a href="#internal-locking">раздел 9.11.1</a>.</li>

<li>Внешняя блокировка происходит, когда сервер и другие программы блокируют
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>, чтобы
скоординировать между собой, какая программа может получить доступ к
таблицам. См. <a href="#external-locking">раздел 9.11.5</a>.
</p></li></ul>

<h3><a name="internal-locking"></a>9.11.1. Внутренние методы блокировки</h3>
<p>Этот раздел обсуждает внутреннюю блокировку,
то есть, блокировкой, выполненной в пределах сервера MySQL непосредственно,
чтобы управлять табличным содержанием многократными сеансами.
Этот тип блокировки является внутренним, потому что это выполнено полностью
сервером и не вовлекает никакие другие программы. Для того, чтобы блокировать
файлы MySQL другими программами, см. <a href="#external-locking">
раздел 9.11.5</a>.</p>

<h4><a name="idm139965369105952"></a>Блокировка на уровне строки</h4>
<p>MySQL использует <a href="glossary.htm#glos_row_lock">блокировку на
уровне строки</a> для <code>InnoDB</code>, чтобы поддержать одновременную
запись многократными сеансами, делая их подходящими для
многопользовательских, очень параллельных приложений OLTP.</p>

<p>Чтобы избежать <a href="glossary.htm#glos_deadlock">тупиков</a>,
с многократными параллельными операциями записи на <code>InnoDB</code>,
приобретите необходимые блокировки в начале транзакции, запросив
<code>SELECT ... FOR UPDATE</code> для каждой группы строк, которая будет
изменена, даже если запросы изменения данных прибывают позже в транзакцию.
Если транзакции изменяют или блокируют больше, чем одну таблицу, делают
применимые запросы в том же самом порядке в пределах каждой транзакции.
Тупики затрагивают работу вместо того, чтобы представить серьезную ошибку,
потому что <code>InnoDB</code> автоматически
<a href="glossary.htm#glos_deadlock_detection">обнаруживает</a>
условия тупика по умолчанию и откатывает до прежнего уровня одну
из затронутых транзакций.</p>

<p>На системах высокого параллелизма обнаружение тупика может вызвать
замедление, когда многочисленные потоки ждут той же самой блокировки.
Время от времени может быть более эффективно отключить обнаружение тупика и
положиться на настройку <a href="innodb.htm#sysvar_innodb_lock_wait_timeout">
<code>innodb_lock_wait_timeout</code></a> для операционной отмены, когда
тупик происходит. Обнаружение тупика может быть отключено, используя опцию
<a href="innodb.htm#sysvar_innodb_deadlock_detect">
<code>innodb_deadlock_detect</code></a>.</p>

<p>Преимущества блокировки на уровне строки:</p>
<ul><li><p>Меньше блокировки находится в противоречии, когда различные сеансы
просят доступ к различным строкам.</li>

<li>Меньше изменений для отмен.</li>
<li>Возможно блокировать единственную строку в течение долгого времени.
</p></li></ul>

<h4><a name="idm139965369091312"></a>Блокировка на уровне таблицы</h4>
<p>MySQL использует <a href="glossary.htm#glos_table_lock">блокировку на
уровне таблицы</a> для <code>MyISAM</code>, <code>MEMORY</code> и
<code>MERGE</code>, разрешая только одному сеансу обновить те таблицы за один
раз. Этот уровень блокировки делает эти механизмы хранения более подходящими
для однопользовательских приложений, только для чтения или
чтения главным образом.</p>

<p>Эти механизмы хранения избегают
<a href="glossary.htm#glos_deadlock">тупиков</a>, всегда прося все
необходимые блокировки сразу в начале запроса и всегда блокируя таблицы в том
же самом порядке. Проблема состоит в том, что эта стратегия уменьшает
параллелизм: другие сеансы, которые хотят изменить таблицу, должны ждать до
окончания запроса изменения данных.</p>

<p>Преимущества блокировки на уровне таблицы:</p>
<ul><li><p>Относительно маленькая требуемая память (блокировка строки требует
памяти на строку или группу заблокированных строк).</li>

<li>Быстро, когда используется на значительной части таблицы, потому что
только единственная блокировка вовлечена.</li>
<li>Быстро, если Вы часто делаете операции <code>GROUP BY</code>
на значительной части данных или должны часто просматривать всю таблицу.
</p></li></ul>

<p>MySQL допускает, что таблица блокируется на запись так:</p>
<ol type="1"><li><p>Если нет блокировок на таблице, поместить блокировку.
</li>
<li>Иначе вставить запрос блокировки в очередь блокировки.</p></li></ol>

<p>MySQL допускает, что таблица блокируется на чтение так:</p>
<ol type="1"><li><p>Если нет блокировки записи на таблице, поместить
блокировку на чтение.</li>
<li>Иначе поместить запрос блокировки в очередь блокировки чтения.
</p></li></ol>

<p>Табличным обновлениям дают более высокий приоритет, чем табличным
извлечениям. Поэтому, когда блокировка снята, блокировка сделана доступной
для запросов в очереди записи, а уже потом в очереди чтения. Это гарантирует,
что обновления таблицы не <span><span>виснут</span></span>, даже когда там
сложный <a href="sql.htm#select"><code>SELECT</code></a>.
Однако, если есть много обновлений для таблицы,
<a href="sql.htm#select"><code>SELECT</code></a>
ждут, пока нет больше обновлений.</p>
<p>См. <a href="#table-locking">раздел 9.11.2</a>.</p>

<p>Вы можете проанализировать табличные блокировки на своей системе, проверяя
переменные <a href="server.htm#statvar_Table_locks_immediate"><code>
Table_locks_immediate</code></a> и
<a href="server.htm#statvar_Table_locks_waited"><code>Table_locks_waited
</code></a>, которые указывают на число раз, которое запросы табличных
блокировок можно было немедленно предоставить и число раз, которое нужно
было ждать, соответственно:
<pre>
mysql&gt; SHOW STATUS LIKE 'Table%';
+-----------------------+---------+
| Variable_name         | Value   |
+-----------------------+---------+
| Table_locks_immediate | 1151552 |
| Table_locks_waited    | 15324   |
+-----------------------+---------+
</pre>

<p>Таблицы блокировки Performance Schema также предоставляют информацию о
блокировке. См. <a href="perfor.htm#performance-schema-lock-tables">раздел
23.9.12</a>.</p>

<p><code>MyISAM</code> поддерживает параллельные вставки, чтобы уменьшить
задержки: если таблица <code>MyISAM</code> не имеет никаких свободных блоков
в середине файла с данными, строки всегда вставляются в конце файла с
данными. В этом случае Вы можете свободно смешать параллельный
<a href="sql.htm#insert"><code>INSERT</code></a> и
<a href="sql.htm#select"><code>SELECT</code></a> для <code>MyISAM</code>
без блокировок. Таким образом, Вы можете вставить строки в таблицу
<code>MyISAM</code> в то же самое время, когда другие клиенты читают из нее.
Промежутки могут следовать из удаленных или обновленных строк в середине
таблицы. Если есть промежутки, параллельные вставки отключены, но включены
снова автоматически, когда все промежутки были заполнены новыми данными.
Чтобы управлять этим поведением, используйте переменную
<a href="server.htm#sysvar_concurrent_insert"><code>concurrent_insert</code>
</a>, см. <a href="#concurrent-inserts">раздел 9.11.3</a>.</p>

<p>Если Вы приобретаете табличную блокировку явно с
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a>,
Вы можете просить <code>READ LOCAL</code> вместо <code>READ</code>, чтобы
позволить другим сеансам выполнить параллельные вставки в то время, как
Вы заблокировали таблицу.</p>

<p>Выполнить много <a href="sql.htm#insert"><code>INSERT</code></a> и
<a href="sql.htm#select"><code>SELECT</code></a>
на таблице <code>t1</code>, когда параллельные вставки невозможны, Вы можете
вставив строки во временную таблицу <code>temp_t1</code>
и обновив реальную таблицу строками из временной таблицы:
<pre>
mysql&gt; LOCK TABLES t1 WRITE, temp_t1 WRITE;
mysql&gt; INSERT INTO t1 SELECT * FROM temp_t1;
mysql&gt; DELETE FROM temp_t1;
mysql&gt; UNLOCK TABLES;
</pre>

<h4><a name="idm139965369041296"></a>Выбор типа блокировки</h4>
<p>Вообще, табличные блокировки превосходят блокировки на уровне
строки в следующих случаях:</p>

<ul><li><p>Большинство запросов для таблицы это чтение.</li>
<li>Запросы для таблицы это соединение чтений и записей,
где обновления или удаления для единственной строки, которая может быть
принесена с одним ключевым чтением:
<pre>
UPDATE <em><code>tbl_name</code></em> SET <em><code>column</code></em>=<em><code>value</code></em>
       WHERE <em><code>unique_key_col</code></em>=<em><code>key_value</code></em>;
DELETE FROM <em><code>tbl_name</code></em>
       WHERE <em><code>unique_key_col</code></em>=<em><code>key_value</code></em>;
</pre></li>

<li><a href="sql.htm#select"><code>SELECT</code></a> с параллельным
<a href="sql.htm#insert"><code>INSERT</code></a> и очень немногими
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>.</li>

<li>Много просмотров или <code>GROUP BY</code>
на всей таблице без любых записей.</p></li></ul>
<p>С высокоуровневыми блокировками Вы можете более легко настроить
приложения, поддерживая блокировки различных типов, потому что издержки
блокировки меньше, чем для блокировок на уровне строки.</p>

<p>Опции кроме блокировки на уровне строки:</p>
<ul><li><p>Versioning (такой, как используемый в MySQL для параллельных
вставок), где возможно иметь много чтений с одной записью. Это означает, что
база данных или таблица поддерживают другие представления для данных в
зависимости от того, когда доступ начинается. Другие распространенные слова
для этого <span><span>time travel</span></span>, <span><span>copy on write
</span></span> или <span><span>copy on demand</span></span>.</li>

<li>Копия по требованию во многих случаях превосходит блокировку на
уровне строки. Однако, в худшем случае, это может использовать намного
больше памяти, чем использование нормальных блокировок.</li>

<li>Вместо того, чтобы использовать блокировки на уровне строки,
Вы можете использовать блокировки уровня приложения, такие как обеспеченные
функциями <a href="funct.htm#function_get-lock"><code>GET_LOCK()</code></a> и
<a href="funct.htm#function_release-lock"><code>RELEASE_LOCK()</code></a> в
MySQL. Это консультативные блокировки, таким образом, они работают только с
приложениями, которые сотрудничают друг с другом. См.
<a href="funct.htm#miscellaneous-functions">раздел 13.18</a>.</p></li></ul>

<h3><a name="table-locking"></a>9.11.2. Табличные проблемы блокировки</h3>
<p><code>InnoDB</code> использует блокировку на уровне строки так, чтобы
многократные сеансы и приложения могли читать из и писать в ту же самую
таблицу одновременно, не заставляя друг друга ждать. Для этого механизма
хранения избегайте использования <a href="sql.htm#lock-tables"><code>LOCK
TABLES</code></a>, потому что это не предлагает дополнительной защиты, но
вместо этого уменьшает параллелизм. Автоматическая блокировка на уровне
строки делает эти таблицы подходящими для Ваших самых занятых баз данных с
Вашими самыми важными данными, также упрощая логику приложения, так как Вы не
должны заблокировать таблицы.</p>

<p>MySQL использует табличную блокировку (вместо страницы, строки или
блокировки столбца) для всех механизмов хранения, кроме <code>InnoDB</code>.
У операций самой блокировки нет многих издержек. Но потому что только один
сеанс может писать таблицу в любой момент, для лучшей работы с этими другими
механизмами хранения, используйте их прежде всего для таблиц, которые
запрашиваются часто и редко обновляются.</p>

<h4><a name="idm139965369009408"></a>
Исполнительное одобрение соображений InnoDB</h4>
<p>Выбирая, создать ли таблицу <code>InnoDB</code>, имейте в виду следующие
недостатки табличной блокировки:</p>

<ul><li><p>Табличная блокировка позволяет многим сеансам читать из таблицы в
то же самое время, но если сеанс хочет писать таблицу, это должно сначала
получить эксклюзивный доступ, означая, что этому, возможно, придется ждать
других сеансов, чтобы закончить с таблицей сначала. Во время обновления
должны ждать все другие сеансы, которые хотят получить доступ к этой особой
таблице, пока обновление не сделано.</li>

<li><a href="sql.htm#select"><code>SELECT</code></a>, который занимает много
времени, препятствует тому, чтобы другие сеансы обновили таблицу тем
временем, заставляя другие сеансы казаться медленными или безразличными.
В то время как сеанс ждет, чтобы получить эксклюзивный доступ к таблице для
обновлений, другие сеансы, создавшие запрос
<a href="sql.htm#select"><code>SELECT</code></a>,
будут стоять в очереди позади этого, уменьшая параллелизм даже для сеансов
только для чтения.</p></li></ul>

<h4><a name="idm139965369000944"></a>Обходные решения для проблем блокировки
</h4>
<p>Следующие элементы описывают некоторые способы избежать или уменьшить
проблемы, вызванные табличной блокировкой:</p>

<ul><li><p>Рассмотрите переключение таблицы к <code>InnoDB</code> с помощью
<code>CREATE TABLE ... ENGINE=INNODB</code> при создании или через
<code>ALTER TABLE ... ENGINE=INNODB</code> для существующей таблицы. См.
<a href="innodb.htm">главу 16</a>.</li>

<li>Оптимизируйте <a href="sql.htm#select"><code>SELECT</code></a>, чтобы
работать быстрее, чтобы они заблокировали таблицы в течение более короткого
времени. Вам, возможно, придется создать некоторые сводные таблицы,
чтобы сделать это.</li>

<li>Запустите <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> с <a href="server.htm#option_mysqld_low-priority-updates"><code>
--low-priority-updates</code></a>. Для механизмов хранения, которые
используют только блокировку на уровне таблицы (<code>MyISAM</code>,
<code>MEMORY</code> и <code>MERGE</code>), это дает всем запросам обновления
(изменения) таблицы более низкий приоритет, чем
<a href="sql.htm#select"><code>SELECT</code></a>. В этом случае второй
<a href="sql.htm#select"><code>SELECT</code></a>
в предыдущем скрипте выполнился бы перед
<a href="sql.htm#update"><code>UPDATE</code></a> и не ждал бы
завершения первого <a href="sql.htm#select"><code>SELECT</code></a>.</li>

<li>Чтобы определить, что все обновления, выпущенные в определенном
соединении, должны быть сделаны с низким приоритетом, установите
<a href="server.htm#sysvar_low_priority_updates"><code>low_priority_updates
</code></a> в 1.</li>

<li>Чтобы дать определенному <a href="sql.htm#insert"><code>INSERT</code>
</a>, <a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>
более низкий приоритет, используйте параметр <code>LOW_PRIORITY</code>.</li>

<li>Чтобы дать определенному <a href="sql.htm#select"><code>SELECT</code></a>
более высокий приоритет, используйте параметр <code>HIGH_PRIORITY</code>, см.
<a href="sql.htm#select">раздел 14.2.9</a>.</li>

<li>Запустите <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> с низким значением для
<a href="server.htm#sysvar_max_write_lock_count"><code>max_write_lock_count
</code></a>, чтобы вынудить MySQL временно поднять приоритет всех
<a href="sql.htm#select"><code>SELECT</code></a>, которые ждут таблицы после
определенного числа вставок к таблице. Это разрешает блокировки
<code>READ</code> после определенного числа блокировок <code>WRITE</code>.
</li>

<li>Если у Вас есть проблемы с
<a href="sql.htm#insert"><code>INSERT</code></a> в сочетании с
<a href="sql.htm#select"><code>SELECT</code></a>, рассмотрите переключение на
<code>MyISAM</code>, которые поддерживают параллельные
<a href="sql.htm#select"><code>SELECT</code></a> и
<a href="sql.htm#insert"><code>INSERT</code></a>, см.
<a href="#concurrent-inserts">раздел 9.11.3</a>.</li>

<li>Если у Вас есть проблемы с
<a href="sql.htm#select"><code>SELECT</code></a> в сочетании с
<a href="sql.htm#delete"><code>DELETE</code></a>, опция <code>LIMIT</code> в
<a href="sql.htm#delete"><code>DELETE</code></a> может помочь, см.
<a href="sql.htm#delete">раздел 14.2.2</a>.</li>

<li>Испольуйте <code>SQL_BUFFER_RESULT</code> с
<a href="sql.htm#select"><code>SELECT</code></a>. Это может помочь сделать
продолжительность табличных блокировок короче. См.
<a href="sql.htm#select">раздел 14.2.9</a>.</li>

<li>Разделение табличного содержания на отдельные таблицы может помочь,
позволяя запросам работать в одной таблице в то время, как обновления
ограничены столбцами в иной таблице.</li>

<li>Вы можете изменить код блокировки в <code>mysys/thr_lock.c</code>, чтобы
использовать единственную очередь. В этом случае у блокировок чтения и записи
будет тот же самый приоритет, который мог бы помочь некоторым приложениям.
</p></li></ul>

<h3><a name="concurrent-inserts"></a>9.11.3. Параллельные вставки</h3>
<p><code>MyISAM</code> поддерживает параллельные вставки, чтобы уменьшить
проблемы для данной таблицы: если таблица <code>MyISAM</code> не имеет
промежутков в файле с данными (удаленные строки в середине),
<a href="sql.htm#insert"><code>INSERT</code></a> может быть выполнено, чтобы
добавить строки в конец таблицы в то же самое время, когда
<a href="sql.htm#select"><code>SELECT</code></a> читает строки из таблицы.
Если там есть многократные <a href="sql.htm#insert"><code>INSERT</code></a>,
они стоят в очереди и выполнены в последовательности, одновременно с
<a href="sql.htm#select"><code>SELECT</code></a>. Результаты параллельного
<a href="sql.htm#insert"><code>INSERT</code></a>, возможно, не
будут видимы немедленно.</p>

<p><a href="server.htm#sysvar_concurrent_insert"><code>concurrent_insert
</code></a> может быть установлена, чтобы изменить обработку. По умолчанию
переменная установлена в <code>AUTO</code> (1), и параллельные вставки
обработаны, как только что описано. Если
<a href="server.htm#sysvar_concurrent_insert"><code>concurrent_insert</code>
</a> установлена в <code>NEVER</code> (0), параллельные вставки отключены.
Если переменная установлена в <code>ALWAYS</code> (2), параллельные вставки в
конце таблицы разрешены даже для таблиц, которые удалили строки. См. также
описание <a href="server.htm#sysvar_concurrent_insert"><code>
concurrent_insert</code></a>.</p>

<p>Если Вы используете двоичный журнал, параллельные вставки преобразованы в
нормальные вставки для <code>CREATE ... SELECT</code> или
<a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>.
Это сделано, чтобы гарантировать, что Вы можете обновить точную копию своих
таблиц, применяя журнал во время резервной работы. См.
<a href="server.htm#binary-log">раздел 6.4.4</a>.
Кроме того, для тех запросов блокировка чтения добавлена, таким образом,
вставки в эту таблицу заблокированы. Эффект состоит в том, что параллельные
вставки для той таблицы должны ждать также.</p>

<p>С <a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>,
если Вы определяете <code>CONCURRENT</code> с <code>MyISAM</code>, которая
удовлетворяет условие для параллельных вставок (то есть, это не содержит
свободных блоков в середине), другие сеансы может получить данные от таблицы
в то время, как работает <a href="sql.htm#load-data"><code>LOAD DATA</code>
</a>. Использование опции <code>CONCURRENT</code> затрагивает исполнение
<a href="sql.htm#load-data"><code>LOAD DATA</code></a>, даже если никакой
другой сеанс не использует таблицу в то же самое время.</p>

<p>Если Вы определяете <code>HIGH_PRIORITY</code>, это переопределяет эффект
<a href="server.htm#option_mysqld_low-priority-updates"><code>
--low-priority-updates</code></a>, если сервер был запущен с этой опцией.
Это также заставляет параллельные вставки не использоваться.</p>

<p>Для <a href="sql.htm#lock-tables"><code>LOCK TABLE</code></a>
различие между <code>READ LOCAL</code> и <code>READ</code> в том, что
<code>READ LOCAL</code> не конфликтует с
<a href="sql.htm#insert"><code>INSERT</code></a> (параллельные вставки),
в то время, как блокировка проводится. Однако, это не может использоваться,
если Вы собираетесь управлять процессами использования базы данных, внешними
к серверу в то время, как Вы держите блокировку.</p>

<h3><a name="metadata-locking"></a>9.11.4. Блокировка метаданных</h3>
<p>MySQL применяет блокировку метаданных, чтобы управлять параллельным
доступом к объектам базы данных и гарантировать последовательность данных.
Блокировка метаданных применяется не только к таблицам, но также и
к схемам, сохраненным программам (процедуры, функции, триггеры
и намеченные события) и табличным пространствам.</p>

<p>Блокировка метаданных действительно вовлекает некоторые издержки, которые
растут, когда объем запроса увеличивается.
Издержки метаданных увеличиваются больше, когда многократные запросы пытаются
получить доступ к тем же самым объектам.</p>

<p>Блокировка метаданных не замена для табличного кэша, и его mutexes и
блокировки отличаются от <code>LOCK_open</code> mutex.
Следующее обсуждение предоставляет некоторую информацию о том, как
блокировка метаданных работает.</p>

<p>Чтобы гарантировать последовательность транзакции, сервер не должен
разрешить одному сеансу выполнять запрос языка определения данных (DDL) о
таблице, которая используется в незаконченной явно или неявно запущенной
транзакции в другом сеансе. Сервер достигает, это, приобретая блокировки
метаданных на таблицы, используемые в пределах транзакции и снимая их, когда
транзакция заканчивается. Блокировка метаданных предотвращает изменения
структуры таблицы. У этого подхода блокировки есть значение, что таблица,
которая используется транзакцией в пределах одного сеанса, не может
использоваться в запросах DDL другими сеансами, пока
транзакция не заканчивается.</p>

<p>Этот принцип применяется не только к транзакционным таблицам, но также и
к нетранзакционным таблицам. Предположите, что сеанс начинает транзакцию,
которая использует транзакционную таблицу <code>t</code>
и нетранзакционную таблицу <code>nt</code> следующим образом:
<pre>
START TRANSACTION;
SELECT * FROM t;
SELECT * FROM nt;
</pre>

<p>Сервер держит блокировки метаданные обоих <code>t</code> и
<code>nt</code>, пока транзакция не заканчивается. Если другой сеанс делает
попытку DDL или блокировки записи на любой таблице, это блокируется до
выпуска блокировки метаданных. Например, второй сеанс блокируется, если он
делает попытку какой-либо из этих операций:
<pre>
DROP TABLE t;
ALTER TABLE t ...;
DROP TABLE nt;
ALTER TABLE nt ...;
LOCK TABLE t ... WRITE;
</pre>

<p>То же самое поведение применимо для
<a href="sql.htm#lock-tables"><code>LOCK TABLES ... READ</code></a>.
Таким образом, явно или неявно запуск транзакции, которая обновляет
любую таблицу (транзакционную или нетранзакционную) заблокирует и
<code>LOCK TABLES ... READ</code> для той таблицы.</p>

<p>Если сервер приобретает блокировки метаданных на запрос, который
синтаксически допустимо, но терпит неудачу во время выполнения,
он не выпускает блокировки рано. Выпуск блокировки все еще
задержан до конца транзакции, потому что неудавшийся запрос записан в
двоичный журнал, а блокировки защищают последовательность журнала.</p>

<p>В режиме autocommit каждый запрос в действительности полная транзакция,
таким образом, блокировки метаданных, приобретенные на запрос, проводятся
только до конца запроса.</p>

<p>Блокировки метаданных, приобретенные во время
<a href="sql.htm#prepare"><code>PREPARE</code></a>, выпущены
как только запрос был подготовлен, даже если подготовка происходит в пределах
транзакции многократного запроса.</p>

<h3><a name="external-locking"></a>9.11.5. Внешняя блокировка</h3>
<p>Внешняя блокировка это использование блокировки файловой системы, чтобы
управлять сдержимым базы данных <a href="storage.htm#myisam-storage-engine">
<code>MyISAM</code></a> многократными процессами. Внешняя блокировка
используется в ситуациях, где единственный процесс, такой как сервер MySQL,
как может предполагаться, не является единственным процессом, который требует
доступа к таблицам. Вот некоторые примеры:</p>

<ul><li><p>Если Вы выполняете много серверов, которые используют тот же самый
каталог базы данных (не рекомендуется так делать!), каждому серверу нужно
было включить внешнюю блокировку.</li>

<li>Если Вы используете <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a>, чтобы выполнить табличные операции
обслуживания на <a href="storage.htm#myisam-storage-engine"><code>MyISAM
</code></a>, Вы должны гарантировать, что сервер не работает, или что сервер
включил внешнюю блокировку так, чтобы это заблокировало табличные файлы по
мере необходимости, чтобы скоординировать с
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
для доступа к таблицам. То же самое верно для использования
<a href="programs.htm#myisampack"><span><strong>myisampack</strong></span>
</a>.</p>

<p>Если сервер выполнен с внешней включенной блокировкой, Вы можете
использовать <a href="programs.htm#myisamchk"><span><strong>myisamchk
</strong></span></a> в любое время для операций проверки таблицы. В этом
случае, если сервер попытается обновить таблицу, которую использует
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>,
сервер будет ждать, пока <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a> закончит работу.</p>

<p>Если Вы используете <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a> для записи, например, для ремонта таблиц,
Вы <span><em>должны</em></span> всегда гарантировать, что
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
не использует таблицу. Если Вы не останавливаете
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>,
по крайней мере, сделайте
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-tables
</strong></span></a> перед <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a>. Если сервер и
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
будут писать таблицы вместе, ничем хорошим это не кончится.</p></li></ul>

<p>С внешней блокировкой каждый процесс, который требует доступа к таблице,
приобретает блокировку файловой системы на табличные файлы прежде, чем
продолжить получать доступ к таблице. Если все необходимые блокировки не
могут быть приобретены, процесс заблокирован на доступ к таблице,
пока блокировки не могут быть получены (после того, как процесс, который в
настоящее время держит блокировки, освобождает их).</p>

<p>Внешняя блокировка затрагивает работу сервера, потому что сервер должен
иногда ждать других процессов прежде, чем это сможет
получить доступ к таблицам.</p>

<p>Внешняя блокировка является ненужной, если Вы выполняете единственный
сервер, чтобы получить доступ к каталогу определенных данных (что является
обычным случаем), и если никакие другие программы, такие как
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
не должны изменить таблицы, в то время как сервер работает. Если Вы только
<span><em>читаете</em></span> таблицы другими программами, внешняя блокировка
не требуется, хотя <a href="programs.htm#myisamchk"><span><strong>myisamchk
</strong></span></a> мог бы сообщить о предупреждениях, если сервер изменяет
таблицы, в то время как <a href="programs.htm#myisamchk"><span><strong>
myisamchk</strong></span></a> читает их.</p>

<p>С внешней отключенной блокировкой, чтобы использовать
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>,
Вы должны или остановить сервер, в то время как
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>
выполняется или иначе блокировать и сбросить таблицы прежде, чем выполнить
<a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span></a>.
См. <a href="../../../dev.mysql.com/doc/refman/5.7/en/system-optimiz.htm"
target="_top">System Factors</a>. Чтобы избежать этого требования,
используйте <a href="sql.htm#check-table"><code>CHECK TABLE</code></a> и
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a> для
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>.</p>

<p>Для <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
внешней блокировкой управляет значение
<a href="server.htm#sysvar_skip_external_locking"><code>skip_external_locking
</code></a>. Когда эта переменная включена, внешняя блокировка отключена и
наоборот. Внешняя блокировка отключена по умолчанию.</p>

<p>Использованием внешней блокировки можно управлять при запуске сервера при
использовании опции <a href="server.htm#option_mysqld_external-locking">
<code>--external-locking</code></a> или
<a href="server.htm#option_mysqld_external-locking">
<code>--skip-external-locking</code></a>.</p>

<p>Если Вы действительно используете внешнюю опцию блокировки, чтобы включить
обновления <a href="storage.htm#myisam-storage-engine"><code>MyISAM</code>
</a> от многих процессов MySQL, Вы должны гарантировать, что
следующие условия удовлетворены:</p>

<ul><li><p>Не используйте кэш запроса для запросов, которые используют
таблицы, которые обновлены другим процессом.</li>
<li>Не запускайте сервер с опцией
<a href="server.htm#option_mysqld_delay-key-write"><code>
--delay-key-write=ALL</code></a> или используйте опцию таблицы
<code>DELAY_KEY_WRITE=1</code> для любых совместно используемых таблиц.
Иначе может произойти повреждение индекса.</p></li></ul>

<p>Самый легкий способ удовлетворить эти условия состоит в том, чтобы
всегда использовать <a href="server.htm#option_mysqld_external-locking">
<code>--external-locking</code></a> с
<a href="server.htm#option_mysqld_delay-key-write"><code>
--delay-key-write=OFF</code></a> и
<a href="server.htm#sysvar_query_cache_size"><code>--query-cache-size=0
</code></a>. Это не сделано по умолчанию, потому что во многих установках
полезно иметь смесь предыдущих опций.</p>

<h2><a name="optimizing-server"></a>9.12. Оптимизация MySQL Server</h2>
<p>Этот раздел обсуждает методы оптимизации для сервера базы данных,
прежде всего имея дело с системной конфигурацией вместо того,
чтобы настроить запросы SQL. Информация в этом разделе является подходящей
для DBA, кто хочет гарантировать работу и масштабируемость через серверы,
которыми они управляют, для разработчиков, создающих скрипт установки,
которые включают базы данных, и выполнение MySQL непосредственно для
развития, тестирования и так далее для тех, кто хочет максимизировать
их собственную производительность.</p>

<h3><a name="disk-issues"></a>9.12.1. Оптимизация дискового I/O</h3>
<p>Этот раздел описывает способы сконфигурировать устройства хранения данных,
когда Вы можете посвятить больше и более быстрые аппаратные средства хранения
серверу базы данных. Для информации об оптимизации <code>InnoDB</code>, чтобы
улучшить работу ввода/вывода см.
<a href="#optimizing-innodb-diskio">раздел 9.5.8</a>.</p>

<ul><li><p>Дисковые поиски огромное исполнительное узкое место. Эта проблема
становится более очевидной, когда объем данных начинает становиться настолько
большим, что эффективное кэширование становится невозможным.
Для больших баз данных, где Вы получаете доступ к данным более или менее
беспорядочно, Вы можете убедиться, что нуждаетесь по крайней мере в одном
диске для чтения и нескольких для записи. Чтобы минимизировать эту проблему,
применяйте диски с низким временем поиска.</li>

<li>Увеличьте число доступных дисков (и таким образом, уменьшите издержки
поиска) или создайте символические ссылки файлам к различным дискам:</p>
<ul><li><p>Символические ссылки</p>
<p>Это означает для <code>MyISAM</code>, что Вы создаете
символьную ссылку на индексный файл и файлы с данными от их обычного
местоположения в каталоге данных к другому диску. Это делает времена
поиска и чтения лучше, предполагая, что диск не используется в других целях
также. См. <a href="#symbolic-links">раздел 9.12.2</a>.</p>

<p>Символические ссылки не поддержаны для использования с
<code>InnoDB</code>. Однако, Вы можете создать табличное пространство
<a href="glossary.htm#glos_file_per_table">file-per-table</a>
в местоположении за пределами каталога данных MySQL, используя параметр
<code>DATA DIRECTORY = <em><code>absolute_path_to_directory</code></em>
</code> в <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.
См. <a href="innodb.htm#tablespace-placing">раздел 16.7.5</a>.
<a href="glossary.htm#glos_general_tablespace">Общие табличные пространства
</a> могут также быть созданы в местоположении за пределами каталога данных
MySQL. Для получения дополнительной информации см.
<a href="innodb.htm#general-tablespaces">раздел 16.7.9</a>.</li>

<li>Striping</p>
<p>Striping подразумевает, что Вы имеете много дисков и помещаете первый блок
на первый диск, второй блок на второй диск и <em><code>N</code></em>-й блок
на диск (<code><em><code>N</code></em> MOD <em><code>number_of_disks</code>
</em></code>). Это означает, что если Ваш нормальный размер данных меньше,
чем размер полосы (или отлично выровнен), Вы получаете намного лучшую работу.
Striping очень зависит от операционной системы и размера полосы, так
определите эффективность своего приложения с различными размерами полосы. См.
<a href="#custom-benchmarks">раздел 9.13.2</a>.</p>

<p>Скорость для striping <span><em>очень зависит</em></span>
от параметров. В зависимости от того, как Вы устанавливаете
параметры и число дисков, Вы можете измерить различия на порядки величин.
Вы должны оптимизировать для случайного или последовательного доступа.
</p></li></ul></li>

<li>Для надежности Вы можете хотеть использовать RAID 0+1 (striping плюс
зеркало), но в этом случае Вы нуждаетесь в 2*<em><code>N</code></em> дисках
для хранения <em><code>N</code></em> блоков данных. Это, вероятно, наилучший
вариант, если у Вас есть деньги для него. Однако, Вам, вероятно, также
придется вложить капитал в некоторое программное обеспечение управления,
чтобы обработать это эффективно.</li>

<li>Хорошая опция должна изменить уровень RAID согласно тому, насколько
важный тип данных использован. Например, храните полуважные данные, которые
могут быть восстановлены, на RAID 0, но храните действительно важные данные,
такие как информация об узле, на RAID 0+1 или RAID <em><code>N</code></em>.
RAID <em><code>N</code></em> может быть проблемой, если Вы имеете, много
записей из-за времени, требуемого, чтобы обновить биты четности.</li>

<li>Вы можете также установить параметры для файловой системы,
которую использует база данных:</p>
<p>Если Вы не должны знать, когда файлы были в последний раз использованы,
Вы можете установить свои файловые системы с опцией <code>-o noatime</code>.
Это пропускает обновления последнего времени доступа в inodes
на файловой системе.</p>

<p>На многих операционных системах Вы можете установить файловую систему,
которая будет обновлена асинхронно, устанавливая это с опцией <code>-o
async</code>. Если Ваш компьютер разумно устойчив, это должно дать Вам лучшую
работу, не жертвуя слишком большой надежностью.
Этот флаг идет по умолчанию в Linux.</p></li></ul>

<h3><a name="symbolic-links"></a>9.12.2. Использование символических ссылок
</h3>
<p>Вы можете переместить базы данных или таблицы от каталога базы данных
в другое место и заменить их символическими ссылками к новым местоположениям.
Вы могли бы хотеть сделать это, например, чтобы переместить базу данных в
файловую систему с большим свободным пространством или увеличить скорость
Вашей системы, распространяя Ваши таблицы к различным дискам.</p>

<p>Для <code>InnoDB</code> используйте <code>DATA DIRECTORY</code> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
вместо символических ссылок, как объяснено в
<a href="innodb.htm#tablespace-placing">разделе 16.7.5</a>.</p>

<p>Чтобы определить местоположение Вашего каталога данных,
используйте этот запрос:
<pre>
SHOW VARIABLES LIKE 'datadir';
</pre>

<h4><a name="symbolic-links-to-databases"></a>9.12.2.1.
Используя символические ссылки для баз данных по Unix</h4>
<p>В Unix надо создать каталог на некотором диске, где у Вас есть свободное
место и затем создать мягкую ссылку к этому из каталога данных MySQL.
<pre>
shell&gt; mkdir /dr1/databases/test
shell&gt; ln -s /dr1/databases/test <em><code>/path/to/datadir</code></em>
</pre>

<p>MySQL не поддерживает соединение одного каталога
к многократным базам данных. Замена каталога базы данных с символической
ссылкой работает, пока Вы не делаете символическую ссылку между базами
данных. Предположите, что у Вас есть база данных <code>db1</code>
в соответствии с каталогом данных MySQL, и затем сделайте символьную ссылку
<code>db2</code>, которая указывает на <code>db1</code>:
<pre>
shell&gt; cd <em><code>/path/to/datadir</code></em>
shell&gt; ln -s db1 db2
</pre>

<p>Результат состоит в том, что любая таблица <code>tbl_a</code> в
<code>db1</code>, также является таблицей
<code>tbl_a</code> в <code>db2</code>. Если один клиент обновляет
client updates <code>db1.tbl_a</code>, а другой клиент обновляет
updates <code>db2.tbl_a</code>, проблемы, вероятно, произойдут.</p>

<h4><a name="symbolic-links-to-tables"></a>9.12.2.2.
Используя символические ссылки для таблиц MyISAM на Unix</h4>
<p>Символьные ссылки полностью поддержаны только для <code>MyISAM</code>.
Для файлов, используемых таблицами для других механизмов хранения, Вы можете
получить странные проблемы, если Вы пытаетесь использовать символические
ссылки. Для <code>InnoDB</code> используйте альтернативный метод,
объясненный в <a href="innodb.htm#tablespace-placing">разделе 16.7.5</a>.</p>

<p>Не делайте таблицы символьной ссылки на системах, у которых нет полностью
рабочего вызова <code>realpath()</code>. Linux и Solaris поддерживают
<code>realpath()</code>. Чтобы определить, поддерживает ли Ваша система
символические ссылки, проверьте значение переменной
<a href="server.htm#sysvar_have_symlink"><code>have_symlink</code></a>:
<pre>
SHOW VARIABLES LIKE 'have_symlink';
</pre>

<p>Обработка символических ссылок для <code>MyISAM</code>
работает следующим образом:</p>
<ul><li><p>В каталоге данных у Вас всегда есть файлы данных
(<code>.MYD</code>) и индекса (<code>.MYI</code>).
Они могут быть перемещены в другое место и заменены в каталоге
данных символьными ссылками.</li>

<li>Вы можете сделать символьной ссылкой файл с данными и индексный файл
независимо к различным каталогам.</li>
<li>Чтобы проинструктировать рабочий сервер MySQL выполнять работу со
ссылками, используйте опции <code>DATA DIRECTORY</code> и
<code>INDEX DIRECTORY</code> в <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a>. См. <a href="sql.htm#create-table">раздел 14.1.15</a>.
Альтернативно, если <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> не работает, эффект может быть достигнут вручную,
используя <span><strong>ln -s</strong></span> в командной строке.</p>

<p>Путь, используемый с <code>DATA
DIRECTORY</code> и <code>INDEX DIRECTORY</code>, возможно, не включает
каталог MySQL <code>data</code> (Bug #32167).</p></li>

<li><a href="programs.htm#myisamchk"><span><strong>myisamchk</strong></span>
</a> не заменяет символьную ссылку файлом с данными или индексным файлом. Это
работает непосредственно над файлом, на который указывает символьная ссылка.
Любые временные файлы создаются в каталоге, где файл с данными или индексный
файл расположены. То же самое верно для
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a> и
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>.</p></li>

<li>Когда Вы удаляете таблицу, которая использует символьные ссылки, удалены
<span><em>символьная ссылка и файл, на который она указывает</em></span>.
Это чрезвычайно серьезное основание <span><em>не</em></span> выполнять
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
как <code>root</code> или системный пользователь с доступом на запись к
каталогам базы данных MySQL.</li>

<li>Если Вы переименовываете таблицу с <a href="sql.htm#alter-table"><code>
ALTER TABLE ... RENAME</code></a> или <a href="sql.htm#rename-table"><code>
RENAME TABLE</code></a> и Вы не перемещаете таблицу в другую базу данных,
символьные ссылки в каталоге базы данных переименованы к новым именам,
файл с данными и индексный файл переименованы соответственно.</li>

<li>Если Вы используете  <a href="sql.htm#alter-table"><code>ALTER TABLE
... RENAME</code></a> или <a href="sql.htm#rename-table"><code>RENAME TABLE
</code></a>, чтобы переместить таблицу в другую базу данных, таблица
перемещена в другой каталог базы данных. Если имя таблицы изменилось,
символьные ссылки в новом каталоге базы данных переименованы к новым именам,
файл с данными и индексный файл переименованы соответственно.</li>

<li>Если Вы не используете символьные ссылки, запустите
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a> с
опцией <a href="server.htm#option_mysqld_symbolic-links"><code>
--skip-symbolic-links</code></a>, чтобы гарантировать, что никто не может
использовать <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a>, чтобы удалить или переименовать файл за
пределами каталога данных.</p></li></ul>

<p>Эти табличные операции для символьной ссылки не поддержаны:</p>
<ul><li><p><a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
игнорирует <code>DATA DIRECTORY</code> и <code>INDEX DIRECTORY</code>.
</p></li></ul>

<h4><a name="windows-symbolic-links"></a>9.12.2.3.
Используя символические ссылки для баз данных в Windows</h4>
<p>В Windows символические ссылки могут использоваться для каталогов базы
данных. Это позволяет Вам поместить каталог базы данных в иное место
(например, на ином диске), настраивая символическую ссылку. Использование
символьных ссылок базы данных в Windows подобно их использованию в Unix,
хотя процедура для того, чтобы настроить ссылку отличается.</p>

<p>Предположите, что Вы хотите поместить каталог для названной базы данных
<code>mydb</code> в <code>D:\data\mydb</code>.
Чтобы сделать это, создайте символическую ссылку в каталоге данных MySQL,
которая указывает на <code>D:\data\mydb</code>.
Однако, прежде, чем создать символическую ссылку, удостоверьтесь, что
<code>D:\data\mydb</code> существует, создавая это в случае необходимости.
Если Вы уже назвали каталог базы данных <code>mydb</code> в каталоге данных,
переместите это в <code>D:\data</code>. Иначе символическая ссылка будет
неэффективна. Чтобы избежать проблем, удостоверьтесь, что сервер не работает,
когда Вы перемещаете каталог базы данных.</p>

<p>Windows Vista, Windows Server 2008 и новее
имеют родную поддержку символической ссылки, таким образом, Вы можете создать
символьную ссылку, используя <span><strong>mklink</strong></span>.
Эта команда требует административных привилегий.</p>

<ol type="1"><li><p>Перейдите в каталог данных:
<pre>
C:\&gt; cd <em><code>\path\to\datadir</code></em>
</pre></li>

<li><p>В каталоге данных создайте ссылку <code>mydb</code>,
которая указывает на местоположение каталога базы данных:
<pre>
C:\&gt; mklink /d mydb D:\data\mydb
</pre></li></ol>
<p>После этого все таблицы в базе данных <code>mydb</code>
создаются в <code>D:\data\mydb</code>.</p>

<h3><a name="optimizing-memory"></a>9.12.3. Оптимизация использования памяти
</h3>
<h4><a name="memory-use"></a>9.12.3.1. Как MySQL использует память</h4>
<p>MySQL выделяет буферы и кэши, чтобы улучшить исполнение операций базы
данных. Конфигурация значения по умолчанию разработана, чтобы позволить
MySQL Server запускаться на виртуальной машине, у которой есть приблизительно
512 МБ RAM. Вы можете улучшить работу MySQL, увеличивая значения кэша и
связанных с буфером системных переменных. Вы можете также изменить
конфигурацию по умолчанию, чтобы выполнить MySQL на
системах с ограниченной памятью.</p>

<p>Следующий список описывает некоторые из способов, которыми MySQL
использует память. Где применимо, на соответствующие системные переменные
ссылаются. Некоторые элементы определены для механизмов хранения.</p>

<ul><li><p>Буферный пул <code>InnoDB</code> область памяти, которая
кэширует данные для таблиц, индексов и другие вспомогательные буферы.
Для эффективности большого объема операций буферный пул разделен на
<a href="glossary.htm#glos_page">страницы</a>, которые могут потенциально
держать много строк. Для эффективности управления кэшем буферный пул
осуществлен как связанный список страниц, данные, которые редко используются,
удаляются из кэша, используя измененный алгоритм
<a href="glossary.htm#glos_lru">LRU</a>. См.
<a href="innodb.htm#innodb-buffer-pool">раздел 16.6.3.1</a>.</p>

<p>Размер буферного пула важен для системной работы.</p>
<ul><li><p>Как правило, рекомендуют сконфигурировать
<a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> к 50-75 процентам системной памяти.</li>

<li><code>InnoDB</code> выделяет память для всего буферного пула при запуске
сервера. Распределение памяти выполнено <code>malloc()</code>.
Буферный размер пула определен опцией
<a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a>.
<a href="innodb.htm#sysvar_innodb_buffer_pool_size"><code>
innodb_buffer_pool_size</code></a> может быть сконфигурирован динамически, в
то время как сервер работает. Для получения дополнительной информации см.
<a href="innodb.htm#innodb-buffer-pool-resize">раздел 16.6.3.2</a>.</li>

<li>На системах с большим объемом памяти Вы можете улучшить параллелизм,
деля буферный пул на многократные
<a href="glossary.htm#glos_buffer_pool_instance">экземпляры</a>.
Число экземпляров буферного пула определено опцией
<a href="innodb.htm#sysvar_innodb_buffer_pool_instances"><code>
innodb_buffer_pool_instances</code></a>.</li>

<li>Буферный пул, который является слишком небольшим, может вызвать
чрезмерное взбалтывание, поскольку страницы сбрасываются
из буферного пула только, чтобы загрузиться снова немного позже.</li>
<li>Буферный пул, который является слишком большим,
может вызвать свопинг из-за соревнования за память.</p></li></ul></li>

<li><a href="perfor.htm">MySQL Performance Schema</a>
это особенность контроля выполнения сервера MySQL на низком уровне.
Performance Schema динамически выделяет память с приращением, масштабируя ее
к фактической загрузке сервера, вместо того, чтобы выделить требуемую память
во время запуска сервера. Как только память выделена, она не освобождена,
пока сервер не перезапущен. Для получения дополнительной информации см.
<a href="perfor.htm#performance-schema-memory-model">раздел 23.14</a>.</li>

<li>Все потоки совместно используют кэш ключей
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>,
его размер определен <a href="server.htm#sysvar_key_buffer_size"><code>
key_buffer_size</code></a>. Другие буферы, используемые сервером, выделены,
когда необходимо. См. <a href="server.htm#server-configuration">раздел 6.1.1
</a>.</p>

<p>Для каждой открытой таблицы <code>MyISAM</code>
индексный файл открыт однажды, файл с данными открыт однажды для каждого
рабочего потока. Для каждого параллельного потока выделены: структуры
таблицы, структуры столбца для каждого столбца и буфер размера <code>3 *
<em><code>N</code></em></code> (здесь <em><code>N</code></em> это
максимальная длина строки, не учитывая <a href="types.htm#blob"><code>BLOB
</code></a>). Столбец <a href="types.htm#blob"><code>BLOB</code></a>
требует пяти-восьми байтов плюс длина данных
<a href="types.htm#blob"><code>BLOB</code></a>. <code>MyISAM</code>
поддерживает один дополнительный буфер строки для внутреннего пользования.
</li>

<li>Каждый поток, который используется, чтобы управлять соединениями клиента,
использует некоторое определенное для потока пространство. Следующий список
указывает на них и какие переменные управляют размером:</p>

<ul><li><p>Стек (<a href="server.htm#sysvar_thread_stack"><code>
thread_stack</code></a>).</li>
<li>Буфер соединения (<a href="server.htm#sysvar_net_buffer_length"><code>
net_buffer_length</code></a>).</li>
<li>Буфер результата (<a href="server.htm#sysvar_net_buffer_length"><code>
net_buffer_length</code></a>).</p></li></ul>

<p>Буфер соединения и результата начинают с размера, равного
<a href="server.htm#sysvar_net_buffer_length"><code>net_buffer_length</code>
</a>, но динамически увеличены до
<a href="server.htm#sysvar_max_allowed_packet"><code>max_allowed_packet
</code></a> по мере надобности. Буфер результата сжимается к
<a href="server.htm#sysvar_net_buffer_length"><code>net_buffer_length</code>
</a> после каждого запроса SQL. В то время как запрос работает, копия текущей
строки запроса также выделена.</p>

<p>Каждый поток соединения использует память для вычислительных
обзоров запроса (см. <a href="perfor.htm#performance-schema-statement-digests">
раздел 23.7</a>): <a href="server.htm#sysvar_max_digest_length"><code>
max_digest_length</code></a> байт на сеанс.</li>

<li>Все потоки совместно используют ту же самую основную память.</li>
<li>Когда поток больше не необходим, память, выделенная ему, освобождена
и возвращена к системе, если поток не возвращается в кэш потока. В этом
случае память остается выделенной.</li>

<li><a href="server.htm#sysvar_myisam_use_mmap"><code>myisam_use_mmap</code>
</a> может быть установлена в 1, чтобы включить отображение памяти для
всех таблиц <code>MyISAM</code>.</li>

<li>Каждый запрос, который выполняет последовательный просмотр таблицы,
выделяет <span>буфер чтения</span>
(<a href="server.htm#sysvar_read_buffer_size"><code>read_buffer_size</code>
</a>).</li>

<li>Читая строки в произвольной последовательности (например, после
сортировки) <span>буфер случайного чтения</span>
(<a href="server.htm#sysvar_read_rnd_buffer_size"><code>read_rnd_buffer_size
</code></a>) может быть выделен, чтобы избежать дисковых поисков.</li>

<li>Для просмотров <code>InnoDB</code>, когда оптимизатор читает много строк,
буфер записей может быть выделен, чтобы уменьшить издержки
навигации B-дерева и блокировок.</li>

<li>Все соединения выполнены в единственном проходе,
большинство соединений может обойтись без использования временной таблицы.
Большинство временных таблиц это основанные на памяти хэш-таблицы. Временные
таблицы с большой длиной строки (вычислена как сумма всех длин столбца) или
таблицы, которые содержат <a href="types.htm#blob"><code>BLOB</code></a>,
сохранены на диске.</p>

<p>Если внутренняя временная таблица в памяти становится слишком большой,
MySQL обрабатывает это автоматически, изменяя таблицу в памяти до формата на
диске, обработанного механизмом хранения, определенным
<a href="server.htm#sysvar_internal_tmp_disk_storage_engine"><code>
internal_tmp_disk_storage_engine</code></a>.
Вы можете увеличить допустимый временный табличный размер как описано в
<a href="#internal-temporary-tables">разделе 9.4.4</a>.</p>

<p>Для таблиц <a href="storage.htm#memory-storage-engine"><code>MEMORY</code>
</a> явно составленных с <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a>, только <a href="server.htm#sysvar_max_heap_table_size"><code>
max_heap_table_size</code></a> определяет, на сколько таблице разрешают
вырасти, нет никакого преобразования в формат на диске.</li>

<li>Большинство запросов, которые выполняют сортировку, выделяют буфер
и от ноля до двух временных файлов, в зависимости от размера набора
результатов. См. <a href="error.htm#temporary-files">раздел B.5.3.5</a>.</li>

<li>Почти весь парсинг и вычисление сделаны в местных потоках
и пулах памяти многократного использования. Никакая память не необходима для
мелочей, таким образом, нормального медленного распределения памяти и
освобождения избегают. Память выделена только для неожиданно больших строк.
</li>

<li>Для каждого столбца <a href="types.htm#blob"><code>BLOB</code></a>
буфер увеличен динамически, чтобы читать значение
<a href="types.htm#blob"><code>BLOB</code></a>.
Если Вы просматриваете таблицу, выделен буфер, столь же большой, как самое
большое значение <a href="types.htm#blob"><code>BLOB</code></a>.</li>

<li>MySQL требует памяти и описателей для табличного кэша. Структуры
обработчиков для всех используемых таблиц сохранены в табличном кэше и
управляются как <span><span>First In, First Out</span></span> (FIFO).
Начальный табличный размер кэша определен
<a href="server.htm#sysvar_table_open_cache"><code>table_open_cache</code>
</a>, см. <a href="#table-cache">раздел 9.4.3.1</a>.</p>

<p>MySQL также требует памяти для табличного кэша определений. Переменная
<a href="server.htm#sysvar_table_definition_cache"><code>
table_definition_cache</code></a> определяет число табличных определений,
которые могут быть сохранены в табличном кэше определений.
Если Вы используете большое количество таблиц, Вы можете создать большой
табличный кэш определений, чтобы ускорить открытие таблиц. Табличный кэш
определений занимает меньше места и не использует описатели файла, в отличие
от табличного кэша.</li>

<li><a href="sql.htm#flush"><code>FLUSH TABLES</code></a> или
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin
flush-tables</strong></span></a>
закрывают все таблицы, которые не находятся в использовании,
и отмечает все таблицы в использовании, которые будут закрыты, когда в
настоящее время выполняющийся поток заканчивается.
Это наиболее эффективно освобождает память.
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a>
не возвращается, пока все таблицы не закрыты.</li>

<li>Сервер кэширует в памяти результаты
<a href="sql.htm#grant"><code>GRANT</code></a>,
<a href="sql.htm#create-user"><code>CREATE USER</code></a>,
<a href="sql.htm#create-server"><code>CREATE SERVER</code></a> и
<a href="sql.htm#install-plugin"><code>INSTALL PLUGIN</code></a>.
Эта память не освобождена соответствующими
<a href="sql.htm#revoke"><code>REVOKE</code></a>,
<a href="sql.htm#drop-user"><code>DROP USER</code></a>,
<a href="sql.htm#drop-server"><code>DROP SERVER</code></a> и
<a href="sql.htm#uninstall-plugin"><code>UNINSTALL PLUGIN</code></a>, таким
образом, для сервера, который выполняет много таких запросов
будет увеличение использования памяти. Эта память может быть освобождена
через <a href="sql.htm#flush"><code>FLUSH PRIVILEGES</code></a>.
</p></li></ul>

<p><span><strong>ps</strong></span> и другие системные программы состояния
могут сообщить, что <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a> использует большую память. Это может быть вызвано
стеками потока на различных адресах памяти. Например, версия Solaris
<span><strong>ps</strong></span> считает неиспользованную память между
стеками как используемую. Чтобы проверить это, проверьте доступную память с
<code>swap -s</code>. Мы проверяем <a href="programs.htm#mysqld"><span>
<strong>mysqld</strong></span></a>
с несколькими датчиками утечки памяти, таким образом не должно быть
никаких утечек памяти.</p>

<h5><a name="monitor-mysql-memory-use"></a>
Контроль использования памяти MySQL</h5>
<p>Следующий пример демонстрирует, как использовать
<a href="perfor.htm">Performance Schema</a> и
<a href="sys.htm">sys schema</a>, чтобы отследить использование памяти MySQL.
</p>

<p>Большинство инструментовки памяти Performance Schema
отключено по умолчанию. Инструменты могут быть включены, обновляя
столбец <code>ENABLED</code> в таблице Performance Schema
<a href="perfor.htm#setup-instruments-table"><code>setup_instruments</code>
</a>. У инструментов памяти есть имена в форме
<code>memory/<em><code>code_area</code></em>/<em><code>instrument_name</code>
</em></code>, где <em><code>code_area</code></em> значение вроде
<code>sql</code> или <code>innodb</code>, а
<em><code>instrument_name</code></em> это конкретный инструмент.</p>

<ol type="1"><li><p>Чтобы рассмотреть доступные инструменты памяти MySQL,
запросите таблицу Performance Schema
<a href="perfor.htm#setup-instruments-table"><code>setup_instruments</code>
</a>. Следующий запрос возвращает сотни инструментов памяти для
всех областей кода.
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_instruments
    -&gt;          WHERE NAME LIKE '%memory%';
</pre>

<p>Вы можете сузить результаты, определяя область кода.
Например, Вы можете ограничить результаты <code>InnoDB</code>, определяя
<code>innodb</code> как область кода.
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_instruments
    -&gt;          WHERE NAME LIKE '%memory/innodb%';
+-------------------------------------------+---------+-------+
| NAME                                      | ENABLED | TIMED |
+-------------------------------------------+---------+-------+
| memory/innodb/adaptive hash index         | NO      | NO    |
| memory/innodb/buf_buf_pool                | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |
| memory/innodb/dict_stats_index_map_t      | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |
| memory/innodb/other                       | NO      | NO    |
| memory/innodb/row_log_buf                 | NO      | NO    |
| memory/innodb/row_merge_sort              | NO      | NO    |
| memory/innodb/std                         | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |
...
</pre>

<p>В зависимости от Вашей установки MySQL, области кода могут включать
<code>performance_schema</code>,
<code>sql</code>, <code>client</code>,
<code>innodb</code>, <code>myisam</code>,
<code>csv</code>, <code>memory</code>, <code>blackhole</code>,
<code>archive</code>, <code>partition</code> и другие.</li>

<li>Чтобы включить инструменты памяти, добавьте правило
<code>performance-schema-instrument</code> к своему конфигурационному файлу
MySQL. Например, чтобы включить все инструменты памяти, добавьте это правило
к своему конфигурационному файлу и перезапустите сервер:
<pre>
performance-schema-instrument='memory/%=COUNTED'
</pre>

<p>Включение инструментов памяти при запуске гарантирует,
что распределения памяти, которые происходят при запуске, посчитаны.</p>
<p>После перезапуска сервера столбец
<code>ENABLED</code> таблицы Performance Schema
<a href="perfor.htm#setup-instruments-table"><code>setup_instruments</code>
</a> должен сообщить <code>YES</code> для инструментов памяти, которые Вы
включали. Столбец <code>TIMED</code> в таблице
<a href="perfor.htm#setup-instruments-table"><code>setup_instruments</code>
</a> проигнорирован для инструментов памяти, потому что операции
памяти не рассчитаны.
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_instruments
    -&gt;          WHERE NAME LIKE '%memory/innodb%';
+-------------------------------------------+---------+-------+
| NAME                                      | ENABLED | TIMED |
+-------------------------------------------+---------+-------+
| memory/innodb/adaptive hash index         | NO      | NO    |
| memory/innodb/buf_buf_pool                | NO      | NO    |
| memory/innodb/dict_stats_bg_recalc_pool_t | NO      | NO    |
| memory/innodb/dict_stats_index_map_t      | NO      | NO    |
| memory/innodb/dict_stats_n_diff_on_level  | NO      | NO    |
| memory/innodb/other                       | NO      | NO    |
| memory/innodb/row_log_buf                 | NO      | NO    |
| memory/innodb/row_merge_sort              | NO      | NO    |
| memory/innodb/std                         | NO      | NO    |
| memory/innodb/trx_sys_t::rw_trx_ids       | NO      | NO    |
...
</pre></li>

<li><p>В этом примере инструментальные данные о памяти запрошены в
таблице Performance Schema
<a href="perfor.htm#memory-summary-tables">
<code>memory_summary_global_by_event_name</code></a>, которая суммирует
данные <code>EVENT_NAME</code>. <code>EVENT_NAME</code> это имя инструмента.
</p>

<p>Следующий запрос возвращает данные о памяти для буферного пула
<code>InnoDB</code>. См.
<a href="perfor.htm#memory-summary-tables">раздел 23.9.15.9</a>.
<pre>
mysql&gt; SELECT * FROM performance_schema.memory_summary_global_by_event_name
    -&gt;          WHERE EVENT_NAME LIKE 'memory/innodb/buf_buf_pool'\G
EVENT_NAME: memory/innodb/buf_buf_pool
 COUNT_ALLOC: 1
COUNT_FREE: 0
   SUM_NUMBER_OF_BYTES_ALLOC: 137428992
SUM_NUMBER_OF_BYTES_FREE: 0
  LOW_COUNT_USED: 0
CURRENT_COUNT_USED: 1
 HIGH_COUNT_USED: 1
LOW_NUMBER_OF_BYTES_USED: 0
CURRENT_NUMBER_OF_BYTES_USED: 137428992
   HIGH_NUMBER_OF_BYTES_USED: 137428992
</pre>

<p>Те же самые основные данные могут быть запрошены, используя схему
<a href="sys.htm"><code>sys</code></a>, таблицу
<a href="sys.htm#sys-memory-global-by-current-bytes">
<code>memory_global_by_current_bytes</code></a>,
которая показывает текущее использование памяти в пределах сервера глобально.
<pre>
mysql&gt; SELECT * FROM sys.memory_global_by_current_bytes
    -&gt;          WHERE event_name LIKE 'memory/innodb/buf_buf_pool'\G
*************************** 1. row ***************************
 event_name: memory/innodb/buf_buf_pool
current_count: 1
current_alloc: 131.06 MiB
current_avg_alloc: 131.06 MiB
 high_count: 1
 high_alloc: 131.06 MiB
   high_avg_alloc: 131.06 MiB
</pre>

<p>Этот запрос схемы <a href="sys.htm"><code>sys</code></a>
агрегирует в настоящее время выделенную память
(<code>current_alloc</code>) областью кода:
<pre>
mysql&gt; SELECT SUBSTRING_INDEX(event_name,'/',2) AS
    -&gt;        code_area, sys.format_bytes(SUM(current_alloc))
    -&gt;        AS current_alloc FROM sys.x$memory_global_by_current_bytes
    -&gt;        GROUP BY SUBSTRING_INDEX(event_name,'/',2)
    -&gt;        ORDER BY SUM(current_alloc) DESC;
+---------------------------+---------------+
| code_area                 | current_alloc |
+---------------------------+---------------+
| memory/innodb             | 843.24 MiB    |
| memory/performance_schema | 81.29 MiB     |
| memory/mysys              | 8.20 MiB      |
| memory/sql                | 2.47 MiB      |
| memory/memory             | 174.01 KiB    |
| memory/myisam             | 46.53 KiB     |
| memory/blackhole          | 512 bytes     |
| memory/federated          | 512 bytes     |
| memory/csv                | 512 bytes     |
| memory/vio                | 496 bytes     |
+---------------------------+---------------+
</pre>
<p>См. <a href="sys.htm">главу 24</a>.</p></li></ol>

<h4><a name="large-page-support"></a>9.12.3.2.
Включение поддержки большой страницы</h4>
<p>Немногие архитектуры аппаратных средств/операционной системы поддерживают
страницы памяти, больше чем значение по умолчанию (обычно 4 КБ). Фактическое
выполнение этой поддержки зависит от используемого оборудования и
операционной системы. Приложения, которые выполняют много доступов к памяти,
могут получить исполнительные улучшения при использовании больших страниц
из-за уменьшенного Translation Lookaside Buffer (TLB).</p>

<p>В MySQL большие страницы могут использоваться InnoDB, чтобы выделить
память для буферного пула и дополнительного пула памяти.</p>
<p>Стандартное использование больших страниц в MySQL пытается использовать
самый большой поддержанный размер, до 4 МБ. В соответствии с
Solaris <span><span>super large pages</span></span>
включает использование страниц до 256 МБ. Эта особенность доступна для
недавних платформ SPARC. Это может быть включено или отключено при
использовании <a href="server.htm#option_mysqld_super-large-pages"><code>
--super-large-pages</code></a> или
<a href="server.htm#option_mysqld_super-large-pages">
<code>--skip-super-large-pages</code></a>.</p>

<p>MySQL также поддерживает выполнение Linux большой поддержки страницы
(который называют HugeTLB в Linux).</p>
<p>Прежде, чем большие страницы могут использоваться в Linux,
ядру нужно позволить поддержать их, и необходимо сконфигурировать пул памяти
HugeTLB. См. файл <code>Documentation/vm/hugetlbpage.txt</code> в
исходных текстах Linux.</p>

<p>Ядро для некоторых недавних систем, таких как Red Hat Enterprise Linux,
имеет поддержку этой функции, включенную по умолчанию. Чтобы проверить,
является ли это истиной для Вашего ядра, используйте следующую команду и
ищите выходные строки, содержащие <span><span>huge</span></span>:
<pre>
shell&gt; cat /proc/meminfo | grep -i huge
HugePages_Total: 0
HugePages_Free:0
HugePages_Rsvd:0
HugePages_Surp:0
Hugepagesize: 4096 kB
</pre>

<p>Непустой вывод команды указывает, что поддержка большой страницы
присутствует, но нулевые значения указывают, что никакие страницы не
сконфигурированы для использования.</p>

<p>Если Ваше ядро должно быть реконфигурировано, чтобы поддержать большие
страницы, консультируйтесь с файлом <code>hugetlbpage.txt</code>.</p>
<p>Предполагая, что Вашему ядру Linux включили поддержку большой страницы,
сконфигурируйте это для использования MySQL, используя следующие команды.
Обычно Вы вставляете их в файл <code>rc</code> или эквивалентный файл
запуска, который выполнен во время системной последовательности загрузки,
чтобы команды выполнялись каждый раз, когда система запускается.
Команды должны выполнить в последовательности загрузки прежде, чем сервер
MySQL запустится. Убедитесь, что изменили числа распределения и групповое
число, как надо для Вашей системы.
<pre>
# Set the number of pages to be used.
# Each page is normally 2MB, so a value of 20 = 40MB.
# This command actually allocates memory, so this much
# memory must be available.
echo 20 &gt; /proc/sys/vm/nr_hugepages

# Set the group number that is permitted to access this
# memory (102 in this case). The mysql user must be a
# member of this group.
echo 102 &gt; /proc/sys/vm/hugetlb_shm_group

# Increase the amount of shmem permitted per segment
# (12G in this case).
echo 1560281088 &gt; /proc/sys/kernel/shmmax

# Increase total amount of shared memory.  The value
# is the number of pages. At 4KB/page, 4194304 = 16GB.
echo 4194304 &gt; /proc/sys/kernel/shmall
</pre>

<p>Для MySQL Вы обычно хотите значение
<code>shmmax</code> близко к значению <code>shmall</code>.</p>
<p>Чтобы проверить конфигурацию страницы, надо проверить
<code>/proc/meminfo</code>, как описано ранее. Теперь Вы должны видеть
некоторые ненулевые значения:
<pre>
shell&gt; cat /proc/meminfo | grep -i huge
HugePages_Total:20
HugePages_Free: 20
HugePages_Rsvd:0
HugePages_Surp:0
Hugepagesize: 4096 kB
</pre>

<p>Заключительный шаг, чтобы использовать
<code>hugetlb_shm_group</code> должен дать пользователю
<code>mysql</code> значение <span><span>unlimited</span></span>
для предела memlock. Это может быть сделано, редактируя
<code>/etc/security/limits.conf</code> или добавляя следующую команду к
Вашему <a href="programs.htm#mysqld-safe"><span><strong>mysqld_safe</strong>
</span></a>:
<pre>
ulimit -l unlimited
</pre>

<p>Добавление <span><strong>ulimit</strong></span> в
<a href="programs.htm#mysqld-safe"><span><strong>mysqld_safe</strong></span>
</a> вызывает пользователя <code>root</code>, чтобы установить предел memlock
в <code>unlimited</code> прежде, чем переключиться на пользователя
<code>mysql</code>. Это предполагает, что
<a href="programs.htm#mysqld-safe"><span><strong>mysqld_safe</strong></span>
</a> запущен как <code>root</code>.</p>

<p>Поддержка большой страницы в MySQL отключена по умолчанию. Чтобы включить,
запустите сервер с опцией <a href="server.htm#option_mysqld_large-pages">
<code>--large-pages</code></a>. Например, Вы можете использовать следующие
строки в своем <code>my.cnf</code>:
<pre>
[mysqld]
large-pages
</pre>

<p>С этой опцией <code>InnoDB</code> использует большие страницы
автоматически для его буферного пула и дополнительного пула памяти. Если
<code>InnoDB</code> не может сделать этого, это отступает к использованию
традиционной памяти и пишет предупреждение в журнал ошибок:
<span>Warning: Using conventional memory pool</span>.</p>

<p>Чтобы проверить, что большие страницы используются, надо проверить
файл <code>/proc/meminfo</code>:
<pre>
shell&gt; cat /proc/meminfo | grep -i huge
HugePages_Total:20
HugePages_Free: 20
HugePages_Rsvd:2
HugePages_Surp:0
Hugepagesize: 4096 kB
</pre>

<h3><a name="optimizing-network"></a>9.12.4.
Оптимизация сетевого использования</h3>
<h4><a name="connection-threads"></a>9.12.4.1.
Как MySQL использует потоки для соединений клиента</h4>
<p>Менеджер соединений распараллеливает запросы соединения клиента
на сетевых интерфейсах, которые сервер слушает. На всех платформах один поток
менеджера обрабатывает запросы соединения TCP/IP. В Unix этот поток менеджера
также обрабатывает запросы соединения файла сокета Unix. В Windows поток
менеджера обрабатывает запросы соединения совместно используемой памяти и
именованного канала. Сервер не создает потоки, чтобы обработать интерфейсы,
которые он не слушает. Например, в Windows сервер, у которого нет поддержки
соединений именованного канала, не создает поток, чтобы обработать их.</p>

<p>Менеджер соединений распараллеливает каждое соединение клиента с потоком,
который ведет обработку аутентификации и запросов для того соединения. Потоки
менеджера создают новую ветвь когда необходимо, но пытаются избежать этого,
работая с кэшем потока сначала, чтобы видеть, содержит ли он поток, который
может использоваться для соединения. Когда соединение заканчивается, его
поток возвращен к кэшу потока, если кэш не полон.</p>

<p>В этой модели потока соединения есть так много потоков, сколько
клиентов в настоящее время работают. У этого есть некоторые недостатки, когда
рабочая нагрузка сервера должна масштабироваться, чтобы обработать большие
количества соединений. Например, создание потока становятся дорогими.
Кроме того, каждый поток требует серверных и ядерных ресурсов, таких как
пространство стека. Чтобы приспособить большое количество одновременных
соединений, размер стека на поток должен быть сохранен маленьким, приводя к
ситуации, где это является слишком маленьким или сервер потребляет
большие объемы памяти. Истощение других ресурсов может произойти также, и
планирование может стать существенным.</p>

<p>Чтобы управлять и контролировать, как сервер управляет потоками, которые
обрабатывают соединения клиента, несколько систем и переменных состояния
релевантны. См. разделы
<a href="server.htm#server-system-variables">6.1.5</a> и
and <a href="server.htm#server-status-variables">6.1.7</a>.</p>

<p>Кэшу потока определили размер
<a href="server.htm#sysvar_thread_cache_size"><code>thread_cache_size</code>
</a>. Значение по умолчанию 0 (никакого кэширования) заставляет поток быть
настроенным для каждого нового соединения. Установка
<a href="server.htm#sysvar_thread_cache_size"><code>thread_cache_size</code>
</a> в <em><code>N</code></em> включает <em><code>N</code></em>
кжширование бездействующих соединений.
<a href="server.htm#sysvar_thread_cache_size"><code>thread_cache_size</code>
</a> может быть установлен при запуске сервера или изменен в то время, как
сервер работает. Поток соединения становится бездействующим, когда соединение
клиента, с которым он был связан, заканчивается.</p>

<p>Чтобы контролировать число потоков в кэше и сколько потоков было создано,
потому что поток не мог быть взят от кэша, следите за переменными
<a href="server.htm#statvar_Threads_cached"><code>Threads_cached</code></a> и
<a href="server.htm#statvar_Threads_created"><code>Threads_created</code></a>.
</p>

<p>Вы можете установить <a href="server.htm#sysvar_max_connections"><code>
max_connections</code></a> при запуске сервера или во время выполнения, чтобы
управлять максимальным количеством клиентов, которые
могут соединиться одновременно.</p>

<p>Когда стек потока является слишком маленьким, это ограничивает сложность
запросов SQL, которые сервер может обработать, глубину рекурсии хранимых
процедур и другие потребляющие память действия.
Чтобы установить размер стека в <em><code>N</code></em> байт для каждого
потока, запустите сервер с <a href="server.htm#sysvar_thread_stack"><code>
--thread_stack=<em><code>N</code></em></code></a>.</p>

<h4><a name="host-cache"></a>9.12.4.2. Оптимизация поиска DNS</h4>
<p>MySQL поддерживает кэш узла в памяти, который содержит информацию о
клиентах: IP-адрес, имя хоста и информацию об ошибке. Сервер использует этот
кэш для нелокальных соединений TCP. Это не использует кэш для соединений TCP,
установленных, используя кольцевой интерфейс
(<code>127.0.0.1</code> или <code>::1</code>) или
для соединений, установленных, используя файл сокета Unix,
именованный канал или совместно используемую память.</p>

<p>Для каждого нового соединения клиента сервер использует IP-адрес клиента,
чтобы проверить, есть ли имя хоста клиента в кэше узла. В противном случае
сервер пытается решить имя хоста. Сначала это решает IP-адрес к имени
хоста и решает имя хоста назад к IP-адресу. Тогда это сравнивает результат с
оригинальным IP-адресом, чтобы гарантировать, что это то же самое. Сервер
хранит информацию о результате этой работы в кэше узла. Если кэш полон,
от последней использованной записи отказываются.</p>

<p>Таблица <a href="perfor.htm#host-cache-table">
<code>host_cache</code></a> Performance Schema
выставляет содержание кэша узла так, чтобы это могло быть исследовано,
используя <a href="sql.htm#select"><code>SELECT</code></a>.
Это может помочь Вам диагностировать причины проблем соединения. См.
<a href="perfor.htm#host-cache-table">раздел 23.9.16.1</a>.</p>

<p>Сервер обрабатывает записи в кэше узла так:</p>
<ol type="1"><li><p>Когда первое соединение клиента TCP достигает сервера от
данного IP-адреса, новый вход создается, чтобы сделать запись IP клиента,
имени хоста и флага проверки допустимости поиска клиента. Первоначально имя
хоста установлено в <code>NULL</code> и флаг ложен. Этот вход также
используется для последующих соединений клиента от того же самого IP.</li>

<li>Если флаг проверки допустимости для входа IP клиента ложен, сервер делает
попытку разрешения IP к имени хоста. Если это успешно, имя хоста обновлено с
решенным именем хоста, и флаг проверки допустимости установлен в истину. Если
разрешение неудачно, предпринятые меры зависят от того, является ли ошибка
постоянной или переходной. Для постоянных отказов остается имя хоста
<code>NULL</code>, а флаг проверки допустимости установлен в истину. Для
переходных отказов имя хоста и флаг проверки допустимости остаются
неизменными. Другая попытка разрешения DNS происходит в следующий раз, когда
клиент соединяется от этого IP.</li>

<li>Если ошибка происходит, обрабатывая поступающее соединение клиента от
данного IP-адреса, сервер обновляет соответствующие счетчики во входе для
этого IP. Для описания зарегистрированных ошибок см.
<a href="perfor.htm#host-cache-table">раздел 23.9.16.1</a>.</p></li></ol>

<p>Сервер выполняет разрешение имени хоста, используя безопасные для
потока вызовы <code>gethostbyaddr_r()</code> и
<code>gethostbyname_r()</code>, если операционная система поддерживает их.
Иначе поток, выполняющий поиск, блокирует mutex и вызывает
<code>gethostbyaddr()</code> и <code>gethostbyname()</code>.
В этом случае никакой другой поток не может решить имена хоста, которые не
находятся в кэше узла, пока поток, держащий блокировку mutex,
не выпускает ее.</p>

<p>Сервер использует кэш узла в нескольких целях:</p>
<ul><li><p>Кэшируя результаты поисков IP к имени хоста, сервер избегает
делать поиск DNS для каждого соединения клиента. Вместо этого для данного
узла это должно выполнить поиск только для первого соединения от того узла.
</li>

<li>Кэш содержит информацию об ошибках, которые происходят во время процесса
соединения. Некоторые ошибки считают <span><span>блокировками</span></span>.
Если слишком многие из них происходят последовательно от данного узла без
успешного соединения, сервер блокирует дальнейшие соединения от того узла.
<a href="server.htm#sysvar_max_connect_errors"><code>max_connect_errors
</code></a> определяет число разрешенных ошибок прежде, чем блокировка
произойдет. См. <a href="error.htm#blocked-host">раздел B.5.2.5</a>.
</p></li></ul>

<p>Чтобы открыть заблокированные узлы, сбросьте кэш узла командой
<a href="sql.htm#flush"><code>FLUSH HOSTS</code></a> или
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin
flush-hosts</strong></span></a>.</p>

<p>Для заблокированного узла возможно стать открытым даже без
<a href="sql.htm#flush"><code>FLUSH HOSTS</code></a>, если деятельность от
других узлов произошла, начиная с последней попытки соединения от
заблокированного узла. Это может произойти, потому что сервер отказывается от
последнего использованного входа кэша, чтобы создать место для нового входа,
если кэш полон, когда соединение прибывает от IP клиента не в кэше.
Если вход, от которого отказываются, был для заблокированного узла, тот
узел становится открытым.</p>

<p>Кэш узла включен по умолчанию. Чтобы отключить это, установите
<a href="server.htm#sysvar_host_cache_size"><code>host_cache_size</code></a>
в 0 при запуске сервера или во время выполнения.</p>

<p>Чтобы отключить поиски имени хоста DNS, запустите сервер с
<a href="server.htm#option_mysqld_skip-name-resolve"><code>
--skip-name-resolve</code></a>. В этом случае сервер использует только
IP-адреса, но не имена хоста, чтобы соответствовать строкам в таблицах
привилегий. Только учетные записи, определенные в тех таблицах, используя
IP-адреса, могут использоваться. Убедитесь, что учетная запись, которая
определяет IP-адрес существует, или Вы можете быть
не в состоянии соединиться.</p>

<p>Если у Вас есть очень медленный DNS и много узлов, Вы могли бы быть в
состоянии улучшить работу, отключая поиски DNS с
<a href="server.htm#option_mysqld_skip-name-resolve"><code>
--skip-name-resolve</code></a> или увеличивая значение
<a href="server.htm#sysvar_host_cache_size"><code>host_cache_size</code></a>,
чтобы сделать кэш узла больше.</p>

<p>Чтобы отвергнуть соединения TCP/IP полностью, запустите сервер с
опцией <a href="server.htm#option_mysqld_skip-networking">
<code>--skip-networking</code></a>.</p>

<p>Некоторые ошибки соединения не связаны с соединениями TCP,
происходят очень рано в процессе соединения (даже прежде, чем IP-адрес будет
известен), или не являются определенными для любого особого IP-адреса (такие,
как условия памяти). Для информации об этих ошибках проверьте
<a href="server.htm#statvar_Connection_errors_xxx"><code>
Connection_errors_<em><code>xxx</code></em></code></a> (см.
<a href="server.htm#server-status-variables">раздел 6.1.7</a>).</p>

<h2><a name="optimize-benchmarking"></a>9.13.
Сопоставительный анализ (Benchmarking)</h2>
<p>Чтобы определить эксплуатационные качества, рассмотрите следующие факторы:
</p>

<ul><li><p>Измеряете ли Вы скорость единственной работы на тихой системе
или как ряд операций в течение времени. С простыми тестами Вы обычно
проверяете, как изменение одного аспекта (установка конфигурации, набор
индексов на таблице, пункты SQL в запросе) влияет на работу. Точки отсчета
это типично продолжительные и тщательно продуманные тесты производительности,
где результаты могли продиктовать высокоуровневый выбор, такой как аппаратные
средства и конфигурация хранения, или как скоро обновиться до
новой версии MySQL.</li>

<li>Для того, чтобы определить эффективность, иногда Вы должны моделировать
тяжелую рабочую нагрузку базы данных, чтобы получить точную картину.</li>
<li>Работа может измениться в зависимости от очень многих различных факторов,
так что различие в несколько процентов не может быть решающей победой.
Результаты могли бы сместиться на противоположный путь, когда Вы проверяете в
различной окружающей среде.</li>

<li>Особенности MySQL помогают или не помогают работе в зависимости от
рабочей нагрузки. Для законченности всегда нужно проведение испытаний с теми
или иными особенностями, включенными и выключенными. Двумя самыми важными
особенностями, чтобы попробовать при каждой рабочей нагрузке, является
<a href="#query-cache">кэш запроса MySQL</a> и
<a href="innodb.htm#innodb-adaptive-hash">адаптивный хеш-индекс</a>
для таблиц <code>InnoDB</code>.</p></li></ul>

<p>Этот раздел прогрессирует от методов простого и прямого измерения,
которые единственный разработчик может сделать, к более сложным, которые
требуют дополнительной экспертизы и интерпретации результатов.</p>

<h3><a name="select-benchmarking"></a>9.13.1.
Измерение скорости выражений и функций</h3>
<p>Чтобы измерить скорость определенного выражения MySQL или функции,
вызовите <a href="funct.htm#function_benchmark"><code>BENCHMARK()</code></a>,
используя <a href="programs.htm#mysql"><span><strong>mysql</strong></span>
</a>. Ее синтаксис: <a href="funct.htm#function_benchmark"><code>
BENCHMARK(<em><code>loop_count</code></em>,<em><code>expression</code></em>)
</code></a>. Возвращаемое значение всегда ноль, но
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
печатает строку, выводящую на экран приблизительно, сколько времени
запрос взял. Например:
<pre>
mysql&gt; SELECT BENCHMARK(1000000,1+1);
+------------------------+
| BENCHMARK(1000000,1+1) |
+------------------------+
| 0                      |
+------------------------+
1 row in set (0.32 sec)
</pre>

<p>Этот результат был получен на системе Pentium II 400MHz.
Это показывает, что MySQL может выполнить 1000000
простых сложений за 0.32 секунды на этой системе.</p>

<p>Встроенные функции MySQL, как правило, чрезвычайно оптимизируются,
но могут быть некоторые исключения.
<a href="funct.htm#function_benchmark"><code>BENCHMARK()</code></a>
превосходный инструмент для того, чтобы узнать, является ли некоторая функция
проблемой для Ваших запросов.</p>

<h3><a name="custom-benchmarks"></a>9.13.2.
Используя Ваши собственные точки отсчета</h3>
<p>Определите эффективность своего приложения и базы данных, чтобы узнать,
где узкие места. После установки одного узкого места (или заменяя это
with a <span><span>пустым</span></span> модулем), Вы можете продолжить
идентифицировать следующее узкое место. Даже если эффективность работы для
Вашего приложения в настоящее время является приемлемой, Вы должны, по
крайней мере, сделать план относительно каждого узкого места и решить, как
решать это, если когда-нибудь Вы действительно будете
нуждаться в дополнительной производительности.</p>

<p>Свободный эталонный набор Open Source Database Benchmark,
можно скачать с <a href="../../../osdb.sourceforge.net/default.htm" target="_top">
http://osdb.sourceforge.net/</a>.</p>

<p>Это очень характерно для проблемы проявляться только,
когда система очень в большой степени загружена. У нас было много клиентов,
которые связываются с нами, когда они имеют (проверенную) систему в
производстве и столкнулись с проблемами загрузки. В большинстве случаев
проблемы, оказывается, происходят из-за проблем основного проектирования баз
данных (например, сканирование таблицы не хорошо при высокой загрузке) или
проблемы с операционной системой или библиотеками. Большую часть времени эти
проблемы было бы намного легче решить, если бы системы еще не работали.</p>

<p>Чтобы избежать проблем, определите эффективность своего целого приложения
при худшей загрузке:</p>
<ul><li><p><a href="programs.htm#mysqlslap">
<span><strong>mysqlslap</strong></span></a> может быть полезной для того,
чтобы моделировать высокую загрузку, произведенную многими клиентами,
выпускающими запросы одновременно. См. <a href="programs.htm#mysqlslap">
раздел 5.5.8</a>.</li>

<li>Вы можете также попытаться определить эффективность пакетов, таких как
SysBench и DBT2, доступных на
<a href="../../../https@launchpad.net/sysbench" target="_top">
https://launchpad.net/sysbench</a> и
<a href="../../../osdldbt.sourceforge.net/#dbt2" target="_top">
http://osdldbt.sourceforge.net/#dbt2</a>.</p></li></ul>
<p>Эти программы или пакеты могут положить систему, так что надо
убедиться, что использовали их только на Ваших системах развития.</p>

<h3><a name="monitoring-performance-schema"></a>9.13.3.
Определение эксплуатационных качеств с performance_schema</h3>
<p>Вы можете запросить таблицы в <code>performance_schema</code>, чтобы
видеть информацию в реальном времени о технических характеристиках Вашего
сервера и приложений, см. <a href="perfor.htm">главу 23</a>.</p>

<h2><a name="thread-information"></a>9.14.
Информация о потоке исследования</h2>
<p>Когда Вы пытаетесь установить то, что делает Ваш сервер MySQL,
может быть полезно исследовать список процессов, который является набором
потоков, в настоящее время выполняющихся в пределах сервера.
Информация о списке процесса доступна из этих источников:</p>

<ul><li><p><code>SHOW [FULL] PROCESSLIST</code>:
<a href="sql.htm#show-processlist">раздел 14.7.5.29</a></li>
<li><a href="sql.htm#show-profile"><code>SHOW PROFILE</code></a>:
<a href="sql.htm#show-profiles">раздел 14.7.5.31</a></li>

<li>Таблица <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a>:
<a href="inform.htm#processlist-table">раздел 22.16</a></li>

<li><a href="programs.htm#mysqladmin"><span>
<strong>mysqladmin processlist</strong></span></a>:
<a href="programs.htm#mysqladmin">раздел 5.5.2</a></li>

<li>Таблицы <a href="perfor.htm#threads-table"><code>потоков</code></a>,
таблицы этапа и таблицы блокировки в Performance Schema:
<a href="perfor.htm#performance-schema-miscellaneous-tables">раздел 23.9.16
</a>, <a href="perfor.htm#performance-schema-stage-tables">раздел 23.9.5</a>
и <a href="perfor.htm#performance-schema-lock-tables">раздел 23.9.12</a>.
</p></li></ul>

<p>Доступ к <a href="perfor.htm#threads-table"><code>threads</code></a>
не требует mutex и оказывает минимальное влияние на работу сервера.
<a href="inform.htm#processlist-table"><code>INFORMATION_SCHEMA.PROCESSLIST
</code></a> и <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a> имеют отрицательные исполнительные последствия, потому что они
требуют mutex. <a href="perfor.htm#threads-table"><code>threads</code></a>
также показывает информацию о фоновых потоках, которую не дают
<a href="inform.htm#processlist-table"><code>INFORMATION_SCHEMA.PROCESSLIST
</code></a> и <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a>. Это означает, что <a href="perfor.htm#threads-table"><code>
threads</code></a> может использоваться, чтобы контролировать деятельность,
которую другие источники информации дать не могут.</p>

<p>Вы можете всегда рассматривать информацию о своих собственных потоках.
Чтобы смотреть информацию о потоках, выполняемых для других учетных записей,
Вы должны иметь привилегию <a href="security.html#priv_process"><code>PROCESS
</code></a>.</p>

<p>Каждый вход списка процесса содержит несколько сведений:</p>
<ul><li><p><code>Id</code> идентификатор соединения для
клиента, связанного с потоком.</li>

<li><code>User</code> и <code>Host</code> указывают на учетную
запись, связанную с потоком.</li>
<li><code>db</code> база данных по умолчанию для потока или
<code>NULL</code>, если ни одна не выбрана.</li>

<li><code>Command</code> и <code>State</code>
указывают на то, что делает поток.</p>
<p>Большинство статусов соответствует очень быстрым операциям. Если поток
остается в данном статусе в течение многих секунд, может быть проблема,
которая должна быть исследована.</li>

<li><code>Time</code> указывает, как долго поток был в его текущем состоянии.
Понятие потока текущего времени может быть изменено в некоторых случаях:
поток может изменить время с <a href="sql.htm#set-variable"><code>SET
TIMESTAMP = <em><code>value</code></em></code></a>.
Для потока, работающего на ведомом устройстве, которое обрабатывает события
от ведущего устройства, время потока установлено во время, найденное в
событиях, и таким образом отражает текущее время на ведущем устройстве,
а не на ведомом.</li>

<li><code>Info</code> содержит текст запроса, выполняемого потоком, или
<code>NULL</code>, если это не выполняет ничего. По умолчанию это значение
содержит только первые 100 символов запроса. Чтобы видеть полные запросы,
надо использовать <a href="sql.htm#show-processlist"><code>
SHOW FULL PROCESSLIST</code></a>.</p></li></ul>

<p>Следующие разделы перечисляют возможные значения
<code>Command</code> и <code>State</code> по категориям. Значение для
некоторых из этих значений самоочевидно. Для других
обеспечено дополнительное описание.</p>

<h3><a name="thread-commands"></a>9.14.1.
Значения команды потока</h3>
<p>У потока может быть любое из следующих значений <code>Command</code>:</p>

<ul><li><p><code>Binlog Dump</code></p>
<p>Это поток на главном сервере для того, чтобы послать
содержание журнала в ведомый сервер.</li>

<li><code>Change user</code></p>
<p>Поток выполняет работу изменения пользователя.</li>
<li><code>Close stmt</code></p>
<p>Поток закрывает готовый запрос.</li>

<li><code>Connect</code></p>
<p>Ведомое устройство соединено с его ведущим устройством.</li>
<li><code>Connect Out</code></p>
<p>Ведомое устройство соединяется с его ведущим устройством.</li>

<li><code>Create DB</code></p>
<p>Поток выполняет работу создать-базу-данных.</li>
<li><code>Daemon</code></p>
<p>Этот поток является внутренним к серверу, а не потоку,
который обслуживает соединение клиента.</li>

<li><code>Debug</code></p>
<p>Поток производит информацию об отладке.</li>
<li><code>Delayed insert</code></p>
<p>Поток обрабатывает отложенную вставку.</li>

<li><code>Drop DB</code></p>
<p>Поток выполняет работу удаления базы данных.</li>
<li><code>Error</code></li>
<li><code>Execute</code></p>
<p>Поток выполняет готовый запрос.</li>

<li><code>Fetch</code></p>
<p>Поток приносит следствия выполнения готового запроса.</li>
<li><code>Field List</code></p>
<p>Поток получает информацию для столбцов таблицы.</li>

<li><code>Init DB</code></p>
<p>Поток выбирает базу данных по умолчанию.</li>
<li><code>Kill</code></p>
<p>Поток уничтожает другой поток.</li>

<li><code>Long Data</code></p>
<p>Поток получает длинные данные в результате выполнения готового запроса.
</li>
<li><code>Ping</code></p>
<p>Поток обрабатывает запрос ping сервера.</li>

<li><code>Prepare</code></p>
<p>Поток готовит готовый запрос.</li>
<li><code>Processlist</code></p>
<p>Поток производит информацию о потоках сервера.</li>

<li><code>Query</code></p>
<p>Поток выполняет запрос.</li>
<li><code>Quit</code></p>
<p>Поток заканчивается.</li>

<li><code>Refresh</code></p>
<p>Поток сбрасывает таблицу, журналы или кэши или сбрасывает переменную
состояния или информацию о сервере репликации.</li>

<li><code>Register Slave</code></p>
<p>Поток регистрирует ведомый сервер.</li>
<li><code>Reset stmt</code></p>
<p>Поток сбрасывает готовый запрос.</li>

<li><code>Set option</code></p>
<p>Поток устанавливает или сбрасывает опцию выполнения запроса клиента.</li>
<li><code>Shutdown</code></p>
<p>Поток закрывает сервер.</li>

<li><code>Sleep</code></p>
<p>Поток ждет клиента, чтобы послать новый запрос.</li>
<li><code>Statistics</code></p>
<p>Поток производит информацию о статусе сервера.</li>

<li><code>Table Dump</code></p>
<p>Поток посылает табличное содержание в ведомый сервер.</li>
<li><code>Time</code></p>
<p>Не использован.</p></li></ul>

<h3><a name="general-thread-states"></a>9.14.2.
Общие состояния потока</h3>
<p>Следующий список описывает значения <code>State</code> потока, которые
связаны с общей обработкой запроса, но не более специализированными
действиями, такими как репликация. Многие из них полезны только для
отлова ошибок в сервере.</p>

<ul><li><p><code>After create</code></p>
<p>Это происходит, когда поток составляет таблицу (включая внутренние
временные таблицы), в конце функции, которая составляет таблицу. Это
состояние используется, даже если таблица не могла быть составлена
из-за некоторой ошибки.</li>

<li><code>Analyzing</code></p>
<p>Поток вычисляет табличные ключевые распределения <code>MyISAM</code>
(например, для <a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code>
</a>).</li>

<li><code>checking permissions</code></p>
<p>Поток проверяет, есть ли у сервера необходимые привилегии, чтобы
выполнить этот запрос.</li>

<li><code>Checking table</code></p>
<p>Поток выполняет табличную проверку.</li>
<li><code>cleaning up</code></p>
<p>Поток обработал одну команду и готовится освобождать память
и сбрасывать определенные параметры состояния.</li>

<li><code>closing tables</code></p>
<p>Поток сбрасывает измененные табличные данные на диск и закрывает
используемые таблицы. Это должно быть быстрой работой. В противном случае
проверьте, что у Вас нет полного диска и что диск не находится в
очень интенсивном использовании.</li>

<li><code>converting HEAP to MyISAM</code></p>
<p>Поток преобразовывает внутреннюю временную таблицу из
<code>MEMORY</code> в <code>MyISAM</code> на диске.</li>

<li><code>copy to tmp table</code></p>
<p>Поток обрабатывает <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>. Это состояние происходит после того, как таблица с новой
структурой была составлена, но прежде, чем строки будут скопированы в нее.
</p>

<p>Для потока в этом статусе Performance Schema может использоваться, чтобы
получить информацию о продвижении работы копии. См.
<a href="perfor.htm#performance-schema-stage-tables">раздел 23.9.5</a>.</li>

<li><code>Copying to group table</code></p>
<p>Если запрос имеет отличающиеся <code>ORDER BY</code> и
<code>GROUP BY</code>, строки сортированы группой и скопированы
во временную таблицу.</li>

<li><code>Copying to tmp table</code></p>
<p>Сервер копирует к временной таблице в памяти.</li>
<li><code>altering table</code></p>
<p>Сервер находится в процессе выполнения оперативного
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</li>

<li><code>Copying to tmp table on disk</code></p>
<p>Сервер копирует к временной таблице на диске.
Временный набор результатов стал слишком большим (см.
<a href="#internal-temporary-tables">раздел 9.4.4</a>).
Следовательно, поток изменяет временную таблицу в памяти до
основанного на диске формата, чтобы сохранить память.</li>

<li><code>Creating index</code></p>
<p>Поток обрабатывает <code>ALTER TABLE ... ENABLE KEYS</code>
для <code>MyISAM</code>.</li>

<li><code>Creating sort index</code></p>
<p>Поток обрабатывает <a href="sql.htm#select"><code>SELECT</code></a>,
используя внутреннюю временную таблицу.</li>

<li><code>creating table</code></p>
<p>Поток составляет таблицу. Это включает создание временных таблиц.</li>
<li><code>Creating tmp table</code></p>
<p>Поток составляет временную таблицу в памяти или на диске.
Если таблица будет составлена в памяти, но позже будет преобразована в
таблицу на диске, то состояние во время той работы будет
<code>Copying to tmp table on disk</code>.</li>

<li><code>committing alter table to storage engine</code></p>
<p>Сервер закончил оперативное <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> и передает результат.</li>

<li><code>deleting from main table</code></p>
<p>Сервер выполняет первую часть многотабличного удаления.
Это удаляет только из первой таблицы и сохраняет столбцы и смещения, которые
будут использоваться для того, чтобы удалить из другой таблицы.</li>

<li><code>deleting from reference tables</code></p>
<p>Сервер выполняет вторую часть многотабличного удаления:
удаление соответствующих строк из других таблиц.</li>

<li><code>discard_or_import_tablespace</code></p>
<p>Поток обрабатывает <code>ALTER TABLE ... DISCARD TABLESPACE</code> или
<code>ALTER TABLE ... IMPORT TABLESPACE</code>.</li>

<li><code>end</code></p>
<p>Это происходит в конце, но перед уборкой
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#create-view"><code>CREATE VIEW</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#select"><code>SELECT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>.</li>

<li><code>executing</code></p>
<p>Поток начал выполнять запрос.</li>
<li><code>Execution of init_command</code></p>
<p>Поток выполняет запросы в значении системной
переменной <code>init_command</code>.</li>

<li><code>freeing items</code></p>
<p>Поток выполнил команду. Некоторое освобождение от элементов, сделанных во
время этого состояния, вовлекает кэш запроса. Это состояние обычно
сопровождается <code>cleaning up</code>.</li>

<li><code>FULLTEXT initialization</code></p>
<p>Сервер готовится выполнять полнотекстовый поиск на естественном языке.
</li>

<li><code>init</code></p>
<p>Это происходит перед инициализацией
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#select"><code>SELECT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>.
Меры, предпринятые сервером в этом статусе, включают сброс двоичного журнала,
журнала <code>InnoDB</code> и некоторые операции уборки кэша запроса.</p>

<p>Для статуса <code>end</code> следующие операции могли происходить:</p>
<ul><li><p>Удаление записи кэша запроса после того, как
данные в таблице изменены.</li>
<li>Запись события в двоичный журнал.</li>
<li>Освобождение буферов памяти, включая blob.</p></li></ul></li>

<li><code>Killed</code></p>
<p>Кто-то послал потоку запрос <a href="sql.htm#kill"><code>KILL</code></a>
и это должно прерваться в следующий раз, когда это проверяет
флаг уничтожения. Флаг проверен в каждом главном цикле
в MySQL, но в некоторых случаях могло бы все еще потребоваться короткое время
для потока, чтобы завершиться. Если поток заблокирован некоторым другим
потоком, уничтожение вступает в силу, как только другой поток
выпускает свою блокировку.</li>

<li><code>Locking system tables</code></p>
<p>Поток пытается заблокировать системную таблицу (например, часовой пояс
или таблицу журнала).</li>

<li><code>logging slow query</code></p>
<p>Поток пишет запрос в журнал медленного запроса.</li>
<li><code>login</code></p>
<p>Начальное состояние для потока соединения, пока клиент не
был заверен успешно.</li>

<li><code>manage keys</code></p>
<p>Сервер включает или отключает индекс таблицы.</li>
<li><code>NULL</code></p>
<p>Это состояние используется для
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>.</li>

<li><code>Opening system tables</code></p>
<p>Поток пытается открыть системную таблицу (например, часовой пояс
или таблицу журнала).</li>

<li><code>Opening tables</code></p>
<p>Поток пытается открыть таблицу. Это должна быть очень быстрая процедура,
если что-то не предотвращает открытие. Например,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> или
<a href="sql.htm#lock-tables"><code>LOCK TABLE</code></a>
может предотвратить открытие таблицы, пока запрос не закончено. Также стоит
проверить что Ваше значение <a href="server.htm#sysvar_table_open_cache">
<code>table_open_cache</code></a> является достаточно большим.</p>
<p>Для системных таблиц вместо этого используется
<code>Opening system tables</code>.</li>

<li><code>optimizing</code></p>
<p>Сервер выполняет начальную оптимизацию для запроса.</li>
<li><code>preparing</code></p>
<p>Это состояние происходит во время оптимизации запроса.</li>

<li><code>Purging old relay logs</code></p>
<p>Поток удаляет ненужные файлы системного журнала реле.</li>
<li><code>query end</code></p>
<p>Это состояние происходит после обработки запроса, но
перед <code>freeing items</code>.</li>

<li><code>Receiving from client</code></p>
<p>Сервер читает пакет от клиента.</li>
<li><code>Removing duplicates</code></p>
<p>Запрос использовал <a href="sql.htm#select"><code>SELECT DISTINCT</code>
</a> таким способом, которым MySQL не мог оптимизировать работу на ранней
стадии. Из-за этого MySQL требует, чтобы дополнительный этап удалил все
дублированные строки прежде, чем послать результат клиенту.</li>

<li><code>removing tmp table</code></p>
<p>Поток удаляет внутреннюю временную таблицу после обработки
<a href="sql.htm#select"><code>SELECT</code></a>.
Это состояние не используется, если никакая временная таблица
не была составлена.</li>

<li><code>rename</code></p>
<p>Поток переименовывает таблицу.</li>
<li><code>rename result table</code></p>
<p>Поток обрабатывает <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>, который составил новую таблицу и переименовывает ее, чтобы
заменить оригинальную таблицу.</li>

<li><code>Reopen tables</code></p>
<p>Поток получил блокировку для таблицы, но после получения блокировки,
которая изменила основную структуру таблицы. Это освободило блокировку,
закрыло таблицу и пытается вновь открыть.</li>

<li><code>Repair by sorting</code></p>
<p>Код ремонта использует сортировку, чтобы создать индексы.</li>
<li><code>preparing for alter table</code></p>
<p>Сервер готовится выполнять оперативное
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.</li>

<li><code>Repair done</code></p>
<p>Поток завершил мультипоточный ремонт для <code>MyISAM</code>.</li>
<li><code>Repair with keycache</code></p>
<p>Код ремонта использует создание ключей один за другим через ключевой кэш.
Это намного медленнее, чем <code>Repair by sorting</code>.</li>

<li><code>Rolling back</code></p>
<p>Поток удаляет транзакцию.</li>
<li><code>Saving state</code></p>
<p>Для операций <code>MyISAM</code>, таких как ремонт или анализ, поток
сохраняет новое табличное состояние в заголовок файла <code>.MYI</code>.
Состояние включает такую информацию, как число строк, счетчик
<code>AUTO_INCREMENT</code> и ключевые распределения.</li>

<li><code>Searching rows for update</code></p>
<p>Поток делает первую фазу, чтобы найти все строки соответствия прежде, чем
обновить их. Это должно быть сделано, если
<a href="sql.htm#update"><code>UPDATE</code></a> изменяет индексирование,
которое используется, чтобы найти вовлеченные строки.</li>

<li><code>Sending data</code></p>
<p>Поток читает и обрабатывает строки для
<a href="sql.htm#select"><code>SELECT</code></a>
и посылает данные клиенту. Поскольку операции, происходящие во время этого
состояния, имеют тенденцию выполнять большое количество дискового доступа
(чтения), это часто самое продолжительное состояние данного запроса.</li>

<li><code>Sending to client</code></p>
<p>Сервер пишет пакет клиенту.</li>
<li><code>setup</code></p>
<p>Поток начинает <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>.
</li>

<li><code>Sorting for group</code></p>
<p>Поток делает сортировку, чтобы удовлетворить <code>GROUP BY</code>.</li>
<li><code>Sorting for order</code></p>
<p>Поток делает сортировку, чтобы удовлетворить <code>ORDER BY</code>.</li>

<li><code>Sorting index</code></p>
<p>Поток сортирует индексные страницы для более эффективного доступа во время
оптимизации таблицы <code>MyISAM</code>.</li>

<li><code>Sorting result</code></p>
<p>Для <a href="sql.htm#select"><code>SELECT</code></a> это подобно
<code>Creating sort index</code>, но не для временных таблиц.</li>

<li><code>statistics</code></p>
<p>Сервер вычисляет статистику, чтобы развить план выполнения запроса.
Если поток находится в этом статусе в течение долгого времени, сервер,
вероятно, занят выполнением другой работы.</li>

<li><code>System lock</code></p>
<p>Поток вызвал <code>mysql_lock_tables()</code>,
и состояние потока не было обновлено с тех пор. Это очень общее состояние,
которое может произойти по многим причинам.</p>

<p>Например, поток собирается просить или ждет внутренней или внешней
системной блокировки для таблицы. Это может произойти, когда
<a href="innodb.htm"><code>InnoDB</code></a>
ждет блокировки на уровне таблицы во время выполнения
<a href="sql.htm#lock-tables"><code>LOCK TABLES</code></a>.
Если это состояние вызывается запросами о внешних блокировках, и Вы не
используете многократные <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a>, которые получают доступ к тем же самым таблицам
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>,
Вы можете отключить внешние системные блокировки с помощью
<a href="server.htm#option_mysqld_external-locking"><code>
--skip-external-locking</code></a>. Однако, внешняя блокировка отключена по
умолчанию, таким образом, вероятно, что эта опция не будет иметь никакого
эффекта. Для <a href="sql.htm#show-profile"><code>SHOW PROFILE</code></a>
это состояние означает, что поток просит блокировку (не ждет ее).</p>
<p>Для системных таблиц вместо этого используется
<code>Locking system tables</code>.</li>

<li><code>update</code></p>
<p>Поток готовится начинать обновлять таблицу.</li>
<li><code>Updating</code></p>
<p>Поток ищет строки, чтобы обновить и обновляет их.</li>

<li><code>updating main table</code></p>
<p>Сервер выполняет первую часть многотабличного обновления. Это обновляет
только первую таблицу и сохраняет столбцы и смещения, которые будут
использоваться для того, чтобы обновить другие таблицы.</li>

<li><code>updating reference tables</code></p>
<p>Сервер выполняет вторую часть многотабличного обновления и обновляет
соответствующие строки других таблиц.</li>

<li><code>User lock</code></p>
<p>Поток собирается просить или ждет консультативной блокировки, которую
требуют через <a href="funct.htm#function_get-lock"><code>GET_LOCK()</code>
</a>. Для <a href="sql.htm#show-profile"><code>SHOW PROFILE</code></a>
это состояние означает, что поток просит блокировку (не ждет ее).</li>

<li><code>User sleep</code></p>
<p>Поток вызвал <a href="funct.htm#function_sleep"><code>SLEEP()</code></a>.
</li>
<li><code>Waiting for commit lock</code></p>
<p><a href="sql.htm#flush"><code>FLUSH TABLES WITH READ LOCK</code></a>
ждет передачи блокировки.</li>

<li><code>Waiting for global read lock</code></p>
<p><a href="sql.htm#flush"><code>FLUSH TABLES WITH READ LOCK</code></a>
ждет глобальной блокировки чтения или установки глобальной переменной
<a href="server.htm#sysvar_read_only"><code>read_only</code></a>.</li>

<li><code>Waiting for tables</code></p>
<p>Поток получил уведомление, что глубинная структура для таблицы изменилась
и это должно вновь открыть таблицу, чтобы получить новую структуру.
Однако, чтобы вновь открыть таблицу, это должно ждать, пока все другие потоки
не закрыли рассматриваемую таблицу.</p>

<p>Это уведомление имеет место, если другой поток использовал
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a>
или один из следующих запросов о рассматриваемой таблице:
<code>FLUSH TABLES <em><code>tbl_name</code></em></code>,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#rename-table"><code>RENAME TABLE</code></a>,
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>,
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> или
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.</li>

<li><code>Waiting for table flush</code></p>
<p>Поток выполняет <a href="sql.htm#flush"><code>FLUSH TABLES</code></a>
и ждет всех потоков, чтобы закрыть их таблицы, или поток получил уведомление,
что глубинная структура для таблицы изменилась, и это должно вновь
открыть таблицу, чтобы получить новую структуру. Однако, чтобы вновь
открыть таблицу, это должно ждать, пока все другие потоки
не закрыли рассматриваемую таблицу.</p>

<p>Это уведомление имеет место, если другой поток использовал
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a>
или один из следующих запросов о рассматриваемой таблице:
<code>FLUSH TABLES <em><code>tbl_name</code></em></code>,
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#rename-table"><code>RENAME TABLE</code></a>,
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>,
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> или
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>.</li>

<li><code>Waiting for <em><code>lock_type</code></em> lock</code></p>
<p>Сервер ждет, чтобы приобрести блокировку <code>THR_LOCK</code> или
блокировку от подсистемы блокировки метаданных, где
<em><code>lock_type</code></em> указывает на тип блокировки.</p>

<p>Это состояние указывает на ожидаемую <code>THR_LOCK</code>:</p>
<ul><li><p><code>Waiting for table level lock</code></p></li></ul>
<p>Эти состояния указывают на ожидание блокировки метаданных:</p>
<ul><li><p><code>Waiting for event metadata lock</code></li>
<li><code>Waiting for global read lock</code></li>
<li><code>Waiting for schema metadata lock</code></li>
<li><code>Waiting for stored function metadatalock</code></li>
<li><code>Waiting for stored procedure metadata lock</code></li>
<li><code>Waiting for table metadata lock</code></li>
<li><code>Waiting for trigger metadata lock</code>
</p></li></ul>

<p>Для информации о табличных индикаторах блокировки см.
<a href="#internal-locking">раздел 9.11.1</a>.
Для информации о блокировке метаданных см.
<a href="#metadata-locking">раздел 9.11.4</a>.
Чтобы видеть, какие блокировки блокируют запросы блокировки, используйте
таблицы блокировки Performance Schema, описанные в
<a href="perfor.htm#performance-schema-lock-tables">разделе 23.9.12</a>.</li>

<li><code>Waiting on cond</code></p>
<p>Состояние, в котором поток ждет условия. Никакая определенная
информация не доступна.</li>
<li><code>Writing to net</code></p>
<p>Сервер пишет пакет в сеть.</p></li></ul>

<h3><a name="query-cache-thread-states"></a>9.14.3.
Состояния потока кэша запроса</h3>
<p>Эти состояния потока связаны с кэшем запроса (см.
<a href="#query-cache">раздел 9.10.3</a>).</p>

<ul><li><p><code>checking privileges on cached query</code></p>
<p>Сервер проверяет, есть ли у пользователя привилегии, чтобы получить доступ
к кэшируемому результату запроса.</li>

<li><code>checking query cache for query</code></p>
<p>Сервер проверяет, присутствует ли текущий запрос в кэше запроса.</li>
<li><code>invalidating query cache entries</code></p>
<p>Записи кэша запроса отмечаются как недопустимые, потому что
основные таблицы изменились.</li>

<li><code>sending cached result to client</code></p>
<p>Сервер берет результат запроса из кэша запроса и посылает это клиенту.
</li>
<li><code>storing result in query cache</code></p>
<p>Сервер хранит результат запроса в кэше запроса.</li>

<li><code>Waiting for query cache lock</code></p>
<p>Это состояние происходит в то время, как сеанс ждет, чтобы взять
блокировку кэша запроса. Это может произойти для любого запроса, который
должен выполнить некоторую работу кэша запроса, например,
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a> лишает законной силы кэш
запроса, <a href="sql.htm#select"><code>SELECT</code></a>, который ищет
кэшируемые данные, <a href="sql.htm#reset"><code>RESET QUERY CACHE</code></a>
и т.д.</p></li></ul>

<h3><a name="master-thread-states"></a>9.14.4.
Ведущие состояния потока репликации</h3>
<p>Следующий список показывает наиболее распространенные состояния, которые
Вы можете видеть в столбце <code>State</code> для потока <code>Binlog Dump
</code> ведущего устройства. Если Вы не видите потоки <code>Binlog Dump
</code> на главном сервере, это означает, что репликация не запущена,
то есть, что никакие ведомые устройства в настоящее время не соединяются.</p>

<ul><li><p><code>Finished reading one binlog; switching to next binlog</code>
</p>
<p>Поток закончил читать двоичный файл системного журнала и открывает
следующий, чтобы послать в ведомое устройство.</li>

<li><code>Master has sent all binlog to slave; waiting for more updates
</code></p>
<p>Поток считал все остающиеся обновления из двоичных журналов
и послал их в ведомое устройство. Поток теперь неактивен, ожидая новых
событий из новых обновлений, происходящих на ведущем устройстве.</li>

<li><code>Sending binlog event to slave</code></p>
<p>Двоичные журналы состоят из <span><em>событий</em></span>, где
событие обычно обновление плюс некоторая другая информация. Поток считал
событие из двоичного журнала и теперь посылает его в ведомое устройство.</li>

<li><code>Waiting to finalize termination</code></p>
<p>Очень краткое состояние, которое происходит как поток, останавливается.
</p></li></ul>

<h3><a name="slave-io-thread-states"></a>9.14.5.
Ведомые состояния потока ввода/вывода</h3>
<p>Следующий список показывает наиболее распространенные состояния, которые
Вы видите в столбце <code>State</code> для ведомого потока ввода/вывода
сервера. Это состояние также появляется в столбце <code>Slave_IO_State
</code>, выведенный на экран <a href="sql.htm#show-slave-status"><code>SHOW
SLAVE STATUS</code></a>, таким образом, Вы можете получить хорошее
представление того, что происходит при использовании запроса.</p>

<ul><li><p><code>Checking master version</code></p>
<p>Установлено состояние, которое происходит очень кратко,
после соединения с ведущим устройством.</li>

<li><code>Connecting to master</code></p>
<p>Поток пытается соединиться с ведущим устройством.</li>
<li><code>Queueing master event to the relay log</code></p>
<p>Поток считал событие и копирует это к журналу реле так, чтобы поток SQL
мог обработать это.</li>

<li><code>Reconnecting after a failed binlog dump request</code></p>
<p>Поток пытается повторно соединиться с ведущим устройством.</li>
<li><code>Reconnecting after a failed master event read</code></p>
<p>Поток пытается повторно соединиться с ведущим устройством. Когда
соединение установлено снова, состояние становится
<code>Waiting for master to send event</code>.</li>

<li><code>Registering slave on master</code></p>
<p>Установлено состояние, которое происходит очень кратко после
соединения с ведущим устройством.</li>

<li><code>Requesting binlog dump</code></p>
<p>Установлено состояние, которое происходит очень кратко, после соединения
с ведущим устройством. Поток посылает ведущему устройству запрос
о содержании его двоичных журналов, запускающихся с требуемого
имени файла системного журнала и позиции.</li>

<li><code>Waiting for its turn to commit</code></p>
<p>Состояние, которое происходит, когда ведомый поток ждет больше
старых потоков, чтобы передать, если включена
<a href="replica.htm#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order</code></a>.</li>

<li><code>Waiting for master to send event</code></p>
<p>Поток соединился с ведущим устройством и ждет событий журнала.
Это может длиться в течение долгого времени, если ведущее устройство
неактивно. Если ожидание длится
<a href="replica.htm#sysvar_slave_net_timeout"><code>slave_net_timeout
</code></a> секунд, тайм-аут происходит. В том пункте поток полагает, что
соединение сломано и предпринимает попытку повторно соединиться.</li>

<li><code>Waiting for master update</code></p>
<p>Начальное состояние прежде <code>Connecting to master</code>.</li>
<li><code>Waiting for slave mutex on exit</code></p>
<p>Состояние, которое происходит кратко, когда поток останавливается.</li>

<li><code>Waiting for the slave SQL thread to free enough
relay log space</code></p>
<p>Вы используете отличное от нуля значение
<a href="server.htm#sysvar_relay_log_space_limit"><code>
relay_log_space_limit</code></a>, и журналы реле стали достаточно большими,
что их объединенный размер превышает это значение. Поток ввода/вывода ждет,
пока поток SQL не освобождает достаточно пространства,
обрабатывая содержание журнала реле так, чтобы это могло удалить некоторые
файлы системного журнала реле.</li>

<li><code>Waiting to reconnect after a failed binlog dump request</code></p>
<p>Если запрос дампа журнала прерван (из-за разъединения), поток входит в это
состояние и спит в то время, как идут попытки периодически повторно
соединяться. Интервал между повторениями может быть определен, используя
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>.</li>

<li><code>Waiting to reconnect after a failed master event read</code></p>
<p>Ошибка произошла, читая (из-за разъединения). Поток спит число секунд,
установленных <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO
</code></a> (по умолчанию 60) прежде, чем попытаться повторно соединиться.
</p></li></ul>

<h3><a name="slave-sql-thread-states"></a>9.14.6.
Ведомое устройство ответа состояния потока SQL</h3>
<p>Следующий список показывает наиболее распространенные состояния, которые
Вы можете видеть в столбце <code>State</code> для потока
SQL ведомого сервера:</p>

<ul><li><p><code>Killing slave</code></p>
<p>Поток обрабатывает <code>STOP SLAVE</code>.</li>
<li><code>Making temporary file (append) before replaying
LOAD DATA INFILE</code></p>
<p>Поток выполняет <a href="sql.htm#load-data"><code>LOAD DATA INFILE</code>
</a> и прилагает данные к временному файлу, содержащему данные, из которых в
едомое устройство считает строки.</li>

<li><code>Making temporary file (create) before replaying
LOAD DATA INFILE</code></p>
<p>Поток выполняет <a href="sql.htm#load-data"><code>LOAD DATA INFILE</code>
</a> и создает временный файл, содержащий данные, из которого ведомое
устройство читает строки. С этим состоянием можно только столкнуться, если
оригинал <a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>
был зарегистрирован ведущим устройством, выполняющим версию MySQL
ниже, чем версия 5.0.3.</li>

<li><code>Reading event from the relay log</code></p>
<p>Поток считал событие из журнала реле так, чтобы оно было обработано.</li>
<li><code>Slave has read all relay log; waiting for more updates</code></p>
<p>Поток обработал все события в файлах системного журнала реле
и теперь ждет потока ввода/вывода, чтобы написать новые события журналу реле.
</li>

<li><code>Waiting for an event from Coordinator</code></p>
<p>Используя мультипоточное ведомое устройство
(<a href="replica.htm#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> больше 1), один из ведомых потоков
ждет события от потока координатора.</li>

<li><code>Waiting for slave mutex on exit</code></p>
<p>Очень краткое состояние, которое происходит, когда поток останавливается.
</li>

<li><code>Waiting for Slave Workers to free pending events</code></p>
<p>Это действие ожидания происходит, когда полный размер обрабатываемых
событий превышает размер <a href="replica.htm#sysvar_slave_pending_jobs_size_max">
<code>slave_pending_jobs_size_max</code></a>.
Координатор продолжит планировать, когда размер будет ниже этого предела. Это
состояние происходит только, когда
<a href="replica.htm#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> больше 0.</li>

<li><code>Waiting for the next event in relay log</code></p>
<p>Начальное состояние прежде <code>Reading event from the relay log</code>.
</li>
<li><code>Waiting until MASTER_DELAY seconds after master executed event
</code></p>
<p>Поток SQL считал событие, но ждет ведомой задержки. Эта задержка
установлена с помощтю опции <code>MASTER_DELAY</code> в
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>.
</p></li></ul>

<p>Столбец <code>Info</code> для потока SQL может также показать текст
запроса. Это указывает, что поток считал событие
из журнала реле, извлек запрос из этого и может его выполнять.</p>

<h3><a name="slave-connection-thread-states"></a>9.14.7.
Ведомые состояния соединения потока</h3>
<p>Эти состояния потока происходят на ведомом устройстве, но связаны с
потоками соединения, а не с потоками SQL или вводом/выводом.</p>

<ul><li><p><code>Changing master</code></p>
<p>Поток обрабатывает <a href="sql.htm#change-master-to"><code>
CHANGE MASTER TO</code></a>.</li>

<li><code>Killing slave</code></p>
<p>Поток обрабатывает <code>STOP SLAVE</code>.</li>
<li><code>Opening master dump table</code></p>
<p>Это состояние происходит после
<code>Creating table from master dump</code>.</li>

<li><code>Reading master dump table data</code></p>
<p>Это состояние происходит после <code>Opening master dump table</code>.
</li>
<li><code>Rebuilding the index on master dump table</code></p>
<p>Это состояние происходит после <code>Reading master dump table data
</code>.</p></li></ul>

<h3><a name="event-scheduler-thread-states"></a>9.14.8.
Состояния потока планировщика событий</h3>
<p>Эти состояния происходят для потока Event Scheduler, потоков, которые
создаются, чтобы запустить намеченные события, или потоков,
которые заканчивают планировщик.</p>

<ul><li><p><code>Clearing</code></p>
<p>Поток планировщика или поток, который запускал событие, заканчиваются
или собираются закончиться.</li>

<li><code>Initialized</code></p>
<p>Поток планировщика или поток, который запустит
событие, были инициализированы.</li>

<li><code>Waiting for next activation</code></p>
<p>У планировщика есть непустая очередь событий, но следующая
активация находится в будущем.</li>

<li><code>Waiting for scheduler to stop</code></p>
<p>Поток запустил <code>SET GLOBAL event_scheduler=OFF</code>
и ждет завершения планировщика.</li>
<li><code>Waiting on empty queue</code></p>
<p>Очередь планировщика событий пуста, и он спит.</p></li></ul>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
