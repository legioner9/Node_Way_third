<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 20. Разделение</title>
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="partitioning"></a>Глава 20. Разделение</h1>
<p>Эта глава обсуждает <span>определяемое пользователем разделение</span>. В
MySQL 8.0 есть поддержка разделения для механизма хранения
<a href="innodb.htm"><code>InnoDB</code></a>. Механизм хранения
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>, используемый MySQL Cluster также
оказывает поддержку разделения, но <code>NDB</code> не входит в MySQL 8.0.
</p>

<p>MySQL 8.0 в настоящее время не поддерживает разделение таблиц, используя
любой механизм хранения кроме <code>InnoDB</code>.
Попытка составить разделенные таблицы, используя механизм хранения, который
не предоставляет поддержку разделения, терпит неудачу с
<span>ER_CHECK_NOT_IMPLEMENTED</span>.</p>

<p>MySQL 8.0 Community включает поддержку разделения, оказанную
<code>InnoDB</code>. Для информации о разделении в версии для предприятий
см. <a href="mysql.htm">главу 27</a>.</p>

<p>Если Вы собираете MySQL 8.0 из исходных текстов, конфигурируя с
<code>InnoDB</code> этого достаточно, чтобы произвести двоичные модули
с поддержкой разделения <code>InnoDB</code>.</p>

<p>Невозможно отключить поддержку разделения <code>InnoDB</code>.</p>
<p>Несколько типов разделения поддержаны, так же как подразделение, см.
разделы <a href="#partitioning-types">20.2</a> и
<a href="#partitioning-subpartitions">20.2.6</a>.</p>

<p><a href="#partitioning-management">Раздел 20.3</a> описывает
методы добавления, удаления и изменения разделения в
существующих разделенных таблицах.</p>

<p><a href="#partitioning-maintenance">Раздел 20.3.4</a>,
обсуждает табличные команды обслуживания для
использования с разделенными таблицами.</p>

<p>Таблица <a href="inform.htm#partitions-table"><code>PARTITIONS</code></a>
в <code>INFORMATION_SCHEMA</code> предоставляет информацию о разделении и
разделенных таблицах. См. <a href="inform.htm#partitions-table">раздел 22.14
</a>. Для некоторых примеров запросов к этой таблицы см.
<a href="#partitioning-handling-nulls">раздел 20.2.7</a>.</p>

<p>Для известных проблем с разделением в MySQL 8.0 см.
<a href="#partitioning-limitations">раздел 20.6</a>.</p>
<p>Вы можете также найти, что следующие ресурсы полезны,
работая с разделенными таблицами.</p>

<ul><li><p><a href="../../../forums.mysql.com/list.php@106" target="_top">
MySQL Partitioning Forum</a></p>
<p>Это официальный дискуссионный форум для заинтересованных или
экспериментирующих с разделением в MySQL. Это показывает объявления и
обновления от разработчиков MySQL и других. Это проверено членами
развития разделения и документации.</li>

<li><a href="../../../mikaelronstrom.blogspot.com/default.htm" target="_top">Mikael
Ronstrц╤m's Blog</a></p>
<p>MySQL Partitioning Architect and Lead Developer Mikael Ronstrц╤m
часто отправляет сюда статьи относительно его работы с MySQL
Partitioning и MySQL Cluster.</li>

<li><a href="../../../www.planetmysql.org/default.htm" target="_top">PlanetMySQL</a></p>
<p>Новостной сайт MySQL, показывающий MySQL-связанные блоги, которые должны
представлять интерес для любого, использующего MySQL.</p></li></ul>

<h2><a name="partitioning-overview"></a>
20.1. Краткий обзор разделения в MySQL</h2>
<p>Этот раздел обеспечивает концептуальный краткий
обзор разделения в MySQL 8.0.</p>

<p>Для информации об ограничениях разделения см.
<a href="#partitioning-limitations">раздел 20.6</a>.</p>
<p>Стандарт SQL не обеспечивает руководства относительно физических аспектов
хранения данных. Сам SQL язык предназначен, чтобы работать независимо от
любых структур данных, лежащих в основе схем, таблиц, строк или столбцов, с
которыми он работает. Тем не менее, наиболее усовершенствованные системы
управления базой данных развили некоторые средства определения физического
местоположения, которое будет использоваться для того, чтобы сохранить
определенные части данных с точки зрения файловой системы, аппаратных средств
или даже обоих. В MySQL механизм хранения <code>InnoDB</code>
долго поддерживал понятие табличного пространства (см.
<a href="innodb.htm#innodb-tablespace">раздел 16.7</a>), а MySQL Server
даже до введения разделения мог быть сконфигурирован, чтобы использовать
различные физические каталоги для того, чтобы сохранить различные базы данных
(см. <a href="optimiz.htm#symbolic-links">раздел 9.12.2</a>,
для объяснения того, как это сделано).</p>

<p><span>Разделение</span> двигает это понятие на шаг далее, позволяя Вам
распределить части отдельных таблиц по файловой системе согласно правилам,
которые Вы можете установить в значительной степени как необходимо. В
действительности, различные части таблицы сохранены как отдельные таблицы в
различных местоположениях. Выбранное пользователем правило, по которому
достигнуто разделение данных, известно как <span>функция разделения</span>,
которая в MySQL может быть модулем, простым соответствием ряда диапазонов или
списку, внутренней хеширующей функцией или линейной хеширующей функции.
Функция выбрана согласно типу разделения, определенному пользователем, и
берет в качестве параметра значение снабженного пользователем выражения.
Это выражение может быть значением столбца, функцией, действующей на одно или
более значений столбцов, или набором значений столбцов, в зависимости от типа
разделения, который используется.</p>

<p>В случае <code>RANGE</code>, <code>LIST</code>,
и [<code>LINEAR</code>] <code>HASH</code> значение столбца разделения
передают функции разделения, которая возвращает целочисленное значение,
представляющее число разделения, в котором должна быть сохранена именно эта
запись. Эта функция должна быть непостоянной и неслучайной. Это, возможно, не
содержит запросов, но может использовать выражение SQL, которое допустимо в
MySQL, пока это выражение возвращает <code>NULL</code> или целое число
<em><code>intval</code></em> таким образом, что
<pre>
-MAXVALUE &lt;= <em><code>intval</code></em> &lt;= MAXVALUE
</pre>

<p>(<code>MAXVALUE</code> используется, чтобы представить наименьшее
значение верхней границы для типа рассматриваемого целого числа.
<code>-MAXVALUE</code> представляет самую большую нижнюю границу.</p>

<p>Для [<code>LINEAR</code>] <code>KEY</code>,
<code>RANGE COLUMNS</code> и <code>LIST COLUMNS</code>
выражение разделения состоит из списка из одного или более столбцов. Для
[<code>LINEAR</code>] <code>KEY</code> функция разделения поставляется MySQL.
</p>

<p>Для получения дополнительной информации о разрешенных типах столбца и
функций разделения см. <a href="#partitioning-types">раздел 20.2
</a> и <a href="sql.htm#create-table">раздел 14.1.15</a>, который
обеспечивает описания синтаксиса разделения и дополнительные примеры. Для
информации об ограничениях на разделение функций см.
<a href="#partitioning-limitations-functions">раздел 20.6.3</a>.
</p>

<p>Это известно как <span>горизонтальное разделение</span>,
то есть, различные строки таблицы могут быть назначены на различное
физическое разделение. MySQL 8.0 не поддерживает <span>вертикальное
разделение</span>, в котором различные столбцы таблицы назначены на различное
физическое разделение. Нет никаких планов ввести
вертикальное разделение в MySQL.</p>

<p>Для того, чтобы составить разделенные таблицы, Вы должны использовать
механизм хранения, который поддерживает их. В MySQL 8.0 все разделение той же
самой разделенной таблицы должно использовать тот же самый механизм хранения.
Однако, нет ничего препятствующего Вам использовать различные механизмы
хранения для различных разделенных таблиц на том же самом сервере MySQL или
даже в той же самой базе данных.</p>

<p>В MySQL 8.0 единственный механизм хранения, который поддерживает
разделение это <code>InnoDB</code>. Разделение не может использоваться с
механизмами хранения, которые не поддерживают его, они включают
<code>MyISAM</code>, <code>MERGE</code>, <code>CSV</code> и <code>FEDERATED
</code>.</p>

<p>Составляя разделенную таблицу, механизм хранения по умолчанию используется
как для создания любой таблицы. Чтобы переопределить это поведение,
необходимо только использовать опцию <code>[STORAGE] ENGINE</code>, как
для таблицы, которая не разделена. Целевой механизм хранения должен оказать
поддержку разделения, или запрос терпит неудачу. Вы должны иметь в виду, что
<code>[STORAGE] ENGINE</code> (и другие табличные опции), должна быть
перечислена <span><em>прежде, чем</em></span> любые опции разделения
используются в <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.
Этот пример показывает, как составить таблицу, которая разделена хешем на 6
разделов и использует механизм хранения <code>InnoDB</code> (независимо от
значения <a href="server.htm#sysvar_default_storage_engine"><code>
default_storage_engine</code></a>):
<pre>
CREATE TABLE ti (id INT, amount DECIMAL(7,2), tr_date DATE)
       ENGINE=INNODB PARTITION BY
       HASH(MONTH(tr_date)) PARTITIONS 6;
</pre>

<p>Каждое предложение <code>PARTITION</code> может включать опцию
<code>[STORAGE] ENGINE</code>, но в MySQL 8.0 это не имеет никакого эффекта.
</p>
<p>Если иное не определено, остающиеся примеры в этом обсуждении принимают,
что <a href="server.htm#sysvar_default_storage_engine"><code>
default_storage_engine</code></a> <code>InnoDB</code>.</p>

<p>Разделение относится ко всем данным и индексам таблицы: Вы не можете
разделить только данные и не разделить индексы или наоборот, и при этом Вы не
можете разделить только часть таблицы.</p>

<p>Данные и индексы для каждого разделения, могут быть назначены на
определенный каталог, используя опции <code>DATA DIRECTORY</code> и
<code>INDEX DIRECTORY</code> предложения <code>PARTITION</code> запроса
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.</p>
<p>InnoDB поддерживает опции <code>DATA DIRECTORY</code> и
<code>INDEX DIRECTORY</code> для отдельных разделов и подразделов.</p>

<p>Все столбцы, используемые в выражении разделения таблицы, должны быть
частью уникального ключа, который таблица может иметь, включая любой
первичный ключ. Это означает, что таблица, такая как эта, создаваемая
следующим запросом, не может быть разделена:
<pre>
CREATE TABLE tnp (id INT NOT NULL AUTO_INCREMENT, ref BIGINT NOT NULL,
                  name VARCHAR(255), PRIMARY KEY pk (id),
                  UNIQUE KEY uk (name));
</pre>

<p>Поскольку ключи <code>pk</code> и <code>uk</code> не имеют никаких
столбцов вместе, нет никаких столбцов, доступных для использования в
выражении разделения. Возможные обходные решения в этой ситуации включают
добавление столбца <code>name</code> к первичному ключу таблицы, добавляя
столбец <code>id</code> к <code>uk</code>, или просто удаляя уникальный
ключ в целом. См.
<a href="#partitioning-limitations-partitioning-keys-unique-keys">
раздел 20.6.1</a> для получения дополнительной информации.</p>

<p>Кроме того, <code>MAX_ROWS</code> и <code>MIN_ROWS</code> могут
использоваться, чтобы определить максимальные и минимальные числа строк,
соответственно, которые могут быть сохранены в каждом разделении. См.
<a href="#partitioning-management">раздел 20.3</a>.</p>

<p>Некоторые преимущества разделения перечислены здесь:</p>
<ul><li><p>Разделение позволяет хранить больше данных в одной таблице, чем
можно сохранить на единственном диске или разделе файловой системы.</li>

<li>Данные, которые теряют полноценность, могут часто легко удаляться из
разделенной таблицы, удаляя раздел или разделы, содержащие только эти данные.
Наоборот процесс добавления новых данных может в некоторых случаях быть очень
облегчен, добавляя один или более разделов для того, чтобы
хранить определенные данные.</li>

<li>Некоторые запросы могут быть очень оптимизированы в силу факта что
данные, удовлетворяющие предложению <code>WHERE</code> могут быть сохранены
только в одном разделе, который автоматически исключает любые остающиеся
разделы из поиска. Поскольку разделение может быть изменено после того, как
разделенная таблица была составлена, Вы можете реорганизовать свои данные,
чтобы улучшить частые запросы, которые не могли часто использоваться, когда
схема разделения была сначала настроена. Эта способность исключить
несоответствие разделения (и таким образом любые строки, которые они
содержат) часто упоминается как <span>сокращение разделения</span>. См.
<a href="#partitioning-pruning">раздел 20.4</a>.</p>

<p>Кроме того, MySQL 8.0 допускает явный выбор разделения для запросов.
Например, <a href="sql.htm#select"><code>SELECT * FROM t PARTITION (p0,p1)
WHERE c &lt; 5</code></a> выбирает только те строки в разделениях
<code>p0</code> и <code>p1</code>, которые соответствуют условию
<code>WHERE</code>. В этом случае MySQL не проверяет никакое другое
разделение таблицы <code>t</code>, это может очень ускорить запросы, когда Вы
уже знаете, какое разделение Вы хотите исследовать. Выбор разделения также
поддержан для запросов модификации данных
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#replace"><code>REPLACE</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#load-data"><code>LOAD DATA</code></a> и
<a href="sql.htm#load-xml"><code>LOAD XML</code></a>. См. описания этих
запросов для получения дополнительной информации и примеров.</p></li></ul>

<p>Другая выгода, обычно связанная с разделением, включена в список ниже.
Эти опции в настоящее время не реализуются в разделении MySQL, но высоки в
нашем списке приоритетов.</p>

<ul><li><p>Запросы, вовлекающие совокупность, функционируют так, что
<a href="funct.htm#function_sum"><code>SUM()</code></a> и
<a href="funct.htm#function_count"><code>COUNT()</code></a>
можно легко распараллелить. Простой пример такого запроса:
<code>SELECT salesperson_id, COUNT(orders) as order_total FROM sales
GROUP BY salesperson_id;</code>. Мы подразумеваем, что запрос может быть
выполнен одновременно на каждом разделении, а окончательный результат получен
просто суммируя результаты, полученные для всех разделений.</li>
<li>Достижение большей пропускной способности запроса в силу данных,
распространяющихся по многим дискам.</p></li></ul>

<h2><a name="partitioning-types"></a>20.2. Типы разделения</h2>
<p>Этот раздел обсуждает типы разделения, которые доступны в MySQL 8.0.
Они включают типы, перечисленные здесь:</p>

<ul><li><p><b>RANGE. </b>Этот тип разделения назначает строки на разделение,
основанное на значениях столбцов, находящихся в пределах данного диапазона.
См. <a href="#partitioning-range">раздел 20.2.1</a>.
Для информации о расширении к этому типу <code>RANGE COLUMNS</code>
см. <a href="#partitioning-columns-range">раздел 20.2.3.1</a>.</li>

<li><b>LIST. </b>Подобно <code>RANGE</code>, за исключением того, что
разделение выбрано основываясь на столбцах, соответствующих одному из ряда
дискретных значений. См. <a href="#partitioning-list">раздел
20.2.2</a>. Для информации о расширении к этому типу
<code>LIST COLUMNS</code> см. <a href="#partitioning-columns-list">
раздел 20.2.3.2</a>.</li>

<li><b>HASH. </b>С этим типом разделение выбрано основываясь на значении,
возвращенном определяемым пользователем выражением, которое воздействует на
значения столбцов в строках, которые будут вставлены в таблицу. Функция может
состоять из любого выражения, допустимого в MySQL, которое приводит к
неотрицательному целочисленному значению. Расширение к этому типу
<code>LINEAR HASH</code> также доступно. См.
<a href="#partitioning-hash">раздел 20.2.4</a>.</li>

<li><b>KEY. </b>Этот тип разделения подобен <code>HASH</code>
за исключением того, что только один или более столбцов, которые будут
оценены, поставляются, а сервер MySQL обеспечивает свою собственную
хеширующую функцию. Эти столбцы могут содержать разные данные кроме
целочисленных значений, так как хеширующая функция, поставляемая MySQL,
гарантирует результат целого числа независимо от типа данных столбца.
Расширение к этому типу <code>LINEAR KEY</code>. См.
<a href="#partitioning-key">раздел 20.2.5</a>.</p></li></ul>

<p>Обычное использование разделения базы данных должно выделять данные по
времени. Некоторые системы базы данных поддерживают явное разделение даты,
которое MySQL не осуществляет в 8.0. Однако, не трудно в MySQL создать схемы
разделения, основанные на столбцах <a href="types.htm#datetime"><code>DATE
</code></a>, <a href="types.htm#time"><code>TIME</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a>, или основанные на
выражениях, использующих такие столбцы.</p>

<p>При разделениях <code>KEY</code> или <code>LINEAR KEY</code> Вы можете
использовать столбцы <a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a> как столбец
разделения, не выполняя модификации значения столбца. Например, этот запрос
создания таблицы допустим в MySQL:
<pre>
CREATE TABLE members (firstname VARCHAR(25) NOT NULL,
                      lastname VARCHAR(25) NOT NULL,
                      username VARCHAR(16) NOT NULL,
                      email VARCHAR(35), joined DATE NOT NULL)
       PARTITION BY KEY(joined) PARTITIONS 6;
</pre>

<p>В MySQL 8.0 также возможно использовать столбцы
<a href="types.htm#datetime"><code>DATE</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a> как столбцы разделения
<code>RANGE COLUMNS</code> и <code>LIST COLUMNS</code>.</p>

<p>Другие типы разделения требуют выражения разделения, которое приводит к
целочисленному значению или <code>NULL</code>. Если Вы хотите использовать
основанное на дате разделение <code>RANGE</code>, <code>LIST</code>,
<code>HASH</code> или <code>LINEAR HASH</code>, Вы можете просто использовать
функцию, которая воздействует на столбец <a href="types.htm#datetime"><code>
DATE</code></a>, <a href="types.htm#time"><code>TIME</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a>
и возвращает такое значение, как показано здесь:
<pre>
CREATE TABLE members (firstname VARCHAR(25) NOT NULL,
                      lastname VARCHAR(25) NOT NULL,
                      username VARCHAR(16) NOT NULL, email VARCHAR(35),
                      joined DATE NOT NULL)
       PARTITION BY RANGE( YEAR(joined))
                 (PARTITION p0 VALUES LESS THAN (1960),
                  PARTITION p1 VALUES LESS THAN (1970),
                  PARTITION p2 VALUES LESS THAN (1980),
                  PARTITION p3 VALUES LESS THAN (1990),
                  PARTITION p4 VALUES LESS THAN MAXVALUE);
</pre>

<p>Дополнительные примеры использования разделения дат могут быть найдены в
следующих разделах этой главы:</p>
<ul><li><p><a href="#partitioning-range">раздел 20.2.1</a>.</li>
<li><a href="#partitioning-hash">раздел 20.2.4</a>.</li>
<li><a href="#partitioning-linear-hash">раздел 20.2.4.1</a>.
</p></li></ul>

<p>Для более сложных примеров основанного на дате разделения
см. следующие разделы:</p>
<ul><li><p><a href="#partitioning-pruning">раздел 20.4</a>.</li>
<li><a href="#partitioning-subpartitions">раздел 20.2.6</a>.
</p></li></ul>

<p>Разделение MySQL оптимизировано для использования с функциями
<a href="funct.htm#function_to-days"><code>TO_DAYS()</code></a>,
<a href="funct.htm#function_year"><code>YEAR()</code></a> и
<a href="funct.htm#function_to-seconds"><code>TO_SECONDS()</code></a>.
Однако, Вы можете использовать другую функцию даты и времени, которые
возвращают целое число или <code>NULL</code>, как
<a href="funct.htm#function_weekday"><code>WEEKDAY()</code></a>,
<a href="funct.htm#function_dayofyear"><code>DAYOFYEAR()</code></a> или
<a href="funct.htm#function_month"><code>MONTH()</code></a>. См.
<a href="funct.htm#date-and-time-functions">раздел 13.7</a>.</p>

<p>Независимо от типа разделения разделы всегда нумеруется автоматически и в
порядке создания, начиная с <code>0</code>. Когда новая строка вставлена в
разделенную таблицу, именно эти числа разделения используются в идентификации
правильного раздела. Например, если Ваша таблица использует 4 раздела, они
пронумерованы <code>0</code>, <code>1</code>, <code>2</code> и
<code>3</code>. Для <code>RANGE</code> и <code>LIST</code>
необходимо гарантировать, что есть раздел, определенный для каждого числа
разделения. Для <code>HASH</code> пользовательская функция должна возвратить
целочисленное значение больше <code>0</code>. Для <code>KEY</code> это
проблема автоматически хеширующей функцией, которую сервер
MySQL использует внутренне.</p>

<p>Названия разделения вообще следуют правилам, управляющими другими
идентификаторами MySQL, такими как имена для таблиц и баз данных.
Однако, Вы должны отметить, что имена разделения не являются чувствительными
к регистру. Например, следующий запрос
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
терпит неудачу как показано:
<pre>
mysql&gt; CREATE TABLE t2 (val INT) PARTITION BY LIST(val)
    -&gt;        (PARTITION mypart VALUES IN (1,3,5),
    -&gt;         PARTITION MyPart VALUES IN (2,4,6));
ERROR 1488 (HY000): Duplicate partition name mypart
</pre>

<p>Отказ происходит, потому что MySQL не видит различия между именами
<code>mypart</code> и <code>MyPart</code>.</p>
<p>Когда Вы определяете число разделения для таблицы, это должно быть
выражено как положительное целое число, отличное от нуля, буквальное без
начальных нулей и оно не может таким выражением, как <code>0.8E+01</code> или
<code>6-2</code>, даже если это оценивается к целочисленному значению.
Десятичные дроби не разрешены.</p>

<p>В разделах, которые следуют далее, мы не обязательно обеспечиваем все
возможные формы для синтаксиса, который может использоваться для того, чтобы
создать каждый тип разделения, для этой информации, см.
<a href="sql.htm#create-table">раздел 14.1.15</a>.</p>

<h3><a name="partitioning-range"></a>20.2.1. RANGE</h3>
<p>Таблица, которая разделена диапазоном, разделена таким способом, что
каждый раздел содержит строки, для которых значение выражения разделения
находится в пределах данного диапазона. Диапазоны должны быть непрерывными,
но без наложений и определены, используя оператор
<code>VALUES LESS THAN</code>. Для следующих примеров, предположите, что Вы
составляете таблицу, чтобы хранить отчеты персонала для цепочки из 20
видеомагазинов, перечисленных от 1 до 20:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT NOT NULL, store_id INT NOT NULL);
</pre>

<p>Таблица <code>employees</code>, используемая здесь, не имеет никаких
основных или уникальных ключей. В то время как примеры работают как показано
в целях существующего обсуждения, Вы должны иметь в виду, что таблицы
чрезвычайно вероятно имеют на деле первичные или уникальные ключи или те и
те, и что допустимый выбор для того, чтобы разделить столбцы, зависит от
столбцов, используемых для этих ключей. Для обсуждения этих проблем см.
<a href="#partitioning-limitations-partitioning-keys-unique-keys">
раздел 20.6.1</a>.</p>

<p>Эта таблица может быть разделена диапазоном многими способами, в
зависимости от Ваших потребностей. Один путь состоял бы в том, чтобы
использовать столбец <code>store_id</code>. Например, Вы могли бы решить
разделить таблицу на 4 части, добавляя <code>PARTITION BY RANGE</code>:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT NOT NULL, store_id INT NOT NULL)
       PARTITION BY RANGE (store_id)
          (PARTITION p0 VALUES LESS THAN (6),
           PARTITION p1 VALUES LESS THAN (11),
           PARTITION p2 VALUES LESS THAN (16),
           PARTITION p3 VALUES LESS THAN (21));
</pre>

<p>В этой схеме разделения все строки, соответствующие служащим, работающим в
хранилищах 1-5, сохранены в разделе <code>p0</code>, работающие в хранилищах
6-10 хранятся в <code>p1</code> и т.д. Отметьте, что каждое разделение
определено в порядке, от самого низкого до самого высокого. Это требование
синтаксиса <code>PARTITION BY RANGE</code>, Вы можете думать об этом как о
сходстве с серией проверок <code>if ... elseif ...</code> в C или Java.</p>

<p>Легко решить что новая строка, содержащая данные
<code>(72, 'Mitchell', 'Wilson', '1998-06-25', NULL, 13)</code>
вставлена в раздел <code>p2</code>, но что происходит, когда Ваша цепочка
добавляет 21<sup>-ое</sup> хранилище? В соответствии с этой схемой, нет
никакого правила, которое касается строки с <code>store_id</code> больше 20,
таким образом, будет ошибка, потому что сервер не знает, куда это поместить.
Вы можете препятствовать ошибке при использовании <code>VALUES LESS THAN
</code> в <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>,
который предусматривает все значения больше, чем самое высокое
значение, явно названное:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT NOT NULL, store_id INT NOT NULL)
       PARTITION BY RANGE (store_id)
          (PARTITION p0 VALUES LESS THAN (6),
           PARTITION p1 VALUES LESS THAN (11),
           PARTITION p2 VALUES LESS THAN (16),
           <span><em>PARTITION p3 VALUES LESS THAN MAXVALUE</em></span>);
</pre>
<p>Как с другими примерами в этой главе, мы предполагаем, что механизм
хранения по умолчанию <code>InnoDB</code>.</p>

<p>Другой способ избежать ошибки, когда никакое значение соответствия не
найдено, состоит в том, чтобы использовать ключевое слово
<code>IGNORE</code> как часть запроса <a href="sql.htm#insert"><code>INSERT
</code></a>. Для примера см. <a href="#partitioning-list">раздел
20.2.2</a>. Основная информация про <code>IGNORE</code> есть в
<a href="sql.htm#insert">разделе 14.2.5</a>.</p>

<p><code>MAXVALUE</code> представляет целочисленное значение, которое всегда
больше чем самое большое целочисленное значение (на математическом языке, оно
служит <span>наименьшим числом верхней границы</span>). Теперь, любые строки,
чье значение столбца <code>store_id</code> больше чем или равно 16 (самое
высокое определенное значение) сохранены в разделе <code>p3</code>. В
некоторый момент, когда число хранилищ увеличилось до 25, 30 или больше, Вы
можете использовать <a href="sql.htm#alter-table-partition-operations"><code>
ALTER TABLE</code></a>, чтобы добавить новые разделы для хранилищ
21-25, 26-30 и т.д. (см. <a href="#partitioning-management">раздел
20.3</a> для деталей о том, как это сделать).</p>

<p>Почти таким же способом Вы могли разделить таблицу, основанную на
коде работы, то есть, на диапазонах значений столбца <code>job_code</code>.
Например, предположим, что коды с двумя цифрами используются для регулярных
рабочих (в магазине), коды с тремя цифрами используются для офиса и
поддерживающего персонала, а коды с четырьмя цифрами используются для
управления, Вы могли бы составить разделенную таблицу,
используя следующий запрос:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT NOT NULL, store_id INT NOT NULL)
       PARTITION BY RANGE (job_code)
         (PARTITION p0 VALUES LESS THAN (100),
          PARTITION p1 VALUES LESS THAN (1000),
          PARTITION p2 VALUES LESS THAN (10000));
</pre>

<p>В этом случае все строки, касающиеся рабочих в магазине, были бы сохранены
в разделе <code>p0</code>, те, которые касаются сотрудников офиса и
технического персонала в <code>p1</code>, а те, которые
касаются менеджеров, в раздел <code>p2</code>.</p>

<p>Также возможно использовать выражение в <code>VALUES LESS THAN</code>.
Однако, MySQL должен быть в состоянии оценить возвращаемое значение выражения
как часть сравнения <code>LESS THAN</code> (<code>&lt;</code>).</p>

<p>Вместо того, чтобы разделять табличные данные согласно номеру хранилища,
Вы можете использовать выражение, основанное на одном из двух столбцов
<a href="types.htm#datetime"><code>DATE</code></a>. Например, давайте
предположим, что Вы хотите разделить основываясь на годе, когда каждый
служащий покинул компанию: то есть, значении
<a href="funct.htm#function_year"><code>YEAR(separated)</code></a>.
Пример <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>,
который осуществляет такую схему разделения:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT, store_id INT)
       PARTITION BY RANGE (YEAR(separated))
          (PARTITION p0 VALUES LESS THAN (1991),
           PARTITION p1 VALUES LESS THAN (1996),
           PARTITION p2 VALUES LESS THAN (2001),
           PARTITION p3 VALUES LESS THAN MAXVALUE);
</pre>

<p>В этой схеме для всех служащих, которые уехали до 1991, строки сохранены в
разделе <code>p0</code>, для тех, кто уехал в 1991-1995, в <code>p1</code>,
для тех, кто уехал в 1996-2000, в <code>p2</code>, а для любых служащих,
которые уехали после 2000 года, в <code>p3</code>.</p>

<p>Также возможно разделить таблицу  <code>RANGE</code>, основываясь
на значении столбца <a href="types.htm#datetime"><code>TIMESTAMP</code></a>,
применяя <a href="funct.htm#function_unix-timestamp"><code>UNIX_TIMESTAMP()
</code></a>, как показано в этом примере:
<pre>
CREATE TABLE quarterly_report_status
       (report_id INT NOT NULL, report_status VARCHAR(20) NOT NULL,
        report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        ON UPDATE CURRENT_TIMESTAMP)
       PARTITION BY RANGE (UNIX_TIMESTAMP(report_updated))
         (PARTITION p0 VALUES LESS THAN (UNIX_TIMESTAMP('2008-01-01 00:00:00') ),
          PARTITION p1 VALUES LESS THAN (UNIX_TIMESTAMP('2008-04-01 00:00:00') ),
          PARTITION p2 VALUES LESS THAN (UNIX_TIMESTAMP('2008-07-01 00:00:00') ),
          PARTITION p3 VALUES LESS THAN (UNIX_TIMESTAMP('2008-10-01 00:00:00') ),
          PARTITION p4 VALUES LESS THAN (UNIX_TIMESTAMP('2009-01-01 00:00:00') ),
          PARTITION p5 VALUES LESS THAN (UNIX_TIMESTAMP('2009-04-01 00:00:00') ),
          PARTITION p6 VALUES LESS THAN (UNIX_TIMESTAMP('2009-07-01 00:00:00') ),
          PARTITION p7 VALUES LESS THAN (UNIX_TIMESTAMP('2009-10-01 00:00:00') ),
          PARTITION p8 VALUES LESS THAN (UNIX_TIMESTAMP('2010-01-01 00:00:00') ),
          PARTITION p9 VALUES LESS THAN (MAXVALUE));
</pre>

<p>Любое другое вовлечение выражений
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>
не разрешено (см. Bug #42849).</p>

<p>Разделение диапазона особенно полезно, когда одно или больше
следующих условий верно:</p>
<ul><li><p>Вы хотите или должны удалить <span>старые</span> данные.
Если Вы используете схему разделения, показанную ранее для таблицы
<code>employees</code>, Вы можете просто использовать
<code>ALTER TABLE employees DROP PARTITION p0;</code>, чтобы
удалить все строки, касающиеся служащих, которые прекратили работать на фирму
до 1991 (см. разделы <a href="sql.htm#alter-table">14.1.7</a> и
<a href="#partitioning-management">20.3</a>. Для таблицы с очень
многими строками это может быть намного более эффективным, чем выполнение
<a href="sql.htm#delete"><code>DELETE</code></a>, например,
<code>DELETE FROM employees WHERE YEAR(separated) &lt;= 1990;</code>.</li>

<li>Вы хотите использовать столбец, содержащий дату или время
или содержащий значения, являющиеся результатом некоторого другого ряда.</li>
<li>Вы часто выполняете запросы, которые зависят непосредственно от столбца,
используемого для того, чтобы разделить таблицу. Например, выполняя такой
запрос, как <a href="sql.htm#explain"><code>EXPLAIN PARTITIONS
SELECT COUNT(*) FROM employees WHERE separated BETWEEN '2000-01-01' AND
'2000-12-31' GROUP BY store_id;</code></a>, MySQL может быстро определить тот
единственный раздел <code>p2</code>, который будет просмотрен, потому что
остающиеся разделы не могут содержать отчеты, удовлетворяющие
<code>WHERE</code>. См. <a href="#partitioning-pruning">раздел 20.4
</a> для получения дополнительной информации о том, как это достигнуто.
</p></li></ul>

<p>Разновидность на этом типе разделения <code>RANGE COLUMNS</code>.
Разделение <code>RANGE COLUMNS</code> позволяет использовать много столбцов
для того, чтобы определить диапазоны разделения, которые применяются к
размещению строк в разделении и для того, чтобы определить включение или
исключение определенного раздела, выполняя сокращение разделения. См.
<a href="#partitioning-columns-range">раздел 20.2.3.1</a>.</p>

<p><a name="partitioning-time-intervals"></a><b>Разделение схем, основанных
на временных интервалах. </b>Если Вы хотите осуществить схему разделения,
основанную на диапазонах или интервалах времени в MySQL 8.0, у Вас
есть две опции:</p>

<ol type="1"><li><p>Разделите таблицу <code>RANGE</code> и для выражения
разделения используйте функцию, воздействующую на столбец
<a href="types.htm#datetime"><code>DATE</code></a>,
<a href="types.htm#time"><code>TIME</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a>
и обеспечивающую возвращение целочисленного значения, как показано здесь:
<pre>
CREATE TABLE members (firstname VARCHAR(25) NOT NULL,
                      lastname VARCHAR(25) NOT NULL,
                      username VARCHAR(16) NOT NULL, email VARCHAR(35),
                      joined DATE NOT NULL)
       PARTITION BY RANGE(YEAR(joined))
          (PARTITION p0 VALUES LESS THAN (1960),
           PARTITION p1 VALUES LESS THAN (1970),
           PARTITION p2 VALUES LESS THAN (1980),
           PARTITION p3 VALUES LESS THAN (1990),
           PARTITION p4 VALUES LESS THAN MAXVALUE);
</pre>

<p>В MySQL 8.0 также возможно разделить таблицу <code>RANGE</code>,
основываясь на значении столбца <a href="types.htm#datetime"><code>TIMESTAMP
</code></a>, применив функцию <a href="funct.htm#function_unix-timestamp">
<code>UNIX_TIMESTAMP()</code></a> как показано в этом примере:
<pre>
CREATE TABLE quarterly_report_status
       (report_id INT NOT NULL, report_status VARCHAR(20) NOT NULL,
        report_updated TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        ON UPDATE CURRENT_TIMESTAMP)
       PARTITION BY RANGE (UNIX_TIMESTAMP(report_updated))
          (PARTITION p0 VALUES LESS THAN (UNIX_TIMESTAMP('2008-01-01 00:00:00')),
           PARTITION p1 VALUES LESS THAN (UNIX_TIMESTAMP('2008-04-01 00:00:00')),
           PARTITION p2 VALUES LESS THAN (UNIX_TIMESTAMP('2008-07-01 00:00:00')),
           PARTITION p3 VALUES LESS THAN (UNIX_TIMESTAMP('2008-10-01 00:00:00')),
           PARTITION p4 VALUES LESS THAN (UNIX_TIMESTAMP('2009-01-01 00:00:00')),
           PARTITION p5 VALUES LESS THAN (UNIX_TIMESTAMP('2009-04-01 00:00:00')),
           PARTITION p6 VALUES LESS THAN (UNIX_TIMESTAMP('2009-07-01 00:00:00')),
           PARTITION p7 VALUES LESS THAN (UNIX_TIMESTAMP('2009-10-01 00:00:00')),
           PARTITION p8 VALUES LESS THAN (UNIX_TIMESTAMP('2010-01-01 00:00:00')),
           PARTITION p9 VALUES LESS THAN (MAXVALUE));
</pre>

<p>В MySQL 8.0 любое другое вовлечение выражений
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>
недопустимо (Bug #42849).</p>

<p>Также возможно в MySQL 8.0 использовать
<a href="funct.htm#function_unix-timestamp"><code>
UNIX_TIMESTAMP(timestamp_column)</code></a> как выражение разделения для
таблиц, которые разделены <code>LIST</code>. Однако, это обычно непрактично.
</p></li>

<li><p>Разделите таблицу <code>RANGE COLUMNS</code> с использованием
столбца <a href="types.htm#datetime"><code>DATE</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a> как столбца
разделения. Например, таблица <code>members</code> могла быть определена,
используя столбец <code>joined</code> непосредственно, как показано здесь:
<pre>
CREATE TABLE members (firstname VARCHAR(25) NOT NULL,
                      lastname VARCHAR(25) NOT NULL,
                      username VARCHAR(16) NOT NULL,
                      email VARCHAR(35), joined DATE NOT NULL)
       PARTITION BY RANGE COLUMNS(joined)
          (PARTITION p0 VALUES LESS THAN ('1960-01-01'),
           PARTITION p1 VALUES LESS THAN ('1970-01-01'),
           PARTITION p2 VALUES LESS THAN ('1980-01-01'),
           PARTITION p3 VALUES LESS THAN ('1990-01-01'),
           PARTITION p4 VALUES LESS THAN MAXVALUE);
</pre></li></ol>

<p>Использование разделения столбцов, использующих дату или время, кроме
типов <a href="types.htm#datetime"><code>DATE</code></a> или
<a href="types.htm#datetime"><code>DATETIME</code></a>
не поддержано с <code>RANGE COLUMNS</code>.</p>

<h3><a name="partitioning-list"></a>20.2.2. LIST</h3>
<p>Разделение списка в MySQL подобно диапазону, делящему разными способами.
Как в разделении <code>RANGE</code>, каждое разделение должно быть явно
определено. Главное различие между двумя типами разделения то, что в
разделении списка каждое разделение определено и выбрано основываясь на
членстве значения столбца в одном из ряда списков значения, а не в одном из
ряда непрерывных диапазонов значений. Это сделано при использовании
<code>PARTITION BY LIST(<em><code>expr</code></em>)</code>, где
<em><code>expr</code></em> значение столбца или выражение, основанное на
значении столбца и возвращении целочисленного значения, и затем определении
каждого разделения посредством <code>VALUES IN (<em><code>value_list</code>
</em>)</code>, где <em><code>value_list</code></em>
список разделенных запятой целых чисел.</p>

<p>В MySQL 8.0 возможно соответствовать только списку целых чисел (и возможно
<code>NULL</code>, см. <a href="#partitioning-handling-nulls">
раздел 20.2.7</a>).</p>

<p>Однако, другие типы столбца могут использоваться в списках значения,
используя разделение <code>LIST COLUMN</code>, которое описано
позже в этом разделе.</p>

<p>В отличие от случая с разделением, определенным диапазоном, разделение
списка не должно быть объявлено ни в каком особом порядке. Для более
подробной синтаксической информации см.
<a href="sql.htm#create-table">раздел 14.1.15</a>.</p>

<p>Для примеров, которые следуют далее, мы предполагаем, что основное
определение таблицы, которая будет разделена, обеспечено
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT, store_id INT);
</pre>

<p>Это та же самая таблица, которая использована в качестве основания для
примеров в <a href="#partitioning-range">разделе 20.2.1</a>.
Как с другими примерами разделения, мы предполагаем, что
<a href="server.htm#sysvar_default_storage_engine">
<code>default_storage_engine</code></a> <code>InnoDB</code>.</p>

<p>Предположите, что есть 20 видеомагазинов, распределенных среди 4 франшиз,
как показано в следующей таблице.</p>
<table border="1">
<thead><tr><th scope="col">Регион</th><th scope="col">ID хранилища
</th></tr></thead>
<tbody><tr><td scope="row">North</td><td>3, 5, 6, 9, 17</td></tr>
<tr><td scope="row">East</td><td>1, 2, 10, 11, 19, 20</td></tr>
<tr><td scope="row">West</td><td>4, 12, 13, 14, 18</td></tr>
<tr><td scope="row">Central</td><td>7, 8, 15, 16</td></tr></tbody></table>

<p>Чтобы разделить эту таблицу таким способом, которым строки для хранилищ,
принадлежащих тому же самому региону, сохранены в том же самом разделении,
Вы могли бы использовать <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a>, показанный здесь:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT, store_id INT)
       PARTITION BY LIST(store_id)
         (PARTITION pNorth VALUES IN (3,5,6,9,17),
          PARTITION pEast VALUES IN (1,2,10,11,19,20),
          PARTITION pWest VALUES IN (4,12,13,14,18),
          PARTITION pCentral VALUES IN (7,8,15,16));
</pre>

<p>Это облегчает добавление или удаление записи, касающиеся определенных
областей. Например, предположите, что все хранилища в Западном регионе
проданы другой компании. В MySQL 8.0 все строки, касающиеся служащих,
работающих в хранилищах в том регионе, могут быть удалены запросом
<code>ALTER TABLE employees TRUNCATE PARTITION pWest</code>,
который может быть выполнен намного более эффективно, чем эквивалент
<code>DELETE FROM employees WHERE store_id IN (4,12,13,14,18);</code>.
Использование <code>ALTER TABLE employees DROP PARTITION pWest</code>
также удалит все эти строки, но также удалит и раздел <code>pWest</code>
из определения таблицы: Вы должны были бы использовать
<code>ALTER TABLE ... ADD PARTITION</code>, чтобы восстановить оригинальную
схему разделения таблицы.</p>

<p>Как с разделением <code>RANGE</code>, возможно объединить
разделение <code>LIST</code> с разделением хешем или ключом, чтобы произвести
сложное разделение (подразделение). См.
<a href="#partitioning-subpartitions">раздел 20.2.6</a>.</p>

<p>В отличие от случая с <code>RANGE</code>, нет никакого
<code>MAXVALUE</code>: все математические ожидания для выражения разделения
должны быть покрыты в <code>PARTITION ... VALUES IN (...)</code>. Запрос
<a href="sql.htm#insert"><code>INSERT</code></a>, содержащий неправильное
значение столбца разделения, терпит неудачу с ошибкой, как
показано в этом примере:
<pre>
mysql&gt; CREATE TABLE h2 (c1 INT, c2 INT)
    -&gt;        PARTITION BY LIST(c1)
    -&gt;          (PARTITION p0 VALUES IN (1, 4, 7),
    -&gt;           PARTITION p1 VALUES IN (2, 5, 8));
Query OK, 0 rows affected (0.11 sec)

mysql&gt; INSERT INTO h2 VALUES (3, 5);
<span>ERROR 1525 (HY000): Table has no partition for value 3</span>
</pre>

<p>Вставляя много строки, используя один запрос
<a href="sql.htm#insert"><code>INSERT</code></a> в одну таблицу,
<a href="innodb.htm"><code>InnoDB</code></a>, считает заявление единственной
транзакцией так, чтобы присутствие любых неправильных значений заставило
запрос терпеть неудачу полностью, и таким образом, никакие
строки не вставлены.</p>

<p>Вы можете заставить этот тип ошибки быть проигнорированным при
использовании <code>IGNORE</code>. Если Вы делаете так, строки, содержащие
неправильные значения столбцов разделения, не вставлены, но любые строки с
соответствием значений вставлены, и ни о каких ошибках не сообщают:
<pre>
mysql&gt; TRUNCATE h2;
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT * FROM h2;
Empty set (0.00 sec)

mysql&gt; INSERT IGNORE INTO h2
                 VALUES (2, 5), (6, 10), (7, 5), (3, 1), (1, 9);
Query OK, 3 rows affected (0.00 sec)
Records: 5  Duplicates: 2  Warnings: 0

mysql&gt; SELECT * FROM h2;
+----+----+
| c1 | c2 |
+----+----+
|  7 | 5  |
|  1 | 9  |
|  2 | 5  |
+----+----+
3 rows in set (0.00 sec)
</pre>

<p>MySQL 8.0 также оказывает поддержку для <code>LIST COLUMNS</code>
разновидности разделения <code>LIST</code>, которое позволяет Вам
использовать столбцы любых типов, кроме типов целого числа для того, чтобы
разделить столбцы, и использовать много столбцов в качестве разделения
ключей. Для получения дополнительной информации см.
<a href="#partitioning-columns-list">раздел 20.2.3.2</a>.</p>

<h3><a name="partitioning-columns"></a>20.2.3. COLUMNS</h3>
<p>Следующие два раздела обсуждают разделение <span><code>COLUMNS</code>,
которое является разновидностью <code>RANGE</code> и <code>LIST</code>.
<code>COLUMNS</code> включает использование многих столбцов в разделении
ключей. Все эти столбцы приняты во внимание с целью размещения строк в
разделении и для определения, которое разделение должно быть проверено на
соответствие строк в сокращении разделения.</p>

<p>Кроме того, оба <code>RANGE COLUMNS</code> и <code>LIST COLUMNS</code>
допускают использование столбцов нецелого числа для того, чтобы определить
диапазоны значения или участников списка. Разрешенные типы данных
показывают в следующем списке:</p>

<ul><li><p>Все типы целого числа:
<a href="types.htm#integer-types"><code>TINYINT</code></a>,
<a href="types.htm#integer-types"><code>SMALLINT</code></a>,
<a href="types.htm#integer-types"><code>MEDIUMINT</code></a>,
<a href="types.htm#integer-types"><code>INT</code></a>
(<a href="types.htm#integer-types"><code>INTEGER</code></a>) и
<a href="types.htm#integer-types"><code>BIGINT</code></a>
(это то же самое, как <code>RANGE</code> и <code>LIST</code>).</p>

<p>Другие типы числовых данных (такие, как
<a href="types.htm#fixed-point-types"><code>DECIMAL</code></a> или
<a href="types.htm#floating-point-types"><code>FLOAT</code></a>)
не поддержаны как разделение столбцов.</li>

<li><a href="types.htm#datetime"><code>DATE</code></a> и
<a href="types.htm#datetime"><code>DATETIME</code></a>.</p>
<p>Столбцы, использующие другие типы данных, касающиеся даты или времени, не
поддержаны как разделение столбцов.</li>

<li>Следующие строковые типы: <a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#binary-varbinary"><code>BINARY</code></a> и
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a>.</p>

<p>Столбцы <a href="types.htm#blob"><code>TEXT</code></a> и
<a href="types.htm#blob"><code>BLOB</code></a> не поддержаны
как разделение столбцов.</p></li></ul>

<p>Обсуждения <code>RANGE COLUMNS</code> и <code>LIST COLUMNS</code>
в следующих двух разделах предполагает, что Вы уже знакомы с разделением,
основанным на диапазонах и списках как поддержано в MySQL 5.1 и выше,
для получения дополнительной информации о них см. разделы
<a href="#partitioning-range">20.2.1</a> и
<a href="#partitioning-list">20.2.2</a>, соответственно.</p>

<h4><a name="partitioning-columns-range"></a>20.2.3.1. RANGE COLUMNS</h4>
<p>Разделение столбцов диапазона подобно разделению диапазона, но позволяет
Вам определить разделение, используя диапазоны, основанные на многих
значениях столбцов. Кроме того, Вы можете определить столбцы использования
диапазонов типов кроме типов целого числа.</p>

<p>Разделение <code>RANGE COLUMNS</code> значительно отличается от
<code>RANGE</code> в следующих моментах:</p>
<ul><li><p><code>RANGE COLUMNS</code> не принимает выражения,
только названия столбцов.</li>
<li><code>RANGE COLUMNS</code> принимает список из одного или более столбцов.
</p>

<p><code>RANGE COLUMNS</code> основано на сравнениях между
<span>кортежами</span> (списки значений столбцов), а не сравнениях между
скалярными значениями. Размещение строк в <code>RANGE COLUMNS</code>
также основано на сравнениях между кортежами, это обсуждается
позже в этом разделе.</li>

<li>Столбцы в <code>RANGE COLUMNS</code> не ограничены столбцами целого
числа: строка, <a href="types.htm#datetime"><code>DATE</code></a> и
<a href="types.htm#datetime"><code>DATETIME</code></a> могут также
использоваться в качестве разделения столбцов. См.
<a href="#partitioning-columns">раздел 20.2.3</a>.</p></li></ul>

<p>Основной синтаксис для того, чтобы составить таблицу, разделенную
<code>RANGE COLUMNS</code> такой:
<pre>
CREATE TABLE <em><code>table_name</code></em>
       PARTITIONED BY RANGE COLUMNS(<em><code>column_list</code></em>) (
       PARTITION <em><code>partition_name</code></em> VALUES LESS THAN
                 (<em><code>value_list</code></em>)[,
       PARTITION <em><code>partition_name</code></em> VALUES LESS THAN
                 (<em><code>value_list</code></em>)][,
...])
<em><code>column_list</code></em>:
<em><code>column_name</code></em>[, <em><code>column_name</code></em>][, ...]
<em><code>value_list</code></em>:
<em><code>value</code></em>[, <em><code>value</code></em>][, ...]
</pre>

<p>Не все опции <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>,
могут использоваться, когда создается таблица. Подробности в
<a href="sql.htm#create-table">разделе 14.1.15</a>.</p>

<p>В синтаксисе <em><code>column_list</code></em> список из одного или
более столбцов (иногда названный <span>списком столбцов разделения</span>), а
<em><code>value_list</code></em> список значений (то есть, это <span>список
значений определения разделения</span>). <em><code>value_list</code></em>
должен поставляться для каждого определения разделения, и каждый
<em><code>value_list</code></em> должен иметь то же самое число значений, как
<em><code>column_list</code></em> имеет столбцов. Вообще говоря, если Вы
используете <em><code>N</code></em> столбцов в предложении
<code>COLUMNS</code>, тогда каждое предложение <code>VALUES LESS THAN</code>
должно также поставляться со списком из <em><code>N</code></em> значений.</p>

<p>Элементы в списке столбца разделения и в списке значения, определяющем
каждое разделение, должны быть в том же самом порядке. Кроме того, каждый
элемент в списке значения должен иметь тот же самый тип данных как
соответствующий элемент в списке столбца. Однако, порядок имен столбцов в
списке столбца разделения и списках значения не должен быть тем же самым,
как порядок определений столбцов таблицы в основной части
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.
Как с таблицей, разделенной <code>RANGE</code>, Вы можете использовать
<code>MAXVALUE</code> таким образом, что любое допустимое значение,
вставленное в данный столбец, всегда меньше, чем это значение. Вот пример
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>, который
помогает проиллюстрировать все эти тезисы:
<pre>
mysql&gt; CREATE TABLE rcx (a INT, b INT, c CHAR(3), d INT)
    -&gt;        PARTITION BY RANGE COLUMNS(a,d,c)
    -&gt;          (PARTITION p0 VALUES LESS THAN (5,10,'ggg'),
    -&gt;           PARTITION p1 VALUES LESS THAN (10,20,'mmmm'),
    -&gt;           PARTITION p2 VALUES LESS THAN (15,30,'sss'),
    -&gt;           PARTITION p3 VALUES LESS THAN
    -&gt;                     (MAXVALUE,MAXVALUE,MAXVALUE));
Query OK, 0 rows affected (0.15 sec)
</pre>

<p>Таблица <code>rcx</code> содержит столбцы <code>a</code>, <code>b</code>,
<code>c</code> и <code>d</code>. Список столбцов разделения, поставляемый
предложением <code>COLUMNS</code> использует 3 из этих столбцов в порядке
<code>a</code>, <code>d</code>, <code>c</code>. Каждый список значений,
используемый, чтобы определить разделение, содержит 3 значения в том же самом
порядке, то есть, у каждого кортежа списка значения есть форма
(<code>INT</code>, <code>INT</code>, <code>CHAR(3)</code>),
которая соответствует типам данных, используемым столбцами <code>a</code>,
<code>d</code> и <code>c</code> (в этом порядке).</p>

<p>Размещение строк в разделении определено, сравнивая кортеж от строки,
которая будет вставлена, который соответствует списку столбцов в
<code>COLUMNS</code> с кортежами, используемыми в <code>VALUES LESS THAN
</code>, чтобы определить раздел таблицы. Поскольку мы сравниваем кортежи (то
есть, списки или наборы значений), а не скалярные значения, семантика
<code>VALUES LESS THAN</code> несколько отличается от случая с простым
<code>RANGE</code>. В <code>RANGE</code> строка, производящая значение
выражения, которое равно предельному значению в <code>VALUES LESS THAN</code>
никогда не помещается в соответствующий раздел, однако, используя
<code>RANGE COLUMNS</code> это иногда возможно.</p>

<p>Рассмотрите таблицу <code>RANGE</code>, которую создали так:
<pre>
CREATE TABLE r1 (a INT, b INT) PARTITION BY RANGE (a)
       (PARTITION p0 VALUES LESS THAN (5),
        PARTITION p1 VALUES LESS THAN (MAXVALUE));
</pre>

<p>Если мы вставляем 3 строки в эту таблицу, таким образом, что значение
столбца для <code>a</code> = <code>5</code> для каждой строки, все 3 строки
сохранены в разделе <code>p1</code>, потому что значение столбца
<code>a</code> в каждом случае не меньше 5, как мы можем видеть, выполняя
надлежащий запрос <a href="inform.htm#partitions-table"><code>
INFORMATION_SCHEMA.PARTITIONS</code></a>:
<pre>
mysql&gt; INSERT INTO r1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; SELECT PARTITION_NAME,TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'r1';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |  0         |
| p1             |  3         |
+----------------+------------+
2 rows in set (0.00 sec)
</pre>

<p>Теперь рассмотрите подобную таблицу <code>rc1</code>, которая использует
разделение <code>RANGE COLUMNS</code> с обоими столбцами <code>a</code> и
<code>b</code> в <code>COLUMNS</code>, создаваемыми как показано здесь:
<pre>
CREATE TABLE rc1 (a INT, b INT) PARTITION BY RANGE COLUMNS(a, b)
       (PARTITION p0 VALUES LESS THAN (5, 12),
        PARTITION p3 VALUES LESS THAN (MAXVALUE, MAXVALUE));
</pre>

<p>Если мы вставляем точно те же самые строки в <code>rc1</code>, мы только
что вставили в <code>r1</code>, распределение строк очень отличается:
<pre>
mysql&gt; INSERT INTO rc1 VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; SELECT PARTITION_NAME,TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'rc1';
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |  2         |
| p            | p1             |  1         |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre>

<p>Это потому, что мы сравниваем строки, а не скалярные значения. Мы можем
сравнить значения строки, вставленные с ограничивающим значением строки из
<code>VALUES THAN LESS THAN</code>, используя для определения раздела
<code>p0</code> в таблице <code>rc1</code>, так:
<pre>
mysql&gt; SELECT (5,10) &lt; (5,12), (5,11) &lt; (5,12), (5,12) &lt; (5,12);
+-----------------+-----------------+-----------------+
| (5,10) &lt; (5,12) | (5,11) &lt; (5,12) | (5,12) &lt; (5,12) |
+-----------------+-----------------+-----------------+
| 1               | 1               | 0               |
+-----------------+-----------------+-----------------+
1 row in set (0.00 sec)
</pre>

<p>Эти 2 кортежа <code>(5,10)</code> и <code>(5,11)</code>
оцениваются как меньше <code>(5,12)</code>, таким образом, они сохранены в
разделе <code>p0</code>. А вот <code>(5,12)</code> не меньше
<code>(5,12)</code> и сохранен в разделе <code>p1</code>.</p>

<p><a href="sql.htm#select"><code>SELECT</code></a> в предыдущем примере,
возможно, также было написано, используя явные конструкторы строки:
<pre>
SELECT ROW(5,10) &lt; ROW(5,12), ROW(5,11) &lt; ROW(5,12), ROW(5,12) &lt; ROW(5,12);
</pre>

<p>Для таблицы, разделенной <code>RANGE COLUMNS</code>,
используя только единственный столбец разделения, хранение строк в разделении
то же самое, как в таблице, которая разделена <code>RANGE</code>. Следующий
запрос <code>CREATE TABLE</code> составляет таблицу, разделенную <code>RANGE
COLUMNS</code> с использованием 1 столбца разделения:
<pre>
CREATE TABLE rx (a INT, b INT) PARTITION BY RANGE COLUMNS (a)
       (PARTITION p0 VALUES LESS THAN (5),
        PARTITION p1 VALUES LESS THAN (MAXVALUE));
</pre>

<p>Если мы вставляем строки <code>(5,10)</code>, <code>(5,11)</code> и
<code>(5,12)</code> в эту таблицу, мы можем видеть, что их размещение то же
самое, как для таблицы <code>r</code>, которую мы создали и заполнили ранее:
<pre>
mysql&gt; INSERT INTO rx VALUES (5,10), (5,11), (5,12);
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql&gt; SELECT PARTITION_NAME,TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'rx';
+--------------+----------------+------------+
| TABLE_SCHEMA | PARTITION_NAME | TABLE_ROWS |
+--------------+----------------+------------+
| p            | p0             |  0         |
| p            | p1             |  3         |
+--------------+----------------+------------+
2 rows in set (0.00 sec)
</pre>

<p>Также возможно составить таблицы, разделенные <code>RANGE COLUMNS</code>,
где предельные значения для одного или более столбцов повторены в
последовательных определениях разделения. Вы можете сделать это, пока кортежи
значений столбцов, используемых, чтобы определить разделение, строго
увеличиваются. Например, каждый из следующих запросов
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> допустим:
<pre>
CREATE TABLE rc2 (a INT, b INT)
       PARTITION BY RANGE COLUMNS(a,b)
          (PARTITION p0 VALUES LESS THAN (0,10),
           PARTITION p1 VALUES LESS THAN (10,20),
           PARTITION p2 VALUES LESS THAN (10,30),
           PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE));

CREATE TABLE rc3 (a INT, b INT)
       PARTITION BY RANGE COLUMNS(a,b)
          (PARTITION p0 VALUES LESS THAN (0,10),
           PARTITION p1 VALUES LESS THAN (10,20),
           PARTITION p2 VALUES LESS THAN (10,30),
           PARTITION p3 VALUES LESS THAN (10,35),
           PARTITION p4 VALUES LESS THAN (20,40),
           PARTITION p5 VALUES LESS THAN (MAXVALUE,MAXVALUE));
</pre>

<p>Следующий запрос также преуспевает, даже при том, что могло бы показаться
на первый взгляд, что это не будет работать, начиная с предельного значения
столбца <code>b</code> 25 для раздела <code>p0</code>, 20 для
<code>p1</code>, и предельного значения столбца
<code>c</code> 100 для <code>p1</code> (и 50 для <code>p2</code>):
<pre>
CREATE TABLE rc4 (a INT, b INT, c INT)
       PARTITION BY RANGE COLUMNS(a,b,c)
          (PARTITION p0 VALUES LESS THAN (0,25,50),
           PARTITION p1 VALUES LESS THAN (10,20,100),
           PARTITION p2 VALUES LESS THAN (10,30,50)
           PARTITION p3 VALUES LESS THAN (MAXVALUE,MAXVALUE,MAXVALUE));
</pre>

<p>Разрабатывая таблицы, разделенные <code>RANGE COLUMNS</code>,
Вы можете всегда проверять последовательные определения разделения, сравнивая
желаемые кортежи, используя клиент <a href="programs.htm#mysql"><span>
<strong>mysql</strong></span></a>:
<pre>
mysql&gt; SELECT (0,25,50) &lt; (10,20,100), (10,20,100) &lt; (10,30,50);
+-------------------------+--------------------------+
| (0,25,50) &lt; (10,20,100) | (10,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
| 1                       | 1                        |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre>

<p>Если <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
содержит определения разделения, которые не находятся в строго
увеличивающемся порядке, он терпит неудачу с ошибкой, как
показано в этом примере:
<pre>
mysql&gt; CREATE TABLE rcf (a INT, b INT, c INT)
    -&gt;        PARTITION BY RANGE COLUMNS(a,b,c)
    -&gt;          (PARTITION p0 VALUES LESS THAN (0,25,50),
    -&gt;           PARTITION p1 VALUES LESS THAN (20,20,100),
    -&gt;           PARTITION p2 VALUES LESS THAN (10,30,50),
    -&gt;           PARTITION p3 VALUES LESS THAN
    -&gt;                     (MAXVALUE, MAXVALUE, MAXVALUE));
<span>ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing
for each partition</span>
</pre>

<p>Когда Вы получаете такую ошибку, Вы можете вывести, какие определения
разделения недопустимы, делая сравнение <span>меньше чем</span>
между их списками столбцов. В этом случае проблема с определением раздела
<code>p2</code>, потому что кортеж, использованный для его определения,
не меньше, чем кортеж для определения <code>p3</code>, как показано здесь:
<pre>
mysql&gt; SELECT (0,25,50) &lt; (20,20,100), (20,20,100) &lt; (10,30,50);
+-------------------------+--------------------------+
| (0,25,50) &lt; (20,20,100) | (20,20,100) &lt; (10,30,50) |
+-------------------------+--------------------------+
| 1                       | 0                        |
+-------------------------+--------------------------+
1 row in set (0.00 sec)
</pre>

<p>Также возможно для <code>MAXVALUE</code> появиться для того же самого
столбца больше, чем в одном <code>VALUES LESS THAN</code> при использовании
<code>RANGE COLUMNS</code>. Однако, предельные значения для отдельных
столбцов в последовательных определениях разделения должны иначе
увеличиваться, должно быть не больше, чем одно разделение, где
<code>MAXVALUE</code> используется в качестве верхнего предела для всех
значений столбцов, и это определение разделения должно быть последним в
списке <code>PARTITION ... VALUES LESS THAN</code>. Кроме того, Вы не можете
использовать <code>MAXVALUE</code> как предельное значение для первого
столбца больше чем в одном определении разделения.</p>

<p>Как заявлено ранее, также возможно с <code>RANGE COLUMNS</code>
использовать столбцы нецелого числа в качестве разделения столбцов. (См.
<a href="#partitioning-columns">раздел 20.2.3</a> для их полного
списка). Предположим, что таблица <code>employees</code> (которая не
разделена), создали с использованием следующего запроса:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT NOT NULL, store_id INT NOT NULL);
</pre>

<p>Используя разделение <code>RANGE COLUMNS</code>, Вы можете создать версию
этой таблицы, которая хранит каждую строку в одном из четырех разделов,
основываясь на фамилии служащего:
<pre>
CREATE TABLE employees_by_lname (id INT NOT NULL, fname VARCHAR(30),
                                 lname VARCHAR(30),
                                 hired DATE NOT NULL DEFAULT '1970-01-01',
                                 separated DATE NOT NULL DEFAULT '9999-12-31',
                                 job_code INT NOT NULL,
                                 store_id INT NOT NULL)
       PARTITION BY RANGE COLUMNS (lname)
          (PARTITION p0 VALUES LESS THAN ('g'),
           PARTITION p1 VALUES LESS THAN ('m'),
           PARTITION p2 VALUES LESS THAN ('t'),
           PARTITION p3 VALUES LESS THAN (MAXVALUE));
</pre>

<p>Альтернативно, Вы могли переделать <code>employees</code>, используя эту
схему, выполняя следующий запрос
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>:
<pre>
ALTER TABLE employees PARTITION BY RANGE COLUMNS (lname)
      (PARTITION p0 VALUES LESS THAN ('g'),
       PARTITION p1 VALUES LESS THAN ('m'),
       PARTITION p2 VALUES LESS THAN ('t'),
       PARTITION p3 VALUES LESS THAN (MAXVALUE));
</pre>

<p>Поскольку у различных наборов символов и сопоставлений есть различные
порядки сортировки, наборы символов и сопоставления в использовании могут
иметь влияние на распределение строк по таблице <code>RANGE COLUMNS</code>,
используя строковые столбцы в качестве разделения столбцов. Кроме того,
изменения набора символов или сопоставления для данной базы данных, таблицы
или столбца после того, как такая таблица составлена, может вызвать изменения
в том, как распределены строки. Например, используя чувствительное к регистру
сопоставление <code>'and'</code> сортируется ДО <code>'Andersen'</code>,
но используя сопоставление, которое является нечувствительным к регистру,
верно как раз обратное.</p>

<p>Точно так же Вы можете сделать таблицу <code>employees</code>, которая
будет разделена таким способом, которым каждая строка сохранена в одном из
нескольких разделов, основываясь на десятилетии, в котором соответствующий
служащий был нанят, используя запрос
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>, как показано здесь:
<pre>
ALTER TABLE employees PARTITION BY RANGE COLUMNS (hired)
      (PARTITION p0 VALUES LESS THAN ('1970-01-01'),
       PARTITION p1 VALUES LESS THAN ('1980-01-01'),
       PARTITION p2 VALUES LESS THAN ('1990-01-01'),
       PARTITION p3 VALUES LESS THAN ('2000-01-01'),
       PARTITION p4 VALUES LESS THAN ('2010-01-01'),
       PARTITION p5 VALUES LESS THAN (MAXVALUE));
</pre>

<h4><a name="partitioning-columns-list"></a>20.2.3.2. LIST COLUMNS</h4>
<p>MySQL 8.0 оказывает поддержку для разделения <code>LIST COLUMNS</code>.
Это разновидность разделения <code>LIST</code>, которое позволяет
использование многих столбцов как ключей разделения, и  использовать столбцы
разных типов данных в качестве разделения столбцов: Вы можете использовать
строковые типы, <a href="types.htm#datetime"><code>DATE</code></a> и
<a href="types.htm#datetime"><code>DATETIME</code></a>. Для получения
дополнительной информации о разрешенных типах данных для столбцов
<code>COLUMNS</code> см. <a href="#partitioning-columns">
раздел 20.2.3</a>.</p>

<p>Предположите, что у Вас есть бизнес, у которого есть клиенты в 12 городах,
которые, для продаж и маркетинговых целей, Вы организуете в 4 области по 3
города в каждой, как показано в следующей таблице:</p>

<table border="1">
<thead><tr><th scope="col">Область</th><th scope="col">Города
</th></tr></thead>
<tbody><tr><td scope="row">1</td><td>Oskarshamn, Hц╤gsby, Mц╤nsterц╔s</td>
</tr>
<tr><td scope="row">2</td><td>Vimmerby, Hultsfred, Vц╓stervik</td></tr>
<tr><td scope="row">3</td><td>Nц╓ssjц╤, Eksjц╤, Vetlanda</td></tr>
<tr><td scope="row">4</td><td>Uppvidinge, Alvesta, Vц╓xjo</td>
</tr></tbody></table>

<p>С разделением <code>LIST COLUMNS</code> Вы можете составить таблицу для
данных о клиентах, которая назначает строку на любой из 4 разделов,
соответствующего этим областям, основываясь на названии города, где клиент
находится, как показано здесь:
<pre>
CREATE TABLE customers_1 (first_name VARCHAR(25), last_name VARCHAR(25),
                          street_1 VARCHAR(30), street_2 VARCHAR(30),
                          city VARCHAR(15), renewal DATE)
       PARTITION BY LIST COLUMNS(city)
         (PARTITION pRegion_1 VALUES IN('Oskarshamn', 'Hц╤gsby', 'Mц╤nsterц╔s'),
          PARTITION pRegion_2 VALUES IN('Vimmerby', 'Hultsfred', 'Vц╓stervik'),
          PARTITION pRegion_3 VALUES IN('Nц╓ssjц╤', 'Eksjц╤', 'Vetlanda'),
          PARTITION pRegion_4 VALUES IN('Uppvidinge', 'Alvesta', 'Vц╓xjo'));
</pre>

<p>Как с разделением <code>RANGE COLUMNS</code>, Вы не должны использовать
выражения в <code>COLUMNS()</code>, чтобы преобразовать значения столбцов в
целые числа. Фактически, использование выражений кроме имен столбцов
не разрешается с <code>COLUMNS()</code>.</p>

<p>Также возможно использовать столбцы <a href="types.htm#datetime"><code>
DATE</code></a> и <a href="types.htm#datetime"><code>DATETIME</code></a>,
как показано в следующем примере, который использует то же самое имя и
столбцы как таблица <code>customers_1</code>, но использует разделение
<code>LIST COLUMNS</code>, основанное на столбце <code>renewal</code>, чтобы
сохранить строки в одном из 4 разделов в зависимости от недели в феврале
2010:
<pre>
CREATE TABLE customers_2 (first_name VARCHAR(25), last_name VARCHAR(25),
                          street_1 VARCHAR(30), street_2 VARCHAR(30),
                          city VARCHAR(15), renewal DATE)
       PARTITION BY LIST COLUMNS(renewal)
          (PARTITION pWeek_1
             VALUES IN('2010-02-01', '2010-02-02', '2010-02-03',
                       '2010-02-04', '2010-02-05', '2010-02-06',
                       '2010-02-07'),
           PARTITION pWeek_2
             VALUES IN('2010-02-08', '2010-02-09', '2010-02-10',
                       '2010-02-11', '2010-02-12', '2010-02-13',
                       '2010-02-14'),
           PARTITION pWeek_3
             VALUES IN('2010-02-15', '2010-02-16', '2010-02-17',
                       '2010-02-18', '2010-02-19', '2010-02-20',
                       '2010-02-21'),
           PARTITION pWeek_4
             VALUES IN('2010-02-22', '2010-02-23', '2010-02-24',
                       '2010-02-25', '2010-02-26', '2010-02-27',
                       '2010-02-28'));
</pre>

<p>Это работает, но становится тяжело определить и поддержать,
если число вовлеченных дат становится очень большим. В таких случаях обычно
более практично использовать <code>RANGE</code> или <code>RANGE COLUMNS
</code>. В этом случае мы хотим использовать как ключ разделения столбец
<a href="types.htm#datetime"><code>DATE</code></a> и применяем разделение
<code>RANGE COLUMNS</code>, как показано здесь:
<pre>
CREATE TABLE customers_3 (first_name VARCHAR(25), last_name VARCHAR(25),
                          street_1 VARCHAR(30), street_2 VARCHAR(30),
                          city VARCHAR(15), renewal DATE)
       PARTITION BY RANGE COLUMNS(renewal)
                 (PARTITION pWeek_1 VALUES LESS THAN('2010-02-09'),
                  PARTITION pWeek_2 VALUES LESS THAN('2010-02-15'),
                  PARTITION pWeek_3 VALUES LESS THAN('2010-02-22'),
                  PARTITION pWeek_4 VALUES LESS THAN('2010-03-01'));
</pre>
<p>Кроме того (как с <code>RANGE COLUMNS</code>), Вы можете использовать
много столбцов в редложении <code>COLUMNS()</code>.</p>

<h3><a name="partitioning-hash"></a>20.2.4. HASH</h3>
<p>Разделение <code>HASH</code> используется прежде всего, чтобы
гарантировать распределение данных среди предопределенного числа разделов.
С диапазоном или разделением списка, Вы должны определить явно, где
данное значение столбца или набор значений столбцов должны быть сохранены.
С разделением хеша это решение принимается сервером и Вы должны только
определить значение столбца или выражение, основанное на значении столбца,
которое будет хешировано, и число разделов, на которое должна
быть поделена таблица.</p>

<p>Чтобы разделить таблицу с применением <code>HASH</code>, надо передать
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> предложение
<code>PARTITION BY HASH (<em><code>expr</code></em>)</code>, где
<em><code>expr</code></em> выражение, которое возвращает целое число. Это
может просто быть названием столбца, тип которого один из типов целого числа
MySQL. Кроме того, Вы наиболее вероятно хотите управлять этим с
<code>PARTITIONS <em><code>num</code></em></code>, где
<em><code>num</code></em> положительное целое число, представляющее число
разделов, на которые должна быть разделена таблица.</p>

<p>Для простоты таблицы в примерах, которые следуют ниже, не используют
ключей. Вы должны знать, что, если у таблицы есть какие-либо уникальные
ключи, каждый столбец, используемый в выражении разделения для этой таблицы,
должен быть частью каждого уникального ключа, включая первичный ключ. См.
<a href="#partitioning-limitations-partitioning-keys-unique-keys">
раздел 20.6.1</a>.</p>

<p>Следующий запрос составляет таблицу, которая использует хеширование на
столбце <code>store_id</code> и разделена на 4 раздела:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT, store_id INT)
       PARTITION BY HASH(store_id) PARTITIONS 4;
</pre>

<p>Если Вы не включаете предложение <code>PARTITIONS</code>, число
разделов по умолчанию <code>1</code>. Использование ключевого слова
<code>PARTITIONS</code> без числа после него
приводит к синтаксической ошибке.</p>

<p>Вы можете также использовать выражение SQL, которое возвращает целое число
для <em><code>expr</code></em>. Например, Вы могли бы хотеть разделить
данные, основываясь на годе, в котором был нанят служащий.
Это может быть сделано как показано здесь:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT, store_id INT)
       PARTITION BY HASH(YEAR(hired)) PARTITIONS 4;
</pre>

<p><em><code>expr</code></em> должен возвратить непостоянное, неслучайное
целочисленное значение (другими словами, это должно изменяться, но быть
детерминировано) и не должен содержать запрещенные конструкции как описано в
<a href="#partitioning-limitations">разделе 20.6</a>.
Вы должны также иметь в виду, что это выражение оценено каждый раз, когда
строка вставлена или обновлена (или возможно удалена). Это означает, что
очень сложные выражения могут дать начало исполнительным проблемам, особенно
выполняя операции (такие, как пакет вставок), которые затрагивают
очень много строк.</p>

<p>Самая эффективная хеширующая функция та, которая работает на единственном
столбце таблицы и чьи значения последовательно растут или уменьшаются со
значением столбца, поскольку это учитывает
<span>уменьшение</span> на диапазонах разделения.
Таким образом, чем точнее выражение меняется в зависимости от значения
столбца, на котором базируется, тем более эффективно MySQL может использовать
это выражение для разделения.</p>

<p>Например, где столбец <code>date_col</code> имеет тип
<a href="types.htm#datetime"><code>DATE</code></a>, выражение
<a href="funct.htm#function_to-days"><code>TO_DAYS(date_col)</code></a>
изменяется непосредственно со значением <code>date_col</code>,
потому что для каждого изменения в значении <code>date_col</code>,
выражение изменяется в последовательной манере. Различие выражения
<a href="funct.htm#function_year"><code>YEAR(date_col)</code></a>
относительно <code>date_col</code> является не совсем столь же прямым как
<a href="funct.htm#function_to-days"><code>TO_DAYS(date_col)</code></a>,
потому что не каждое возможное изменение в <code>date_col</code>
вызывает эквивалентное изменение в
<a href="funct.htm#function_year"><code>YEAR(date_col)</code></a>.
Даже в этом случае
<a href="funct.htm#function_year"><code>YEAR(date_col)</code></a>
хороший кандидат на хеширующую функцию, потому что это изменяется
непосредственно с частью <code>date_col</code> и нет никакого возможного
изменения в <code>date_col</code>, которое вызывает непропорциональное
изменение в <a href="funct.htm#function_year"><code>YEAR(date_col)</code>
</a>.</p>

<p>Предположите, что Вы имеете столбец <code>int_col</code> с типом
<a href="types.htm#integer-types"><code>INT</code></a>.
Теперь рассмотрите выражение <a href="funct.htm#function_pow"><code>
POW(5-int_col,3) + 6</code></a>. Это было бы плохим выбором для хеширующей
функции потому, что изменение в значении <code>int_col</code>
не вызовет пропорциональное изменение в значении выражения.
Например, изменение <code>int_col</code> с <code>5</code> до <code>6</code>
вызывает изменение <code>-1</code> в значении выражения, но изменение
значения <code>int_col</code> от <code>6</code> до <code>7</code> вызывает
изменение уже в <code>-7</code> в значении выражения.</p>

<p>Другими словами, лучше, если график значения столбца как можно ближе к
прямой линии <code>y=<em><code>c</code></em>x</code>, где
<em><code>c</code></em> некоторая константа отличная от нуля.
Это имеет отношение к факту что, чем более нелинейно выражение, тем более
неравное распределение данных среди разделов оно производит.</p>

<p>В теории сокращение также возможно для выражений, вовлекающих больше, чем
одно значение столбца, но определение, какие из таких выражений являются
подходящими, может быть довольно трудным и отнимающим много времени. Поэтому
использование выражений хеширования, вовлекающих много столбцов,
особенно не рекомендуется.</p>

<p>Когда <code>PARTITION BY HASH</code> используется, механизм хранения
определяет, который раздел <em><code>num</code></em>
использовать, основываясь на модуле результата пользовательской функции.
Другими словами, для выражения <em><code>expr</code></em>
раздел, в котором сохранена запись, является номером раздела
<em><code>N</code></em>, где <code><em><code>N</code></em> = MOD(<em><code>
expr</code></em>, <em><code>num</code></em>)</code>. Предположите, что
таблица <code>t1</code> определена следующим образом, так, чтобы у
нее было 4 раздела:
<pre>
CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
       PARTITION BY HASH(YEAR(col3)) PARTITIONS 4;
</pre>

<p>Если Вы вставляете запись в <code>t1</code>, а значение
<code>col3</code> = <code>'2005-09-15'</code>,
раздел, в котором это сохранено, определен следующим образом:
<pre>
MOD(YEAR('2005-09-01'),4) = MOD(2005,4) = 1
</pre>

<p>MySQL 8.0 также поддерживает разновидность разделения <code>HASH</code>,
известную как <span>linear hashing</span>, которая использует более сложный
алгоритм для того, чтобы определить размещение новых строк, вставленных в
разделенную таблицу. См.
<a href="#partitioning-linear-hash">раздел 20.2.4.1</a>.</p>

<p>Пользовательская функция оценена каждый раз, когда запись
вставлена или обновлена.</p>
<p>Если у таблицы, которая будет разделена, есть ключ <code>UNIQUE</code>,
тогда любые столбцы, поставляемые как параметры пользовательской функции
<code>HASH</code>  или <code>KEY</code> <em><code>column_list</code></em>
должны быть частью этого ключа.</p>

<h4><a name="partitioning-linear-hash"></a>20.2.4.1. LINEAR HASH</h4>
<p>Линейное хеширование отличается от регулярного хеширования, в котором
линейное хеширование использует линейный алгоритм, тогда как регулярное
хеширование использует модуль значения хеширующей функции.</p>

<p>Синтаксически, единственная разница между линейным разделением хеша и
регулярным хешированием это добавление ключевого слова <code>LINEAR</code>
с <code>PARTITION BY</code>, как показано здесь:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(30),
                        lname VARCHAR(30),
                        hired DATE NOT NULL DEFAULT '1970-01-01',
                        separated DATE NOT NULL DEFAULT '9999-12-31',
                        job_code INT, store_id INT)
       PARTITION BY LINEAR HASH(YEAR(hired)) PARTITIONS 4;
</pre>

<p>Учитывая выражение <em><code>expr</code></em>, разделение, в котором
сохранена запись, когда линейное хеширование используется, является номером
раздела <em><code>N</code></em> из числа <em><code>num</code></em> разделов,
где <em><code>N</code></em> получен согласно следующему алгоритму:</p>

<ol type="1"><li><p>Найти следующую степень 2 больше
<em><code>num</code></em>. Мы называем это значение
<em><code>V</code></em>, вычисляется оно так:
<pre>
<em><code>V</code></em> = POWER(2, CEILING(LOG(2, <em><code>num</code></em>)))
</pre>

<p>Предположите, что <em><code>num</code></em> 13. Тогда
<a href="funct.htm#function_log"><code>LOG(2,13)</code></a> 3.7004397181413.
<a href="funct.htm#function_ceiling"><code>CEILING(3.7004397181411)</code>
</a> 4, а <em><code>V</code></em> = <a href="funct.htm#function_power"><code>
POWER(2,4)</code></a> = 16.
</li>

<li>Пусть <em><code>N</code></em> =
<em><code>F</code></em>(<em><code>column_list</code></em>)
&amp; (<em><code>V</code></em> - 1).</li>

<li>Пока <em><code>N</code></em> &gt;= <em><code>num</code></em>:</p>
<ul><li><p><em><code>V</code></em> = CEIL(<em><code>V</code></em> / 2)</li>
<li><em><code>N</code></em> = <em><code>N</code></em> &amp;
(<em><code>V</code></em> - 1)</p></li></ul></li></ol>

<p>Предположите что таблица <code>t1</code>, используя линейное разделение
хеша и 6 разделов, создается, используя этот запрос:
<pre>
CREATE TABLE t1 (col1 INT, col2 CHAR(5), col3 DATE)
       PARTITION BY LINEAR HASH(YEAR(col3)) PARTITIONS 6;
</pre>

<p>Теперь предположите, что Вы хотите вставить две записи в
<code>t1</code>, значения столбца <code>col3</code> <code>'2003-04-14'</code>
и <code>'1998-10-19'</code>. Номер раздела для первого из них
определен следующим образом:
<pre>
<em><code>V</code></em> = POWER(2, CEILING( LOG(2,6) )) = 8
<em><code>N</code></em> = YEAR('2003-04-14') &amp; (8 - 1) = 2003 &amp; 7 = 3
<span><em>3 &gt;= 6 FALSE: запись сохранена в раздел #3</em></span>
</pre>

<p>Номер раздела для второй записи определен следующим образом:
<pre>
<em><code>V</code></em> = 8
<em><code>N</code></em> = YEAR('1998-10-19') &amp; (8-1) = 1998 &amp; 7 = 6
<span><em>6 &gt;= 6 TRUE: нужен еще шаг...</em></span>
<em><code>N</code></em> = 6 &amp; CEILING(8 / 2) = 6 &amp; 3 = 2
<span><em>2 &gt;= 6 FALSE: запись сохранена в раздел #2</em></span>
</pre>

<p>Преимущество в разделении линейным хешем состоит в том, что добавление,
удаление и слияние разделов сделаны намного быстрее, что может быть выгодно,
имея дело с таблицами, содержащими чрезвычайно большое количество (терабайты)
данных. Недостаток: данные, вероятно, будут менее равномерно распределены
между разделами по сравнению с распределением, полученным, используя
регулярное разделение хеша.</p>

<h3><a name="partitioning-key"></a>20.2.5. KEY</h3>
<p>Разделение ключом подобно разделению хешем, за исключением того, что там,
где разделение хеша использует определяемое пользователем выражение,
хеширующая функция для ключевого разделения поставляется сервером MySQL. Эта
внутренняя хеширующая функция основана на том же самом алгоритме, как
<a href="funct.htm#function_password"><code>PASSWORD()</code></a>.</p>

<p>Синтаксис для <code>CREATE TABLE ... PARTITION BY KEY</code>
подобен тому, которым составляют таблицу, разделенную хешем. Существенные
различия перечислены здесь:</p>

<ul><li><p><code>KEY</code> используется вместо <code>HASH</code>.</li>
<li><code>KEY</code> берет только список из ноля или больше имен столбцов.
Любые столбцы, используемые в качестве ключа разделения, должны включать
часть или весь первичный ключ таблицы, если у таблицы он есть. Где никакое
имя столбца не определено как ключ разделения, первичный ключ таблицы
используется, если есть. Например, следующий запрос
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
допустим в MySQL 8.0:
<pre>
CREATE TABLE k1 (id INT NOT NULL PRIMARY KEY, name VARCHAR(20))
       PARTITION BY KEY() PARTITIONS 2;
</pre>

<p>Если нет никакого первичного ключа, но есть уникальный ключ, то уникальный
ключ используется для ключа разделения:
<pre>
CREATE TABLE k1 (id INT NOT NULL, name VARCHAR(20), UNIQUE KEY (id))
       PARTITION BY KEY() PARTITIONS 2;
</pre>

<p>Однако, если уникальный ключевой столбец не был определен как
<code>NOT NULL</code>, предыдущий запрос потерпел бы неудачу.</p>
<p>В обоих из этих случаев ключ разделения столбец <code>id</code>,
даже при том, что это не показывают в выводе
<a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE</code></a> или в
столбце <code>PARTITION_EXPRESSION</code> таблицы
<a href="inform.htm#partitions-table"><code>INFORMATION_SCHEMA.PARTITIONS
</code></a>.</p>

<p>В отличие от случая с другими типами разделения, столбцы, используемые для
того, чтобы разделить <code>KEY</code> не ограничены целым числом или
<code>NULL</code>. Например, следующий запрос
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> допустим:
<pre>
CREATE TABLE tm1 (s1 CHAR(32) PRIMARY KEY)
       PARTITION BY KEY(s1) PARTITIONS 10;
</pre>

<p>Предыдущий запрос <span><em>НЕ</em></span> допустим, если бы был иной тип
разделения определен. В этом случае простое использование
<code>PARTITION BY KEY()</code> было бы допустимо и имело бы тот же самый
эффект, как <code>PARTITION BY KEY(s1)</code>, пока
<code>s1</code> первичный ключ таблицы.</p>

<p>Для разделенной ключом таблицы Вы не можете выполнить
<code>ALTER TABLE DROP PRIMARY KEY</code>, поскольку выполнение этого
производит ошибку <span>ERROR 1466 (HY000): Field in list of fields for
partition function not found in table</span>.</li></ul>

<p>Также возможно разделить таблицу линейным ключом. Вот простой пример:
<pre>
CREATE TABLE tk (col1 INT NOT NULL, col2 CHAR(5), col3 DATE)
       PARTITION BY LINEAR KEY (col1) PARTITIONS 3;
</pre>

<p>Ключевое слово <code>LINEAR</code> имеет тот же самый эффект на
<code>KEY</code>, как на <code>HASH</code> с числом разделов, получаемым,
используя алгоритм степеней двух, а не арифметики модуля. См.
<a href="#partitioning-linear-hash">раздел 20.2.4.1</a>.</p>

<h3><a name="partitioning-subpartitions"></a>20.2.6. Подразделение</h3>
<p>Подразделение также известно как <span>композитное разделение</span> и
является дальнейшим подразделением каждого разделения в разделенной таблице.
Рассмотрите следующий запрос
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE ts (id INT, purchased DATE)
       PARTITION BY RANGE(YEAR(purchased))
       SUBPARTITION BY HASH(TO_DAYS(purchased))
       SUBPARTITIONS 2 (PARTITION p0 VALUES LESS THAN (1990),
                        PARTITION p1 VALUES LESS THAN (2000),
                        PARTITION p2 VALUES LESS THAN MAXVALUE);
</pre>

<p>Таблица <code>ts</code> имеет 3 раздела <code>RANGE</code>
<code>p0</code>, <code>p1</code> и <code>p2</code>. Каждый из них
далее разделен на 2 подраздела. В действительности, вся таблица разделена на
<code>3 * 2 = 6</code> разделов. Однако, из-за действия
<code>PARTITION BY RANGE</code> первые 2 из них хранят только записи со
значением столбца <code>purchased</code> меньше 1990.</p>

<p>Возможно подразделить таблицы, которые разделены <code>RANGE</code> или
<code>LIST</code>. Подразделение может использовать также <code>HASH</code>
или <code>KEY</code> разделение. Это также известно как
<span>композитное разделение</span>.</p>

<p><code>SUBPARTITION BY HASH</code> и <code>SUBPARTITION BY KEY</code>
вообще следуют тем же самым правилам синтаксиса, как
<code>PARTITION BY HASH</code> и <code>PARTITION BY KEY</code>,
соответственно. Исключение: <code>SUBPARTITION BY KEY</code> (в отличие от
<code>PARTITION BY KEY</code>) в настоящее время не поддерживает столбец
по умолчанию, таким образом, столбец, используемый с этой целью, должен быть
определен, даже если у таблицы есть явный первичный ключ. Это известная
проблема, над которой мы работаем.</p>

<p>Также возможно определить подразделение, явно используя
<code>SUBPARTITION</code>, чтобы определить опции для отдельного
подразделения. Например, можно определить <code>ts</code> так:
<pre>
CREATE TABLE ts (id INT, purchased DATE)
       PARTITION BY RANGE(YEAR(purchased))
       SUBPARTITION BY HASH(TO_DAYS(purchased))
                    (PARTITION p0 VALUES LESS THAN (1990)
                               (SUBPARTITION s0, SUBPARTITION s1),
                     PARTITION p1 VALUES LESS THAN (2000)
                               (SUBPARTITION s2, SUBPARTITION s3),
                     PARTITION p2 VALUES LESS THAN MAXVALUE
                               (SUBPARTITION s4, SUBPARTITION s5));
</pre>

<p>Некоторые синтаксические элементы перечислены здесь:</p>
<ul><li><p>У каждого раздела должно быть то же самое число подразделов.</li>
<li>Если Вы явно определяете какое-либо использование подразделения
<code>SUBPARTITION</code> на любом разделе разделенной таблицы, Вы должны
определить их все. Другими словами, следующий запрос потерпит неудачу:
<pre>
CREATE TABLE ts (id INT, purchased DATE)
       PARTITION BY RANGE(YEAR(purchased))
       SUBPARTITION BY HASH(TO_DAYS(purchased))
       (PARTITION p0 VALUES LESS THAN (1990)
                  (SUBPARTITION s0, SUBPARTITION s1),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE
                  (SUBPARTITION s2, SUBPARTITION s3));
</pre>
<p>Этот запрос все еще потерпел бы неудачу, даже если бы он использовал
<code>SUBPARTITIONS 2</code>.</li>

<li>Каждое предложение <code>SUBPARTITION</code> должен включать (как
минимум) название подраздела. Вы можете установить любую желаемую опцию для
подраздела или позволить этому принимать свою настройку по умолчанию.</li>

<li>Имена подразделения должны быть уникальными для всей таблицы. Например,
следующий запрос <a href="sql.htm#create-table"><code>CREATE TABLE</code>
</a> допустим:
<pre>
CREATE TABLE ts (id INT, purchased DATE) PARTITION BY RANGE(YEAR(purchased))
       SUBPARTITION BY HASH(TO_DAYS(purchased))
       (PARTITION p0 VALUES LESS THAN (1990)
                     (SUBPARTITION s0, SUBPARTITION s1),
       PARTITION p1 VALUES LESS THAN (2000)
                    (SUBPARTITION s2, SUBPARTITION s3),
       PARTITION p2 VALUES LESS THAN MAXVALUE
                    (SUBPARTITION s4, SUBPARTITION s5));
</pre></li></ul>

<h3><a name="partitioning-handling-nulls"></a>20.2.7. Как MySQL
обрабатывает NULL в разделах</h3>
<p>Разделение в MySQL не делает ничего, чтобы отвергнуть <code>NULL</code>
как значение выражения разделения, является ли это значением столбца или
значением данного пользователем выражения. Даже при том, что разрешено
использовать <code>NULL</code> как значение выражения, которое должно иначе
привести к целому числу, важно иметь в виду, что <code>NULL</code> не число.
<code>NULL</code> рассматривается как значение, меньше любого
не-<code>NULL</code>, как в <code>ORDER BY</code>.</p>

<p>Это означает, что обработка <code>NULL</code> изменяется между
разделениями различных типов и может произвести поведение, которое Вы не
ожидаете. Это рассмотрено позднее.</p>

<p><b>Обработка NULL с RANGE. </b>Если Вы вставляете строку в таблицу,
разделенную <code>RANGE</code> таким образом, что значение столбца,
используемое для определения раздела <code>NULL</code>, строка вставлена в
самое низкое разделение. Считайте эти две таблицы в базе данных
<code>p</code>, созданными следующим образом::
<pre>
mysql&gt; CREATE TABLE t1 (c1 INT, c2 VARCHAR(20))
    -&gt;        PARTITION BY RANGE(c1)
    -&gt;        (PARTITION p0 VALUES LESS THAN (0),
    -&gt;         PARTITION p1 VALUES LESS THAN (10),
    -&gt;         PARTITION p2 VALUES LESS THAN MAXVALUE);
Query OK, 0 rows affected (0.09 sec)

mysql&gt; CREATE TABLE t2 (c1 INT, c2 VARCHAR(20))
    -&gt;        PARTITION BY RANGE(c1)
    -&gt;        (PARTITION p0 VALUES LESS THAN (-5),
    -&gt;         PARTITION p1 VALUES LESS THAN (0),
    -&gt;         PARTITION p2 VALUES LESS THAN (10),
    -&gt;         PARTITION p3 VALUES LESS THAN MAXVALUE);
Query OK, 0 rows affected (0.09 sec)
</pre>

<p>Вы можете видеть разделение, создаваемое этими двумя
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>,
используя следующий запрос к таблице
<a href="inform.htm#partitions-table"><code>PARTITIONS</code></a> в
<code>INFORMATION_SCHEMA</code>:
<pre>
mysql&gt; SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH,
     &gt;        DATA_LENGTH FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;        WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |  0         |   0            |   0         |
| t1         | p1             |  0         |   0            |   0         |
| t1         | p2             |  0         |   0            |   0         |
| t2         | p0             |  0         |   0            |   0         |
| t2         | p1             |  0         |   0            |   0         |
| t2         | p2             |  0         |   0            |   0         |
| t2         | p3             |  0         |   0            |   0         |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.00 sec)
</pre>

<p>Теперь заполним каждую из этих таблиц единственной строкой, содержащей
<code>NULL</code> в столбце, используемом в качестве ключа разделения, и
проверьте, что строки были вставлены, используя пару запросов
<a href="sql.htm#select"><code>SELECT</code></a>:
<pre>
mysql&gt; INSERT INTO t1 VALUES (NULL, 'mothra');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO t2 VALUES (NULL, 'mothra');
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT * FROM t1;
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)

mysql&gt; SELECT * FROM t2;
+------+--------+
| id   | name   |
+------+--------+
| NULL | mothra |
+------+--------+
1 row in set (0.00 sec)
</pre>

<p>Вы можете видеть, какой раздел используется, чтобы сохранить вставленные
строки, запуская повторно предыдущий запрос
<a href="inform.htm#partitions-table"><code>INFORMATION_SCHEMA.PARTITIONS
</code></a>:
<pre>
mysql&gt; SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH,
     &gt;        DATA_LENGTH FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;        WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 't_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| t1         | p0             |  1         |    20          |  20         |
| t1         | p1             |  0         |     0          |   0         |
| t1         | p2             |  0         |     0          |   0         |
| t2         | p0             |  1         |    20          |  20         |
| t2         | p1             |  0         |     0          |   0         |
| t2         | p2             |  0         |     0          |   0         |
| t2         | p3             |  0         |     0          |   0         |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre>

<p>Вы можете также продемонстрировать, что эти строки были сохранены в
разделе с самым низким номером каждой таблицы, удаляя этот раздел, и затем
запуская повторно <a href="sql.htm#select"><code>SELECT</code></a>:
<pre>
mysql&gt; ALTER TABLE t1 DROP PARTITION p0;
Query OK, 0 rows affected (0.16 sec)

mysql&gt; ALTER TABLE t2 DROP PARTITION p0;
Query OK, 0 rows affected (0.16 sec)

mysql&gt; SELECT * FROM t1;
Empty set (0.00 sec)

mysql&gt; SELECT * FROM t2;
Empty set (0.00 sec)
</pre>

<p><code>NULL</code> также обработан таким образом для выражений разделения,
которые применяют функции SQL. Предположите, что мы определяем таблицу,
используя <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE tndate (id INT, dt DATE)
       PARTITION BY RANGE(YEAR(dt))
       (PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (2000),
        PARTITION p2 VALUES LESS THAN MAXVALUE);
</pre>

<p>Как с другими функциями MySQL,
<a href="funct.htm#function_year"><code>YEAR(NULL)</code></a> вернет
<code>NULL</code>. Строка со значением столбца <code>dt</code>
<code>NULL</code> обработана, как если бы выражение разделения оценено к
значению меньше, чем любое другое значение, и вставлена в раздел
<code>p0</code>.</p>

<p><b>Обработка NULL с LIST. </b>Таблица, которая разделена
<code>LIST</code> признает <code>NULL</code>, если и только если один из его
разделов определен, используя список значения, который содержит
<code>NULL</code>. Обратное из этого то, что таблица, разделенная
<code>LIST</code>, которая явно не использует <code>NULL</code>
в значениях списка, отклоняет строки, приводящие к
<code>NULL</code> для выражения разделения, как показано в этом примере:
<pre>
mysql&gt; CREATE TABLE ts1 (c1 INT, c2 VARCHAR(20))
    -&gt;        PARTITION BY LIST(c1)
    -&gt;        (PARTITION p0 VALUES IN (0, 3, 6),
    -&gt;         PARTITION p1 VALUES IN (1, 4, 7),
    -&gt;         PARTITION p2 VALUES IN (2, 5, 8));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; INSERT INTO ts1 VALUES (9, 'mothra');
<span>ERROR 1504 (HY000): Table has no partition for value 9</span>

mysql&gt; INSERT INTO ts1 VALUES (NULL, 'mothra');
<span>ERROR 1504 (HY000): Table has no partition for value NULL</span>
</pre>

<p>Только строки, имеющие значение <code>c1</code> между
<code>0</code> и <code>8</code> включительно могут быть вставлены в
<code>ts1</code>. <code>NULL</code> вне этого диапазона, точно так же,
как число <code>9</code>. Мы можем составить таблицы <code>ts2</code> и
<code>ts3</code>, имеющие списки значений, содержащие <code>NULL</code>:
<pre>
mysql&gt; CREATE TABLE ts2 (c1 INT, c2 VARCHAR(20))
    -&gt;        PARTITION BY LIST(c1)
    -&gt;        (PARTITION p0 VALUES IN (0, 3, 6),
    -&gt;         PARTITION p1 VALUES IN (1, 4, 7),
    -&gt;         PARTITION p2 VALUES IN (2, 5, 8),
    -&gt;         PARTITION p3 VALUES IN (NULL));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; CREATE TABLE ts3 (c1 INT, c2 VARCHAR(20))
    -&gt;        PARTITION BY LIST(c1)
    -&gt;        (PARTITION p0 VALUES IN (0, 3, 6),
    -&gt;         PARTITION p1 VALUES IN (1, 4, 7, NULL),
    -&gt;         PARTITION p2 VALUES IN (2, 5, 8));
Query OK, 0 rows affected (0.01 sec)
</pre>

<p>Когда определяете значения списков для разделения, Вы можете (и должны)
обработать <code>NULL</code> так же, как любое другое значение.
Например, оба <code>VALUES IN (NULL)</code> и <code>VALUES IN (1, 4, 7, NULL)
</code> допустимы, как <code>VALUES IN (1, NULL, 4, 7)</code>, <code>VALUES
IN (NULL, 1, 4, 7)</code> и т.д. Вы можете вставить строки с
<code>NULL</code> для столбца <code>c1</code> в каждую из таблиц
<code>ts2</code> и <code>ts3</code>:
<pre>
mysql&gt; INSERT INTO ts2 VALUES (NULL, 'mothra');
Query OK, 1 row affected (0.00 sec)

mysql&gt; INSERT INTO ts3 VALUES (NULL, 'mothra');
Query OK, 1 row affected (0.00 sec)
</pre>

<p>Запрашивая <a href="inform.htm#partitions-table"><code>
INFORMATION_SCHEMA.PARTITIONS</code></a>, Вы можете определить, какое
разделение использовалось, чтобы сохранить строки (мы принимаем, как в
предыдущих примерах, что разделенные таблицы были составлены в базе данных
<code>p</code>):
<pre>
mysql&gt; SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH,
     &gt;        DATA_LENGTH FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;        WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME LIKE 'ts_';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| ts2        | p0             |  0         |  0             |   0         |
| ts2        | p1             |  0         |  0             |   0         |
| ts2        | p2             |  0         |  0             |   0         |
| ts2        | p3             |  1         | 20             |  20         |
| ts3        | p0             |  0         |  0             |   0         |
| ts3        | p1             |  1         | 20             |  20         |
| ts3        | p2             |  0         |  0             |   0         |
+------------+----------------+------------+----------------+-------------+
7 rows in set (0.01 sec)
</pre>

<p>Как показано ранее в этом разделе, Вы можете также проверить, какой
раздел использовался для того, чтобы сохранить строки, удаляя этот раздел и
затем запуская <a href="sql.htm#select"><code>SELECT</code></a>.</p>

<p><b>Обработка NULL с HASH и KEY. </b><code>NULL</code> обработан несколько
по-другому для таблиц, разделенных <code>HASH</code> или <code>KEY</code>.
В этих случаях любое выражение разделения, которое приводит к
<code>NULL</code> обработано, как если бы его возвращаемое значение было
нолем. Мы можем проверить это поведение, исследуя эффекты составления
таблицы, разделенной <code>HASH</code> и заполнения ее записями, содержащими
соответствующие значения. Предположите, что у Вас есть таблица
<code>th</code> (тоже в базе данных <code>p</code>), созданная так:
<pre>
mysql&gt; CREATE TABLE th (c1 INT, c2 VARCHAR(20))
    -&gt;        PARTITION BY HASH(c1) PARTITIONS 2;
Query OK, 0 rows affected (0.00 sec)
</pre>

<p>Разделение, принадлежащее этой таблице, может быть рассмотрено, используя
запрос, показанный здесь:
<pre>
mysql&gt; SELECT TABLE_NAME,PARTITION_NAME,TABLE_ROWS,AVG_ROW_LENGTH,
     &gt;        DATA_LENGTH FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;        WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |  0         |      0         |   0         |
| th         | p1             |  0         |      0         |   0         |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
</pre>

<p>Отметьте это <code>TABLE_ROWS</code> для каждого раздела 0.
Теперь вставьте две строки в <code>th</code> чей столбец <code>c1</code>
имеет значения <code>NULL</code> и 0, а затем проверьте, что эти строки были
вставлены, как показано здесь:
<pre>
mysql&gt; INSERT INTO th VALUES (NULL, 'mothra'), (0, 'gigan');
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT * FROM th;
+------+---------+
| c1   | c2      |
+------+---------+
| NULL | mothra  |
+------+---------+
|0     | gigan   |
+------+---------+
2 rows in set (0.01 sec)
</pre>

<p>Вспомните, что для любого целого числа <em><code>N</code></em>, значение
<code>NULL MOD<em><code>N</code></em></code> всегда <code>NULL</code>.
Для таблиц, которые разделены <code>HASH</code> или <code>KEY</code>, этот
результат определяет правильный раздел как  <code>0</code>. Проверяя
<a href="inform.htm#partitions-table"><code>INFORMATION_SCHEMA.PARTITIONS
</code></a> мы можем видеть, что обе строки были вставлены в раздел
<code>p0</code>:
<pre>
mysql&gt; SELECT TABLE_NAME, PARTITION_NAME, TABLE_ROWS, AVG_ROW_LENGTH,
     &gt;        DATA_LENGTH FROM INFORMATION_SCHEMA.PARTITIONS
     &gt;        WHERE TABLE_SCHEMA = 'p' AND TABLE_NAME ='th';
+------------+----------------+------------+----------------+-------------+
| TABLE_NAME | PARTITION_NAME | TABLE_ROWS | AVG_ROW_LENGTH | DATA_LENGTH |
+------------+----------------+------------+----------------+-------------+
| th         | p0             |  2         | 20             |  20         |
| th         | p1             |  0         | 0              |   0         |
+------------+----------------+------------+----------------+-------------+
2 rows in set (0.00 sec)
</pre>

<p>Повторяя последнее использование в качестве примера
<code>PARTITION BY KEY</code> вместо <code>PARTITION BY HASH</code>
в определении таблицы Вы можете проверить, что <code>NULL</code>
также обработан как 0 для этого типа разделения.</p>

<h2><a name="partitioning-management"></a>20.3. Управление разделением</h2>
<p>Есть много способов использовать запросы SQL, чтобы изменить разделенные
таблицы: возможно добавить, удалить, пересмотреть, слить или разделить
существующее разделение, используя расширения разделения для
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>. Есть также способы получить информацию о разделенных таблицах и
разделении. Мы обсуждаем эти темы в разделах далее.</p>

<ul><li><p>Для информации об управлении разделением в таблицах, разделенных
<code>RANGE</code> или <code>LIST</code> см.
<a href="#partitioning-management-range-list">раздел 20.3.1</a>.
</li>

<li>Для информации об управлении разделением в таблицах, разделенных
<code>HASH</code> и <code>KEY</code> см.
<a href="#partitioning-management-hash-key">раздел 20.3.2</a>.</li>

<li>См. <a href="#partitioning-info">раздел 20.3.5</a>
для обсуждения механизмов, обеспеченных в MySQL 8.0 для того, чтобы получить
информацию о разделенных таблицах и разделении.</li>

<li>Для обсуждения операций обслуживания см.
<a href="#partitioning-maintenance">
раздел 20.3.4</a>.</p></li></ul>

<p>У всех разделов таблицы должно быть то же самое число подразделов:
невозможно изменить подраздел, как только таблица была составлена.</p>
<p>Чтобы изменить схему разделения таблицы, необходимо использовать только
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE</code></a> с опцией <em><code>partition_options</code></em>, у которой
есть тот же самый синтаксис как у <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> для того, чтобы составить разделенную таблицу, эта опция
(также) всегда начинается с ключевых слов <code>PARTITION BY</code>.
Предположите что следующий запрос <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> использовался, чтобы составить таблицу,
которая разделена диапазоном:
<pre>
CREATE TABLE trb3 (id INT, name VARCHAR(50), purchased DATE)
       PARTITION BY RANGE(YEAR(purchased))
       (PARTITION p0 VALUES LESS THAN (1990),
        PARTITION p1 VALUES LESS THAN (1995),
        PARTITION p2 VALUES LESS THAN (2000),
        PARTITION p3 VALUES LESS THAN (2005));
</pre>

<p>Теперь эта таблица должна быть изменена так, чтобы это было разделено
ключом на два раздела, используя значение столбца <code>id</code> как
основание для ключа. Вы можете использовать этот запрос:
<pre>
ALTER TABLE trb3 PARTITION BY KEY(id) PARTITIONS 2;
</pre>

<p>Это имеет тот же самый эффект на структуру таблицы как удаление
и восстановление таблицы через <code>CREATE TABLE trb3
PARTITION BY KEY(id) PARTITIONS 2;</code>.</p>

<p><code>ALTER TABLE ... ENGINE = ...</code> меняет
только механизм хранения, используемый таблицей, и схема разделения таблицы
остается прежней. Запрос преуспевает, только если целевой механизм хранения
оказывает поддержку разделения. Вы можете использовать
<code>ALTER TABLE ... REMOVE PARTITIONING</code>, чтобы удалить разделение
таблицы, см. <a href="sql.htm#alter-table">раздел 14.1.7</a>.</p>

<p>Только одно предложение <code>PARTITION BY</code>, <code>ADD
PARTITION</code>, <code>DROP PARTITION</code>,
<code>REORGANIZE PARTITION</code> или <code>COALESCE PARTITION</code>
может использоваться в данном запросе
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>. Если Вы (например) хотите удалить раздел и реорганизовать остающееся
разделение таблицы, Вы должны сделать это за два отдельных запроса
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a> (первый использует <code>DROP PARTITION</code>,
затем второй реализует <code>REORGANIZE PARTITIONS</code>).</p>

<p>Вы можете удалить все строки из одного или более выбранного раздела
с помощью <a href="sql.htm#alter-table"><code>ALTER TABLE ...
TRUNCATE PARTITION</code></a>.</p>

<h3><a name="partitioning-management-range-list"></a>20.3.1.
Управление RANGE и LIST</h3>
<p>Диапазон и разделение списка подобны относительно того, как добавление и
удаление раздела обработаны. По этой причине мы обсуждаем управление обоими
видами разделения в этом разделе. Для информации о работе с таблицами,
которые разделены хешем или ключом см.
<a href="#partitioning-management-hash-key">раздел 20.3.2</a>.
Удаление <code>RANGE</code> или <code>LIST</code> является более прямым, чем
добавление, таким образом, мы обсуждаем это сначала.</p>

<p>Удаление раздела таблицы, которая разделена
<code>RANGE</code> или <code>LIST</code> может быть достигнуто, используя
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a> с предложением <code>DROP PARTITION</code>. Вот очень общий пример,
который предполагает, что Вы уже составили таблицу, которая разделена
диапазоном и затем заполнена 10 записями, используя следующие
запросы <a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#insert"><code>INSERT</code></a>:
<pre>
mysql&gt; CREATE TABLE tr (id INT, name VARCHAR(50), purchased DATE)
    -&gt;        PARTITION BY RANGE(YEAR(purchased)) (
    -&gt;                  PARTITION p0 VALUES LESS THAN (1990),
    -&gt;                  PARTITION p1 VALUES LESS THAN (1995),
    -&gt;                  PARTITION p2 VALUES LESS THAN (2000),
    -&gt;                  PARTITION p3 VALUES LESS THAN (2005));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; INSERT INTO tr VALUES
    -&gt;        (1, 'desk organiser', '2003-10-15'),
    -&gt;        (2, 'CD player', '1993-11-05'),
    -&gt;        (3, 'TV set', '1996-03-10'),
    -&gt;        (4, 'bookcase', '1982-01-10'),
    -&gt;        (5, 'exercise bike', '2004-05-09'),
    -&gt;        (6, 'sofa', '1987-06-05'),
    -&gt;        (7, 'popcorn maker', '2001-11-22'),
    -&gt;        (8, 'aquarium', '1992-08-04'),
    -&gt;        (9, 'study desk', '1984-09-16'),
    -&gt;        (10, 'lava lamp', '1998-12-25');
Query OK, 10 rows affected (0.01 sec)
</pre>

<p>Вы можете видеть, какие элементы должны были быть вставлены в раздел
<code>p2</code>:
<pre>
mysql&gt; SELECT * FROM tr
    -&gt;          WHERE purchased BETWEEN '1995-01-01' AND '1999-12-31';
+----+-----------+------------+
| id | name      | purchased  |
+----+-----------+------------+
|  3 | TV set    | 1996-03-10 |
| 10 | lava lamp | 1998-12-25 |
+----+-----------+------------+
2 rows in set (0.00 sec)
</pre>

<p>Чтобы удалить раздел <code>p2</code>, скомандуйте:
<pre>
mysql&gt; ALTER TABLE tr DROP PARTITION p2;
Query OK, 0 rows affected (0.03 sec)
</pre>

<p>Очень важно помнить, что <span><em>когда Вы удаляете раздел, Вы также
удаляете и все данные, которые хранились в этом разделе</em></span>.
Вы можете видеть, что дело обстоит именно так, запуская повторно предыдущий
запрос <a href="sql.htm#select"><code>SELECT</code></a>:
<pre>
mysql&gt; SELECT * FROM tr WHERE purchased
    -&gt;          BETWEEN '1995-01-01' AND '1999-12-31';
Empty set (0.00 sec)
</pre>

<p>Из-за этого Вы должны иметь привилегию
<a href="security.html#priv_drop"><code>DROP</code></a>
для таблицы прежде, чем Вы сможете выполнить <code>ALTER TABLE ... DROP
PARTITION</code> на этой таблице.</p>

<p>Если Вы хотите исключить все данные из всего разделения, сохраняя
табличное определение и его схему разделения, используйте
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>.</p>

<p>Если Вы намереваетесь изменить разделение таблицы
<span><em>НЕ</em></span> теряя данные, надо использовать <code>ALTER
TABLE ... REORGANIZE PARTITION</code>. Больше информации о
<code>REORGANIZE PARTITION</code> может быть найдено в другом месте в этом
разделе или см.
<a href="sql.htm#alter-table-partition-operations">раздел 14.1.7.1</a>.</p>

<p>Если Вы теперь выполняете <a href="sql.htm#show-create-table"><code>SHOW
CREATE TABLE</code></a>, Вы можете видеть, как состав разделов
таблицы был изменен:
<pre>
mysql&gt; SHOW CREATE TABLE tr\G
*************************** 1. row ***************************
 Table: tr
Create Table: CREATE TABLE `tr` (
  `id` int(11) default NULL,
  `name` varchar(50) default NULL,
  `purchased` date default NULL) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE (YEAR(purchased)) (
  PARTITION p0 VALUES LESS THAN (1990) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1995) ENGINE = MyISAM,
  PARTITION p3 VALUES LESS THAN (2005) ENGINE = MyISAM)
1 row in set (0.01 sec)
</pre>

<p>Когда Вы вставляете новые строки в измененную таблицу со значением
столбца <code>purchased</code> между <code>'1995-01-01'</code> и
<code>'2004-12-31'</code> включительно, те строки будут сохранены в разделе
<code>p3</code>. Вы можете проверить это следующим образом:
<pre>
mysql&gt; INSERT INTO tr VALUES (11, 'pencil holder', '1995-07-12');
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT * FROM tr WHERE purchased
    -&gt;          BETWEEN '1995-01-01' AND '2004-12-31';
+----+----------------+------------+
| id | name           | purchased  |
+----+----------------+------------+
| 11 | pencil holder  | 1995-07-12 |
|  1 | desk organiser | 2003-10-15 |
|  5 | exercise bike  | 2004-05-09 |
|  7 | popcorn maker  | 2001-11-22 |
+----+----------------+------------+
4 rows in set (0.00 sec)

mysql&gt; ALTER TABLE tr DROP PARTITION p3;
Query OK, 0 rows affected (0.03 sec)

mysql&gt; SELECT * FROM tr WHERE purchased
    -&gt;          BETWEEN '1995-01-01' AND '2004-12-31';
Empty set (0.00 sec)
</pre>

<p>Отметьте, что число строк, удаленных из таблицы в результате
<code>ALTER TABLE ... DROP PARTITION</code> не сообщается сервером, как это
было бы при эквивалентном запросе <a href="sql.htm#delete"><code>DELETE
</code></a>.</p>

<p>Удаление раздела <code>LIST</code> использует точно тот же самый
синтаксис <code>ALTER TABLE ... DROP PARTITION</code> как и для
<code>RANGE</code>. Однако, есть одно важное различие в эффекте, который это
имеет на Ваше использование таблицы позже: Вы больше не можете вставить в
таблицу строки, имеющие любое из значений, которые были включены в список
значения, определяющий удаленный раздел. См.
<a href="#partitioning-list">раздел 20.2.2</a>.</p>

<p>Чтобы добавить новый диапазон или разделение списка к ранее разделенной
таблице, используйте <code>ALTER TABLE ... ADD PARTITION</code>. Для таблиц,
которые разделены <code>RANGE</code>, это может использоваться, чтобы
добавить новый диапазон в конец списка существующего разделения.
Предположите, что у Вас есть разделенная таблица, содержащая данные о
членстве для Вашей организации, которая определена следующим образом:
<pre>
CREATE TABLE members (id INT, fname VARCHAR(25), lname VARCHAR(25), dob DATE)
       PARTITION BY RANGE(YEAR(dob))
                 (PARTITION p0 VALUES LESS THAN (1970),
                  PARTITION p1 VALUES LESS THAN (1980),
                  PARTITION p2 VALUES LESS THAN (1990));
</pre>

<p>Предположите далее, что минимальный возраст для участников 16 лет.
Поскольку календарь приближается к концу 2005, Вы понимаете, что будете скоро
принимать членов, кто родился в 1990 (и позже в последующие годы). Вы можете
изменить таблицу <code>members</code>, чтобы разместить новых участников,
родившихся в годы с 1990 по 1999, как показано здесь:
<pre>
ALTER TABLE members ADD PARTITION (PARTITION p3 VALUES LESS THAN (2000));
</pre>

<p>С таблицами, которые разделены диапазоном, Вы можете использовать
<code>ADD PARTITION</code>, чтобы добавить новый раздел только к верхнему
концу списка разделов. Попытка добавить новый раздел в этой манере между или
перед существующими результатами разделения приведет к ошибке:
<pre>
mysql&gt; ALTER TABLE members ADD PARTITION (PARTITION n
     &gt;       VALUES LESS THAN (1960));
ERROR 1463 (HY000): VALUES LESS THAN value must be strictly б╩
                    increasing for each partition
</pre>

<p>Вы можете обойти эту проблем, реорганизуя первый раздел на два новых,
которые разделяют диапазон между ними:
<pre>
ALTER TABLE members REORGANIZE PARTITION p0
      INTO (PARTITION n0 VALUES LESS THAN (1960),
            PARTITION n1 VALUES LESS THAN (1970));
</pre>

<p>Используя <a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE
</code></a> Вы можете видеть, что <code>ALTER TABLE</code>
имел желаемый эффект:
<pre>
mysql&gt; SHOW CREATE TABLE members\G
*************************** 1. row ***************************
 Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) DEFAULT NULL,
  `fname` varchar(25) DEFAULT NULL,
  `lname` varchar(25) DEFAULT NULL,
  `dob` date DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin1
/*!50100 PARTITION BY RANGE (YEAR(dob))
(PARTITION n0 VALUES LESS THAN (1960) ENGINE = InnoDB,
 PARTITION n1 VALUES LESS THAN (1970) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (1980) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (1990) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (2000) ENGINE = InnoDB) */
1 row in set (0.00 sec)
</pre>

<p>Вы можете также использовать <code>ALTER TABLE ... ADD PARTITION</code>,
чтобы добавить новый раздел к таблице, которая разделена <code>LIST</code>.
Предположите таблицу <code>tt</code>, определенную, используя следующий
запрос <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE tt (id INT, data INT) PARTITION BY LIST(data)
       (PARTITION p0 VALUES IN (5, 10, 15),
       PARTITION p1 VALUES IN (6, 12, 18));
</pre>

<p>Вы можете добавить новый раздел, в котором можно сохранить строки, имеющие
значения столбца <code>data</code> <code>7</code>, <code>14</code> и
<code>21</code>:
<pre>
ALTER TABLE tt ADD PARTITION (PARTITION p2 VALUES IN (7, 14, 21));
</pre>

<p>Вы <span><em>НЕ можете</em></span> добавить новый раздел
<code>LIST</code>, охватывающий любые значения, которые уже включены в список
значений существующего раздела. Если Вы попытаетесь сделать так, будет ошибка:
<pre>
mysql&gt; ALTER TABLE tt ADD PARTITION
     &gt;       (PARTITION np VALUES IN (4, 8, 12));
ERROR 1465 (HY000): Multiple definition of same constant
                    in list partitioning
</pre>

<p>Поскольку любые строки со значением столбца <code>data</code>
<code>12</code> были уже поручены разделу <code>p1</code>, Вы не можете
создать новый раздел на таблице <code>tt</code>, который включает
<code>12</code> в списке значений. Чтобы достигнуть этого, Вы могли
удалить <code>p1</code>, добавить <code>np</code>, а затем новый
<code>p1</code> с измененным определением. Однако, как обсуждено ранее, это
привело бы к потере всех данных, хранившихся в <code>p1</code>,
часто имеет место, что это не то, что Вы действительно хотите сделать. Другое
решение: сделать копию таблицы с новым разделением и скопировать данные в нее
через <a href="sql.htm#create-table"><code>CREATE TABLE ... SELECT ...</code>
</a>, затем удалить старую таблицу и переименовать новую, но это может быть
отнимающим очень много времени, имея дело с большими объемами данных. Это
также не может быть выполнимо в ситуациях, где высокая
доступность является требованием.</p>

<p>Вы можете добавить много разделов за один запрос <code>ALTER TABLE
... ADD PARTITION</code> так:
<pre>
CREATE TABLE employees (id INT NOT NULL, fname VARCHAR(50) NOT NULL,
                        lname VARCHAR(50) NOT NULL, hired DATE NOT NULL)
PARTITION BY RANGE(YEAR(hired))
          (PARTITION p1 VALUES LESS THAN (1991),
           PARTITION p2 VALUES LESS THAN (1996),
           PARTITION p3 VALUES LESS THAN (2001),
           PARTITION p4 VALUES LESS THAN (2005));
ALTER TABLE employees ADD PARTITION
      (PARTITION p5 VALUES LESS THAN (2010),
       PARTITION p6 VALUES LESS THAN MAXVALUE);
</pre>

<p>Возможно пересмотреть разделение, не теряя данные. Давайте смотреть
сначала на пару простых примеров с <code>RANGE</code>. Вспомните таблицу
<code>members</code>, которая теперь определена как показано здесь:
<pre>
mysql&gt; SHOW CREATE TABLE members\G
*************************** 1. row ***************************
 Table: members
Create Table: CREATE TABLE `members` (
  `id` int(11) default NULL,
  `fname` varchar(25) default NULL,
  `lname` varchar(25) default NULL,
  `dob` date default NULL) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE (YEAR(dob)) (
  PARTITION p0 VALUES LESS THAN (1970) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1980) ENGINE = MyISAM,
  PARTITION p2 VALUES LESS THAN (1990) ENGINE = MyISAM.
  PARTITION p3 VALUES LESS THAN (2000) ENGINE = MyISAM)
</pre>

<p>Предположите, что Вы хотели бы переместить все строки, представляющие
участников, родившихся до 1960 в отдельный раздел. Как мы уже видели, это не
может быть сделано, используя <code>ALTER TABLE ... ADD PARTITION</code>.
Однако, Вы можете использовать другое связанное с разделением расширение для
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>:
<pre>
ALTER TABLE members REORGANIZE PARTITION p0
      INTO (PARTITION s0 VALUES LESS THAN (1960),
            PARTITION s1 VALUES LESS THAN (1970));
</pre>

<p>В действительности, эта команда разделяет раздел <code>p0</code> на два
новых <code>s0</code> и <code>s1</code>. Это также перемещает данные, которые
хранились в <code>p0</code> в новый раздел согласно правилам, воплощенным в
двух предложениях <code>PARTITION ... VALUES ...</code> так, что
<code>s0</code> содержит только те записи, для которых
<a href="funct.htm#function_year"><code>YEAR(dob)</code></a> меньше 1960, а
<code>s1</code> содержит те строки, в которых
<a href="funct.htm#function_year"><code>YEAR(dob)</code></a> больше или
равно 1960, но меньше 1970.</p>

<p>Предложение <code>REORGANIZE PARTITION</code> может также использоваться
для того, чтобы слить смежные разделы. Вы можете возвратить таблицу
<code>members</code> к ее предыдущему разделению как показано здесь:
<pre>
ALTER TABLE members REORGANIZE PARTITION s0,s1
      INTO (PARTITION p0 VALUES LESS THAN (1970));
</pre>

<p>Никакие данные не потеряны в разделении или слиянии при использовании
<code>REORGANIZE PARTITION</code>. В выполнении вышеупомянутого запроса MySQL
перемещает все записи, которые были сохранены в разделах
<code>s0</code> и <code>s1</code>, в <code>p0</code>.</p>

<p>Общий синтаксис для <code>REORGANIZE PARTITION</code> показан здесь:
<pre>
ALTER TABLE <em><code>tbl_name</code></em>
      REORGANIZE PARTITION <em><code>partition_list</code></em>
      INTO (<em><code>partition_definitions</code></em>);
</pre>

<p>Здесь <em><code>tbl_name</code></em> название разделенной таблицы, а
<em><code>partition_list</code></em> список разделенных запятой значений
из названий одного или более существующих разделов, которые будут изменены.
<em><code>partition_definitions</code></em> список разделенных запятой
значений новых определений разделов, которые следуют тем же самым правилам,
что касаются списка <em><code>partition_definitions</code></em> в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>. Нужно отметить,
что Вы не ограничены слиянием нескольких разделения в один или разделением
одного раздела на несколько, используя <code>REORGANIZE PARTITION</code>.
Например, Вы можете реорганизовать все четыре раздела <code>members</code>
в два следующим образом:
<pre>
ALTER TABLE members REORGANIZE PARTITION p0,p1,p2,p3 INTO (
      PARTITION m0 VALUES LESS THAN (1980),
      PARTITION m1 VALUES LESS THAN (2000));
</pre>

<p>Вы можете также использовать <code>REORGANIZE PARTITION</code>
с таблицами, которые разделены <code>LIST</code>. Давайте возвратимся к
проблеме добавления нового раздела к разделенной списком таблице
<code>tt</code> и провалу попытки, потому что у нового раздела было значение,
которое уже присутствовало в списке значений одного из существующего
разделов. Мы можем обработать это, добавляя раздел, который содержит только
непротиворечивые значения, а затем проведя реорганизацию нового и
существующего разделов так, чтобы значение, которое было сохранено в
существующем, было теперь перемещено в новый:
<pre>
ALTER TABLE tt ADD PARTITION (PARTITION np VALUES IN (4, 8));
ALTER TABLE tt REORGANIZE PARTITION p1,np
      INTO (PARTITION p1 VALUES IN (6, 18),
            PARTITION np VALUES in (4, 8, 12));
</pre>

<p>Вот некоторые ключевые пункты, чтобы иметь в виду, используя
<code>ALTER TABLE ... REORGANIZE PARTITION</code> для перестройки таблиц,
которые разделены <code>RANGE</code> или <code>LIST</code>:</p>

<ul><li><p>Предложение <code>PARTITION</code> используется, чтобы указать,
что новая схема разделения подчиняется правилам, используемым в
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>.</p>

<p>В частности помните, что у новой схемы разделения не может быть никаких
диапазонов наложения (относится к таблицам, разделенным <code>RANGE</code>)
или наборов значений (реорганизовывая таблицы, разделенные
<code>LIST</code>).</li>

<li>Комбинация разделения в списке
<em><code>partition_definitions</code></em> должна составлять тот же самый
диапазон или набор значений как объединенное разделение, названное в
<em><code>partition_list</code></em>.</p>

<p>Например, в таблице <code>members</code>, используемой в качестве примера,
разделы <code>p1</code> и <code>p2</code> вместе покрывают годы 1980-1999.
Поэтому любая перестройка этих двух разделов должна покрыть тот же
самый диапазон лет.</li>

<li>Для таблиц, разделенных <code>RANGE</code>, Вы можете реорганизовать
только смежные разделы, Вы не можете перескочить через разделение диапазона.
<p>Например, Вы не можете реорганизовать таблицу <code>members</code>,
используемую в качестве примера, используя запрос <code>ALTER TABLE members
REORGANIZE PARTITION p0,p2 INTO ...</code>, так как <code>p0</code>
покрывает годы до 1970, а <code>p2</code> годы с 1990 до 1999 включительно, и
таким образом эти два раздела не смежные.</li>

<li>Вы не можете использовать <code>REORGANIZE PARTITION</code>, чтобы
изменить тип разделения таблицы, то есть, Вы не можете (например) изменить
<code>RANGE</code> на <code>HASH</code>. Вы также не можете использовать этот
запрос, чтобы изменить выражение разделения или столбец. Чтобы выполнить
любую из этих задач, не обновляя таблицу, Вы можете использовать
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... PARTITION BY ...</code></a>:
<pre>
ALTER TABLE members PARTITION BY HASH(YEAR(dob)) PARTITIONS 8;
</pre></li></ul>

<h3><a name="partitioning-management-hash-key"></a>20.3.2.
Управление HASH и KEY</h3>
<p>Таблицы, которые разделены хешем или ключом, очень подобны друг другу
относительно произведения изменений в установке разделения, и сильно
отличаются от таблиц, которые были разделены диапазоном или списком.
По этой причине, этот раздел обращается к модификации таблиц, разделенных
хешем или ключом только. Для обсуждения добавления и удаления разделов
таблиц, которые разделены диапазоном или списком, см.
<a href="#partitioning-management-range-list">раздел 20.3.1</a>.
</p>

<p>Вы не можете исключить разделение из таблиц, которые разделены
<code>HASH</code> или <code>KEY</code> таким же образом, как для
таблиц, которые разделены <code>RANGE</code> или <code>LIST</code>. Однако,
Вы можете слить <code>HASH</code> или <code>KEY</code>, применив
<code>ALTER TABLE ... COALESCE PARTITION</code>. Предположите, что таблица
<code>clients</code>, содержащая данные о клиентах, разделена на 12 разделов,
создаваемых как показано здесь:
<pre>
CREATE TABLE clients (id INT, fname VARCHAR(30), lname VARCHAR(30),
                      signed DATE)
       PARTITION BY HASH(MONTH(signed)) PARTITIONS 12;
</pre>

<p>Чтобы сократить количество разделов с 12 до 8, выполните следующий запрос
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>:
<pre>
mysql&gt; ALTER TABLE clients COALESCE PARTITION 4;
Query OK, 0 rows affected (0.02 sec)
</pre>

<p><code>COALESCE</code> работает одинаково хорошо с таблицами, которые
разделены <code>HASH</code>, <code>KEY</code>, <code>LINEAR HASH</code> или
<code>LINEAR KEY</code>. Вот пример, подобный предыдущему, отличается только
тем, что в нем таблица разделена <code>LINEAR KEY</code>:
<pre>
mysql&gt; CREATE TABLE clients_lk (id INT, fname VARCHAR(30),
    -&gt;                          lname VARCHAR(30), signed DATE)
    -&gt;        PARTITION BY LINEAR KEY(signed) PARTITIONS 12;
Query OK, 0 rows affected (0.03 sec)

mysql&gt; ALTER TABLE clients_lk COALESCE PARTITION 4;
Query OK, 0 rows affected (0.06 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre>

<p>Число после <code>COALESCE PARTITION</code> задает количество разделов,
чтобы слить. Другими словами, это число разделов, чтобы удалить из таблицы.
</p>

<p>Пытаясь удалить больше разделов, чем находится в таблице,
Вы получите ошибку:
<pre>
mysql&gt; ALTER TABLE clients COALESCE PARTITION 18;
ERROR 1478 (HY000): Cannot remove all partitions, use DROP TABLE instead
</pre>

<p>Увеличить число разделов для таблицы <code>clients</code> с 12 до 18 можно
применив <code>ALTER TABLE ... ADD PARTITION</code>:
<pre>
ALTER TABLE clients ADD PARTITION PARTITIONS 6;
</pre>

<h3><a name="partitioning-management-exchange"></a>20.3.3.
Обмен разделами с таблицами</h3>
<p>В MySQL 8.0 возможно обменять табличное разделение или подразделение
применив <code>ALTER TABLE <em><code>pt</code></em> EXCHANGE PARTITION
<em><code>p</code></em> WITH TABLE <em><code>nt</code></em></code>,
где <em><code>pt</code></em> разделенная таблица и
<em><code>p</code></em> разделение или подразделение
<em><code>pt</code></em> для обмена с неразделенной таблицей
<em><code>nt</code></em> при условии, что следующие заявления истина:</p>

<ol type="1"><li><p>Таблица <em><code>nt</code></em>
самостоятельно не разделена.</li>
<li>Таблица <em><code>nt</code></em> не временная.</li>

<li>Структура таблиц <em><code>pt</code></em> и
<em><code>nt</code></em> идентична.</li>
<li>Таблица <code>nt</code> не содержит ссылок внешнего ключа, и ни у какой
другой таблицы нет внешних ключей, которые обращаются к <code>nt</code>.</li>

<li>Нет никаких строк в <em><code>nt</code></em>, которые
вне границ определения разделения для <em><code>p</code></em>. Это условие не
применяется, если используется <code>WITHOUT VALIDATION</code>.</p></li></ol>

<p>В дополнение к привилегиям <a href="security.html#priv_alter"><code>ALTER
</code></a>, <a href="security.html#priv_insert"><code>INSERT</code></a> и
<a href="security.html#priv_create"><code>CREATE</code></a>
обычно требуемым для <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>, Вы должны иметь <a href="security.html#priv_drop"><code>DROP</code></a>
для выполнения <a href="sql.htm#alter-table"><code>
ALTER TABLE ... EXCHANGE PARTITION</code></a>.</p>

<p>Вы должны также знать о следующих эффектах
<a href="sql.htm#alter-table"><code>ALTER TABLE ... EXCHANGE PARTITION
</code></a>:</p>

<ul><li><p>Выполнение <a href="sql.htm#alter-table"><code>ALTER TABLE ...
EXCHANGE PARTITION</code></a> не вызывает триггеров в таблицах.</li>
<li>Любые столбцы <code>AUTO_INCREMENT</code> в обмененной таблице сброшены.
</li>
<li>Ключевое слово <code>IGNORE</code> не имеет никакого эффекта, когда
используется с <code>ALTER TABLE ... EXCHANGE PARTITION</code>.</p></li></ul>

<p>Синтаксис для <a href="sql.htm#alter-table"><code>ALTER TABLE ...
EXCHANGE PARTITION</code></a> показан здесь, где <em><code>pt</code></em>
разделенная таблица, <em><code>p</code></em> разделение (или подразделение)
на обмен, а <em><code>nt</code></em> неразделенная таблица, которая
будет обменена с <em><code>p</code></em>:
<pre>
ALTER TABLE <em><code>pt</code></em>
      EXCHANGE PARTITION <em><code>p</code></em>
      WITH TABLE <em><code>nt</code></em>;
</pre>

<p>Произвольно, Вы можете приложить <code>WITH VALIDATION</code> или
<code>WITHOUT VALIDATION</code>. Когда указано <code>WITHOUT VALIDATION
</code>, <a href="sql.htm#alter-table"><code>ALTER TABLE ...
EXCHANGE PARTITION</code></a> не выполняет проверки допустимости строк,
обменивая таблицы и разрешая администраторам базы данных принять на себя
ответственность за то, что строки в пределах границ определения разделения.
<code>WITH VALIDATION</code> значение по умолчанию.</p>

<p>Одно и только одно разделение или подразделение может быть обменено с
одной и только одной неразделенной таблицей в одном запросе
<a href="sql.htm#alter-table"><code>ALTER TABLE EXCHANGE PARTITION</code></a>.
Чтобы обменять много разделений, используйте много запросов
<a href="sql.htm#alter-table"><code>ALTER TABLE EXCHANGE PARTITION</code></a>.
<code>EXCHANGE PARTITION</code> невозможно объединить с другими опциями
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>. Разделение и
(если применимо) подразделение используемое разделенной таблицей может иметь
какой угодно тип или типы, поддержанные в MySQL 8.0.</p>

<h4><a name="idm139965298027568"></a>
Обмен разделения с неразделенной таблицей</h4>
<p>Предположите что разделенная таблица <code>e</code> была создана и
заполнена с использованием следующих запросов SQL:
<pre>
CREATE TABLE e (id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30))
       PARTITION BY RANGE (id) (PARTITION p0 VALUES LESS THAN (50),
                                PARTITION p1 VALUES LESS THAN (100),
                                PARTITION p2 VALUES LESS THAN (150),
                                PARTITION p3 VALUES LESS THAN (MAXVALUE));
INSERT INTO e VALUES
       (1669, "Jim", "Smith"), (337, "Mary", "Jones"),
       (16, "Frank", "White"), (2005, "Linda", "Black");
</pre>

<p>Теперь мы создаем неразделенную копию <code>e</code>, назовем ее
<code>e2</code>. Это может быть сделано, используя клиент
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>:
<pre>
mysql&gt; CREATE TABLE e2 LIKE e;
Query OK, 0 rows affected (1.34 sec)

mysql&gt; ALTER TABLE e2 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.90 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre>

<p>Вы можете видеть, который раздел в <code>e</code>
содержит строки, запрашивая <a href="inform.htm#partitions-table"><code>
INFORMATION_SCHEMA.PARTITIONS</code></a>:
<pre>
mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |  1         |
| p1             |  0         |
| p2             |  0         |
| p3             |  3         |
+----------------+------------+
4 rows in set (0.00 sec)
</pre>

<p>Для разделенных таблиц <code>InnoDB</code> количество строк, поданное
столбцом <code>TABLE_ROWS</code> в <a href="inform.htm#partitions-table">
<code>INFORMATION_SCHEMA.PARTITIONS</code></a> только ориентировочная
величина, используемая в оптимизации SQL, и не всегда точная.</p>

<p>Обменять раздел <code>p0</code> в таблице <code>e</code> с таблицей
<code>e2</code> Вы можете через
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>:
<pre>
mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.28 sec)
</pre>

<p>Вы можете наблюдать, как прошел обмен, запрашивая таблицу
<a href="inform.htm#partitions-table"><code>INFORMATION_SCHEMA.PARTITIONS
</code></a> как прежде. Строка таблицы, которая была ранее найдена в разделе
<code>p0</code> больше не присутствует:
<pre>
mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |  0         |
| p1             |  0         |
| p2             |  0         |
| p3             |  3         |
+----------------+------------+
4 rows in set (0.00 sec)
</pre>

<p>Если Вы запрашиваете таблицу <code>e2</code>, Вы можете видеть, что
<span>строка может быть теперь найдена там:
<pre>
mysql&gt; SELECT * FROM e2;
+----+-------+-------+
| id | fname | lname |
+----+-------+-------+
| 16 | Frank | White |
+----+-------+-------+
1 row in set (0.00 sec)
</pre>

<p>Таблица, которая будет обменена с разделением, должна не обязательно быть
пустой. Чтобы продемонстрировать это, мы сначала вставляем новую строку в
таблицу <code>e</code>, удостоверяясь, что эта строка сохранена в разделе
<code>e</code>, выбирая значение столбца <code>id</code>, которое меньше 50,
и проверяя это позже, запрашивая таблицу
<a href="inform.htm#partitions-table"><code>PARTITIONS</code></a>:
<pre>
mysql&gt; INSERT INTO e VALUES (41, "Michael", "Green");
Query OK, 1 row affected (0.05 sec)

mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |  1         |
| p1             |  0         |
| p2             |  0         |
| p3             |  3         |
+----------------+------------+
4 rows in set (0.00 sec)
</pre>

<p>Теперь мы еще раз обмениваем раздел <code>p0</code> с таблицей
<code>e2</code> с использованием того же самого запроса
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE</code></a> как ранее:
<pre>
mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
Query OK, 0 rows affected (0.28 sec)
</pre>

<p>Вывод следующих запросов показывает, что строка таблицы, которая была
сохранена в разделе <code>p0</code> и строка таблицы, которая была сохранена
в таблице <code>e2</code>, до
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a>, теперь поменялись местами:
<pre>
mysql&gt; SELECT * FROM e;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
|   16 | Frank | White |
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
4 rows in set (0.00 sec)

mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |  1         |
| p1             |  0         |
| p2             |  0         |
| p3             |  3         |
+----------------+------------+
4 rows in set (0.00 sec)

mysql&gt; SELECT * FROM e2;
+----+---------+-------+
| id | fname   | lname |
+----+---------+-------+
| 41 | Michael | Green |
+----+---------+-------+
1 row in set (0.00 sec)
</pre>

<h4><a name="idm139965297974144"></a>Несоответствие строк</h4>
<p>Вы должны иметь в виду, что любые строки в неразделенной таблице до
<a href="sql.htm#alter-table"><code>ALTER TABLE ... EXCHANGE PARTITION</code>
</a> должны удовлетворять условиям, требуемым для их сохранения в целевом
разделе, иначе, запрос терпит неудачу. Чтобы видеть, как это происходит,
сначала вставьте строку в <code>e2</code> вне границ определения для
<code>p0</code> таблицы <code>e</code>. Например, вставьте строку с значением
столбца <code>id</code>, которое является слишком большим. Теперь попытайтесь
обменять таблицу с разделением снова:
<pre>
mysql&gt; INSERT INTO e2 VALUES (51, "Ellen", "McDonald");
Query OK, 1 row affected (0.08 sec)

mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
<span>ERROR 1707 (HY000): Found row that does not match the partition</span>
</pre>

<p>Ключевое слово <code>IGNORE</code> принято, но не имеет никакого эффекта,
когда используется с <code>EXCHANGE PARTITION</code>,
как показано здесь:
<pre>
mysql&gt; ALTER IGNORE TABLE e EXCHANGE PARTITION p0 WITH TABLE e2;
<span>ERROR 1707 (HY000): Found row that does not match the partition</span>
</pre>

<p>Только опция <code>WITHOUT VALIDATION</code> разрешила бы этому
запросу выполниться успешно:
<pre>
mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0
                WITH TABLE e2 WITHOUT VALIDATION;
Query OK, 0 rows affected (0.02 sec)
</pre>

<p>Когда разделение обменено с таблицей, которая содержит строки, которые не
соответствуют определение разделения, обязанность администратора базы данных
установить несоответствующие строки, которые могут быть выполнены, используя
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a> или
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... REPAIR PARTITION</code></a>.</p>

<h4><a name="idm139965297956144"></a>Обмен разделения без
проверки допустимости строки</h4>
<p>Чтобы избежать трудоёмкой проверки допустимости, обменивая разделение с
таблицей, у которой есть много строк, возможно пропустить шаг проверки
допустимости строки, указав опцию <code>WITHOUT VALIDATION</code>
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... EXCHANGE PARTITION</code></a>.</p>

<p>Следующий пример сравнивает различие между временем выполнения, обменивая
разделение с неразделенной таблицей с и без проверки допустимости.
Разделенная таблица (<code>e</code>) содержит два раздела по 1 миллиону строк
каждый. Строки в p0 таблицы e удалены, и p0 обменен с неразделенной таблицей
в 1 миллион строк. Операция <code>WITH VALIDATION</code> занимает 0.74
секунды. А вот <code>WITHOUT VALIDATION</code> всего 0.01 секунды.
<pre>
# Create a partitioned table with 1 million rows in each partition
CREATE TABLE e (id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30))
       PARTITION BY RANGE (id) (PARTITION p0 VALUES LESS THAN (1000001),
                                PARTITION p1 VALUES LESS THAN (2000001));
mysql&gt; SELECT COUNT(*) FROM e;
+----------+
| COUNT(*) |
+----------+
|  2000000 |
+----------+
1 row in set (0.27 sec)

# View the rows in each partition
SELECT PARTITION_NAME, TABLE_ROWS FROM INFORMATION_SCHEMA.PARTITIONS
       WHERE TABLE_NAME = 'e';
+----------------+-------------+
| PARTITION_NAME | TABLE_ROWS  |
+----------------+-------------+
| p0             | 1000000     |
| p1             | 1000000     |
+----------------+-------------+
2 rows in set (0.00 sec)

# Create a nonpartitioned table of the same structure and populate it
# with 1 million rows
CREATE TABLE e2 (id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30));
mysql&gt; SELECT COUNT(*) FROM e2;
+----------+
| COUNT(*) |
+----------+
|  1000000 |
+----------+
1 row in set (0.24 sec)

# Create another nonpartitioned table of the same structure and populate
# it with 1 million rows
CREATE TABLE e3 (id INT NOT NULL, fname VARCHAR(30), lname VARCHAR(30));
mysql&gt; SELECT COUNT(*) FROM e3;
+----------+
| COUNT(*) |
+----------+
|  1000000 |
+----------+
1 row in set (0.25 sec)

# Drop the rows from p0 of table e
mysql&gt; DELETE FROM e WHERE id &lt; 1000001;
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0
mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
                 FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |  0         |
| p1             |  1000000   |
+----------------+------------+
2 rows in set (0.00 sec)

# Exchange partition p0 of table e with the table e2 'WITH VALIDATION'
mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0 WITH TABLE e2 WITH VALIDATION;
Query OK, 0 rows affected (0.74 sec)

# Confirm that the partition was exchanged with table e2
mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
                 FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             | 1000000    |
| p1             | 1000000    |
+----------------+------------+
2 rows in set (0.00 sec)

# Once again, drop the rows from p0 of table e
mysql&gt; DELETE FROM e WHERE id &lt; 1000001;
Query OK, 1000000 rows affected (5.55 sec)

# Confirm that there are no rows in partition p0
mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
                 FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             |  0         |
| p1             | 1000000    |
+----------------+------------+
2 rows in set (0.00 sec)

# Exchange partition p0 of table e with the table e3 'WITHOUT VALIDATION'
mysql&gt; ALTER TABLE e EXCHANGE PARTITION p0
                WITH TABLE e3 WITHOUT VALIDATION;
Query OK, 0 rows affected (0.01 sec)

# Confirm that the partition was exchanged with table e3
mysql&gt; SELECT PARTITION_NAME, TABLE_ROWS
                 FROM INFORMATION_SCHEMA.PARTITIONS WHERE TABLE_NAME = 'e';
+----------------+------------+
| PARTITION_NAME | TABLE_ROWS |
+----------------+------------+
| p0             | 1000000    |
| p1             | 1000000    |
+----------------+------------+
2 rows in set (0.00 sec)
</pre>

<p>Если раздел обменен с таблицей, которая содержит строки, которые не
соответствуют определению разделения, обязанность администратора базы данных
установить несоответствующие строки, используя
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a> или
<a href="sql.htm#alter-table-partition-operations">
<code>ALTER TABLE ... REPAIR PARTITION</code></a>.</p>

<h4><a name="idm139965297940624"></a>
Обмен подразделения с неразделенной таблицей</h4>
<p>Вы можете также обменять подразделение таблицы (см.
<a href="#partitioning-subpartitions">раздел 20.2.6</a>)
с неразделенной таблицей, используя
<a href="sql.htm#alter-table"><code>ALTER TABLE ... EXCHANGE PARTITION</code>
</a>. В следующем примере мы сначала составляем таблицу <code>es</code>,
разделенную <code>RANGE</code> и подразделенную <code>KEY</code>, заполним
эту таблицу, как в случае с таблицей <code>e</code>, а затем создадим пустую,
неразделенную копию <code>es2</code> таблицы, как показано здесь:
<pre>
mysql&gt; CREATE TABLE es (id INT NOT NULL, fname VARCHAR(30),
    -&gt;                  lname VARCHAR(30))
    -&gt;        PARTITION BY RANGE (id)
    -&gt;        SUBPARTITION BY KEY (lname) SUBPARTITIONS 2
    -&gt;        (PARTITION p0 VALUES LESS THAN (50),
    -&gt;         PARTITION p1 VALUES LESS THAN (100),
    -&gt;         PARTITION p2 VALUES LESS THAN (150),
    -&gt;         PARTITION p3 VALUES LESS THAN (MAXVALUE));
Query OK, 0 rows affected (2.76 sec)

mysql&gt; INSERT INTO es VALUES
    -&gt;        (1669, "Jim", "Smith"),
    -&gt;        (337, "Mary", "Jones"),
    -&gt;        (16, "Frank", "White"),
    -&gt;        (2005, "Linda", "Black");
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0

mysql&gt; CREATE TABLE es2 LIKE es;
Query OK, 0 rows affected (1.27 sec)

mysql&gt; ALTER TABLE es2 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.70 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre>

<p>Хотя мы явно не называли ни одного подразделения, составляя таблицу
<code>es</code>, мы можем получить произведенные названия включением столбца
<code>SUBPARTITION_NAME</code> таблицы
<a href="inform.htm#partitions-table"><code>PARTITIONS</code></a> из
<code>INFORMATION_SCHEMA</code>, как показано здесь:
<pre>
mysql&gt; SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'es';
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |  1         |
| p0             | p0sp1             |  0         |
| p1             | p1sp0             |  0         |
| p1             | p1sp1             |  0         |
| p2             | p2sp0             |  0         |
| p2             | p2sp1             |  0         |
| p3             | p3sp0             |  3         |
| p3             | p3sp1             |  0         |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)
</pre>

<p>Следующий запрос
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE</code>
</a> обменивает подраздел <code>p3sp0</code> в таблице <code>es</code>
с неразделенной таблицей <code>es2</code>:
<pre>
mysql&gt; ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es2;
Query OK, 0 rows affected (0.29 sec)
</pre>

<p>Вы можете проверить, что строки были обменены, выпуская следующие запросы:
<pre>
mysql&gt; SELECT PARTITION_NAME, SUBPARTITION_NAME, TABLE_ROWS
    -&gt;        FROM INFORMATION_SCHEMA.PARTITIONS
    -&gt;        WHERE TABLE_NAME = 'es';
+----------------+-------------------+------------+
| PARTITION_NAME | SUBPARTITION_NAME | TABLE_ROWS |
+----------------+-------------------+------------+
| p0             | p0sp0             |  1         |
| p0             | p0sp1             |  0         |
| p1             | p1sp0             |  0         |
| p1             | p1sp1             |  0         |
| p2             | p2sp0             |  0         |
| p2             | p2sp1             |  0         |
| p3             | p3sp0             |  0         |
| p3             | p3sp1             |  0         |
+----------------+-------------------+------------+
8 rows in set (0.00 sec)

mysql&gt; SELECT * FROM es2;
+------+-------+-------+
| id   | fname | lname |
+------+-------+-------+
| 1669 | Jim   | Smith |
|  337 | Mary  | Jones |
| 2005 | Linda | Black |
+------+-------+-------+
3 rows in set (0.00 sec)
</pre>

<p>Если таблица подразделена, Вы можете обменять только подраздел
с неразделенной таблицей, как показано здесь:
<pre>
mysql&gt; ALTER TABLE es EXCHANGE PARTITION p3 WITH TABLE es2;
<span>ERROR 1704 (HY000): Subpartitioned table, use subpartition
instead of partition</span>
</pre>

<p>Структуры таблиц сравнены строгим способом; число, порядок, имена и типы
столбцов и индексов разделенной таблицы и неразделенная таблица должны
соответствовать точно. Кроме того, обе таблицы должны использовать тот же
самый механизм хранения:
<pre>
mysql&gt; CREATE TABLE es3 LIKE e;
Query OK, 0 rows affected (1.31 sec)

mysql&gt; ALTER TABLE es3 REMOVE PARTITIONING;
Query OK, 0 rows affected (0.53 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; SHOW CREATE TABLE es3\G
*************************** 1. row ***************************
 Table: es3
Create Table: CREATE TABLE `es3` (
  `id` int(11) NOT NULL,
  `fname` varchar(30) DEFAULT NULL,
  `lname` varchar(30) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)

mysql&gt; ALTER TABLE es3 ENGINE = MyISAM;
Query OK, 0 rows affected (0.15 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql&gt; ALTER TABLE es EXCHANGE PARTITION p3sp0 WITH TABLE es3;
<span>ERROR 1497 (HY000): The mix of handlers in the partitions
is not allowed in this version of MySQL</span>
</pre>

<h3><a name="partitioning-maintenance"></a>20.3.4. Обслуживание разделения
</h3>
<p>Много таблиц и задач обслуживания разделения могут быть выполнены на
разделенных таблицах, используя запросы SQL, предназначенные для таких целей.
</p>

<p>Табличное обслуживание разделенных таблиц может быть достигнуто, используя
using the statements <a href="sql.htm#check-table"><code>CHECK TABLE</code>
</a>, <a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>,
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> и
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>,
которые поддержаны для разделенных таблиц.</p>

<p>Вы можете использовать много расширений для
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE</code></a> для того, чтобы выполнить операции этого типа на одном или
более разделении непосредственно, как описано в следующем списке:</p>

<ul><li><p><b>Восстановление разделения. </b>Восстанавливает разделение, это
имеет тот же самый эффект как удаление всех записей, сохраненных в
разделении, затем повторно вставляя их. Это может быть
полезно в целях дефрагментации.</p>

<p>Пример:
<pre>
ALTER TABLE t1 REBUILD PARTITION p0, p1;
</pre></li>

<li><b>Оптимизация разделения. </b>Если Вы удалили большое количество строк
из раздела или произвели много изменений в разделенной таблице со строками
переменной длины (то есть, имея столбцы
<a href="types.htm#char"><code>VARCHAR</code></a>,
<a href="types.htm#blob"><code>BLOB</code></a>, или
<a href="types.htm#blob"><code>TEXT</code></a>), Вы можете использовать
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... OPTIMIZE PARTITION</code></a>, чтобы восстановить любое
неиспользуемое место и дефрагментировать файл с данными.</p>

<p>Пример:
<pre>
ALTER TABLE t1 OPTIMIZE PARTITION p0, p1;
</pre>

<p>Использование <code>OPTIMIZE PARTITION</code>
на данном разделе эквивалентно выполнению <code>CHECK PARTITION</code>,
<code>ANALYZE PARTITION</code> и <code>REPAIR PARTITION</code>
на этом разделе.</p>

<p>Некоторые механизмы хранения MySQL, включая
<a href="innodb.htm"><code>InnoDB</code></a>, не поддерживают оптимизацию
разделов, в этих случаях
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... OPTIMIZE PARTITION</code></a> анализирует и восстанавливает всю
таблицу и выставляет соответствующее предупреждение (Bug #11751825, Bug
#42822). Используйте <code>ALTER TABLE ... REBUILD PARTITION</code> и
<code>ALTER TABLE ... ANALYZE PARTITION</code>, чтобы избежать этой проблемы.
</li>

<li><b>Анализ разделения.</b> Это читает и сохраняет ключевые
распределения для раздела.</p>
<p>Пример:
<pre>
ALTER TABLE t1 ANALYZE PARTITION p3;
</pre></li>

<li><b>Восстановление разделения. </b>
Это восстанавливает поврежденное разделение.</p>
<p>Пример:
<pre>
ALTER TABLE t1 REPAIR PARTITION p0,p1;
</pre>

<p>Обычно <code>REPAIR PARTITION</code> терпит неудачу, когда разделение
содержит ошибки дублирования ключа. Вы можете использовать
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
IGNORE TABLE</code></a> с этой опцией, когда все строки, которые не могут
быть перемещены из-за дубликатов ключа, удалены из разделения (Bug
#16900947).</li>

<li><b>Проверка разделения. </b>Вы можете проверить разделение на ошибки
почти таким же способом, которым Вы можете использовать <code>CHECK TABLE
</code> с неразделенными таблицами.</p>
<p>Пример:
<pre>
ALTER TABLE trb3 CHECK PARTITION p1;
</pre>

<p>Эта команда скажет Вам, повреждены ли данные или индексы в разделе
<code>p1</code> таблицы <code>t1</code>. Если это верно, надо использовать
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... REPAIR PARTITION</code></a> для ремонта раздела.</p>

<p>Обычно <code>CHECK PARTITION</code> терпит неудачу, когда разделение
содержит ошибки дублирования ключа. Вы можете использовать
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
IGNORE TABLE</code></a> с этой опцией, когда запрос возвращает содержание
каждой строки в разделении, где найдено нарушение дублирования ключа.
Отметьте, что сообщается только о значениях для столбцов в выражении
разделения таблицы (Bug #16900947).</p></li></ul>

<p>Каждый из запрсов в списке также поддерживает ключевое слово
<code>ALL</code> вместо списка имен разделов. Использование <code>ALL</code>
заставляет запрос действовать на все разделение в таблице.</p>

<p>Вы можете также усечь раздел с помощью
<a href="sql.htm#alter-table"><code>ALTER TABLE ... TRUNCATE PARTITION</code>
</a>. Этот запрос может использоваться, чтобы удалить все строки из одного
или более разделов почти таким же способом, которым
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
удаляет все строки из таблицы.</p>
<p><a href="sql.htm#alter-table"><code>ALTER TABLE ...
TRUNCATE PARTITION ALL</code></a> усекает все разделение в таблице.</p>

<h3><a name="partitioning-info"></a>20.3.5.
Получение информации о разделении</h3>
<p>Этот раздел обсуждает получение информации о существующем разделении,
которое может быть сделано многими способами. Методы получения такой
информации включают следующее:</p>

<ul><li><p>Использование <a href="sql.htm#show-create-table"><code>SHOW
CREATE TABLE</code></a>, чтобы рассмотреть пункты разделения, используемые в
составлении разделенной таблицы.</li>

<li>Использование <a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS
</code></a>, чтобы определить, разделена ли таблица.</li>
<li>Запрос таблицы <a href="inform.htm#partitions-table"><code>
INFORMATION_SCHEMA.PARTITIONS</code></a>.</li>

<li>Использование <a href="sql.htm#explain"><code>EXPLAIN PARTITIONS SELECT
</code></a>, чтобы видеть, какое разделение используется данным
<a href="sql.htm#select"><code>SELECT</code></a>.</p></li></ul>

<p><a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE</code></a>
включает в вывод <code>PARTITION BY</code>, которым таблица создана. Пример:
<pre>
mysql&gt; SHOW CREATE TABLE trb3\G
*************************** 1. row ***************************
 Table: trb3
Create Table: CREATE TABLE `trb3` (
  `id` int(11) default NULL,
  `name` varchar(50) default NULL,
  `purchased` date default NULL) ENGINE=MyISAM DEFAULT CHARSET=latin1
PARTITION BY RANGE (YEAR(purchased)) (
  PARTITION p0 VALUES LESS THAN (1990) ENGINE = MyISAM,
  PARTITION p1 VALUES LESS THAN (1995) ENGINE = MyISAM,
  PARTITION p2 VALUES LESS THAN (2000) ENGINE = MyISAM,
  PARTITION p3 VALUES LESS THAN (2005) ENGINE = MyISAM)
1 row in set (0.00 sec)
</pre>

<p>Вывод <a href="sql.htm#show-table-status"><code>SHOW TABLE STATUS</code>
</a> для разделенных таблиц тот же самый, как для неразделенных таблиц, за
исключением того, что столбец <code>Create_options</code> содержит строку
<code>partitioned</code>. Столбец <code>Engine</code> содержит название
механизма хранения, используемого всем разделением таблицы. См.
<a href="sql.htm#show-table-status">раздел 14.7.5.36</a>.</p>

<p>Вы можете также получить информацию о разделении от
<code>INFORMATION_SCHEMA</code>, которая содержит таблицу
<a href="inform.htm#partitions-table"><code>PARTITIONS</code></a>. См.
<a href="inform.htm#partitions-table">раздел 22.14</a>.</p>

<p>Возможно определить, какой раздел разделенной таблицы вовлечен в данный
запрос <a href="sql.htm#select"><code>SELECT</code></a>, используя
<a href="sql.htm#explain"><code>EXPLAIN PARTITIONS</code></a>. Ключевое слово
<code>PARTITIONS</code> добавляет столбец <code>partitions</code> в вывод
<a href="sql.htm#explain"><code>EXPLAIN</code></a>.</p>

<p>Предположите, что таблица <code>trb1</code> создана и
заполнена следующим образом:
<pre>
CREATE TABLE trb1 (id INT, name VARCHAR(50), purchased DATE)
       PARTITION BY RANGE(id)
       (PARTITION p0 VALUES LESS THAN (3),
        PARTITION p1 VALUES LESS THAN (7),
        PARTITION p2 VALUES LESS THAN (9),
        PARTITION p3 VALUES LESS THAN (11));

INSERT INTO trb1 VALUES
       (1, 'desk organiser', '2003-10-15'),
       (2, 'CD player', '1993-11-05'),
       (3, 'TV set', '1996-03-10'),
       (4, 'bookcase', '1982-01-10'),
       (5, 'exercise bike', '2004-05-09'),
       (6, 'sofa', '1987-06-05'),
       (7, 'popcorn maker', '2001-11-22'),
       (8, 'aquarium', '1992-08-04'),
       (9, 'study desk', '1984-09-16'),
       (10, 'lava lamp', '1998-12-25');
</pre>

<p>Вы можете видеть, какой раздел используется в запросе
<code>SELECT * FROM trb1;</code>:
<pre>
mysql&gt; EXPLAIN PARTITIONS SELECT * FROM trb1\G
*************************** 1. row ***************************
   id: 1
  select_type: SIMPLE
table: trb1
   partitions: p0,p1,p2,p3
 type: ALL
possible_keys: NULL
  key: NULL
key_len: NULL
  ref: NULL
 rows: 10
Extra: Using filesort
</pre>

<p>В этом случае работают все четыре раздела. Однако, когда ограничивающее
условие, использующее ключ разделения, добавлено к запросу, Вы можете видеть,
что просмотрено только разделение, содержащее соответствие значений,
как показано здесь:
<pre>
mysql&gt; EXPLAIN PARTITIONS SELECT * FROM trb1 WHERE id &lt; 5\G
*************************** 1. row ***************************
   id: 1
  select_type: SIMPLE
table: trb1
   partitions: p0,p1
 type: ALL
possible_keys: NULL
  key: NULL
key_len: NULL
  ref: NULL
 rows: 10
Extra: Using where
</pre>

<p><a href="sql.htm#explain"><code>EXPLAIN PARTITIONS</code></a>
предоставляет информацию о ключах используемых и возможных так же, как
стандартный запрос <a href="sql.htm#explain"><code>EXPLAIN SELECT</code></a>:
<pre>
mysql&gt; ALTER TABLE trb1 ADD PRIMARY KEY (id);
Query OK, 10 rows affected (0.03 sec)
Records: 10  Duplicates: 0  Warnings: 0

mysql&gt; EXPLAIN PARTITIONS SELECT * FROM trb1 WHERE id &lt; 5\G
*************************** 1. row ***************************
   id: 1
  select_type: SIMPLE
table: trb1
   partitions: p0,p1
 type: range
possible_keys: PRIMARY
  key: PRIMARY
key_len: 4
  ref: NULL
 rows: 7
Extra: Using where
</pre>

<p>Вы должны принять во внимание следующие ограничения на
<a href="sql.htm#explain"><code>EXPLAIN PARTITIONS</code></a>:</p>
<ul><li><p>Вы не можете использовать ключевые слова <code>PARTITIONS</code> и
<code>EXTENDED</code> вместе в том же самом запросе
<a href="sql.htm#explain"><code>EXPLAIN ... SELECT</code></a>.
Попытка сделать так производит синтаксическую ошибку.</li>

<li>Если используется <a href="sql.htm#explain"><code>EXPLAIN PARTITIONS
</code></a>, чтобы исследовать запрос к неразделенной таблице, никакая ошибка
не произведена, но значение столбца
<code>partitions</code> всегда <code>NULL</code>.</p></li></ul>

<p>Столбец <code>rows</code> вывода
<a href="sql.htm#explain"><code>EXPLAIN PARTITIONS</code></a>
выводит на экран общее количество строк в таблице.</p>

<h2><a name="partitioning-pruning"></a>20.4. Сокращение разделения</h2>
<p>Оптимизация, известная как <span>сокращение разделения</span>, основана на
относительно простом понятии, которое может быть описано как
<span>не просматривать раздел, где не может быть никакого соответствия
</span>. Предположите разделенную таблицу <code>t1</code>,
созданную этим запросом:
<pre>
CREATE TABLE t1 (fname VARCHAR(50) NOT NULL, lname VARCHAR(50) NOT NULL,
                 region_code TINYINT UNSIGNED NOT NULL, dob DATE NOT NULL)
       PARTITION BY RANGE(region_code)
       (PARTITION p0 VALUES LESS THAN (64),
        PARTITION p1 VALUES LESS THAN (128),
        PARTITION p2 VALUES LESS THAN (192),
        PARTITION p3 VALUES LESS THAN MAXVALUE);
</pre>

<p>Предположите, что Вы хотите получить результаты такого
<a href="sql.htm#select"><code>SELECT</code></a>:
<pre>
SELECT fname, lname, region_code, dob FROM t1
       WHERE region_code &gt; 125 AND region_code &lt; 130;
</pre>

<p>Легко видеть, что ни одна из строк, которые должны быть возвращены, не
находится ни в одном из разделов <code>p0</code> или <code>p3</code>,
то есть, мы должны искать только в разделах <code>p1</code> и <code>p2
</code>. Ограничивая поиск, возможно израсходовать намного меньше времени и
усилий в обнаружении соответствия строк, чем просматривая все разделение в
таблице. Этот путь известен как <span>сокращение</span>. Когда оптимизатор
может использовать сокращение в выполнении этого запроса, выполнение запроса
может быть на порядок быстрее, чем тот же самый запрос на неразделенной
таблице, содержащей те же самые определения столбца и данные.</p>

<p>Оптимизатор может выполнить сокращение всякий раз, когда выражение
<code>WHERE</code> может быть уменьшено до любого из следующих двух случаев:
</p>
<ul><li><p><code><em><code>partition_column</code></em> =
<em><code>constant</code></em></code></li>
<li><code><em><code>partition_column</code></em> IN
(<em><code>constant1</code></em>, <em><code>constant2</code></em>, ...,
<em><code>constantN</code></em>)</code></p></li></ul>

<p>В первом случае оптимизатор просто оценивает выражение разделения для
данного значения, определяет, какой раздел содержит то значение, и
просматривает только этот раздел. Во многих случаях знак &quot;равно&quot;
может быть заменен другим арифметическим сравнением, включая
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>
и <code>&lt;&gt;</code>. Некоторое запросы <code>BETWEEN</code> в
<code>WHERE</code> могут также использовать в своих
интересах сокращение разделения.</p>

<p>Во втором случае оптимизатор оценивает выражение разделения для каждого
значения в списке, создает список соответствия разделения, и затем
просматривает только раздел в этом списке.</p>

<p><a href="sql.htm#select"><code>SELECT</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>
поддерживают сокращение разделения.
<a href="sql.htm#insert"><code>INSERT</code></a> сейчас так не умеет.</p>

<p>Сокращение может также быть применено к малым диапазонам, которые
оптимизатор может преобразовать в эквивалентные списки значений. Например, в
предыдущем примере <code>WHERE</code> может быть преобразован в
<code>WHERE region_code IN (126, 127, 128, 129)</code>. Тогда оптимизатор
может решить, что первые два значения в списке найдены в разделе
<code>p1</code>, остальные два значения в разделе <code>p2</code>, а
другие разделы не содержат соответствующих значений.</p>

<p>Оптимизатор может также выполнить сокращение для условия
<code>WHERE</code>, которое вовлекает сравнения предыдущих типов на многих
столбцах для таблиц <code>RANGE COLUMNS</code> или <code>LIST COLUMNS</code>.
</p>

<p>Этот тип оптимизации может быть применен всякий раз, когда выражение
разделения состоит из равенства или диапазона, который может быть уменьшен до
ряда равенств, или когда выражение разделения представляет увеличение или
уменьшение отношений. Сокращение может также быть применено для таблиц,
разделенных на столбцах <a href="types.htm#datetime"><code>DATE</code></a>
или <a href="types.htm#datetime"><code>DATETIME</code></a>, когда выражение
разделения использует функцию
<a href="funct.htm#function_year"><code>YEAR()</code></a> или
<a href="funct.htm#function_to-days"><code>TO_DAYS()</code></a>.
Сокращение может также быть применено для таких таблиц, когда выражение
разделения использует функцию
<a href="funct.htm#function_to-seconds"><code>TO_SECONDS()</code></a>.</p>

<p>Предположите таблицу <code>t2</code>, разделенную на столбце
<a href="types.htm#datetime"><code>DATE</code></a>,
созданную, используя запрос:
<pre>
CREATE TABLE t2 (fname VARCHAR(50) NOT NULL, lname VARCHAR(50) NOT NULL,
                 region_code TINYINT UNSIGNED NOT NULL, dob DATE NOT NULL)
       PARTITION BY RANGE (YEAR(dob)) (
       PARTITION d0 VALUES LESS THAN (1970),
       PARTITION d1 VALUES LESS THAN (1975),
       PARTITION d2 VALUES LESS THAN (1980),
       PARTITION d3 VALUES LESS THAN (1985),
       PARTITION d4 VALUES LESS THAN (1990),
       PARTITION d5 VALUES LESS THAN (2000),
       PARTITION d6 VALUES LESS THAN (2005),
       PARTITION d7 VALUES LESS THAN MAXVALUE);
</pre>

<p>Следующие запросы используют <code>t2</code> и могут сделать сокращение:
<pre>
SELECT * FROM t2 WHERE dob = '1982-06-23';
UPDATE t2 SET region_code = 8 WHERE dob BETWEEN '1991-02-15' AND '1997-04-25';
DELETE FROM t2 WHERE dob &gt;= '1984-06-21' AND dob &lt;= '1999-06-21'
</pre>

<p>В случае последнего запроса оптимизатор может также
действовать следующим образом:</p>

<ol type="1"><li><p>Найдите раздел, содержащий нижний уровень диапазона.</p>
<p><a href="funct.htm#function_year"><code>YEAR('1984-06-21')</code></a>
приводит к значению <code>1984</code>, которое найдено в разделе
<code>d3</code>.</li>

<li>Найдите раздел, содержащий верхний уровень диапазона.</p>
<p><a href="funct.htm#function_year"><code>YEAR('1999-06-21')</code></a>
оценивается как <code>1999</code>, который найден в разделе <code>d5</code>.
</li>

<li>Просмотрите только эти два раздела и любой раздел, который может
находиться между ними.</p>
<p>В этом случае это означает, что просматриваются только разделы
<code>d3</code>, <code>d4</code> и <code>d5</code>.
Остающиеся разделы могут быть безопасно проигнорированы.</p></li></ol>

<p>Недопустимые значения <code>DATE</code> и <code>DATETIME</code>, на
которые ссылаются в условии <code>WHERE</code>, обработаны как
<code>NULL</code>. Это означает что такой запрос, как
<code>SELECT * FROM <em><code>partitioned_table</code></em>
WHERE <em><code>date_column</code></em> &lt; '2008-12-00'</code>
не возвращает значений (см. Bug #40972).</p>

<p>До сих пор мы только смотрели на использование в качестве примера
разделения <code>RANGE</code>, но сокращение может быть применено и с
другими типами разделения.</p>

<p>Рассмотрите таблицу, которая разделена <code>LIST</code>,
где выражение разделения увеличивается или уменьшается, например, таблицу
<code>t3</code>. В этом примере мы предполагаем ради краткости, что столбец
<code>region_code</code> ограничен значениями между 1 и 10 включительно.

<pre>
CREATE TABLE t3 (fname VARCHAR(50) NOT NULL,
                 lname VARCHAR(50) NOT NULL,
                 region_code TINYINT UNSIGNED NOT NULL, dob DATE NOT NULL)
       PARTITION BY LIST(region_code) (PARTITION r0 VALUES IN (1, 3),
                                       PARTITION r1 VALUES IN (2, 5, 8),
                                       PARTITION r2 VALUES IN (4, 9),
                                       PARTITION r3 VALUES IN (6, 7, 10));
</pre>

<p>Для такого запроса как <code>SELECT * FROM t3 WHERE
region_code BETWEEN 1 AND 3</code> оптимизатор определяет, в котором
разделе находятся значения 1, 2 и 3 (<code>r0</code> и <code>r1</code>)
и пропускает остающиеся (<code>r2</code> и <code>r3</code>).</p>

<p>Для таблиц, которые разделены <code>HASH</code> или <code>[LINEAR] KEY
</code>, сокращение разделения также возможно в случаях, в которых
<code>WHERE</code>  использует простое отношение <code>=</code> для
столбца, который используется в выражении разделения.
Считайте таблицу создаваемой так:
<pre>
CREATE TABLE t4 (fname VARCHAR(50) NOT NULL, lname VARCHAR(50) NOT NULL,
                 region_code TINYINT UNSIGNED NOT NULL, dob DATE NOT NULL)
       PARTITION BY KEY(region_code) PARTITIONS 8;
</pre>

<p>Может быть сокращен запрос, который сравнивает
значение столбца с константой:
<pre>
UPDATE t4 WHERE region_code = 7;
</pre>

<p>Сокращение может также использоваться для малых диапазонов, потому что
оптимизатор может повернуть такие условия в отношение <code>IN</code>.
Например, используя ту же самую таблицу <code>t4</code>, определенную ранее,
такие запросы могут быть сокращены:
<pre>
SELECT * FROM t4 WHERE region_code &gt; 2 AND region_code &lt; 6;
SELECT * FROM t4 WHERE region_code BETWEEN 3 AND 5;
</pre>

<p>В обоих этих случаях <code>WHERE</code> преобразован оптимизатором в
<code>WHERE region_code IN (3, 4, 5)</code>.</p>
<p>Эта оптимизация используется, только если размер диапазона меньше,
чем число разделов. Рассмотрите этот запрос:
<pre>
DELETE FROM t4 WHERE region_code BETWEEN 4 AND 12;
</pre>

<p>Диапазон в <code>WHERE</code> касается 9 значений
(4, 5, 6, 7, 8, 9, 10, 11, 12), но <code>t4</code> имеет только 8 разделов.
Это означает, что <code>DELETE</code> не может быть сокращен.</p>

<p>Когда таблица разделена <code>HASH</code> или <code>[LINEAR] KEY</code>,
сокращение может использоваться только на столбцах целого числа. Например,
этот запрос не может использовать сокращение, потому что <code>dob</code>
столбец типа <a href="types.htm#datetime"><code>DATE</code></a>:
<pre>
SELECT * FROM t4 WHERE dob &gt;= '2001-04-14' AND dob &lt;= '2005-10-15';
</pre>

<p>Однако, если таблица хранит значения года в столбце
<a href="types.htm#integer-types"><code>INT</code></a>, то запрос, имеющий
<code>WHERE year_col &gt;= 2001 AND year_col &lt;=2005</code>
может быть сокращен.</p>

<p>Таблицы, использующие механизм хранения, который обеспечивает
автоматическое разделение, такой как <code>NDB</code>, используемый MySQL
Cluster (не поддерживается сейчас в MySQL 8.0), могут быть сокращены,
если они явно разделены.</p>

<h2><a name="partitioning-selection"></a>20.5. Выбор разделения</h2>
<p>Явный выбор разделения и подразделения для строк, соответствующих данному
<code>WHERE</code> поддержан. Выбор разделения подобен сокращению разделения,
но отличается по двум ключевым отношениям:</p>

<ol type="1"><li><p>Разделение, которое будет проверено, определено
запросом, в отличие от сокращения разделения,
которое является автоматическим.</li>

<li>Принимая во внимание, что сокращение разделения применяется только к
запросам, явный выбор разделения поддержан для многих запросов и DML.
</p></li></ol>

<p>Запросы SQL, поддерживающие явный выбор разделения, перечислены здесь:</p>
<ul><li><p><a href="sql.htm#select"><code>SELECT</code></a></li>
<li><a href="sql.htm#delete"><code>DELETE</code></a></li>
<li><a href="sql.htm#insert"><code>INSERT</code></a></li>
<li><a href="sql.htm#replace"><code>REPLACE</code></a></li>
<li><a href="sql.htm#update"><code>UPDATE</code></a></li>
<li><a href="sql.htm#load-data"><code>LOAD DATA</code></a>.</li>
<li><a href="sql.htm#load-xml"><code>LOAD XML</code></a>.</p></li></ul>

<p>Явный выбор разделения осуществлен, используя опцию
<code>PARTITION</code>. Для всех поддержанных запросов
эта опция использует синтаксис, показанный здесь:
<pre>
PARTITION (<em><code>partition_names</code></em>)
<em><code>partition_names</code></em>:
<em><code>partition_name</code></em>, ...
</pre>

<p>Эта опция всегда следует за названием таблицы, которой принадлежит
разделение. <em><code>partition_names</code></em> это список разделенных
запятой значений разделения или подразделения, которое будет использоваться.
Каждое имя в этом списке должно быть названием существующего разделения или
подразделения указанной таблицы, если какое-либо разделение или подразделение
не найдено, запрос терпит неудачу с ошибкой (<span>partition
'<em><code>partition_name</code></em>' doesn't exist</span>).
Разделение и подразделение, названное в
<em><code>partition_names</code></em> могут быть перечислены в любом
порядке и могут наложиться.</p>

<p>Когда опция <code>PARTITION</code> используется, только перечисленные
разделение и подразделение проверены на соответствие строк. Эта опция может
использоваться в <a href="sql.htm#select"><code>SELECT</code></a>, чтобы
определить, какие строки принадлежат данному разделению. Считайте разделенную
таблицу, названную <code>employees</code>, создаваемой и заполняемой с
использованием показанных запросов:
<pre>
SET @@SQL_MODE = '';
CREATE TABLE employees (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                        fname VARCHAR(25) NOT NULL,
                        lname VARCHAR(25) NOT NULL,
                        store_id INT NOT NULL, department_id INT NOT NULL)
       PARTITION BY RANGE(id) (PARTITION p0 VALUES LESS THAN (5),
                               PARTITION p1 VALUES LESS THAN (10),
                               PARTITION p2 VALUES LESS THAN (15),
                               PARTITION p3 VALUES LESS THAN MAXVALUE);
INSERT INTO employees VALUES
       ('', 'Bob', 'Taylor', 3, 2), ('', 'Frank', 'Williams', 1, 2),
       ('', 'Ellen', 'Johnson', 3, 4), ('', 'Jim', 'Smith', 2, 4),
       ('', 'Mary', 'Jones', 1, 1), ('', 'Linda', 'Black', 2, 3),
       ('', 'Ed', 'Jones', 2, 1), ('', 'June', 'Wilson', 3, 1),
       ('', 'Andy', 'Smith', 1, 3), ('', 'Lou', 'Waters', 2, 4),
       ('', 'Jill', 'Stone', 1, 4), ('', 'Roger', 'White', 3, 2),
       ('', 'Howard', 'Andrews', 1, 2), ('', 'Fred', 'Goldberg', 3, 3),
       ('', 'Barbara', 'Brown', 2, 3), ('', 'Alice', 'Rogers', 2, 2),
       ('', 'Mark', 'Morgan', 3, 3), ('', 'Karen', 'Cole', 3, 2);
</pre>

<p>Вы можете видеть, какие строки сохранены в разделе <code>p1</code>:
<pre>
mysql&gt; SELECT * FROM employees PARTITION (p1);
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  5 | Mary  | Jones  | 1        | 1             |
|  6 | Linda | Black  | 2        | 3             |
|  7 | Ed    | Jones  | 2        | 1             |
|  8 | June  | Wilson | 3        | 1             |
|  9 | Andy  | Smith  | 1        | 3             |
+----+-------+--------+----------+---------------+
5 rows in set (0.00 sec)
</pre>

<p>Результат тот же самый, какой получен запросом
<code>SELECT * FROM employees WHERE id BETWEEN 5 AND 9</code>.</p>
<p>Чтобы получить строки из многих разделов, укажите их имена как
разграниченный запятой список. Например, <code>SELECT * FROM
employees PARTITION (p1, p2)</code> вернет все строки из разделов
<code>p1</code> и <code>p2</code> в то же время исключая строки
от остающегося раздела.</p>

<p>Любой допустимый запрос может быть переписан с опцией
<code>PARTITION</code>, чтобы ограничить результат одним или более
желаемым разделом. Вы можете использовать условия
<code>WHERE</code>, <code>ORDER BY</code> и опцию <code>LIMIT</code>.
Вы можете также использовать совокупные функции с опциями
<code>HAVING</code> и <code>GROUP BY</code>. Каждый из следующих запросов
приводит к допустимому результату, когда работает с таблицей
<code>employees</code>, определенной ранее:
<pre>
mysql&gt; SELECT * FROM employees PARTITION (p0, p2) WHERE lname LIKE 'S%';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
|  4 | Jim   | Smith | 2        | 4             |
| 11 | Jill  | Stone | 1        | 4             |
+----+-------+-------+----------+---------------+
2 rows in set (0.00 sec)

mysql&gt; SELECT id, CONCAT(fname, ' ', lname) AS name
    -&gt;        FROM employees PARTITION (p0) ORDER BY lname;
+----+----------------+
| id | name           |
+----+----------------+
|  3 | Ellen Johnson  |
|  4 | Jim Smith      |
|  1 | Bob Taylor     |
|  2 | Frank Williams |
+----+----------------+
4 rows in set (0.06 sec)

mysql&gt; SELECT store_id, COUNT(department_id) AS c
    -&gt;        FROM employees PARTITION (p1,p2,p3)
    -&gt;        GROUP BY store_id HAVING c &gt; 4;
+---+----------+
| c | store_id |
+---+----------+
| 5 | 2        |
| 5 | 3        |
+---+----------+
2 rows in set (0.00 sec)
</pre>

<p>Запросы используя выбор разделения могут использоваться с таблицами,
используя любой из поддержанных типов разделения. Когда таблица составлена,
используя <code>[LINEAR] HASH</code> или <code>[LINEAR] KEY</code>
и названия разделов не определены, MySQL автоматически называет разделы
<code>p0</code>, <code>p1</code>, <code>p2</code>, ..., <code>p<em><code>
N-1</code></em></code>, где <em><code>N</code></em> число разделов.
Для подразделения не названного явно MySQL назначает автоматически
подразделам в каждом разделе <code>p<em><code>X</code></em></code> имена
<code>p<em><code>X</code></em>sp0</code>,
<code>p<em><code>X</code></em>sp1</code>,
<code>p<em><code>X</code></em>sp2</code>, ...,
<code>p<em><code>X</code></em>sp<em><code>M-1</code></em></code>, где
<em><code>M</code></em> количество подразделов. Выполняя для этой таблицы
<a href="sql.htm#select"><code>SELECT</code></a> (или другой запрос SQL, для
которого позволен явный выбор разделения), Вы можете использовать эти
произведенные имена в опции <code>PARTITION</code>, как показано здесь:
<pre>
mysql&gt; CREATE TABLE employees_sub (id INT NOT NULL AUTO_INCREMENT,
    -&gt;                             fname VARCHAR(25) NOT NULL,
    -&gt;                             lname VARCHAR(25) NOT NULL,
    -&gt;                             store_id INT NOT NULL,
    -&gt;                             department_id INT NOT NULL,
    -&gt;                             PRIMARY KEY pk (id, lname))
    -&gt;        PARTITION BY RANGE(id) SUBPARTITION BY KEY (lname)
    -&gt;        SUBPARTITIONS 2 (PARTITION p0 VALUES LESS THAN (5),
    -&gt;                         PARTITION p1 VALUES LESS THAN (10),
    -&gt;                         PARTITION p2 VALUES LESS THAN (15),
    -&gt;                         PARTITION p3 VALUES LESS THAN MAXVALUE);
Query OK, 0 rows affected (1.14 sec)

mysql&gt; INSERT INTO employees_sub   # reuse data in employees table
    -&gt;        SELECT * FROM employees;
Query OK, 18 rows affected (0.09 sec)
Records: 18  Duplicates: 0  Warnings: 0

mysql&gt; SELECT id, CONCAT(fname, ' ', lname) AS name
    -&gt;        FROM employees_sub PARTITION (p2sp1);
+----+---------------+
| id | name          |
+----+---------------+
| 10 | Lou Waters    |
| 14 | Fred Goldberg |
+----+---------------+
2 rows in set (0.00 sec)
</pre>

<p>Вы можете также использовать опцию <code>PARTITION</code> в части
<a href="sql.htm#select"><code>SELECT</code></a> запроса
<a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>:
<pre>
mysql&gt; CREATE TABLE employees_copy LIKE employees;
Query OK, 0 rows affected (0.28 sec)

mysql&gt; INSERT INTO employees_copy
    -&gt;        SELECT * FROM employees PARTITION (p2);
Query OK, 5 rows affected (0.04 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql&gt; SELECT * FROM employees_copy;
+----+--------+----------+----------+---------------+
| id | fname  | lname    | store_id | department_id |
+----+--------+----------+----------+---------------+
| 10 | Lou    | Waters   | 2        | 4             |
| 11 | Jill   | Stone    | 1        | 4             |
| 12 | Roger  | White    | 3        | 2             |
| 13 | Howard | Andrews  | 1        | 2             |
| 14 | Fred   | Goldberg | 3        | 3             |
+----+--------+----------+----------+---------------+
5 rows in set (0.00 sec)
</pre>

<p>Выбор разделения может также использоваться с соединениями. Предположите,
что мы создаем и заполняем две таблицы, используя запросы, показанные здесь:
<pre>
CREATE TABLE stores (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                     city VARCHAR(30) NOT NULL)
       PARTITION BY HASH(id) PARTITIONS 2;
INSERT INTO stores VALUES
       ('', 'Nambucca'), ('', 'Uranga'),
       ('', 'Bellingen'), ('', 'Grafton');
CREATE TABLE departments (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                          name VARCHAR(30) NOT NULL)
       PARTITION BY KEY(id) PARTITIONS 2;
INSERT INTO departments VALUES
       ('', 'Sales'), ('', 'Customer Service'),
       ('', 'Delivery'), ('', 'Accounting');
</pre>

<p>Вы можете явно выбрать раздел (подраздел или то и другое сразу)
из любых таблиц в соединении. Отметьте, что опция <code>PARTITION</code>,
которая выбирает раздел из данной таблицы, немедленно следует за названием
таблицы, перед всеми другими опциями, включая любой табличный псевдоним.
Например, следующий запрос получает значения name, employee ID, department и
city для всех служащих, которые работают в продажах или отделе поставки
(раздел <code>p1</code> таблицы <code>departments</code>)
в хранилищах в любом из городов Nambucca и Bellingen (а это уже раздел
<code>p0</code> таблицы <code>stores</code>):
<pre>
mysql&gt; SELECT e.id AS 'Employee ID',
    -&gt;        CONCAT(e.fname, ' ', e.lname) AS Name,
    -&gt;        s.city AS City, d.name AS department FROM employees AS e
    -&gt;        JOIN stores PARTITION (p1) AS s ON e.store_id=s.id
    -&gt;        JOIN departments PARTITION (p0) AS d ON e.department_id=d.id
    -&gt;        ORDER BY e.lname;
+-------------+---------------+-----------+------------+
| Employee ID | Name          | City      | department |
+-------------+---------------+-----------+------------+
|  14         | Fred Goldberg | Bellingen | Delivery   |
|   5         | Mary Jones    | Nambucca  | Sales      |
|  17         | Mark Morgan   | Bellingen | Delivery   |
|   9         | Andy Smith    | Nambucca  | Delivery   |
|   8         | June Wilson   | Bellingen | Sales      |
+-------------+---------------+-----------+------------+
5 rows in set (0.00 sec)
</pre>

<p>Когда опция <code>PARTITION</code> используется с
<a href="sql.htm#delete"><code>DELETE</code></a>, только тот раздел
(и подраздел, если есть) перечисленный с опцией проверены на строки, которые
будут удалены. Любые другие разделы проигнорированы, как показано здесь:
<pre>
mysql&gt; SELECT * FROM employees WHERE fname LIKE 'j%';
+----+-------+--------+----------+---------------+
| id | fname | lname  | store_id | department_id |
+----+-------+--------+----------+---------------+
|  4 | Jim   | Smith  | 2        | 4             |
|  8 | June  | Wilson | 3        | 1             |
| 11 | Jill  | Stone  | 1        | 4             |
+----+-------+--------+----------+---------------+
3 rows in set (0.00 sec)

mysql&gt; DELETE FROM employees PARTITION (p0, p1)
    -&gt;        WHERE fname LIKE 'j%';
Query OK, 2 rows affected (0.09 sec)

mysql&gt; SELECT * FROM employees WHERE fname LIKE 'j%';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone | 1        | 4             |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre>

<p>Только эти две строки в разделах <code>p0</code> и
<code>p1</code>, соответствующие условию <code>WHERE</code> были удалены.
Как Вы можете видеть из результата, когда выполянется
<a href="sql.htm#select"><code>SELECT</code></a> во второй раз,
остается строка в таблице, соответствующая <code>WHERE</code>, но
находящяяся в ином разделе (<code>p2</code>).</p>

<p><a href="sql.htm#update"><code>UPDATE</code></a>, используя явный выбор
раздела ведут себя таким же образом: только строки в разделе, на который
ссылается опция <code>PARTITION</code> рассматриваются, определяя строки,
которые будут обновлены, как может быть замечено, выполняя следующие запросы:
<pre>
mysql&gt; UPDATE employees PARTITION (p0)
    -&gt;        SET store_id = 2 WHERE fname = 'Jill';
Query OK, 0 rows affected (0.00 sec)
Rows matched: 0  Changed: 0  Warnings: 0

mysql&gt; SELECT * FROM employees WHERE fname = 'Jill';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone | 1        | 4             |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)

mysql&gt; UPDATE employees PARTITION (p2)
    -&gt;        SET store_id = 2 WHERE fname = 'Jill';
Query OK, 1 row affected (0.09 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql&gt; SELECT * FROM employees WHERE fname = 'Jill';
+----+-------+-------+----------+---------------+
| id | fname | lname | store_id | department_id |
+----+-------+-------+----------+---------------+
| 11 | Jill  | Stone | 2        | 4             |
+----+-------+-------+----------+---------------+
1 row in set (0.00 sec)
</pre>

<p>Таким же образом, когда <code>PARTITION</code> используется с
<a href="sql.htm#delete"><code>DELETE</code></a>, только строки в разделе,
названном в списке разделов, проверены на удаление.</p>

<p>Для запросов, которые вставляют строки, поведение отличается в том, что
если подходящий раздел не найден, весь запрос отваливается. Это истина для
обоих запросов <a href="sql.htm#insert"><code>INSERT</code></a> и
<a href="sql.htm#replace"><code>REPLACE</code></a>, как показано здесь:
<pre>
mysql&gt; INSERT INTO employees PARTITION (p2) VALUES
                 (20, 'Jan', 'Jones', 1, 3);
<span>ERROR 1729 (HY000): Found a row not matching the given partition set</span>

mysql&gt; INSERT INTO employees PARTITION (p3)
                 VALUES (20, 'Jan', 'Jones', 1, 3);
Query OK, 1 row affected (0.07 sec)

mysql&gt; REPLACE INTO employees PARTITION (p0)
                  VALUES (20, 'Jan', 'Jones', 3, 2);
<span>ERROR 1729 (HY000): Found a row not matching the given partition set</span>

mysql&gt; REPLACE INTO employees PARTITION (p3)
                  VALUES (20, 'Jan', 'Jones', 3, 2);
Query OK, 2 rows affected (0.09 sec)
</pre>

<p>Для запросов, которые пишут много строк в разделенную таблицу
<a href="innodb.htm"><code>InnoDB</code></a>: если любая строка в списке
после <code>VALUES</code> не может быть записана в один из разделов,
определенных в списке <em><code>partition_names</code></em>, запрос
терпит неудачу, и никакие строки не записаны. Это показывается для
<a href="sql.htm#insert"><code>INSERT</code></a> в следующем примере, снова
используя таблицу <code>employees</code>, составленную ранее:
<pre>
mysql&gt; ALTER TABLE employees REORGANIZE PARTITION p3 INTO (
    -&gt;       PARTITION p3 VALUES LESS THAN (20),
    -&gt;       PARTITION p4 VALUES LESS THAN (25),
    -&gt;       PARTITION p5 VALUES LESS THAN MAXVALUE);
Query OK, 6 rows affected (2.09 sec)
Records: 6  Duplicates: 0  Warnings: 0

mysql&gt; SHOW CREATE TABLE employees\G
*************************** 1. row ***************************
 Table: employees
Create Table: CREATE TABLE `employees` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `fname` varchar(25) NOT NULL,
  `lname` varchar(25) NOT NULL,
  `store_id` int(11) NOT NULL,
  `department_id` int(11) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=27 DEFAULT CHARSET=latin1
/*! 50100 PARTITION BY RANGE (id)
(PARTITION p0 VALUES LESS THAN (5) ENGINE = InnoDB,
 PARTITION p1 VALUES LESS THAN (10) ENGINE = InnoDB,
 PARTITION p2 VALUES LESS THAN (15) ENGINE = InnoDB,
 PARTITION p3 VALUES LESS THAN (20) ENGINE = InnoDB,
 PARTITION p4 VALUES LESS THAN (25) ENGINE = InnoDB,
 PARTITION p5 VALUES LESS THAN MAXVALUE ENGINE = InnoDB) */
1 row in set (0.00 sec)

mysql&gt; INSERT INTO employees PARTITION (p3, p4) VALUES
    -&gt;        (24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);
ERROR 1729 (HY000): Found a row not matching the given partition set

mysql&gt; INSERT INTO employees PARTITION (p3, p4. p5) VALUES
    -&gt;        (24, 'Tim', 'Greene', 3, 1),  (26, 'Linda', 'Mills', 2, 1);
Query OK, 2 rows affected (0.06 sec)
Records: 2  Duplicates: 0  Warnings: 0
</pre>

<p>Это верно для записи многих строк одним запросом
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#replace"><code>REPLACE</code></a>.</p>

<p>Выбор разделения отключен для таблиц, использующих механизм хранения,
который поставляет автоматическое разделение, такой как <code>NDB</code>
(применяется в MySQL Cluster, сейчас не поддерживается в MySQL 8.0).</p>

<h2><a name="partitioning-limitations"></a>20.6. Ограничения на разделение
</h2>
<p>Этот раздел обсуждает текущие ограничения на поддержку разделов MySQL.</p>
<p><b>Запрещенные конструкции. </b>Следующие конструкции не
разрешены в выражениях разделений:</p>
<ul><li><p>Хранимые процедуры, сохраненные функции, UDF или плагины.</li>
<li>Объявленные или пользовательские переменные.</p></li></ul>

<p>Для списка функций SQL, которые разрешены в разделении выражений, см.
<a href="#partitioning-limitations-functions">раздел 20.6.3</a>.
<p><b>Арифметические и логические операторы. </b>Использование арифметических
операторов  <a href="funct.htm#operator_plus"><code>+</code></a>,
<a href="funct.htm#operator_minus"><code>-</code></a> и
<a href="funct.htm#operator_times"><code>*</code></a>
разрешен в разделении выражений. Однако, результат должен быть целочисленным
значением или <code>NULL</code> (кроме <code>[LINEAR] KEY</code>, как
обсуждено в другом месте в этой главе: см.
<a href="#partitioning-types">раздел 20.2</a>).</p>

<p>Оператор <a href="funct.htm#operator_div"><code>DIV</code></a> разрешен.
Оператор <a href="funct.htm#operator_divide"><code>/</code></a> запрещен.</p>
<p>Битовые операторы <a href="funct.htm#operator_bitwise-or"><code>|</code>
</a>, <a href="funct.htm#operator_bitwise-and"><code>&amp;</code></a>,
<a href="funct.htm#operator_bitwise-xor"><code>^</code></a>,
<a href="funct.htm#operator_left-shift"><code>&lt;&lt;</code></a>,
<a href="funct.htm#operator_right-shift"><code>&gt;&gt;</code></a> и
<a href="funct.htm#operator_bitwise-invert"><code>~</code></a>
не разрешены в разделении выражений.</p>

<p><b>Режимы сервера SQL. </b>Таблицы, использующие определяемое
пользователем разделение, не сохраняют режим SQL в то время, когда они
создавались. Как обсуждено в другом месте в этом руководстве (см.
<a href="server.htm#sql-mode">раздел 6.1.8</a>), результаты многих функций
MySQL и операторов могут измениться, согласно режиму SQL сервера. Поэтому
изменение в режиме SQL в любое время после создания разделенных таблиц может
привести к существенным изменениям в поведении таких таблиц, и легко может
привести к повреждению или потере данных. По этим причинам
<span><em>сильно рекомендуется, чтобы Вы никогда не изменяли режим SQL
сервера после составления разделенных таблиц</em></span>.</p>

<p><b>Примеры. </b>Следующие примеры иллюстрируют некоторые изменения в
поведении разделенных таблиц из-за изменения в режиме SQL сервера:</p>
<ol type="1"><li><p><b>Обработка ошибок. </b>Обработка особых значений
(0 и <code>NULL</code>) может отличаться в различных режимах SQL (см.
<a href="server.htm#sql-mode">раздел 6.1.8</a>). Например,
<a href="server.htm#sqlmode_error_for_division_by_zero"><code>
ERROR_FOR_DIVISION_BY_ZERO</code></a> может затронуть, может ли быть 0
вставлен как значение в таблицу, выражения разделения которой использует
<code><em><code>column</code></em> DIV
<em><code>value</code></em></code> или
<code><em><code>column</code></em> MOD
<em><code>value</code></em></code>.</li>

<li><b>Табличная доступность. </b>Иногда изменение в режиме SQL может
сделать разделенные таблицы непригодными. Следующий запрос
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
может быть выполнен успешно только если режим
<a href="server.htm#sqlmode_no_unsigned_subtraction"><code>
NO_UNSIGNED_SUBTRACTION</code></a> включен:
<pre>
mysql&gt; SELECT @@sql_mode;
+------------+
| @@sql_mode |
+------------+
|            |
+------------+
1 row in set (0.00 sec)

mysql&gt; CREATE TABLE tu (c1 BIGINT UNSIGNED)
    -&gt;        PARTITION BY RANGE(c1 - 10) (
    -&gt;        PARTITION p0 VALUES LESS THAN (-5),
    -&gt;        PARTITION p1 VALUES LESS THAN (0),
    -&gt;        PARTITION p2 VALUES LESS THAN (5),
    -&gt;        PARTITION p3 VALUES LESS THAN (10),
    -&gt;        PARTITION p4 VALUES LESS THAN (MAXVALUE));
<span>ERROR 1563 (HY000): Partition constant is out of
partition function domain</span>

mysql&gt; SET sql_mode='NO_UNSIGNED_SUBTRACTION';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT @@sql_mode;
+-------------------------+
| @@sql_mode              |
+-------------------------+
| NO_UNSIGNED_SUBTRACTION |
+-------------------------+
1 row in set (0.00 sec)

mysql&gt; CREATE TABLE tu (c1 BIGINT UNSIGNED) PARTITION BY RANGE(c1 - 10)
    -&gt;        (PARTITION p0 VALUES LESS THAN (-5),
    -&gt;         PARTITION p1 VALUES LESS THAN (0),
    -&gt;         PARTITION p2 VALUES LESS THAN (5),
    -&gt;         PARTITION p3 VALUES LESS THAN (10),
    -&gt;         PARTITION p4 VALUES LESS THAN (MAXVALUE));
Query OK, 0 rows affected (0.05 sec)
</pre>

<p>Если Вы удаляете режим SQL
<a href="server.htm#sqlmode_no_unsigned_subtraction"><code>
NO_UNSIGNED_SUBTRACTION</code></a> после создания <code>tu</code>, Вы больше
не в состоянии получить доступ к этой таблице:
<pre>
mysql&gt; SET sql_mode='';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT * FROM tu;
<span>ERROR 1563 (HY000): Partition constant is out of
partition function domain</span>

mysql&gt; INSERT INTO tu VALUES (20);
<span>ERROR 1563 (HY000): Partition constant is out of
partition function domain</span>
</pre></li></ol>

<p>Режимы SQL также воздействует на репликацию разделенных таблиц.
Несоизмеримые режимы SQL на ведущем и ведомом устройствах могут привести к
оценке по-другому выражений разделения, это может заставить распределение
данных среди разделения отличаться в копиях ведущего и ведомого устройств
данной таблицы, и может даже вызвать вставки в разделенные таблицы, которые
преуспевают на ведущем устройстве, чтобы потерпеть неудачу на ведомом. Для
лучших результатов Вы должны всегда использовать тот же самый режим SQL.</p>

<p><b>Исполнительные соображения. </b>Некоторые эффекты разделения операций
даны в следующем списке:</p>
<ul><li><p><a name="partitioning-limitations-file-system-ops"></a>
<b>Операции файловой системы. </b>Разделение и переразделение операций
(таких, как <a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE</code></a> с <code>PARTITION BY ...</code>,
<code>REORGANIZE PARTITIONS</code> или <code>REMOVE PARTITIONING</code>)
зависят от операций файловой системы для их выполнения. Это означает, что
скорость этих операций затронута такими факторами, как тип файловой системы и
характеристики, дисковая скорость, область подкачки, эффективность обработки
файла операционной системы, параметры сервера MySQL и переменные, которые
касаются обработки файла. В частности Вы должны удостовериться, что
<a href="server.htm#sysvar_large_files_support"><code>large_files_support
</code></a> включена, а <a href="server.htm#sysvar_open_files_limit"><code>
open_files_limit</code></a> установлена должным образом. Разделение и
переразделение таблиц <code>InnoDB</code> могут быть сделаны более
эффективными, включая <a href="innodb.htm#sysvar_innodb_file_per_table">
<code>innodb_file_per_table</code></a>.</li>

<li><b>Табличные блокировки. </b>Процесс, выполняющий работу разделения на
таблице, требует блокировку записи на таблице. Чтения таких таблиц не
затронуты, ожидающие запросы
<a href="sql.htm#insert"><code>INSERT</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>
выполнены, как только работа разделения завершилась.</li>

<li><b>Индексы, сокращение разделения. </b>Как с неразделенными таблицами,
правильное использование индексов может значительно ускорить запросы на
разделенных таблицах. Кроме того, разработка разделенных таблиц и запросов на
этих таблицах, чтобы использовать в своих интересах <span>сокращение
разделения</span> может резко улучшить работу. См.
<a href="#partitioning-pruning">раздел 20.4</a>.</li>

<li><b>Работа с LOAD DATA. </b>В MySQL 8.0 <a href="sql.htm#load-data"><code>
LOAD DATA</code></a> буферизация использована, чтобы улучшить работу. Вы
должны знать, что буфер использует память 130 КБ на раздел.</p></li></ul>

<p><a name="partitioning-limitations-max-partitions"></a>
<b>Максимальное количество разделов. </b>В MySQL 8.0 максимально возможное
число разделов для таблицы 8192. Это число включает подразделы.</p>

<p>Если, составляя таблицы с большим количеством разделов
(но меньше чем максимум), Вы сталкиваетесь с сообщением об ошибке
<span>Got error ... from storage engine: Out of resources
when opening file</span>, Вы можете решить проблему, увеличивая значение
переменной <a href="server.htm#sysvar_open_files_limit"><code>
open_files_limit</code></a>. Однако, это зависит от операционной системы, и
может быть невозможно или нежелательно на всех платформах, см.
<a href="error.htm#not-enough-file-handles">раздел B.5.2.17</a>. В некоторых
случаях использование большого количества (сотен) разделов, возможно, также
нежелательно из-за других проблем, так что использование большего количества
разделов автоматически не приводит к лучшим результатам.</p>

<p><b>Кэш запроса не поддержан. </b>Кэш запроса не поддержан для разделенных
таблиц, и автоматически отключен для запросов, вовлекающих разделенные
таблицы. Кэш запроса не может быть включен для таких запросов.</p>

<p><b>Внешние ключи не поддержаны для разделенных таблиц InnoDB. </b>
Разделенные таблицы, используя <a href="innodb.htm"><code>InnoDB</code></a>
не поддерживают внешние ключи. Более определенно это означает, что следующие
два утверждения верны:</p>

<ol type="1"><li><p>Никакое определение <code>InnoDB</code>-таблицы,
использующей определяемое пользователем разделение, не может содержать ссылки
внешнего ключа, таблица <code>InnoDB</code>, определение которой содержит
ссылки внешнего ключа, не может быть разделена.</li>

<li>Никакое определение <code>InnoDB</code>-таблицы, не может
содержать ссылку внешнего ключа на разделенную пользователем таблицу,
никакая <code>InnoDB</code>-таблица с определяемым пользователем разделением
не может содержать столбцы, на которые ссылаются внешние ключи.</p></li></ol>

<p>Контекст ограничений включает все таблицы, которые используют механизм
хранения <code>InnoDB</code>. <a href="sql.htm#create-table-foreign-keys">
<code>CREATE TABLE</code></a> и <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, которые привели бы к таблицам, нарушающим эти
ограничения, не позволены.</p>

<p><b>ALTER TABLE ... ORDER BY. </b>
<code>ALTER TABLE ... ORDER BY <em><code>column</code></em></code> для
разделенной таблицы вызывает упорядочивание строк только в
пределах каждого раздела.</p>

<p><b>Влияние на REPLACE с модификацией первичных ключей. </b>
Это может быть желательно в некоторых случаях (см.
<a href="#partitioning-limitations-partitioning-keys-unique-keys">
раздел 20.6.1</a>), чтобы изменить первичный ключ таблицы. Знайте, что если
Ваше приложение использует <a href="sql.htm#replace"><code>REPLACE</code></a>
и Вы делаете это, результаты этих запросов могут быть решительно изменены.
См. <a href="sql.htm#replace">раздел 14.2.8</a>.</p>

<p><b>Поддержка FULLTEXT. </b>Разделенные таблицы не поддерживают индексы
или поиски <code>FULLTEXT</code>.</p>
<p><b>Пространственные столбцы. </b>Столбцы с пространственными типами данных
(например, <code>POINT</code> или <code>GEOMETRY</code>)
не могут использоваться в разделенных таблицах.</p>

<p><b>Временные таблицы. </b>Временные таблицы не могут быть разделены.</p>
<p><b>Таблицы журнала. </b>Невозможно разделить таблицы журнала:
<a href="sql.htm#alter-table-partition-operations"><code>ALTER TABLE ...
PARTITION BY ...</code></a> на такой таблице терпит неудачу с ошибкой.</p>

<p><b>Тип данных разделения ключа. </b>Ключ разделения должен быть столбцом
целого числа или выражением, которое решается к целому числу. Использование
выражений, применяющих столбцы <a href="types.htm#enum"><code>ENUM</code></a>
недопустимо. Столбец или значение выражения могут также быть <code>NULL
</code>: см. <a href="#partitioning-handling-nulls">раздел 20.2.7
</a>.</p>

<p>Есть два исключения:</p>
<ol type="1"><li><p>Для [<code>LINEAR</code>] <code>KEY</code>
возможно использовать столбцы любого допустимого типа данных MySQL, кроме
<a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a> как разделение ключей, потому
что внутренние хеширующие ключ функции производят правильный тип данных из
этих типов. Например, следующие два <a href="sql.htm#create-table"><code>
CREATE TABLE</code></a> допустимы:
<pre>
CREATE TABLE tkc (c1 CHAR) PARTITION BY KEY(c1) PARTITIONS 4;
CREATE TABLE tke (c1 ENUM('red', 'orange', 'yellow', 'green',
                  'blue', 'indigo', 'violet'))
       PARTITION BY LINEAR KEY(c1) PARTITIONS 6;
</pre></li>

<li>Для <code>RANGE COLUMNS</code> или <code>LIST COLUMNS</code>
возможно использовать строку, <a href="types.htm#datetime"><code>DATE</code>
</a> и <a href="types.htm#datetime"><code>DATETIME</code></a>.
Например, каждый из следующих <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> допустим:
<pre>
CREATE TABLE rc (c1 INT, c2 DATE) PARTITION BY RANGE COLUMNS(c2) (
       PARTITION p0 VALUES LESS THAN('1990-01-01'),
       PARTITION p1 VALUES LESS THAN('1995-01-01'),
       PARTITION p2 VALUES LESS THAN('2000-01-01'),
       PARTITION p3 VALUES LESS THAN('2005-01-01'),
       PARTITION p4 VALUES LESS THAN(MAXVALUE));

CREATE TABLE lc (c1 INT, c2 CHAR(1)) PARTITION BY LIST COLUMNS(c2) (
       PARTITION p0 VALUES IN('a', 'd', 'g', 'j', 'm', 'p', 's', 'v', 'y'),
       PARTITION p1 VALUES IN('b', 'e', 'h', 'k', 'n', 'q', 't', 'w', 'z'),
       PARTITION p2 VALUES IN('c', 'f', 'i', 'l', 'o', 'r', 'u', 'x', NULL));
</pre></li></ol>

<p>Ни одно из предыдущих исключений не относится к столбцам типа
<a href="types.htm#blob"><code>BLOB</code></a> или
<a href="types.htm#blob"><code>TEXT</code></a>.</p>

<p><b>Подзапросы. </b>Ключ разделения не может быть подзапросом, даже если
этот подзапрос решается к целочисленному значению или <code>NULL</code>.</p>
<p><a name="partitioning-limitations-subpartitions"></a>
<b>Проблемы с подразделением. </b>Подразделение должно использовать
<code>HASH</code> или <code>KEY</code>. Только разделения
<code>RANGE</code> и <code>LIST</code> могут быть подразделены,
<code>HASH</code> и <code>KEY</code> не могут быть подразделены.</p>

<p><code>SUBPARTITION BY KEY</code> требует, чтобы столбец подразделения или
столбцы были определены явно, в отличие от случая с <code>PARTITION BY KEY
</code>, где это может быть опущено (когда столбец первичного ключа таблицы
используется по умолчанию). Считайте таблицу создаваемой этим запросом:
<pre>
CREATE TABLE ts (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                 name VARCHAR(30));
</pre>

<p>Вы можете составить таблицу, имеющую те же самые
столбцы, разделенные <code>KEY</code>:
<pre>
CREATE TABLE ts (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                 name VARCHAR(30))
       PARTITION BY KEY() PARTITIONS 4;
</pre>

<p>Предыдущий запрос обработан, как если бы он был написан как этот, со
столбцом первичного ключа таблицы, используемым в
качестве столбца разделения:
<pre>
CREATE TABLE ts (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                 name VARCHAR(30)) PARTITION BY
                 KEY(id) PARTITIONS 4;
</pre>

<p>Однако, следующий запрос, который пытается составить подразделенную
таблицу, используя столбец значения по умолчанию в качестве столбца
подразделения, терпит неудачу, столбец должен быть определен,
как показано здесь:
<pre>
mysql&gt; CREATE TABLE ts (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;                  name VARCHAR(30))
    -&gt;        PARTITION BY RANGE(id) SUBPARTITION BY KEY()
    -&gt;        SUBPARTITIONS 4 (PARTITION p0 VALUES LESS THAN (100),
    -&gt;                         PARTITION p1 VALUES LESS THAN (MAXVALUE));

<span>ERROR 1064 (42000): You have an error in your SQL syntax;
check the manual that corresponds to your MySQL server version for
the right syntax to use near ')</span>

mysql&gt; CREATE TABLE ts (id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
    -&gt;                  name VARCHAR(30)) PARTITION BY RANGE(id)
    -&gt;                  SUBPARTITION BY KEY(id)
    -&gt;        SUBPARTITIONS 4 (PARTITION p0 VALUES LESS THAN (100),
    -&gt;                         PARTITION p1 VALUES LESS THAN (MAXVALUE));
Query OK, 0 rows affected (0.07 sec)
</pre>
<p>Это известная проблема (см. Bug #51470).</p>

<p><b>Опции DATA DIRECTORY и INDEX DIRECTORY. </b>
Опции уровня таблицы <code>DATA DIRECTORY</code> и <code>INDEX DIRECTORY
</code> игнорируются (см. Bug #32091). Вы можете использовать эти опции для
отдельного разделения или подразделения таблиц
<a href="innodb.htm"><code>InnoDB</code></a>.</p>

<p><b>Восстановление разделенных таблиц. </b>
Запросы <a href="sql.htm#check-table"><code>CHECK TABLE</code></a>,
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a>,
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a> и
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>
поддержаны для разделенных таблиц.</p>

<p>Кроме того, Вы можете использовать <code>ALTER TABLE ... REBUILD PARTITION
</code>, чтобы восстановить один или более разделов разделенной таблицы.
<code>ALTER TABLE ... REORGANIZE PARTITION</code> также можно использовать.
См. <a href="sql.htm#alter-table">раздел 14.1.7</a>.</p>

<p><code>ANALYZE</code>, <code>CHECK</code>,
<code>OPTIMIZE</code>, <code>REPAIR</code> и <code>TRUNCATE</code>
поддержаны с подразделением. См.
<a href="sql.htm#alter-table-partition-operations">раздел 14.1.7.1</a>.</p>

<h3><a name="partitioning-limitations-partitioning-keys-unique-keys"></a>
20.6.1. Первичные и уникальные ключи</h3>
<p>Этот раздел обсуждает отношения ключей разделения с первичными и
уникальными ключами. Правило, управляющее этими отношениями, может быть
выражено следующим образом: все столбцы, используемые в выражении разделения
для разделенной таблицы, должны быть частью каждого уникального ключа,
который может иметь таблица.</p>

<p>Другими словами, <span><em>каждый уникальный ключ на таблице должен
использовать каждый столбец в выражении разделения таблицы</em></span>. Это
также включает первичный ключ таблицы, так как это по определению уникальный
ключ. Этот особый случай рассмотрен позже в этом разделе. Например, каждый из
следующих табличных запросов создания недопустим:
<pre>
CREATE TABLE t1 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, UNIQUE KEY (col1, col2))
                PARTITION BY HASH(col3) PARTITIONS 4;

CREATE TABLE t2 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, UNIQUE KEY (col1), UNIQUE KEY (col3))
                PARTITION BY HASH(col1 + col3) PARTITIONS 4;
</pre>

<p>В каждом случае у предложенной таблицы был бы по крайней мере один
уникальный ключ, который не включает все столбцы,
используемые в выражении разделения.</p>

<p>Каждый из следующих запросов допустим и представляет один путь, которым
соответствующий недопустимый табличный запрос создания мог быть сделан:
<pre>
CREATE TABLE t1 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, UNIQUE KEY (col1, col2, col3))
                PARTITION BY HASH(col3) PARTITIONS 4;

CREATE TABLE t2 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, UNIQUE KEY (col1, col3))
                PARTITION BY HASH(col1 + col3) PARTITIONS 4;
</pre>

<p>Этот пример показывает ошибку, произведенную в таких случаях:
<pre>
mysql&gt; CREATE TABLE t3 (col1 INT NOT NULL, col2 DATE NOT NULL,
    -&gt;                  col3 INT NOT NULL, col4 INT NOT NULL,
    -&gt;                  UNIQUE KEY (col1, col2), UNIQUE KEY (col3))
    -&gt;                 PARTITION BY HASH(col1 + col3) PARTITIONS 4;
<span>ERROR 1491 (HY000): A PRIMARY KEY must include all columns
in the table's partitioning function</span>
</pre>

<p><a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
терпит неудачу потому что оба столбца <code>col1</code> и <code>col3</code>
включены в предложенный ключ разделения, но ни один из этих столбцов не часть
обоих уникальных ключей таблицы. Это показывает одно возможное
затруднительное положение для недопустимого табличного определения:
<pre>
mysql&gt; CREATE TABLE t3 (col1 INT NOT NULL, col2 DATE NOT NULL,
    -&gt;                  col3 INT NOT NULL, col4 INT NOT NULL,
    -&gt;                  UNIQUE KEY (col1, col2, col3),
    -&gt;                  UNIQUE KEY (col3))
    -&gt;                 PARTITION BY HASH(col3) PARTITIONS 4;
Query OK, 0 rows affected (0.05 sec)
</pre>

<p>В этом случае предложенный ключ разделения <code>col3</code> часть
обоих уникальных ключей, и табличный запрос создания работает.</p>
<p>Следующая таблица не может быть разделена вообще, потому что нет никакого
способа включать в ключ разделения любые столбцы, которые принадлежат
обоим уникальным ключам:
<pre>
CREATE TABLE t4 (col1 INT NOT NULL, col2 INT NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, UNIQUE KEY (col1, col3),
                 UNIQUE KEY (col2, col4));
</pre>

<p>Так как каждый первичный ключ по определению уникальный, это ограничение
также включает первичный ключ таблицы, если он вообще есть. Например,
следующие два запроса недопустимы:
<pre>
CREATE TABLE t5 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, PRIMARY KEY(col1, col2))
                PARTITION BY HASH(col3) PARTITIONS 4;

CREATE TABLE t6 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, PRIMARY KEY(col1, col3),
                 UNIQUE KEY(col2))
                PARTITION BY HASH(YEAR(col2)) PARTITIONS 4;
</pre>

<p>В обоих случаях первичный ключ не включает все столбцы, на которые
ссылаются в выражение разделения.
Однако, оба следующие два запроса допустимы:
<pre>
CREATE TABLE t7 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, PRIMARY KEY(col1, col2))
                 PARTITION BY HASH(col1 + YEAR(col2)) PARTITIONS 4;

CREATE TABLE t8 (col1 INT NOT NULL, col2 DATE NOT NULL, col3 INT NOT NULL,
                 col4 INT NOT NULL, PRIMARY KEY(col1, col2, col4),
                 UNIQUE KEY(col2, col1))
                 PARTITION BY HASH(col1 + YEAR(col2)) PARTITIONS 4;
</pre>

<p>Если у таблицы нет никакого уникального ключа, это включает отсутствие
первичного ключа, тогда это ограничение не применяется, и Вы можете
использовать любой столбец или столбцы в выражении разделения, пока тип
столбца совместим с типом разделения.</p>

<p>По той же самой причине Вы не можете позже добавить уникальный ключ к
разделенной таблице, если ключ не включает все столбцы, используемые
выражением разделения таблицы. Считайте разделенную таблицу создаваемой
как показано здесь:
<pre>
mysql&gt; CREATE TABLE t_no_pk (c1 INT, c2 INT)
    -&gt;        PARTITION BY RANGE(c1) (PARTITION p0 VALUES LESS THAN (10),
    -&gt;                  PARTITION p1 VALUES LESS THAN (20),
    -&gt;                  PARTITION p2 VALUES LESS THAN (30),
    -&gt;                  PARTITION p3 VALUES LESS THAN (40));
Query OK, 0 rows affected (0.12 sec)
</pre>

<p>Возможно добавить первичный ключ к <code>t_no_pk</code>, используя
любой из запросов <a href="sql.htm#alter-table-partition-operations">
<code>ALTER TABLE</code></a>:
<pre>
#  possible PK
mysql&gt; ALTER TABLE t_no_pk ADD PRIMARY KEY(c1);
Query OK, 0 rows affected (0.13 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; ALTER TABLE t_no_pk DROP PRIMARY KEY;
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0

#  use another possible PK
mysql&gt; ALTER TABLE t_no_pk ADD PRIMARY KEY(c1, c2);
Query OK, 0 rows affected (0.12 sec)
Records: 0  Duplicates: 0  Warnings: 0

# drop this PK
mysql&gt; ALTER TABLE t_no_pk DROP PRIMARY KEY;
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre>

<p>Однако, следующий запрос терпит неудачу, потому что <code>c1</code>
часть ключа разделения, но не часть предложенного первичного ключа:
<pre>
#  fails with error 1503
mysql&gt; ALTER TABLE t_no_pk ADD PRIMARY KEY(c2);
<span>ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the
table's partitioning function</span>
</pre>

<p>С тех пор, как <code>t_no_pk</code> имеет только <code>c1</code>
в выражении разделения, попытки добавить уникальный ключ на
<code>c2</code> проваливаются. Однако, Вы можете добавить уникальный ключ,
который использует оба <code>c1</code> и <code>c2</code>.</p>

<p>Эти правила также относятся к существующим неразделенным таблицам, которые
Вы желаете разделить через <a href="sql.htm#alter-table-partition-operations">
<code>ALTER TABLE ... PARTITION BY</code></a>. Рассмотрите таблицу
<code>np_pk</code>, создаваемую как показано здесь:
<pre>
mysql&gt; CREATE TABLE np_pk (id INT NOT NULL AUTO_INCREMENT,
                              name VARCHAR(50), added DATE,
                              PRIMARY KEY (id));
Query OK, 0 rows affected (0.08 sec)
</pre>

<p>Следующий <a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE</code></a> терпит неудачу с ошибкой, потому что столбец
<code>added</code> не часть любого уникального ключа в таблице:
<pre>
mysql&gt; ALTER TABLE np_pk PARTITION BY HASH(TO_DAYS(added)) PARTITIONS 4;
<span>ERROR 1503 (HY000): A PRIMARY KEY must include all columns in the
table's partitioning function</span>
</pre>

<p>Однако, этот запрос, использующий столбец <code>id</code> для столбца
разделения допустим, как показано здесь:
<pre>
mysql&gt; ALTER TABLE np_pk PARTITION BY HASH(id) PARTITIONS 4;
Query OK, 0 rows affected (0.11 sec)
Records: 0  Duplicates: 0  Warnings: 0
</pre>

<p>В случае <code>np_pk</code> единственный столбец, который может
использоваться в качестве части выражения разделения, <code>id</code>. Если
Вы хотите разделить эту таблицу, используя какой-либо другой столбец (или
столбцы) в выражении разделения, Вы должны сначала изменить таблицу, добавляя
желаемый столбец или столбцы к первичному ключу, или удаляя
первичный ключ в целом.</p>

<h3><a name="partitioning-limitations-storage-engines"></a>20.6.2.
Ограничения, касающиеся механизмов хранения</h3>
<p>В MySQL 8.0 поддержка разделов фактически обеспечена не сервером MySQL, а
собственным обработчиком разделения механизма хранения таблицы. В MySQL 8.0
только <a href="innodb.htm"><code>InnoDB</code></a> обеспечивает обработчик
разделения. Это означает, что разделенные таблицы не могут быть составлены,
используя любой другой механизм хранения.</p>

<p>MySQL Cluster <code>NDB</code> также оказывает поддержку разделения, но в
настоящее время не поддерживается в MySQL 8.0.</p>
<p><a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... OPTIMIZE PARTITION</code></a> не работает правильно с разделенными
таблицами, которые применяют <code>InnoDB</code>. Примените
<code>ALTER TABLE ... REBUILD PARTITION</code> и
<code>ALTER TABLE ... ANALYZE PARTITION</code>. См.
<a href="sql.htm#alter-table-partition-operations">раздел 14.1.7.1</a>.</p>

<p><b>Обновление разделенных таблиц. </b>Выполняя обновление, таблицы,
которые разделены <code>KEY</code> должны быть выведены и перезагружены.
Разделенные таблицы, использующие механизмы хранения, кроме
<code>InnoDB</code>, не могут быть обновлены от MySQL 5.7 или ранее к MySQL
8.0: Вы должны или исключить разделение из таких таблиц с <code>ALTER TABLE
... REMOVE PARTITIONING</code> или преобразовать их в <code>InnoDB</code>
через <code>ALTER TABLE ... ENGINE=INNODB</code> до обновления.</p>

<h3><a name="partitioning-limitations-functions"></a>20.6.3.
Ограничения, касающиеся функций</h3>
<p>Этот раздел обсуждает ограничения в разделении MySQL, имеющие
отношение определенно к функциям, используемым в разделении выражений.</p>
<p>Только функции MySQL, показанные в следующей таблице,
позволены в разделении выражений.</p>

<table border="1">
<tbody><tr><td scope="row"><a href="funct.htm#function_abs"><code>ABS()
</code></a></td><td><a href="funct.htm#function_ceiling"><code>CEILING()
</code></a> (см. <a href="#partitioning-limitations-ceiling-floor">
CEILING() and FLOOR()</a>)</td><td><a href="funct.htm#function_day"><code>
DAY()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_dayofmonth"><code>
DAYOFMONTH()</code></a></td><td><a href="funct.htm#function_dayofweek">
<code>DAYOFWEEK()</code></a></td><td><a href="funct.htm#function_dayofyear">
<code>DAYOFYEAR()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_datediff"><code>DATEDIFF()
</code></a></td><td><a href="funct.htm#function_extract"><code>EXTRACT()
</code></a> (см. <a href="#partitioning-limitations-extract">
EXTRACT() function with WEEK specifier</a>)</td><td>
<a href="funct.htm#function_floor"><code>FLOOR()</code></a> (см.
<a href="#partitioning-limitations-ceiling-floor">CEILING() и
FLOOR()</a>)</td></tr>
<tr><td scope="row"><a href="funct.htm#function_hour"><code>HOUR()</code></a>
</td><td><a href="funct.htm#function_microsecond"><code>MICROSECOND()</code>
</a></td><td><a href="funct.htm#function_minute"><code>MINUTE()</code></a>
</td></tr>
<tr><td scope="row"><a href="funct.htm#function_mod"><code>MOD()</code></a>
</td><td><a href="funct.htm#function_month"><code>MONTH()</code></a></td>
<td><a href="funct.htm#function_quarter"><code>QUARTER()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_second"><code>SECOND()</code>
</a></td><td><a href="funct.htm#function_time-to-sec"><code>TIME_TO_SEC()
</code></a></td><td><a href="funct.htm#function_to-days"><code>TO_DAYS()
</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_to-seconds"><code>
TO_SECONDS()</code></a></td><td><a href="funct.htm#function_unix-timestamp">
<code>UNIX_TIMESTAMP()</code></a> (со столбцами
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>)</td>
<td><a href="funct.htm#function_weekday"><code>WEEKDAY()</code></a></td></tr>
<tr><td scope="row"><a href="funct.htm#function_year"><code>YEAR()</code></a>
</td><td> </td><td><a href="funct.htm#function_yearweek"><code>YEARWEEK()
</code></a></td></tr></tbody></table>

<p>В MySQL 8.0 сокращение разделения поддержано для функций
the <a href="funct.htm#function_to-days"><code>TO_DAYS()</code></a>,
<a href="funct.htm#function_to-seconds"><code>TO_SECONDS()</code></a>,
<a href="funct.htm#function_year"><code>YEAR()</code></a> и
<a href="funct.htm#function_unix-timestamp"><code>UNIX_TIMESTAMP()</code>
</a>. См. <a href="#partitioning-pruning">раздел 20.4</a>.</p>

<p><a name="partitioning-limitations-ceiling-floor"></a><b>CEILING() и
FLOOR(). </b>Каждая из этих функций возвращает целое число, только если ей
передают параметр точного числового типа, такого как один из типов
<a href="types.htm#integer-types"><code>INT</code></a> или
<a href="types.htm#fixed-point-types"><code>DECIMAL</code></a>.
Это означает, например, что следующий запрос <a href="sql.htm#create-table">
<code>CREATE TABLE</code></a> терпит неудачу с ошибкой, как показано здесь:
<pre>
mysql&gt; CREATE TABLE t (c FLOAT) PARTITION BY LIST(FLOOR(c))(
    -&gt;        PARTITION p0 VALUES IN (1,3,5),
    -&gt;        PARTITION p1 VALUES IN (2,4,6));
<span>ERROR 1490 (HY000): The PARTITION function returns the wrong type</span>
</pre>

<p><a name="partitioning-limitations-extract"></a>
<b>Функция EXTRACT() с опцией WEEK. </b>Значение, возвращенное функцией
<a href="funct.htm#function_extract"><code>EXTRACT()</code></a>,
когда используется как <a href="funct.htm#function_extract"><code>
EXTRACT(WEEK FROM <em><code>col</code></em>)</code></a>, зависит от значения
системной переменной <a href="server.htm#sysvar_default_week_format"><code>
default_week_format</code></a>. Поэтому
<a href="funct.htm#function_extract"><code>EXTRACT()</code></a>
не разрешена как функция разделения, когда это определяет модуль как
<code>WEEK</code> (Bug #54483).</p>

<p>См. <a href="funct.htm#mathematical-functions">раздел 13.6.2</a>
для получения дополнительной информации о типах возвращения этих функций, так
же как <a href="types.htm#numeric-types">раздел 12.2</a>.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
