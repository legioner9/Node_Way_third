<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 23. MySQL Performance Schema</title>
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="performance-schema"></a>Глава 23. MySQL Performance Schema</h1>
<p>MySQL Performance Schema особенность контроля выполнения MySQL Server
на низком уровне. У Performance Schema есть эти характеристики:</p>

<ul><li><p>Performance Schema обеспечивает способ осмотреть внутреннее
выполнение сервера во времени выполнения. Это осуществлено, используя
механизм хранения <a href="perfor.htm"><code>PERFORMANCE_SCHEMA</code></a> и
базу данных <code>performance_schema</code>. Performance Schema
сосредотачивается прежде всего на характеристиках. Это отличается от
<code>INFORMATION_SCHEMA</code>, которая служит для просмотра метаданных.
</li>

<li>Performance Schema следит за развитием событий сервера.
<span>Событие</span> является чем-либо, что сервер делает, что
занимает время и было инструментовано так, чтобы информация синхронизации
могла быть собрана. Вообще, случаем мог быть вызов функции, ожидание
операционной системы, этапа выполнения запроса SQL, такого как парсинг или
сортировка, всего запроса или группы запросов. Набор событий обеспечивает
доступ к информации о требованиях синхронизации файла и табличного
ввода/вывода, табличные блокировки и т.д. для сервера и для
нескольких механизмов хранения.</li>

<li>События Performance Schema отличны от событий, записанных в двоичный
журнал сервера (которые описывают модификации данных) и событий Event
Scheduler (которые являются типом сохраненной программы).</li>

<li>События Performance Schema являются определенными для приведенного
примера MySQL Server. Таблицы Performance Schema считаются локальными для
сервера, и изменения в них не копируются в двоичный журнал.</li>

<li>Текущие события доступны, так же как истории событий и резюме.
Это позволяет Вам определить, сколько инструментованных действий было
выполнено и сколько времени они заняли. Информация о событии доступна, чтобы
показать действия определенных потоков или деятельность, связанную с особыми
объектами, такими как mutex или файл.</li>

<li>Механизм хранения <a href="perfor.htm"><code>PERFORMANCE_SCHEMA</code>
</a> собирает данные событий, используя <span>точки инструментовки</span>
в исходном коде сервера.</li>

<li>Собранные события сохранены в таблицах в базе данных
<code>performance_schema</code>. Эти таблицы могут быть запрошены, используя
<a href="sql.htm#select"><code>SELECT</code></a> как другие таблицы.</li>

<li>Конфигурация Performance Schema может быть изменена динамически, обновляя
таблицы в базе данных <code>performance_schema</code>
через запросы SQL. Конфигурация немедленно изменяет сбор данных.</li>

<li>Таблицы в базе данных <code>performance_schema</code> это
представления или временные таблицы, которые не используют постоянного
хранения на диске.</li>

<li>Контроль доступен на всех платформах, поддержанных MySQL.</p>
<p>Некоторые ограничения могут применяться: типы таймеров могут изменяться
для платформы. Инструменты, которые относятся к механизмам хранения, не могут
быть осуществлены для всех механизмов хранения. Инструментовка каждого
имеющего отношение к третьей стороне механизма ответственность автора
механизма. См. также
<a href="restr.htm#performance-schema-restrictions">раздел C.8</a>.</li>

<li>Сбор данных осуществлен, изменяя исходный код сервера, чтобы добавить
инструментовку. Нет никаких отдельных потоков, связанных с Performance
Schema, в отличие от других особенностей, таких как репликация
или Event Scheduler.</p></li></ul>

<p>Performance Schema предназначена, чтобы обеспечить доступ к полезной
информации о выполнении сервера, оказывая минимальное влияние на работу
сервера. Выполнение следует за этими целями проекта:</p>

<ul><li><p>Активирование Performance Schema не вызывает изменений в поведении
сервера. Например, это не вызывает поток, намечающий измениться, и это не
меняет план выполнения запроса (как показано
<a href="sql.htm#explain"><code>EXPLAIN</code></a>).</li>

<li>Контроль сервера происходит непрерывно и незаметно с очень малыми
издержками. Активирование Performance Schema
не делает сервер непригодным.</li>

<li>Анализатор неизменен. Нет никаких новых ключевых слов или запросов.</li>
<li>Выполнение сервера обычно работает нормально, даже если
Performance Schema терпит неудачу внутренне.</li>

<li>Когда есть выбор между выполнением обработки во время набора событий
первоначально или во время извлечения событий позже, приоритет дан созданию
набора быстрее. Это потому, что набор является процессом, тогда как
извлечение происходит по требованию и могло бы не происходить вообще.</li>

<li>Большинство таблиц Performance Schema имеет индекс, который предоставляет
доступ к планам выполнения, кроме полного сканирования таблицы. Для получения
дополнительной информации см.
<a href="optimiz.htm#performance-schema-optimization">раздел 9.2.5</a>.</li>
<li>Легко добавить новые пункты инструментовки.</li>

<li>Если выполнение инструментовки изменится, то ранее инструментованный код
продолжит работать. Это приносит пользу разработчикам, имеющим отношение к
плагинам, потому что не надо обновлять каждый плагин, чтобы остаться
синхронизированным с последними изменениями Performance Schema.</p></li></ul>

<p>MySQL <code>sys</code> schema ряд объектов, который обеспечивает удобный
доступ к данным, собранным Performance Schema. <code>sys</code> schema
установлена по умолчанию. Для инструкций см. <a href="sys.htm">раздел 24</a>.
</p>

<h2><a name="performance-schema-quick-start"></a>23.1.
Быстрый запуск Performance Schema</h2>
<p>Этот раздел кратко начинает Performance Schema с примеров, которые
показывают, как использовать это. Для дополнительных примеров см.
<a href="#performance-schema-examples">раздел 23.16</a>.</p>

<p>Чтобы Performance Schema была доступна, она должна быть сконфигурирована,
когда MySQL был создан. Вы можете проверить обстоит ли дело так, проверяя
вывод сервера. Если Performance Schema доступна, то вывод упомянет несколько
переменных с именами, которые начинаются с <code>performance_schema</code>:
<pre>
shell&gt; mysqld --verbose --help
...
  --performance_schema
Enable the performance schema.
  --performance_schema_events_waits_history_long_size=#
Number of rows in events_waits_history_long.
...
</pre>

<p>Если такие переменные не появляются в выводе, Ваш сервер не был создан,
чтобы поддерживать Performance Schema. В этом случае см.
<a href="#performance-schema-configuration">раздел 23.2</a>.</p>

<p>Предполагая, что Performance Schema доступна, она включена по умолчанию.
Чтобы включить или отключить это явно, запустите сервер с соответствующим
значением переменной <a href="#sysvar_performance_schema"><code>
performance_schema</code></a>. Например, используйте эти строки в Вашем
файле <code>my.cnf</code>:
<pre>
[mysqld]
performance_schema=ON
</pre>

<p>Когда сервер запускается, он видит
<a href="#sysvar_performance_schema"><code>performance_schema
</code></a> и попытается инициализировать Performance Schema.
Чтобы проверить успешную инициализацию, используйте этот запрос:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'performance_schema';
+--------------------+-------+
| Variable_name      | Value |
+--------------------+-------+
| performance_schema | ON    |
+--------------------+-------+
</pre>

<p>Значение <code>ON</code> указывает, что Performance Schema
инициализированная успешно и готова к употреблению. Значение <code>OFF</code>
указывает, что некоторая ошибка произошла. Проверьте журнал ошибок сервера на
информацию о том, что пошло не так, как надо.</p>

<p>Performance Schema осуществлена как механизм хранения. Если этот механизм
доступен (это Вы должны были уже проверить ранее), Вы должны видеть, что он
перечислен со значением <code>YES</code> столбца <code>SUPPORT</code> таблицы
<a href="inform.htm#engines-table"><code>INFORMATION_SCHEMA.ENGINES</code>
</a> или вывода <a href="sql.htm#show-engines"><code>SHOW ENGINES</code></a>:
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.ENGINES
                   WHERE ENGINE='PERFORMANCE_SCHEMA'\G
*************************** 1. row ***************************
ENGINE: PERFORMANCE_SCHEMA
 SUPPORT: YES
 COMMENT: Performance Schema
TRANSACTIONS: NO
XA: NO
  SAVEPOINTS: NO

mysql&gt; SHOW ENGINES\G
...
Engine: PERFORMANCE_SCHEMA
 Support: YES
 Comment: Performance Schema
Transactions: NO
XA: NO
  Savepoints: NO
...
</pre>

<p>Механизм хранения <a href="perfor.htm"><code>PERFORMANCE_SCHEMA</code></a>
воздействует на таблицы в базе данных <code>performance_schema</code>.
Вы можете сделать базу данных <code>performance_schema</code> базой данных по
умолчанию так, чтобы ссылки на ее таблицы не были квалифицированы с
именем базы данных:
<pre>
mysql&gt; USE performance_schema;
</pre>

<p>Много примеров в этой главе принимают <code>performance_schema</code>
как базу данных по умолчанию.</p>
<p>Таблицы Performance Schema сохранены в базе данных
<code>performance_schema</code>. Информация о структуре этой базы данных и ее
таблиц может быть получена как для любой другой базы данных, выбирая из
<code>INFORMATION_SCHEMA</code> или при использовании
<a href="sql.htm#show"><code>SHOW</code></a>. Например, используйте любой из
этих запросов, чтобы видеть, какие таблицы Performance Schema существуют:
<pre>
mysql&gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
                 WHERE TABLE_SCHEMA = 'performance_schema';
+------------------------------------------------+
| TABLE_NAME                                     |
+------------------------------------------------+
| accounts                                       |
| cond_instances                                 |
...
| events_stages_current                          |
| events_stages_history                          |
| events_stages_history_long                     |
| events_stages_summary_by_account_by_event_name |
| events_stages_summary_by_host_by_event_name    |
| events_stages_summary_by_thread_by_event_name  |
| events_stages_summary_by_user_by_event_name    |
| events_stages_summary_global_by_event_name     |
| events_statements_current                      |
| events_statements_history                      |
| events_statements_history_long                 |
...
| file_instances                                 |
| file_summary_by_event_name                     |
| file_summary_by_instance                       |
| host_cache                                     |
| hosts                                          |
| memory_summary_by_account_by_event_name        |
| memory_summary_by_host_by_event_name           |
| memory_summary_by_thread_by_event_name         |
| memory_summary_by_user_by_event_name           |
| memory_summary_global_by_event_name            |
| metadata_locks                                 |
| mutex_instances                                |
| objects_summary_global_by_type                 |
| performance_timers                             |
| replication_connection_configuration           |
| replication_connection_status                  |
| replication_applier_configuration              |
| replication_applier_status                     |
| replication_applier_status_by_coordinator      |
| replication_applier_status_by_worker           |
| rwlock_instances                               |
| session_account_connect_attrs                  |
| session_connect_attrs                          |
| setup_actors                                   |
| setup_consumers                                |
| setup_instruments                              |
| setup_objects                                  |
| setup_timers                                   |
| socket_instances                               |
| socket_summary_by_event_name                   |
| socket_summary_by_instance                     |
| table_handles                                  |
| table_io_waits_summary_by_index_usage          |
| table_io_waits_summary_by_table                |
| table_lock_waits_summary_by_table              |
| threads                                        |
| users                                          |
+------------------------------------------------+

mysql&gt; SHOW TABLES FROM performance_schema;
+------------------------------------------------------+
| Tables_in_performance_schema |
+------------------------------------------------------+
| accounts   |
| cond_instances   |
| events_stages_current  |
| events_stages_history  |
| events_stages_history_long   |
...
</pre>

<p>Число таблиц Performance Schema увеличится в течение долгого времени как
выполнение дополнительных инструментов.</p>
<p>Название базы данных <code>performance_schema</code> в нижнем регистре,
как и названия таблиц в ее пределах. Запросы должны определить
имена в нижнем регистре.</p>

<p>Чтобы видеть структуру отдельных таблиц, надо использовать
<code>SHOW CREATE TABLE</code>:
<pre>
mysql&gt; SHOW CREATE TABLE setup_timers\G
*************************** 1. row ***************************
 Table: setup_timers
Create Table: CREATE TABLE `setup_timers` (
  `NAME` varchar(64) NOT NULL,
  `TIMER_NAME` enum('CYCLE','NANOSECOND','MICROSECOND','MILLISECOND','TICK')
   NOT NULL) ENGINE=PERFORMANCE_SCHEMA DEFAULT CHARSET=utf8
</pre>

<p>Структура таблицы также доступна, выбирая из таких таблиц, как
<a href="inform.htm#columns-table"><code>INFORMATION_SCHEMA.COLUMNS</code>
</a> или при использовании запросов <code>SHOW COLUMNS</code>.</p>

<p>Таблицы в <code>performance_schema</code> могут быть сгруппированы
согласно типу информации в них: текущие события, истории событий и резюме,
экземпляры объектов и информацию конфигурации. Следующие примеры иллюстрируют
несколько вариантов использования для этих таблиц. Для получения дальнейшей
информации о таблицах в каждой группе см.
<a href="#performance-schema-table-descriptions">раздел 23.9</a>.
</p>

<p>Первоначально, не все инструменты и потребители включены, таким образом,
performance schema не собирает все события. Чтобы включить всех их и включить
синхронизацию событий, выполните два запроса (количество строк может
отличаться в зависимости от версии MySQL):
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'YES', TIMED = 'YES';
Query OK, 560 rows affected (0.04 sec)
mysql&gt; UPDATE setup_consumers SET ENABLED = 'YES';
Query OK, 10 rows affected (0.00 sec)
</pre>

<p>Чтобы видеть, что сервер делает в настоящее время, исследуйте таблицу
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>. Это содержит одну строку на поток, показывая новое следившее за
развитием событие каждого потока:
<pre>
mysql&gt; SELECT * FROM events_waits_current\G
*************************** 1. row ***************************
THREAD_ID: 0
 EVENT_ID: 5523
 EVENT_NAME: wait/synch/mutex/mysys/THR_LOCK::mutex
   SOURCE: thr_lock.c:525
TIMER_START: 201660494489586
TIMER_END: 201660494576112
 TIMER_WAIT: 86526
SPINS: NULL
  OBJECT_SCHEMA: NULL
OBJECT_NAME: NULL
OBJECT_TYPE: NULL
OBJECT_INSTANCE_BEGIN: 142270668
 NESTING_EVENT_ID: NULL
OPERATION: lock
NUMBER_OF_BYTES: NULL
FLAGS: 0
...
</pre>

<p>Этот случай указывает, что поток 0 ждал 86526 пикосекунд, чтобы приобрести
блокировку на <code>THR_LOCK::mutex</code>, mutex в подсистеме
<code>mysys</code>. Первые несколько столбцов
предоставляют следующую информацию:</p>

<ul><li><p>ID столбца указывают, какой поток прибывает и число событий.</li>
<li><code>EVENT_NAME</code> указывает на то, что было инструментовано и
<code>SOURCE</code> указывает, какой исходный файл
содержит инструментованный код.</li>

<li>Столбцы таймера показывают, когда случай запустился и остановился
и сколько времени это заняло. Если случай все еще происходит,
<code>TIMER_END</code> и <code>TIMER_WAIT</code> <code>NULL</code>.
Значения таймера приблизительны и выражены в пикосекундах. Для информации о
таймерах и времени событий см.
<a href="#performance-schema-timing">раздел 23.2.3.1</a>.
</p></li></ul>

<p>Таблицы истории содержат тот же самый вид строк как таблица текущих
событий, но имеют больше строк и показывают то, что сервер делал. Таблицы
<a href="#events-waits-history-table"><code>events_waits_history
</code></a> и <a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a> содержат самые свежие 10 событий на
поток и новые 10000 событий, соответственно. Например, чтобы увидеть
информацию для недавних событий, произведенных потоком 13, сделайте это:
<pre>
mysql&gt; SELECT EVENT_ID, EVENT_NAME, TIMER_WAIT
                 FROM events_waits_history WHERE THREAD_ID = 13
                 ORDER BY EVENT_ID;
+----------+-----------------------------------------+------------+
| EVENT_ID | EVENT_NAME                              | TIMER_WAIT |
+----------+-----------------------------------------+------------+
| 86       | wait/synch/mutex/mysys/THR_LOCK::mutex  | 686322     |
| 87       | wait/synch/mutex/mysys/THR_LOCK_malloc  | 320535     |
| 88       | wait/synch/mutex/mysys/THR_LOCK_malloc  | 339390     |
| 89       | wait/synch/mutex/mysys/THR_LOCK_malloc  | 377100     |
| 90       | wait/synch/mutex/sql/LOCK_plugin        | 614673     |
| 91       | wait/synch/mutex/sql/LOCK_open          | 659925     |
| 92       | wait/synch/mutex/sql/THD::LOCK_thd_data | 494001     |
| 93       | wait/synch/mutex/mysys/THR_LOCK_malloc  | 222489     |
| 94       | wait/synch/mutex/mysys/THR_LOCK_malloc  | 214947     |
| 95       | wait/synch/mutex/mysys/LOCK_alarm       | 312993     |
+----------+-----------------------------------------+------------+
</pre>

<p>Поскольку новые события добавлены к таблице истории, от более старых
событий отказываются, если таблица полна.</p>
<p>Сводные таблицы предоставляют соединенную информацию для всех событий в
течение долгого времени. Таблицы в этой группе суммируют данные событий
по-разному. Чтобы видеть, какие инструменты были запущены большинство раз или
заняли больше времени, сортируют таблицу
<a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a> по столбцу
<code>COUNT_STAR</code> или <code>SUM_TIMER_WAIT</code>, которые
соответствуют <code>COUNT(*)</code> или <code>SUM(TIMER_WAIT)</code>,
соответственно, вычисленным по всем событиям:
<pre>
mysql&gt; SELECT EVENT_NAME, COUNT_STAR
                 FROM events_waits_summary_global_by_event_name
                 ORDER BY COUNT_STAR DESC LIMIT 10;
+---------------------------------------------------+------------+
| EVENT_NAME                                        | COUNT_STAR |
+---------------------------------------------------+------------+
| wait/synch/mutex/mysys/THR_LOCK_malloc            | 6419       |
| wait/io/file/sql/FRM                              |  452       |
| wait/synch/mutex/sql/LOCK_plugin                  |  337       |
| wait/synch/mutex/mysys/THR_LOCK_open              |  187       |
| wait/synch/mutex/mysys/LOCK_alarm                 |  147       |
| wait/synch/mutex/sql/THD::LOCK_thd_data           |  115       |
| wait/io/file/myisam/kfile                         |  102       |
| wait/synch/mutex/sql/LOCK_global_system_variables |   89       |
| wait/synch/mutex/mysys/THR_LOCK::mutex            |   89       |
| wait/synch/mutex/sql/LOCK_open                    |   88       |
+---------------------------------------------------+------------+

mysql&gt; SELECT EVENT_NAME, SUM_TIMER_WAIT
                 FROM events_waits_summary_global_by_event_name
                 ORDER BY SUM_TIMER_WAIT DESC LIMIT 10;
+----------------------------------------+----------------+
| EVENT_NAME                             | SUM_TIMER_WAIT |
+----------------------------------------+----------------+
| wait/io/file/sql/MYSQL_LOG             | 1599816582     |
| wait/synch/mutex/mysys/THR_LOCK_malloc | 1530083250     |
| wait/io/file/sql/binlog_index          | 1385291934     |
| wait/io/file/sql/FRM                   | 1292823243     |
| wait/io/file/myisam/kfile              |  411193611     |
| wait/io/file/myisam/dfile              |  322401645     |
| wait/synch/mutex/mysys/LOCK_alarm      |  145126935     |
| wait/io/file/sql/casetest              |  104324715     |
| wait/synch/mutex/sql/LOCK_plugin       |   86027823     |
| wait/io/file/sql/pid                   |   72591750     |
+----------------------------------------+----------------+
</pre>

<p>Эти результаты показывают, что <code>THR_LOCK_malloc</code>
востребована с точки зрения того, как часто используется и количества
времени, которое потоки ждут, пытаясь приобрести это.</p>
<p><code>THR_LOCK_malloc</code> mutex используется только в отладке.</p>

<p>Таблицы документируют, какие типы объектов инструментованы.
Инструментованный объект, когда используется сервером, производит случай. Эти
таблицы обеспечивают имена событий и примечания или информацию о статусе.
Например, таблица <a href="#file-instances-table"><code>
file_instances</code></a> приводит случаи инструментов для операций
ввода/вывода файла и их связанных файлов:
<pre>
mysql&gt; SELECT * FROM file_instances\G
*************************** 1. row ***************************
 FILE_NAME: /opt/mysql-log/60500/binlog.000007
EVENT_NAME: wait/io/file/sql/binlog
OPEN_COUNT: 0
*************************** 2. row ***************************
 FILE_NAME: /opt/mysql/60500/data/mysql/tables_priv.MYI
EVENT_NAME: wait/io/file/myisam/kfile
OPEN_COUNT: 1
*************************** 3. row ***************************
 FILE_NAME: /opt/mysql/60500/data/mysql/columns_priv.MYI
EVENT_NAME: wait/io/file/myisam/kfile
OPEN_COUNT: 1
...
</pre>

<p>Таблицы установки используются, чтобы сконфигурировать и вывести на экран
контролирующие характеристики. Например, чтобы видеть, какие таймеры
событий выбраны, запросите таблицы <a href="#setup-timers-table">
<code>setup_timers</code></a>:
<pre>
mysql&gt; SELECT * FROM setup_timers;
+-------------+-------------+
| NAME        | TIMER_NAME  |
+-------------+-------------+
| idle        | MICROSECOND |
| wait        | CYCLE       |
| stage       | NANOSECOND  |
| statement   | NANOSECOND  |
| transaction | NANOSECOND  |
+-------------+-------------+
</pre>

<p><a href="#setup-instruments-table"><code>setup_instruments
</code></a> перечисляет набор инструментов, для которых события могут быть
собраны и показывает, которые из них включены:
<pre>
mysql&gt; SELECT * FROM setup_instruments;
+---------------------------------------------------+---------+-------+
| NAME                                              | ENABLED | TIMED |
+---------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock        | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                 | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                  | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger         | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect       | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave         | YES     | YES   |
...
| wait/io/file/sql/binlog                           | YES     | YES   |
| wait/io/file/sql/binlog_index                     | YES     | YES   |
| wait/io/file/sql/casetest                         | YES     | YES   |
| wait/io/file/sql/dbopt                            | YES     | YES   |
...
</pre>

<p>Чтобы понять, как интерпретировать инструментальные имена см.
<a href="#performance-schema-instrument-naming">раздел 23.4</a>.
</p>

<p>Чтобы управлять тем, собраны ли события для инструмента, устанавливайте
значение <code>ENABLED</code> в <code>YES</code> или <code>NO</code>:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'NO'
                 WHERE NAME = 'wait/synch/mutex/sql/LOCK_mysql_create_db';
</pre>

<p>Performance Schema использует собранные события, чтобы обновить таблицы в
<code>performance_schema</code>, которые действуют как
<span>потребители</span> информации о событии. Таблица
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
приводит доступных потребителей и которые включены:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            |  NO     |
| events_stages_history            |  NO     |
| events_stages_history_long       |  NO     |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   |  NO     |
| events_transactions_current      |  NO     |
| events_transactions_history      |  NO     |
| events_transactions_history_long |  NO     |
| events_waits_current             |  NO     |
| events_waits_history             |  NO     |
| events_waits_history_long        |  NO     |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
</pre>

<p>Чтобы управлять тем, поддерживает ли Performance Schema как место
назначения для информации о событии, устанавливайте <code>ENABLED</code>.</p>
<p>Для получения дополнительной информации о таблицах установки и как
использовать их, чтобы управлять набором событий см.
<a href="#performance-schema-filtering">раздел 23.2.3.2</a>.</p>

<p>Есть некоторые разные таблицы, которые не попадают ни в одну из
предыдущих групп. Например,
<a href="#performance-timers-table"><code>performance_timers</code>
</a> перечисляет доступные таймеры событий и их характеристики. Для
информации о таймерах см. <a href="#performance-schema-timing">
раздел 23.2.3.1</a>.</p>

<h2><a name="performance-schema-configuration"></a>23.2.
Конфигурация Performance Schema</h2>
<p>Чтобы использовать MySQL Performance Schema,
эти соображения конфигурации применяются:</p>

<ul><li><p>Performance Schema должна быть сконфигурирована в ходе сборки
MySQL Server, чтобы она была доступна. Performance Schema включена в двоичные
дистрибутивы MySQL. Если Вы создаете пакет из исходных текстов, Вы должны
гарантировать, что он сконфигурирован как описано в
<a href="#performance-schema-build-configuration">разделе 23.2.1
</a>.</li>

<li>Performance Schema должна быть позволена при запуске сервера, чтобы
позволить набору событий произойти. Опции Performance Schema могут быть
активированы при запуске сервера или во времея выполнения, чтобы управлять,
какие типы событий происходят. См. разделы
<a href="#performance-schema-startup-configuration">23.2.2</a>,
<a href="#performance-schema-runtime-configuration">23.2.3</a> и
<a href="#performance-schema-filtering">23.2.3.2</a>.</p></li></ul>

<h3><a name="performance-schema-build-configuration"></a>23.2.1.
Создание конфигурации Performance Schema</h3>
<p>Если Вы создаете MySQL из исходных текстов, включите
Performance Schema запуском <span><strong>CMake</strong></span> с опцией
<a href="install.htm#option_cmake_storage_engine_options"><code>
WITH_PERFSCHEMA_STORAGE_ENGINE</code></a>:
<pre>
shell&gt; cmake . -DWITH_PERFSCHEMA_STORAGE_ENGINE=1
</pre>

<p>Конфигурирование MySQL с опцией
<a href="install.htm#option_cmake_storage_engine_options">
<code>-DWITHOUT_PERFSCHEMA_STORAGE_ENGINE=1</code></a> запрещает включение
Performance Schema, так что, если Вы хотите включить, не используйте эту
опцию. См. <a href="install.htm#source-configuration-options">раздел 2.8.4
</a>.</p>

<p>Также возможно включить Performance Schema, но исключить определенные
части инструментовки. Например, чтобы включить Performance Schema, но
исключить инструментовку этапов и запросов, сделайте это:
<pre>
shell&gt; cmake . -DWITH_PERFSCHEMA_STORAGE_ENGINE=1 \
                  -DDISABLE_PSI_STAGE=1 \
                  -DDISABLE_PSI_STATEMENT=1
</pre>

<p>Для получения дополнительной информации см. описания опций
<code>DISABLE_PSI_<em><code>XXX</code></em></code>
<span><strong>CMake</strong></span> в
<a href="install.htm#source-configuration-options">разделе 2.8.4</a>.</p>

<p>Если Вы устанавливаете MySQL по предыдущей установке, которая была
сконфигурирована без Performance Schema (или с более старой версией
Performance Schema, у которой, возможно, нет всех текущих таблиц), выполните
<a href="programs.htm#mysql-upgrade"><span><strong>mysql_upgrade</strong>
</span></a> после запуска сервера, чтобы гарантировать, что база данных
<code>performance_schema</code> существует со всеми текущими таблицами. Тогда
перезапустите сервер. Один признак, что Вы должны сделать это, является
присутствием сообщений, таких как следующее в журнале ошибок:
<pre>
[ERROR] Native table 'performance_schema'.'events_waits_history'
        has the wrong structure
[ERROR] Native table 'performance_schema'.'events_waits_history_long'
        has the wrong structure
...
</pre>

<p>Чтобы проверить, был ли сервер создан с поддержкой Performance Schema,
проверьте ее вывод справки. Если Performance Schema будет доступна, то вывод
упомянет несколько переменных с именами, которые
начинаются с <code>performance_schema</code>:
<pre>
shell&gt; mysqld --verbose --help
...
  --performance_schema
Enable the performance schema.
  --performance_schema_events_waits_history_long_size=#
Number of rows in events_waits_history_long.
...
</pre>

<p>Вы можете также соединиться с сервером и искать строку, которая называет
механизм хранения <a href="perfor.htm"><code>PERFORMANCE_SCHEMA</code></a>
в выводе <a href="sql.htm#show-engines"><code>SHOW ENGINES</code></a>:
<pre>
mysql&gt; SHOW ENGINES\G
...
Engine: PERFORMANCE_SCHEMA
 Support: YES
 Comment: Performance Schema
Transactions: NO
XA: NO
  Savepoints: NO
...
</pre>

<p>Если Performance Schema не была сконфигурирована в сервер, никакой строки
для <a href="perfor.htm"><code>PERFORMANCE_SCHEMA</code></a> не появится в
выводе <a href="sql.htm#show-engines"><code>SHOW ENGINES</code></a>.
Вы могли бы видеть <code>performance_schema</code> перечисленную в выводе
<a href="sql.htm#show-databases"><code>SHOW DATABASES</code></a>, но у этого
не будет никаких таблиц, и Вы не будете в состоянии использовать это.</p>

<p>Строка для <a href="perfor.htm"><code>PERFORMANCE_SCHEMA</code></a> в
<a href="sql.htm#show-engines"><code>SHOW ENGINES</code></a> означает, что
Performance Schema доступна, а не то, что это включено. Чтобы включить, Вы
должны сделать так при запуске сервера, как описано в следующем разделе.</p>

<h3><a name="performance-schema-startup-configuration"></a>23.2.2.
Конфигурация запуска Performance Schema</h3>
<p>Предполагая, что Performance Schema доступна, она включена по умолчанию.
Чтобы включить или отключить это явно, запустите сервер с переменной
<a href="#sysvar_performance_schema"><code>performance_schema
</code></a>, установленной к соответствующему значению. Например, используйте
эти строки в Вашем файле <code>my.cnf</code>:
<pre>
[mysqld]
performance_schema=ON
</pre>

<p>Если сервер неспособен выделить какой-либо внутренний буфер во время
инициализации Performance Schema, то Performance Schema отключается и
устанавливает <a href="#sysvar_performance_schema"><code>
performance_schema</code></a> в <code>OFF</code>, а
сервер работает без инструментовки.</p>

<p>Performance Schema также разрешает настроить инструмент и потребительскую
конфигурацию при запуске сервера.</p>
<p>Чтобы управлять инструментом при запуске сервера, используйте
опцию этой формы:
<pre>
--performance-schema-instrument='<em><code>instrument_name</code></em>=<em><code>value</code></em>'
</pre>

<p>Здесь <em><code>instrument_name</code></em> инструментальное имя, такое
как <code>wait/synch/mutex/sql/LOCK_open</code>, а
<em><code>value</code></em> одно из этих значений:</p>

<ul><li><p><code>OFF</code>, <code>FALSE</code> или
<code>0</code>: Отключите инструмент.</li>
<li><code>ON</code>, <code>TRUE</code> или <code>1</code>:
Включить и измерять время.</li>
<li><code>COUNTED</code>: Включить и считать инструмент.</p></li></ul>

<p>Каждая опция <a href="#option_mysqld_performance-schema-instrument">
<code>--performance-schema-instrument</code></a> может определить только одно
инструментальное имя, но много копий опции могут быть приведены, чтобы
сконфигурировать много инструментов. Кроме того, образцы разрешены в
инструментальных именах, чтобы сконфигурировать инструменты, которые
соответствуют образцу. Чтобы сконфигурировать все инструменты синхронизации
условия как включенные и считающиеся, используйте эту опцию:
<pre>
--performance-schema-instrument='wait/synch/cond/%=COUNTED'
</pre>

<p>Чтобы отключить все инструменты, используйте эту опцию:
<pre>
--performance-schema-instrument='%=OFF'
</pre>

<p>Исключение: инструменты <code>memory/performance_schema/%</code>
встроены и не могут быть отключены при запуске.</p>
<p>Более длинные инструментальные строки имен имеют приоритет над более
коротким образцами имен, независимо от порядка. Для информации об определении
образцов, чтобы выбрать инструменты, см.
<a href="#performance-schema-filtering-names">раздел 23.2.3.9</a>.
</p>

<p>Проигнорировано непризнанное инструментальное имя. Возможно, что плагин,
установленный позже, может создать инструмент, в котором
имя признано и сконфигурировано.</p>

<p>Чтобы управлять потребителем при запуске сервера, используйте
опцию этой формы:
<pre>
--performance-schema-consumer-<em><code>consumer_name</code></em>=<em><code>value</code></em>
</pre>

<p>Здесь <em><code>consumer_name</code></em> потребительское имя, такое как
<code>events_waits_history</code>, а <em><code>value</code></em>
одно из этих значений:</p>

<ul><li><p><code>OFF</code>, <code>FALSE</code> или <code>0</code>:
Не собирать события для потребителя.</li>
<li><code>ON</code>, <code>TRUE</code> или <code>1</code>:
Собирать события для потребителя.</p></li></ul>

<p>Например, чтобы включить потребителя <code>events_waits_history</code>,
используйте эту опцию:
<pre>
--performance-schema-consumer-events-waits-history=ON
</pre>

<p>Разрешенные потребительские имена могут быть найдены, исследуя таблицу
<a href="#setup-consumers-table"><code>setup_consumers</code></a>.
Образцы не разрешены. Потребитель называется в таблице
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
с применением подчеркивания, но для потребительского набора при запуске тире
и подчеркивания в пределах имени эквивалентны.</p>

<p>Performance Schema включает несколько системных переменных, которые
предоставляют информацию о конфигурации:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'perf%';
+--------------------------------------------------------+-------+
| Variable_name                                          | Value |
+--------------------------------------------------------+-------+
| performance_schema                                     |    ON |
| performance_schema_accounts_size                       |   100 |
| performance_schema_digests_size                        |   200 |
| performance_schema_events_stages_history_long_size     | 10000 |
| performance_schema_events_stages_history_size          |    10 |
| performance_schema_events_statements_history_long_size | 10000 |
| performance_schema_events_statements_history_size      |    10 |
| performance_schema_events_waits_history_long_size      | 10000 |
| performance_schema_events_waits_history_size           |    10 |
| performance_schema_hosts_size                          |   100 |
| performance_schema_max_cond_classes                    |    80 |
| performance_schema_max_cond_instances                  |  1000 |
...
</pre>

<p>Переменная <a href="#sysvar_performance_schema"><code>
performance_schema</code></a> <code>ON</code> или <code>OFF</code>, чтобы
указать, включена ли Performance Schema. Другие переменные указывают на
табличные размеры (число строк) или значения распределения памяти.</p>

<p>С включенной Performance Schema число случаев Performance Schema
затрагивает память сервера, возможно в большой степени. Performance Schema
автомасштабирует много параметров, чтобы использовать память только как
требуется, см. <a href="#performance-schema-memory-model">раздел
23.14</a>.</p>

<p>Чтобы изменить значение системных переменных Performance Schema,
установите их при запуске сервера. Например, поместите следующие строки в
файл <code>my.cnf</code>, чтобы изменить размеры таблиц истории для события:
<pre>
[mysqld]
performance_schema
performance_schema_events_waits_history_size=20
performance_schema_events_waits_history_long_size=15000
</pre>

<p>Performance Schema автоматически измеряет значения нескольких из ее
параметров при запуске сервера, если они не установлены явно. Например, это
измеряет параметры, которые управляют размерами событий. Performance Schema
выделяет память, масштабируя ее использование к фактической загрузке сервера
вместо того, чтобы выделить всю память, которая требуется во время запуска
сервера. Следовательно, много параметров калибровки не должны быть
установлены вообще. Чтобы видеть, какие параметры автоизмерены или
автомасштабируются, используйте <a href="programs.htm#mysqld"><span><strong>
mysqld --verbose --help</strong></span></a> и исследуйте описания опции.</p>

<p>Для каждого авторазмерного параметра, который не установлен при запуске
сервера (или установле в -1) Performance Schema определяет, как установить
значение, основанное на значении следующих системных значений, которые
рассматривают как <span>подсказки</span> о том, как Вы сконфигурировали
свой сервер MySQL:
<pre>
max_connections
open_files_limit
table_definition_cache
table_open_cache
</pre>

<p>Чтобы переопределить автокалибровку или автомасштабирование для данного
параметра, установите это в значение не -1 при запуске. В этом случае
Performance Schema назначает этому указанное значение.</p>

<p>Во временя выполнения <a href="sql.htm#show-variables"><code>SHOW
VARIABLES</code></a> выводит на экран фактические значения, к которым были
установлены автоизмеренные параметры. Автомасштабируемые параметры выводятся
на экран со значением -1.</p>

<p>Если Performance Schema отключена, ее авторазмерные и автомасштабируемые
параметры остаются установленными в -1 и <a href="sql.htm#show-variables">
<code>SHOW VARIABLES</code></a> покажет -1.</p>

<h3><a name="performance-schema-runtime-configuration"></a>23.2.3.
Конфигурация Performance Schema во время работы</h3>
<p>Таблицы установки Performance Schema
содержат информацию о контролирующей конфигурации:
<pre>
mysql&gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
                 WHERE TABLE_SCHEMA = 'performance_schema' AND
                 TABLE_NAME LIKE 'setup%';
+-------------------+
| TABLE_NAME        |
+-------------------+
| setup_actors      |
| setup_consumers   |
| setup_instruments |
| setup_objects     |
| setup_timers      |
+-------------------+
</pre>

<p>Вы можете исследовать содержание этих таблиц, чтобы получить информацию о
Performance Schema, контролирующей характеристики. Если Вы имеете привилегию
<a href="security.html#priv_update"><code>UPDATE</code></a>, Вы можете
изменить работу Performance Schema, изменяя таблицы установки, чтобы
затронуть, как происходит контроль. Для дополнительных деталей об этих
таблицах см. <a href="#performance-schema-setup-tables">раздел
23.9.2</a>.</p>

<p>Чтобы видеть, какие таймеры событий выбраны, запросите
<a href="#setup-timers-table"><code>setup_timers</code></a>:
<pre>
mysql&gt; SELECT * FROM setup_timers;
+-------------+-------------+
| NAME        | TIMER_NAME  |
+-------------+-------------+
| idle        | MICROSECOND |
| wait        | CYCLE       |
| stage       | NANOSECOND  |
| statement   | NANOSECOND  |
| transaction | NANOSECOND  |
+-------------+-------------+
</pre>

<p><code>NAME</code> указывает на тип инструмента, к которому таймер
применяется, а <code>TIMER_NAME</code> указывает, какой таймер относится к
тем инструментам. Таймер относится к инструментам, где их имя начинается с
компонента, соответствующего <code>NAME</code>.</p>

<p>Чтобы изменить таймер, обновите <code>NAME</code>. Например, чтобы
использовать таймер <code>NANOSECOND</code> для <code>wait</code>:
<pre>
mysql&gt; UPDATE setup_timers SET TIMER_NAME = 'NANOSECOND'
                 WHERE NAME = 'wait';
mysql&gt; SELECT * FROM setup_timers;
+-------------+-------------+
| NAME        | TIMER_NAME  |
+-------------+-------------+
| idle        | MICROSECOND |
| wait        | NANOSECOND  |
| stage       | NANOSECOND  |
| statement   | NANOSECOND  |
| transaction | NANOSECOND  |
+-------------+-------------+
</pre>

<p>Таблицы <a href="#setup-instruments-table"><code>
setup_instruments</code></a> и <a href="#setup-consumers-table">
<code>setup_consumers</code></a> приводят инструменты, для которых события
могут быть собраны и типы потребителей, для которых информация о событии
фактически собрана, соответственно. Другие таблицы установки позволяют
дальнейшей модификации контролирующей конфигурации.
<a href="#performance-schema-filtering">Раздел 23.2.3.2</a>
обсуждает, как Вы можете изменить эти таблицы, чтобы затронуть набор событий.
</p>

<p>Если есть изменения конфигурации Performance Schema, которые должны быть
произведены во время выполнения, используя запросы SQL, и Вы хотели бы, чтобы
эти изменения вступили в силу каждый раз, когда сервер запускается, поместите
эти запросы в файл и запускайте сервер с опцией
<a href="server.htm#option_mysqld_init-file"><code>--init-file=<em><code>
file_name</code></em></code></a>. Эта стратегия может также быть полезной,
если у Вас есть много контрольных конфигураций, каждая чтобы произвести
различный вид контроля. Поместите запросы для каждой контрольной конфигурации
в их собственный файл и определите соответствующий файл как параметр
<a href="server.htm#option_mysqld_init-file"><code>--init-file</code></a>,
когда Вы запускаете сервер.</p>

<h4><a name="performance-schema-timing"></a>23.2.3.1.
Синхронизация событий Performance Schema</h4>
<p>События собраны посредством инструментовки, добавленной к исходному коду
сервера. Инструментальные события времени обеспечивают сведения о том,
сколько времени события берут. Также возможно сконфигурировать инструменты,
чтобы не собирать информацию синхронизации. Этот раздел обсуждает доступные
таймеры, их характеристики, и как значения
синхронизации представлены в событиях.</p>

<h5><a name="performance-schema-timers"></a>Таймеры Performance Schema</h5>
<p>Две таблицы Performance Schema предоставляют информацию о таймере:</p>
<ul><li><p><a href="#performance-timers-table"><code>
performance_timers</code></a> перечисляет доступные
таймеры и их характеристики.</li>
<li><a href="#setup-timers-table"><code>setup_timers</code></a>
указывает, какие таймеры используются для каких инструментов.</p></li></ul>

<p>Каждая строка таймера в <a href="#setup-timers-table"><code>
setup_timers</code></a> должна обратиться к одному из таймеров, перечисленных
в <a href="#performance-timers-table"><code>performance_timers
</code></a>.</p>

<p>Таймеры изменяются по точности и издержкам. Чтобы видеть, какие таймеры
доступны и их характеристики, проверьте таблицу
<a href="#performance-timers-table"><code>performance_timers</code>
</a>:
<pre>
mysql&gt; SELECT * FROM performance_timers;
+-------------+-----------------+------------------+----------------+
| TIMER_NAME  | TIMER_FREQUENCY | TIMER_RESOLUTION | TIMER_OVERHEAD |
+-------------+-----------------+------------------+----------------+
| CYCLE       |      2389029850 |                1 |    72          |
| NANOSECOND  |      1000000000 |                1 |   112          |
| MICROSECOND |         1000000 |                1 |   136          |
| MILLISECOND |            1036 |                1 |   168          |
| TICK        |             105 |                1 |  2416          |
+-------------+-----------------+------------------+----------------+
</pre>

<p>У столбцов есть эти значения:</p>
<ul><li><p><code>TIMER_NAME</code> показывает названия доступных таймеров.
<code>CYCLE</code> обращается к таймеру, который основан на счетчике цикла
центрального процессора. Вы можете использовать таймеры в
<a href="#setup-timers-table"><code>setup_timers</code></a>,
которые не имеют <code>NULL</code> в других столбцах. Если значения,
связанные с данным именем таймера, <code>NULL</code>, этот таймер не
поддержан на Вашей платформе.</li>

<li><code>TIMER_FREQUENCY</code> указывает на число модулей таймера в
секунду. Для счетчика циклов частота вообще связана со скоростью центрального
процессора. Показанное значение было получено на системе 2.4GHz.
Другие таймеры основаны на фиксированных долях секунд. Для <code>TICK</code>
частота может изменяться платформой (например, некоторые используют 100
tick/секунду, другие 1000 tick/секунду).</li>

<li><code>TIMER_RESOLUTION</code> указывает на число модулей таймера,
которыми таймер оценивает увеличение за один раз. Если у таймера есть
разрешение 10, его значение увеличивается на 10 каждый раз.</li>

<li><code>TIMER_OVERHEAD</code> минимальное число циклов, чтобы получить одну
синхронизацию с данным таймером. Издержки на событие являются удвоенным
значением, выведенным на экран, потому что таймер вызван в начале и в конце.
</p></li></ul>

<p>Чтобы видеть, который таймеры работают или изменить таймеры, получите
доступ к таблице <a href="#setup-timers-table"><code>setup_timers
</code></a>:
<pre>
mysql&gt; SELECT * FROM setup_timers;
+-------------+-------------+
| NAME        | TIMER_NAME  |
+-------------+-------------+
| idle        | MICROSECOND |
| wait        | CYCLE       |
| stage       | NANOSECOND  |
| statement   | NANOSECOND  |
| transaction | NANOSECOND  |
+-------------+-------------+

mysql&gt; UPDATE setup_timers SET TIMER_NAME = 'MICROSECOND'
                 WHERE NAME = 'idle';
mysql&gt; SELECT * FROM setup_timers;
+-------------+-------------+
| NAME        | TIMER_NAME  |
+-------------+-------------+
| idle        | MICROSECOND |
| wait        | CYCLE       |
| stage       | NANOSECOND  |
| statement   | NANOSECOND  |
| transaction | NANOSECOND  |
+-------------+-------------+
</pre>

<p>По умолчанию Performance Schema использует лучший таймер, доступный для
каждого инструментального типа, но Вы можете выбрать другой.</p>
<p>Для событий ожидания самый важный критерий это уменьшение издержек, таким
образом использование таймера <code>CYCLE</code> является лучшим.</p>

<p>Время, которое запрос (или этап) занимает, чтобы выполниться,
находится в общих порядках величины, больше чем время, которое требуется,
чтобы выполнить только ожидание. Для запросов времени самым важным критерием
должна быть точная мера, которая не затронута изменениями в частоте
процессора, таким образом использование таймера, который не основан на
циклах, является лучшим. Таймер по умолчанию для запросов
<code>NANOSECOND</code>. Дополнительные <span>издержки</span>
по сравнению с таймером <code>CYCLE</code> не являются существенными, потому
что являются порядком величин меньше по сравнению со временем центрального
процессора, используемым, чтобы выполнить запрос непосредственно.
Использование таймера <code>CYCLE</code> не обладает никаким преимуществом
здесь, только недостатками.</p>

<p>Точность, предлагаемая счетчиком цикла, зависит от скорости процессора.
Если процессор достигает 1 ГГц (один миллиард циклов/секунду) или выше,
счетчик цикла поставляет точность наносекунды. Использование счетчика цикла
намного более дешево, чем получение фактического времени суток. Например,
стандартная функция <code>gettimeofday()</code> может взять сотни циклов,
что является недопустимыми издержками для того, что может произойти тысячи
или миллионы раз в секунду.</p>

<p>У счетчиков цикла также есть недостатки:</p>
<ul><li><p>Конечные пользователи ожидают видеть синхронизации в модулях
стенных часов такие, как доли секунды. Преобразование из циклов в доли
секунд может быть дорогим. Поэтому преобразование быстрая и довольно
грубая работа умножения.</li>

<li>Уровень цикла процессора мог бы измениться, как тогда, когда ноутбук
входит в сберегающий режим или когда центральный процессор замедляется, чтобы
уменьшить температуру. Если уровень цикла процессора колеблется,
преобразование циклов в модули в реальном времени подвергается ошибке.</li>

<li>Счетчики цикла могли бы быть ненадежными или недоступными в зависимости
от процессора или операционной системы. Например, на Pentium есть инструкция
<code>RDTSC</code> (ассемблер, а не инструкция C) и для операционной
системы теоретически возможно препятствовать тому, чтобы программы
пользовательского режима использовали это.</li>
<li>Некоторые детали процессора, не связанные с выполнением или
синхронизацией, могли бы вызвать противоречия до 1000 циклов.</p></li></ul>
<p>MySQL работает со счетчиками цикла на x386 (Windows, OS X,
Linux, Solaris и другие разновидности Unix), PowerPC и IA-64.</p>

<h5><a name="performance-schema-timing-in-events"></a>
Представление таймера Performance Schema в событиях</h5>
<p>У строк в таблицах Performance Schema, которые хранят текущие и
исторические события, есть три столбца, чтобы представить информацию о
синхронизации: <code>TIMER_START</code> и <code>TIMER_END</code> указывают,
когда случай запустился и закончился, а <code>TIMER_WAIT</code>
указывает на продолжительность события.</p>

<p>Таблица <a href="#setup-instruments-table"><code>
setup_instruments</code></a> имеет столбец <code>ENABLED</code>, чтобы
указать на инструменты, для которых можно собрать события. У таблицы также
есть столбец <code>TIMED</code>, чтобы указать, какие инструменты рассчитаны.
Если инструмент не включен, он не производит событий. Если включенный
инструмент не рассчитан, события, произведенные инструментом, имеют
<code>NULL</code> для значений таймера <code>TIMER_START</code>,
<code>TIMER_END</code> и <code>TIMER_WAIT</code>. Это в свою очередь
заставляет проигнорировать те значения, вычисляя сумму, минимум, максимум и
средние временные оценки в сводных таблицах.</p>

<p>Внутренне, времена в пределах событий сохранены в модулях, данных таймером
в действительности, когда синхронизация событий начинается. Для отображения,
когда события получены от таблиц Performance Schema времена показываются в
пикосекундах и нормализуются к стандартному модулю, независимо от
которого выбран таймер.</p>

<p>Модификации таблицы
<a href="#setup-timers-table"><code>setup_timers</code></a>
применяются немедленно. События, уже происходящие, могут использовать
оригинальный таймер в течение времени начала и новый таймер в течение времени
окончания. Чтобы избежать непредсказуемых результатов после того, как Вы
производите изменения таймера, надо использовать
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>, чтобы
сбрасывать статистику Performance Schema.</p>

<p>Базовая линия таймера (<span>нулевое время</span>) происходит при
инициализации Performance Schema во время запуска сервера. Значения
<code>TIMER_START</code> и <code>TIMER_END</code>
в событиях представляют пикосекунды, начиная с базовой линии. Значения
<code>TIMER_WAIT</code> указывают продолжительности в пикосекундах.</p>

<p>Значения пикосекунды в событиях приблизительны. Их точность подвергается
обычным формам ошибки, связанной с преобразованием от одного модуля до
другого. Если таймер <code>CYCLE</code> используется, и уровень процессора
изменяется, мог бы быть дрейф. По этим причинам неразумно смотреть на
значение <code>TIMER_START</code> как на точную меру времени, начиная с
запуска сервера. С другой стороны, разумно использовать
<code>TIMER_START</code> или <code>TIMER_WAIT</code> в <code>ORDER BY</code>,
чтобы упорядочить события по времени запуска или продолжительности.</p>

<p>У выбора пикосекунд в событиях, а не таких значений, как микросекунды
есть исполнительное основание. Одна цель выполнения состояла в том, чтобы
показать результаты в однородной единице измерения времени, независимо от
таймера. В идеальном мире эта единица измерения времени была бы похожа на
модуль стенных часов и была бы разумно точна, другими словами, микросекунды.
Но преобразовать циклы или наносекунды к микросекундам, было бы необходимо
выполнить деление для каждой инструментовки. Деление дорого на многих
платформах. Умножение не дорого, так что оно и используется.
Поэтому, единица измерения времени целое число, полученное из максимально
возможного <code>TIMER_FREQUENCY</code>, используя множитель, достаточно
большой, чтобы гарантировать, что нет никакой крупной потери точности.
Результат состоит в том, что единица измерения времени <span>пикосекунда
</span>. Эта точность является поддельной, но решение минимизирует издержки.
</p>

<p>В то время как ожидание, этап, запрос или операционный случай выполняются,
соответствующие таблицы текущих событий выводят на экран информацию о
синхронизации текущих событий:
<pre>
events_waits_current
events_stages_current
events_statements_current
events_transactions_current
</pre>

<p>Чтобы позволить определить, сколько времени завершенный случай работал,
столбцы таймера установлены следующим образом:</p>
<ul><li><p><code>TIMER_START</code> заполнен.</li>
<li><code>TIMER_END</code> заполнен текущим значением таймера.</li>
<li><code>TIMER_WAIT</code> заполнен временем, прошедшим до сих пор
(<code>TIMER_END</code>-<code>TIMER_START</code>).</p></li></ul>

<p>События, которые еще не завершились, имеют значение
<code>END_EVENT_ID</code> <code>NULL</code>.
Чтобы оценить прошедшее время для случая, используйте столбец
<code>TIMER_WAIT</code>. Поэтому, чтобы идентифицировать события, которые еще
не завершились и заняли больше времени, чем <em><code>N</code></em>
пикосекунд к настоящему времени, приложения могут использовать
это выражение в запросах:
<pre>
WHERE END_EVENT_ID IS NULL AND TIMER_WAIT &gt; <em><code>N</code></em>
</pre>

<p>Идентификация событий как только описано предполагает, что соответствующие
инструменты имеют <code>ENABLED</code> и <code>TIMED</code> установленные в
<code>YES</code>, а соответствующие потребители включены.</p>

<h4><a name="performance-schema-filtering"></a>23.2.3.2.
Фильтрация событий Performance Schema</h4>
<p>События обработаны способом производителя/потребителя:</p>

<ul><li><p>Инструментованный код производит события, которые будут собраны.
Таблица <a href="#setup-instruments-table"><code>setup_instruments
</code></a> приводит инструменты, для которых могут быть собраны события,
включены ли они и (для включенных инструментов), собирать
ли информацию синхронизации:
<pre>
mysql&gt; SELECT * FROM setup_instruments;
+---------------------------------------------------+---------+-------+
| NAME                                              | ENABLED | TIMED |
+---------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock        | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                 | YES     | YES   |
...
</pre>

<p>Таблица <a href="#setup-instruments-table"><code>
setup_instruments</code></a> обеспечивает наиболее каноническую форму
управления производством событий. Чтобы далее усовершенствовать производство
событий, основанное на типе объекта или проверяемого потока, другие таблицы
могут использоваться как описано в
<a href="#performance-schema-pre-filtering">разделе 23.2.3.3</a>.
</li>

<li>Таблицы Performance Schema это места назначения для событий и
потребители. Таблица <a href="#setup-consumers-table"><code>
setup_consumers</code></a> приводит типы потребителей, в которые можно
послать информацию о событии и включены ли они:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | NO      |
| events_transactions_history      | NO      |
| events_transactions_history_long | NO      |
| events_waits_current             | NO      |
| events_waits_history             | NO      |
| events_waits_history_long        | NO      |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
</pre></li></ul>

<p>Фильтрация может быть сделана на различных
этапах исполнительного контроля:</p>
<ul><li><p><span><strong>Предварительная фильтрация.</strong></span>
Это сделано, изменяя конфигурацию Performance Schema так, чтобы только
определенные типы событий были собраны от производителей, и собранные события
обновляют только определенных потребителей. Чтобы сделать это, включите или
отключите инструменты или потребителей. Предварительная фильтрация сделана
Performance Schema и имеет глобальный эффект, который относится
ко всем пользователям.</p>

<p>Причины использовать предварительную фильтрацию:</p>
<ul><li><p>Уменьшить издержки. Издержки Performance Schema
должны быть минимальны даже со всеми включенными инструментами, но возможно
Вы хотите уменьшить их далее. Или Вы не заботитесь о событиях синхронизации и
хотите отключить код синхронизации, чтобы устранить издержки синхронизации.
</li>

<li>Избежать заполнения текущих событий или таблицы истории с событиями, к
которым у Вас нет никакого интереса. Предварительная фильтрация оставляет
больше места в этих таблицах для случаев строк включенных инструментальных
типов. Если Вы включаете только инструменты файла с предварительной
фильтрацией, никакие строки не собраны для не файловых инструментов.
С постфильтрацией не файловые события собраны, оставляя меньше строк
для событий файла.</li>

<li>Избежать поддерживать некоторые виды таблиц событий. Если Вы отключаете
потребителя, сервер не тратит времея для этого потребителя. Например, если Вы
не заботитесь об историях событий, Вы можете отключить табличных потребителей
истории, чтобы улучшить работу.</p></li></ul></li>

<li><p><span><strong>Постфильтрация.</strong></span> Это вовлекает
использование <code>WHERE</code> в запросах, которые выбирают информацию из
таблиц Performance Schema, чтобы определить, какое из доступных событий Вы
хотите видеть. Постфильтрация выполнена в расчёте на пользователя, потому что
отдельные пользователи выбирают, какие из доступных
событий представляют интерес.</p>

<p>Причины использовать постфильтрацию:</p>
<ul><li><p>Избежать принятия решений для отдельных пользователей о том,
информация о каких событиях представляет интерес.</li>

<li>Использовать Performance Schema, чтобы исследовать исполнительную
проблему, когда ограничения использования предварительной
фильтрации неизвестны заранее.</p></li></ul></li></ul>

<p>Следующие разделы обеспечивают больше деталей о предварительной фильтрации
и обеспечивают направления для того, чтобы назвать инструменты или
потребителей в фильтрации операций. Для информации о написании
запросов, чтобы получить информацию (постфильтрация) см.
<a href="#performance-schema-queries">раздел 23.3</a>.</p>

<h4><a name="performance-schema-pre-filtering"></a>23.2.3.3.
Предварительная фильтрация событий</h4>
<p>Предварительная фильтрация сделана Performance Schema
и имеет глобальный эффект, который относится ко всем пользователям.
Предварительная фильтрация может быть применена к производителю или к
потребителю обработки событий:</p>

<ul><li><p>Чтобы сконфигурировать предварительную фильтрацию на этапе
производителя, несколько таблиц могут использоваться:</p>
<ul><li><p><a href="#setup-instruments-table"><code>
setup_instruments</code></a> указывает, какие инструменты доступны.
Инструмент, отключенный в этой таблице, не производит событий независимо от
содержания других связанных с производством таблиц. Инструменту, включенному
в этой таблице, разрешают произвести события, согласно
содержанию других таблиц.</li>

<li><a href="#setup-objects-table"><code>setup_objects</code></a>
контролирует особые таблицы Performance Schema и хранит объекты программы.
</li>
<li><a href="#threads-table"><code>threads</code></a>
указывает, включен ли контроль для каждого потока сервера.</li>

<li><a href="#setup-actors-table"><code>setup_actors</code></a>
определяет начальное контрольное состояние
для новых потоков переднего плана.</p></li></ul></li>

<li><p>Чтобы сконфигурировать предварительную фильтрацию на потребительском
этапе, измените таблицу <a href="#setup-consumers-table"><code>
setup_consumers</code></a>. Это определяет места назначения, в которые
посылают события. Если данный случай не пошлют ни к какому месту назначения
(то есть, он не будет потребляться), Performance Schema не производит его.
</p></li></ul>

<p>Модификации любой из этих таблиц действуют немедленно, за исключением
того, что модификации <a href="#setup-actors-table"><code>
setup_actors</code></a> влияют только на потоки переднего плана, созданные
после модификации, а не на существующие потоки.</p>

<p>Когда Вы изменяете контролирующую конфигурацию, Performance Schema
не сбрасывает таблицы истории. События, уже собранные, остаются в текущих
событиях и таблицах истории пока не перемещены более новыми событиями. Если
Вы отключаете инструменты, Вы, возможно, должны были бы ждать некоторое время
прежде, чем события для них перемещены более новыми мероприятиями.
Альтернативно, можно использовать
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>, чтобы
освободить таблицы истории.</p>

<p>После произведения изменений инструментовки Вы могли бы хотеть усечь
сводные таблицы. Вообще, эффект состоит в том, чтобы сбросить сводные столбцы
к 0 или <code>NULL</code>, а не удалить строки. Это могло бы быть полезно,
например, после того, как Вы произвели изменение конфигурации во время
выполнения. Исключения к этому поведению усечения отмечены в отдельных
разделах сводной таблицы.</p>
<p>Следующие разделы описывают, как использовать определенные таблицы, чтобы
управлять предварительной фильтрацией Performance Schema.</p>

<h4><a name="performance-schema-instrument-filtering"></a>23.2.3.4.
Предварительная фильтрация по инструменту</h4>
<p>Таблица <a href="#setup-instruments-table"><code>
setup_instruments</code></a> приводит доступные инструменты:
<pre>
mysql&gt; SELECT * FROM setup_instruments;
+---------------------------------------------------+---------+-------+
| NAME                                              | ENABLED | TIMED |
+---------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock        | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                 | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                  | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger         | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect       | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave         | YES     | YES   |
...
| wait/io/file/sql/binlog                           | YES     | YES   |
| wait/io/file/sql/binlog_index                     | YES     | YES   |
| wait/io/file/sql/casetest                         | YES     | YES   |
| wait/io/file/sql/dbopt                            | YES     | YES   |
...
</pre>

<p>Чтобы управлять, включен ли инструмент, устанавливайте столбец
<code>ENABLED</code> в <code>YES</code> или <code>NO</code>.
Чтобы сконфигурировать, собирать ли информацию синхронизации для включенного
инструмента, установите <code>TIMED</code> в <code>YES</code> или
<code>NO</code>. Установка <code>TIMED</code> затрагивает табличное
содержание Performance Schema как описано в
<a href="#performance-schema-timing">разделе 23.2.3.1</a>.</p>

<p>Модификации большинства строк
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a> действуют немедленно. Для некоторых инструментов модификации эффективны
только при запуске сервера, изменение их во время выполнения не имеет
никакого эффекта. Это затрагивает прежде всего mutexes, условия и rwlocks в
сервере, хотя могут быть другие инструменты, для которых это истина.</p>

<p>Таблица <a href="#setup-instruments-table"><code>
setup_instruments</code></a> обеспечивает наиболее каноническую форму
управления производством событий. Чтобы далее усовершенствовать производство
событий, основанное на типе объекта или проверяемого потока, другие таблицы
могут использоваться как описано в
<a href="#performance-schema-pre-filtering">разделе 23.2.3.3</a>.
</p>

<p>Следующие примеры демонстрируют возможные операции на
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. Эти изменения, как другие операции перед фильтрацией, затрагивают всех
пользователей. Некоторые из этих запросов используют оператор
<a href="funct.htm#operator_like"><code>LIKE</code></a> и инструмент
соответствия образца. Для дополнительной информации об определении образцов,
чтобы выбрать инструменты см.
<a href="#performance-schema-filtering-names">раздел 23.2.3.9</a>.
</p>

<ul><li><p>Отключите все инструменты:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'NO';
</pre>
<p>Теперь никакие события не будут собраны.</li>

<li>Отключите все инструменты файла, добавляя их к текущему
набору отключенных инструментов:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'NO'
                 WHERE NAME LIKE 'wait/io/file/%';
</pre></li>

<li>Отключите только инструменты файла, включите все другие инструменты:
<pre>
mysql&gt; UPDATE setup_instruments
          SET ENABLED = IF(NAME LIKE 'wait/io/file/%', 'NO', 'YES');
</pre></li>

<li>Включите все, кроме инструментов в библиотеке <code>mysys</code>:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = CASE
                 WHEN NAME LIKE '%/mysys/%' THEN 'YES' ELSE 'NO' END;
</pre></li>

<li>Отключите определенный инструмент:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'NO'
                 WHERE NAME = 'wait/synch/mutex/mysys/TMPDIR_mutex';
</pre></li>

<li>Переключите статус инструмента <span>flip</span>:
<pre>
mysql&gt; UPDATE setup_instruments
                 SET ENABLED = IF(ENABLED = 'YES','NO','YES')
                 WHERE NAME = 'wait/synch/mutex/mysys/TMPDIR_mutex';
</pre></li>

<li>Отключите синхронизацию для всех событий:
<pre>
mysql&gt; UPDATE setup_instruments SET TIMED = 'NO';
</pre></li></ul>

<h4><a name="performance-schema-object-filtering"></a>23.2.3.5.
Предварительная фильтрация по объекту</h4>
<p>Таблица <a href="#setup-objects-table"><code>setup_objects
</code></a> управляет, контролирует ли Performance Schema
особую таблицу и хранение объектов программы. Начальное содержимое
<a href="#setup-objects-table"><code>setup_objects</code></a>
похоже на это:
<pre>
mysql&gt; SELECT * FROM setup_objects;
+-------------+--------------------+-------------+---------+-------+
| OBJECT_TYPE | OBJECT_SCHEMA      | OBJECT_NAME | ENABLED | TIMED |
+-------------+--------------------+-------------+---------+-------+
| EVENT       | mysql              | %           | NO      | NO    |
| EVENT       | performance_schema | %           | NO      | NO    |
| EVENT       | information_schema | %           | NO      | NO    |
| EVENT       | %                  | %           | YES     | YES   |
| FUNCTION    | mysql              | %           | NO      | NO    |
| FUNCTION    | performance_schema | %           | NO      | NO    |
| FUNCTION    | information_schema | %           | NO      | NO    |
| FUNCTION    | %                  | %           | YES     | YES   |
| PROCEDURE   | mysql              | %           | NO      | NO    |
| PROCEDURE   | performance_schema | %           | NO      | NO    |
| PROCEDURE   | information_schema | %           | NO      | NO    |
| PROCEDURE   | %                  | %           | YES     | YES   |
| TABLE       | mysql              | %           | NO      | NO    |
| TABLE       | performance_schema | %           | NO      | NO    |
| TABLE       | information_schema | %           | NO      | NO    |
| TABLE       | %                  | %           | YES     | YES   |
| TRIGGER     | mysql              | %           | NO      | NO    |
| TRIGGER     | performance_schema | %           | NO      | NO    |
| TRIGGER     | information_schema | %           | NO      | NO    |
| TRIGGER     | %                  | %           | YES     | YES   |
+-------------+--------------------+-------------+---------+-------+
</pre>

<p>Модификации <a href="#setup-objects-table"><code>setup_objects
</code></a> вступают в силу немедленно.</p>
<p>Столбец <code>OBJECT_TYPE</code> указывает на тип объекта, к которому
применяется строка. <code>TABLE</code> фильтрует табличные события
ввода/вывода (инструмент <code>wait/io/table/sql/handler</code>) и
события блокировки (инструмент<code>wait/lock/table/sql/handler</code>).</p>

<p>Столбцы <code>OBJECT_SCHEMA</code> и <code>OBJECT_NAME</code>
должны содержать буквальную схему или название объекта или <code>'%'</code>,
чтобы соответствовать любому имени.</p>

<p>Столбец <code>ENABLED</code> указывает, проверены ли соответствующие
объекты, а <code>TIMED</code> указывает, собирать ли информацию
синхронизации. Установка <code>TIMED</code> затрагивает табличное содержание
Performance Schema как описано в
<a href="#performance-schema-timing">разделе 23.2.3.1</a>.</p>

<p>Эффект конфигурации объекта по умолчанию состоит в том, чтобы
инструментовать все объекты кроме тех, которые в базах данных
<code>mysql</code>, <code>INFORMATION_SCHEMA</code> и
<code>performance_schema</code>. Таблицы в <code>INFORMATION_SCHEMA</code>
не инструментованы независимо от содержания
<a href="#setup-objects-table"><code>setup_objects</code></a>:
строка для <code>information_schema.%</code>
просто делает это значение по умолчанию явным.</p>

<p>Когда Performance Schema проверяет на соответствие в
<a href="#setup-objects-table"><code>setup_objects</code></a>,
это пытается найти более определенные соответствия сначала. Для строк,
которые соответствуют данному <code>OBJECT_TYPE</code>, Performance Schema
проверяет строки в этом порядке:</p>

<ul><li><p>Строки с <code>OBJECT_SCHEMA='<em><code>literal</code></em>'
</code> и <code>OBJECT_NAME='<em><code>literal</code></em>'</code>.</li>
<li>Строки с <code>OBJECT_SCHEMA='<em><code>literal</code></em>'</code>
и <code>OBJECT_NAME='%'</code>.</li>
<li>Строки с <code>OBJECT_SCHEMA='%'</code> и <code>OBJECT_NAME='%'</code>.
</p></li></ul>

<p>Например, с таблицей <code>db1.t1</code> Performance Schema смотрит
строки для <code>TABLE</code> для <code>'db1'</code> и <code>'t1'</code>,
потом для <code>'db1'</code> и <code>'%'</code>, а уже потом для
<code>'%'</code> и <code>'%'</code>. Порядок, в котором соответствие
происходит такой, потому что различное соответствующие строки
<a href="#setup-objects-table"><code>setup_objects</code></a>
могут иметь отличающиеся значения <code>ENABLED</code> и <code>TIMED</code>.
</p>

<p>Для связанных с таблицей событий Performance Schema комбинирует содержание
<a href="#setup-objects-table"><code>setup_objects</code></a> с
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>, чтобы определить, включить ли инструменты и включены ли
по времени инструменты:</p>

<ul><li><p>Для таблиц, которые соответствуют строке в
<a href="#setup-objects-table"><code>setup_objects</code></a>,
табличные инструменты производят события только, если <code>ENABLED</code>
<code>YES</code> в <a href="#setup-instruments-table"><code>
setup_instruments</code></a> и <a href="#setup-objects-table">
<code>setup_objects</code></a>.</li>

<li>Значения <code>TIMED</code> в этих двух таблицах объединены так, чтобы
информация синхронизации была собрана только, когда
оба значения <code>YES</code>.</p></li></ul>

<p>Для хранимых объектов программы Performance Schema берет столбцы
<code>ENABLED</code> и <code>TIMED</code> непосредственно из строки
<a href="#setup-objects-table"><code>setup_objects</code></a>.
Нет никакого объединения значений с
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<p>Предположите, что <a href="#setup-objects-table"><code>
setup_objects</code></a> содержит следующие строки <code>TABLE</code>,
которые относятся к <code>db1</code>, <code>db2</code> и <code>db3</code>:
<pre>
+-------------+---------------+-------------+---------+-------+
| OBJECT_TYPE | OBJECT_SCHEMA | OBJECT_NAME | ENABLED | TIMED |
+-------------+---------------+-------------+---------+-------+
| TABLE       | db1           | t1          | YES     | YES   |
| TABLE       | db1           | t2          | NO      | NO    |
| TABLE       | db2           | %           | YES     | YES   |
| TABLE       | db3           | %           | NO      | NO    |
| TABLE       | %             | %           | YES     | YES   |
+-------------+---------------+-------------+---------+-------+
</pre>

<p>Если связанный с объектом инструмент в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a> имеет <code>ENABLED</code> <code>NO</code>, события для объекта не
отслеживаются. Если <code>ENABLED</code> <code>YES</code>,
контроль событий происходит согласно значению <code>ENABLED</code>
в соответствующей строке <a href="#setup-objects-table"><code>
setup_objects</code></a>:</p>

<ul><li><p>События <code>db1.t1</code> отслеживаются.</li>
<li>События <code>db1.t2</code> не отслеживаются.</li>
<li>События <code>db2.t3</code> отслеживаются.</li>
<li>События <code>db3.t4</code> не отслеживаются.</li>
<li>События <code>db4.t5</code> отслеживаются.</p></li></ul>

<p>Подобная логика просит объединения столбцов <code>TIMED</code> из
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a> и <a href="#setup-objects-table"><code>setup_objects</code>
</a>, чтобы определить, собирать ли информацию синхронизации событий.</p>

<p>Если у постоянной и временной таблиц есть то же самое имя, соответствующее
строке <a href="#setup-objects-table"><code>setup_objects</code>
</a> происходит тот же самый путь к обоим. Невозможно позволить
контролировать для одной таблицы, но не для другой.
Однако, каждая таблица инструментована отдельно.</p>

<h4><a name="performance-schema-thread-filtering"></a>23.2.3.6.
Предварительная фильтрация по потоку</h4>
<p>Таблица <a href="#threads-table"><code>threads</code></a>
содержит строку для каждого потока сервера. Каждая строка содержит информацию
о потоке и указывает, включен ли контроль для этого. Для Performance Schema,
чтобы контролировать поток, эти вещи должны быть истиной:</p>

<ul><li><p>Потребитель <code>thread_instrumentation</code> в
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
должен быть <code>YES</code>.</li>
<li>Столбец <code>threads.INSTRUMENTED</code> должен быть <code>YES</code>.
</li>

<li>Контроль происходит только для событий потока, произведенных из
инструментов, которые включены в
<a href="#setup-instruments-table"><code>setup_instruments
</code></a>.</p></li></ul>

<p>Таблица <a href="#threads-table"><code>threads</code></a>
также показывает для каждого потока сервера, выполнить ли журналирование
исторического события. Это включает ожидание, подготовку, запрос и
операционное журналирование событий для этих таблиц:
<pre>
events_waits_history
events_waits_history_long
events_stages_history
events_stages_history_long
events_statements_history
events_statements_history_long
events_transactions_history
events_transactions_history_long
</pre>

<p>Для журналирования исторического события эти вещи должны быть истиной:</p>
<ul><li><p>Соответствующие связанные с историей потребители в
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
должны быть включены. Например, случай ожидания, протоколируемый в
<a href="#events-waits-history-table"><code>events_waits_history
</code></a> и <a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a> требует соответствующих потребителей
<code>events_waits_history</code> и <code>events_waits_history_long</code>
со статусом <code>YES</code>.</li>

<li>Столбец <code>threads.HISTORY</code> должен быть <code>YES</code>.</li>
<li>Журналирование происходит только для событий потока, произведенных из
инструментов, которые включены в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p></li></ul>

<p>Для потоков переднего плана (следующих из соединений клиента), начальные
значения столбцов <code>INSTRUMENTED</code> и <code>HISTORY</code> в строках
таблицы <a href="#threads-table"><code>threads</code></a>
определены тем, соответствует ли учетная запись пользователя, связанная с
потоком, какой-либо строке в <a href="#setup-actors-table"><code>
setup_actors</code></a>. Значения прибывают из столбцов <code>ENABLED</code>
и <code>HISTORY</code> соответствующих строк
<a href="#setup-actors-table"><code>setup_actors</code></a>.</p>

<p>Для фоновых потоков нет никакого связанного пользователя.
<code>INSTRUMENTED</code> и <code>HISTORY</code> <code>YES</code>
по умолчанию и <a href="#setup-actors-table"><code>setup_actors
</code></a> не проверяется.</p>

<p>Стартовое содержание <a href="#setup-actors-table"><code>
setup_actors</code></a> похоже на это:
<pre>
mysql&gt; SELECT * FROM setup_actors;
+------+------+------+---------+---------+
| HOST | USER | ROLE | ENABLED | HISTORY |
+------+------+------+---------+---------+
| %    | %    | %    | YES     | YES     |
+------+------+------+---------+---------+
</pre>

<p>Столбцы <code>HOST</code> и <code>USER</code>
должны содержать буквальный узел или имя пользователя, или
<code>'%'</code>, чтобы соответствовать любому имени.</p>

<p>Столбцы <code>ENABLED</code> и <code>HISTORY</code>
указывают, включить ли инструментовку и журналирование исторического события
для соответствующих потоков, согласно другим условиям, описанным ранее.</p>

<p>Когда Performance Schema проверяет на соответствие
каждый новый поток переднего плана в <code>setup_actors</code>,
это пытается найти более определенные соответствия сначала, используя
столбцы <code>USER</code> и <code>HOST</code>
(<code>ROLE</code> не использован):</p>

<ul><li><p>Строки с <code>USER='<em><code>literal</code></em>'</code> и
<code>HOST='<em><code>literal</code></em>'</code>.</li>
<li>Строки с <code>USER='<em><code>literal</code></em>'</code>
и <code>HOST='%'</code>.</li>

<li>Строки с <code>USER='%'</code> и
<code>HOST='<em><code>literal</code></em>'</code>.</li>
<li>Строки с <code>USER='%'</code> и <code>HOST='%'</code>.</p></li></ul>

<p>Порядок, в котором соответствие происходит таков,
потому что различные соответствующие строки
<a href="#setup-actors-table"><code>setup_actors</code></a>
могут иметь отличающиеся <code>USER</code> и <code>HOST</code>.
Это позволяет инструментовать и журналировать события, которые будут
применены выборочно на основе узла, пользователя или учетной записи
(комбинация пользователя и узла), исходя из значения столбцов:
<code>ENABLED</code> и <code>HISTORY</code>:</p>

<ul><li><p>Когда лучшее соответствие строка с
<code>ENABLED=YES</code>, значение <code>INSTRUMENTED</code>
для потока становится <code>YES</code>. Когда лучшее соответствие строка с
<code>HISTORY=YES</code>, <code>HISTORY</code> для
потока становится <code>YES</code>.</li>

<li>Когда лучшее соответствие строка с
<code>ENABLED=NO</code>, <code>INSTRUMENTED</code> для потока становится
<code>NO</code>. Когда лучшее соответствие строка с <code>HISTORY=NO</code>,
<code>HISTORY</code> для потока становится <code>NO</code>.</li>

<li>Когда никакое соответствие не найдено, <code>INSTRUMENTED</code> и
<code>HISTORY</code> для потока становятся <code>NO</code>.</p></li></ul>
<p>Столбцы <code>ENABLED</code> и <code>HISTORY</code> в строках
<a href="#setup-actors-table"><code>setup_actors</code></a>
могут быть установлены в <code>YES</code> или <code>NO</code>
независимо друг от друга. Это означает, что Вы можете включить инструментовку
отдельно от того, собираете ли Вы исторические события.</p>

<p>По умолчанию контроль и набор исторического события включен для всех
новых потоков переднего плана потому, что
<a href="#setup-actors-table"><code>setup_actors</code></a>
первоначально содержит строку с <code>'%'</code> для
<code>HOST</code> и <code>USER</code>. Чтобы выполнить более ограниченное
соответствие, например, позволить контролировать только для некоторых потоков
переднего плана, Вы должны изменить эту строку, потому что это соответствует
любому соединению, и добавить строки для более определенной комбинации
<code>HOST</code>/<code>USER</code>.</p>

<p>Предположите, что Вы изменяете <a href="#setup-actors-table">
<code>setup_actors</code></a> следующим образом:
<pre>
UPDATE setup_actors SET ENABLED = 'NO', HISTORY = 'NO'
       WHERE HOST = '%' AND USER = '%';
INSERT INTO setup_actors (HOST,USER,ROLE,ENABLED,HISTORY)
       VALUES('localhost','joe','%','YES','YES');
INSERT INTO setup_actors (HOST,USER,ROLE,ENABLED,HISTORY)
       VALUES('hosta.example.com','joe','%','YES','NO');
INSERT INTO setup_actors (HOST,USER,ROLE,ENABLED,HISTORY)
       VALUES('%','sam','%','NO','YES');
</pre>

<p><a href="sql.htm#update"><code>UPDATE</code></a> изменяет соответствие по
умолчанию, чтобы отключить набор исторического события и инструментовку.
<a href="sql.htm#insert"><code>INSERT</code></a>
добавляют строки для более определенных соответствий.</p>

<p>Теперь Performance Schema определяет, как установить значения
<code>INSTRUMENTED</code> и <code>HISTORY</code>
для потока нового соединения следующим образом:</p>

<ul><li><p>Если <code>joe</code> соединяется с локального хоста, соединение
соответствует первой вставленной строке. <code>INSTRUMENTED</code> и
<code>HISTORY</code> для потока становятся <code>YES</code>.</li>

<li>Если <code>joe</code> соединяется с
<code>hosta.example.com</code>, соединение соответствует второй
вставленной строке. <code>INSTRUMENTED</code> для потока становится
<code>YES</code>, а <code>HISTORY</code> <code>NO</code>.</li>

<li>Если <code>joe</code> соединяется с любого другого узла, это не идет ни в
какое сравнение. <code>INSTRUMENTED</code> и <code>HISTORY</code>
для потока становятся <code>NO</code>.</li>

<li>Если <code>sam</code> соединяется с любого узла, соединение
соответствует третей вставленной строке. <code>INSTRUMENTED</code> для потока
становится <code>NO</code>, а <code>HISTORY</code> <code>YES</code>.</li>

<li>Для любого другого соединения строки с
<code>HOST</code> и <code>USER</code> соответствуют
<code>'%'</code>. Эта строка теперь имеет <code>ENABLED</code> и
<code>HISTORY</code> <code>NO</code>, так что <code>INSTRUMENTED</code> и
<code>HISTORY</code> для потока становятся <code>NO</code>.</p></li></ul>

<p>Модификации <a href="#setup-actors-table"><code>setup_actors
</code></a> влияют только на потоки переднего плана, созданные после
модификации, а не на существующие потоки. Чтобы затронуть существующие
потоки, измените <code>INSTRUMENTED</code> и <code>HISTORY</code> строках
таблицы <a href="#threads-table"><code>threads</code></a>.</p>

<h4><a name="performance-schema-consumer-filtering"></a>23.2.3.7.
Предварительная фильтрация по потребителю</h4>
<p><a href="#setup-consumers-table"><code>setup_consumers</code>
</a> приводит доступные потребительские типы и то, которые включены:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            |  NO     |
| events_stages_history            |  NO     |
| events_stages_history_long       |  NO     |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   |  NO     |
| events_transactions_current      |  NO     |
| events_transactions_history      |  NO     |
| events_transactions_history_long |  NO     |
| events_waits_current             |  NO     |
| events_waits_history             |  NO     |
| events_waits_history_long        |  NO     |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
</pre>

<p>Измените <a href="#setup-consumers-table"><code>setup_consumers
</code></a>, чтобы затронуть предварительную фильтрацию в потребителе
и определить места назначения, в которые посылают события. Чтобы включить или
отключить потребителя, установите <code>ENABLED</code> в
<code>YES</code> или <code>NO</code>.</p>

<p>Модификации <a href="#setup-consumers-table"><code>
setup_consumers</code></a> срабатывают немедленно.</p>
<p>Если Вы отключаете потребителя, сервер не тратит времени на поддержание
места назначения для этого потребителя. Например, если Вы не заботитесь об
информации об историческом событии, отключите потребителей истории:
<pre>
mysql&gt; UPDATE setup_consumers SET ENABLED = 'NO' WHERE NAME
                 LIKE '%history%';
</pre>

<p>Потребительские настройки в <a href="#setup-consumers-table">
<code>setup_consumers</code></a> имеют иерархию.
Следующие принципы применяются:</p>

<ul><li><p>Места назначения, связанные с потребителем, не получают событий,
если Performance Schema не проверяет потребителя.</li>
<li>Потребитель проверен, только если все потребители, от которых он
зависит (если такие есть), включены.</li>

<li>Если потребитель не проверен, или проверен, но отключен, другие
потребители, которые зависят от него, не проверены.</li>
<li>У зависимых потребителей могут быть свои
собственные зависимые потребители.</li>
<li>Если случай не послан никакому месту назначения, Performance Schema
не производит его.</p></li></ul>

<p>Следующие списки описывают доступные потребительские значения. Для
обсуждения нескольких потребительских конфигураций и их эффекта
на инструментовку см.
<a href="#performance-schema-consumer-configurations">раздел
23.2.3.8</a>.</p>

<p><span><strong>Глобальные и потребители потока</strong></span></p>
<ul><li><p><code>global_instrumentation</code> потребитель высшего уровня.
Если <code>global_instrumentation</code> <code>NO</code>,
это отключает глобальную инструментовку. Все другие настройки более низкого
уровня и не проверены, не имеет значения, во что они установлены. Нет
глобальной или поточной информацим о потоке, и никакие одиночные события
не собраны в таблицах истории событий или текущих событиях. Если
<code>global_instrumentation</code> <code>YES</code>, Performance Schema
поддерживает информацию для глобальных состояний, а также проверяет
потребителей <code>thread_instrumentation</code>.</li>

<li><code>thread_instrumentation</code> проверен только, если
<code>global_instrumentation</code> <code>YES</code>. Иначе, если
<code>thread_instrumentation</code> <code>NO</code>,
это отключает определенную для потока инструментовку, и все настройки низшего
уровня проигнорированы. Никакая информация не поддержана для потока, и
никакие одиночные события не собраны в таблицах истории событий или текущих
событиях. Если <code>thread_instrumentation</code> <code>YES</code>,
Performance Schema поддерживает определенную для потока информацию, а также
проверяет <code>events_<em><code>xxx</code></em>_current</code>.
</p></li></ul>

<p><span><strong>Потребители событий ожидания</strong></span></p>
<p>Эти потребители требуют установки обоих
<code>global_instrumentation</code> и <code>thread_instrumentation</code> в
<code>YES</code> или они не проверены. Если проверены, они
действуют следующим образом:</p>

<ul><li><p><code>events_waits_current</code>, если <code>NO</code>,
отключает сбор индивидуальных событий ожидания в таблице
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>. Если <code>YES</code>, это включает сбор событий и
Performance Schema проверяет <code>events_waits_history</code> и
<code>events_waits_history_long</code>.</li>

<li><code>events_waits_history</code> не проверен, если
<code>event_waits_current</code> <code>NO</code>. Иначе
<code>events_waits_history</code> <code>NO</code> или <code>YES</code>
отключает или включает сбор событий в таблице
<a href="#events-waits-history-table"><code>events_waits_history
</code></a>.</li>

<li><code>events_waits_history_long</code> не проверен, если
<code>event_waits_current</code> <code>NO</code>. Иначе
<code>events_waits_history_long</code> <code>NO</code> или <code>YES</code>
отключает или включает сбор событий в таблице
<a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a>.</p></li></ul>

<p><span><strong>Потребители событий этапа</strong></span></p>
<p>Эти потребители требуют <code>global_instrumentation</code> и
<code>thread_instrumentation</code> в <code>YES</code>
или они не проверены. Если проверены, действуют следующим образом:</p>

<ul><li><p><code>events_stages_current</code>, если <code>NO</code>,
отключает сбор отдельных событий этапа в таблице
<a href="#events-stages-current-table"><code>events_stages_current
</code></a>. Если <code>YES</code>, это включает сбор этапов событий, и
Performance Schema проверяет <code>events_stages_history</code> и
<code>events_stages_history_long</code>.</li>

<li><code>events_stages_history</code> не проверен, если
<code>event_stages_current</code> <code>NO</code>. Иначе
<code>events_stages_history</code> <code>NO</code> или <code>YES</code>
отключает или включает сбор событий этапа в
<a href="#events-stages-history-table"><code>events_stages_history
</code></a>.</li>

<li><code>events_stages_history_long</code> не проверен, если
<code>event_stages_current</code> <code>NO</code>. Иначе
<code>events_stages_history_long</code> <code>NO</code> или <code>YES</code>
отключает или включает сбор событий этапа в
<a href="#events-stages-history-long-table"><code>
events_stages_history_long</code></a>.</p></li></ul>

<p><span><strong>Потребители событий запроса</strong></span></p>
<p>Эти потребители требуют <code>global_instrumentation</code> и
<code>thread_instrumentation</code> в <code>YES</code>
или они не проверены. Если проверены, действуют следующим образом:</p>

<ul><li><p><code>events_statements_current</code>, если <code>NO</code>,
отключает сбор отдельных событий запроса в таблице
<a href="#events-statements-current-table"><code>
events_statements_current</code></a>. Если <code>YES</code>,
это включает сбор запросов событий, и Performance Schema проверяет
<code>events_statements_history</code> и
<code>events_statements_history_long</code>.</li>

<li><code>events_statements_history</code> не проверен, если
<code>events_statements_current</code> <code>NO</code>. Иначе
<code>events_statements_history</code> <code>NO</code> или <code>YES</code>
отключает или включает сбор событий запроса в таблице
<a href="#events-statements-history-table"><code>
events_statements_history</code></a>.</li>

<li><code>events_statements_history_long</code> не проверен, если
<code>events_statements_current</code> <code>NO</code>. Иначе
<code>events_statements_history_long</code> <code>NO</code> или
<code>YES</code> отключает или включает сбор событий запроса в таблице
<a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a>.</p></li></ul>

<p><span><strong>Операционные потребители событий</strong></span></p>
<p>Эти потребители требуют <code>global_instrumentation</code> и
<code>thread_instrumentation</code> <code>YES</code>
или они не проверены. Если проверены, они действуют следующим образом:</p>

<ul><li><p><code>events_transactions_current</code>, если
<code>NO</code>, отключает сбор отдельных операционных событий в таблице
<a href="#events-transactions-current-table"><code>
events_transactions_current</code></a>. Если <code>YES</code>,
это включает сбор операционных событий, и Performance Schema проверяет
<code>events_transactions_history</code> и
<code>events_transactions_history_long</code>.</li>

<li><code>events_transactions_history</code> не проверен, если
<code>events_transactions_current</code> <code>NO</code>. Иначе
<code>events_transactions_history</code> <code>NO</code> или <code>YES</code>
отключает или включает сбор операционных событий в таблице
<a href="#events-transactions-history-table"><code>
events_transactions_history</code></a>.</li>

<li><code>events_transactions_history_long</code> не проверен, если
<code>events_transactions_current</code> <code>NO</code>. Иначе
<code>events_transactions_history_long</code>
<code>NO</code> или <code>YES</code>
отключает или включает сбор операционных событий в таблице
<a href="#events-transactions-history-long-table"><code>
events_transactions_history_long</code></a>.</p></li></ul>

<p><span><strong>Потребитель обзора запросов</strong></span></p>
<p>Этот потребитель требует <code>global_instrumentation</code>
<code>YES</code> или это не проверено. Нет никакой зависимости от
потребителей событий запросов, таким образом, Вы можете получить статистику
обзоров, не имея необходимости собирать статистические данные в
<a href="#events-statements-current-table"><code>
events_statements_current</code></a>, что выгодно с точки зрения издержек.
Наоборот, Вы можете вложить детализированные запросы
<a href="#events-statements-current-table"><code>
events_statements_current</code></a> без обзоров (столбцы <code>DIGEST</code>
и <code>DIGEST_TEXT</code> должны быть <code>NULL</code>).</p>

<h4><a name="performance-schema-consumer-configurations"></a>23.2.3.8.
Потребительские конфигурации в качестве примера</h4>
<p>Потребительские настройки в таблице
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
имеют иерархию. Следующее обсуждение описывает, как потребители работают,
показывая определенные конфигурации и их эффекты. Общие принципы, описанные
здесь, относятся к другим потребительским значениям, которые
могут быть доступны.</p>

<p>Описания конфигурации происходят в порядке увеличивающейся
функциональности. Если Вы не нуждаетесь в информации, предоставленной,
включая настройками низшего уровня, отключите их, и Performance Schema
выполнит меньше кода от Вашего имени.</p>

<p>Таблица <a href="#setup-consumers-table"><code>setup_consumers
</code></a> содержит следующую иерархию значений:
<pre>
global_instrumentation
 thread_instrumentation
   events_waits_current
 events_waits_history
 events_waits_history_long
   events_stages_current
 events_stages_history
 events_stages_history_long
   events_statements_current
 events_statements_history
 events_statements_history_long
   events_transactions_current
 events_transactions_history
 events_transactions_history_long
 statements_digest
</pre>

<p>В потребительской иерархии потребители для ожиданий, этапов, запросов и
транзакции все на том же самом уровне. Это отличается от иерархии вложения
событий, где события вложены по уровням.</p>

<p>Если данный потребитель устанавливает <code>NO</code>, Performance Schema
отключает инструментовку, связанную с потребителем, и игнорирует все
настройки низшего уровня. Если данная установка <code>YES</code>, Performance
Schema включает инструментовку, связанную с этим, и проверяет настройки на
следующем самом низком уровне. Для описания правил для каждого потребителя
см. <a href="#performance-schema-consumer-filtering">раздел
23.2.3.7</a>.</p>

<p>Например, если <code>global_instrumentation</code> включен,
<code>thread_instrumentation</code> проверен. Если
<code>thread_instrumentation</code> включен, потребители
<code>events_<em><code>xxx</code></em>_current</code> проверены. Если из них
<code>events_waits_current</code> включен,
<code>events_waits_history</code> и
<code>events_waits_history_long</code> проверены.</p>

<p>Каждое из следующих описаний конфигурации указывает, какие элементы
установки проверки Performance Schema выводят таблицы, которые она
поддерживает (то есть, для которых таблиц она собирает информацию).</p>

<h5><a name="idm139965291317328"></a>Никакой инструментовки</h5>
<p>Состояние конфигурации сервера:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+---------------------------+---------+
| NAME                      | ENABLED |
+---------------------------+---------+
| global_instrumentation    | NO      |
...
+---------------------------+---------+
</pre>

<p>В этой конфигурации ничто не инструментовано.</p>
<p>Элементы установки проверяют:</p>
<ul><li><p>Таблица <a href="#setup-consumers-table"><code>
setup_consumers</code></a>, потребитель <code>global_instrumentation</code>.
</p></li></ul>
<p>Выходные таблицы поддержаны:</p>
<ul><li><p>Нет.</p></li></ul>

<h5><a name="idm139965291308896"></a>Только глобальная инструментовка</h5>
<p>Состояние конфигурации сервера:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+---------------------------+---------+
| NAME                      | ENABLED |
+---------------------------+---------+
| global_instrumentation    | YES     |
| thread_instrumentation    | NO      |
...
+---------------------------+---------+
</pre>

<p>В этой конфигурации инструментовка поддержана только для глобальных
состояний. Инструментовка потоков отключена.</p>
<p>Дополнительные проверенные элементы установки,
относительно предыдущей конфигурации:</p>
<ul><li><p>Таблица <a href="#setup-consumers-table"><code>
setup_consumers</code></a>, потребитель <code>thread_instrumentation</code>.
</li>

<li>Таблица <a href="#setup-instruments-table"><code>
setup_instruments</code></a>.</li>
<li>Таблица <a href="#setup-objects-table"><code>setup_objects
</code></a>.</li>
<li>Таблица <a href="#setup-timers-table"><code>setup_timers</code>
</a>.</p></li></ul>

<p>Дополнительные выходные таблицы, относительно предыдущей конфигурации:</p>
<ul><li><p><a href="#mutex-instances-table"><code>mutex_instances
</code></a></li>

<li><a href="#rwlock-instances-table"><code>rwlock_instances</code>
</a></li>
<li><a href="#cond-instances-table"><code>cond_instances</code></a>
</li>

<li><a href="#file-instances-table"><code>file_instances</code></a>
</li>
<li><a href="#users-table"><code>users</code></a></li>
<li><a href="#hosts-table"><code>hosts</code></a></li>
<li><a href="#accounts-table"><code>accounts</code></a></li>

<li><a href="#socket-summary-tables"><code>
socket_summary_by_event_name</code></a></li>
<li><a href="#file-summary-tables"><code>file_summary_by_instance
</code></a></li>

<li><a href="#file-summary-tables"><code>file_summary_by_event_name
</code></a></li>
<li><a href="#objects-summary-global-by-type-table"><code>
objects_summary_global_by_type</code></a></li>

<li><a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a></li>
<li><a href="#table-lock-waits-summary-by-table-table"><code>
table_lock_waits_summary_by_table</code></a></li>

<li><a href="#table-io-waits-summary-by-index-usage-table"><code>
table_io_waits_summary_by_index_usage</code></a></li>
<li><a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a></li>

<li><a href="#wait-summary-tables"><code>
events_waits_summary_by_instance</code></a></li>
<li><a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a></li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_global_by_event_name</code></a></li>
<li><a href="#statement-summary-tables"><code>
events_statements_summary_global_by_event_name</code></a></li>
<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_global_by_event_name</code></a></p></li></ul>

<h5><a name="idm139965291253344"></a>Инструментовка глобальная и потока</h5>
<p>Состояние конфигурации сервера:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | NO      |
...
| events_stages_current            | NO      |
...
| events_statements_current        | NO      |
...
| events_transactions_current      | NO      |
...
+----------------------------------+---------+
</pre>

<p>В этой конфигурации инструментовка поддержана глобально и для потоков.
Никакие одиночные события не собраны в таблицах истории событий
или текущих событиях.</p>

<p>Дополнительные проверенные элементы установки,
относительно предыдущей конфигурации:</p>
<ul><li><p>Таблица <a href="#setup-consumers-table"><code>
setup_consumers</code></a>, потребители <code>events_<em><code>xxx</code>
</em>_current</code>, где <em><code>xxx</code></em>
<code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</li>

<li>Таблица <a href="#setup-actors-table"><code>setup_actors
</code></a>.</li>
<li>Столбец <code>threads.instrumented</code>.</p></li></ul>

<p>Дополнительные выходные поддержанные таблицы,
относительно предыдущей конфигурации:</p>
<ul><li><p><code>events_<em><code>xxx</code></em>_summary_by_<em><code>yyy
</code></em>_by_event_name</code>, где <em><code>xxx</code></em>
<code>waits</code>, <code>stages</code>, <code>statements</code>,
<code>transactions</code>, а <em><code>yyy</code></em>
<code>thread</code>, <code>user</code>,
<code>host</code>, <code>account</code>.</p></li></ul>

<h5><a name="idm139965291229248"></a>
Инструментовка текущих событий, глобальная и потока</h5>
<p>Состояние конфигурации сервера:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | YES     |
| events_waits_history             | NO      |
| events_waits_history_long        | NO      |
| events_stages_current            | YES     |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | NO      |
...
+----------------------------------+---------+
</pre>

<p>В этой конфигурации инструментовка поддержана глобально и для потока.
Одиночные события собраны в таблице текущих событий, но не в
таблицах истории событий.</p>

<p>Дополнительные проверенные элементы установки,
относительно предыдущей конфигурации:</p>
<ul><li><p>Потребители <code>events_<em><code>xxx</code></em>_history</code>,
где <em><code>xxx</code></em> <code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</li>

<li>Потребители <code>events_<em><code>xxx</code></em>_history_long</code>,
где <em><code>xxx</code></em> <code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</p></li></ul>

<p>Дополнительные выходные поддержанные таблицы,
относительно предыдущей конфигурации:</p>
<ul><li><p><code>events_<em><code>xxx</code></em>_current</code>,
где <em><code>xxx</code></em> is <code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</p></li></ul>

<h5><a name="idm139965291207888"></a>
Инструментовка текущих событий, стории событий, глобальная и потока</h5>
<p>Предыдущая конфигурация не собирает историю событий потому, что
потребители <code>events_<em><code>xxx</code></em>_history</code>
и <code>events_<em><code>xxx</code></em>_history_long</code> отключены.
Эти потребители можно включить отдельно или вместе, чтобы собрать историю
событий для потока, глобально или обоими способами.</p>

<p>Эта конфигурация собирает историю событий для потока, но не глобально:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | YES     |
| events_waits_history             | YES     |
| events_waits_history_long        | NO      |
| events_stages_current            | YES     |
| events_stages_history            | YES     |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | NO      |
...
+----------------------------------+---------+
</pre>

<p>Таблицы истории событий для этой конфигурации:</p>
<ul><li><p><code>events_<em><code>xxx</code></em>_history</code>, где
<em><code>xxx</code></em> <code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</p></li></ul>

<p>Эта конфигурация собирает историю событий глобально, но не для потока:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | YES     |
| events_waits_history             | NO      |
| events_waits_history_long        | YES     |
| events_stages_current            | YES     |
| events_stages_history            | NO      |
| events_stages_history_long       | YES     |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | YES     |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | YES     |
...
+----------------------------------+---------+
</pre>

<p>Таблицы истории событий для этой конфигурации:</p>
<ul><li><p><code>events_<em><code>xxx</code></em>_history_long</code>, где
<em><code>xxx</code></em> <code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</p></li></ul>

<p>Эта конфигурация собирает историю событий для потока и глобально:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| events_waits_current             | YES     |
| events_waits_history             | YES     |
| events_waits_history_long        | YES     |
| events_stages_current            | YES     |
| events_stages_history            | YES     |
| events_stages_history_long       | YES     |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | YES     |
| events_transactions_current      | YES     |
| events_transactions_history      | YES     |
| events_transactions_history_long | YES     |
...
+----------------------------------+---------+
</pre>

<p>Таблицы истории событий для этой конфигурации:</p>
<ul><li><p><code>events_<em><code>xxx</code></em>_history</code>, где
<em><code>xxx</code></em> <code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</li>

<li><code>events_<em><code>xxx</code></em>_history_long</code>, где
<em><code>xxx</code></em> <code>waits</code>, <code>stages</code>,
<code>statements</code>, <code>transactions</code>.</p></li></ul>

<h4><a name="performance-schema-filtering-names"></a>23.2.3.9.
Обозначение инструментов или потребителей для операций фильтрации</h4>
<p>Имена, данные для того, чтобы фильтровать операции, могут быть столь
определенными или общими как требуется. Чтобы указать на единственный
инструмент или потребителя, определите его имя полностью:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'NO'
                 WHERE NAME = 'wait/synch/mutex/myisammrg/MYRG_INFO::mutex';
mysql&gt; UPDATE setup_consumers
                 SET ENABLED = 'NO' WHERE NAME = 'events_waits_current';
</pre>

<p>Чтобы определить группу инструментов или потребителей, используйте
образец, который соответствует членам группы:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'NO'
                 WHERE NAME LIKE 'wait/synch/mutex/%';
mysql&gt; UPDATE setup_consumers SET ENABLED = 'NO'
                 WHERE NAME LIKE '%history%';
</pre>

<p>Если Вы используете образец, это должно быть выбрано так, чтобы
соответствовало всем элементам, представляющим интерес и никаким другим.
Например, чтобы выбрать все инструменты ввода/вывода файла, лучше
использовать образец, который включает всю инструментальную приставку имени:
<pre>
... WHERE NAME LIKE 'wait/io/file/%';
</pre>

<p>Образец <code>'%/file/%'</code> будет соответствовать другим инструментам,
у которых есть компонент <code>'/file/'</code>
где угодно в имени. Еще менее подходящий образец <code>'%file%'</code>, так
как это будет соответствовать инструментам с <code>'file'</code>
где угодно в имени, например,
<code>wait/synch/mutex/sql/LOCK_des_key_file</code>.</p>

<p>Чтобы проверить, какой инструмент или потребитель вызывают соответствие
образцу, выполните простой тест:
<pre>
mysql&gt; SELECT NAME FROM setup_instruments
                 WHERE NAME LIKE '<em><code>pattern</code></em>';
mysql&gt; SELECT NAME FROM setup_consumers
                 WHERE NAME LIKE '<em><code>pattern</code></em>';
</pre>

<h4><a name="performance-schema-instrumentation-checking"></a>23.2.3.10.
Определение, что инструментовано</h4>
<p>Всегда возможно определить то, что инструментует Performance Schema,
проверяя <a href="#setup-instruments-table"><code>setup_instruments
</code></a>. Например, чтобы видеть, какие связанные с файлом события
инструментованы для механизма хранения <code>InnoDB</code>,
используйте этот запрос:
<pre>
mysql&gt; SELECT * FROM setup_instruments
                   WHERE NAME LIKE 'wait/io/file/innodb/%';
+--------------------------------------+---------+-------+
| NAME                                 | ENABLED | TIMED |
+--------------------------------------+---------+-------+
| wait/io/file/innodb/innodb_data_file | YES     | YES   |
| wait/io/file/innodb/innodb_log_file  | YES     | YES   |
| wait/io/file/innodb/innodb_temp_file | YES     | YES   |
+--------------------------------------+---------+-------+
</pre>

<p>Исчерпывающее описание того, что инструментовано, не дано в этой
документации, по нескольким причинам:</p>
<ul><li><p>То, что инструментовано, является кодом сервера. Изменения этого
кода часто происходят, что также затрагивает набор инструментов.</li>

<li>Непрактично перечислять все инструменты, потому что их сотни.</li>
<li>Как описано ранее, возможно узнать, запрашивая таблицу
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. Эта информация всегда современна для Вашей версии MySQL, а также
включает инструментовку для плагинов, которые Вы, возможно, установили,
не являющихся частью основного сервера.
Они могут использоваться автоматизированными инструментами.</p></li></ul>

<h2><a name="performance-schema-queries"></a>23.3. Запросы Performance Schema
</h2>
<p>Предварительная фильтрация ограничивает, какая информация о событии
собрана и независима от любого особого пользователя. В отличие от этого,
постфильтрация выполнена отдельными пользователями с помощью запросов с
соответствующим <code>WHERE</code>, который ограничивает, какая информация о
событии должна быть выбрана из событий, доступных
после предварительной фильтрации.</p>

<p>В <a href="#performance-schema-pre-filtering">разделе 23.2.3.3
</a>, пример показал, как предварительно фильтровать для инструментов файла.
Если таблицы событий содержат информацию о файле и не о файле, постфильтрация
другой способ видеть информацию только для событий файла. Добавьте
<code>WHERE</code> к запросам, чтобы ограничить выбор событий соответственно:
<pre>
mysql&gt; SELECT THREAD_ID, NUMBER_OF_BYTES FROM events_waits_history
                 WHERE EVENT_NAME LIKE 'wait/io/file/%' AND
                 NUMBER_OF_BYTES IS NOT NULL;
+-----------+-----------------+
| THREAD_ID | NUMBER_OF_BYTES |
+-----------+-----------------+
|  11       |  66             |
|  11       |  47             |
|  11       | 139             |
|   5       |  24             |
|   5       | 834             |
+-----------+-----------------+
</pre>

<p>Большинство таблиц Performance Schema имеют индекс, который предоставляет
оптимизатору доступ к планам выполнения кроме полного сканирования таблицы.
Они также улучшают работу для связанных объектов, таких как представления
<a href="sys.htm"><code>sys</code></a> schema, которые используют те таблицы.
Для получения дополнительной информации см.
<a href="optimiz.htm#performance-schema-optimization">раздел 9.2.5</a>.</p>

<h2><a name="performance-schema-instrument-naming"></a>23.4.
Соглашения о присвоении имен инструментам Performance Schema</h2>
<p>Инструментальное имя состоит из последовательности компонентов, отделенных
<code>'/'</code> Имена в качестве примера:
<pre>
wait/io/file/myisam/log
wait/io/file/mysys/charset
wait/lock/table/sql/handler
wait/synch/cond/mysys/COND_alarm
wait/synch/cond/sql/BINLOG::update_cond
wait/synch/mutex/mysys/BITMAP_mutex
wait/synch/mutex/sql/LOCK_delete
wait/synch/rwlock/sql/Query_cache_query::lock
stage/sql/closing tables
stage/sql/Sorting result
statement/com/Execute
statement/com/Query
statement/sql/create_table
statement/sql/lock_tables
errors
</pre>

<p>У инструментального пространства имен есть подобная дереву структура.
Компоненты инструментального имени слева направо обеспечивают прогрессию от
более общего до более определенного. Число компонентов, которые имеет имя,
зависит от типа инструмента.</p>

<p>Интерпретация данного компонента зависит от компонентов слева от этого.
Например, <code>myisam</code> появляется в обоих из следующих имен, но
<code>myisam</code> в первом имени связан с вводом/выводом файла, тогда как
во втором это связано с инструментом синхронизации:
<pre>
wait/io/file/myisam/log
wait/synch/cond/myisam/MI_SORT_INFO::cond
</pre>

<p>Инструментальные имена состоят из приставки со структурой, определенной
выполнением Performance Schema и суффиксом, определенным разработчиком,
осуществляющим инструментальный код. Высокоуровневый компонент
инструментальной приставки указывает на тип инструмента. Этот компонент также
определяет, который таймер событий в <code>setup_timers</code> относится к
инструменту. Для части приставки инструментальных имен верхний уровень
указывает на тип инструмента.</p>

<p>Часть суффикса инструментальных имен прибывает непосредственно из кода для
инструментов. Суффиксы могут включать уровни, такие как:</p>
<ul><li><p>Название главного компонента (модуль сервера такой, как
<code>myisam</code>, <code>innodb</code>,
<code>mysys</code> или <code>sql</code>) или имя плагина.</li>

<li>Название переменной в коде, в форме
<em><code>XXX</code></em> (глобальная переменная) или
<code><em><code>CCC</code></em>::<em><code>MMM</code></em></code>
(член <em><code>MMM</code></em> класса <em><code>CCC</code></em>). Примеры:
<code>COND_thread_cache</code>, <code>THR_LOCK_myisam</code>,
<code>BINLOG::LOCK_index</code>.</p></li></ul>

<p><span><strong>Высокоуровневые инструментальные компоненты
</strong></span></p>
<ul><li><p><code>idle</code>: Инструментованный неактивный случай. У этого
инструмента нет никаких дальнейших компонентов.</li>

<li><code>error</code>: Инструментованный ошибочный случай. У этого
инструмента нет никаких дальнейших компонентов.</li>
<li><code>memory</code>: Инструментованное событие памяти.</li>

<li><code>stage</code>: Инструментованное событие этапа.</li>
<li><code>statement</code>: Инструментованное событие запроса.</li>
<li><code>transaction</code>: Инструментованное событие транзакции. У этого
инструмента нет никаких дальнейших компонентов.</li>
<li><code>wait</code>: Инструментованное событие ожидания.</p></li></ul>

<p><span><strong>Неактивные инструментальные компоненты</strong></span></p>
<p>Инструмент <code>idle</code> используется для неактивных событий, которые
Performance Schema производит как обсуждено в описании столбца
<code>socket_instances.STATE</code> в
<a href="#socket-instances-table">разделе 23.9.3.5</a>.</p>

<p><span><strong>Ошибочные инструментальные компоненты</strong></span></p>
<p>Инструмент <code>error</code> указывает, собрать ли информацию для ошибок
сервера и предупреждений. Этот инструмент включен по умолчанию. Столбец
<code>TIMED</code> для строки <code>error</code> в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a> является неподходящим, потому что информация синхронизации не собрана.
</p>

<p><span><strong>Инструментальные компоненты памяти</strong></span></p>
<p>Большинство инструментов памяти отключено по умолчанию и может быть
включено или отключено динамически, обновляя столбец
<code>ENABLED</code> соответствующих инструментов в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. У инструментов памяти есть названия формы
<code>memory/<em><code>code_area</code></em>/<em><code>instrument_name</code>
</em></code>, где <em><code>code_area</code></em> такое значение, как
<code>sql</code> или <code>myisam</code>, а
<em><code>instrument_name</code></em> инструментальная деталь.</p>

<p>Инструменты с приставкой <code>memory/performance_schema/</code>
показывают, сколько памяти выделено для внутренних буферов в Performance
Schema. Инструменты <code>memory/performance_schema/</code> встроены, всегда
включаются, и не могут быть отключены при запуске или во время выполнения.
Встроенные инструменты памяти выведены на экран только в таблице
<a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a>.</p>

<p><span><strong>Инструментальные компоненты этапа</strong></span></p>
<p>У инструментов этапа есть названия формы
<code>stage/<em><code>code_area</code></em>/<em><code>stage_name</code></em>
</code>, где <em><code>code_area</code></em> такое значение, как
<code>sql</code> или <code>myisam</code>, а <em><code>stage_name</code></em>
указывает на этап обработки запроса, такой как <code>Sorting result</code>
или <code>Sending data</code>. Этапы соответствуют статусам потока,
выведенным на экран <a href="sql.htm#show-processlist"><code>SHOW
PROCESSLIST</code></a> или видимым в
<a href="inform.htm#processlist-table"><code>INFORMATION_SCHEMA.PROCESSLIST
</code></a>.</p>

<p><span><strong>Инструментальные Компоненты запроса</strong></span></p>
<ul><li><p><code>statement/abstract/*</code>: Абстрактный инструмент для
операций запроса. Абстрактные инструменты используются во время ранних стадий
классификации запроса прежде, чем точный тип запроса будет известен, затем
изменены на более определенный инструмент запроса, когда тип известен. Для
описания этого процесса см.
<a href="#performance-schema-statement-tables">раздел 23.9.6</a>.
</li>

<li><code>statement/com</code>: Инструментованная работа команды. У них есть
соответствие имен <code>COM_<em><code>xxx</code></em></code>
(см. файлы <code>mysql_com.h</code> и <code>sql/sql_parse.cc</code>).
Например, инструменты <code>statement/com/Connect</code> и
<code>statement/com/Init DB</code> соответствуют командам
<code>COM_CONNECT</code> и <code>COM_INIT_DB</code>.</li>

<li><code>statement/scheduler/event</code>: Единственный инструмент, чтобы
отследить все события, запущенные планировщиком событий. Этот инструмент
играет роль, когда запланированный случай начинает выполняться.</li>

<li><code>statement/sp</code>: Инструментованная внутренняя инструкция
выполнена сохраненной программой. Например, инструменты
<code>statement/sp/cfetch</code> и <code>statement/sp/freturn</code>
применяются для получения курсора и возврата из функции.</li>

<li><code>statement/sql</code>: Инструментованная работа запроса SQL.
Например, инструменты <code>statement/sql/create_db</code> и
<code>statement/sql/select</code> используются для
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a> и
<a href="sql.htm#select"><code>SELECT</code></a>.</p></li></ul>

<p><span><strong>Инструментальные компоненты ожидания</strong></span></p>
<ul><li><p><code>wait/io</code></p>
<p>Инструментованная работа ввода/вывода.</p>

<ul><li><p><code>wait/io/file</code></p>
<p>Инструментованная работа ввода/вывода файла. Для файлов ожидание
является временем ожидания завершения работы файла (например, вызов
<code>fwrite()</code>). Из-за кэширования физический ввод/вывод файла на
диске не может произойти в пределах этого требования.</li>

<li><code>wait/io/socket</code></p>
<p>Инструментованная работа сокета. У инструментов сокета есть названия формы
<code>wait/io/socket/sql/<em><code>socket_type</code></em></code>. У сервера
есть сокеты для каждого сетевого протокола, который он поддерживает. У
инструментов, связанных с сокетами TCP/IP или соединений файла сокета Unix,
есть значение <em><code>socket_type</code></em>
<code>server_tcpip_socket</code> или <code>server_unix_socket</code>,
соответственно. Когда сокет слушания обнаруживает соединение, сервер передает
соединение с новым сокетом, которым управляет отдельный поток. У инструмента
для нового потока соединения есть значение
<em><code>socket_type</code></em> <code>client_connection</code>.</li>

<li><code>wait/io/table</code></p>
<p>Инструментованная табличная работа ввода/вывода. Они включают доступы на
уровне строки к постоянным базовым или временным таблицам. Операции, которые
затрагивают строки, являются получением, вставками, обновлениями и удалениями.
Для представления ожидание связано с базовыми таблицами, на
которые ссылается представление.</p>

<p>В отличие от большинства ожиданий, табличный ввод/вывод может включать
другое ожидание. Например, табличный ввод/вывод мог бы включать ввод/вывод
файла или операции памяти. Таким образом,
<a href="#events-waits-current-table"><code>events_waits_current
</code></a> для таблицы обычно имеет две строки.</p>

<p>Некоторые операции строки могли бы вызвать многократный табличный
ввод/вывод. Например, вставка могла бы активировать триггер,
который вызывает обновление.</p></li></ul></li>

<li><p><code>wait/lock</code></p>
<p>Инструментованная работа блокировки.</p>
<ul><li><p><code>wait/lock/table</code></p>
<p>Инструментованная блокировка таблицы.</li>

<li><code>wait/lock/metadata/sql/mdl</code></p>
<p>Инструментованные метаданные блокировки (отключены по умолчанию).
</p></li></ul></li>

<li><p><code>wait/synch</code></p>
<p>Инструментованный объект синхронизации. Для объектов синхронизации
время <code>TIMER_WAIT</code> включает количество заблокированное времени,
потраченное пытаясь приобрести блокировку на объекте, если это было.</p>

<ul><li><p><code>wait/synch/cond</code></p>
<p>Условие используется одним потоком, чтобы сигнализировать другим потокам,
что что-то, чего они ждали, произошло. Если единственный поток ждал условия,
он может проснуться и возобновить выполнение. Если несколько потоков ждали,
они могут все проснуться и конкурировать за ресурс, которого они ждали.</li>

<li><code>wait/synch/mutex</code></p>
<p>Объект взаимного исключения используется, чтобы разрешить доступ к ресурсу
(такому, как раздел выполнимого кода), препятствуя другим потокам
получить доступ к ресурсу.</li>

<li><code>wait/synch/rwlock</code></p>
<p>Объект <a href="glossary.htm#glos_rw_lock">блокировки чтения-записи</a>
используется, чтобы блокировать определенную переменную для доступа,
предотвращая ее использование другими потоками. Совместно используемая
блокировка чтения может быть приобретена одновременно многими потоками.
Исключительная блокировка записи может быть приобретена только одним потоком
за один раз.</li>

<li><code>wait/synch/sxlock</code></p>
<p>Совместно используемо-исключительная (SX) блокировка тип объекта
блокировки <a href="glossary.htm#glos_rw_lock">rwlock</a>, который
обеспечивает доступ на запись к общему ресурсу, разрешая непоследовательные
чтения другим потокам.</p></li></ul></li></ul>

<h2><a name="performance-schema-status-monitoring"></a>23.5.
Контроль состояния Performance Schema</h2>
<p>Есть несколько переменных состояния, связанных с Performance Schema:
<pre>
mysql&gt; SHOW STATUS LIKE 'perf%';
+-----------------------------------------------+-------+
| Variable_name                                 | Value |
+-----------------------------------------------+-------+
| Performance_schema_accounts_lost              | 0     |
| Performance_schema_cond_classes_lost          | 0     |
| Performance_schema_cond_instances_lost        | 0     |
| Performance_schema_digest_lost                | 0     |
| Performance_schema_file_classes_lost          | 0     |
| Performance_schema_file_handles_lost          | 0     |
| Performance_schema_file_instances_lost        | 0     |
| Performance_schema_hosts_lost                 | 0     |
| Performance_schema_locker_lost                | 0     |
| Performance_schema_memory_classes_lost        | 0     |
| Performance_schema_metadata_lock_lost         | 0     |
| Performance_schema_mutex_classes_lost         | 0     |
| Performance_schema_mutex_instances_lost       | 0     |
| Performance_schema_nested_statement_lost      | 0     |
| Performance_schema_program_lost               | 0     |
| Performance_schema_rwlock_classes_lost        | 0     |
| Performance_schema_rwlock_instances_lost      | 0     |
| Performance_schema_session_connect_attrs_lost | 0     |
| Performance_schema_socket_classes_lost        | 0     |
| Performance_schema_socket_instances_lost      | 0     |
| Performance_schema_stage_classes_lost         | 0     |
| Performance_schema_statement_classes_lost     | 0     |
| Performance_schema_table_handles_lost         | 0     |
| Performance_schema_table_instances_lost       | 0     |
| Performance_schema_thread_classes_lost        | 0     |
| Performance_schema_thread_instances_lost      | 0     |
| Performance_schema_users_lost                 | 0     |
+-----------------------------------------------+-------+
</pre>

<p>Переменные состояния Performance Schema предоставляют информацию об
инструментовке, которая не могла быть загружена или создана из-за ограничений
памяти. У названий этих переменных есть несколько форм:</p>

<ul><li><p><code>Performance_schema_<em><code>xxx</code></em>_classes_lost
</code> указывает сколько инструментов типа <em><code>xxx</code></em>
не могли быть загружены.</li>

<li><code>Performance_schema_<em><code>xxx</code></em>_instances_lost</code>
указывает, сколько экземпляров объекта <em><code>xxx</code></em>
не могло быть создано.</li>

<li><code>Performance_schema_<em><code>xxx</code></em>_handles_lost</code>
указывает, сколько экземпляров объекта <em><code>xxx</code></em>
не могло быть открыто.</li>
<li><code>Performance_schema_locker_lost</code> указывает, сколько событий
<span>потеряны</span> или не зарегистрированы.</p></li></ul>

<p>Например, если mutex инструментован в источнике сервера, но сервер не
может выделить память для инструментовки во время выполнения, это увеличивает
<a href="#statvar_Performance_schema_mutex_classes_lost"><code>
Performance_schema_mutex_classes_lost</code></a>. Здесь mutex все еще
функционирует как объект синхронизации (то есть, сервер продолжает
функционировать обычно), но характеристики для этого не будут собраны. Если
инструмент может быть выделен, он может использоваться для того, чтобы
инициализировать инструментованные mutex случаи. Для единичного mutex, такого
как глобальный mutex, будет только один случай. У других mutex есть случай на
соединение или страницу в различных кэшах и буферах данных, таким образом,
число случаев изменяется в течение долгого времени. Увеличение максимального
количества соединений или максимального размера некоторых буферов увеличит
максимальное количество случаев, которые могли бы быть выделены сразу. Если
сервер не может создать инструментованный mutex случай, он увеличивает
<a href="#statvar_Performance_schema_mutex_instances_lost"><code>
Performance_schema_mutex_instances_lost</code></a>.</p>

<p>Предположите, что следующие условия выполнены:</p>
<ul><li><p>Сервер был запущен с опцией
<a href="#sysvar_performance_schema_max_mutex_classes"><code>
--performance_schema_max_mutex_classes=200</code></a>
и таким образом имеет пространство для 200 инструментов mutex.</li>

<li>150 mutex инструментов уже были загружены.</li>
<li>Плагин <code>plugin_a</code> содержит 40 инструментов mutex.</li>
<li>Плагин <code>plugin_b</code> содержит 20 инструментов mutex.</li></ul>

<p>Сервер выделяет mutex инструменты для плагинов в зависимости от того,
в скольких они нуждаются и сколько доступно, как иллюстрировано
следующей последовательностью запросов:
<pre>
INSTALL PLUGIN plugin_a
</pre>

<p>Сервер теперь имеет 150+40 = 190 mutex.
<pre>
UNINSTALL PLUGIN plugin_a;
</pre>

<p>У сервера все еще есть 190 инструментов. Все исторические данные,
произведенные сменным кодом, являются все еще доступными, но новые события
для инструментов не собраны.
<pre>
INSTALL PLUGIN plugin_a;
</pre>

<p>Сервер обнаруживает, что эти 40 инструментов уже определены,
таким образом, никакие новые инструменты не создаются, и ранее назначенные
внутренние буферы памяти снова использованы.
У сервера все еще есть 190 инструментов.
<pre>
INSTALL PLUGIN plugin_b;
</pre>

<p>Сервер имеет пространство для 200-190 = 10 инструментов (в этом случае
классы mutex) и видит, что плагин содержит 20 новых инструментов. 10
инструментов загружены, а 10 <span>потеряны</span>.
<a href="#statvar_Performance_schema_mutex_classes_lost"><code>
Performance_schema_mutex_classes_lost</code></a> указывает на
число потерянных инструментов:
<pre>
mysql&gt; SHOW STATUS LIKE "perf%mutex_classes_lost";
+---------------------------------------+-------+
| Variable_name                         | Value |
+---------------------------------------+-------+
| Performance_schema_mutex_classes_lost | 10    |
+---------------------------------------+-------+
1 row in set (0.10 sec)
</pre>

<p>Инструментовка все еще работает и собирает (частичные) данные для
<code>plugin_b</code>.</p>
<p>Когда сервер не может создать mutex инструмент, эти результаты происходят:
</p>

<ul><li><p>Никакая строка для инструмента не вставлена в
<a href="#setup-instruments-table"><code>
setup_instruments</code></a>.</li>

<li><a href="#statvar_Performance_schema_mutex_classes_lost"><code>
Performance_schema_mutex_classes_lost</code></a> растет на 1.</li>
<li><a href="#statvar_Performance_schema_mutex_instances_lost">
<code>Performance_schema_mutex_instances_lost</code></a> не изменяется.
Когда инструмент mutex не создается, он не может использоваться, чтобы
создать инструментованные случаи mutex позже.</p></li></ul>

<p>Этот пример относится ко всем типам инструментов, не только mutex.</p>
<p>Значение <a href="#statvar_Performance_schema_mutex_classes_lost">
<code>Performance_schema_mutex_classes_lost</code></a> больше 0
может произойти в двух случаях:</p>

<ul><li><p>Чтобы сохранить несколько байтов памяти, Вы запускаете сервер с
<a href="#sysvar_performance_schema_max_mutex_classes"><code>
--performance_schema_max_mutex_classes=<em><code>N</code></em></code></a>,
где <em><code>N</code></em> меньше, чем значение по умолчанию. Значение по
умолчанию выбрано, чтобы быть достаточным, чтобы загрузить все плагины,
обеспеченные в дистрибутиве MySQL, но это может быть уменьшено, если
некоторые плагины никогда не загружаются. Например, Вы могли бы хотеть не
загружать некоторые из механизмов хранения.</li>

<li>Вы загружаете имеющий отношение к третьей стороне плагин, который
инструментован для Performance Schema, но не учитываете требования к памяти
инструментовки плагина, когда Вы запускаете сервер. Поскольку это прибывает
от третьей стороны, инструментальное потребление памяти этого механизма не
составляется в значении по умолчанию, выбранном для
<a href="#sysvar_performance_schema_max_mutex_classes"><code>
performance_schema_max_mutex_classes</code></a>.</p>

<p>Если у сервера недостаточно ресурсов для инструментов плагина, и Вы
явно не выделяете больше, используя
<a href="#sysvar_performance_schema_max_mutex_classes"><code>
--performance_schema_max_mutex_classes=<em><code>N</code></em></code></a>,
загрузка плагина приводит к проблемам.</p></li></ul>

<p>Если значение, выбранное для
<a href="#sysvar_performance_schema_max_mutex_classes"><code>
performance_schema_max_mutex_classes</code></a> является слишком маленьким,
ни о какой ошибке не сообщают в журнале ошибок и нет никакого отказа во время
выполнения. Однако, контент таблиц в <code>performance_schema</code>
пропустит события. Переменная состояния
<a href="#statvar_Performance_schema_mutex_classes_lost">
<code>Performance_schema_mutex_classes_lost</code></a> единственный видимый
знак указать, что некоторые события были удалены внутренне из-за
отказа создать инструменты.</p>

<p>Если инструмент не потерян, он известен Performance Schema
и используется, инструментуя случаи. Например,
<code>wait/synch/mutex/sql/LOCK_delete</code> имя mutex инструмента в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. Этот единственный инструмент используется, создавая mutex в коде (в
<code>THD::LOCK_delete</code>), однако, много случаев mutex необходимы, когда
сервер работает. В этом случае <code>LOCK_delete</code> mutex для соединения
(<code>THD</code>), так что, если у сервера есть 1000 соединений, есть 1000
потоков и 1000 инструментованных случаев <code>LOCK_delete</code> mutex
(<code>THD::LOCK_delete</code>).</p>

<p>Если сервер не имеет пространства  для инструментованного mutexes всех
этих 1000, некоторые mutex создаются с инструментовкой, а некоторые создаются
без инструментовки. Если сервер может создать только 800 случаев, 200 случаев
потеряны. Сервер продолжает работать, но увеличивает
<a href="#statvar_Performance_schema_mutex_instances_lost"><code>
Performance_schema_mutex_instances_lost</code></a> на 200, чтобы указать, что
случаи не могли быть созданы.</p>

<p>Значение <a href="#statvar_Performance_schema_mutex_instances_lost">
<code>Performance_schema_mutex_instances_lost</code></a> больше 0
может произойти, когда код инициализирует больше mutex во время выполнения,
чем было выделено для
<a href="#sysvar_performance_schema_max_mutex_instances"><code>
--performance_schema_max_mutex_instances=<em><code>N</code></em></code></a>.
</p>

<p>-Нижняя строка это если
<a href="sql.htm#show-status"><code>SHOW STATUS LIKE 'perf%'</code></a>
говорит, что ничто не было потеряно (все значения - ноль), Исполнительные
данные точны и могут быть использованы. Если что-то было потеряно, данные
неполные, и Performance Schema не могла сделать запись всех данных.
В этом случае переменная <code>Performance_schema_<em><code>xxx</code></em>
_lost</code> указывает на проблемную область.</p>

<p>Могло бы быть уместно в некоторых случаях вызвать преднамеренный
инструментальный сбой. Например, если Вы не заботитесь о характеристиках
ввода/вывода файла, Вы можете запустить сервер со всеми параметрами
Performance Schema, связанных с вводом/выводом файла, установленными в 0.
Никакая память не будет выделена для связанных с файлом классов, случаев
или дескрипторов, и все события файла будут потеряны.</p>

<p>Надо использовать <a href="sql.htm#show-engine"><code>SHOW ENGINE
PERFORMANCE_SCHEMA STATUS</code></a>, чтобы просмотреть внутреннюю работу
кода Performance Schema:
<pre>
mysql&gt; SHOW ENGINE PERFORMANCE_SCHEMA STATUS\G
...
*************************** 3. row ***************************
  Type: performance_schema
  Name: events_waits_history.size
Status: 76
*************************** 4. row ***************************
  Type: performance_schema
  Name: events_waits_history.count
Status: 10000
*************************** 5. row ***************************
  Type: performance_schema
  Name: events_waits_history.memory
Status: 760000
...
*************************** 57. row ***************************
  Type: performance_schema
  Name: performance_schema.memory
Status: 26459600
...
</pre>

<p>Это запрос предназначен, чтобы помочь DBA понять эффекты, которые
различные опции Performance Schema оказывают на требования к памяти. Для
описания полевых значений см.
<a href="sql.htm#show-engine">раздел 14.7.5.15</a>.</p>

<h2><a name="performance-schema-atom-molecule-events"></a>23.6.
События атома и молекулы Performance Schema</h2>
<p>Для табличного случая ввода/вывода обычно есть две строки в
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>. Например, получение строки могло бы привести к строкам как эти:
<pre>
Row# EVENT_NAME                TIMER_START TIMER_END
---- ----------                ----------- ---------
   1 wait/io/file/myisam/dfile 10001       10002
   2 wait/io/table/sql/handler 10000       NULL
</pre>

<p>Получение строки вызывает чтение файла. В примере табличный случай
ввода/вывода запускался перед случаем ввода/вывода файла, но не закончился
(Значение <code>TIMER_END</code> <code>NULL</code>). Случай ввода/вывода
файла <span>вложен</span> в пределах табличного случая ввода/вывода.</p>

<p>Это происходит, потому что, в отличие от <span>атомного</span> события
(mutex или ввода/вывода файла), табличные события ввода/вывода
<span>молекулярные</span> и включают (перекрывают) другие события. В
In <a href="#events-waits-current-table"><code>events_waits_current
</code></a> у табличного случая ввода/вывода обычно есть две строки:</p>

<ul><li><p>Одна строка для ожидания нового табличного ввода/вывода.</li>
<li>Одна строка для нового случая ожидания любого вида.</p></li></ul>
<p>Обычно, но не всегда, случай ожидания отличается от табличного
случая ввода/вывода. Поскольку каждый вспомогательный случай завершается, он
исчезает из <a href="#events-waits-current-table"><code>
events_waits_current</code></a>. В этом пункте, пока начинается следующий
вспомогательный случай, табличный ввод/вывод также новее
ожидания любого вида.</p>

<h2><a name="performance-schema-statement-digests"></a>23.7.
Обзоры запроса Performance Schema</h2>
<p>Сервер MySQL способен к поддержанию информации об обзоре запроса.
Процесс переваривания преобразовывает запрос SQL к нормализованной форме и
вычисляет значение хеша для результата. Нормализация разрешает запросы,
которые подобны, сгруппировать и суммировать, чтобы выставить информацию о
типах запросов, которые выполняет сервер и то, как часто они происходят.
Этот раздел описывает, как нормализация запросы происходит и как это
может быть полезно.</p>

<p>Переваривание происходит на уровне SQL независимо от того, доступна ли
Performance Schema, чтобы у других функций сервера, таких как плагины
перезаписи запроса был доступ к обзорам запроса.</p>

<p>В Performance Schema запрос вовлекает эти компоненты:</p>
<ul><li><p>Потребитель <code>statement_digest</code> в
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
управляет, поддерживает ли Performance Schema информацию об обзоре.</li>

<li>Таблицы запроса событий
(<a href="#events-statements-current-table"><code>
events_statements_current</code></a>,
<a href="#events-statements-history-table"><code>
events_statements_history</code></a> и
<a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a>) имеют столбцы, которые содержат
обзоры и соответствующие значения хеша обзора:</p>

<ul><li><p><code>DIGEST_TEXT</code> текст нормализованного обзора запроса.
</li>
<li><code>DIGEST</code> значение хеша MD5 обзора.</p></li></ul>

<p>Максимальное пространство, доступное для вычисления обзора, составляет
1024 байта по умолчанию. Это значение может быть изменено при запуске
сервера, устанавливая переменную
<a href="#sysvar_performance_schema_max_digest_length"><code>
performance_schema_max_digest_length</code></a>.</li>

<li>У таблиц запроса событий также есть столбец <code>SQL_TEXT</code>,
который содержит оригинальный запрос SQL. Максимальное пространство,
доступное для отображнеия запроса, составляет 1024 байта по умолчанию. Это
значение может быть изменено при запуске сервера, устанавливая переменную
<a href="#sysvar_performance_schema_max_sql_text_length">
<code>performance_schema_max_sql_text_length</code></a>.</li>

<li>Таблица <a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a> предоставляет соединенную
информацию об обзоре запроса.</p></li></ul>

<p>Нормализация преобразовывает текст запроса к более стандартизированному
строковому представлению обзора, которое сохраняет структуру общего
утверждения, удаляя информацию, не важную для структуры:</p>

<ul><li><p>Сохранены идентификаторы объекта, такие как имена
баз данных и таблиц.</li>
<li>Буквальные значения преобразованы в маркеры параметра. Нормализованный
запрос не сохраняет информацию, такую как имена, пароли, даты и т.д.</li>
<li>Комментарии удалены и пробелы скорректированы.</p></li></ul>

<p>Рассмотрите эти запросы:
<pre>
SELECT * FROM orders WHERE customer_id=10 AND quantity &gt; 20
SELECT * FROM orders WHERE customer_id = 20 AND quantity &gt; 100
</pre>

<p>Чтобы нормализовать эти запросы, Performance Schema
заменяет значения данных <code>?</code> и корректирует пробелы.
Оба запроса приводят к той же самой нормализованной форме и таким
образом считаются подобными:
<pre>
SELECT * FROM orders WHERE customer_id = ? AND quantity &gt; ?
</pre>

<p>Нормализованный запрос содержит меньше информации, но является все еще
представительным для оригинального запроса. У других подобных запросов,
у которых есть различные сравнительные значения, есть та же
самая нормализованная форма.</p>

<p>Теперь рассмотрите эти запросы:
<pre>
SELECT * FROM customers WHERE customer_id = 1000
SELECT * FROM orders WHERE customer_id = 1000
</pre>

<p>В этом случае запросы не <span>подобны</span>. Идентификаторы объекта
отличаются, таким образом, запросы приводят к
различным нормализованным формам:
<pre>
SELECT * FROM customers WHERE customer_id = ?
SELECT * FROM orders WHERE customer_id = ?
</pre>

<p>Если нормализация производит запрос, который превышает пространство,
доступное в буфере обзора, текст кончается с <span>...</span>.
Длинные запросы, которые отличаются только по части, которая происходит после
<span>...</span>, как полагают, являются подобными. Рассмотрите эти запросы:
<pre>
SELECT * FROM mytable WHERE cola = 10 AND colb = 20
SELECT * FROM mytable WHERE cola = 10 AND colc = 20
</pre>

<p>Если сокращение было правильным, после <code>AND</code>
у обоих запросов была бы эта нормализованная форма:
<pre>
SELECT * FROM mytable WHERE cola = ? AND ...
</pre>

<p>В этом случае различие во втором имени столбца потеряно, и
оба запросы считаются подобными.</p>
<p>Для каждого нормализованного запроса Performance Schema
вычисляет значение обзора хеша и хранит запрос и его значение хеша MD5 в
столбцах <code>DIGEST_TEXT</code> и <code>DIGEST</code> таблиц событий
запросов (<a href="#events-statements-current-table"><code>
events_statements_current</code></a>,
<a href="#events-statements-history-table"><code>
events_statements_history</code></a> и
<a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a>). Кроме того, информация для
запросов с теми же самыми значениями <code>SCHEMA_NAME</code> и
<code>DIGEST</code> соединена в таблице
<a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a>. Performance Schema использует
значения хеша MD5, потому что они быстры, чтобы вычислить и иметь
благоприятное статистическое распределение,
которое минимизирует столкновения.</p>

<p>Сводная таблица обзора запросов обеспечивает профиль запросов, выполненных
сервером. Это показывает, какие виды запросов приложение выполняет и как
часто. Разработчик приложений может использовать эту информацию вместе с
другой информацией в таблице, чтобы оценить технические характеристики
приложения. Например, столбцы таблицы, которые показывают время ожидания,
время блокировки или использование индекса, могут выделить типы запросов,
которые неэффективны. Это дает понимание разработчика, каким частям
приложения необходимо уделять внимание.</p>

<p><a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a> имеет фиксированный размер,
так что, когда это становится полным, запросы, которые имеют
<code>SCHEMA_NAME</code> и <code>DIGEST</code> не соответствующие
существующим значениям в таблице, сгруппированы в специальной строке с
<code>SCHEMA_NAME</code> и <code>DIGEST</code> <code>NULL</code>.
Это разрешает всем запросым быть посчитанными. Однако, если специальная
строка составляет существенный процент выполненных запросов, могло бы быть
желательно увеличить размер сводной таблицы, устанавливая переменную
<a href="#sysvar_performance_schema_digests_size"><code>
performance_schema_digests_size</code></a> к большему значению при запуске
сервера. Если не задано значение
<a href="#sysvar_performance_schema_digests_size"><code>
performance_schema_digests_size</code></a>, Performance Schema использует
значение при запуске.</p>

<p>Переменная <a href="#sysvar_performance_schema_max_digest_length">
<code>performance_schema_max_digest_length</code></a> определяет максимальное
количество байтов, доступных в буфере обзора для вычисления обзора.
Однако, длина отображения обзоров может быть больше, чем доступный размер
буфера из-за кодирования компонентов запросы, таких как ключевые слова и
буквальные значения в буфере обзора. Следовательно, значения, выбранные из
столбца <code>DIGEST_TEXT</code> таблиц событий запросов, может казаться,
превышает <a href="#sysvar_performance_schema_max_digest_length">
<code>performance_schema_max_digest_length</code></a>.</p>

<p>Для приложений, которые производят очень длинные запросы, которые
отличаются только в конце, увеличение
<a href="#sysvar_performance_schema_max_digest_length"><code>
performance_schema_max_digest_length</code></a> позволяет вычисление
обзоров, которые отличают запросы, которые иначе соединились бы к тому же
самому обзору. Наоборот, уменьшение
<a href="#sysvar_performance_schema_max_digest_length"><code>
performance_schema_max_digest_length</code></a>
заставляет сервер посвящать меньше памяти хранению обзора, но увеличивает
вероятность более длинных запросов, соединяющихся к тому же самому обзору.
Администраторы должны иметь в виду, что большие значения приводят к
соответственно увеличенным требованиям к памяти, особенно для рабочих
нагрузок, которые вовлекают большие количества одновременных сеансов
(<a href="#sysvar_performance_schema_max_digest_length"><code>
performance_schema_max_digest_length</code></a> байт выделено на сеанс).</p>

<p>Чтобы оценить объем памяти, используемый для хранения запроса SQL
и вычисления обзора, используйте <code>SHOW ENGINE PERFORMANCE_SCHEMA STATUS
</code> или эти инструменты:
<pre>
mysql&gt; SELECT NAME FROM setup_instruments
                 WHERE NAME LIKE '%.sqltext';
+------------------------------------------------------------------+
| NAME                                                             |
+------------------------------------------------------------------+
| memory/performance_schema/events_statements_history.sqltext      |
| memory/performance_schema/events_statements_current.sqltext      |
| memory/performance_schema/events_statements_history_long.sqltext |
+------------------------------------------------------------------+

mysql&gt; SELECT NAME FROM setup_instruments
                 WHERE NAME LIKE 'memory/performance_schema/%.tokens';
+----------------------------------------------------------------------+
| NAME                                                                 |
+----------------------------------------------------------------------+
| memory/performance_schema/events_statements_history.tokens           |
| memory/performance_schema/events_statements_current.tokens           |
| memory/performance_schema/events_statements_summary_by_digest.tokens |
| memory/performance_schema/events_statements_history_long.tokens      |
+----------------------------------------------------------------------+
</pre>

<h2><a name="performance-schema-table-characteristics"></a>23.8.
Общие табличные характеристики Performance Schema</h2>
<p>Название базы данных <code>performance_schema</code> в
нижнем регистре, как названия таблиц в пределах этого. Запросы должны
определить имена в нижнем регистре.</p>

<p>Много таблиц в <code>performance_schema</code>
только для чтения и не могут быть изменены:
<pre>
mysql&gt; TRUNCATE TABLE setup_instruments;
ERROR 1683 (HY000): Invalid performance_schema usage.
</pre>

<p>У некоторых из таблиц установки есть столбцы, которые могут быть изменены,
чтобы затронуть работу Performance Schema. Некоторые также разрешают строкам
быть вставленными или удаленными. Усечение разрешено для очистки собранных
событий, таким образом, <a href="sql.htm#truncate-table"><code>TRUNCATE TABLE
</code></a> может использоваться на таблицах, содержащих эти виды информации,
такие как таблицы, названные с приставкой <code>events_waits_</code>.</p>

<p>Сводные таблицы могут быть усечены с
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>.
Вообще, эффект состоит в том, чтобы сбросить сводные столбцы к 0 или
<code>NULL</code>, а не удалить строки. Это позволяет очистить собранные
значения. Это могло бы быть полезно, например, после того, как Вы произвели
изменение конфигурации во время выполнения. Исключения к этому поведению
усечения отмечены в отдельных разделах сводной таблицы.</p>

<p>Привилегии что касается других баз данных и таблиц:</p>
<ul><li><p>Чтобы получать данные из таблиц <code>performance_schema</code>,
Вы должны иметь привилегию <a href="security.html#priv_select"><code>SELECT
</code></a>.</li>

<li>Чтобы изменить те столбцы, которые могут быть изменены, Вы должны иметь
привилегию <a href="security.html#priv_update"><code>UPDATE</code></a>.</li>
<li>Чтобы усечь таблицы, которые могут быть усечены, Вы должны иметь
привилегию <a href="security.html#priv_drop"><code>DROP</code></a>.
</p></li></ul>

<h2><a name="performance-schema-table-descriptions"></a>23.9.
Описания таблиц Performance Schema</h2>
<p>Таблицы в <code>performance_schema</code> могут быть
сгруппированы следующим образом:</p>

<ul><li><p>Таблицы установки. Эти таблицы используются, чтобы
сконфигурировать и вывести на экран контролирующие характеристики.</li>
<li>Таблицы текущих событий.
<a href="#events-waits-current-table"><code>events_waits_current
</code></a> содержит новый случай для каждого потока. Другие подобные таблицы
содержат текущие события на разных уровнях иерархии событий:
<a href="#events-stages-current-table"><code>events_stages_current
</code></a> для событий этапа,
<a href="#events-statements-current-table"><code>
events_statements_current</code></a> для событий запросов и
<a href="#events-transactions-current-table"><code>
events_transactions_current</code></a> для операционных событий.</li>

<li>Таблицы истории. Эти таблицы имеют ту же самую структуру как таблицы
текущих событий, но содержат больше строк. Например, для события ожидания
<a href="#events-waits-history-table"><code>events_waits_history
</code></a> содержит новые 10 событий для потока.
<a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a> содержит новые 10000 событий. Другие
подобные таблицы существуют для этапа, запросов и операционных историй.</p>

<p>Чтобы изменить размеры таблиц истории, установите соответствующие
системные переменные при запуске сервера. Например, чтобы установить размеры
таблиц истории ожидания событий, установите
<a href="#sysvar_performance_schema_events_waits_history_size">
<code>performance_schema_events_waits_history_size</code></a> и
<a href="#sysvar_performance_schema_events_waits_history_long_size">
<code>performance_schema_events_waits_history_long_size</code></a>.</li>

<li>Сводные таблицы. Эти таблицы содержат информацию, соединенную по группам
событий, включая те, от которых отказались в таблицах истории.</li>
<li>Таблицы случая. Эти таблицы документируют, какие типы объектов
инструментованы. Инструментованный объект, когда используется сервером,
производит случай. Эти таблицы обеспечивают имена событий и примечания
или информацию о статусе.</li>
<li>Разные таблицы. Они не попадают ни в одну из других табличных групп.
</p></li></ul>

<h3><a name="performance-schema-table-index"></a>23.9.1. Индекс таблиц
Performance Schema</h3>
<p>Следующая таблица приводит каждую таблицу Performance Schema
и обеспечивает краткое описание каждой.</p>

<a name="performance-schema-tables-table"></a><p><b>Таблица 23.1.
Таблицы Performance Schema</b></p>
<table border="1">
<thead><tr><th scope="col">Имя</th><th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row"><a href="#accounts-table"><code>accounts
</code></a></td><td>Статистика соединений на учетную запись клиента</td></tr>
<tr><td scope="row"><a href="#cond-instances-table"><code>
cond_instances</code></a></td><td>Случаи синхронизации объекта</td></tr>
<tr><td scope="row"><a href="#data-lock-waits-table"><code>
data_lock_waits</code></a></td><td>Отношения ожидания блокировки данных</td>
</tr>
<tr><td scope="row"><a href="#data-locks-table"><code>data_locks
</code></a></td><td>Блокировки данных полученные и запрошенные</td></tr>
<tr><td scope="row"><a href="#error-summary-tables"><code>
events_errors_summary_by_account_by_error</code></a></td><td>
Ошибки по кодам ошибки на учетную запись</td></tr>
<tr><td scope="row"><a href="#error-summary-tables"><code>
events_errors_summary_by_host_by_error</code></a></td><td>
Ошибки по кодам ошибки на хост</td></tr>
<tr><td scope="row"><a href="#error-summary-tables"><code>
events_errors_summary_by_thread_by_error</code></a></td><td>
Ошибки по кодам ошибки на хост</td></tr>
<tr><td scope="row"><a href="#error-summary-tables"><code>
events_errors_summary_by_user_by_error</code></a></td><td>
Ошибки по кодам ошибки на хост</td></tr>
<tr><td scope="row"><a href="#error-summary-tables"><code>
events_errors_summary_global_by_error</code></a></td><td>
Ошибки по кодам ошибки</td></tr>
<tr><td scope="row"><a href="#events-stages-current-table"><code>
events_stages_current</code></a></td><td>Текущие события этапа</td></tr>
<tr><td scope="row"><a href="#events-stages-history-table"><code>
events_stages_history</code></a></td><td>
Новые события этапа для каждого потока</td></tr>
<tr><td scope="row"><a href="#events-stages-history-long-table">
<code>events_stages_history_long</code></a></td><td>
Новые события этапа повсюду</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_stages_summary_by_account_by_event_name</code></a></td><td>
События этапа на учетную запись и имя событий</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_stages_summary_by_host_by_event_name</code></a></td><td>
События этапа по именам хоста и событий</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_stages_summary_by_thread_by_event_name</code></a></td><td>
Этап ожидания на имя события и поток</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_stages_summary_by_user_by_event_name</code></a></td><td>
События этапа на имя пользователя и события</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_stages_summary_global_by_event_name</code></a></td><td>
Этап ожидания на имя события</td></tr>
<tr><td scope="row"><a href="#events-statements-current-table">
<code>events_statements_current</code></a></td><td>
Текущие события запроса</td></tr>
<tr><td scope="row"><a href="#events-statements-history-table">
<code>events_statements_history</code></a></td><td>
Новые события запроса для каждого потока</td></tr>
<tr><td scope="row"><a href="#events-statements-history-long-table">
<code>events_statements_history_long</code></a></td><td>
Новые события запроса повсюду</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_statements_summary_by_account_by_event_name</code></a></td><td>
События запроса на учетную запись и имя события</td></tr>
<tr><td scope="row"><a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a></td><td>
События запроса на значение схемы и обзора</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_statements_summary_by_host_by_event_name</code></a></td><td>
События запроса на имя хоста и события</td></tr>
<tr><td scope="row"><a href="#statement-summary-tables"><code>
events_statements_summary_by_program</code></a></td><td>
События запроса на сохраненную программу</td></tr>
<tr><td scope="row"><a href="#statement-summary-tables"><code>
events_statements_summary_by_thread_by_event_name</code></a></td><td>
События запроса на поток и имя события</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_statements_summary_by_user_by_event_name</code></a></td><td>
События запроса на имя пользователя и события</td></tr>
<tr><td scope="row"><a href="#statement-summary-tables"><code>
events_statements_summary_global_by_event_name</code></a></td><td>
События запроса на имя события</td></tr>
<tr><td scope="row"><a href="#events-transactions-current-table">
<code>events_transactions_current</code></a></td><td>
Текущие операционные события</td></tr>
<tr><td scope="row"><a href="#events-transactions-history-table">
<code>events_transactions_history</code></a></td><td>
Новые операционные события для каждого потока</td></tr>
<tr><td scope="row">
<a href="#events-transactions-history-long-table">
<code>events_transactions_history_long</code></a></td><td>
Новые операционные события повсюду</td></tr>
<tr><td scope="row"><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_account_by_event_name</code></a></td><td>
Операционные события на учетную запись и имя события</td></tr>
<tr><td scope="row"><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_host_by_event_name</code></a></td><td>
Операционные события на имя хоста и события</td></tr>
<tr><td scope="row"><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_thread_by_event_name</code></a></td><td>
Операционные события на поток и имя события</td></tr>
<tr><td scope="row"><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_user_by_event_name</code></a></td><td>
Операционные события на имя пользователя и события</td></tr>
<tr><td scope="row"><a href="#transaction-summary-tables"><code>
events_transactions_summary_global_by_event_name</code></a></td><td>
Операционные события на имя события</td></tr>
<tr><td scope="row"><a href="#events-waits-current-table"><code>
events_waits_current</code></a></td><td>События ожидания потока</td></tr>
<tr><td scope="row"><a href="#events-waits-history-table"><code>
events_waits_history</code></a></td><td>Новые события ожидания каждого потока
</td></tr>
<tr><td scope="row"><a href="#events-waits-history-long-table">
<code>events_waits_history_long</code></a></td><td>
Новые события ожидания повсюду</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_waits_summary_by_account_by_event_name</code></a></td><td>
События ожидания на имя событий и учетную запись</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_waits_summary_by_host_by_event_name</code></a></td><td>
События ожидания на имя события и хоста</td></tr>
<tr><td scope="row"><a href="#wait-summary-tables"><code>
events_waits_summary_by_instance</code></a></td><td>
События ожидания на случай</td></tr>
<tr><td scope="row"><a href="#wait-summary-tables"><code>
events_waits_summary_by_thread_by_event_name</code></a></td><td>
События ожидания на имя события и поток</td></tr>
<tr><td scope="row"><a href="#stage-summary-tables"><code>
events_waits_summary_by_user_by_event_name</code></a></td><td>
События ожидания на имя события и пользователя</td></tr>
<tr><td scope="row"><a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a></td><td>
События ожидания по именам</td></tr>
<tr><td scope="row"><a href="#file-instances-table"><code>
file_instances</code></a></td><td>Случаи файла</td></tr>
<tr><td scope="row"><a href="#file-summary-tables"><code>
file_summary_by_event_name</code></a></td><td>События файла на имя события
</td></tr>
<tr><td scope="row"><a href="#file-summary-tables"><code>
file_summary_by_instance</code></a></td><td>События файла на случай файла
</td></tr>
<tr><td scope="row">
<a href="#performance-schema-status-variable-tables">
<code>global_status</code></a></td><td>Глобальные переменные состояния
</td></tr>
<tr><td scope="row">
<a href="#performance-schema-system-variable-tables">
<code>global_variables</code></a></td><td>Глобальные системные переменные
</td></tr>
<tr><td scope="row"><a href="#host-cache-table"><code>host_cache
</code></a></td><td>Информация от внутреннего кэша узла</td></tr>
<tr><td scope="row"><a href="#hosts-table"><code>hosts</code></a>
</td><td>Статистика соединения на имя хоста клиента</td></tr>
<tr><td scope="row"><a href="#memory-summary-tables"><code>
memory_summary_by_account_by_event_name</code></a></td><td>
Операции памяти на учетную запись и имя события</td></tr>
<tr><td scope="row"><a href="#memory-summary-tables"><code>
memory_summary_by_host_by_event_name</code></a></td><td>
Операции памяти на узел и имя события</td></tr>
<tr><td scope="row"><a href="#memory-summary-tables"><code>
memory_summary_by_thread_by_event_name</code></a></td><td>
Операции памяти на поток и имя события</td></tr>
<tr><td scope="row"><a href="#memory-summary-tables"><code>
memory_summary_by_user_by_event_name</code></a></td><td>
Операции памяти на пользователя и имя события</td></tr>
<tr><td scope="row"><a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a></td><td>
Операции памяти глобально на имя события</td></tr>
<tr><td scope="row"><a href="#metadata-locks-table"><code>
metadata_locks</code></a></td><td>Метаданные и запросы блокировки</td></tr>
<tr><td scope="row"><a href="#mutex-instances-table"><code>
mutex_instances</code></a></td><td>Синхронизация экземпляров объекта Mutex
</td></tr>
<tr><td scope="row"><a href="#objects-summary-global-by-type-table">
<code>objects_summary_global_by_type</code></a></td><td>Резюме объекта</td>
</tr>
<tr><td scope="row"><a href="#performance-timers-table"><code>
performance_timers</code></a></td><td>Какие таймеры событий доступны</td></tr>
<tr><td scope="row"><a href="#prepared-statements-instances-table">
<code>prepared_statements_instances</code></a></td><td>
Готовые запросы и статистика</td></tr>
<tr><td scope="row">
<a href="#replication-applier-configuration-table"><code>
replication_applier_configuration</code></a></td><td>
Параметры конфигурации для транзакции на ведомом устройстве</td></tr>
<tr><td scope="row"><a href="#replication-applier-status-table">
<code>replication_applier_status</code></a></td><td>
Текущий статус транзакции на ведомом устройстве</td></tr>
<tr><td scope="row">
<a href="#replication-applier-status-by-coordinator-table">
<code>replication_applier_status_by_coordinator</code></a></td><td>
Статус SQL или координатора потока</td></tr>
<tr><td scope="row">
<a href="#replication-applier-status-by-worker-table"><code>
replication_applier_status_by_worker</code></a></td>
<td>Состояние рабочего потока (пусто, если ведомое устройство
не является мультипоточным)</td></tr>
<tr><td scope="row">
<a href="#replication-connection-configuration-table"><code>
replication_connection_configuration</code></a></td><td>
Параметры конфигурации для того, чтобы соединиться с ведущим устройством
</td></tr>
<tr><td scope="row"><a href="#replication-connection-status-table">
<code>replication_connection_status</code></a></td><td>
Текущий статус соединения с ведущим устройством</td></tr>
<tr><td scope="row"><a href="#rwlock-instances-table"><code>
rwlock_instances</code></a></td><td>Синхронизация блокировки объекта</td></tr>
<tr><td scope="row"><a href="#session-account-connect-attrs-table">
<code>session_account_connect_attrs</code></a></td><td>
Атрибуты соединения для текущего сеанса</td></tr>
<tr><td scope="row"><a href="#session-connect-attrs-table"><code>
session_connect_attrs</code></a></td><td>Атрибуты соединения для всех сеансов
</td></tr>
<tr><td scope="row">
<a href="#performance-schema-status-variable-tables"><code>
session_status</code></a></td><td>Переменные состояния для текущего сеанса
</td></tr>
<tr><td scope="row">
<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a></td><td>Системные переменные для текущего сеанса
</td></tr>
<tr><td scope="row"><a href="#setup-actors-table"><code>
setup_actors</code></a></td><td>Как инициализировать контроль для новых
потоков переднего плана</td></tr>
<tr><td scope="row"><a href="#setup-consumers-table"><code>
setup_consumers</code></a></td><td>Потребители, для которых может быть
сохранена информация о событии</td></tr>
<tr><td scope="row"><a href="#setup-instruments-table"><code>
setup_instruments</code></a></td><td>Классы инструментованных объектов, для
которых могут быть собраны события</td></tr>
<tr><td scope="row"><a href="#setup-objects-table"><code>
setup_objects</code></a></td><td>Какие объекты должны быть проверены</td></tr>
<tr><td scope="row"><a href="#setup-timers-table"><code>
setup_timers</code></a></td><td>Текущий таймер событий</td></tr>
<tr><td scope="row"><a href="#socket-instances-table"><code>
socket_instances</code></a></td><td>Активные соединения</td></tr>
<tr><td scope="row"><a href="#socket-summary-tables"><code>
socket_summary_by_event_name</code></a></td><td>
Ожидание сокета и ввод/вывод на имя события</td></tr>
<tr><td scope="row"><a href="#socket-summary-tables"><code>
socket_summary_by_instance</code></a></td><td>
Ожидание сокета и ввод/вывод на случай</td></tr>
<tr><td scope="row">
<a href="#performance-schema-status-variable-summary-tables"><code>
status_by_account</code></a></td><td>Переменные состояния сеанса
на учетную запись</td></tr>
<tr><td scope="row">
<a href="#performance-schema-status-variable-summary-tables"><code>
status_by_host</code></a></td><td>Переменные состояния сеанса на имя хоста
</td></tr>
<tr><td scope="row">
<a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a></td><td>Переменные состояния сеанса за сеанс
</td></tr>
<tr><td scope="row">
<a href="#performance-schema-status-variable-summary-tables">
<code>status_by_user</code></a></td><td>Переменные состояния сеанса
на имя пользователя</td></tr>
<tr><td scope="row"><a href="#table-handles-table"><code>
table_handles</code></a></td><td>Табличные блокировки и запросы блокировок
</td></tr>
<tr><td scope="row">
<a href="#table-io-waits-summary-by-index-usage-table"><code>
table_io_waits_summary_by_index_usage</code></a></td><td>
Табличный ввод/вывод, ждущий индекс</td></tr>
<tr><td scope="row">
<a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a></td><td>
Табличный ввод/вывод на таблицу</td></tr>
<tr><td scope="row">
<a href="#table-lock-waits-summary-by-table-table"><code>
table_lock_waits_summary_by_table</code></a></td><td>
Табличная блокировка на таблицу</td></tr>
<tr><td scope="row"><a href="#threads-table"><code>threads</code>
</a></td><td>Информация о потоках сервера</td></tr>
<tr><td scope="row">
<a href="#performance-schema-user-variable-tables"><code>
user_variables_by_thread</code></a></td><td>
Определяемые пользователем переменные на поток</td></tr>
<tr><td scope="row"><a href="#users-table"><code>users</code></a>
</td><td>Статистика соединения на имя пользователя клиента</td></tr>
<tr><td scope="row">
<a href="#performance-schema-system-variable-tables"><code>
variables_by_thread</code></a></td><td>Системные переменные сеанса за сеанс
</td></tr>
<tr><td scope="row"><a href="#variables-info-table"><code>
variables_info</code></a></td><td>Как системные переменные были
последний раз установлены</td></tr></tbody></table>

<h3><a name="performance-schema-setup-tables"></a>23.9.2.
Таблицы установки Performance Schema</h3>
<p>Таблицы установки предоставляют информацию о текущей инструментовке и
позволяют контролирующей конфигурации быть измененной. Поэтому некоторые
столбцы в этих таблицах могут быть изменены, если Вы имеете привилегию
<a href="security.html#priv_update"><code>UPDATE</code></a>.</p>

<p>Использование таблиц, а не отдельных переменных для информации об
установке обеспечивает высокую степень гибкости в изменении конфигурации
Performance Schema. Например, Вы можете использовать единственный запрос со
стандартным синтаксисом SQL, чтобы произвести многократные
одновременные изменения конфигурации.</p>

<p>Эти таблицы установки доступны:</p>
<ul><li><p><a href="#setup-actors-table"><code>setup_actors</code>
</a>: Как инициализировать контроль для новых потоков переднего плана.</li>

<li><a href="#setup-consumers-table"><code>setup_consumers</code>
</a>: Места назначения, в которые информацию о событии можно послать.</li>
<li><a href="#setup-instruments-table"><code>setup_instruments
</code></a>: Классы инструментованных объектов, для которых могут
быть собраны события.</li>

<li><a href="#setup-objects-table"><code>setup_objects</code></a>:
Какие объекты должны быть проверены.</li>
<li><a href="#setup-timers-table"><code>setup_timers</code></a>:
Текущий таймер событий.</p></li></ul>

<h4><a name="setup-actors-table"></a>23.9.2.1. Таблица setup_actors</h4>
<p>Таблица <a href="#setup-actors-table"><code>setup_actors</code>
</a> содержит информацию, которая определяет, позволить ли контролировать и
журналировать исторические события для новых потоков сервера переднего плана
(потоки, связанные с соединениями клиента). У этой таблицы есть максимальный
размер 100 строк по умолчанию. Чтобы изменить табличный размер,
измените системную переменную
<a href="#sysvar_performance_schema_setup_actors_size"><code>
performance_schema_setup_actors_size</code></a> при запуске сервера.</p>

<p>Для каждого нового потока переднего плана Performance Schema
соответствует пользователю и узлу в строке таблицы
<a href="#setup-actors-table"><code>setup_actors</code></a>.
Если строка этой таблицы соответствует, значения ее столбцов
<code>ENABLED</code> и <code>HISTORY</code> используются, чтобы установить
столбцы <code>INSTRUMENTED</code> и <code>HISTORY</code>, соответственно,
в строках таблицы <a href="#threads-table"><code>threads</code></a>
для потока. Это позволяет управлять инструментовкой и журналированием
исторических событий, которое будет применено выборочно для узла,
пользователя или учетной записи (комбинация узла и пользователя). Если нет
соответствия, <code>INSTRUMENTED</code> и <code>HISTORY</code>
для потока установлены в <code>NO</code>.</p>

<p>Для фоновых потоков нет никакого связанного пользователя.
<code>INSTRUMENTED</code> и <code>HISTORY</code> <code>YES</code>
по умолчанию и <a href="#setup-actors-table"><code>setup_actors
</code></a> не проверяется.</p>

<p>Начальное содержание <a href="#setup-actors-table"><code>
setup_actors</code></a> соответствует любой комбинации пользователя и узла,
таким образом контроль и сбор исторических событий включены по умолчанию для
всех потоков переднего плана:
<pre>
mysql&gt; SELECT * FROM setup_actors;
+------+------+------+---------+---------+
| HOST | USER | ROLE | ENABLED | HISTORY |
+------+------+------+---------+---------+
| %    | %    | %    | YES     | YES     |
+------+------+------+---------+---------+
</pre>

<p>Модификации <a href="#setup-actors-table"><code>setup_actors
</code></a> вступают в силу только при создании потоков переднего плана
после модификации, на существующие потоки изменения не влияют.
Чтобы затронуть существующие потоки, измените столбцы
<code>INSTRUMENTED</code> и <code>HISTORY</code> строк таблицы
<a href="#threads-table"><code>threads</code></a>.</p>

<p>У таблицы <a href="#setup-actors-table"><code>setup_actors
</code></a> есть эти столбцы:</p>
<ul><li><p><code>HOST</code></p>
<p>Имя хоста. Это должно быть буквальным именем или
<code>'%'</code> означает <span>любой хост</span>.</li>

<li><code>USER</code></p>
<p>Имя пользователя. Это должно быть буквальным именем или
<code>'%'</code> означает <span>любой пользователь</span>.</li>

<li><code>ROLE</code></p>
<p>Не используется.</li>
<li><code>ENABLED</code></p>
<p>Включить ли инструментовку для потоков переднего плана, соответствующих
строке. Значения <code>YES</code> или <code>NO</code>.</li>

<li><code>HISTORY</code></p>
<p>Зарегистрировать ли исторические события для потоков переднего плана,
соответствующих строке. Значения <code>YES</code> или <code>NO</code>.
</p></li></ul>

<p>У таблицы <a href="#setup-actors-table"><code>setup_actors
</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>, <code>USER</code>,
<code>ROLE</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
разрешен для <a href="#setup-actors-table"><code>setup_actors
</code></a>. Удаляет строки.</p>

<h4><a name="setup-consumers-table"></a>23.9.2.2. Таблица setup_consumers</h4>
<p>Таблица <a href="#setup-consumers-table"><code>setup_consumers
</code></a> приводит типы потребителей, для которых может быть сохранена
информация о событии и которые включены:
<pre>
mysql&gt; SELECT * FROM setup_consumers;
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_stages_current            | NO      |
| events_stages_history            | NO      |
| events_stages_history_long       | NO      |
| events_statements_current        | YES     |
| events_statements_history        | YES     |
| events_statements_history_long   | NO      |
| events_transactions_current      | NO      |
| events_transactions_history      | NO      |
| events_transactions_history_long | NO      |
| events_waits_current             | NO      |
| events_waits_history             | NO      |
| events_waits_history_long        | NO      |
| global_instrumentation           | YES     |
| thread_instrumentation           | YES     |
| statements_digest                | YES     |
+----------------------------------+---------+
</pre>

<p>Модификации <a href="#setup-consumers-table"><code>
setup_consumers</code></a> действуют немедленно.</p>
<p>У таблицы <a href="#setup-consumers-table"><code>
setup_consumers</code></a> есть эти столбцы:</p>

<ul><li><p><code>NAME</code></p>
<p>Потребительское имя.</li>

<li><code>ENABLED</code></p>
<p>Включен ли потребитель. Значение <code>YES</code> или <code>NO</code>.
Этот столбец может быть изменен. Если Вы отключаете потребителя, сервер не
тратит время на добавление информацию о событии к этому.</p></li></ul>

<p>У <a href="#setup-consumers-table"><code>setup_consumers</code>
</a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
не разрешен для <a href="#setup-consumers-table"><code>
setup_consumers</code></a>.</p>

<h4><a name="setup-instruments-table"></a>23.9.2.3. Таблица setup_instruments
</h4>
<p><a href="#setup-instruments-table"><code>setup_instruments
</code></a> приводит классы инструментованных объектов, для которых могут
быть собраны события:
<pre>
mysql&gt; SELECT * FROM setup_instruments;
+---------------------------------------------------+---------+-------+
| NAME                                              | ENABLED | TIMED |
+---------------------------------------------------+---------+-------+
...
| wait/synch/mutex/sql/LOCK_global_read_lock        | YES     | YES   |
| wait/synch/mutex/sql/LOCK_global_system_variables | YES     | YES   |
| wait/synch/mutex/sql/LOCK_lock_db                 | YES     | YES   |
| wait/synch/mutex/sql/LOCK_manager                 | YES     | YES   |
...
| wait/synch/rwlock/sql/LOCK_grant                  | YES     | YES   |
| wait/synch/rwlock/sql/LOGGER::LOCK_logger         | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_connect       | YES     | YES   |
| wait/synch/rwlock/sql/LOCK_sys_init_slave         | YES     | YES   |
...
| wait/io/file/sql/binlog                           | YES     | YES   |
| wait/io/file/sql/binlog_index                     | YES     | YES   |
| wait/io/file/sql/casetest                         | YES     | YES   |
| wait/io/file/sql/dbopt                            | YES     | YES   |
...
</pre>

<p>Каждый инструмент, добавленный к исходному коду, обеспечивает строку
в этой таблице, даже когда инструментованный код не выполнен. Когда
инструмент включен и запущен, инструментованные случаи создаются, которые
видимы в таблицах <code>*_instances</code>.</p>

<p>Для некоторых инструментов модификации эффективны только при запуске
сервера, изменение их во времени выполнения не имеет никакого эффекта. Это
затрагивает прежде всего mutex, условия и rwlocks в сервере, хотя могут быть
другие инструменты, для которых это истина. Для большинства изменения
вступают в силу сразу.</p>

<p>У <a href="#setup-instruments-table"><code>setup_instruments
</code></a> есть эти столбцы:</p>
<ul><li><p><code>NAME</code></p>
<p>Инструментальное имя. Инструментальные имена могут иметь много частей
и сформировать иерархию, как обсуждено в
<a href="#performance-schema-instrument-naming">разделе 23.4</a>.
События, произведенные из выполнения инструмента, имеют
<code>EVENT_NAME</code>, которое взято от инструментального значения
<code>NAME</code>. У событий действительно нет <span>name</span>,
но это обеспечивает способ связать события с инструментами.</li>

<li><code>ENABLED</code></p>
<p>Включен ли инструмент. Значение <code>YES</code> или <code>NO</code>.
Этот столбец может быть изменен.
Отключенный инструмент не производит событий.</li>

<li><code>TIMED</code></p>
<p>Рассчитан ли инструмент. Этот столбец может быть изменен.</p>
<p>Для инструментов памяти столбец <code>TIMED</code> в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a> проигнорирован, потому что операции памяти не рассчитаны.</p>

<p>Если включенный инструмент не рассчитан, инструментальный код включен,
но таймер нет. События, произведенные инструментом, имеют <code>NULL</code>
для <code>TIMER_START</code>, <code>TIMER_END</code> и
<code>TIMER_WAIT</code>. Это в свою очередь заставляет те значения быть
проигнорированными, вычисляя сумму, минимум, максимум и средние временные
оценки в сводных таблицах.</p></li></ul>

<p>У <a href="#setup-instruments-table"><code>setup_instruments
</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
разрешен для <a href="#setup-instruments-table"><code>
setup_instruments</code></a>.</p>

<h4><a name="setup-objects-table"></a>23.9.2.4. Таблица setup_objects</h4>
<p><a href="#setup-objects-table"><code>setup_objects</code></a>
управляет, контролирует ли Performance Schema особые объекты. У этой таблицы
есть максимальный размер 100 строк по умолчанию. Чтобы изменить табличный
размер, измените переменную
<a href="#sysvar_performance_schema_setup_objects_size">
<code>performance_schema_setup_objects_size</code></a> при запуске сервера.
</p>

<p>Начальное содержание <a href="#setup-objects-table"><code>
setup_objects</code></a> похоже на это:
<pre>
mysql&gt; SELECT * FROM setup_objects;
+-------------+--------------------+-------------+---------+-------+
| OBJECT_TYPE | OBJECT_SCHEMA      | OBJECT_NAME | ENABLED | TIMED |
+-------------+--------------------+-------------+---------+-------+
| EVENT       | mysql              | %           |      NO | NO    |
| EVENT       | performance_schema | %           |      NO | NO    |
| EVENT       | information_schema | %           |      NO | NO    |
| EVENT       | %                  | %           |     YES | YES   |
| FUNCTION    | mysql              | %           |      NO | NO    |
| FUNCTION    | performance_schema | %           |      NO | NO    |
| FUNCTION    | information_schema | %           |      NO | NO    |
| FUNCTION    | %                  | %           |     YES | YES   |
| PROCEDURE   | mysql              | %           |      NO | NO    |
| PROCEDURE   | performance_schema | %           |      NO | NO    |
| PROCEDURE   | information_schema | %           |      NO | NO    |
| PROCEDURE   | %                  | %           |     YES | YES   |
| TABLE       | mysql              | %           |      NO | NO    |
| TABLE       | performance_schema | %           |      NO | NO    |
| TABLE       | information_schema | %           |      NO | NO    |
| TABLE       | %                  | %           |     YES | YES   |
| TRIGGER     | mysql              | %           |      NO | NO    |
| TRIGGER     | performance_schema | %           |      NO | NO    |
| TRIGGER     | information_schema | %           |      NO | NO    |
| TRIGGER     | %                  | %           |     YES | YES   |
+-------------+--------------------+-------------+---------+-------+
</pre>

<p>Модификации действуют немедленно.</p>
<p>Для типов объекта, перечисленных в
<a href="#setup-objects-table"><code>setup_objects</code></a>,
Performance Schema использует таблицу для того, как контролировать их.
Соответствие лбъектов основано на столбцах <code>OBJECT_SCHEMA</code> и
<code>OBJECT_NAME</code>. Объекты, которые не идут ни в какое
сравнение, не проверены.</p>

<p>Эффект конфигурации объекта по умолчанию состоит в том, чтобы
инструментовать все таблицы кроме в
<code>mysql</code>, <code>INFORMATION_SCHEMA</code> и
<code>performance_schema</code>. Таблицы в <code>INFORMATION_SCHEMA</code>
не инструментована независимо от содержания
<a href="#setup-objects-table"><code>setup_objects</code></a>.
Строка <code>information_schema.%</code> просто делает это значение явным.
</p>

<p>Когда Performance Schema checks проверяет на соответствие
<a href="#setup-objects-table"><code>setup_objects</code></a>,
это пытается найти более определенные соответствия сначала. Например, с
таблицей <code>db1.t1</code>, это ищет совпадение для
<code>'db1'</code> и <code>'t1'</code>, потом для
<code>'db1'</code> и <code>'%'</code>, потом для
<code>'%'</code> и <code>'%'</code>. Порядок, в котором соответствие
происходит таков, потому что различные строки
<a href="#setup-objects-table"><code>setup_objects</code></a>
могут иметь отличающиеся <code>ENABLED</code> и <code>TIMED</code>.</p>

<p>Строки могут быть вставлены или удалены из
<a href="#setup-objects-table"><code>setup_objects</code></a>
пользователями с привилегиями <a href="security.html#priv_insert"><code>
INSERT</code></a> или <a href="security.html#priv_delete"><code>DELETE
</code></a> на таблице. Для существующих строк могут быть изменены только
столбцы <code>ENABLED</code> и <code>TIMED</code> пользователями с
привилегией <a href="security.html#priv_update"><code>UPDATE</code></a>.</p>

<p>У <a href="#setup-objects-table"><code>setup_objects</code></a>
есть эти столбцы:</p>
<ul><li><p><code>OBJECT_TYPE</code></p>
<p>Тип объекта для инструментовки. Значение одно из
<code>'EVENT'</code> (событие Event Scheduler),
<code>'FUNCTION'</code> (сохраненная функция),
<code>'PROCEDURE'</code> (хранимая процедура), <code>'TABLE'</code> (базовая
таблица) или <code>'TRIGGER'</code> (триггер).</p>

<p><code>TABLE</code> фильтрует табличные события ввода/вывода
(инструмент <code>wait/io/table/sql/handler</code>) и события блокировки
таблицы (<code>wait/lock/table/sql/handler</code>).</li>

<li><code>OBJECT_SCHEMA</code></p>
<p>Схема, которая содержит объект. Это должно быть буквальным именем или
<code>'%'</code> для <span>любой схемы</span>.</li>

<li><code>OBJECT_NAME</code></p>
<p>Название инструментованного объекта. Это должно быть буквальным именем
или <code>'%'</code> для <span>любого объекта</span>.</li>

<li><code>ENABLED</code></p>
<p>Инструментованы ли события для объекта. Значение <code>YES</code> или
<code>NO</code>. Этот столбец может быть изменен.</li>

<li><code>TIMED</code></p>
<p>Рассчитаны ли события для объекта. Этот столбец может быть изменен.
</p></li></ul>

<p>У <a href="#setup-objects-table"><code>setup_objects</code></a>
есть эти индексы:</p>
<ul><li><p>Индекс на (<code>OBJECT_TYPE</code>,
<code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
разрешен для <a href="#setup-objects-table"><code>setup_objects
</code></a>. Это удаляет строки.</p>

<h4><a name="setup-timers-table"></a>23.9.2.5. Таблица setup_timers</h4>
<p><a href="#setup-timers-table"><code>setup_timers</code></a>
показывает в настоящее время выбираемые таймеры событий:
<pre>
mysql&gt; SELECT * FROM setup_timers;
+-------------+-------------+
| NAME        | TIMER_NAME  |
+-------------+-------------+
| idle        | MICROSECOND |
| wait        | CYCLE       |
| stage       | NANOSECOND  |
| statement   | NANOSECOND  |
| transaction | NANOSECOND  |
+-------------+-------------+
</pre>

<p><code>setup_timers.TIMER_NAME</code> может быть изменено, чтобы выбрать
иной таймер. Значение может быть любым из значений в столбце
<code>performance_timers.TIMER_NAME</code>.</p>

<p>Изменения в <a href="#setup-timers-table"><code>setup_timers
</code></a> действуют немедленно. События, уже происходящие, могут
использовать оригинальный таймер в начале и новый таймер в конце. Чтобы
избежать непредсказуемых результатов после того, как Вы производите изменения
таймера, надо использовать
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> для сброса
статистики Performance Schema.</p>

<p>У <a href="#setup-timers-table"><code>setup_timers</code></a>
есть эти столбцы:</p>
<ul><li><p><code>NAME</code></p>
<p>Тип инструмента, для которого таймер используется.</li>

<li><code>TIMER_NAME</code></p>
<p>Таймер, который относится к инструментальному типу.
Этот столбец может быть изменен.</p></li></ul>

<p>У <a href="#setup-timers-table"><code>setup_timers</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#setup-timers-table"><code>setup_timers
</code></a>.</p>

<h3><a name="performance-schema-instance-tables"></a>23.9.3.
Таблицы случая Performance Schema</h3>
<p>Таблицы случая документируют, какие типы объектов инструментованы. Они
обеспечивают имена событий и примечания или информацию о статусе:</p>

<ul><li><p><a href="#cond-instances-table"><code>cond_instances
</code></a>: Синхронизация условия.</li>
<li><a href="#file-instances-table"><code>file_instances</code>
</a>: Случаи файла.</li>

<li><a href="#mutex-instances-table"><code>mutex_instances</code>
</a>: Синхронизация Mutex.</li>
<li><a href="#rwlock-instances-table"><code>rwlock_instances</code>
</a>: Синхронизация блокировки.</li>

<li><a href="#socket-instances-table"><code>socket_instances</code>
</a>: Активные соединения.</p></li></ul>
<p>Эти таблицы приводят инструментованные объекты синхронизации, файлы и
соединения. Есть три типа объектов синхронизации: <code>cond</code>,
<code>mutex</code> и <code>rwlock</code>. Каждая таблица случая имеет
столбцы <code>EVENT_NAME</code> или <code>NAME</code>, чтобы указать на
инструмент, связанный с каждой строкой. Инструментальные имена могут иметь
много частей и сформировать иерархию, как обсуждено в
<a href="#performance-schema-instrument-naming">разделе 23.4</a>.
</p>

<p>Столбцы <code>mutex_instances.LOCKED_BY_THREAD_ID</code> и
<code>rwlock_instances.WRITE_LOCKED_BY_THREAD_ID</code> чрезвычайно важны для
исследования исполнительных узких мест или тупиков. Для примеров того, как
использовать их с этой целью см.
<a href="#performance-schema-examples">раздел 23.16</a>.</p>

<h4><a name="cond-instances-table"></a>23.9.3.1. Таблица cond_instances</h4>
<p><a href="#cond-instances-table"><code>cond_instances</code></a>
приводит все условия, замеченные Performance Schema в то время, как сервер
выполняется. Условие это механизм синхронизации, используемый в коде, чтобы
сигнализировать, что определенное событие произошло, чтобы поток, ждущий
этого условия, мог возобновить работу.</p>

<p>Когда поток ждет чего-то, имя условия это признак того, чего ждет поток,
но нет никакого непосредственного способа сказать, который другой поток или
потоки вызовет условие.</p>

<p>У <a href="#cond-instances-table"><code>cond_instances</code>
</a> есть эти столбцы:</p>
<ul><li><p><code>NAME</code></p>
<p>Инструментальное имя, связанное с условием.</li>
<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Адрес в памяти об инструментованном условии.</p></li></ul>

<p>У <a href="#cond-instances-table"><code>cond_instances</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#cond-instances-table"><code>cond_instances
</code></a>.</p>

<h4><a name="file-instances-table"></a>23.9.3.2. Таблица file_instances</h4>
<p><a href="#file-instances-table"><code>file_instances</code></a>
приводит все файлы, замеченные Performance Schema, запуская инструментовку
ввода/вывода файла. Если файл на диске никогда не открывался, его не будет в
<a href="#file-instances-table"><code>file_instances</code></a>.
Когда файл удален с диска, он также удален из
<a href="#file-instances-table"><code>file_instances</code></a>.
</p>

<p>У <a href="#file-instances-table"><code>file_instances</code>
</a> есть эти столбцы:</p>
<ul><li><p><code>FILE_NAME</code></p>
<p>Имя файла.</li>

<li><code>EVENT_NAME</code></p>
<p>Инструментальное имя, связанное с файлом.</li>
<li><code>OPEN_COUNT</code></p>
<p>Количество открытых дескрипторов на файле. Если файл был открыт и затем
закрыт, он был открыт 1 раз, но <code>OPEN_COUNT</code> будет 0. Чтобы
перечислить все файлы, в настоящее время открываемые сервером, надо
использовать <code>WHERE OPEN_COUNT &gt; 0</code>.</p></li></ul>

<p>У <a href="#file-instances-table"><code>file_instances</code>
</a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>FILE_NAME</code>).</li>
<li>Индекс на (<code>EVENT_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
не позволен для <a href="#file-instances-table"><code>
file_instances</code></a>.</p>

<h4><a name="mutex-instances-table"></a>23.9.3.3. Таблица mutex_instances</h4>
<p><a href="#mutex-instances-table"><code>mutex_instances</code>
</a> приводит все mutex, замеченные Performance Schema в то время, как сервер
выполняет. mutex это механизм синхронизации, используемый в коде, чтобы
провести в жизнь только тот поток, который в установленный срок может иметь
доступ к некоторому общему ресурсу. Ресурс, как говорят, при этом
является <span>защищенным</span> mutex.</p>

<p>Когда два потока в сервере (например, два пользовательских сеанса,
выполняющие запрос одновременно), действительно должны будут получить доступ
к тому же самому ресурсу (файлу, буферу или некоторой части данных), эти два
потока конкурируют друг против друга так, чтобы первый запрос, который
получит блокировку на mutex, заставил другой запрос ждать, пока первый не
будет сделан и отпирает mutex.</p>

<p>Это потенциально узкое место, именуемое "<span>критический раздел</span>".
Проблема в том, что много потоков вынуждены проходить его строго
последовательно и по одному.</p>

<p>У <a href="#mutex-instances-table"><code>mutex_instances</code>
</a> есть эти столбцы:</p>
<ul><li><p><code>NAME</code></p>
<p>Инструментальное имя, связанное с mutex.</li>

<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Адрес в памяти об инструментованном mutex.</li>
<li><code>LOCKED_BY_THREAD_ID</code></p>
<p>Когда потоку в настоящее время блокировали mutex,
<code>LOCKED_BY_THREAD_ID</code> <code>THREAD_ID</code>
потока блокировки, иначе это <code>NULL</code>.</p></li></ul>

<p>У <a href="#mutex-instances-table"><code>mutex_instances</code>
</a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>NAME</code>).</li>
<li>Индекс на (<code>LOCKED_BY_THREAD_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#mutex-instances-table"><code>mutex_instances
</code></a>.</p>

<p>Для каждого mutex, инструментованного в коде, Performance Schema
предоставляет следующую информацию.</p>
<ul><li><p>Таблица <a href="#setup-instruments-table"><code>
setup_instruments</code></a> приводит название пункта инструментовки, с
приставкой <code>wait/synch/mutex/</code>.</li>

<li>Когда некоторый код создает mutex, строка добавлена к таблице
<a href="#mutex-instances-table"><code>mutex_instances</code></a>.
Столбец <code>OBJECT_INSTANCE_BEGIN</code> свойство, которое
уникально идентифицирует mutex.</li>

<li>Когда поток пытается заблокировать mutex,
<a href="#events-waits-current-table"><code>events_waits_current
</code></a> показывает строку для этого потока, указывая, что он ждет mutex
(в столбце <code>EVENT_NAME</code>) и указание, какой mutex ждут (в столбце
<code>OBJECT_INSTANCE_BEGIN</code>).</li>

<li>Когда поток преуспевает в том, чтобы блокировать mutex:</p>
<ul><li><p><a href="#events-waits-current-table"><code>
events_waits_current</code></a> показывает, что ожидание mutex завершено (в
столбцах <code>TIMER_END</code> и <code>TIMER_WAIT</code>).</li>

<li>Завершенный случай ожидания добавлен к
<a href="#events-waits-history-table"><code>events_waits_history
</code></a> и <a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a>.</li>

<li><a href="#mutex-instances-table"><code>mutex_instances</code>
</a> показывает, что mutex теперь принадлежит потоку
(в столбце <code>THREAD_ID</code>).</p></li></ul></li>

<li><p>Когда поток отпирает mutex,
<a href="#mutex-instances-table"><code>mutex_instances</code></a>
показывает, что у mutex теперь нет никакого владельца
(<code>THREAD_ID</code> <code>NULL</code>).</li>

<li>Когда объект mutex разрушен, соответствующая строка удалена из
<a href="#mutex-instances-table"><code>mutex_instances</code></a>.
</p></li></ul>

<p>Выполняя запросы на обеих из следующих таблиц, контролирующее приложение
или DBA могут обнаружить узкие места или тупики между потоками,
которые вовлекают mutex:</p>

<ul><li><p><a href="#events-waits-current-table"><code>
events_waits_current</code></a>, чтобы видеть, какой mutex ждет поток.</li>
<li><a href="#mutex-instances-table"><code>mutex_instances</code>
</a>, чтобы видеть, какому другому потоку в настоящее
время принадлежит mutex.</p></li></ul>

<h4><a name="rwlock-instances-table"></a>23.9.3.4. Таблица rwlock_instances
</h4>
<p>Таблица <a href="#rwlock-instances-table"><code>rwlock_instances
</code></a> приводит все <a href="glossary.htm#glos_rw_lock">rwlock</a>
(read write lock) случаи, замеченные Performance Schema в то время, как
сервер выполняется. <code>rwlock</code> механизм синхронизации, используемый
в коде, чтобы провести в жизнь то, который поток в установленный срок может
иметь доступ к некоторому общему ресурсу по определенным правилам.
Ресурс, как говорят, является <span>защищенным</span> <code>rwlock</code>.
Доступ совместно использован (у многих потоков может быть блокировка чтения в
то же самое время), исключительный (только у одного потока может быть
блокировка записи в установленный срок) или совместно
используемо-исключительный (у потока может быть блокировка записи, разрешая
непоследовательные чтения другими потоками). Совместно используемый
эксклюзивный доступ иначе известен как <code>sxlock</code> и был введен в
MySQL 5.7, чтобы оптимизировать параллелизм и улучшить масштабируемость
для чтения-записи.</p>

<p>В зависимости от того, сколько потоков просят блокировку, и природы
блокировок, которые требуются, доступ можно или предоставить в совместно
используемом режиме, исключительном режиме, совместно
используемо-исключительном режиме или не предоставить вообще, ожидая сначала
завершения других потоков.</p>

<p>У <a href="#rwlock-instances-table"><code>rwlock_instances
</code></a> есть эти столбцы:</p>
<ul><li><p><code>NAME</code></p>
<p>Инструментальное имя, связанное с блокировкой.</li>

<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Адрес в памяти об инструментованной блокировке.</li>
<li><code>WRITE_LOCKED_BY_THREAD_ID</code></p>
<p>Когда поток в настоящее время имеет <code>rwlock</code> заблокированную в
исключительном (записи) режиме, <code>WRITE_LOCKED_BY_THREAD_ID</code>
<code>THREAD_ID</code> потока блокировки, иначе <code>NULL</code>.</li>

<li><code>READ_LOCKED_BY_COUNT</code></p>
<p>Когда поток в настоящее время имеет <code>rwlock</code> заблокированную в
совместно используемом (чтение) режиме, <code>READ_LOCKED_BY_COUNT</code>
увеличен на 1. Это только счетчик, таким образом, это не может использоваться
непосредственно, чтобы найти, какой поток держит блокировку чтения, но это
может использоваться, чтобы видеть, есть ли чтение на <code>rwlock</code>,
и сколько читателей в настоящее время активно.</p></li></ul>

<p>У <a href="#rwlock-instances-table"><code>rwlock_instances
</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>NAME</code>).</li>
<li>Индекс на (<code>WRITE_LOCKED_BY_THREAD_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#rwlock-instances-table"><code>
rwlock_instances</code></a>.</p>

<p>Выполняя запросы на обеих из следующих таблиц, контролирующее приложение
или DBA могут обнаружить некоторые узкие места или тупики между потоками,
которые вовлекают блокировки:</p>

<ul><li><p><a href="#events-waits-current-table"><code>
events_waits_current</code></a>, чтобы видеть, что
поток ждет <code>rwlock</code>.</li>

<li><a href="#rwlock-instances-table"><code>rwlock_instances</code>
</a>, чтобы видеть который другой поток в настоящее
время имеет <code>rwlock</code>.</p></li></ul>

<p>Есть ограничение: <a href="#rwlock-instances-table"><code>
rwlock_instances</code></a> может использоваться только, чтобы
идентифицировать поток, держащий блокировку записи, но не потоки,
держащие блокировку чтения.</p>

<h4><a name="socket-instances-table"></a>23.9.3.5. Таблица socket_instances
</h4>
<p><a href="#socket-instances-table"><code>socket_instances</code>
</a> обеспечивает снимок в реальном времени активных соединений с сервером
MySQL. Таблица содержит одну строку на TCP/IP или соединение файла сокета
Unix. Информация, доступная в этой таблице, обеспечивает снимок в реальном
времени активных соединений с сервером. Дополнительная информация доступна в
сводных таблицах сокета, включая такую сетевую деятельность, как операции
сокета и число байтов, переданных и полученных, см.
<a href="#socket-summary-tables">раздел 23.9.15.8</a>).
<pre>
mysql&gt; SELECT * FROM socket_instances\G
*************************** 1. row ***************************
 EVENT_NAME: wait/io/socket/sql/server_unix_socket
OBJECT_INSTANCE_BEGIN: 4316619408
THREAD_ID: 1
SOCKET_ID: 16
 IP:
 PORT: 0
STATE: ACTIVE
*************************** 2. row ***************************
 EVENT_NAME: wait/io/socket/sql/client_connection
OBJECT_INSTANCE_BEGIN: 4316644608
THREAD_ID: 21
SOCKET_ID: 39
 IP: 127.0.0.1
 PORT: 55233
STATE: ACTIVE
*************************** 3. row ***************************
 EVENT_NAME: wait/io/socket/sql/server_tcpip_socket
OBJECT_INSTANCE_BEGIN: 4316699040
THREAD_ID: 1
SOCKET_ID: 14
 IP: 0.0.0.0
 PORT: 50603
STATE: ACTIVE
</pre>

<p>У инструментов сокета есть названия формы
<code>wait/io/socket/sql/<em><code>socket_type</code></em></code>
и используются как это:</p>

<ol type="1"><li><p>У сервера есть сокет для каждого сетевого протокола,
который он поддерживает. У инструментов, связанных с сокетами для TCP/IP или
соединений файла сокета Unix, есть <em><code>socket_type</code></em>
<code>server_tcpip_socket</code> или
<code>server_unix_socket</code>, соответственно.</li>

<li>Когда сокет обнаруживает соединение, сервер передает соединение с новым
сокетом, которым управляет отдельный поток. У инструмента для нового потока
соединения есть <em><code>socket_type</code></em>
<code>client_connection</code>.</li>

<li>Когда соединение заканчивается, строка в
<a href="#socket-instances-table"><code>socket_instances</code>
</a>, соответствующая ему удалена.</p></li></ol>

<p>У <a href="#socket-instances-table"><code>socket_instances
</code></a> есть эти столбцы:</p>
<ul><li><p><code>EVENT_NAME</code></p>
<p>Название инструмента <code>wait/io/socket/*</code>, который произвел
случай. Это значение <code>NAME</code> из
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. Инструментальные имена могут иметь многое частей и сформировать
иерархию, как обсуждено в
<a href="#performance-schema-instrument-naming">разделе 23.4</a>.
</li>

<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Этот столбец уникально идентифицирует сокет.
Значение адрес объекта в памяти.</li>

<li><code>THREAD_ID</code></p>
<p>Внутренний идентификатор потока, назначенный сервером. Каждым сокетом
управляет единственный поток, таким образом, каждый сокет может быть
отображен на поток, который может быть отображен на процесс сервера.</li>

<li><code>SOCKET_ID</code></p>
<p>Внутренний дескриптор, назначенный на сокет.</li>
<li><code>IP</code></p>
<p>IP-адрес клиента. Значение может быть адресом IPv4, IPv6 или
пустым, чтобы указать на соединение файла сокета Unix.</li>

<li><code>PORT</code></p>
<p>Номер порта TCP/IP в диапазоне от 0 до 65535.</li>
<li><code>STATE</code></p>
<p>Состояние сокета <code>IDLE</code> или <code>ACTIVE</code>.
Ожидания для активных сокетов прослежены, используя соответствующий
инструмент сокета. Ожидания для неактивных сокетов прослежены,
используя инструмент <code>idle</code>.</p>

<p>Сокет неактивен, если ждет запроса от клиента. Когда сокет становится
неактивным, строка событий в <a href="#socket-instances-table">
<code>socket_instances</code></a> отслеживает переход сокета от состояния
<code>ACTIVE</code> в <code>IDLE</code>. Значение <code>EVENT_NAME</code>
остается <code>wait/io/socket/*</code>, но синхронизация для инструмента
приостановлена. Вместо этого случай произведен в таблице
<a href="#events-waits-current-table"><code>events_waits_current
</code></a> с <code>EVENT_NAME</code> <code>idle</code>.</p>

<p>Когда следующий запрос получен, <code>idle</code> заканчивается,
сокета переходит от <code>IDLE</code> к <code>ACTIVE</code>, а
синхронизация инструмента сокета восстанавливается.</p></li></ul>

<p>У <a href="#socket-instances-table"><code>socket_instances
</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>

<li>Индекс на (<code>THREAD_ID</code>).</li>
<li>Индекс на (<code>SOCKET_ID</code>).</li>
<li>Индекс на (<code>IP</code>, <code>PORT</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#socket-instances-table"><code>
socket_instances</code></a>.</p>

<p>Значение комбинации столбца <code>IP:PORT</code> идентифицирует
соединение. Это значение комбинации используется в столбце
the <code>OBJECT_NAME</code> таблицы <code>events_waits_<em><code>xxx</code>
</em></code>, чтобы идентифицировать соединение, из которого
прибывают события сокета:</p>

<ul><li><p>Для сокета домена Unix
(<code>server_unix_socket</code>) порт 0, IP <code>''</code>.</li>
<li>Для соединений клиента через домен Unix
(<code>client_connection</code>) порт 0, IP <code>''</code>.</li>

<li>Для сокета сервера TCP/IP (<code>server_tcpip_socket</code>), порт
всегда основной порт (например, 3306), IP всегда <code>0.0.0.0</code>.</li>
<li>Для соединений клиента через TCP/IP (<code>client_connection</code>)
порт тот, что сервер назначает, но никогда 0. IP указывает IP удаленного узла
(<code>127.0.0.1</code> или <code>::1</code> для localhost).</p></li></ul>

<h3><a name="performance-schema-wait-tables"></a>23.9.4.
Таблицы ожидания событий Performance Schema</h3>
<p>Эти таблицы хранят ожидание события:</p>

<ul><li><p><a href="#events-waits-current-table"><code>
events_waits_current</code></a>: Поток ждет события.</li>
<li><a href="#events-waits-history-table"><code>
events_waits_history</code></a>: Новые события ожидания каждого потока.</li>

<li><a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a>: Новые события ожидания повсюду.
</p></li></ul>

<p>Следующие разделы описывают те таблицы. Есть также сводные таблицы
совокупной информации о событиях ожидания, см.
<a href="#wait-summary-tables">раздел 23.9.15.1</a>.</p>

<h4><a name="wait-event-configuration"></a>Конфигурация событий ожидания</h4>
<p>Чтобы включить сбор событий ожидания, включите
соответствующие инструменты и потребителей.</p>

<p><a href="#setup-instruments-table"><code>setup_instruments
</code></a> содержит инструменты с именами, которые
начинаются с <code>wait</code>. Например:
<pre>
mysql&gt; SELECT * FROM setup_instruments
                   WHERE NAME LIKE 'wait/io/file/innodb%';
+--------------------------------------+---------+-------+
| NAME                                 | ENABLED | TIMED |
+--------------------------------------+---------+-------+
| wait/io/file/innodb/innodb_data_file | YES     | YES   |
| wait/io/file/innodb/innodb_log_file  | YES     | YES   |
| wait/io/file/innodb/innodb_temp_file | YES     | YES   |
+--------------------------------------+---------+-------+

mysql&gt; SELECT * FROM setup_instruments
                   WHERE NAME LIKE 'wait/io/socket/%';
+----------------------------------------+---------+-------+
| NAME                                   | ENABLED | TIMED |
+----------------------------------------+---------+-------+
| wait/io/socket/sql/server_tcpip_socket | NO      | NO    |
| wait/io/socket/sql/server_unix_socket  | NO      | NO    |
| wait/io/socket/sql/client_connection   | NO      | NO    |
+----------------------------------------+---------+-------+
</pre>

<p>Чтобы изменить набор событий, изменяют столбцы
<code>ENABLED</code> и <code>TIMING</code>
соответствующих инструментов. Например:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'YES', TIMED = 'YES'
                 WHERE NAME LIKE 'wait/io/socket/sql/%';
</pre>

<p><a href="#setup-consumers-table"><code>setup_consumers</code>
</a> содержит потребительские значения, соответствующие текущим и недавним
именам событий ожидания в таблице. Эти потребители могут использоваться,
чтобы фильтровать события. Потребители отключены по умолчанию:
<pre>
mysql&gt; SELECT * FROM setup_consumers WHERE NAME LIKE '%waits%';
+---------------------------+---------+
| NAME                      | ENABLED |
+---------------------------+---------+
| events_waits_current      | NO      |
| events_waits_history      | NO      |
| events_waits_history_long | NO      |
+---------------------------+---------+
</pre>

<p>Чтобы включить всех потребителей:
<pre>
mysql&gt; UPDATE setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%waits%';
</pre>

<p><a href="#setup-timers-table"><code>setup_timers</code></a>
содержит строку с <code>NAME</code> <code>ожидания</code>, которое
указывает модуль для синхронизации событий.
Модуль по умолчанию <code>CYCLE</code>.
<pre>
mysql&gt; SELECT * FROM setup_timers WHERE NAME = 'wait';
+------+------------+
| NAME | TIMER_NAME |
+------+------------+
| wait | CYCLE      |
+------+------------+
</pre>

<p>Чтобы изменить модуль синхронизации, измените
значение <code>TIMER_NAME</code>:
<pre>
mysql&gt; UPDATE setup_timers SET TIMER_NAME = 'NANOSECOND'
                 WHERE NAME = 'wait';
</pre>

<h4><a name="events-waits-current-table"></a>23.9.4.1.
Таблица events_waits_current</h4>
<p><a href="#events-waits-current-table"><code>events_waits_current
</code></a> содержит текущие события ожидания, одна строка на поток,
показывая текущий статус недавно проверенных событий ожидания потока.</p>

<p>Из таблиц, которые содержат строки событий,
<a href="#events-waits-current-table"><code>events_waits_current
</code></a> является самой фундаментальной. Другие таблицы, которые содержат
строки событий, логически получены из текущих событий. Например,
<a href="#events-waits-history-table"><code>events_waits_history
</code></a> и <a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a> собирают новые события ожидания до
постоянного числа строк.</p>

<p>У <a href="#events-waits-current-table"><code>
events_waits_current</code></a> есть эти столбцы:</p>
<ul><li><p><code>THREAD_ID</code>, <code>EVENT_ID</code></p>
<p>Поток, связанный со случаем, и число текущих событий потока, когда случай
запускается. <code>THREAD_ID</code> и <code>EVENT_ID</code>, взятые вместе,
уникально идентифицируют строку. Ни у каких двух строк нет той же
самой пары значений.</li>

<li><code>END_EVENT_ID</code></p>
<p>Этот столбец установлен в <code>NULL</code>, когда случай запускается, и
обновленный к числу текущих событий потока, когда случай заканчивается.</li>

<li><code>EVENT_NAME</code></p>
<p>Название инструмента, который произвел случай. Это <code>NAME</code> из
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. Инструментальные имена могут иметь много частей и сформировать
иерархию, как обсуждено в
<a href="#performance-schema-instrument-naming">разделе 23.4</a>.
</li>

<li><code>SOURCE</code></p>
<p>Название исходного файла, содержащего инструментованный код, который
произвел случай и номер строки в файле, в которой происходит инструментовка.
Это позволяет Вам проверить источник, чтобы определить точно, какой код
вовлечен. Например, если блокировка или mutex
блокируются, Вы можете проверить контекст, в котором это происходит.</li>

<li><code>TIMER_START</code>, <code>TIMER_END</code>,
<code>TIMER_WAIT</code></p>
<p>Информация о синхронизации для случая. Модуль для этих значений
пикосекунда. <code>TIMER_START</code> и <code>TIMER_END</code>
указывают, когда синхронизация событий запустилась и закончилась.
<code>TIMER_WAIT</code> продолжительность события.</p>

<p>Если случай не закончился, <code>TIMER_END</code>
текущее значение таймера и <code>TIMER_WAIT</code> уже прошедшее время
(<code>TIMER_END</code> - <code>TIMER_START</code>).</p>

<p>Если случай произведен из инструмента, который имеет
<code>TIMED = NO</code>, информация синхронизации не собрана,
<code>TIMER_START</code>, <code>TIMER_END</code> и
<code>TIMER_WAIT</code> <code>NULL</code>.</p></li>

<li><code>SPINS</code></p>
<p>Для mutex число спинов. Если значение <code>NULL</code>,
код не использует спины или они не инструментованы.</li>

<li><code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>,
<code>OBJECT_TYPE</code>, <code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Эти столбцы идентифицируют объект как <span>действует</span>.
Что это означает, зависит от типа объекта.</p>

<p>Для объекта синхронизации (<code>cond</code>,
<code>mutex</code>, <code>rwlock</code>):</p>
<ul><li><p><code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code> и
<code>OBJECT_TYPE</code> <code>NULL</code>.</li>
<li><code>OBJECT_INSTANCE_BEGIN</code> адрес объекта синхронизации в памяти.
</p></li></ul>

<p>Для объекта ввода/вывода файла:</p>
<ul><li><p><code>OBJECT_SCHEMA</code> <code>NULL</code>.</li>
<li><code>OBJECT_NAME</code> имя файла.</li>
<li><code>OBJECT_TYPE</code> <code>FILE</code>.</li>
<li><code>OBJECT_INSTANCE_BEGIN</code> адрес в памяти.</p></li></ul>

<p>Для объекта сокета:</p>
<ul><li><p><code>OBJECT_NAME</code> <code>IP:PORT</code> для сокета.</li>
<li><code>OBJECT_INSTANCE_BEGIN</code> адрес в памяти.</p></li></ul>

<p>Для табличного объекта ввода/вывода:</p>
<ul><li><p><code>OBJECT_SCHEMA</code> название схемы,
которая содержит таблицу.</li>

<li><code>OBJECT_NAME</code> имя таблицы.</li>
<li><code>OBJECT_TYPE</code> <code>TABLE</code>
для постоянной базовой таблицы или <code>TEMPORARY TABLE</code>
для временной таблицы.</li>
<li><code>OBJECT_INSTANCE_BEGIN</code> адрес в памяти.</p></li></ul>

<p>У самого значения <code>OBJECT_INSTANCE_BEGIN</code>
нет никакого значения, за исключением того, что различные значения указывают
на различные объекты. <code>OBJECT_INSTANCE_BEGIN</code> может использоваться
для того, чтобы отладить. Например, это может использоваться с <code>GROUP
BY OBJECT_INSTANCE_BEGIN</code>, чтобы видеть, что загрузка 1000 mutex
(которые защищают, скажем, 1000 страниц или блоков данных)
распространена равномерно или поражает только несколько узких мест.
Это может помочь Вам коррелировать с другими источниками информации, если Вы
видите тот же самый адрес объекта в файле системного журнала или
другом инструменте отладки.</li>

<li><code>INDEX_NAME</code></p>
<p>Имя индекса. <code>PRIMARY</code> указывает на первичный индекс таблицы.
<code>NULL</code> значит, что использовались средства,
которые не индексируют.</li>

<li><code>NESTING_EVENT_ID</code></p>
<p><code>EVENT_ID</code> значение случая, в пределах которого
вложен этот случай.</li>

<li><code>NESTING_EVENT_TYPE</code></p>
<p>Тип вложения событий. Значение <code>TRANSACTION</code>,
<code>STATEMENT</code>, <code>STAGE</code> или <code>WAIT</code>.</li>

<li><code>OPERATION</code></p>
<p>Тип работы <code>lock</code>, <code>read</code> или <code>write</code>.
</li>

<li><code>NUMBER_OF_BYTES</code></p>
<p>Число байтов, прочитанных или записанных. Для табличного ожидания
ввода/вывода (события для инструмента <code>wait/io/table/sql/handler
</code>) <code>NUMBER_OF_BYTES</code> указывает на число строк. Если значение
больше 1, это случай пакетной работы ввода/вывода. Следующее обсуждение
описывает различие между сообщением о единственной строке и сообщением, что
это отражает пакетный ввод/вывод.</p>

<p>MySQL выполняет соединения, используя выполнение вложенного цикла.
Задание инструментовки Performance Schema должно предоставить количество
строк и накопленное время выполнения на таблицу в соединении. Примите запрос
соединения следующей формы, которая выполнена, используя табличный порядок
соединения <code>t1</code>, <code>t2</code>, <code>t3</code>:
<pre>
SELECT ... FROM t1 JOIN t2 ON ... JOIN t3 ON ...
</pre>

<p>Таблица <span>fanout</span> увеличена или уменьшена в числе строк от
добавления таблицы во время обработки соединения. Если разветвление для
таблицы <code>t3</code> больше 1, большинство операций получения строки для
этой таблицы. Предположите, что соединение получает 10 строк из
<code>t1</code>, 20 из <code>t2</code> на строку из <code>t1</code> и 30
строк из <code>t3</code> на строку из <code>t2</code>.
С сообщением единственной строки общее количество инструментованных операций:
<pre>
10 + (10 * 20) + (10 * 20 * 30) = 6210
</pre>

<p>Значительное сокращение числа инструментованных операций достижимо,
соединяя их за просмотр (то есть, за уникальную комбинацию строк из
<code>t1</code> и <code>t2</code>). С пакетным сообщением ввода/вывода
Performance Schema производит случай для каждого просмотра самой внутренней
таблицы <code>t3</code>, а не для каждой строки, и число инструментованных
операций строки уменьшается до:
<pre>
10 + (10 * 20) + (10 * 20) = 410
</pre>

<p>Это сокращение на 93% иллюстрирует, как сообщающая о пакете стратегия
значительно уменьшает издержки Performance Schema для табличного
ввода/вывода, сокращая количество сообщений о требованиях. Расплата:
меньшая точность для синхронизации событий. А не время для отдельной работы
строки как в сообщении на строку, синхронизация для пакетного ввода/вывода
включает время, проведенное для таких операций, как буферизация соединения,
объединение и возвращение строк клиенту.</p>

<p>Для пакетного ввода/вывода эти условия должны быть истиной:</p>
<ul><li><p>Выполнение запроса получает доступ к самой внутренней таблице
блока запроса (для однотабличного запроса эта таблица
считается самой внутренней).</li>

<li>Выполнение запроса не просит единственную строку таблицы
(так, например, <a href="optimiz.htm#jointype_eq_ref"><code>eq_ref</code></a>
предотвращает использование сообщения пакета).</li>
<li>Выполнение запроса не оценивает подзапрос, содержащий табличный
доступ для таблицы.</p></li></ul></li>
<li><p><code>FLAGS</code></p>
<p>Сохранено для будущего использования.</p></li></ul>

<p>У <a href="#events-waits-current-table"><code>
events_waits_current</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>EVENT_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
позволен для <a href="#events-waits-current-table"><code>
events_waits_current</code></a>. Это удаляет строки.</p>

<h4><a name="events-waits-history-table"></a>23.9.4.2.
Таблица events_waits_history</h4>
<p><a href="#events-waits-history-table"><code>events_waits_history
</code></a> содержит новые <em><code>N</code></em> событий ожидания на поток.
Значение <em><code>N</code></em> автоизмерено при запуске сервера. Чтобы
установить табличный размер явно, установите переменную
<a href="#sysvar_performance_schema_events_waits_history_size">
<code>performance_schema_events_waits_history_size</code></a>
при запуске сервера. События не добавлены к таблице, пока они не закончены.
Когда новые события добавлены, от более старых событий отказываются,
если таблица полна.</p>

<p>У <a href="#events-waits-history-table"><code>
events_waits_history</code></a> есть та же самая структура, как у
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>, включая индексацию. См.
<a href="#events-waits-current-table">раздел 23.9.4.1</a>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> разрешен
для <a href="#events-waits-history-table"><code>
events_waits_history</code></a>. Это удаляет строки.</p>

<h4><a name="events-waits-history-long-table"></a>23.9.4.3.
Таблица events_waits_history_long</h4>
<p><a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a> содержит <em><code>N</code></em> новых
события ожидания. <em><code>N</code></em> определяется при запуске сервера.
Чтобы установить табличный размер явно, установите переменную
<a href="#sysvar_performance_schema_events_waits_history_long_size">
<code>performance_schema_events_waits_history_long_size</code></a>
при запуске сервера. События ожидания не добавлены к таблице, пока они не
закончены. Когда новые события добавлены, от более старых отказываются, если
таблица полна. Когда поток заканчивается, его строки удалены из таблицы.</p>

<p><a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a> имеет структуру, аналогичную
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>, но не имеет индексов. См.
<a href="#events-waits-current-table">раздел 23.9.4.1</a>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a>. Это удаляет строки.</p>

<h3><a name="performance-schema-stage-tables"></a>23.9.5.
Таблицы событий этапа Performance Schema</h3>
<p>Инструменты этапа Performance Schema, которые являются шагами во время
процесса выполнения запроса, такими как парсинг запроса, открытие таблицы
или выполнение <code>filesort</code>. Этапы соответствуют статусам,
отображенным <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code>
</a> или видимым в таблице <a href="inform.htm#processlist-table"><code>
INFORMATION_SCHEMA.PROCESSLIST</code></a>. Этапы начинаются и заканчиваются,
когда статус оценивает изменение.</p>

<p>Эти таблицы хранят события этапа:</p>
<ul><li><p><a href="#events-stages-current-table"><code>
events_stages_current</code></a>: Текущие события этапа.</li>

<li><a href="#events-stages-history-table"><code>
events_stages_history</code></a>: Новые события этапа для каждого потока.</li>
<li><a href="#events-stages-history-long-table"><code>
events_stages_history_long</code></a>: Новые события этапа повсюду.
</p></li></ul>

<h4><a name="stage-event-configuration"></a>Конфигурация событий этапа</h4>
<p>Чтобы включить сбор событий этапа, включите
соответствующие инструменты и потребителей.</p>

<p><a href="#setup-instruments-table"><code>setup_instruments
</code></a> содержит инструменты с именами, которые начинаются с
<code>stage</code>. Кроме тех инструментов, которые предоставляют информацию
о продвижении запроса, эти инструменты отключены по умолчанию. Например:
<pre>
mysql&gt; SELECT * FROM setup_instruments WHERE NAME RLIKE 'stage/sql/[a-c]';
+----------------------------------------------------+---------+-------+
| NAME                                               | ENABLED | TIMED |
+----------------------------------------------------+---------+-------+
| stage/sql/After create                             | NO      | NO    |
| stage/sql/allocating local table                   | NO      | NO    |
| stage/sql/altering table                           | NO      | NO    |
| stage/sql/committing alter table to storage engine | NO      | NO    |
| stage/sql/Changing master                          | NO      | NO    |
| stage/sql/Checking master version                  | NO      | NO    |
| stage/sql/checking permissions                     | NO      | NO    |
| stage/sql/checking privileges on cached query      | NO      | NO    |
| stage/sql/checking query cache for query           | NO      | NO    |
| stage/sql/cleaning up                              | NO      | NO    |
| stage/sql/closing tables                           | NO      | NO    |
| stage/sql/Connecting to master                     | NO      | NO    |
| stage/sql/converting HEAP to MyISAM                | NO      | NO    |
| stage/sql/Copying to group table                   | NO      | NO    |
| stage/sql/Copying to tmp table                     | NO      | NO    |
| stage/sql/copy to tmp table                        | NO      | NO    |
| stage/sql/Creating sort index                      | NO      | NO    |
| stage/sql/creating table                           | NO      | NO    |
| stage/sql/Creating tmp table                       | NO      | NO    |
+----------------------------------------------------+---------+-------+
</pre>

<p>Инструменты событий этапа, которые предоставляют информацию о продвижении
запроса, включены и рассчитаны по умолчанию:
<pre>
mysql&gt; SELECT * FROM setup_instruments WHERE ENABLED='YES' AND
                   NAME LIKE "stage/%";
+------------------------------------------------------+---------+-------+
| NAME                                                 | ENABLED | TIMED |
+------------------------------------------------------+---------+-------+
| stage/sql/copy to tmp table                          | YES     | YES   |
| stage/innodb/alter table (end)                       | YES     | YES   |
| stage/innodb/alter table (flush)                     | YES     | YES   |
| stage/innodb/alter table (insert)                    | YES     | YES   |
| stage/innodb/alter table (log apply index)           | YES     | YES   |
| stage/innodb/alter table (log apply table)           | YES     | YES   |
| stage/innodb/alter table (merge sort)                | YES     | YES   |
| stage/innodb/alter table (read PK and internal sort) | YES     | YES   |
| stage/innodb/buffer pool load                        | YES     | YES   |
+------------------------------------------------------+---------+-------+
</pre>

<p>Чтобы изменить набор событий этапа, измените столбцы
<code>ENABLED</code> и <code>TIMING</code>
соответствующих инструментов. Например:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'YES', TIMED = 'YES'
                 WHERE NAME = 'stage/sql/altering table';
</pre>

<p><a href="#setup-consumers-table"><code>setup_consumers</code>
</a> содержит потребительские значения с именами, соответствующими текущим и
недавним именам таблиц этапа событий. Эти потребители могут использоваться,
чтобы фильтровать набор событий этапа.
Потребители этапа отключены по умолчанию:
<pre>
mysql&gt; SELECT * FROM setup_consumers WHERE NAME LIKE '%stages%';
+----------------------------+---------+
| NAME                       | ENABLED |
+----------------------------+---------+
| events_stages_current      | NO      |
| events_stages_history      | NO      |
| events_stages_history_long | NO      |
+----------------------------+---------+
</pre>

<p>Чтобы включить всех потребителей этапа:
<pre>
mysql&gt; UPDATE setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%stages%';
</pre>

<p><a href="#setup-timers-table"><code>setup_timers</code></a>
содержит строку <code>NAME</code> со значением <code>stage</code>, которая
указывает на модуль для синхронизации этапа событий.
Модуль по умолчанию <code>NANOSECOND</code>.
<pre>
mysql&gt; SELECT * FROM setup_timers WHERE NAME = 'stage';
+-------+------------+
| NAME  | TIMER_NAME |
+-------+------------+
| stage | NANOSECOND |
+-------+------------+
</pre>

<p>Чтобы изменить модуль синхронизации, измените
значение <code>TIMER_NAME</code>:
<pre>
mysql&gt; UPDATE setup_timers SET TIMER_NAME = 'MICROSECOND'
                 WHERE NAME = 'stage';
</pre>

<h4><a name="stage-event-progress"></a>Информация о продвижении этапа событий
</h4>
<p>Таблицы событий этапа Performance Schema содержат два столбца, которые,
вместе взятые, обеспечивают индикатор хода выполнения этапа
для каждой строки:</p>

<ul><li><p><code>WORK_COMPLETED</code>: Число единиц работы, которые
завершились для этапа.</li>
<li><code>WORK_ESTIMATED</code>: Число единиц работы, которые
ожидаются для этапа.</p></li></ul>

<p>Каждый столбец <code>NULL</code>, если никакая информация о продвижении не
предоставлена для инструмента. Интерпретация информации, если это доступно,
зависит полностью от инструментального выполнения. Таблицы Performance Schema
обеспечивают контейнер, чтобы хранить данные продвижения, но не делают
предположения о семантике метрики непосредственно:</p>

<ul><li><p><span>Единица работы</span> является метрикой целого числа,
которая увеличивается в течение долгого времени во время выполнения, такое
как число байтов, строк, файлов или обработанных таблиц. Определение
<span>единицы работы</span> для особого инструмента оставляют коду
инструментовки, обеспечивающему данные.</li>

<li>Значение <code>WORK_COMPLETED</code> может увеличиться на один
или много модулей за один раз, в зависимости от инструментованного кода.</li>
<li>Значение <code>WORK_ESTIMATED</code> может измениться во время этапа, в
зависимости от инструментованного кода.</p></li></ul>

<p>Инструментовка для индикатора хода выполнения этапа событий может
осуществить любое из следующих поведений:</p>
<ul><li><p>Никакого прогресса нет.</p>

<p>Это самый типичный случай, где никакие данные о продвижении не обеспечены.
Столбцы <code>WORK_COMPLETED</code> и
<code>WORK_ESTIMATED</code> оба <code>NULL</code>.</li>

<li>Неограниченная инструментовка продвижения.</p>
<p>Только столбец <code>WORK_COMPLETED</code> является значащим. Никакие
данные не предусмотрены для <code>WORK_ESTIMATED</code>,
который выводит на экран 0.</p>

<p>Запрашивая таблицу <a href="#events-stages-current-table"><code>
events_stages_current</code></a> для проверенного сеанса, контролирующее
приложение может сообщить, сколько работы до сих пор выполнялось, но не может
сообщить, является ли этап близким к завершению. В настоящее время никакие
этапы не инструментованы таким образом.</li>

<li>Ограниченная инструментовка продвижения.</p>
<p>Столбцы <code>WORK_COMPLETED</code> и <code>WORK_ESTIMATED</code>
являются оба значащими.</p>

<p>Этот тип индикатора хода выполнения является подходящим для работы с
определенным критерием завершения, таким как инструмент табличной копии,
описанный позже. Запрашивая таблицу
<a href="#events-stages-current-table"><code>events_stages_current
</code></a> для проверенного сеанса, контролирующее приложение может
сообщить, сколько работы до сих пор выполнялось, и может сообщить о полном
проценте завершения для этапа, вычисляя коэффициент
<code>WORK_COMPLETED</code>/<code>WORK_ESTIMATED</code>.</p></li></ul>

<p>Инструмент <code>stage/sql/copy to tmp table</code> иллюстрирует, как
работают индикаторы хода выполнения. Во время выполнения
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
этап <code>stage/sql/copy to tmp table</code> используется, и этот этап может
выполняться потенциально в течение долгого времени, в зависимости
от размера данных.</p>

<p>У задачи табличной копии есть определенное завершение
(все строки скопированы) и <code>stage/sql/copy to tmp table</code>
инструментован к предоставленной ограниченной информации о продвижении:
используемая единица работы является числом скопированных строк,
<code>WORK_COMPLETED</code> и <code>WORK_ESTIMATED</code> являются значащими,
а их отношение указывает на процент выполнения задачи.</p>

<p>Чтобы включить инструмент и соответствующих потребителей,
выполните эти запросы:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED='YES'
                 WHERE NAME='stage/sql/copy to tmp table';
mysql&gt; UPDATE setup_consumers SET ENABLED='YES'
                 WHERE NAME LIKE 'events_stages_%';
</pre>

<p>Чтобы видеть ход продолжающегося запроса
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
выберите из таблицы <a href="#events-stages-current-table"><code>
events_stages_current</code></a>.</p>

<h4><a name="events-stages-current-table"></a>23.9.5.1.
Таблица events_stages_current</h4>
<p><a href="#events-stages-current-table"><code>
events_stages_current</code></a> содержит текущие события этапа, одну строку
на поток, показывая текущий статус нового отслеживаемого
события этапа потока.</p>

<p>Из таблиц, которые содержат строки этапа событий,
<a href="#events-stages-current-table"><code>events_stages_current
</code></a> является самой фундаментальной. Другие таблицы, которые содержат
строки этапа событий, логически получены из текущих событий. Например,
<a href="#events-stages-history-table"><code>events_stages_history
</code></a> и <a href="#events-stages-history-long-table"><code>
events_stages_history_long</code></a> собирают новые события этапа до
постоянного числа строк.</p>

<p>У <a href="#events-stages-current-table"><code>
events_stages_current</code></a> есть эти столбцы:</p>
<ul><li><p><code>THREAD_ID</code>, <code>EVENT_ID</code></p>
<p>Поток, связанный со случаем и числом событий потока,
когда случай запускается. <code>THREAD_ID</code> и <code>EVENT_ID</code>,
взятые вместе, уникально идентифицируют строку. Ни у каких двух строк нет той
же самой пары значений.</li>

<li><code>END_EVENT_ID</code></p>
<p>Этот столбец установлен в <code>NULL</code>, когда случай запускается, и
обновлен к числу событий потока, когда случай заканчивается.</li>

<li><code>EVENT_NAME</code></p>
<p>Название инструмента, который произвел случай. Это значение
<code>NAME</code> из <a href="#setup-instruments-table"><code>
setup_instruments</code></a>. Инструментальные имена могут иметь много частей
и сформировать иерархию, как обсуждено в
<a href="#performance-schema-instrument-naming">разделе 23.4</a>.
</li>

<li><code>SOURCE</code></p>
<p>Название исходного файла, содержащего инструментованный код, который
произвел случай и номер строки в файле, в которой происходит
инструментовка. Это позволяет Вам проверить источник, чтобы определить точно,
какой код вовлечен.</li>

<li><code>TIMER_START</code>, <code>TIMER_END</code>,
<code>TIMER_WAIT</code></p>
<p>Информация о синхронизации для случая. Модуль для этих значений
пикосекунды. <code>TIMER_START</code> и <code>TIMER_END</code>
указывают, когда синхронизация событий запустилась и закончилась.
<code>TIMER_WAIT</code> продолжительность событий.</p>

<p>Если случай не закончился, <code>TIMER_END</code>
текущее значение таймера и <code>TIMER_WAIT</code> время, законченное до сих
пор (<code>TIMER_END</code> - <code>TIMER_START</code>).</p>

<p>Если случай произведен из инструмента, который имеет
<code>TIMED = NO</code>, информация синхронизации не собрана,
<code>TIMER_START</code>, <code>TIMER_END</code> и
<code>TIMER_WAIT</code> все <code>NULL</code>.</p></li>

<li><code>WORK_COMPLETED</code>, <code>WORK_ESTIMATED</code></p>
<p>Эти столбцы предоставляют информацию о продвижении этапа для
инструментов, которые были осуществлены, чтобы произвести такую информацию.
<code>WORK_COMPLETED</code> указывает, сколько единиц работы было завершено
для этапа, а <code>WORK_ESTIMATED</code>
указывает, сколько единиц работы ожидается для этапа.</li>

<li><code>NESTING_EVENT_ID</code></p>
<p>Значение <code>EVENT_ID</code> случая, в пределах которого вложен этот
случай. Событие вложения для случая этапа обычно событие запроса.</li>

<li><code>NESTING_EVENT_TYPE</code></p>
<p>Тип вложения событий. Значение <code>TRANSACTION</code>,
<code>STATEMENT</code>, <code>STAGE</code> или
<code>WAIT</code>.</p></li></ul>

<p>У <a href="#events-stages-current-table"><code>
events_stages_current</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>, <code>EVENT_ID</code>).
</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-stages-current-table"><code>
events_stages_current</code></a>. Это удаляет строки.</p>

<h4><a name="events-stages-history-table"></a>23.9.5.2.
Таблица events_stages_history Table</h4>
<p><a href="#events-stages-history-table"><code>
events_stages_history</code></a> содержит <em><code>N</code></em> новых
событий этапа на поток. Значение <em><code>N</code></em> определено
при запуске сервера. Чтобы установить табличный размер явно, установите
при запуске сервера переменную
<a href="#sysvar_performance_schema_events_stages_history_size">
<code>performance_schema_events_stages_history_size</code></a>. События этапа
не добавлены к таблице, пока они не закончены. Когда новые события добавлены,
от более старых событий отказываются, если таблица полна.</p>

<p>У <a href="#events-stages-history-table"><code>
events_stages_history</code></a> есть та же самая структура, как у
<a href="#events-stages-current-table"><code>events_stages_current
</code></a>, включая индексы. См.
<a href="#events-stages-current-table">раздел 23.9.5.1</a>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-stages-history-table"><code>
events_stages_history</code></a>. Это удаляет строки.</p>

<h4><a name="events-stages-history-long-table"></a>23.9.5.3. Таблица
events_stages_history_long</h4>
<p><a href="#events-stages-history-long-table"><code>
events_stages_history_long</code></a> содержит <em><code>N</code></em> новых
событий этапа. <em><code>N</code></em> определено при запуске сервера. Чтобы
установить табличный размер явно, установите при запуске сервера переменную
<a href="#sysvar_performance_schema_events_stages_history_long_size">
<code>performance_schema_events_stages_history_long_size</code></a>.
События этапа не добавлены к таблице, пока они не закончились. Когда
новые события добавлены, от более старых событий отказываются, если таблица
полна. Когда поток заканчивается, его строки удалены из таблицы.</p>

<p>У <a href="#events-stages-history-long-table"><code>
events_stages_history_long</code></a> есть та же самая структура, как у
<a href="#events-stages-current-table"><code>events_stages_current
</code></a>, но нет индексов. См.
<a href="#events-stages-current-table">раздел 23.9.5.1</a>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-stages-history-long-table"><code>
events_stages_history_long</code></a>. Это удаляет строки.</p>

<h3><a name="performance-schema-statement-tables"></a>23.9.6.
Таблицы событий запросов Performance Schema</h3>
<p>Эти таблицы хранят события запросов:</p>

<ul><li><p><a href="#events-statements-current-table"><code>
events_statements_current</code></a>: Текущие события запросов.</li>
<li><a href="#events-statements-history-table"><code>
events_statements_history</code></a>: Новые события запросов
для каждого потока.</li>

<li><a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a>: Новые события запросов повсюду.
</li>

<li><a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>: Готовые запросы и статистика.
</p></li></ul>

<h4><a name="performance-schema-statement-tables-configuration"></a>
Конфигурация событий запросов</h4>
<p>Чтобы включить сбор событий запросов, включите
соответствующие инструменты и потребителей.</p>

<p>Таблица <a href="#setup-instruments-table"><code>
setup_instruments</code></a> содержит инструменты с именами, которые
начинаются с <code>statement</code>. Эти инструменты включены по умолчанию:
<pre>
mysql&gt; SELECT * FROM setup_instruments WHERE NAME LIKE 'statement/%';
+--------------------------------+---------+-------+
| NAME                           | ENABLED | TIMED |
+--------------------------------+---------+-------+
| statement/sql/select           | YES     | YES   |
| statement/sql/create_table     | YES     | YES   |
| statement/sql/create_index     | YES     | YES   |
...
| statement/sp/stmt              | YES     | YES   |
| statement/sp/set               | YES     | YES   |
| statement/sp/set_trigger_field | YES     | YES   |
| statement/scheduler/event      | YES     | YES   |
| statement/com/Sleep            | YES     | YES   |
| statement/com/Quit             | YES     | YES   |
| statement/com/Init DB          | YES     | YES   |
...
| statement/abstract/Query       | YES     | YES   |
| statement/abstract/new_packet  | YES     | YES   |
| statement/abstract/relay_log   | YES     | YES   |
+--------------------------------+---------+-------+
</pre>

<p>Чтобы изменить набор событий запросов, измените столбцы
<code>ENABLED</code> и <code>TIMING</code>
соответствующих инструментов. Например:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'NO'
                 WHERE NAME LIKE 'statement/com/%';
</pre>

<p><a href="#setup-consumers-table"><code>setup_consumers</code>
</a> содержит потребительские значения с именами, соответствующими текущим и
недавним именам событий запросов и потребителю обзора запросов.
Эти потребители могут использоваться, чтобы фильтровать набор событий.
<code>events_statements_current</code>,
<code>events_statements_history</code> и <code>statements_digest</code>
включены по умолчанию:
<pre>
mysql&gt; SELECT * FROM setup_consumers WHERE NAME LIKE '%statements%';
+--------------------------------+---------+
| NAME                           | ENABLED |
+--------------------------------+---------+
| events_statements_current      | YES     |
| events_statements_history      | YES     |
| events_statements_history_long | NO      |
| statements_digest              | YES     |
+--------------------------------+---------+
</pre>

<p>Чтобы включить всех потребителей, сделайте это:
<pre>
mysql&gt; UPDATE setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%statements%';
</pre>

<p><a href="#setup-timers-table"><code>setup_timers</code></a>
содержит строку со значением <code>NAME</code> <code>statement</code>,
которая указывает на модуль для синхронизации запросы событий.
Модуль по умолчанию <code>NANOSECOND</code>.
<pre>
mysql&gt; SELECT * FROM setup_timers WHERE NAME = 'statement';
+-----------+------------+
| NAME      | TIMER_NAME |
+-----------+------------+
| statement | NANOSECOND |
+-----------+------------+
</pre>

<p>Чтобы изменить модуль синхронизации,
измените значение <code>TIMER_NAME</code>:
<pre>
mysql&gt; UPDATE setup_timers SET TIMER_NAME = 'MICROSECOND'
                 WHERE NAME = 'statement';
</pre>

<h4><a name="performance-schema-statement-tables-monitoring"></a>
Контроль запросов</h4>
<p>Контроль запросов начинается с момента, когда сервер видит, что на
потоке требуется активность, до момента, когда вся деятельность прекратилась.
Как правило, это означает по времени от момента, когда сервер получает первый
пакет от клиента, до времени, когда сервер закончил посылать ответ.
Запросы в пределах сохраненных программ проверены как другие запросы.</p>

<p>Когда Performance Schema инструментует запрос (команду сервера или запрос
SQL), это использует инструментальные имена, которые проистекают из более
общего (или <span>абстрактного</span>) к более определенному, пока это не
достигает заключительного инструментального имени.</p>

<p>Заключительные инструментальные имена соответствуют командам
сервера и запросам SQL:</p>
<ul><li><p>Команды сервера соответствуют кодам
<code>COM_<em><code>xxx</code></em></code>, определенным в заголовочном файле
<code>mysql_com.h</code> и обработанным в <code>sql/sql_parse.cc</code>.
Примеры: <code>COM_PING</code> и <code>COM_QUIT</code>.
У инструментов для команд есть имена, которые начинаются на
<code>statement/com</code>, к примеру, <code>statement/com/Ping</code> и
<code>statement/com/Quit</code>.</li>

<li>Запросы SQL выражены как текст, такой как
<code>DELETE FROM t1</code> или <code>SELECT * FROM t2</code>.
У инструментов для запросов SQL есть имена, которые начинаются с
<code>statement/sql</code>, например, <code>statement/sql/delete</code> и
<code>statement/sql/select</code>.</p></li></ul>

<p>Некоторые заключительные инструментальные имена являются определенными
для обработки ошибок:</p>
<ul><li><p><code>statement/com/Error</code> считает
сообщения, полученные сервером, которые являются вне группы. Это может
использоваться, чтобы обнаружить команды, посланные клиентами, которых не
понимает сервер. Это может быть полезно в таких целях, как идентификация
клиентов, которые являются неправильно настроенными или используют версии
MySQL, более свежие, чем сервер, или клиенты, которые пытаются
напасть на сервер.</li>

<li><code>statement/sql/error</code> считает запросы SQL, которые сервер не
в состоянии разобрать. Это может использоваться, чтобы обнаружить уродливые
запросы, посланные клиентами. Запрос, который сервер не в состоянии
разобрать, отличается от запроса, который разбирает, но терпит неудачу из-за
ошибки во время выполнения. Например, <code>SELECT * FROM</code>
неправилен, и используется инструмент <code>statement/sql/error</code>.
В отличие от этого, <code>SELECT *</code> разобран, но терпит неудачу с
ошибкой <code>No tables used</code>. В этом случае используется
<code>statement/sql/select</code> и случай запроса содержит информацию, чтобы
указать на природу ошибки.</p></li></ul>

<p>Запрос может быть получен из любого из этих источников:</p>
<ul><li><p>Как команда или запрос от клиента, который посылает
запрос как пакет.</li>
<li>Как строка запроса, считанная из протокола на ведомом устройстве.</li>
<li>Как событие от Event Scheduler.</p></li></ul>

<p>Детали для запроса первоначально неизвестны и Performance Schema
раблтает от абстрактных до определенных инструментальных имен в
последовательности, которая зависит от источника запроса.</p>

<p>Для запроса, полученного от клиента:</p>
<ol type="1"><li><p>Когда сервер обнаруживает новый пакет на уровне сокета,
новое запрос запущен с абстрактного инструментального названия
<code>statement/abstract/new_packet</code>.</li>

<li>Когда сервер читает число пакетов, он знает больше о типе полученного
запроса, и Performance Schema совершенствует инструментальное имя. Например,
если запрос пакет <code>COM_PING</code>, инструментальное имя становится
<code>statement/com/Ping</code> и это заключительное имя. Если запрос пакет
<code>COM_QUERY</code>, это, как известно, соответствует запросу SQL, но не
особому типу запроса. В этом случае инструмент изменяется от одного
абстрактного имени к более определенному, но все еще абстрактногому имени,
<code>statement/abstract/Query</code> и запрос
требует дальнейшей классификации.</li>

<li>Если это именно запрос, текст запроса считан и передан анализатору. После
парсинга известен точный тип запроса. Если запрос, например,
<a href="sql.htm#insert"><code>INSERT</code></a>, Performance Schema
совершенствует инструментальное имя от <code>statement/abstract/Query</code>
к <code>statement/sql/insert</code>, что является заключительным именем.
</p></li></ol>

<p>Для чтения запроса как запроса от протокола ведомого устройства:</p>
<ol type="1"><li><p>Запросы в журнале сохранены как текст и считаны как есть.
Нет никакого сетевого протокола, таким образом, инструмент
<code>statement/abstract/new_packet</code> не используется. Вместо этого
начальный инструмент <code>statement/abstract/relay_log</code>.</li>

<li>Когда запрос разобран, точный тип запроса известен. Если запрос,
например, <a href="sql.htm#insert"><code>INSERT</code></a>, Performance
Schema совершенствует инструментальное имя от
<code>statement/abstract/Query</code> до
<code>statement/sql/insert</code>, что является заключительным именем.
</p></li></ol>

<p>Предыдущее описание применяется только для основанной на запросе
репликации. Для основанной на строке табличный ввод/вывод, сделанный на
ведомом устройстве, когда это обрабатывает изменения строки, может быть
инструментован, но события строки в журнале не появляются
как дискретные запросы.</p>

<p>Для запроса, полученного от Event Scheduler:</p>
<p>Выполнение событий инструментовано, используя имя
<code>statement/scheduler/event</code>. Это заключительное имя.</p>

<p>Запросы, выполненные в пределах тела событий, инструментованы, используя
имена <code>statement/sql/*</code>, без использования любого предыдущего
абстрактного инструмента. Событие это сохраненная программа, а сохраненные
программы предварительно собраны в памяти перед выполнением. Следовательно,
нет никакого парсинга во время выполнения, а тип каждого запроса известен к
тому времени, когда это выполняется.</p>

<p>Запросы, выполненные в пределах тела событий, являются дочерними
запросами. Например, если событие выполняет <a href="sql.htm#insert"><code>
INSERT</code></a>, выполнение самого события родитель, инструментованный с
использованием <code>statement/scheduler/event</code>, а
<a href="sql.htm#insert"><code>INSERT</code></a> потомок, инструментованный с
<code>statement/sql/insert</code>. Отношение хранится <span><em>между</em>
</span> отдельными инструментованными операциями. Это отличается от
последовательности обработки, которая происходит
<span class="emphasis"><em>в</em></span> единственной инструментованной
работе, от абстракции до заключительных инструментальных имен.</p>

<p>Для статистики, которая будет собрана для запросов, недостаточно включить
только финальные инструменты <code>statement/sql/*</code>
для отдельных типов запросов. Абстрактные инструменты
<code>statement/abstract/*</code> должны быть включены также. Это не должно
обычно быть проблемой, потому что все инструменты запроса включены по
умолчанию. Однако, приложение, которое включает или отключает инструменты
запроса выборочно, должно принять во внимание, что отключение абстрактных
инструментов также отключает сбор статистики для отдельных инструментов
запросов. Например, чтобы собрать статистические данные для
<a href="sql.htm#insert"><code>INSERT</code></a>,
<code>statement/sql/insert</code> должен быть включен, но также
also <code>statement/abstract/new_packet</code> и
<code>statement/abstract/Query</code>. Точно так же для копируемых запросов,
которые будут инструментованы, должен быть включен
<code>statement/abstract/relay_log</code>.</p>

<p>Никакие статистические данные не соединены для таких абстрактных
инструментов, как <code>statement/abstract/Query</code>,
потому что никакой запрос никогда не классифицируется с абстрактным
инструментом как заключительным именем запроса.</p>

<h4><a name="events-statements-current-table"></a>23.9.6.1.
Таблица The events_statements_current</h4>
<p><a href="#events-statements-current-table"><code>
events_statements_current</code></a> содержит текущие события запроса, одну
строку на поток, показывая текущий статус новых отслеживаемых за развитием
события запросов потока.</p>

<p>Из таблиц, которые содержат строки запросов событий,
<a href="#events-statements-current-table"><code>
events_statements_current</code></a> является самой фундаментальной. Другие
таблицы, которые содержат строки запросы событий, логически получены из
текущих событий. Например,
<a href="#events-statements-history-table"><code>
events_statements_history</code></a> и
<a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a> собирают
новые события запроса до постоянного числа строк.</p>

<p>У <a href="#events-statements-current-table"><code>
events_statements_current</code></a> есть эти столбцы:</p>
<ul><li><p><code>THREAD_ID</code>, <code>EVENT_ID</code>.</p>
<p>Поток, связанный со случаем и текущим числом событий потока,
когда случай запускается. <code>THREAD_ID</code> и <code>EVENT_ID</code>
вместе уникально идентифицируют строку. Ни у каких двух строк нет той же
самой пары значений.</li>

<li><code>END_EVENT_ID</code></p>
<p>Этот столбец установлен в <code>NULL</code>, когда случай запускается
и обновлен к числу событий потока, когда случай заканчивается.</li>

<li><code>EVENT_NAME</code></p>
<p>Название инструмента, у которого был собран случай. Это <code>NAME</code>
из таблицы <a href="#setup-instruments-table"><code>
setup_instruments</code></a>. Инструментальные имена могут иметь много частей
и сформировать иерархию, как обсуждено в
<a href="#performance-schema-instrument-naming">разделе 23.4</a>.
</p>

<p>Для запросов SQL <code>EVENT_NAME</code> первоначально
<code>statement/com/Query</code> пока запрос не разобран, затем изменяется на
более соответствующее значение, как описано в
<a href="#performance-schema-statement-tables">разделе 23.9.6</a>.
</li>

<li><code>SOURCE</code></p>
<p>Название исходного файла, содержащего инструментованный код, который
произвел случай и номер строки в файле, в котором происходит инструментовка.
Это позволяет Вам проверить источник, чтобы определить точно,
какой код вовлечен.</li>

<li><code>TIMER_START</code>, <code>TIMER_END</code>,
<code>TIMER_WAIT</code></p>
<p>Информация о синхронизации для случая. Модуль для этих значений
пикосекунды <code>TIMER_START</code> и <code>TIMER_END</code>
указывают, когда синхронизация событий запустилась и закончилась.
<code>TIMER_WAIT</code> продолжительность событий.</p>

<p>Если случай не закончился, <code>TIMER_END</code>
текущее значение таймера и <code>TIMER_WAIT</code>
время, законченное до сих пор
(<code>TIMER_END</code> - <code>TIMER_START</code>).</p>

<p>Если случай произведен из инструмента, который имеет
<code>TIMED = NO</code>, информация синхронизации не собрана, а
<code>TIMER_START</code>, <code>TIMER_END</code> и
<code>TIMER_WAIT</code> <code>NULL</code>.</p></li>

<li><code>LOCK_TIME</code></p>
<p>Время, потраченное на ожидание табличных блокировок. Это значение
вычислено в микросекундах, но нормализовано к пикосекундам для более легкого
сравнения с другими таймерами Performance Schema.</li>

<li><code>SQL_TEXT</code></p>
<p>Текст запроса SQL. Для команды, не связанной с запросом
SQL, значение <code>NULL</code>.</p>

<p>Максимальное количество байтов, чтобы вывести на экран может быть
изменено, изменяя при запуске сервера переменную
<a href="#sysvar_performance_schema_max_sql_text_length"><code>
performance_schema_max_sql_text_length</code></a>.</li>

<li><code>DIGEST</code></p>
<p>Обзор запроса MD5 как строка из 32 шестнадцатеричных символов или
<code>NULL</code>, если потребитель
<code>statement_digest</code> <code>no</code>.</li>

<li><code>DIGEST_TEXT</code></p>
<p>Нормализованный текст обзора запроса или <code>NULL</code>, если
потребитель <code>statement_digest</code> <code>no</code>.</p>

<p>Перменная <a href="#sysvar_performance_schema_max_digest_length">
<code>performance_schema_max_digest_length</code></a>
определяет максимальное количество байтов, доступных для вычислительных
обзоров запроса. Однако, длина отображения обзоров запроса может быть более
длительной, чем доступный размер буфера из-за кодирования компонентов
запроса, таких как ключевые слова и буквальные значения в буфере обзора.
Следовательно, значения, выбранные из столбца <code>DIGEST_TEXT</code>
таблиц событий запроса, может казаться, превышает
<a href="#sysvar_performance_schema_max_digest_length">
<code>performance_schema_max_digest_length</code></a>.</li>

<li><code>CURRENT_SCHEMA</code></p>
<p>База данных значения по умолчанию для запроса,
<code>NULL</code>, если нет.</li>

<li><code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>,
<code>OBJECT_TYPE</code></p>
<p>Для вложенных запросов (сохраненные программы), эти столбцы содержат
информацию о родительском запросе. Иначе <code>NULL</code>.</li>

<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Этот столбец идентифицирует запрос. Значение адрес объекта в памяти.</li>
<li><code>MYSQL_ERRNO</code></p>
<p>Код ошибки из области диагностики.</li>

<li><code>RETURNED_SQLSTATE</code></p>
<p>Значение SQLSTATE из области диагностики.</li>
<li><code>MESSAGE_TEXT</code></p>
<p>Сообщение об ошибке запроса из области диагностики.</li>

<li><code>ERRORS</code></p>
<p>Произошла ли ошибка для запроса. Значение 0, если значение SQLSTATE
начинается с <code>00</code> (выполнен) или <code>01</code> (предупреждение).
Значение 1, если SQLSTATE иное.</li>

<li><code>WARNINGS</code></p>
<p>Число предупреждений из области диагностики.</li>
<li><code>ROWS_AFFECTED</code></p>
<p>Число строк, затронутых запросом. Для описания значения
"<span>затронутых</span>" см. <a href="connect.htm#mysql-affected-rows">
раздел 25.8.7.1</a>.</li>

<li><code>ROWS_SENT</code></p>
<p>Число строк, возвращенных запросом.</li>
<li><code>ROWS_EXAMINED</code></p>
<p>Число строк, прочитанных из механизмов хранения во
время выполнения запроса.</li>

<li><code>CREATED_TMP_DISK_TABLES</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Created_tmp_disk_tables"><code>
Created_tmp_disk_tables</code></a>, но для запроса.</li>

<li><code>CREATED_TMP_TABLES</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Created_tmp_tables"><code>
Created_tmp_tables</code></a>, но для запроса.</li>

<li><code>SELECT_FULL_JOIN</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Select_full_join"><code>
Select_full_join</code></a>, но для запроса.</li>

<li><code>SELECT_FULL_RANGE_JOIN</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Select_full_range_join"><code>
Select_full_range_join</code></a>, но для запроса.</li>

<li><code>SELECT_RANGE</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Select_range"><code>Select_range</code></a>,
но для запроса.</li>

<li><code>SELECT_RANGE_CHECK</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Select_range_check"><code>
Select_range_check</code></a>, но для запроса.</li>

<li><code>SELECT_SCAN</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Select_scan"><code>Select_scan</code></a>,
но для запроса.</li>

<li><code>SORT_MERGE_PASSES</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Sort_merge_passes"><code>Sort_merge_passes</code>
</a>, но для запроса.</li>

<li><code>SORT_RANGE</code></p>
<p>Как переменная состояния
a href="server.htm#statvar_Sort_range"><code>Sort_range</code></a>,
но для запроса.</li>

<li><code>SORT_ROWS</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Sort_rows"><code>Sort_rows</code></a>,
но для запроса.</li>

<li><code>SORT_SCAN</code></p>
<p>Как переменная состояния
<a href="server.htm#statvar_Sort_scan"><code>Sort_scan</code></a>,
но для запроса.</li>

<li><code>NO_INDEX_USED</code></p>
<p>1, если запрос выполнил сканирование таблицы, не
используя индексирование, 0 иначе.</li>

<li><code>NO_GOOD_INDEX_USED</code></p>
<p>1, если сервер не нашел индекс, чтобы использовать для запроса, 0 иначе.
Для дополнительной информации см. описание столбца <code>Extra</code> из
вывода <code>EXPLAIN</code> для значения
<code>Range checked for each record</code>
<a href="optimiz.htm#explain-output">разделе 9.8.2</a>.</li>

<li><code>NESTING_EVENT_ID</code>, <code>NESTING_EVENT_TYPE</code>,
<code>NESTING_EVENT_LEVEL</code></p>
<p>Эти три столбца используются с другими столбцами, чтобы предоставить
информацию следующим образом для запросов верхнего уровня (невложенных) и
вложенные запросы (выполненных в пределах сохраненной программы).</p>

<p>Для высокоуровневых запросов:
<pre>
OBJECT_TYPE = NULL
OBJECT_SCHEMA = NULL
OBJECT_NAME = NULL
NESTING_EVENT_ID = NULL
NESTING_EVENT_TYPE = NULL
NESTING_LEVEL = 0
</pre>

<p>Для вложенных запросов:
<pre>
OBJECT_TYPE = родительский тип объекта запроса
OBJECT_SCHEMA = родительская схема объекта
OBJECT_NAME = родительское название объекта
NESTING_EVENT_ID = EVENT_ID родительского запроса
NESTING_EVENT_TYPE = 'STATEMENT'
NESTING_LEVEL = NESTING_LEVEL родительского запроса+1
</pre></li></ul>

<p>У <a href="#events-statements-current-table"><code>
events_statements_current</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>, <code>EVENT_ID</code>).
</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-statements-current-table"><code>
events_statements_current</code></a>. Это удаляет строки.</p>

<h4><a name="events-statements-history-table"></a>23.9.6.2.
Таблица events_statements_history</h4>
<p><a href="#events-statements-history-table"><code>
events_statements_history</code></a> содержит <em><code>N</code></em> новых
событий запроса на поток. Значение <em><code>N</code></em> задано
при запуске сервера. Чтобы установить табличный размер явно, установите
при запуске сервера переменную
<a href="#sysvar_performance_schema_events_statements_history_size">
<code>performance_schema_events_statements_history_size</code></a>.
Событие запроса не добавлено к таблице, пока оно не закончено. Когда
новые события добавлены, от более старых событий отказываются,
если таблица полна.</p>

<p><a href="#events-statements-history-table"><code>
events_statements_history</code></a> имеет ту же структуру, что и
<a href="#events-statements-current-table"><code>
events_statements_current</code></a>. См.
<a href="#events-statements-current-table">раздел 23.9.6.1</a>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-statements-history-table"><code>
events_statements_history</code></a>. Это удаляет строки.</p>

<h4><a name="events-statements-history-long-table"></a>23.9.6.3.
Таблица events_statements_history_long</h4>
<p><a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a> содержит <em><code>N</code></em>
новых событий запроса. Значение <em><code>N</code></em> задано при запуске
сервера. Чтобы установить табличный размер явно, установите при
запуске сервера переменную
<a href="#sysvar_performance_schema_events_statements_history_long_size">
<code>performance_schema_events_statements_history_long_size</code></a>.
События не добавлены к таблице, пока они не закончились. Когда
новые события добавлены, от более старых событий отказываются, если таблица
полна. Когда поток заканчивается, его строки удалены из таблицы.</p>

<p><a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a> имеет ту же структуру, что и
<a href="#events-statements-current-table"><code>
events_statements_current</code></a>, но без индексов. См.
<a href="#events-statements-current-table">раздел 23.9.6.1</a>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a>. Это удаляет строки.</p>

<h4><a name="prepared-statements-instances-table"></a>23.9.6.4.
Таблица prepared_statements_instances</h4>
<p>Performance Schema обеспечивает инструментовку для готовых запросов, для
которых есть два протокола:</p>

<ul><li><p>Протокол двоичной синхронной передачи данных. К этому получают
доступ через MySQL C API, и он отображается на основные команды сервера как
показано в следующей таблице.</p>

<table border="1">
<thead><tr><th scope="col">Функция C API</th><th scope="col">
Соответствующая команда сервера</th></tr></thead>
<tbody><tr><td scope="row"><a href="connect.htm#mysql-stmt-prepare"><code>
mysql_stmt_prepare()</code></a></td>
<td><code>COM_STMT_PREPARE</code></td></tr>
<tr><td scope="row"><a href="connect.htm#mysql-stmt-execute"><code>
mysql_stmt_execute()</code></a></td>
<td><code>COM_STMT_EXECUTE</code></td></tr>
<tr><td scope="row"><a href="connect.htm#mysql-stmt-close"><code>
mysql_stmt_close()</code></a></td><td><code>COM_STMT_CLOSE</code>
</td></tr></tbody></table></li>

<li><p>Текстовый протокол. К этому получают доступ, используя запросы SQL и
отображая на основные команды сервера, как показано в следующей таблице.</p>
<table border="1">
<thead><tr><th scope="col">SQL-запрос</th>
<th scope="col">Соответствующая команда сервера</th></tr></thead>
<tbody><tr><td scope="row"><a href="sql.htm#prepare"><code>PREPARE</code></a>
</td><td><code>SQLCOM_PREPARE</code></td></tr>
<tr><td scope="row"><a href="sql.htm#execute"><code>EXECUTE</code></a></td>
<td><code>SQLCOM_EXECUTE</code></td></tr>
<tr><td scope="row"><a href="sql.htm#deallocate-prepare"><code>DEALLOCATE
PREPARE</code></a>, <a href="sql.htm#deallocate-prepare"><code>DROP PREPARE
</code></a></td>
<td><code>SQLCOM_DEALLOCATE PREPARE</code></td></tr></tbody></table></li></ul>

<p>Performance Schema подготовила покрытие инструментовки обоих протоколов.
Следующее обсуждение отсылает к командам сервера, а не функциям C API
или запросам SQL.</p>

<p>Информация о готовых запросах доступна в таблице
<a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>. Эта таблица включает просмотр
готовых запросов, используемых в сервере, и обеспечивает соединенную
статистику о них. Чтобы управлять размером этой таблицы, установите
при запуске сервера системную переменную
<a href="#sysvar_performance_schema_max_prepared_statements_instances">
<code>performance_schema_max_prepared_statements_instances</code></a>.</p>

<p>Сбор готовой информации о запросе зависит от инструментов запроса,
показанных в следующей таблице. Эти инструменты включены по умолчанию. Чтобы
изменить их, обновите <a href="#setup-instruments-table"><code>
setup_instruments</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Инструмент</th><th scope="col">Команда сервера
</th></tr></thead>
<tbody><tr><td scope="row"><code>statement/com/Prepare</code></td>
<td><code>COM_STMT_PREPARE</code></td></tr>
<tr><td scope="row"><code>statement/com/Execute</code></td>
<td><code>COM_STMT_EXECUTE</code></td></tr>
<tr><td scope="row"><code>statement/sql/prepare_sql</code></td>
<td><code>SQLCOM_PREPARE</code></td></tr>
<tr><td scope="row"><code>statement/sql/execute_sql</code></td>
<td><code>SQLCOM_EXECUTE</code></td></tr></tbody></table>

<p>Performance Schema управляет содержанием
<a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a> следующим образом:</p>

<ul><li><p>Подготовка запроса.</p>
<p>Команда <code>COM_STMT_PREPARE</code> или <code>SQLCOM_PREPARE</code>
создает готовый запрос в сервере. Если запрос успешно инструментован, новая
строка добавлена к <a href="#prepared-statements-instances-table">
<code>prepared_statements_instances</code></a>.
Если запрос не может быть инструментован, увеличена переменная
<a href="#statvar_Performance_schema_prepared_statements_lost">
<code>Performance_schema_prepared_statements_lost</code></a>.</li>

<li>Выполнение готового запроса.</p>
<p>Выполнение команды <code>COM_STMT_EXECUTE</code> или
<code>SQLCOM_PREPARE</code> для инструментованного готового случая запроса
обновляет соответствующую строку таблицы
<a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>.</li>

<li>Освобождение готового запроса.</p>
<p>Выполнение команды <code>COM_STMT_CLOSE</code> или
<code>SQLCOM_DEALLOCATE_PREPARE</code> для инструментованного готового случая
запроса удаляет соответствующую строку таблицы
<a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>. Чтобы избежать утечек ресурса,
удаление происходит, даже если инструменты готового запроса,
описанные ранее, отключены.</p></li></ul>

<p>У <a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a> есть эти столбцы:</p>
<ul><li><p><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Адрес в памяти инструментованного готового запроса.</li>
<li><code>STATEMENT_ID</code></p>
<p>Внутренний ID, назначенный сервером.</li>

<li><code>STATEMENT_NAME</code></p>
<p>Для протокола двоичной синхронной передачи данных этот столбец
<code>NULL</code>. Для текстового протокола этот столбец внешнее имя,
назначенное пользователем. Например, для следующего запроса SQL, название
готового запроса <code>stmt</code>:
<pre>
PREPARE stmt FROM 'SELECT 1';
</pre></li>

<li><code>SQL_TEXT</code></p>
<p>Готовый текст запроса с маркерами заполнителями <code>?</code>.</li>
<li><code>OWNER_THREAD_ID</code>, <code>OWNER_EVENT_ID</code></p>
<p>Эти столбцы указывают на событие, которое создало готовый запрос.</li>

<li><code>OWNER_OBJECT_TYPE</code>, <code>OWNER_OBJECT_SCHEMA</code>,
<code>OWNER_OBJECT_NAME</code></p>
<p>Для готового запроса, создаваемого сеансом клиента, эти столбцы
<code>NULL</code>. Для готового запроса, создаваемого сохраненной программой,
эти столбцы указывают на сохраненную программу. Типичная пользовательская
ошибка в том, что пользователь забывает освобождать подготовленные запросы.
Эти столбцы могут использоваться, чтобы найти сохраненные программы, которые
пропускают готовые запросы:
<pre>
SELECT OWNER_OBJECT_TYPE, OWNER_OBJECT_SCHEMA, OWNER_OBJECT_NAME,
       STATEMENT_NAME, SQL_TEXT
       FROM performance_schema.prepared_statements_instances
       WHERE OWNER_OBJECT_TYPE IS NOT NULL;
</pre></li>

<li><code>TIMER_PREPARE</code></p>
<p>Время на выполнение подготовки запроса.</li>
<li><code>COUNT_REPREPARE</code></p>
<p>Сколько раз запрос был повторно подготовлено внутренне (см.
<a href="optimiz.htm#statement-caching">раздел 9.10.4</a>).
Статистические данные синхронизации для переподготовки недоступны, потому
что это посчитано как часть выполнения запроса, не как отдельная работа.</li>

<li><code>COUNT_EXECUTE</code>, <code>SUM_TIMER_EXECUTE</code>,
<code>MIN_TIMER_EXECUTE</code>, <code>AVG_TIMER_EXECUTE</code>,
<code>MAX_TIMER_EXECUTE</code></p>
<p>Соединенная статистика для выполнения готового запроса.</li>

<li><code>SUM_<em><code>xxx</code></em></code></p>
<p>Остающееся столбцы <code>SUM_<em><code>xxx</code></em></code>
то же самое, что касается сводных таблиц запросов (см.
<a href="#statement-summary-tables">раздел 23.9.15.3</a>).
</p></li></ul>

<p>У <a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>STATEMENT_ID</code>).</li>
<li>Индекс на (<code>STATEMENT_NAME</code>).</li>
<li>Индекс на (<code>OWNER_THREAD_ID</code>, <code>OWNER_EVENT_ID</code>).
</li>

<li>Индекс на (<code>OWNER_OBJECT_TYPE</code>,
<code>OWNER_OBJECT_SCHEMA</code>, <code>OWNER_OBJECT_NAME</code>).
</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
сбрасывает столбцы статистики
<a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>.</p>

<h3><a name="performance-schema-transaction-tables"></a>23.9.7.
Операционные таблицы Performance Schema</h3>
<p>Эти таблицы хранят операционные события:</p>

<ul><li><p><a href="#events-transactions-current-table"><code>
events_transactions_current</code></a>: Текущие операционные события.</li>
<li><a href="#events-transactions-history-table"><code>
events_transactions_history</code></a>:
Новые операционные события для каждого потока.</li>

<li><a href="#events-transactions-history-long-table"><code>
events_transactions_history_long</code></a>:
Новые операционные события повсюду.</p></li></ul>

<h4><a name="performance-schema-transaction-tables-configuration"></a>
Операционная конфигурация событий</h4>
<p>Чтобы включить сбор операционных событий, включите
соответствующие инструменты и потребителей.</p>

<p><a href="#setup-instruments-table"><code>setup_instruments
</code></a> содержит инструмент <code>transaction</code>.
Этот инструмент отключен по умолчанию:
<pre>
mysql&gt; SELECT * FROM setup_instruments WHERE NAME = 'transaction';
+-------------+---------+-------+
| NAME        | ENABLED | TIMED |
+-------------+---------+-------+
| transaction | NO      | NO    |
+-------------+---------+-------+
</pre>

<p>Чтобы включить сбор операционных событий,
включая информацию о синхронизации:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED = 'YES', TIMED = 'YES'
                 WHERE NAME = 'transaction';
</pre>

<p><a href="#setup-consumers-table"><code>setup_consumers</code>
</a> содержит потребительские значения с именами, соответствующими текущим и
недавним операционным именам таблиц событий. Эти потребители могут
использоваться, чтобы фильтровать набор операционных событий:
<pre>
mysql&gt; SELECT * FROM setup_consumers WHERE NAME LIKE '%transactions%';
+----------------------------------+---------+
| NAME                             | ENABLED |
+----------------------------------+---------+
| events_transactions_current      | NO      |
| events_transactions_history      | NO      |
| events_transactions_history_long | NO      |
+----------------------------------+---------+
</pre>

<p>Чтобы включить всех операционных потребителей:
<pre>
mysql&gt; UPDATE setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%transactions%';
</pre>

<p>Чтобы включить сбор операционных событий только для определенных
операционных таблиц событий, включите
соответствующих операционных потребителей.</p>

<p><a href="#setup-timers-table"><code>setup_timers</code></a>
содержит строку с <code>NAME</code> <code>transaction</code>, которая
указывает на модуль для операционной синхронизации событий.
Модуль по умолчанию <code>NANOSECOND</code>.
<pre>
mysql&gt; SELECT * FROM setup_timers WHERE NAME = 'transaction';
+-------------+------------+
| NAME        | TIMER_NAME |
+-------------+------------+
| transaction | NANOSECOND |
+-------------+------------+
</pre>

<p>Чтобы изменить модуль синхронизации, измените <code>TIMER_NAME</code>:
<pre>
mysql&gt; UPDATE setup_timers SET TIMER_NAME = 'MICROSECOND'
                 WHERE NAME = 'transaction';
</pre>

<h4><a name="performance-schema-transaction-tables-transaction-boundaries">
</a>Операционные границы</h4>
<p>В MySQL Server транзакции запускаются явно с этих запросов:
<pre>
START TRANSACTION | BEGIN | XA START | XA BEGIN
</pre>

<p>Транзакции также запускаются неявно. Например, когда включена переменная
<a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>,
запуск каждого запроса запускает новую транзакцию.</p>

<p>Если <a href="server.htm#sysvar_autocommit"><code>autocommit</code></a>
выключена, первый запрос после переданной транзакции отмечает запуск новой
транзакции. Последующие запросы это часть транзакции, пока это не передано.
</p>

<p>Транзакции явно заканчиваются этими запросами:
<pre>
COMMIT | ROLLBACK | XA COMMIT | XA ROLLBACK
</pre>

<p>Транзакции также заканчиваются неявно, выполнением запросов DDL, запросами
блокировки и запросами администрирования сервера.</p>
<p>В следующем обсуждении ссылки на
<a href="sql.htm#commit"><code>START TRANSACTION</code></a> также применимы к
<a href="sql.htm#commit"><code>BEGIN</code></a>,
<a href="sql.htm#xa-statements"><code>XA START</code></a> и
<a href="sql.htm#xa-statements"><code>XA BEGIN</code></a>. Точно так же
ссылки на <a href="sql.htm#commit"><code>COMMIT</code></a> и
<a href="sql.htm#commit"><code>ROLLBACK</code></a> относятся к
<a href="sql.htm#xa-statements"><code>XA COMMIT</code></a> и
<a href="sql.htm#xa-statements"><code>XA ROLLBACK</code></a>.</p>

<p>Performance Schema определяет операционные границы аналогично серверу.
Запуск и конец операционного случая близко соответствуют соответствующим
изменениям состояния в сервере:</p>

<ul><li><p>Для явно запущенной транзакции операционный случай запускается во
время обработки <a href="sql.htm#commit"><code>START TRANSACTION</code></a>.
</li>

<li>Для неявно запущенной транзакции операционный случай запускается на
первом запросе, который использует транзакционный механизм после того, как
предыдущая транзакция закончилась.</li>

<li>Для любой транзакции, явно или неявно законченной, заканчивается
операционный случай, когда сервер выходит из активной транзакции во
время обработки <a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.</p></li></ul>

<p>Есть тонкие значения к этому подходу:</p>
<ul><li><p>Операционные события в Performance Schema не полностью включают
события запроса, связанные с передачей
<a href="sql.htm#commit"><code>START TRANSACTION</code></a>,
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.
Есть тривиальное количество перекрытия синхронизации между операционным
случаем и этими запросыми.</li>

<li>Запросы, которые работают с нетранзакционными механизмами, не имеют
никакого эффекта на операционное состояние соединения. Для неявных транзакций
операционный случай начинается с первого запроса, который использует
транзакционный механизм. Это означает, что запросы, воздействующие
исключительно на нетранзакционные таблицы, проигнорированы, даже после
<a href="sql.htm#commit"><code>START TRANSACTION</code></a>.</p></li></ul>

<p>Чтобы иллюстрировать, рассмотрите следующий сценарий:
<pre>
1. SET autocommit = OFF;
2. CREATE TABLE t1 (a INT) ENGINE = InnoDB;
3. START TRANSACTION; -- Transaction 1 START
4. INSERT INTO t1 VALUES (1), (2), (3);
5. CREATE TABLE t2 (a INT) ENGINE = MyISAM; -- Transaction 1 COMMIT
  -- (implicit; DDL forces commit)
6. INSERT INTO t2 VALUES (1), (2), (3); -- Update nontransactional table
7. UPDATE t2 SET a = a + 1; -- ... and again
8. INSERT INTO t1 VALUES (4), (5), (6); -- Write to transactional table
  -- Transaction 2 START (implicit)
9. COMMIT;-- Transaction 2 COMMIT
</pre>

<p>С точки зрения сервера, транзакция 1 завершилась, когда таблица
<code>t2</code> создается. Транзакция 2 не запускается, пока к транзакционный
таблице не получают доступ, несмотря на прошедшие
обновления нетранзакционных таблиц.</p>

<p>С точки зрения Performance Schema, транзакция 2 запускается, когда сервер
переходит в активное состояние транзакции. Запросы 6 и 7 не включены в
пределы границ транзакции 2, которые совместимы с тем, как сервер пишет
транзакции в двоичный журнал.</p>

<h4><a name="performance-schema-transaction-tables-instrumentation"></a>
Операционная инструментовка</h4>
<p>Три признака определяют транзакции:</p>
<ul><li><p>Режим доступа (только для чтения, чтение-запись).</li>
<li>Уровень изоляции (<a href="innodb.htm#isolevel_serializable"><code>
SERIALIZABLE</code></a>, <a href="innodb.htm#isolevel_repeatable-read"><code>
REPEATABLE READ</code></a>, и т.д.).</li>

<li>Неявная (включен <a href="server.htm#sysvar_autocommit"><code>autocommit
</code></a>) или явная (выключен <a href="server.htm#sysvar_autocommit">
<code>autocommit</code></a>).</p></li></ul>

<p>Чтобы уменьшить сложность операционной инструментовки и гарантировать, что
собранные операционные данные обеспечивают полные, значащие результаты, все
транзакции инструментованы независимо от режима доступа, уровня изоляции
или режима autocommit.</p>

<p>Чтобы выборочно исследовать операционную историю, используйте столбцы
признака в операционных таблицах событий: <code>ACCESS_MODE</code>,
<code>ISOLATION_LEVEL</code> и <code>AUTOCOMMIT</code>.</p>

<p>Стоимость операционной инструментовки может быть уменьшена различными
путями, такими как включение или отключение операционной инструментовки,
согласно пользователю, учетной записи, узлу или потоку (соединению клиента).
</p>

<h4><a name="performance-schema-transaction-tables-nested-events"></a>
Транзакции и вложенные события</h4>
<p>Родитель операционного случая это случай, который начал транзакцию.
Для явно запущенной транзакции это включает
<a href="sql.htm#commit"><code>START TRANSACTION</code></a> и
<a href="sql.htm#commit"><code>COMMIT AND CHAIN</code></a>. Для неявно
запущенной транзакции это первый запрос, который использует транзакционный
механизм после того, как предыдущая транзакция заканчивается.</p>

<p>Вообще, транзакция высокоуровневый родитель ко всем событиям, начатым во
время транзакции, включая запросы, которые явно заканчивают транзакцию, такие
как <a href="sql.htm#commit"><code>COMMIT</code></a> и
<a href="sql.htm#commit"><code>ROLLBACK</code></a>. Исключения: запросы,
которые неявно заканчивают транзакцию, такие как запросы DDL, когда текущая
транзакция должна быть закрыта прежде, чем новый запрос выполнен.</p>

<h4><a name="performance-schema-transaction-tables-stored-programs"></a>
Транзакции и сохраненные программы</h4>
<p>Транзакции и сохраненные события программы связаны следующим образом:</p>

<ul><li><p>Хранимые процедуры.</p>
<p>Хранимые процедуры работают независимо от транзакций. Хранимая процедура
может быть запущена в пределах транзакции, и транзакция может быть запущена
или закончена изнутри хранимой процедуры. Если вызвана изнутри транзакции,
хранимая процедура может выполнить запросы, которые вызывают передачу
родительской транзакции и затем запускают новую транзакцию.</p>

<p>Если хранимая процедура запущена в пределах транзакции, та транзакция
родитель случая хранимой процедуры.</p>
<p>Если транзакция запущена хранимой процедурой, хранимая процедура
родитель операционного случая.</li>

<li>Сохраненные функции.</p>
<p>Сохраненные функции ограничены от порождения явной или неявной передачи
или отмены транзакции. Сохраненные функциональные события могут находиться в
пределах родительского операционного случая.</li>

<li>Триггеры.</p>
<p>Триггеры активируются как часть запроса, обращающегося
к таблице, с которой он связан, таким образом, родитель случая триггера
всегда запрос, который активирует его.</p>
<p>Триггеры не могут сделать запросы, которые вызывают явную или неявную
передают или отмену транзакции.</li>

<li>Запланированные события.</p>
<p>Выполнение запросов в теле запланированного события
имеет место в новом соединении. Вложение запланированного события
в пределы родительской транзакции неприменимо.</p></li></ul>

<h4><a name="performance-schema-transaction-tables-savepoints"></a>
Транзакции и Savepoints</h4>
<p>Запросы Savepoint зарегистрированы как отдельные события.
Операционные события включают отдельные счетчики для
<a href="sql.htm#savepoint"><code>SAVEPOINT</code></a>,
<a href="sql.htm#savepoint"><code>ROLLBACK TO SAVEPOINT</code></a> и
<a href="sql.htm#savepoint"><code>RELEASE SAVEPOINT</code></a>, которые
произошли во время транзакции.</p>

<h4><a name="performance-schema-transaction-tables-errors"></a>
Транзакции и ошибки</h4>
<p>Ошибки и предупреждения, которые происходят в пределах транзакции,
зарегистрированы в событиях запросов, но не в соответствующем операционном
событии. Это включает определенные для транзакции ошибки и предупреждения,
такие как отмена транзакции на нетранзакционный таблице или
ошибка последовательности GTID.</p>

<h4><a name="events-transactions-current-table"></a>23.9.7.1.
Таблица events_transactions_current</h4>
<p><a href="#events-transactions-current-table"><code>
events_transactions_current</code></a> содержит текущие операционные события,
одну строку на поток, показывая текущий статус нового
отслеживающего потока. Например:
<pre>
mysql&gt; SELECT * FROM events_transactions_current LIMIT 1\G
*************************** 1. row ***************************
THREAD_ID: 26
 EVENT_ID: 7
 END_EVENT_ID: NULL
   EVENT_NAME: transaction
  STATE: ACTIVE
 TRX_ID: NULL
   GTID: 3E11FA47-71CA-11E1-9E33-C80AA9429562:56
XID: NULL
 XA_STATE: NULL
 SOURCE: transaction.cc:150
  TIMER_START: 420833537900000
TIMER_END: NULL
   TIMER_WAIT: NULL
  ACCESS_MODE: READ WRITE
ISOLATION_LEVEL: REPEATABLE READ
   AUTOCOMMIT: NO
 NUMBER_OF_SAVEPOINTS: 0
NUMBER_OF_ROLLBACK_TO_SAVEPOINT: 0
NUMBER_OF_RELEASE_SAVEPOINT: 0
OBJECT_INSTANCE_BEGIN: NULL
   NESTING_EVENT_ID: 6
 NESTING_EVENT_TYPE: STATEMENT
</pre>

<p>Из таблиц, которые содержат операционные строки событий,
<a href="#events-transactions-current-table"><code>
events_transactions_current</code></a> является самой фундаментальной. Другие
таблицы, которые содержат операционные строки событий, логически получены из
текущих событий. Например,
<a href="#events-transactions-history-table"><code>
events_transactions_history</code></a> и
<a href="#events-transactions-history-long-table"><code>
events_transactions_history_long</code></a>
собирают новые операционные события до постоянного числа строк.</p>

<p>У <a href="#events-transactions-current-table"><code>
events_transactions_current</code></a> есть эти столбцы:</p>
<ul><li><p><code>THREAD_ID</code>, <code>EVENT_ID</code></p>
<p>Поток, связанный со случаем и текущим числом событий потока, когда случай
запускается. <code>THREAD_ID</code> и <code>EVENT_ID</code> вместе
уникально идентифицируют строку. Ни у каких двух строк нет той же
самой пары значений.</li>

<li><code>END_EVENT_ID</code></p>
<p>Этот столбец установлен в <code>NULL</code>, когда случай запускается и
обновлен к текущему числу событий потока, когда случай заканчивается.</li>

<li><code>EVENT_NAME</code></p>
<p>Название инструмента, у которого был собран случай. Это <code>NAME</code>
из <a href="#setup-instruments-table"><code>setup_instruments
</code></a>. Инструментальные имена могут иметь много частей и сформировать
иерархию, как обсуждено в
<a href="#performance-schema-instrument-naming">разделе 23.4</a>.
</li>

<li><code>STATE</code></p>
<p>Текущее операционное состояние. Значение <code>ACTIVE</code> (после
<a href="sql.htm#commit"><code>START TRANSACTION</code></a> или
<a href="sql.htm#commit"><code>BEGIN</code></a>), <code>COMMITTED</code>
(после <a href="sql.htm#commit"><code>COMMIT</code></a>) или <code>ROLLED
BACK</code> (после <a href="sql.htm#commit"><code>ROLLBACK</code></a>).</li>

<li><code>TRX_ID</code></p>
<p>Не использован.</li>
<li><code>GTID</code></p>
<p>Столбец GTID содержит значение
<a href="replica.htm#sysvar_gtid_next"><code>gtid_next</code></a>,
которое может быть одним из <code>ANONYMOUS</code>, <code>AUTOMATIC</code>
или GTID с использованием формата <code>UUID:NUMBER</code>.
Для транзакций с использованием <a href="replica.htm#sysvar_gtid_next"><code>
gtid_next=AUTOMATIC</code></a> (это все нормальные транзакции клиента),
столбец GTID меняется, когда транзакция завершается и фактический GTID
назначен. Если <a href="replica.htm#sysvar_gtid_mode"><code>gtid_mode</code>
</a> <code>ON</code> или <code>ON_PERMISSIVE</code>, столбец GTID
изменяется на GTID транзакции. Если <code>gtid_mode</code> <code>OFF</code>
или <code>OFF_PERMISSIVE</code>, столбец GTID
изменяется на <code>ANONYMOUS</code>.</li>

<li><code>XID_FORMAT_ID</code>, <code>XID_GTRID</code>,
<code>XID_BQUAL</code></p>
<p>Компоненты операционного идентификатора XA. Их формат описан в
<a href="sql.htm#xa-statements">разделе 14.3.7.1</a>.</li>

<li><code>XA_STATE</code></p>
<p>Состояние транзакции XA. Значение <code>ACTIVE</code> (после
<a href="sql.htm#xa-statements"><code>XA START</code></a>), <code>IDLE</code>
(после <a href="sql.htm#xa-statements"><code>XA END</code></a>),
<code>PREPARED</code> (после <a href="sql.htm#xa-statements"><code>XA
PREPARE</code></a>), <code>ROLLED BACK</code> (после
<a href="sql.htm#xa-statements"><code>XA ROLLBACK</code></a>) или
<code>COMMITTED</code> (после <a href="sql.htm#xa-statements"><code>XA
COMMIT</code></a>).</li>

<li><code>SOURCE</code></p>
<p>Название исходного файла, содержащего инструментованный код, который
произвел случай и номер строки в файле, в котором происходит инструментовка.
Это позволяет Вам проверить источник, чтобы определить точно,
какой код вовлечен.</li>

<li><code>TIMER_START</code>, <code>TIMER_END</code>,
<code>TIMER_WAIT</code></p>
<p>Информация о синхронизации для случая. Модуль для этих значений
пикосекунды. <code>TIMER_START</code> и <code>TIMER_END</code>
указывают, когда синхронизация событий запустилась и закончилась.
<code>TIMER_WAIT</code> продолжительность.</p>

<p>Если случай не закончился, <code>TIMER_END</code> текущее значение
таймера и <code>TIMER_WAIT</code> время, законченное до сих пор
(<code>TIMER_END</code> - <code>TIMER_START</code>).</p>

<p>Если случай произведен из инструмента, который имеет
<code>TIMED = NO</code>, информация синхронизации не собрана, и
<code>TIMER_START</code>, <code>TIMER_END</code> и
<code>TIMER_WAIT</code> <code>NULL</code>.</p></li>

<li><code>ACCESS_MODE</code></p>
<p>Операционный режим доступа. Значение <code>READ ONLY</code>
или <code>READ WRITE</code>.</li>

<li><code>ISOLATION_LEVEL</code></p>
<p>Операционный уровень изоляции. Значение
<a href="innodb.htm#isolevel_repeatable-read"><code>REPEATABLE READ</code>
</a>, <a href="innodb.htm#isolevel_read-committed"><code>READ COMMITTED
</code></a>, <a href="innodb.htm#isolevel_read-uncommitted"><code>READ
UNCOMMITTED</code></a> или <a href="innodb.htm#isolevel_serializable"><code>
SERIALIZABLE</code></a>.</li>

<li><code>AUTOCOMMIT</code></p>
<p>Был ли режим autcommit включен, когда транзакция запускалась.</li>
<li><code>NUMBER_OF_SAVEPOINTS</code>,
<code>NUMBER_OF_ROLLBACK_TO_SAVEPOINT</code>,
<code>NUMBER_OF_RELEASE_SAVEPOINT</code></p>
<p>Число запросов <a href="sql.htm#savepoint"><code>SAVEPOINT</code></a>,
<a href="sql.htm#savepoint"><code>ROLLBACK TO SAVEPOINT</code></a> и
<a href="sql.htm#savepoint"><code>RELEASE SAVEPOINT</code></a>
во время транзакции.</li>

<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Не использован.</li>
<li><code>NESTING_EVENT_ID</code></p>
<p><code>EVENT_ID</code> случая, в пределах которого вложен этот случай.</li>

<li><code>NESTING_EVENT_TYPE</code></p>
<p>Тип вложения событий. Значение
<code>TRANSACTION</code>, <code>STATEMENT</code>, <code>STAGE</code> или
<code>WAIT</code>. <code>TRANSACTION</code> не будет появляться, потому что
транзакции не могут быть вложены.</p></li></ul>

<p>У <a href="#events-transactions-current-table"><code>
events_transactions_current</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>EVENT_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-transactions-current-table"><code>
events_transactions_current</code></a>. Это удаляет строки.</p>

<h4><a name="events-transactions-history-table"></a>23.9.7.2.
Таблица events_transactions_history</h4>
<p>Таблица <a href="#events-transactions-history-table"><code>
events_transactions_history</code></a> хранит <em><code>N</code></em>
последних операционных событий на поток. Значение <em><code>N</code></em>
задано при запуске сервера. Чтобы установить табличный размер явно,
установите системную переменную
<a href="#sysvar_performance_schema_events_transactions_history_size">
<code>performance_schema_events_transactions_history_size</code></a>
при запуске сервера. Операционные события не добавлены к таблице, пока они не
закончены. Когда новые события добавлены, от более старых событий
отказываются, если таблица полна.</p>

<p>Таблица <a href="#events-transactions-history-table"><code>
events_transactions_history</code></a> имеет ту же самую структуру, как
<a href="#events-transactions-current-table"><code>
events_transactions_current</code></a>, включая индексацию. См.
<a href="#events-transactions-current-table">раздел 23.9.7.1</a>.
</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-transactions-history-table"><code>
events_transactions_history</code></a>. Это удаляет строки.</p>

<h4><a name="events-transactions-history-long-table"></a>23.9.7.3.
Таблица events_transactions_history_long</h4>
<p>Таблица <a href="#events-transactions-history-long-table"><code>
events_transactions_history_long</code></a> хранит <em><code>N</code></em>
новых операционных событий. Значение <em><code>N</code></em>
задано при запуске сервера. Чтобы установить табличный размер явно,
установите при запуске сервера системную переменную
<a href="#sysvar_performance_schema_events_transactions_history_long_size">
<code>performance_schema_events_transactions_history_long_size</code></a>.
Операционные события не добавлены к таблице, пока они не закончены. Когда
новые события добавлены, от более старых событий отказываются, если таблица
полна. Когда поток заканчивается, его строки удалены из таблицы.</p>

<p>У <a href="#events-transactions-history-long-table"><code>
events_transactions_history_long</code></a> та же самая структура, как у
<a href="#events-transactions-current-table"><code>
events_transactions_current</code></a>, за исключением того, что это не имеет
индексов. См. <a href="#events-transactions-current-table">раздел
23.9.7.1</a>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на <a href="#events-transactions-history-long-table"><code>
events_transactions_history_long</code></a>. Это удаляет строки.</p>

<h3><a name="performance-schema-connection-tables"></a>23.9.8.
Таблицы соединения Performance Schema</h3>
<p>Когда клиент соединяется с сервером MySQL, он делает это под именем
пользователя и от конкретного узла. Performance Schema
обеспечивает статистику об этих соединениях, отслеживая их для учетной записи
(комбинация пользователя и узла), а также отдельно для имени пользователя и
имени хоста, используя эти таблицы:</p>

<ul><li><p><a href="#accounts-table"><code>accounts</code></a>:
Статистика соединения по учетной записи клиента.</li>
<li><a href="#hosts-table"><code>hosts</code></a>:
Статистика соединения по имени хоста клиента.</li>
<li><a href="#users-table"><code>users</code></a>:
Статистика соединения по имени пользователя клиента.</p></li></ul>

<p>Значение <span>account</span> в таблицах соединения подобно его значению в
таблицах привилегий MySQL базы данных <code>mysql</code>,
в том смысле, что термин относится к комбинации значений узла и пользователя.
Они отличаются в том, что для таблиц привилегий часть узла учетной записи
может быть образцом, тогда как для Performance Schema значение узла всегда
определенное имя хоста.</p>

<p>Каждая таблица соединения имеет столбцы <code>CURRENT_CONNECTIONS</code> и
<code>TOTAL_CONNECTIONS</code>, чтобы отследить текущее и общее количество
соединений за <span>преиод слежения</span> на котором базируются
статистические данные. Таблицы отличаются по тому, что они используют для
значения отслеживания. Таблица
<a href="#accounts-table"><code>accounts</code></a> имеет столбцы
<code>USER</code> и <code>HOST</code>, чтобы отследить соединения на
комбинацию пользователя и узла. <a href="#users-table"><code>users
</code></a> и <a href="#hosts-table"><code>hosts</code></a> имеют
столбцы <code>USER</code> и <code>HOST</code>, соответственно, чтобы
отследить соединения за имя пользователя и имя хоста.</p>

<p>Performance Schema также считает внутренние потоки и потоки для
пользовательских сеансов, которые были не в состоянии подтвердить
подлинность, используя строки со столбцами
<code>USER</code> и <code>HOST</code> <code>NULL</code>.</p>

<p>Предположите, что клиенты <code>user1</code> и <code>user2</code>
соединились с машин <code>hosta</code> и <code>hostb</code>. Performance
Schema отслеживает соединения следующим образом:</p>

<ul><li><p>Таблица <a href="#accounts-table"><code>accounts</code>
</a> имеет четыре строки, считая одно соединение за учетную запись, для
<code>user1</code>/<code>hosta</code>, <code>user1</code>/<code>hostb</code>,
<code>user2</code>/<code>hosta</code> и
<code>user2</code>/<code>hostb</code>.</li>

<li>Таблица <a href="#hosts-table"><code>hosts</code></a> имеет
имеет две строки для <code>hosta</code> и <code>hostb</code>,
считая два соединения на имя хоста.</li>

<li>Таблица <a href="#users-table"><code>users</code></a>
имеет две строки для <code>user1</code> и <code>user2</code>,
считая два соединения на имя пользователя.</p></li></ul>

<p>Когда клиент соединяется, Performance Schema определяет, какая строка в
каждой таблице соединения применяется, используя значение отслеживания,
соответствующее каждой таблице. Если нет такой строки, она добавлена. Тогда
Performance Schema постепенно увеличивает столбцы <code>CURRENT_CONNECTIONS
</code> и <code>TOTAL_CONNECTIONS</code> в этой строке.</p>

<p>Когда клиент разъединяется, Performance Schema уменьшает столбец
<code>CURRENT_CONNECTIONS</code> в строке и не меняет
столбец <code>TOTAL_CONNECTIONS</code>.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на таблицах соединения. Это имеет эффекты:</p>
<ul><li><p>Строки удалены для учетных записей, узлов или пользователей, у
которых нет никаких текущих соединений (строки с
<code>CURRENT_CONNECTIONS = 0</code>).</li>

<li>Неудаленные строки сброшены, чтобы посчитать только текущие соединения:
для строк с <code>CURRENT_CONNECTIONS &gt; 0</code>,
<code>TOTAL_CONNECTIONS</code> сброшен к <code>CURRENT_CONNECTIONS</code>.
</li>
<li>Сводные таблицы, которые зависят от таблицы соединения, являются неявно
усеченными, как описано позже в этом разделе.</p></li></ul>

<p>Performance Schema поддерживает сводные таблицы, которые ведут совокупную
статистику соединений для различных типов случаев по учетной записи, узлу или
пользователю. Эти таблицы имеют в имени <code>_summary_by_account</code>,
<code>_summary_by_host</code> или <code>_summary_by_user</code>.
Чтобы идентифицировать их, используйте этот запрос:
<pre>
mysql&gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES
                 WHERE TABLE_SCHEMA = 'performance_schema' AND
                 TABLE_NAME REGEXP '_summary_by_(account|host|user)'
                 ORDER BY TABLE_NAME;
+------------------------------------------------------+
| TABLE_NAME |
+------------------------------------------------------+
| events_errors_summary_by_account_by_error|
| events_errors_summary_by_host_by_error   |
| events_errors_summary_by_user_by_error   |
| events_stages_summary_by_account_by_event_name |
| events_stages_summary_by_host_by_event_name|
| events_stages_summary_by_user_by_event_name|
| events_statements_summary_by_account_by_event_name   |
| events_statements_summary_by_host_by_event_name|
| events_statements_summary_by_user_by_event_name|
| events_transactions_summary_by_account_by_event_name |
| events_transactions_summary_by_host_by_event_name|
| events_transactions_summary_by_user_by_event_name|
| events_waits_summary_by_account_by_event_name  |
| events_waits_summary_by_host_by_event_name |
| events_waits_summary_by_user_by_event_name |
| memory_summary_by_account_by_event_name  |
| memory_summary_by_host_by_event_name |
| memory_summary_by_user_by_event_name |
+------------------------------------------------------+
</pre>

<p>Для деталей об отдельных сводных таблицах соединения, консультируйтесь с
разделом, который описывает таблицы для полученного в итоге типа событий:</p>
<ul><li><p>Резюме событий ожидания: <a href="#wait-summary-tables">
раздел 23.9.15.1</a>.</li>

<li>Резюме этапа событий:
<a href="#stage-summary-tables">раздел 23.9.15.2</a>.</li>
<li>Резюме событий запросов:
<a href="#statement-summary-tables">раздел 23.9.15.3</a>.</li>

<li>Операционные резюме событий:
<a href="#transaction-summary-tables">раздел 23.9.15.4</a>.</li>
<li>Резюме событий памяти:
<a href="#memory-summary-tables">раздел 23.9.15.9</a>.</li>

<li>Резюме событий ошибок:
<a href="#error-summary-tables">раздел 23.9.15.10</a>.</li></ul>
<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на сводных таблицах соединения. Это удаляет строки для учетных записей, узлов
или пользователей без соединений и сбрасывает сводные столбцы к нолю для
остающихся строк. Кроме того, каждая сводная таблица, которая собирает данные
соединения по учетной записи, узлу, пользователю или потоку, неявно усечена
усечением таблицы соединения, от которой зависит. Следующая таблица описывает
отношения между табличным усечением соединения и неявно усеченными таблицами.
</p>

<a name="idm139965288978432"></a><p><b>Таблица 23.2.
Неявные эффекты табличного усечения соединения</b></p>
<table border="1">
<thead><tr><th scope="col">Усеченная таблица соединения</th>
<th scope="col">Неявно усеченные сводные таблицы</th></tr></thead>
<tbody><tr><td scope="row"><code>accounts</code></td>
<td>Таблицы с именами, содержащими <code>_summary_by_account</code>,
<code>_summary_by_thread</code></td></tr>
<tr><td scope="row"><code>hosts</code></td>
<td>Таблицы с именами, содержащими <code>_summary_by_account</code>,
<code>_summary_by_host</code>, <code>_summary_by_thread</code></td></tr>
<tr><td scope="row"><code>users</code></td>
<td>Таблицы с именами, содержащими <code>_summary_by_account</code>,
<code>_summary_by_user</code>, <code>_summary_by_thread</code></td>
</tr></tbody></table>

<p>Усечение <code>_summary_global</code> также неявно усекает свое
соответствующее соединение и сводные таблицы потока. Например, усечение
<a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a>
неявно усекает сводные таблицы событий ожидания, которые соединены с учетной
записью, узлом, пользователем или потоком.</p>

<h4><a name="accounts-table"></a>23.9.8.1. Таблица accounts</h4>
<p>Таблица <a href="#accounts-table"><code>accounts</code></a>
содержит строку для каждой учетной записи, которая соединилась с сервером
MySQL. Для каждой учетной записи таблица считает текущее и общее количество
соединений. Табличный размер задан при запуске сервера.
Чтобы установить табличный размер явно, установите системную переменную
<a href="#sysvar_performance_schema_accounts_size"><code>
performance_schema_accounts_size</code></a> при запуске сервера.
Чтобы отключить статистику учетной записи, установите эту переменную в 0.</p>

<p>Таблица <a href="#accounts-table"><code>accounts</code></a>
имеет следующие столбцы. Для описания того, как Performance Schema
поддерживает строки в этой таблице, включая эффект
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>, см.
<a href="#performance-schema-connection-tables">раздел 23.9.8</a>.
</p>

<ul><li><p><code>USER</code></p>
<p>Имя пользователя клиента для соединения. Это <code>NULL</code>
для внутреннего потока или для пользовательского сеанса, который был не в
состоянии подтвердить подлинность.</li>

<li><code>HOST</code></p>
<p>Узел, с которого соединялся клиент. Это <code>NULL</code>
для внутреннего потока или для пользовательского сеанса, который был не в
состоянии подтвердить подлинность.</li>

<li><code>CURRENT_CONNECTIONS</code></p>
<p>Текущее число соединений для учетной записи.</li>
<li><code>TOTAL_CONNECTIONS</code></p>
<p>Общее количество соединений для учетной записи.</p></li></ul>

<p>У <a href="#accounts-table"><code>accounts</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>, <code>HOST</code>).
</p></li></ul>

<h4><a name="hosts-table"></a>23.9.8.2. Таблица hosts</h4>
<p>Таблица <a href="#hosts-table"><code>hosts</code></a>
содержит строку для каждого узла, с которого клиенты соединились с сервером
MySQL. Для каждого имени хоста таблица считает текущее и общее количество
соединений. Табличный размер задан при запуске сервера. Чтобы установить
табличный размер явно, установите системную переменную
<a href="#sysvar_performance_schema_hosts_size"><code>
performance_schema_hosts_size</code></a> при запуске сервера.
Чтобы отключить статистику учетной записи, установите эту переменную в 0.</p>

<p>Таблица <a href="#hosts-table"><code>hosts</code></a>
имеет следующие столбцы. Для описания того, как Performance Schema
поддерживает строки в этой таблице, включая эффект
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>, см.
<a href="#performance-schema-connection-tables">раздел 23.9.8</a>.
</p>

<ul><li><p><code>HOST</code></p>
<p>Узел, от которого соединялся клиент. Это <code>NULL</code>
для внутреннего потока или для пользовательского сеанса, который был не в
состоянии подтвердить подлинность.</li>

<li><code>CURRENT_CONNECTIONS</code></p>
<p>Текущее число соединений для учетной записи.</li>
<li><code>TOTAL_CONNECTIONS</code></p>
<p>Общее количество соединений для учетной записи.</p></li></ul>

<p>У <a href="#hosts-table"><code>hosts</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>).</p></li></ul>

<h4><a name="users-table"></a>23.9.8.3. Таблица users</h4>
<p>Таблица <a href="#users-table"><code>users</code></a>
содержит строку для каждого пользователя, который соединился с сервером
MySQL. Для каждого имени пользователя таблица считает текущее и общее
количество соединений. Табличный размер задан при запуске сервера. Чтобы
установить табличный размер явно, установите переменную
<a href="#sysvar_performance_schema_users_size"><code>
performance_schema_users_size</code></a> при запуске сервера. Чтобы отключить
пользовательскую статистику, установите эту переменную в 0.</p>

<p>У таблицы <a href="#users-table"><code>users</code></a>
есть следующие столбцы. Для описания того, как Performance Schema
поддерживает строки в этой таблице, включая эффект
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>, см.
<a href="#performance-schema-connection-tables">раздел 23.9.8</a>.
</p>

<ul><li><p><code>HOST</code></p>
<p>Узел, от которого соединялся клиент. Это <code>NULL</code>
для внутреннего потока или для пользовательского сеанса, который был не в
состоянии подтвердить подлинность.</li>

<li><code>CURRENT_CONNECTIONS</code></p>
<p>Текущее число соединений для учетной записи.</li>
<li><code>TOTAL_CONNECTIONS</code></p>
<p>Общее количество соединений для учетной записи.</p></li></ul>

<p>У <a href="#users-table"><code>users</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>).</p></li></ul>

<h3><a name="performance-schema-connection-attribute-tables"></a>23.9.9.
Таблицы атрибутов соединения Performance Schema</h3>
<p>Приложения могут предоставить пары ключ/значение как атрибуты соединения
для передачи серверу во время соединения. Для C API определите набор
признака, используя функции
<a href="connect.htm#mysql-options"><code>mysql_options()</code></a> и
<a href="connect.htm#mysql-options4"><code>mysql_options4()</code></a>.
Другие MySQL Connector могут обеспечить свои собственные методы определения.
</p>

<p>Эти таблицы выставляют информацию атрибута:</p>
<ul><li><p><a href="#session-account-connect-attrs-table"><code>
session_account_connect_attrs</code></a>:
Признаки соединения для текущего сеанса и других сеансов, связанных
с учетной записью сеанса.</li>

<li><a href="#session-connect-attrs-table"><code>
session_connect_attrs</code></a>: Признаки соединения для всех сеансов.
</p></li></ul>

<p>Названия атрибутов, которые начинаются с подчеркивания
(<code>_</code>), сохранены для внутреннего пользования и не должен быть
созданы приложениями. Это соглашение разрешает новым признакам быть
введенными MySQL, не сталкиваясь с признаками приложения.</p>

<p>Набор признаков соединения, видимых в данном соединении, изменяется в
зависимости от Вашей платформы и MySQL Connector,
которым установили соединение.</p>

<p>Библиотека клиента <code>libmysqlclient</code> (обеспечена в
MySQL и MySQL Connector/C) устанавливает эти признаки:</p>
<ul><li><p><code>_client_name</code>:
Имя клиента (<code>libmysql</code> для библиотеки клиента).</li>

<li><code>_client_version</code>: Версия библиотеки клиента.</li>
<li><code>_os</code>: Операционная система (например,
<code>Linux</code>, <code>Win64</code>).</li>

<li><code>_pid</code>: ID процесса клиента.</li>
<li><code>_platform</code>: Машинная платформа (например,
<code>x86_64</code>).</li>
<li><code>_thread</code>: ID потока клиента (только под Windows).
</p></li></ul>

<p>Прочие MySQL Connector могут определить свои
собственные признаки соединения.</p>
<p>MySQL Connector/J определяет эти признаки:</p>

<ul><li><p><code>_client_license</code>: Тип лицензии соединителя.</li>
<li><code>_runtime_vendor</code>: Поставщик Java runtime environment (JRE).
</li>
<li><code>_runtime_version</code>: Версия Java runtime environment (JRE).
</p></li></ul>

<p>MySQL Connector/Net определяет эти признаки:</p>
<ul><li><p><code>_client_version</code>: Версия библиотеки клиента.</li>
<li><code>_os</code>: Операционная система (например,
<code>Linux</code>, <code>Win64</code>).</li>

<li><code>_pid</code>: ID процесса клиента.</li>
<li><code>_platform</code>: Машинная платформа (например,
<code>x86_64</code>).</li>

<li><code>_program_name</code>: Имя клиента.</li>
<li><code>_thread</code>: ID потока клиента (только под Windows).
</p></li></ul>

<p>PHP определяет признаки, которые зависят от того, как он был собран:</p>
<ul><li><p>Собран с применением <code>libmysqlclient</code>:
признаки <code>libmysqlclient</code>, описанные ранее.</li>
<li>Собран с применением <code>mysqlnd</code>: только признак
<code>_client_name</code> со значением <code>mysqlnd</code>.</p></li></ul>

<p>Много программ клиента MySQL устанавливают признак
<code>program_name</code> со значением, равным имени клиента. Например,
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin</strong></span>
</a> и <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a> устанавливают <code>program_name</code> в
<code>mysqladmin</code> и <code>mysqldump</code>, соответственно.</p>

<p>Некоторые программы клиента MySQL определяют дополнительные признаки:</p>
<ul><li><p><a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a> определяет <code>_client_role</code> как
<code>binary_log_listener</code>.</li>

<li>Ведомые соединения репликации определяют
<code>program_name</code> как <code>mysqld</code>, <code>_client_role</code>
как <code>binary_log_listener</code> и
<code>_client_replication_channel_name</code> как название канала.</li>

<li>Соединения механизма хранения
<a href="storage.htm#federated-storage-engine"><code>FEDERATED</code></a>
определяют <code>program_name</code> как <code>mysqld</code> и
<code>_client_role</code> как <code>federated_storage</code>.</p></li></ul>

<p>Есть пределы на количестве данных о признаке соединения,
переданных от клиента к серверу: фиксированный предел наложен клиентом до
времени соединения, фиксированный предел наложен сервером во время соединения
и конфигурируемый предел наложен Performance Schema во время соединения.</p>

<p>Для соединений, начатых, используя C API, библиотека
<code>libmysqlclient</code> налагает предел 64 КБ на совокупный размер данных
о признаке соединения по стороне клиента: вызовы
<a href="connect.htm#mysql-options"><code>mysql_options()</code></a>, которые
превышают этот предел, производят ошибку
<a href="error.htm#error_cr_invalid_parameter_no"><code>
CR_INVALID_PARAMETER_NO</code></a>. Другие MySQL Connector
могут наложить свои собственные клиентские пределы на то, сколько данных о
признаке соединения может быть передано серверу.</p>

<p>На стороне сервера данные о признаке соединения проверяются так:</p>
<ul><li><p>Сервер налагает предел 64 КБ на совокупный размер данных о
признаке соединения, который примет. Если клиент пытается послать больше
64 КБ данных о признаке, сервер отклоняет соединение. Иначе, сервер полагает,
что признак допустимый и отслеживает размер самого длинного буфера признака
в статусной переменной <a href="#statvar_Performance_schema_session_connect_attrs_longest_seen">
<code>Performance_schema_session_connect_attrs_longest_seen</code></a>.</li>

<li>Для принятых соединений Performance Schema проверяет совокупный размер
признака по значению переменной
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>.
Если размер признака превышает это значение, эти действия имеют место:</p>

<ul><li><p>Performance Schema усекает данные о признаке и увеличивает
переменную <a href="#statvar_Performance_schema_session_connect_attrs_lost">
<code>Performance_schema_session_connect_attrs_lost</code></a>, которая
указывает число соединений, для которых произошло усечение признака.</li>

<li>Performance Schema пишет сообщение в журнал ошибок, если
<a href="server.htm#sysvar_log_warnings"><code>log_warnings</code></a>
больше, чем ноль:
<pre>
Connection attributes of length <em><code>N</code></em> were truncated (<em><code>N</code></em> bytes lost)
for connection <em><code>N</code></em>, user
<em><code>user_name</code></em>@<em><code>host_name</code></em>
(as <em><code>user_name</code></em>), auth: {yes|no}
</pre>

<p>Информация в предупреждающем сообщении предназначена, чтобы помочь DBA
идентифицировать клиентов, для которых произошло усечение признака.</li>
<li>Признак <code>_truncated</code> добавлен к признакам сеанса со значением,
указывающим, сколько байтов было потеряно, если у буфера признака есть
достаточное пространство. Это позволяет Performance Schema выставить
информацию об усечении на соединение в таблицах атрибутов соединения.
Эта информация может быть исследована, не имея необходимости
проверять журнал ошибок.</p></li></ul></li></ul>

<h4><a name="session-account-connect-attrs-table"></a>23.9.9.1.
Таблица session_account_connect_attrs</h4>
<p>Приложения могут обеспечить признаки соединения ключа/значения,
которые передадут к серверу во время соединения, используя функции C API
the <a href="connect.htm#mysql-options"><code>mysql_options()</code></a> и
<a href="connect.htm#mysql-options4"><code>mysql_options4()</code></a>.</p>

<p><a href="#session-account-connect-attrs-table">
<code>session_account_connect_attrs</code></a>
содержит признаки соединения только для сеансов для Вашей собственной учетной
записи. Чтобы видеть признаки соединения для всех сеансов, загляните в
<a href="#session-connect-attrs-table"><code>session_connect_attrs
</code></a>.</p>

<p>У <a href="#session-account-connect-attrs-table"><code>
session_account_connect_attrs</code></a> есть эти столбцы:</p>
<ul><li><p><code>PROCESSLIST_ID</code></p>
<p>Идентификатор соединения для сеанса.</li>

<li><code>ATTR_NAME</code></p>
<p>Название атрибута.</li>
<li><code>ATTR_VALUE</code></p>
<p>Значение атрибута.</li>

<li><code>ORDINAL_POSITION</code></p>
<p>Порядок, в котором признак был добавлен к набору признаков соединения.
</p></li></ul>

<p>У <a href="#session-account-connect-attrs-table"><code>
session_account_connect_attrs</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>PROCESSLIST_ID</code>,
<code>ATTR_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#session-account-connect-attrs-table"><code>
session_account_connect_attrs</code></a>.</p>

<h4><a name="session-connect-attrs-table"></a>23.9.9.2.
Таблица session_connect_attrs</h4>
<p>Приложения могут обеспечить признаки соединения ключа/значения, которые
передадут серверу во время соединения, используя функции C API
the <a href="connect.htm#mysql-options"><code>mysql_options()</code></a> и
<a href="connect.htm#mysql-options4"><code>mysql_options4()</code></a>.</p>

<p><a href="#session-connect-attrs-table"><code>
session_connect_attrs</code></a> содержит признаки соединения для всех
сеансов. Чтобы видеть признаки соединения сеансов только для Вашей
собственной учетной записи, загляните в
<a href="#session-account-connect-attrs-table"><code>
session_account_connect_attrs</code></a>.</p>

<p>У <a href="#session-connect-attrs-table"><code>
session_connect_attrs</code></a> есть эти столбцы:</p>
<ul><li><p><code>PROCESSLIST_ID</code></p>
<p>Идентификатор соединения для сеанса.</li>

<li><code>ATTR_NAME</code></p>
<p>Название атрибута.</li>
<li><code>ATTR_VALUE</code></p>
<p>Значение атрибута.</li>

<li><code>ORDINAL_POSITION</code></p>
<p>Порядок, в котором признак был добавлен к набору признаков соединения.
</p></li></ul>

<p>У <a href="#session-connect-attrs-table"><code>
session_connect_attrs</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>PROCESSLIST_ID</code>,
<code>ATTR_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#session-connect-attrs-table">
<code>session_connect_attrs</code></a>.</p>

<h3><a name="performance-schema-user-variable-tables"></a>23.9.10.
Таблицы пользовательских переменных Performance Schema</h3>
<p>Performance Schema обеспечивает таблицу
<a href="#performance-schema-user-variable-tables">
<code>user_variables_by_thread</code></a>, которая выставляет определяемые
пользователем переменные. Это переменные, определенные в пределах
определенного сеанса, и включают символ <code>@</code>, предшествующий имени.
</p>

<p>У <a href="#performance-schema-user-variable-tables"><code>
user_variables_by_thread</code></a> есть эти столбцы:</p>
<ul><li><p><code>THREAD_ID</code></p>
<p>Идентификатор потока сеанса, в котором определена переменная.</li>

<li><code>VARIABLE_NAME</code></p>
<p>Имя переменной без символа <code>@</code>.</li>
<li><code>VARIABLE_VALUE</code></p>
<p>Значение переменной.</p></li></ul>

<p>У <a href="#performance-schema-user-variable-tables"><code>
user_variables_by_thread</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>VARIABLE_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#performance-schema-user-variable-tables">
<code>user_variables_by_thread</code></a>.</p>

<h3><a name="performance-schema-replication-tables"></a>23.9.11.
Таблицы репликации Performance Schema</h3>
<p>Performance Schema обеспечивает таблицы, которые выставляют информацию о
репликации. Это подобно информации, доступной от
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>,
но представление в табличной форме более доступно и обладает преимуществами
удобства и простоты использования:</p>

<ul><li><p>Вывод <a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS
</code></a> полезен для визуального осмотра, но не для использования с
программным управлением. В отличие от этого, используя таблицы Performance
Schema, информация о ведомом состоянии может искаться, используя общие
запросы <a href="sql.htm#select"><code>SELECT</code></a>, включая комплексные
условия <code>WHERE</code>, соединения и т.д.</li>

<li>Результаты запроса могут быть сохранены в таблицах для дальнейшего
анализа или назначены переменным и таким образом
использоваться в хранимых процедурах.</li>

<li>Таблицы репликации предоставляют лучшую диагностическую информацию. Для
мультипоточной ведомой работы <a href="sql.htm#show-slave-status"><code>SHOW
SLAVE STATUS</code></a> показывает все ошибки потоков, используя поля
<code>Last_SQL_Errno</code> и <code>Last_SQL_Error</code>,
таким образом, только последняя из этих ошибок видима, и информация может
быть потеряна. Таблицы репликации хранят ошибки на основе потока
без потери информации.</li>

<li>Последняя замеченная транзакция видима в таблицах. Эта информация
недоступна из <a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS
</code></a>.</li>

<li>Разработчики, знакомые с интерфейсом Performance Schema, могут расширить
таблицы, чтобы обеспечить дополнительную информацию,
добавляя строки к таблицам.</p></li></ul>

<h4><a name="idm139965288704688"></a>Описание таблиц репликации</h4>
<p>Performance Schema обеспечивает несколько связанных таблиц:</p>
<ul><li><p>Таблицы, которые содержат информацию о присоединении ведомого
сервера к главному серверу:</p>

<ul><li><p><a href="#replication-connection-configuration-table">
<code>replication_connection_configuration</code></a>: Параметры конфигурации
для того, чтобы соединиться с ведущим устройством.</li>

<li><a href="#replication-connection-status-table"><code>
replication_connection_status</code></a>:
Текущий статус соединения с ведущим устройством.</p></li></ul></li>

<li><p>Таблицы, которые содержат общую (не определенную для
потока) информацию о транзакци:</p>
<ul><li><p><a href="#replication-applier-configuration-table">
<code>replication_applier_configuration</code></a>:
Параметры конфигурации для транзакции на ведомом устройстве.</li>

<li><a href="#replication-applier-status-table"><code>
replication_applier_status</code></a>:
Текущий статус транзакции на ведомом устройстве.</p></li></ul></li>

<li><p>Таблицы, которые содержат информацию об определенных потоках,
ответственных за применение транзакций, полученных от ведущего устройства:
</p>

<ul><li><p><a href="#replication-applier-status-by-coordinator-table">
<code>replication_applier_status_by_coordinator</code></a>:
Состояние (SQL или координатор) потока.</li>

<li><a href="#replication-applier-status-by-worker-table"><code>
replication_applier_status_by_worker</code></a>:
Состояние рабочего потока (пустой, если ведомое устройство
не является мультипоточным).</p></li></ul></li>

<li><p>Таблицы, которые содержат информацию о членах группы:</p>
<ul><li><p><a href="#replication-group-members-table"><code>
replication_group_members</code></a>:
Предоставляет сетевую и информацию о статусе членов группы.</li>

<li><a href="#replication-group-member-stats-table"><code>
replication_group_member_stats</code></a>:
Предоставляет статистическую информацию о членах группы и транзакции,
в которой они участвуют.</p></li></ul></li></ul>

<p>Следующие разделы описывают каждую таблицу более подробно, включая
связь между столбцами, произведенными <a href="sql.htm#show-slave-status">
<code>SHOW SLAVE STATUS</code></a> и столбцы таблицы репликации, в которых
появляется та же самая информация.</p>

<p>Остаток этого введения в таблицы описывает, как Performance Schema
заполняет их, и которые области от <a href="sql.htm#show-slave-status"><code>
SHOW SLAVE STATUS</code></a> не представлены в таблицах.</p>

<h4><a name="idm139965288676688"></a>Жизненный цикл таблиц</h4>
<p>Performance Schema заполняет таблицы следующим образом:</p>
<ul><li><p>До выполнения <a href="sql.htm#change-master-to"><code>CHANGE
MASTER TO</code></a> таблицы пусты.</li>

<li>После <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code>
</a> параметры конфигурации могут быть замечены в таблицах. В это время нет
никаких активных ведомых потоков, таким образом, столбцы
<code>THREAD_ID</code> <code>NULL</code> и <code>SERVICE_STATE</code>
<code>OFF</code>.</li>

<li>После <a href="sql.htm#start-slave"><code>START SLAVE</code></a>,
<code>THREAD_ID</code> не <code>NULL</code>. У потоков, которые спят или
активны, есть <code>SERVICE_STATE</code> <code>ON</code>.
У потока, который соединяется с главным сервером, есть значение
<code>CONNECTING</code> в то время, как это устанавливает соединение, и
<code>ON</code> после этого, пока соединение длится.</li>

<li>После <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>
<code>THREAD_ID</code> <code>NULL</code> и у столбцов <code>SERVICE_STATE
</code> для потоков, которые больше не существуют, <code>OFF</code>.</li>

<li>Таблицы сохранены после <a href="sql.htm#stop-slave"><code>STOP
SLAVE</code></a> или потоков с ошибками.</li>
<li>Таблица <a href="#replication-applier-status-by-worker-table">
<code>replication_applier_status_by_worker</code></a>
непуста только, когда ведомое устройство работает в виде мультидерева
сообщений. Таким образом, если системная переменная
<a href="replica.htm#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> больше 0, эта таблица заполнена, когда
выполнен <a href="sql.htm#start-slave"><code>START SLAVE</code></a>, число
строк показывает количество рабочих процессов.</p></li></ul>

<h4><a name="idm139965288649488"></a>Информация SHOW SLAVE STATUS
не в таблицах репликации</h4>
<p>Информация в таблицах Performance Schema несколько отличается от
информации, доступной от <a href="sql.htm#show-slave-status"><code>SHOW SLAVE
STATUS</code></a> потому? что таблицы ориентируются на использование
глобальных операционных идентификаторов (GTID), а не имен файла и позиций, и
они представляют серверные значения UUID, а не значения ID сервера.
Из-за этих различий, несколько столбцов <a href="sql.htm#show-slave-status">
<code>SHOW SLAVE STATUS</code></a> не сохранены в Performance Schema или
представлены иным путем:</p>

<ul><li><p>Следующие области обращаются к именам файла и
позициям и не сохранены:
<pre>
Master_Log_File
Read_Master_Log_Pos
Relay_Log_File
Relay_Log_Pos
Relay_Master_Log_File
Exec_Master_Log_Pos
Until_Condition
Until_Log_File
Until_Log_Pos
</pre></li>

<li>Поле <code>Master_Info_File</code> не сохранено. Это обращается к
файлу <code>master.info</code>, который был заменен безопасными для
катастрофического отказа ведомыми таблицами.</li>

<li>Следующие области основаны на
<a href="server.htm#sysvar_server_id"><code>server_id</code></a>, а не
<a href="replica.htm#sysvar_server_uuid"><code>server_uuid</code>
</a> и не сохранены:
<pre>
Master_Server_Id
Replicate_Ignore_Server_Ids
</pre></li>

<li>Поле <code>Skip_Counter</code> основано на количестве
событий, а не GTID и не сохранено.</li>
<li>Эти ошибочные поля псевдонимы для
<code>Last_SQL_Errno</code> и <code>Last_SQL_Error</code>,
таким образом, они не сохранены:
<pre>
Last_Errno
Last_Error
</pre>

<p>В Performance Schema эта информация об ошибке доступна в столбцах
<code>LAST_ERROR_NUMBER</code> и <code>LAST_ERROR_MESSAGE</code> таблицы
<a href="#replication-applier-status-by-coordinator-table">
<code>replication_applier_status_by_coordinator</code></a>
(и <a href="#replication-applier-status-by-worker-table"><code>
replication_applier_status_by_worker</code></a>,
если ведомое устройство является мультипоточным). Те таблицы предоставляют
более определенную информацию об ошибке для потока, чем доступна от
<code>Last_Errno</code> и <code>Last_Error</code>.</li>

<li>Области, которые предоставляют информацию об опциях фильтрации командной
строки, не сохранены:
<pre>
Replicate_Do_DB
Replicate_Ignore_DB
Replicate_Do_Table
Replicate_Ignore_Table
Replicate_Wild_Do_Table
Replicate_Wild_Ignore_Table
</pre></li>

<li>Поля <code>Slave_IO_State</code> и
<code>Slave_SQL_Running_State</code> не сохранены. Если нужно, эти значения
могут быть получены из списка процессов при использовании столбца
<code>THREAD_ID</code> соответствующей таблицы и присоединения к этому
столбца <code>ID</code> таблицы <code>INFORMATION_SCHEMA</code>
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a>, чтобы
выбрать столбец <code>STATE</code> последней таблицы.</li>

<li>Поле <code>Executed_Gtid_Set</code> может показать большой набор с
большим количеством текста. Вместо этого таблицы Performance Schema
показывают GTID транзакций, которые в настоящее время применяются ведомым
устройством. Альтернативно, набор выполненного GTID может быть получен из
значения переменной <a href="replica.htm#sysvar_gtid_executed"><code>
gtid_executed</code></a>.</li>
<li><code>Seconds_Behind_Master</code> и
<code>Relay_Log_Space</code> не сохранены.</p></li></ul>

<h4><a name="idm139965288612496"></a>
Переменные состояния, перемещенные в таблицы</h4>
<p>Начиная с MySQL 5.7.5, следующие переменные состояния (ранее доступные
через использование <a href="sql.htm#show-status"><code>SHOW STATUS</code>
</a>) были перемещены в таблицы Perfomance Schema:</p>

<ul><li><p><a href="server.htm#statvar_Slave_retried_transactions"><code>
Slave_retried_transactions</code></a></li>
<li><a href="server.htm#statvar_Slave_last_heartbeat"><code>
Slave_last_heartbeat</code></a></li>

<li><a href="server.htm#statvar_Slave_received_heartbeats"><code>
Slave_received_heartbeats</code></a></li>
<li><a href="server.htm#statvar_Slave_heartbeat_period"><code>
Slave_heartbeat_period</code></a></li>
<li><a href="server.htm#statvar_Slave_running"><code>Slave_running</code></a>
</p></li></ul>

<p>Эти переменные состояния теперь релевантны только, когда применяется
единственный канал репликации, потому что они сообщают о состоянии
<span class="emphasis"><em>только</em></span> каналапо умолчанию. Когда
много каналов существует, используйте таблицы Performance Schema, описанные в
этом разделе, которые сообщают об этих переменных для
каждого существующего канала.</p>

<h4><a name="idm139965288596880"></a>Каналы репликации</h4>
<p>Первый столбец таблиц Performance Schema <code>CHANNEL_NAME</code>.
Это позволяет таблицам рассматриваться по каналам. Когда Вы используете
многократные каналы на ведомом устройстве, Вы можете фильтровать таблицы по
каналам, чтобы контролировать определенный канал. См. разделы
<a href="replica.htm#replication-channels">19.2.3</a> и
<a href="replica.htm#replication-multi-source-monitoring">19.1.4.3</a>.</p>

<h4><a name="replication-connection-configuration-table"></a>23.9.11.1.
Таблица replication_connection_configuration</h4>
<p>Эта таблица показывает параметры конфигурации, используемые ведомым
сервером для того, чтобы соединиться с главным сервером. Параметры,
сохраненные в таблице, могут быть изменены во время выполнения с помощью
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>,
как обозначено в описаниях столбца.</p>

<p>По сравнению с <a href="#replication-connection-status-table">
<code>replication_connection_status</code></a>,
<a href="#replication-connection-configuration-table"><code>
replication_connection_configuration</code></a>
изменяется менее часто. Это содержит значения, которые определяют, как
ведомое устройство соединяется с ведущим и которые остаются постоянными во
время соединения, тогда как
<a href="#replication-connection-status-table"><code>
replication_connection_status</code></a>
содержит значения, которые изменяются во время соединения.</p>

<p>У <a href="#replication-connection-configuration-table"><code>
replication_connection_configuration</code></a> есть эти столбцы:</p>
<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Канал, который эта строка отображает. Всегда есть канал по умолчанию, и
больше каналов может быть добавлено. См.
<a href="replica.htm#replication-channels">раздел 19.2.3</a>.</li>

<li><code>HOST</code></p>
<p>Основной узел, с которым соединено ведомое устройство.
(<code>CHANGE MASTER TO</code> опция <code>MASTER_HOST</code>).</li>

<li><code>PORT</code></p>
<p>Порт для связи с ведущим устройством. (<code>CHANGE
MASTER TO</code> опция <code>MASTER_PORT</code>).</li>

<li><code>USER</code></p>
<p>Имя пользователя учетной записи для связи с ведущим устройством.
(<code>CHANGE MASTER TO</code> опция <code>MASTER_USER</code>).</li>

<li><code>NETWORK_INTERFACE</code></p>
<p>Сетевой интерфейс для связи, если есть.
(<code>CHANGE MASTER TO</code> опция <code>MASTER_BIND</code>).</li>

<li><code>AUTO_POSITION</code></p>
<p>1, если авторасположение используется, иначе 0.
(<code>CHANGE MASTER TO</code> опция <code>MASTER_AUTO_POSITION</code>).</li>

<li><code>SSL_ALLOWED</code>, <code>SSL_CA_FILE</code>,
<code>SSL_CA_PATH</code>, <code>SSL_CERTIFICATE</code>,
<code>SSL_CIPHER</code>, <code>SSL_KEY</code>,
<code>SSL_VERIFY_SERVER_CERTIFICATE</code>,
<code>SSL_CRL_FILE</code>, <code>SSL_CRL_PATH</code></p>
<p>Эти столбцы показывают параметры SSL, используемые ведомым устройством,
чтобы соединиться с ведущим, если они есть.</p>

<p><code>SSL_ALLOWED</code> имеет эти значения:</p>
<ul><li><p><code>Yes</code> если соединение SSL с
ведущим устройством разрешено.</li>

<li><code>No</code>, если соединение SSL с ведущим устройством не разрешено.
</li>
<li>
<code>Ignored</code>, если соединение SSL разрешено, но у ведомого сервера
нет включенной поддержки SSL.</p></li></ul>

<p>Опции <code>CHANGE MASTER TO</code> для других столбцов SSL:
<code>MASTER_SSL_CA</code>, <code>MASTER_SSL_CAPATH</code>,
<code>MASTER_SSL_CERT</code>, <code>MASTER_SSL_CIPHER</code>,
<code>MASTER_SSL_CRL</code>, <code>MASTER_SSL_CRLPATH</code>,
<code>MASTER_SSL_KEY</code>, <code>MASTER_SSL_VERIFY_SERVER_CERT</code>.</li>

<li><code>CONNECTION_RETRY_INTERVAL</code></p>
<p>Число секунд между повторами соединения.
(<code>CHANGE MASTER TO</code> опция <code>MASTER_CONNECT_RETRY</code>).</li>

<li><code>CONNECTION_RETRY_COUNT</code></p>
<p>Число раз, которое ведомое устройство может попытаться повторно
соединиться с ведущим устройством в случае потерянного соединения.
(<code>CHANGE MASTER TO</code> опция <code>MASTER_RETRY_COUNT</code>).</li>
<li><code>HEARTBEAT_INTERVAL</code></p>
<p>Интервал биения репликации на ведомом устройстве в секундах.</p></li></ul>

<p>У <a href="#replication-connection-configuration-table"><code>
replication_connection_configuration</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>CHANNEL_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-connection-configuration-table">
<code>replication_connection_configuration</code></a>.</p>

<p>Следующая таблица показывает связь между столбцами
<a href="#replication-connection-configuration-table"><code>
replication_connection_configuration</code></a> и
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Столбец <code>replication_connection_configuration
</code></th><th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th></tr>
</thead>
<tbody><tr><td scope="row"><code>HOST</code></td><td><code>Master_Host</code>
</td></tr>
<tr><td scope="row"><code>PORT</code></td><td><code>Master_Port</code></td>
</tr>
<tr><td scope="row"><code>USER</code></td><td><code>Master_User</code></td>
</tr>
<tr><td scope="row"><code>NETWORK_INTERFACE</code></td><td><code>Master_Bind
</code></td></tr>
<tr><td scope="row"><code>AUTO_POSITION</code></td><td><code>Auto_Position
</code></td></tr>
<tr><td scope="row"><code>SSL_ALLOWED</code></td><td><code>Master_SSL_Allowed
</code></td></tr>
<tr><td scope="row"><code>SSL_CA_FILE</code></td><td><code>Master_SSL_CA_File
</code></td></tr>
<tr><td scope="row"><code>SSL_CA_PATH</code></td><td><code>Master_SSL_CA_Path
</code></td></tr>
<tr><td scope="row"><code>SSL_CERTIFICATE</code></td><td><code>
Master_SSL_Cert</code></td></tr>
<tr><td scope="row"><code>SSL_CIPHER</code></td><td><code>Master_SSL_Cipher
</code></td></tr>
<tr><td scope="row"><code>SSL_KEY</code></td><td><code>Master_SSL_Key</code>
</td></tr>
<tr><td scope="row"><code>SSL_VERIFY_SERVER_CERTIFICATE</code></td><td><code>
Master_SSL_Verify_Server_Cert</code></td></tr>
<tr><td scope="row"><code>SSL_CRL_FILE</code></td><td><code>Master_SSL_Crl
</code></td></tr>
<tr><td scope="row"><code>SSL_CRL_PATH</code></td><td><code>
Master_SSL_Crlpath</code></td></tr>
<tr><td scope="row"><code>CONNECTION_RETRY_INTERVAL</code></td><td><code>
Connect_Retry</code></td></tr>
<tr><td scope="row"><code>CONNECTION_RETRY_COUNT</code></td><td><code>
Master_Retry_Count</code></td></tr></tbody></table>

<h4><a name="replication-connection-status-table"></a>23.9.11.2.
Таблица replication_connection_status</h4>
<p>Эта таблица показывает текущий статус потока ввода/вывода, который
обрабатывает ведомое соединение сервера с главным сервером.</p>

<p>По сравнению с <a href="#replication-connection-configuration-table">
<code>replication_connection_configuration</code></a>,
<a href="#replication-connection-status-table"><code>
replication_connection_status</code></a> изменяется более часто. Это содержит
значения, которые изменяются во время соединения, тогда как
<a href="#replication-connection-configuration-table"><code>
replication_connection_configuration</code></a>
содержит значения, которые определяют, как ведомое устройство соединяется с
ведущим и которые остаются постоянными во время соединения.</p>

<p>У <a href="#replication-connection-status-table"><code>
replication_connection_status</code></a> есть эти столбцы:</p>
<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Канал, который эта строка отображает. Всегда есть канал по умолчанию, и
больше каналов может быть добавлено. См.
<a href="replica.htm#replication-channels">раздел 19.2.3</a>.</li>

<li><code>GROUP_NAME</code></p>
<p>Этот столбец сохранен для будущего использования.</li>
<li><code>SOURCE_UUID</code></p>
<p><a href="replica.htm#sysvar_server_uuid"><code>server_uuid</code></a>
от ведущего устройства.</li>

<li><code>THREAD_ID</code></p>
<p>ID потока I/O.</li>
<li><code>SERVICE_STATE</code></p>
<p><code>ON</code> (поток существует и является активным или спящим),
<code>OFF</code> (поток больше не существует) или <code>CONNECTING</code>
(поток существует и соединяется с ведущим устройством).</li>

<li><code>RECEIVED_TRANSACTION_SET</code></p>
<p>Набор глобальных операционных ID (GTID), соответствующий всем транзакциям,
полученным этим ведомым устройством. Пустой, если GTID не используются.</li>

<li><code>LAST_ERROR_NUMBER</code>, <code>LAST_ERROR_MESSAGE</code></p>
<p>Код ошибки и сообщение об ошибке, которая заставила поток ввода/вывода
останавливаться. Код ошибки 0 и пустая строка не означают отсутствие ошибок.
Если <code>LAST_ERROR_MESSAGE</code> не пусто,
ошибочные значения также появляются в журнале ошибок ведомого устройства.</p>

<p><a href="sql.htm#reset-master"><code>RESET MASTER</code></a> или
<a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a>
сбрасывает значения, показанные в этих столбцах.</li>

<li><code>LAST_ERROR_TIMESTAMP</code></p>
<p>timestamp в формате <code>YYMMDD HH:MM:SS</code>, который показывает,
когда последняя ошибка ввода/вывода имела место.</li>

<li><code>LAST_HEARTBEAT_TIMESTAMP</code></p>
<p>timestamp в формате <code>YYMMDD HH:MM:SS</code>, который показывает,
когда последний сигнал биения был получен ведомым устройством.</li>

<li><code>COUNT_RECEIVED_HEARTBEATS</code></p>
<p>Общее количество сигналов биения, которые ведомое устройство
получило с прошлого перезапуска или запроса
<code>CHANGE MASTER TO</code>.</p></li></ul>

<p>У <a href="#replication-connection-status-table"><code>
replication_connection_status</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>CHANNEL_NAME</code>).</li>
<li>Индекс на (<code>THREAD_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-connection-status-table"><code>
replication_connection_status</code></a>.</p>

<p>Следующая таблица показывает связь между столбцами
<a href="#replication-connection-status-table"><code>
replication_connection_status</code></a> и
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Столбец <code>replication_connection_status</code>
</th><th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th></tr></thead>
<tbody><tr><td scope="row"><code>SOURCE_UUID</code></td><td><code>Master_UUID
</code></td></tr>
<tr><td scope="row"><code>THREAD_ID</code></td><td>Нет</td></tr>
<tr><td scope="row"><code>SERVICE_STATE</code></td><td><code>Slave_IO_Running
</code></td></tr>
<tr><td scope="row"><code>RECEIVED_TRANSACTION_SET</code></td><td><code>
Retrieved_Gtid_Set</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_NUMBER</code></td><td><code>
Last_IO_Errno</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_MESSAGE</code></td><td><code>
Last_IO_Error</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_TIMESTAMP</code></td><td><code>
Last_IO_Error_Timestamp</code></td></tr></tbody></table>

<h4><a name="replication-applier-configuration-table"></a>23.9.11.3.
Таблица replication_applier_configuration</h4>
<p>Таблица показывает параметры конфигурации, примененные ведомым сервером.
Параметры, сохраненные в таблице, могут быть изменены во время выполнения с
помощью <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>,
как обозначено в описаниях столбца.</p>

<p>У <a href="#replication-applier-configuration-table"><code>
replication_applier_configuration</code></a> есть эти столбцы:</p>
<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Канал, который эта строка отображает. Всегда есть канал по умолчанию, и
больше каналов может быть добавлено. См.
<a href="replica.htm#replication-channels">раздел 19.2.3</a>.</li>

<li><code>DESIRED_DELAY</code></p>
<p>Число секунд, которые ведомое устройство должно
изолировать ведущее устройство. (<code>CHANGE MASTER TO</code> опция
<code>MASTER_DELAY</code>).</p></li></ul>

<p>У <a href="#replication-applier-configuration-table"><code>
replication_applier_configuration</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>CHANNEL_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-applier-configuration-table">
<code>replication_applier_configuration</code></a>.</p>

<p>Следующая таблица показывает связь между столбцами
<a href="#replication-applier-configuration-table"><code>
replication_applier_configuration</code></a> и
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Столбец <code>replication_applier_configuration
</code></th>
<th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th></tr></thead>
<tbody><tr><td scope="row"><code>DESIRED_DELAY</code></td>
<td><code>SQL_Delay</code></td></tr></tbody></table>

<h4><a name="replication-applier-status-table"></a>23.9.11.4.
Таблица replication_applier_status</h4>
<p>Эта таблица показывает текущее общее операционное состояние выполнения
на ведомом сервере.</p>

<p>Эта таблица предоставляет информацию об общих аспектах транзакции, которые
не являются определенными для любого вовлеченного потока. Определенная для
потока информация о статусе доступна в
<a href="#replication-applier-status-by-coordinator-table"><code>
replication_applier_status_by_coordinator</code></a> (и
<a href="#replication-applier-status-by-worker-table"><code>
replication_applier_status_by_worker</code></a>,
если ведомое устройство является мультипоточным).</p>

<p>У <a href="#replication-applier-status-table"><code>
replication_applier_status</code></a> есть эти столбцы:</p>
<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Канал, который эта строка отображает. Всегда есть канал по умолчанию, и
больше каналов может быть добавлено. См.
<a href="replica.htm#replication-channels">раздел 19.2.3</a>.</li>

<li><code>SERVICE_STATE</code></p>
<p>Сохранено для будущего использования.</li>
<li><code>REMAINING_DELAY</code></p>
<p>Если ведомое устройство ждет <code>DESIRED_DELAY</code>
секунд, так как ведущее устройство применяет случай, это поле содержит
оставшееся число секунд задержки. В других случаях это <code>NULL</code>.
<code>DESIRED_DELAY</code> сохранено в
<a href="#replication-applier-configuration-table">
<code>replication_applier_configuration</code></a>.</li>

<li><code>COUNT_TRANSACTIONS_RETRIES</code></p>
<p>Показывает число повторений, которые были сделаны, потому что ведомый
поток SQL был не в состоянии применить транзакцию.</p></li></ul>

<p>У <a href="#replication-applier-status-table">
<code>replication_applier_status</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>CHANNEL_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-applier-status-table"><code>
replication_applier_status</code></a>.</p>

<p>Следующая таблица показывает связь между
<a href="#replication-applier-status-table">
<code>replication_applier_status</code></a> и
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Столбец <code>replication_applier_status</code>
</th>
<th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th></tr></thead>
<tbody><tr><td scope="row"><code>SERVICE_STATE</code></td><td>Нет</td></tr>
<tr><td scope="row"><code>REMAINING_DELAY</code></td>
<td><code>SQL_Remaining_Delay</code></td></tr></tbody></table>

<h4><a name="replication-applier-status-by-coordinator-table"></a>23.9.11.5.
Таблица replication_applier_status_by_coordinator</h4>
<p>Для мультипоточного ведомого устройства ведомое устройство использует
много рабочих потоков и поток координатора, чтобы управлять ими. Эта таблица
показывает состояние потока координатора. Для однопоточного ведомого
устройства эта таблица пуста. Для мультипоточного ведомого устройства
<a href="#replication-applier-status-by-worker-table">
<code>replication_applier_status_by_worker</code></a>
показывает состояние рабочих потоков.</p>

<p>У <a href="#replication-applier-status-by-coordinator-table">
<code>replication_applier_status_by_coordinator</code></a>
есть эти столбцы:</p>

<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Канал, который эта строка отображает. Всегда есть канал по умолчанию, и
больше каналов может быть добавлено. См.
<a href="replica.htm#replication-channels">раздел 19.2.3</a>.</li>

<li><code>THREAD_ID</code></p>
<p>ID потока SQL/coordinator.</li>
<li><code>SERVICE_STATE</code></p>
<p><code>ON</code> (поток существует и является активным или спящим) или
<code>OFF</code> (поток больше не существует).</li>

<li><code>LAST_ERROR_NUMBER</code>, <code>LAST_ERROR_MESSAGE</code></p>
<p>Код ошибки и сообщение об ошибке, которая заставила поток SQL/coordinator
останавливаться. Код ошибки 0 и пустая строка не означают, что ошибки нет.
Если <code>LAST_ERROR_MESSAGE</code> не пусто, ошибочные значения также
появляются в журнале ошибок ведомого устройства.</p>

<p><a href="sql.htm#reset-master"><code>RESET MASTER</code></a> или
<a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a>
сбрасывает значения, показанные в этих столбцах.</p>

<p>Все коды ошибки и сообщения в <code>LAST_ERROR_NUMBER</code> и
<code>LAST_ERROR_MESSAGE</code> соответствуют ошибочным значениям,
перечисленным в <a href="error.htm#error-messages-server">разделе B.3</a>.
</li>

<li><code>LAST_ERROR_TIMESTAMP</code></p>
<p>timestamp в формате <code>YYMMDD HH:MM:SS</code>,
который показывает, когда последняя ошибка SQL/coordinator произошла.
</p></li></ul>

<p>У <a href="#replication-applier-status-by-coordinator-table">
<code>replication_applier_status_by_coordinator</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>CHANNEL_NAME</code>).</li>
<li>Индекс на (<code>THREAD_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-applier-status-by-coordinator-table">
<code>replication_applier_status_by_coordinator</code></a>.</p>

<p>Следующая таблица показывает связь между
<a href="#replication-applier-status-by-coordinator-table"><code>
replication_applier_status_by_coordinator</code></a> и
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Столбец <code>
replication_applier_status_by_coordinator</code></th>
<th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th></tr></thead>
<tbody><tr><td scope="row"><code>THREAD_ID</code></td><td>Нет</td></tr>
<tr><td scope="row"><code>SERVICE_STATE</code></td><td><code>
Slave_SQL_Running</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_NUMBER</code></td><td><code>
Last_SQL_Errno</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_MESSAGE</code></td><td><code>
Last_SQL_Error</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_TIMESTAMP</code></td><td><code>
Last_SQL_Error_Timestamp</code></td></tr></tbody></table>

<h4><a name="replication-applier-status-by-worker-table"></a>23.9.11.6.
Таблица replication_applier_status_by_worker</h4>
<p>Если ведомое устройство не является мультипоточным, эта таблица показывает
состояние потока. Иначе, ведомое устройство использует много рабочих потоков
и поток координатора, чтобы управлять ими, и эта таблица показывает состояние
рабочих потоков. Для мультипоточного ведомого устройства
<a href="#replication-applier-status-by-coordinator-table">
<code>replication_applier_status_by_coordinator</code></a>
показывает состояние потока координатора.</p>

<p>У <code>replication_applier_status_by_worker</code>
есть эти столбцы:</p>
<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Канал, который эта строка отображает. Всегда есть канал по умолчанию, и
больше каналов может быть добавлено. См.
<a href="replica.htm#replication-channels">раздел 19.2.3</a>.</li>

<li><code>WORKER_ID</code></p>
<p>Идентификатор рабочего (то же самое значение, как столбец
<code>id</code> в таблице <code>mysql.slave_worker_info</code>).
После <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>
<code>THREAD_ID</code> становится <code>NULL</code>, но
<code>WORKER_ID</code> сохранено.</li>

<li><code>THREAD_ID</code></p>
<p>ID рабочего потока.</li>
<li><code>SERVICE_STATE</code></p>
<p><code>ON</code> (поток существует и является активным или спящим) или
<code>OFF</code> (поток больше не существует).</li>

<li><code>LAST_SEEN_TRANSACTION</code></p>
<p>Транзакция, которую рабочий поток обработал последней.
Рабочий поток не обязательно применил эту транзакцию, потому что она могла
быть в процессе выполнения.</p>

<p>Если значение переменной <a href="replica.htm#sysvar_gtid_mode"><code>
gtid_mode</code></a> <code>OFF</code>, этот столбец <code>ANONYMOUS</code>,
указывая, что транзакции не имеют глобальных операционных идентификаторов
(GTID) и идентифицированы только файлом и позицией.</p>

<p>Если <a href="replica.htm#sysvar_gtid_mode"><code>gtid_mode</code></a>
<code>ON</code>, значение столбца определено следующим образом:</p>
<ul><li><p>Если никакая транзакция не выполнена, столбец пуст.</li>

<li>Когда транзакция выполнена, столбец установлен как
<a href="replica.htm#sysvar_gtid_next"><code>gtid_next</code></a>.
С этого момента столбец всегда показывает GTID.</li>

<li>GTID сохранен, пока следующая транзакция не выполнена. Если ошибка
происходит, значение столбца GTID транзакции, выполняемой рабочим потоком,
когда ошибка произошла.</li>

<li>Когда следующий случай журнала GTID поднят этим потоком, этот столбец
обновлен из <a href="replica.htm#sysvar_gtid_next"><code>gtid_next</code></a>
вскоре после того, как
<a href="replica.htm#sysvar_gtid_next"><code>gtid_next</code></a> установлен.
</p></li></ul></li>

<li><p><code>LAST_ERROR_NUMBER</code>, <code>LAST_ERROR_MESSAGE</code></p>
<p>Код ошибки и сообщение об ошибке, которая заставила поток
останавливаться. Код ошибки 0 и пустая строка не означают отсутствие ошибки.
Если <code>LAST_ERROR_MESSAGE</code> не пусто, ошибочные значения также
появляются в журнале ошибок ведомого устройства.</p>

<p><a href="sql.htm#reset-master"><code>RESET MASTER</code></a> или
<a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a>
сбрасывает значения, показанные в этих столбцах.</p>

<p>Все коды ошибки и сообщения, выведенные на экран в
<code>LAST_ERROR_NUMBER</code> и <code>LAST_ERROR_MESSAGE</code>
соответствуют ошибочным значениям, перечисленным в
<a href="error.htm#error-messages-server">разделе B.3</a>.</li>

<li><code>LAST_ERROR_TIMESTAMP</code></p>
<p>timestamp в формате <code>YYMMDD HH:MM:SS</code>, который показывает,
когда последняя ошибка рабочего потока произошла.</p></li></ul>

<p>У <a href="#replication-applier-status-by-worker-table">
<code>replication_applier_status_by_worker</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>CHANNEL_NAME</code>,
<code>WORKER_ID</code>).</li>
<li>Индекс на (<code>THREAD_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-applier-status-by-worker-table">
<code>replication_applier_status_by_worker</code></a>.</p>

<p>Следующая таблица показывает связь между
<code>replication_applier_status_by_worker</code> и
 <a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Столбец <code>replication_applier_status_by_worker
</code></th>
<th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th></tr></thead>
<tbody><tr><td scope="row"><code>WORKER_ID</code></td><td>Нет</td></tr>
<tr><td scope="row"><code>THREAD_ID</code></td><td>Нет</td></tr>
<tr><td scope="row"><code>SERVICE_STATE</code></td><td>Нет</td></tr>
<tr><td scope="row"><code>LAST_SEEN_TRANSACTION</code></td><td>Нет</td></tr>
<tr><td scope="row"><code>LAST_ERROR_NUMBER</code></td><td><code>
Last_SQL_Errno</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_MESSAGE</code></td><td><code>
Last_SQL_Error</code></td></tr>
<tr><td scope="row"><code>LAST_ERROR_TIMESTAMP</code></td><td><code>
Last_SQL_Error_Timestamp</code></td></tr></tbody></table>

<h4><a name="replication-group-members-table"></a>23.9.11.7.
Таблица replication_group_members</h4>
<p>Эта таблица показывает сеть и информацию о статусе для
членов группы репликации.</p>

<p>Таблица <code>replication_group_members</code> имеет следующие столбцы:
</p>
<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Название группового канала.</li>

<li><code>MEMBER_ID</code></p>
<p>Идентификатор для этого участника, то же самое как сервер UUID.</li>
<li><code>MEMBER_HOST</code></p>
<p>Сетевой адрес этого участника (имя хоста или IP-адрес).</li>

<li><code>MEMBER_PORT</code></p>
<p>Порт, на котором слушает сервер.</li>
<li><code>MEMBER_STATE</code></p>
<p>Текущее состояние этого участника, может быть любое из следующего:</p>

<ul><li><p><code>OFFLINE</code>: Групповой плагин установлен, но
не был запущен.</li>
<li><code>RECOVERING</code>: Сервер присоединился к группе, от которой
он получает данные.</li>
<li><code>ONLINE</code>: Участник находится в
полностью функционирующем статусе.</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-group-members-table">
<code>replication_group_members</code></a>.</p>

<h4><a name="replication-group-member-stats-table"></a>23.9.11.8.
Таблица replication_group_member_stats</h4>
<p>Эта таблица показывает статистическую информацию для членов группы.</p>
<p>У <code>replication_group_member_stats</code> есть следующие столбцы:</p>

<ul><li><p><code>CHANNEL_NAME</code></p>
<p>Название группового канала.</li>
<li><code>VIEW_ID</code></p>
<p>Идентификатор текущего представления для этой группы.</li>

<li><code>MEMBER_ID</code></p>
<p>Идентификатор для этого участника, то же самое как сервер UUID.</li>
<li><code>COUNT_TRANSACTIONS_IN_QUEUE</code></p>
<p>Число транзакций в ожидании.</li>

<li><code>COUNT_TRANSACTIONS_CHECKED</code></p>
<p>Число транзакций уже удостоверено этим участником.</li>
<li><code>COUNT_CONFLICTS_DETECTED</code></p>
<p>Число транзакций, которые не были удостоверены.</li>

<li><code>COUNT_TRANSACTIONS_VALIDATING</code></p>
<p>Число транзакций, с которыми может выполниться удостоверение,
но не был собран мусор.</li>

<li><code>TRANSACTIONS_COMMITTED_ALL_MEMBERS</code></p>
<p>Набор устойчивых групповых транзакций.</li>
<li><code>LAST_CONFLICT_FREE_TRANSACTION</code></p>
<p>Последняя транзакция, удостоверенная без конфликтов.</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#replication-group-member-stats-table">
<code>replication_group_member_stats</code></a>.</p>

<h3><a name="performance-schema-lock-tables"></a>23.9.12.
Таблицы блокировки Performance Schema</h3>
<p>Performance Schema выставляет информацию о блокировке через эти таблицы:
<ul><li><p><a href="#data-locks-table"><code>data_locks</code></a>:
Блокировки данных.</li>

<li><a href="#data-lock-waits-table"><code>data_lock_waits</code>
</a>: Отношения между владельцами блокировок и просителями,
заблокированными этими владельцами.</li>

<li><a href="#metadata-locks-table"><code>metadata_locks</code>
</a>: Блокировки метаданных.</li>
<li><a href="#table-handles-table"><code>table_handles</code></a>:
Табличные блокировки.</p></li></ul>
<p>Следующие разделы описывают эти таблицы более подробно.</p>

<h4><a name="data-locks-table"></a>23.9.12.1. Таблица data_locks</h4>
<p>Таблица <a href="#data-locks-table"><code>data_locks</code></a>
показывает блокировки данных, которые введены и требуются. Для информации о
том, какие запросы блокировки заблокированы введеными блокировками, см.
<a href="#data-lock-waits-table">раздел 23.9.12.2</a>.
Обе таблицы были добавлены в MySQL 8.0.1.</p>

<p>Данные в качестве примера:
<pre>
mysql&gt; SELECT * FROM data_locks\G
*************************** 1. row ***************************
   ENGINE: INNODB
 ENGINE_LOCK_ID: 4140:74
ENGINE_TRANSACTION_ID: 4140
THREAD_ID: 37
 EVENT_ID: 9
  OBJECT_SCHEMA: test
OBJECT_NAME: t1
 PARTITION_NAME: NULL
SUBPARTITION_NAME: NULL
 INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 140489308280888
LOCK_TYPE: TABLE
LOCK_MODE: IX
LOCK_STATUS: GRANTED
LOCK_DATA: NULL
*************************** 2. row ***************************
   ENGINE: INNODB
 ENGINE_LOCK_ID: 4140:66:5:1
ENGINE_TRANSACTION_ID: 4140
THREAD_ID: 37
 EVENT_ID: 9
  OBJECT_SCHEMA: test
OBJECT_NAME: t1
 PARTITION_NAME: NULL
SUBPARTITION_NAME: NULL
 INDEX_NAME: GEN_CLUST_INDEX
OBJECT_INSTANCE_BEGIN: 140489320307736
LOCK_TYPE: RECORD
LOCK_MODE: X
LOCK_STATUS: GRANTED
LOCK_DATA: supremum pseudo-record
</pre>

<p>В отличие от большинства сбора данных Performance Schema,
нет никаких инструментов для того, чтобы управлять, собрана ли информация
о блокировках данных, или системных переменных для того, чтобы управлять
табличными размерами блокировки данных. Performance Schema собирает
информацию, которая уже доступна в сервере, таким образом нет никаких
издержек памяти или центрального процессора, чтобы произвести эту информацию
или потребности в параметрах, которые управляют ее сбором.</p>

<p>Используйте <a href="#data-locks-table"><code>data_locks</code>
</a>, чтобы помочь диагностировать исполнительные проблемы, которые
происходят во времена тяжелой параллельной загрузки. Для <code>InnoDB</code>
см. обсуждение этой темы в
<a href="innodb.htm#innodb-information-schema-transactions">разделе 16.14.2
</a>.</p>

<p>У <a href="#data-locks-table"><code>data_locks</code></a>
есть эти столбцы:</p>
<ul><li><p><code>ENGINE</code>:</p>
<p>Механизм хранения, который держит или просил блокировку.</li>

<li><code>ENGINE_LOCK_ID</code>:</p>
<p>ID блокировки. Кортежи зачений
(<code>ENGINE_LOCK_ID</code>, <code>ENGINE</code>) уникальны.</p>

<p>Форматы ID блокировки являются внутренними и подлежат изменению в любое
время. Приложения не должны положиться на ID
блокировки, имеющие особый формат.</li>

<li><code>ENGINE_TRANSACTION_ID</code>:</p>
<p>Внутренний ID механизма хранения транзакции, которая просила блокировку.
</p>

<p>Для <code>InnoDB</code>, чтобы получить детали о транзакции,
присоединитесь к этому столбцу с <code>TRX_ID</code> из
<code>INFORMATION_SCHEMA</code>
<a href="inform.htm#innodb-trx-table"><code>INNODB_TRX</code></a>.</li>

<li><code>THREAD_ID</code>:</p>
<p>ID потока, которому принадлежит блокировка. Чтобы получить детали о
потоке, присоединитесь к этому столбцу с <code>THREAD_ID</code> из
Performance Schema <a href="#threads-table"><code>threads</code>
</a>.</li>

<li><code>EVENT_ID</code>:</p>
<p>Исполнительный случай, который вызвал блокировку. Кортежи
(<code>THREAD_ID</code>, <code>EVENT_ID</code>) неявно идентифицируют
родительский случай в других таблицах Performance Schema:</p>

<ul><li><p>Родительский случай ожидания в таблице
<code>events_waits_<em><code>xxx</code></em></code>.</li>
<li>Родительский случай этапа в таблице
<code>events_stages_<em><code>xxx</code></em></code>.</li>

<li>Родительский случай запроса в таблице
<code>events_statements_<em><code>xxx</code></em></code>.</li>
<li>Родительский операционный случай в таблице
<code>events_transactions_<em><code>xxx</code></em></code>.</p></li></ul>

<p>Чтобы получить детали о родительском случае, соедините столбцы
<code>THREAD_ID</code> и <code>EVENT_ID</code> со столбцами подобного имени в
соответствующей родительской таблице событий.</li>

<li><code>OBJECT_SCHEMA</code>:</p>
<p>Схема, которая содержит заблокированную таблицу.</li>
<li><code>OBJECT_NAME</code>:</p>
<p>Название заблокированной таблицы.</li>

<li><code>PARTITION_NAME</code>:</p>
<p>Название заблокированного разделения, если есть, иначе <code>NULL</code>.
</li>
<li><code>SUBPARTITION_NAME</code>:</p>
<p>Название заблокированного подразделения, если
есть, иначе <code>NULL</code>.</li>

<li><code>INDEX_NAME</code>:</p>
<p>Название заблокированного индекса, если
есть, иначе <code>NULL</code>.</p>

<p>Практически <code>InnoDB</code> всегда создает индекс
(<code>GEN_CLUST_INDEX</code>), так что <code>INDEX_NAME</code>
не <code>NULL</code> для таблиц <code>InnoDB</code> всегда.</li>

<li><code>OBJECT_INSTANCE_BEGIN</code>:</p>
<p>Адрес в памяти о блокировке.</li>
<li><code>LOCK_TYPE</code>:</p>
<p>Тип блокировки.</p>

<p>Значение зависит от механизма хранения. Для <code>InnoDB</code>
разрешенные значения <code>RECORD</code> для блокировки на уровне строки и
<code>TABLE</code> для блокировки на уровне таблицы.</li>

<li><code>LOCK_MODE</code>:</p>
<p>Как блокировку требуют.</p>
<p>Значение зависит от механизма хранения. Для <code>InnoDB</code>
разрешенные значения <code>S[,GAP]</code>, <code>X[,GAP]</code>,
<code>IS[,GAP]</code>, <code>IX[,GAP]</code>,
<code>AUTO_INC</code> и <code>UNKNOWN</code>. Режимы блокировки кроме
<code>AUTO_INC</code> и <code>UNKNOWN</code>
указывают на блокировки промежутка, если существует. Для информации о
<code>S</code>, <code>X</code>, <code>IS</code>, <code>IX</code>
и блокировке промежутка, обратитесь к
<a href="innodb.htm#innodb-locking">разделу 16.5.1</a>.</li>

<li><code>LOCK_STATUS</code>:</p>
<p>Состояние запроса блокировки.</p>
<p>Значение зависит от механизма хранения. Для <code>InnoDB</code>
разрешенные значения <code>GRANTED</code> (блокировка проводится) и
<code>PENDING</code> (блокировку ждут).</li>

<li><code>LOCK_DATA</code>:</p>
<p>Данные связанные с блокировкой, если есть.</p>
<p>Значение зависит от механизма хранения. Для <code>InnoDB</code>
это значения первичного ключа заблокированной записи, если
<code>LOCK_TYPE</code> <code>RECORD</code>, иначе <code>NULL</code>.
Этот столбец содержит значения столбцов первичного ключа в заблокированной
строке, отформатированной как допустимая строка SQL (готовая, чтобы быть
скопированной в запрос SQL). Если нет никакого первичного ключа,
<code>LOCK_DATA</code> уникальный внутренний идентификационный номер строки.
<code>InnoDB</code>. Если блокировка промежутка взята для значений ключа или
диапазонов выше самого большого значения в индексировании,
<code>LOCK_DATA</code> сообщает "<code>supremum pseudo-record</code>".
Когда страница, содержащая заблокированную запись, не находится в буферном
бассейне (в случае, когда страницы были выгружены на диск в то время, как
блокировка проводилась), <code>InnoDB</code> не грузит страницу с
диска, чтобы избежать ненужных дисковых операций. Вместо этого
<code>LOCK_DATA</code> установлен в <code>NULL</code>.</p></li></ul>

<p>У <a href="#data-locks-table"><code>data_locks</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>ENGINE_LOCK_ID</code>,
<code>ENGINE</code>).</li>
<li>Индекс на (<code>ENGINE_TRANSACTION_ID</code>,
<code>ENGINE</code>).</li>

<li>Индекс на (<code>THREAD_ID</code>, <code>EVENT_ID</code>).</li>
<li>Индекс на (<code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>,
<code>PARTITION_NAME</code>, <code>SUBPARTITION_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#data-locks-table"><code>data_locks</code>
</a>.</p>

<h4><a name="data-lock-waits-table"></a>23.9.12.2. Таблица data_lock_waits
</h4>
<p>Таблица <a href="#data-lock-waits-table"><code>data_lock_waits
</code></a> осуществляет отношения, показывая, какие данные запирают запросы
в <a href="#data-locks-table"><code>data_locks</code></a>,
сдерживая блокировки данных. Сдержанные блокировки в
<a href="#data-locks-table"><code>data_locks</code></a>
отобразятся в <a href="#data-lock-waits-table"><code>
data_lock_waits</code></a> только, если они блокируют некоторый запрос
блокировки. Обе таблицы были добавлены в MySQL 8.0.1.</p>

<p>Эта информация позволяет Вам понять зависимости от блокировки данных
между сеансами. Таблица выставляет не только, которые блокировки держат
сеанс, или какую блокировку ждет транзакция, но и то, какая сессия или
транзакция в настоящее время проводят ту блокировку.</p>

<p>Блокировка данных в качестве примера:
<pre>
mysql&gt; SELECT * FROM data_lock_waits\G
*************************** 1. row ***************************
  ENGINE: INNODB
 REQUESTING_ENGINE_LOCK_ID: 4141:66:5:2
REQUESTING_ENGINE_TRANSACTION_ID: 4141
REQUESTING_THREAD_ID: 38
 REQUESTING_EVENT_ID: 11
REQUESTING_OBJECT_INSTANCE_BEGIN: 140489320441368
   BLOCKING_ENGINE_LOCK_ID: 4140:66:5:2
  BLOCKING_ENGINE_TRANSACTION_ID: 4140
  BLOCKING_THREAD_ID: 37
   BLOCKING_EVENT_ID: 9
  BLOCKING_OBJECT_INSTANCE_BEGIN: 140489320307736
</pre>

<p>В отличие от большинства сбора данных Performance Schema,
нет никаких инструментов для того, чтобы управлять, собрана ли информация
о блокировках данных, или системных переменных для того, чтобы управлять
табличными размерами блокировки данных. Performance Schema собирает
информацию, которая уже доступна в сервере, таким образом нет никаких
издержек памяти или центрального процессора, чтобы произвести эту информацию
или потребности в параметрах, которые управляют ее сбором.</p>

<p>Используйте <a href="#data-locks-table"><code>data_locks</code>
</a>, чтобы помочь диагностировать исполнительные проблемы, которые
происходят во времена тяжелой параллельной загрузки. Для <code>InnoDB</code>
см. обсуждение этой темы в
<a href="innodb.htm#innodb-information-schema-transactions">разделе 16.14.2
</a>.</p>

<p>Поскольку столбцы в <a href="#data-lock-waits-table"><code>
data_lock_waits</code></a> подобны столбцам в
<a href="#data-locks-table"><code>data_locks</code></a>,
описания столбцов здесь сокращены. Для более подробных описаний столбцов см.
<a href="#data-locks-table">раздел 23.9.12.1</a>.</p>

<p>У <a href="#data-lock-waits-table"><code>data_lock_waits</code>
</a> есть эти столбцы:</p>
<ul><li><p><code>ENGINE</code></p>
<p>Механизм хранения, который запросил блокировку.</li>

<li><code>REQUESTING_ENGINE_LOCK_ID</code></p>
<p>ID блокировки, которую требует механизм хранения. Чтобы получить детали о
блокировке, присоедините к этому столбцу <code>LOCK_ID</code> из
<a href="#data-locks-table"><code>data_locks</code></a>.</li>

<li><code>REQUESTING_ENGINE_TRANSACTION_ID</code></p>
<p>Внутренний ID механизма хранения транзакции, который запросил блокировку.
</li>

<li><code>REQUESTING_THREAD_ID</code></p>
<p>ID потока сеанса, который запросил блокировку.</li>
<li><code>REQUESTING_EVENT_ID</code></p>
<p>Случай Performance Schema, который вызвал запрос блокировки в сеансе,
который запросил блокировку.</li>

<li><code>REQUESTING_OBJECT_INSTANCE_BEGIN</code></p>
<p>Адрес в памяти о требуемой блокировке.</li>
<li><code>BLOCKING_ENGINE_LOCK_ID</code></p>
<p>ID блокировки. Чтобы получить детали о блокировке, присоединитесь к этому
столбцу с <code>LOCK_ID</code> из <a href="#data-locks-table">
<code>data_locks</code></a>.</li>

<li><code>BLOCKING_ENGINE_TRANSACTION_ID</code></p>
<p>Внутренний ID механизма хранения транзакции, которая держит блокировку.
</li>
<li><code>BLOCKING_THREAD_ID</code></p>
<p>ID потока сеанса, который держит блокировку.</li>

<li><code>BLOCKING_EVENT_ID</code></p>
<p>Случай Performance Schema, который вызвал блокировку в сеансе.</li>
<li><code>BLOCKING_OBJECT_INSTANCE_BEGIN</code></p>
<p>Адрес в памяти о блокировке.</p></li></ul>

<p>У <a href="#data-lock-waits-table">
<code>data_lock_waits</code></a> есть эти индексы:</p>
<ul><li><p>Индекс на (<code>REQUESTING_ENGINE_LOCK_ID</code>,
<code>ENGINE</code>).</li>
<li>Индекс на (<code>BLOCKING_ENGINE_LOCK_ID</code>,
<code>ENGINE</code>).</li>

<li>Индекс на (<code>REQUESTING_ENGINE_TRANSACTION_ID</code>,
<code>ENGINE</code>).</li>
<li>Индекс на (<code>BLOCKING_ENGINE_TRANSACTION_ID</code>,
<code>ENGINE</code>).</li>

<li>Индекс на (<code>REQUESTING_THREAD_ID</code>,
<code>REQUESTING_EVENT_ID</code>).</li>
<li>Индекс на (<code>BLOCKING_THREAD_ID</code>,
<code>BLOCKING_EVENT_ID</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#data-lock-waits-table"><code>data_lock_waits
</code></a>.</p>

<h4><a name="metadata-locks-table"></a>23.9.12.3. Таблица metadata_locks</h4>
<p>Performance Schema выставляет информацию о блокировке метаданных через
<a href="#metadata-locks-table"><code>metadata_locks</code></a>:

<ul><li><p>Блокировки, которые предоставили.</li>
<li>Блокировки, которые требовали, но еще не предоставили.</li>
<li>Запросы блокировки, которые были уничтожены датчиком тупика или
рассчитаны и ждут блокировки.</p></li></ul>

<p>Эта информация позволяет Вам понять зависимости от блокировки метаданных
между сеансами. Вы можете видеть не только, которые блокировки сеанс ждет, но
и какая сессия в настоящее время проводит эту блокировку.</p>

<p><a href="#metadata-locks-table"><code>metadata_locks</code></a>
только для чтения и не может быть обновлена. Это задано по умолчанию, чтобы
сконфигурировать табличный размер, установите системную переменную
<a href="#sysvar_performance_schema_max_metadata_locks"><code>
performance_schema_max_metadata_locks</code></a> при запуске сервера.</p>

<p>Инструментовка блокировки метаданных отключена по умолчанию. Чтобы
включить, запустите инструмент <code>wait/lock/metadata/sql/mdl</code> в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<p>Performance Schema поддерживает табличный контент
<a href="#metadata-locks-table"><code>metadata_locks</code></a>
следующим образом, используя столбец <code>LOCK_STATUS</code>, чтобы указать
на состояние каждой блокировки:</p>

<ul><li><p>Когда блокировку метаданных требуют и немедленно получают, строка
с состоянием <code>GRANTED</code> вставлена.</li>
<li>Когда блокировку метаданных требуют и немедленно не получают, строка с
состоянием <code>PENDING</code> вставлена.</li>

<li>Когда блокировку метаданных, которую ранее требуют, предоставляют,
состояние ее строки обновлено к <code>GRANTED</code>.</li>
<li>Когда блокировка метаданных выпущена, ее строка удалена.</li>

<li>Когда запрос блокировки на ожидании отменен датчиком тупика, чтобы
сломать тупик (<a href="error.htm#error_er_lock_deadlock"><code>
ER_LOCK_DEADLOCK</code></a>), состояние строки обновлено от
<code>PENDING</code> до <code>VICTIM</code>.</li>

<li>Когда запрос блокировки получает тайм-аут
(<a href="error.htm#error_er_lock_wait_timeout"><code>ER_LOCK_WAIT_TIMEOUT
</code></a>), состояние строки обновлено от <code>PENDING</code> до
<code>TIMEOUT</code>.</li>

<li>Когда предоставленная блокировка или запрос блокировки на ожидании
уничтожен, состояние строки обновлено от <code>GRANTED</code> или
<code>PENDING</code> до <code>KILLED</code>.</li>

<li>Статусы <code>VICTIM</code>, <code>TIMEOUT</code> и <code>KILLED</code>
кратки и показывают, что строка блокировки собирается быть удаленной.</li>
<li>Статусы <code>PRE_ACQUIRE_NOTIFY</code> и
<code>POST_RELEASE_NOTIFY</code> кратки и показывают, что подсистема
блокировки метаданных регистрирует заинтересованные механизмы хранения, вводя
приобретение блокировки или оставляя операции выпуска блокировки.
</p></li></ul>

<p>У <a href="#metadata-locks-table"><code>metadata_locks</code>
</a> есть эти столбцы:</p>
<ul><li><p><code>OBJECT_TYPE</code></p>
<p>Тип блокировки, использованный в подсистеме блокировки метаданных,
значение одно из <code>GLOBAL</code>, <code>SCHEMA</code>,
<code>TABLE</code>, <code>FUNCTION</code>, <code>PROCEDURE</code>,
<code>TRIGGER</code> (сейчас не используется), <code>EVENT</code>,
<code>COMMIT</code>, <code>USER LEVEL LOCK</code>, <code>TABLESPACE</code>
или <code>LOCKING SERVICE</code>.</p>

<p>Значение <code>USER LEVEL LOCK</code> указывает на блокировку,
приобретенную с <a href="funct.htm#function_get-lock"><code>GET_LOCK()</code>
</a>. Значение <code>LOCKING SERVICE</code> указывает, что блокировка
приобреталась с использованием службы блокировки, описанной в
<a href="extend.htm#locking-service">разделе 26.3.1</a>.</li>

<li><code>OBJECT_SCHEMA</code></p>
<p>Схема, которая содержит объект.</li>
<li><code>OBJECT_NAME</code></p>
<p>Название инструментованного объекта.</li>

<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Адрес в памяти об инструментованном объекте.</li>
<li><code>LOCK_TYPE</code></p>
<p>Тип блокировки от подсистемы метаданных блокировок. Значение одно из
<code>INTENTION_EXCLUSIVE</code>, <code>SHARED</code>,
<code>SHARED_HIGH_PRIO</code>, <code>SHARED_READ</code>,
<code>SHARED_WRITE</code>, <code>SHARED_UPGRADABLE</code>,
<code>SHARED_NO_WRITE</code>, <code>SHARED_NO_READ_WRITE</code> или
<code>EXCLUSIVE</code>.</li>

<li><code>LOCK_DURATION</code></p>
<p>Продолжительность блокировки от подсистемы метаданных блокировок.
Значение одно из <code>STATEMENT</code>, <code>TRANSACTION</code> или
<code>EXPLICIT</code>. <code>STATEMENT</code> и <code>TRANSACTION</code>
для блокировок, которые выпущены в запросе или операционном конце,
соответственно. <code>EXPLICIT</code> значение для блокировок, которые
переживают запрос или конец транзакции и выпущены явно, такие как глобальные
блокировки, приобретенные с <a href="sql.htm#flush"><code>FLUSH TABLES WITH
READ LOCK</code></a>.</li>

<li><code>LOCK_STATUS</code></p>
<p>Состояние блокировки от подсистемы метаданных блокировок.
Значение одно из <code>PENDING</code>, <code>GRANTED</code>,
<code>VICTIM</code>, <code>TIMEOUT</code>, <code>KILLED</code>,
<code>PRE_ACQUIRE_NOTIFY</code> или <code>POST_RELEASE_NOTIFY</code>.
Performance Schema назначает эти значения как описано ранее в этом разделе.
</li>

<li><code>SOURCE</code></p>
<p>Название исходного файла, содержащего инструментованный код, который
произвел случай и номер строки в файле, в котором происходит инструментовка.
Это позволяет Вам проверить источник, чтобы определить точно,
какой код вовлечен.</li>

<li><code>OWNER_THREAD_ID</code></p>
<p>Поток, просящий блокировку метаданных.</li>
<li><code>OWNER_EVENT_ID</code></p>
<p>Случай, просящий блокировку метаданных.</p></li></ul>

<p>У <a href="#metadata-locks-table"><code>metadata_locks</code>
</a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>OBJECT_TYPE</code>, <code>OBJECT_SCHEMA</code>,
<code>OBJECT_NAME</code>).</li>
<li>Индекс на (<code>OWNER_THREAD_ID</code>, <code>OWNER_EVENT_ID</code>).
</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#metadata-locks-table"><code>metadata_locks
</code></a>.</p>

<h4><a name="table-handles-table"></a>23.9.12.4. Таблица table_handles</h4>
<p>Performance Schema выставляет табличную информацию о блокировке через
<a href="#table-handles-table"><code>table_handles</code></a>,
чтобы показать табличную блокировку в настоящее время в действительности для
каждого открытого табличного дескриптора.
<a href="#table-handles-table"><code>table_handles</code></a>
сообщает, что зарегистрировано табличной инструментовкой блокировки. Это
показывает, какая таблица открыта сервером, как она
заблокирована и которым сеансом.</p>

<p><a href="#table-handles-table"><code>table_handles</code></a>
только для чтения и не может быть обновлена. Это задано по умолчанию, чтобы
сконфигурировать табличный размер, установите переменную
<a href="#sysvar_performance_schema_max_table_handles"><code>
performance_schema_max_table_handles</code></a> при запуске сервера.</p>

<p>У <a href="#table-handles-table"><code>table_handles</code></a>
есть эти столбцы:</p>
<ul><li><p><code>OBJECT_TYPE</code></p>
<p>Таблица открылась табличным дескриптором.</li>

<li><code>OBJECT_SCHEMA</code></p>
<p>Схема, которая содержит объект.</li>
<li><code>OBJECT_NAME</code></p>
<p>Название инструментованного объекта.</li>

<li><code>OBJECT_INSTANCE_BEGIN</code></p>
<p>Табличный дескриптор в памяти.</li>
<li><code>OWNER_THREAD_ID</code></p>
<p>Поток, имеющий табличный дескриптор.</li>

<li><code>OWNER_EVENT_ID</code></p>
<p>Случай, который заставил табличный дескриптор быть открытым.</li>
<li><code>INTERNAL_LOCK</code></p>
<p>Табличная блокировка на уровне SQL. Значение одно из
<code>READ</code>, <code>READ WITH SHARED LOCKS</code>,
<code>READ HIGH PRIORITY</code>, <code>READ NO INSERT</code>,
<code>WRITE ALLOW WRITE</code>, <code>WRITE CONCURRENT INSERT</code>,
<code>WRITE LOW PRIORITY</code> или <code>WRITE</code>.
Для информации об этих типах блокировки см. файл исходных текстов
<code>include/thr_lock.h</code>.</li>

<li><code>EXTERNAL_LOCK</code></p>
<p>Табличная блокировка на уровне механизма хранения. Значение одно из
<code>READ EXTERNAL</code> или <code>WRITE EXTERNAL</code>.</p></li></ul>

<p>У <a href="#table-handles-table"><code>table_handles</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>OBJECT_TYPE</code>, <code>OBJECT_SCHEMA</code>,
<code>OBJECT_NAME</code>).</li>
<li>Индекс на (<code>OWNER_THREAD_ID</code>, <code>OWNER_EVENT_ID</code>).
</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#table-handles-table"><code>table_handles
</code></a>.</p>

<h3><a name="performance-schema-system-variable-tables"></a>23.9.13.
Системные таблицы переменных Performance Schema</h3>
<p>Значение переменной <a href="server.htm#sysvar_show_compatibility_56">
<code>show_compatibility_56</code></a> затрагивает информацию, доступную из
таблиц <a href="#performance-schema-system-variable-tables"><code>
global_variables</code></a>,
<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a> и
<a href="#performance-schema-system-variable-tables"><code>
variables_by_thread</code></a>, описанных здесь
(<a href="#variables-info-table"><code>variables_info</code></a>
не затронута). Для деталей см. описание той переменной в
<a href="server.htm#server-system-variables">разделе 6.1.5</a>.</p>

<p>MySQL server поддерживает много системных переменных, которые указывают,
как он сконфигурирован (см. <a href="server.htm#server-system-variables">
раздел 6.1.5</a>). Системная информация о переменных доступна в этих
таблицах Performance Schema:</p>

<ul><li><p><a href="#performance-schema-system-variable-tables">
<code>global_variables</code></a>: Глобальные системные переменные.
Приложение, которое хочет только глобальные значения, должно
использовать эту таблицу.</li>

<li><a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a>: Системные переменные для текущего сеанса.
Приложение, которое хочет все системные значения переменной для собственного
сеанса, должно использовать эту таблицу. Это включает переменные сеанса для
своего сеанса, так же как значения глобальных переменных, у которых нет
никакой сеансовой копии.</li>

<li><a href="#performance-schema-system-variable-tables"><code>
variables_by_thread</code></a>: Системные переменные сеанса для каждого
активного сеанса. Приложение, которое хочет знать значения переменной сеанса
для определенных сеансов, должно использовать эту таблицу. Это включает
только переменные сеанса, идентифицированные ID потока.</li>

<li><a href="#variables-info-table"><code>variables_info</code></a>:
Показывает для каждой системной переменной источник, из которого это было
последний раз установлено, и диапазон значений. См.
<a href="#variables-info-table">раздел 23.9.13.1</a>.</p></li></ul>

<p>Таблицы переменной сеанса
(<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a>,
<a href="#performance-schema-system-variable-tables"><code>
variables_by_thread</code></a>) содержат информацию только для активных
сеансов, не законченных сеансов.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
допускается для системных таблиц переменных Performance Schema.</p>
<p>У <a href="#performance-schema-system-variable-tables"><code>
global_variables</code></a> и
<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a> есть эти столбцы:</p>

<ul><li><p><code>VARIABLE_NAME</code></p>
<p>Системное имя переменной.</li>
<li><code>VARIABLE_VALUE</code></p>
<p>Системное значение переменной. Для
<a href="#performance-schema-system-variable-tables"><code>
global_variables</code></a> этот столбец содержит глобальное значение. Для
<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a> этот столбец содержит значение переменной
для текущего сеанса.</p></li></ul>

<p>У <a href="#performance-schema-system-variable-tables"><code>
global_variables</code></a> и
<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a> есть индексы:</p>
<ul><li><p>Первичный ключ на (<code>VARIABLE_NAME</code>).</p></li></ul>

<p>У <a href="#performance-schema-system-variable-tables"><code>
variables_by_thread</code></a> есть эти столбцы:</p>
<ul><li><p><code>THREAD_ID</code></p>
<p>Идентификатор потока сеанса, в котором определена системная переменная.
</li>

<li><code>VARIABLE_NAME</code></p>
<p>Системное имя переменной.</li>
<li><code>VARIABLE_VALUE</code></p>
<p>Значение переменной сеанса для сеанса, названного в столбце
<code>THREAD_ID</code>.</p></li></ul>

<p>У <a href="#performance-schema-system-variable-tables"><code>
variables_by_thread</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>VARIABLE_NAME</code>).</p></li></ul>

<p><a href="#performance-schema-system-variable-tables"><code>
variables_by_thread</code></a> содержит системную информацию о переменных
только о потоках переднего плана. Если не все потоки будут инструментованы
Performance Schema, эта таблица пропустит некоторые строки. В этом случае
переменная состояния <a href="#statvar_Performance_schema_thread_instances_lost">
<code>Performance_schema_thread_instances_lost</code></a>
будет больше, чем ноль.</p>

<h4><a name="variables-info-table"></a>23.9.13.1. Таблица variables_info</h4>
<p><a href="#variables-info-table"><code>variables_info</code></a>
для каждой системной переменной показывает источник, из которого это было
последний раз установлено, и его диапазон значений.</p>

<p>У <a href="#variables-info-table"><code>variables_info</code>
</a> есть эти столбцы:</p>
<ul><li><p><code>VARIABLE_NAME</code></p>
<p>Имя переменной.</li>

<li><code>VARIABLE_SOURCE</code></p>
<p>Источник, из которого была последний раз установлена переменная:</p>
<ul><li><p><code>COMMAND_LINE</code></p>
<p>Переменная была установлена из командной строки.</li>

<li><code>COMPILED</code></p>
<p>У переменной есть значение по умолчанию. <code>COMPILED</code> это
значение, используемое для переменных, не заданных любым другим путем.</li>

<li><code>DYNAMIC</code></p>
<p>Переменная была установлена во время выполнения. Это включает задание
переменных в пределах файлов, определенных, используя опцию
<a href="server.htm#option_mysqld_init-file"><code>--init-file</code></a>.
</li>

<li><code>EXPLICIT</code></p>
<p>Переменная была установлена из файла опции, названного в опции
<a href="server.htm#option_mysqld_defaults-file"><code>--defaults-file
</code></a>.</li>

<li><code>EXTRA</code></p>
<p>Переменная была установлена из файла опции, названного в опции
<a href="server.htm#option_mysqld_defaults-extra-file"><code>
--defaults-extra-file</code></a>.</li>

<li><code>GLOBAL</code></p>
<p>Переменная была установлена из глобального файла опции. Это включает файлы
опции, не покрытые <code>EXPLICIT</code>, <code>EXTRA</code>,
<code>LOGIN</code>, <code>PERSISTED</code>,
<code>SERVER</code> или <code>USER</code>.</li>

<li><code>LOGIN</code></p>
<p>Переменная была установлена из определенного для пользователя файла входа
в систему (<code>~/.mylogin.cnf</code>).</li>

<li><code>PERSISTED</code></p>
<p>Переменная была установлена из определенного для сервера файла опций
<code>mysqld-auto.cnf</code>. Ни у какой строки нет этого значения, если
сервер был запущен с выключенной
<a href="server.htm#sysvar_persisted_globals_load"><code>
persisted_globals_load</code></a>.</li>

<li><code>SERVER</code></p>
<p>Переменная была установлена из определенного для сервера файла опций
<code><code>$MYSQL_HOME</code>/my.cnf</code>. Для деталей см.
<a href="programs.htm#option-files">раздел 5.2.6</a>.</li>

<li><code>USER</code></p>
<p>Переменная была установлена из определенного для пользователя файла опций
<code>~/.my.cnf</code>.</p></li></ul></li>

<li><p><code>VARIABLE_PATH</code></p>
<p>Если переменная была установлена из файла опции,
<code>VARIABLE_PATH</code> путь к этому файлу. Иначе значение пустая строка.
</li>

<li><code>MIN_VALUE</code>, <code>MAX_VALUE</code></p>
<p>Минимальные и максимальные разрешенные значения для переменной. Оба 0 для
переменных, у которых нет таких значений (то есть, переменные, которые
не являются числовыми).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#variables-info-table"><code>variables_info
</code></a>.</p>

<p>Если переменная с <code>VARIABLE_SOURCE</code>, кроме <code>DYNAMIC</code>
установлена во время выполнения, <code>VARIABLE_SOURCE</code> становится
<code>DYNAMIC</code>, а <code>VARIABLE_PATH</code> пустой строкой.</p>

<p>Системная переменная, у которой есть только значение сеанса (такая как
<a href="server.htm#sysvar_debug_sync"><code>debug_sync</code></a>)
не может быть установлена при запуске. Для системных переменных только для
сеанса <code>VARIABLE_SOURCE</code> может быть только
<code>COMPILED</code> или <code>DYNAMIC</code>.</p>

<p>Если у системной переменной есть неожиданное
<code>VARIABLE_SOURCE</code>,
рассмотрите свой метод запуска сервера. Например,
<a href="programs.htm#mysqld-safe"><span><strong>mysqld_safe</strong></span>
</a> читает файлы опции и передает определенные опции, которые он находит там
как часть командной строки, которую он использует, чтобы запустить
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.
Следовательно, некоторые системные переменные, которые Вы устанавливаете в
файлах опции, могли бы отобразиться в
<a href="#variables-info-table"><code>variables_info</code></a> как
<code>COMMAND_LINE</code> вместо <code>GLOBAL</code> или <code>SERVER</code>.
</p>

<p>Некоторые типовые запросы, которые используют
<a href="#variables-info-table"><code>variables_info</code></a>:
</p>

<ul><li><p>Показать переменные из командной строки:
<pre>
mysql&gt; SELECT VARIABLE_NAME FROM variables_info
                 WHERE VARIABLE_SOURCE = 'COMMAND_LINE'
                 ORDER BY VARIABLE_NAME;
+---------------+
| VARIABLE_NAME |
+---------------+
| basedir       |
| datadir       |
| log_error     |
| pid_file      |
| plugin_dir    |
| port          |
+---------------+
</pre></li>

<li>Показать переменные из постоянного хранения:
<pre>
mysql&gt; SELECT VARIABLE_NAME FROM variables_info
                 WHERE VARIABLE_SOURCE = 'PERSISTED'
                 ORDER BY VARIABLE_NAME;
+--------------------------+
| VARIABLE_NAME            |
+--------------------------+
| event_scheduler          |
| expire_logs_days         |
| max_connections          |
| validate_password_policy |
+--------------------------+
</pre></li>

<li>Соединение <a href="#variables-info-table"><code>variables_info
</code></a> с <a href="#performance-schema-system-variable-tables">
<code>global_variables</code></a>, чтобы вывести на экран текущие значения
сохраненных переменных, вместе с их диапазоном значений:
<pre>
mysql&gt; SELECT VI.VARIABLE_NAME, GV.VARIABLE_VALUE,
                 VI.MIN_VALUE,VI.MAX_VALUE FROM variables_info AS VI
                 INNER JOIN global_variables AS GV USING(VARIABLE_NAME)
                 WHERE VI.VARIABLE_SOURCE = 'PERSISTED'
                 ORDER BY VARIABLE_NAME;
+--------------------------+----------------+-----------+-----------+
| VARIABLE_NAME            | VARIABLE_VALUE | MIN_VALUE | MAX_VALUE |
+--------------------------+----------------+-----------+-----------+
| event_scheduler          | ON             | 0         | 0         |
| expire_logs_days         | 7              | 0         | 99        |
| max_connections          | 200            | 1         | 100000    |
| validate_password_policy | STRONG         | 0         | 0         |
+--------------------------+----------------+-----------+-----------+
</pre></li></ul>

<h3><a name="performance-schema-status-variable-tables"></a>23.9.14.
Таблицы состояния переменных Performance Schema</h3>
<p>Значение переменной <a href="server.htm#sysvar_show_compatibility_56">
<code>show_compatibility_56</code></a> затрагивает информацию, доступную из
таблиц, описанных здесь. Для деталей см. описание этой переменной в
<a href="server.htm#server-system-variables">разделе 6.1.5</a>.</p>

<p>Сервер MySQL поддерживает много переменных состояния, которые
предоставляют информацию о его работе (см.
<a href="server.htm#server-status-variables">раздел 6.1.7</a>). Информация о
переменной состояния доступна в этих таблицах Performance Schema:</p>

<ul><li><p><a href="#performance-schema-status-variable-tables">
<code>global_status</code></a>: Глобальные переменные состояния. Приложение,
которое хочет только глобальные значения, должно использовать эту таблицу.
</li>

<li><a href="#performance-schema-status-variable-tables"><code>
session_status</code></a>: Переменные состояния для текущего сеанса.
Приложение, которое хочет все значения переменной состояния для собственного
сеанса, должно использовать эту таблицу. Это включает переменные сеанса для
своего сеанса, так же как значения глобальных переменных, у которых нет
никакой сеансовой копии.</li>

<li><a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a>: Переменные состояния сеанса для каждого
активного сеанса. Приложение, которое хочет знать значения переменной сеанса
для определенных сеансов, должно использовать эту таблицу. Это включает
только переменные сеанса, идентифицированные ID потока.</p></li></ul>

<p>Есть также сводные таблицы, которые предоставляют информацию о переменных
состояния, связанные учетной записью, именем хоста и именем пользователя. См.
<a href="#performance-schema-status-variable-summary-tables">
раздел 23.9.15.11</a>.</p>

<p>Таблицы переменной сеанса
(<a href="#performance-schema-status-variable-tables"><code>
session_status</code></a>,
<a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a>) содержат информацию только для активных, а
не законченных сеансов.</p>

<p>Performance Schema собирает статистические данные для глобальных
переменных состояния только для потоков для которых значение
<code>INSTRUMENTED</code> <code>YES</code> в
<a href="#threads-table"><code>threads</code></a>.
Статистические данные для переменных состояния сеанса всегда собираются,
независимо от значения <code>INSTRUMENTED</code>.</p>

<p>Performance Schema не собирает статистические данные для
переменных состояния <code>Com_<em><code>xxx</code></em></code> в
таблицах переменных состояния. Чтобы получить глобальное и сессионное
количество выполнения запросов за сеанс, используйте
<a href="#statement-summary-tables"><code>
events_statements_summary_global_by_event_name</code></a>
и <a href="#statement-summary-tables"><code>
events_statements_summary_by_thread_by_event_name</code>
</a>, соответственно. Например:
<pre>
SELECT EVENT_NAME, COUNT_STAR
       FROM events_statements_summary_global_by_event_name
       WHERE EVENT_NAME LIKE 'statement/sql/%';
</pre>

<p>У <a href="#performance-schema-status-variable-tables"><code>
global_status</code></a> и
<a href="#performance-schema-status-variable-tables"><code>
session_status</code></a> есть эти столбцы:</p>

<ul><li><p><code>VARIABLE_NAME</code></p>
<p>Имя переменной состояния.</li>
<li><code>VARIABLE_VALUE</code></p>
<p>Значение переменной состояния. Для
<a href="#performance-schema-status-variable-tables"><code>
global_status</code></a> этот столбец содержит глобальное значение. Для
<a href="#performance-schema-status-variable-tables"><code>
session_status</code></a> этот столбец содержит значение для текущего сеанса.
</p></li></ul>

<p>У <a href="#performance-schema-status-variable-tables"><code>
global_status</code></a> и
<a href="#performance-schema-status-variable-tables"><code>
session_status</code></a> есть индексы:</p>
<ul><li><p>Первичный ключ на (<code>VARIABLE_NAME</code>).</p></li></ul>

<p><a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a> содержит состояние каждого активного потока. У
нее есть эти столбцы:</p>

<ul><li><p><code>THREAD_ID</code></p>
<p>Идентификатор потока сеанса, в котором определена переменная состояния.
</li>
<li><code>VARIABLE_NAME</code></p>
<p>Имя переменной состояния.</li>
<li><code>VARIABLE_VALUE</code></p>
<p>Значение переменной сеанса для сеанса,
названного в столбце <code>THREAD_ID</code>.</p></li></ul>

<p>У <a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>VARIABLE_NAME</code>).</p></li></ul>

<p><a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a> содержит информацию о переменной состояния только
о потоках переднего плана. Если переменная
<a href="#sysvar_performance_schema_max_thread_instances"><code>
performance_schema_max_thread_instances</code></a> не автомасштабируется
(установлена в -1), и максимальное разрешенное число инструментованных
объектов потока не больше, чем число фоновых потоков, таблица будет пуста.
</p>

<p>Performance Schema поддерживает <a href="sql.htm#truncate-table"><code>
TRUNCATE TABLE</code></a> для таблиц переменных состояния следующим образом:
</p>
<ul><li><p><a href="#performance-schema-status-variable-tables">
<code>global_status</code></a>: Сбрасывает потоки, учетные записи, узлы и
пользователей. Сбрасывает глобальные переменные состояния кроме тех, которые
никогда не сбрасывает сервер.</li>

<li><a href="#performance-schema-status-variable-tables"><code>
session_status</code></a>: Не поддерживается.</li>
<li><a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a>: Состояние совокупностей для всех потоков к
глобальному состоянию и состоянию учетной записи, затем сбрасывает состояние
потока. Если статистические данные учетной записи не собраны, состояние
сеанса добавлено к состояниям хоста и пользователя, если они собраны.</p>

<p>Учетная запись, узел и пользовательская статистика не собраны, если
переменные <a href="#sysvar_performance_schema_accounts_size">
<code>performance_schema_accounts_size</code></a>,
<a href="#sysvar_performance_schema_hosts_size"><code>
performance_schema_hosts_size</code></a> и
<a href="#sysvar_performance_schema_users_size"><code>
performance_schema_users_size</code></a>, соответственно, установлены в 0.
</p></li></ul>

<p><a href="sql.htm#flush"><code>FLUSH STATUS</code></a>
добавляет состояние сеанса из всех активных сеансов в глобальные переменные
состояния, сбрасывает состояние всех активных сеансов и сбрасывает значения
состояния учетной записи, узла и пользователя от разъединенных сеансов.</p>

<h3><a name="performance-schema-summary-tables"></a>23.9.15.
Сводные таблицы Performance Schema</h3>
<p>Сводные таблицы предоставляют соединенную информацию для законченных
событий в течение долгого времени. Таблицы в этой группе суммируют данные
событий по-разному.</p>

<p><span><strong>Резюме событий ожидания:</strong></span></p>
<ul><li><p><a href="#stage-summary-tables"><code>
events_waits_summary_by_account_by_event_name</code></a>:
События ожидания, полученные на имя событий и учетную запись.</li>

<li><a href="#stage-summary-tables"><code>
events_waits_summary_by_host_by_event_name</code></a>:
События ожидания, полученные на имя событий и имя хоста.</li>

<li><a href="#wait-summary-tables"><code>
events_waits_summary_by_instance</code></a>:
События ожидания, полученные на случай.</li>

<li><a href="#wait-summary-tables"><code>
events_waits_summary_by_thread_by_event_name</code></a>:
События ожидания, полученные на имя события и поток.</li>

<li><a href="#stage-summary-tables"><code>
events_waits_summary_by_user_by_event_name</code></a>:
События ожидания, полученные на имя события и имя пользователя.</li>

<li><a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a>:
События ожидания, полученные на имя события.</p></li></ul>

<p><span><strong>Резюме этапа:</strong></span></p>
<ul><li><p><a href="#stage-summary-tables"><code>
events_stages_summary_by_account_by_event_name</code></a>:
События этапа на имя события и учетную запись.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_by_host_by_event_name</code></a>:
События этапа на имя события и имя хоста.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_by_thread_by_event_name</code></a>:
События этапа на имя события и поток.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_by_user_by_event_name</code></a>:
События этапа на имя события и имя пользователя.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_global_by_event_name</code></a>:
События этапа на имя события.</p></li></ul>

<p><span><strong>Резюме запросов:</strong></span></p>
<ul><li><p><a href="#stage-summary-tables"><code>
events_statements_summary_by_account_by_event_name</code></a>:
События запросов на имя события и учетную запись.</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a>:
События запросов на значение схемы и обзора.</li>

<li><a href="#stage-summary-tables"><code>
events_statements_summary_by_host_by_event_name</code></a>:
События запросов на имя события и имя хоста.</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_by_program</code></a>:
События запросов на сохраненную программу (хранимые процедуры и
функции, триггеры и события).</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_by_thread_by_event_name</code></a>:
События запросов на имя события и поток.</li>

<li><a href="#stage-summary-tables"><code>
events_statements_summary_by_user_by_event_name</code></a>:
События запросов на имя события и имя пользователя.</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_global_by_event_name</code></a>:
События запросов на имя события.</li>

<li><a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>:
Готовые случаи запроса и статистика.</p></li></ul>

<p><span><strong>Операционные резюме:</strong></span></p>
<ul><li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_account_by_event_name</code></a>:
Операционные события на учетную запись и имя события.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_host_by_event_name</code></a>:
Операционные события на имя хоста и имя события.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_thread_by_event_name</code></a>:
Операционные события на поток и имя события.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_user_by_event_name</code></a>:
Операционные события на имя пользователя и имя события.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_global_by_event_name</code></a>:
Операционные события на имя события.</p></li></ul>

<p><span><strong>Резюме ожидания объекта:</strong></span></p>
<ul><li><p><a href="#objects-summary-global-by-type-table">
<code>objects_summary_global_by_type</code></a>: Резюме объекта.</li></ul>

<p><span><strong>Резюме ввода/вывода файла:</strong></span></p>
<ul><li><p><a href="#file-summary-tables"><code>
file_summary_by_event_name</code></a>: События файла на имя события.</li>
<li><a href="#file-summary-tables"><code>file_summary_by_instance
</code></a>: События файла на случай файла.</p></li></ul>

<p><span><strong>Табличный ввод / вывод и ожидание блокировки:</strong></span>
</p>
<ul><li><p><a href="#table-io-waits-summary-by-index-usage-table">
<code>table_io_waits_summary_by_index_usage</code></a>:
Табличный ввод/вывод на индекс.</li>

<li><a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a>:
Табличный ввод/вывод на таблицу.</li>

<li><a href="#table-lock-waits-summary-by-table-table"><code>
table_lock_waits_summary_by_table</code></a>:
Табличная блокировка на таблицу.</p></li></ul>

<p><span><strong>Резюме сокета:</strong></span></p>
<ul><li><p><a href="#socket-summary-tables"><code>
socket_summary_by_instance</code></a>:
Ожидание и ввод/вывод сокета на случай.</li>

<li><a href="#socket-summary-tables"><code>
socket_summary_by_event_name</code></a>:
Ожидание и ввод/вывод сокета на имя события.</p></li></ul>

<p><span><strong>Резюме памяти:</strong></span></p>
<ul><li><p><a href="#memory-summary-tables"><code>
memory_summary_by_account_by_event_name</code></a>:
Операции памяти на имя события и учетную запись.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_by_host_by_event_name</code></a>:
Операции памяти на имя события и узел.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_by_thread_by_event_name</code></a>:
Операции памяти на имя события и поток.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_by_user_by_event_name</code></a>:
Операции памяти на имя события и пользователя.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a>:
Операции памяти на глобально за имя события.</p></li></ul>

<p><span><strong>Резюме ошибок:</strong></span></p>
<ul><li><p><a href="#error-summary-tables"><code>
events_errors_summary_by_account_by_error</code></a>:
Ошибки на код ошибки и учетную запись.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_by_host_by_error</code></a>:
Ошибки на код ошибки и узел.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_by_thread_by_error</code></a>:
Ошибки на код ошибки и поток.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_by_user_by_error</code></a>:
Ошибки на код ошибки и пользователя.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_global_by_error</code></a>:
Ошибки на код ошибки.</p></li></ul>

<p><span><strong>Резюме переменных состояния:</strong></span></p>
<ul><li><p><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_account</code></a>:
Переменные состояния, связанные с учетной записью.</li>

<li><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_host</code></a>:
Переменные состояния, связанные с именем хоста.</li>

<li><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_user</code></a>:
Переменные состояния, связанные с именем пользователя.</p></li></ul>

<p>У каждой сводной таблицы есть группирующиеся столбцы, которые определяют,
как сгруппировать данные, которые будут соединены, и сводные столбцы, которые
содержат соединенные значения. Таблицы, которые суммируют события похожими
способами, имеют подобные наборы сводных столбцов и отличаются только по
группирующимся столбцам, используемым, чтобы определить,
как соединены события.</p>

<p>Сводные таблицы могут быть усечены с
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>.
Вообще, эффект состоит в том, чтобы сбросить сводные столбцы к 0 или
<code>NULL</code>, а не удалить строки. Это позволяет очистить
собранные значения. Это могло бы быть полезно, например, после того, как Вы
произвели изменение конфигурации во время выполнения. Исключения к этому
поведению усечения отмечены в отдельных разделах сводной таблицы.</p>

<h4><a name="wait-summary-tables"></a>23.9.15.1.
Сводные таблицы событий ожидания</h4>
<p>Performance Schema поддерживает таблицы для того, чтобы собрать
актуальные и недавние события.
<a href="#performance-schema-wait-tables">раздел 23.9.4</a>
описывает события, на которых базируются резюме.</p>

<p>Пример информации о резюме событий:
<pre>
mysql&gt; SELECT * FROM events_waits_summary_global_by_event_name\G
...
*************************** 6. row ***************************
EVENT_NAME: wait/synch/mutex/sql/BINARY_LOG::LOCK_index
COUNT_STAR: 8
SUM_TIMER_WAIT: 2119302
MIN_TIMER_WAIT: 196092
AVG_TIMER_WAIT: 264912
MAX_TIMER_WAIT: 569421
...
*************************** 9. row ***************************
EVENT_NAME: wait/synch/mutex/sql/hash_filo::lock
COUNT_STAR: 69
SUM_TIMER_WAIT: 16848828
MIN_TIMER_WAIT: 0
AVG_TIMER_WAIT: 244185
MAX_TIMER_WAIT: 735345
...
</pre>

<p>У сводной таблицы событий есть один или более группирующихся столбцов,
чтобы указать как табличные события объединяются. Имена событий обращаются к
названиям инструментов событий в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<ul><li><p><a href="#stage-summary-tables"><code>
events_waits_summary_by_account_by_event_name</code></a> имеет столбцы
<code>EVENT_NAME</code>, <code>USER</code> и <code>HOST</code>.
Каждая строка суммирует события для сделанного отчета (комбинация
пользователя и узла) и имя событий.</li>

<li><a href="#stage-summary-tables"><code>
events_waits_summary_by_host_by_event_name</code></a> имеет столбцы
<code>EVENT_NAME</code> и <code>HOST</code>.
Каждая строка суммирует события для данного узла и имени событий.</li>

<li><a href="#wait-summary-tables"><code>
events_waits_summary_by_instance</code></a>
имеет столбцы <code>EVENT_NAME</code> и <code>OBJECT_INSTANCE_BEGIN</code>.
Каждая строка суммирует события для данного имени событий и объекта. Если
инструмент используется, чтобы создать многократные случаи, у каждого случая
есть уникальное значение <code>OBJECT_INSTANCE_BEGIN</code>
и он получен в итоге отдельно в этой таблице.</li>

<li><a href="#wait-summary-tables"><code>
events_waits_summary_by_thread_by_event_name</code></a>
имеет столбцы <code>THREAD_ID</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного потока и имени событий.</li>

<li><a href="#stage-summary-tables"><code>
events_waits_summary_by_user_by_event_name</code></a>
имеет столбцы <code>EVENT_NAME</code> и <code>USER</code>. Каждая строка
суммирует события для данного пользователя и имени событий.</li>

<li><a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a> имеет столбец
<code>EVENT_NAME</code>. Каждая строка суммирует события для данного имени
событий. Инструмент мог бы использоваться, чтобы создать многократные случаи
инструментованного объекта. Например, если есть инструмент для mutex, который
создается для каждого соединения, есть так много случаев, сколько есть
соединений. Сводная строка для инструмента подводит итог по
всем этим случаям.</p></li></ul>

<p>У сводной таблицы событий есть эти сводные столбцы,
содержащие соединенные значения:</p>
<ul><li><p><code>COUNT_STAR</code></p>
<p>Число полученных в итоге событий. Это значение включает все события.</li>

<li><code>SUM_TIMER_WAIT</code></p>
<p>Общее количество времени ожидания полученных в итоге рассчитанных событий.
Это значение вычислено только для рассчитанных событий, потому что у
нерассчитанных событий время ожидания <code>NULL</code>. The
То же самое истина для других значений
<code><em><code>xxx</code></em>_TIMER_WAIT</code>.</li>

<li><code>MIN_TIMER_WAIT</code></p>
<p>Минимум времени ожидания полученных в итоге рассчитанных событий.</li>
<li><code>AVG_TIMER_WAIT</code></p>
<p>Среднее время ожидания полученных в итоге рассчитанных событий.</li>

<li><code>MAX_TIMER_WAIT</code></p>
<p>Максимум времени ожидания полученных в итоге рассчитанных событий.
</p></li></ul>

<p>Сводные таблицы событий имеют индексы:</p>
<ul><li><p><a href="#stage-summary-tables"><code>
events_waits_summary_by_account_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>HOST</code>, <code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#stage-summary-tables"><code>
events_waits_summary_by_host_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#wait-summary-tables"><code>
events_waits_summary_by_instance</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#wait-summary-tables"><code>
events_waits_summary_by_thread_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#stage-summary-tables"><code>
events_waits_summary_by_user_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>EVENT_NAME</code>).
</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на сводных таблицах. Это имеет эффекты:</p>
<ul><li><p>Для сводных таблиц, не соединенных с учетной записью, узлом или
пользователем, усечение сбрасывает сводные столбцы к нолю вместо того,
чтобы удалить строки.</li>

<li>Для сводных таблиц, соединенных с учетной записью, узлом или
пользователем, усечение удаляет строки для учетных записей, узлов или
пользователей без соединений и сбрасывает сводные столбцы к нолю
для остающихся строк.</p></li></ul>

<p>Кроме того, каждая сводная таблица, которая соединена с учетной записью,
узлом, пользователем или потоком является неявно усеченной усечением таблицы
соединения, от которой зависит или усечением
<a href="#wait-summary-tables"><code>
events_waits_summary_global_by_event_name</code></a>.</p>

<h4><a name="stage-summary-tables"></a>23.9.15.2. Сводные таблицы этапа</h4>
<p>Performance Schema поддерживает таблицы для того, чтобы собрать текущие и
недавние события этапа. <a href="#performance-schema-stage-tables">
Раздел 23.9.5</a> описывает события, на которых базируются резюме этапа.</p>

<p>Информация о резюме этапа событий в качестве примера:
<pre>
mysql&gt; SELECT * FROM events_stages_summary_global_by_event_name\G
...
*************************** 5. row ***************************
EVENT_NAME: stage/sql/checking permissions
COUNT_STAR: 57
SUM_TIMER_WAIT: 26501888880
MIN_TIMER_WAIT: 7317456
AVG_TIMER_WAIT: 464945295
MAX_TIMER_WAIT: 12858936792
...
*************************** 9. row ***************************
EVENT_NAME: stage/sql/closing tables
COUNT_STAR: 37
SUM_TIMER_WAIT: 662606568
MIN_TIMER_WAIT: 1593864
AVG_TIMER_WAIT: 17907891
MAX_TIMER_WAIT: 437977248
...
</pre>

<p>У каждой сводной таблицы этапа есть один или более группирующихся
столбцов, чтобы указать как табличные события объединяются.
Имена событий обращаются к названиям инструментов событий в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<ul><li><p><a href="#stage-summary-tables"><code>
events_stages_summary_by_account_by_event_name</code></a> имеет столбцы
<code>EVENT_NAME</code>, <code>USER</code> и <code>HOST</code>.
Каждая строка суммирует события для сделанного отчета (комбинация
пользователя и узла) и имени события.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_by_host_by_event_name</code></a>
имеет столбцы <code>EVENT_NAME</code> и <code>HOST</code>.
Каждая строка суммирует события для данного узла и имени событий.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_by_thread_by_event_name</code></a>
имеет столбцы <code>THREAD_ID</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного потока и имени событий.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_by_user_by_event_name</code></a>
имеет столбцы <code>EVENT_NAME</code> и <code>USER</code>. Каждая строка
суммирует события для данного пользователя и имени событий.</li>

<li><a href="#stage-summary-tables"><code>
events_stages_summary_global_by_event_name</code></a>
имеет столбец <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного имени события.</p></li></ul>

<p>У каждой сводной таблицы этапа есть эти сводные столбцы,
содержащие соединенные значения: <code>COUNT_STAR</code>,
<code>SUM_TIMER_WAIT</code>, <code>MIN_TIMER_WAIT</code>,
<code>AVG_TIMER_WAIT</code> и <code>MAX_TIMER_WAIT</code>.
Эти столбцы походят на столбцы с теми же именами в сводных таблицах событий
ожидания (см. <a href="#wait-summary-tables">раздел 23.9.15.1</a>),
за исключением того, что события совокупности сводных таблиц этапа из
<a href="#events-stages-current-table"><code>events_stages_current
</code></a> вместо
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>.</p>

<p>Сводные таблицы этапа имеют индексы:</p>
<ul><li><p><a href="#stage-summary-tables"><code>
events_stages_summary_by_account_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>HOST</code>, <code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#stage-summary-tables"><code>
events_stages_summary_by_host_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>, <code>EVENT_NAME</code>).
</p></li></ul></li>

<li><p><a href="#stage-summary-tables"><code>
events_stages_summary_by_thread_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#stage-summary-tables"><code>
events_stages_summary_by_user_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#stage-summary-tables"><code>
events_stages_summary_global_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>EVENT_NAME</code>).
</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на сводных таблицах этапа. Это имеет эффекты:</p>
<ul><li><p>Для сводных таблиц, не соединенных с учетной записью, узлом или
пользователем, усечение сбрасывает сводные столбцы к нолю вместо того,
чтобы удалить строки.</li>

<li>Для сводных таблиц, соединенных с учетной записью, узлом или
пользователем, усечение удаляет строки для учетных записей, узлов или
пользователей без соединений и сбрасывает сводные столбцы к нолю
для остающихся строк.</p></li></ul>

<p>Кроме того, каждая сводная таблица этапа, которая соединена с учетной
записью, узлом, пользователем или потоком, является неявно усеченной
усечением таблицы, от которой это зависит, или усечением
<a href="#stage-summary-tables"><code>
events_stages_summary_global_by_event_name</code></a>.</p>

<h4><a name="statement-summary-tables"></a>23.9.15.3.
Сводные таблицы запросов</h4>
<p>Performance Schema поддерживает таблицы для того, чтобы собрать текущие
и недавние события запросов.
<a href="#performance-schema-statement-tables">Раздел 23.9.6</a>
описывает события, на которых базируются резюме запросов.</p>

<p>Информация о резюме запросов событий в качестве примера:
<pre>
mysql&gt; SELECT * FROM events_statements_summary_global_by_event_name\G
*************************** 1. row ***************************
 EVENT_NAME: statement/sql/select
 COUNT_STAR: 25
 SUM_TIMER_WAIT: 1535983999000
 MIN_TIMER_WAIT: 209823000
 AVG_TIMER_WAIT: 61439359000
 MAX_TIMER_WAIT: 1363397650000
  SUM_LOCK_TIME: 20186000000
 SUM_ERRORS: 0
   SUM_WARNINGS: 0
SUM_ROWS_AFFECTED: 0
  SUM_ROWS_SENT: 388
SUM_ROWS_EXAMINED: 370
SUM_CREATED_TMP_DISK_TABLES: 0
 SUM_CREATED_TMP_TABLES: 0
 SUM_SELECT_FULL_JOIN: 0
 SUM_SELECT_FULL_RANGE_JOIN: 0
 SUM_SELECT_RANGE: 0
 SUM_SELECT_RANGE_CHECK: 0
SUM_SELECT_SCAN: 6
SUM_SORT_MERGE_PASSES: 0
 SUM_SORT_RANGE: 0
  SUM_SORT_ROWS: 0
  SUM_SORT_SCAN: 0
SUM_NO_INDEX_USED: 6
 SUM_NO_GOOD_INDEX_USED: 0
...
</pre>

<p>У каждой сводной таблицы запросы есть один или более группирующихся
столбцов, чтобы указать как табличные события объединяются. Имена событий
обращаются к названиям инструментов событий в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<ul><li><p><a href="#stage-summary-tables"><code>
events_statements_summary_by_account_by_event_name</code></a>
имеет столбцы <code>EVENT_NAME</code>, <code>USER</code> и <code>HOST</code>.
Каждая строка суммирует события для сделанного отчета (комбинация
пользователя и узла) и имя событий.</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a> имеет столбцы
<code>SCHEMA_NAME</code> и <code>DIGEST</code>.
Каждая строка суммирует события для данных значений схемы/обзора.
<code>DIGEST_TEXT</code> содержит соответствующий нормализованный текст
обзора запроса, но не является ни группировкой, ни сводным столбцом.</p>

<p>Максимальное количество строк в таблице задано при запуске сервера. Чтобы
установить этот максимум явно, установите системнуюая переменную
<a href="#sysvar_performance_schema_digests_size"><code>
performance_schema_digests_size</code></a> при запуске сервера.</li>

<li><a href="#stage-summary-tables"><code>
events_statements_summary_by_host_by_event_name</code></a> имеет столбцы
<code>EVENT_NAME</code> и <code>HOST</code>.
Каждая строка суммирует события для данного узла и имени событий.</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_by_program</code></a> имеет столбцы
<code>OBJECT_TYPE</code>, <code>OBJECT_SCHEMA</code> и
<code>OBJECT_NAME</code>. Каждая строка суммирует события для данной
сохраненной программы (хранимая процедура или функция, триггер или событие).
</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_by_thread_by_event_name</code></a> имеет столбцы
<code>THREAD_ID</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного потока и имени событий.</li>

<li><a href="#stage-summary-tables"><code>
events_statements_summary_by_user_by_event_name</code></a> имеет столбцы
<code>EVENT_NAME</code> и <code>USER</code>. Каждая строка суммирует события
для данного пользователя и имени событий.</li>

<li><a href="#statement-summary-tables"><code>
events_statements_summary_global_by_event_name</code></a>
имеет столбец <code>EVENT_NAME</code>. Каждая строка суммирует события для
данного имени события.</li>

<li><a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>
имеет столбец <code>OBJECT_INSTANCE_BEGIN</code>. Каждая строка суммирует
события для данного подготовленного запроса.</p></li></ul>

<p>У каждой сводной таблицы запросов есть эти сводные столбцы, содержащие
соединенные значения (с исключениями, как отмечено):</p>
<ul><li><p><code>COUNT_STAR</code>, <code>SUM_TIMER_WAIT</code>,
<code>MIN_TIMER_WAIT</code>, <code>AVG_TIMER_WAIT</code>,
<code>MAX_TIMER_WAIT</code></p>
<p>Эти столбцы походят на столбцы с теми же самыми именами в
сводных таблицах событий (см. <a href="#wait-summary-tables">
раздел 23.9.15.1</a>), за исключением того, что события сводных таблиц
запросов собраны из <a href="#events-statements-current-table">
<code>events_statements_current</code></a> вместо
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>.</p>

<p>У <a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a> нет этих столбцов.</li>
<li><code>SUM_<em><code>xxx</code></em></code></p>
<p>Совокупность соответствующих столбцов <em><code>xxx</code></em> в
<a href="#events-statements-current-table"><code>
events_statements_current</code></a>. Например, столбцы
<code>SUM_LOCK_TIME</code> и <code>SUM_ERRORS</code>
в сводных таблицах запросов это совокупности столбцов
<code>LOCK_TIME</code> и <code>ERRORS</code> в
<a href="#events-statements-current-table"><code>
events_statements_current</code></a>.</p></li></ul>

<p>У <a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a>
есть эти дополнительные сводные столбцы:</p>

<ul><li><p><code>FIRST_SEEN_TIMESTAMP</code>,
<code>LAST_SEEN_TIMESTAMP</code></p>
<p>Времена, в которые запрос с данным значением обзора был
замечен в первый и последний раз.</p></li></ul>

<p>У <a href="#statement-summary-tables"><code>
events_statements_summary_by_program</code></a>
есть эти дополнительные сводные столбцы:</p>

<ul><li><p><code>COUNT_STATEMENTS</code>, <code>SUM_STATEMENTS_WAIT</code>,
<code>MIN_STATEMENTS_WAIT</code>, <code>AVG_STATEMENTS_WAIT</code>,
<code>MAX_STATEMENTS_WAIT</code></p>
<p>Статистика о вложенных запросах во время выполнения сохраненной программы.
</p></li></ul>

<p>У <a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>
есть эти дополнительные сводные столбцы:</p>

<ul><li><p><code>COUNT_EXECUTE</code>, <code>SUM_TIMER_EXECUTE</code>,
<code>MIN_TIMER_EXECUTE</code>, <code>AVG_TIMER_EXECUTE</code>,
<code>MAX_TIMER_EXECUTE</code></p>
<p>Соединенная статистика для выполнения готового запроса.</p></li></ul>

<p>Сводные таблицы запросы имеют индексы:</p>
<ul><li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_account_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>HOST</code>, <code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>SCHEMA_NAME</code>,
<code>DIGEST</code>).</p></li></ul></li>

<li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_host_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#statement-summary-tables"><code>
events_statements_summary_by_program</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_TYPE</code>,
<code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>).</p></li></ul></li>

<li><p><a href="#statement-summary-tables"><code>
events_statements_summary_by_thread_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#transaction-summary-tables">
<code>events_transactions_summary_by_user_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p>У <a href="#statement-summary-tables"><code>
events_statements_summary_global_by_event_name</code></a> есть эти индексы:
<ul><li><p>Первичный ключ на (<code>EVENT_NAME</code>).
</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
для сводных таблиц запросов. Это имеет эффекты:</p>
<ul><li><p>Для <a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a> это удаляет строки.</li>

<li>Для других сводных таблиц, не соединенных с учетной записью, узлом или
пользователем, усечение сбрасывает сводные столбцы к нолю вместо того,
чтобы удалить строки.</li>

<li>Для других сводных таблиц, соединенных с учетной записью, узлом или
пользователем, усечение удаляет строки для учетных записей, узлов или
пользователей без соединений и сбрасывает сводные столбцы к нолю
для остающихся строк.</p></li></ul>

<p>Кроме того, каждая сводная таблица запросов, которая соединена с учетной
записью, узлом, пользователем или потоком, является неявно усеченной
усечением таблицы соединения, от которой зависит, или усечением
<a href="#statement-summary-tables"><code>
events_statements_summary_global_by_event_name</code></a>.</p>

<h5><a name="statement-summary-tables-aggregation"></a>
Правила агрегации обзоров запросов</h5>
<p>Если потребитель включен <code>statement_digest</code>, агрегация в
<a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a>
происходит следующим образом, когда запрос завершается. Агрегация основана на
значении <code>DIGEST</code>, вычисленном для запроса.</p>

<ul><li><p>Если строка <a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a> уже существует со значением
обзора для запроса, который только что завершился, статистические данные для
запроса присоединены к этой строке. Столбец <code>LAST_SEEN</code>
обновлен к текущему времени.</li>

<li>Если ни у какой строки нет значения обзора для запроса, который только
что завершился, и таблица не полна, новая строка создается для запроса.
<code>FIRST_SEEN</code> и <code>LAST_SEEN</code>
инициализированы с текущим временем.</li>

<li>Если ни у какой строки нет значения обзора для запроса, который только
что завершился, и таблица полна, статистические данные для запроса
добавлены к специальной строке <span>catch-all</span> с
<code>DIGEST</code> = <code>NULL</code>,
который создается в случае необходимости. Если строка создается, столбцы
<code>FIRST_SEEN</code> и <code>LAST_SEEN</code>
инициализированы с текущим временем. Иначе <code>LAST_SEEN</code>
обновлен с текущим временем.</p></li></ul>

<p>Строка с <code>DIGEST</code> = <code>NULL</code> поддержана, потому что у
таблиц Performance Schema есть максимальный размер из-за ограничений памяти.
Строка <code>DIGEST</code> = <code>NULL</code> разрешает обзоры, которые не
соответствуют другим строкам, которые будут посчитаны, даже если сводная
таблица полна. Эта строка помогает Вам оценить, является ли
резюме обзора представительным:</p>

<ul><li><p>Строка <code>DIGEST</code> = <code>NULL</code>, у которой есть
значение <code>COUNT_STAR</code>, которое представляет 5% всех обзоров,
показывает, что сводная таблица обзора является очень представительной:
другие строки покрывают 95% замеченных запросов.</li>

<li>Строка <code>DIGEST</code> = <code>NULL</code>, у которой есть
значение <code>COUNT_STAR</code>, которое представляет 50% всех обзоров,
показывает, что сводная таблица обзора не является очень представительной:
другие строки покрывают только половину замеченных запросов. Наиболее
вероятно DBA должен увеличить максимальный табличный размер так, чтобы больше
строк включилось, а строка <code>DIGEST</code> = <code>NULL</code>
была бы посчитана, используя более определенные строки вместо этого.
Чтобы сделать это, установите системную переменную
<a href="#sysvar_performance_schema_digests_size"><code>
performance_schema_digests_size</code></a> к большему значению при запуске
сервера. Размер значения по умолчанию 200.</p></li></ul>

<h5><a name="statement-summary-tables-stored-programs"></a>
Поведение инструментовки сохраненной программы</h5>
<p>Для типов сохраненных программ, для которых инструментовка включена в
<a href="#setup-objects-table"><code>setup_objects</code></a>,
<a href="#statement-summary-tables"><code>
events_statements_summary_by_program</code></a>
поддерживает статистику для сохраненных программ следующим образом:</p>

<ul><li><p>Строка добавлена для объекта, когда он
сначала используется в сервере.</li>
<li>Строка для объекта удалена, когда объект удален.</li>
<li>Статистические данные соединены в строке для объекта, как он выполняется.
</p></li></ul>

<h4><a name="transaction-summary-tables"></a>23.9.15.4.
Операционные сводные таблицы</h4>
<p>Performance Schema поддерживает таблицы для того, чтобы собрать текущие и
недавние операционные события.
<a href="#performance-schema-transaction-tables">Раздел 23.9.7</a>
описывает события, на которых базируются операционные резюме.</p>

<p>Операционная информация о резюме событий в качестве примера:
<pre>
mysql&gt; SELECT * FROM events_transactions_summary_global_by_event_name
                   LIMIT 1\G
*************************** 1. row ***************************
EVENT_NAME: transaction
COUNT_STAR: 5
SUM_TIMER_WAIT: 19550092000
MIN_TIMER_WAIT: 2954148000
AVG_TIMER_WAIT: 3910018000
MAX_TIMER_WAIT: 5486275000
COUNT_READ_WRITE: 5
SUM_TIMER_READ_WRITE: 19550092000
MIN_TIMER_READ_WRITE: 2954148000
AVG_TIMER_READ_WRITE: 3910018000
MAX_TIMER_READ_WRITE: 5486275000
 COUNT_READ_ONLY: 0
 SUM_TIMER_READ_ONLY: 0
 MIN_TIMER_READ_ONLY: 0
 AVG_TIMER_READ_ONLY: 0
 MAX_TIMER_READ_ONLY: 0
</pre>

<p>У каждой операционной сводной таблицы есть один или более группирующихся
столбцов, чтобы указать как табличные события объединяются.
Имена событий обращаются к названиям инструментов событий в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<ul><li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_account_by_event_name</code></a> имеет столбцы
<code>USER</code>, <code>HOST</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для сделанного отчета (комбинация
пользователя и узла) и имя событий.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_host_by_event_name</code></a> имеет столбцы
<code>HOST</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного узла и имени событий.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_thread_by_event_name</code></a> имеет столбцы
<code>THREAD_ID</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного потока и имени событий.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_user_by_event_name</code></a> имеет столбцы
<code>USER</code> и <code>EVENT_NAME</code>. Каждая строка суммирует события
для данного пользователя и имени событий.</li>

<li><a href="#transaction-summary-tables"><code>
events_transactions_summary_global_by_event_name</code></a> имеет столбец
<code>EVENT_NAME</code>. Каждая строка суммирует события для
данного имени событий.</p></li></ul>

<p>У каждой операционной сводной таблицы есть эти сводные столбцы,
содержащие соединенные значения:</p>
<ul><li><p><code>COUNT_STAR</code>, <code>SUM_TIMER_WAIT</code>,
<code>MIN_TIMER_WAIT</code>, <code>AVG_TIMER_WAIT</code>,
<code>MAX_TIMER_WAIT</code></p>
<p>Эти столбцы походят на столбцы с теми же самыми именами в
сводных таблицах событий ожидания за исключением того, что операционные
события сводных таблиц из
<a href="#events-transactions-current-table"><code>
events_transactions_current</code></a> вместо
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>. Эти столбцы суммируют транзакции только для
чтения и чтения-записи.</li>

<li><code>COUNT_READ_WRITE</code>, <code>SUM_TIMER_READ_WRITE</code>,
<code>MIN_TIMER_READ_WRITE</code>, <code>AVG_TIMER_READ_WRITE</code>,
<code>MAX_TIMER_READ_WRITE</code></p>
<p>Они подобны <code>COUNT_STAR</code> и
<code><em><code>xxx</code></em>_TIMER_WAIT</code>, но подводят итог
только транзакций чтения-записи.</li>

<li><code>COUNT_READ_ONLY</code>, <code>SUM_TIMER_READ_ONLY</code>,
<code>MIN_TIMER_READ_ONLY</code>, <code>AVG_TIMER_READ_ONLY</code>,
<code>MAX_TIMER_READ_ONLY</code></p>
<p>Они подобны <code>COUNT_STAR</code> и
<code><em><code>xxx</code></em>_TIMER_WAIT</code>, но подводят итог
только транзакций чтения.</p></li></ul>

<p>Операционные сводные таблицы имеют индексы:</p>
<ul><li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_account_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>HOST</code>, <code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_host_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_thread_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_by_user_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#transaction-summary-tables"><code>
events_transactions_summary_global_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>EVENT_NAME</code>).
</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
для операционных сводных таблиц. Это имеет эффекты:</p>
<ul><li><p>Для сводных таблиц, не соединенных с учетной записью, узлом или
пользователем, усечение сбрасывает сводные столбцы к нолю вместо того,
чтобы удалить строки.</li>

<li>Для сводных таблиц, соединенных с учетной записью, узлом или
пользователем, усечение удаляет строки для учетных записей, узлов или
пользователей без соединений и сбрасывает сводные столбцы к нолю
для остающихся строк.</p></li></ul>

<h5><a name="transaction-summary-tables-aggregation"></a>
Правила агрегирования транзакций</h5>
<p>Операционный сбор событий происходит без отношения с уровнем изоляции,
режимом доступа или режимом autocommit.</p>

<p>Транзакции чтения-записи вообще требуют больше ресурсов,
чем транзакции только для чтения, поэтому операционные сводные таблицы
включают отдельные совокупные столбцы для чтения-записи
и транзакции только для чтения.</p>

<p>Требования ресурса могут также меняться в зависимости от операционного
уровня изоляции. Однако, предполагая, что только один уровень изоляции
использовался бы на сервере, агрегирование уровнем изоляции не обеспечено.
</p>

<h4><a name="objects-summary-global-by-type-table"></a>23.9.15.5.
Сводная таблица ожидания объектов</h4>
<p>Performance Schema поддерживает
<a href="#objects-summary-global-by-type-table"><code>
objects_summary_global_by_type</code></a>
для того, чтобы соединить события ожидания объектов.</p>

<p>Резюме событий в качестве примера:
<pre>
mysql&gt; SELECT * FROM objects_summary_global_by_type\G
...
*************************** 3. row ***************************
   OBJECT_TYPE: TABLE
 OBJECT_SCHEMA: test
   OBJECT_NAME: t
COUNT_STAR: 3
SUM_TIMER_WAIT: 263126976
MIN_TIMER_WAIT: 1522272
AVG_TIMER_WAIT: 87708678
MAX_TIMER_WAIT: 258428280
...
*************************** 10. row ***************************
   OBJECT_TYPE: TABLE
 OBJECT_SCHEMA: mysql
   OBJECT_NAME: user
COUNT_STAR: 14
SUM_TIMER_WAIT: 365567592
MIN_TIMER_WAIT: 1141704
AVG_TIMER_WAIT: 26111769
MAX_TIMER_WAIT: 334783032
...
</pre>

<p>У <a href="#objects-summary-global-by-type-table"><code>
objects_summary_global_by_type</code></a>
есть эти столбцы группировки, чтобы указать как табличные события
объединены: <code>OBJECT_TYPE</code>, <code>OBJECT_SCHEMA</code> и
<code>OBJECT_NAME</code>. Каждая строка суммирует события
для данного объекта.</p>

<p><a href="#objects-summary-global-by-type-table"><code>
objects_summary_global_by_type</code></a>
имеет те же самые сводные столбцы, как
<code>events_waits_summary_by_<em><code>xxx</code></em></code>. См.
<a href="#wait-summary-tables">раздел 23.9.15.1</a>.</p>

<p>У <a href="#objects-summary-global-by-type-table"><code>
objects_summary_global_by_type</code></a> есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_TYPE</code>,
<code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
для сводной таблицы объекта. Это сбрасывает сводные столбцы к нолю вместо
того, чтобы удалить строки.</p>

<h4><a name="file-summary-tables"></a>23.9.15.6.
Сводные таблицы ввода/вывода файла</h4>
<p>Performance Schema поддерживает сводные таблицы ввода/вывода файла.</p>

<p>Информация о резюме событий ввода/вывода файла в качестве примера:
<pre>
mysql&gt; SELECT * FROM file_summary_by_event_name\G
...
*************************** 2. row ***************************
   EVENT_NAME: wait/io/file/sql/binlog
   COUNT_STAR: 31
 SUM_TIMER_WAIT: 8243784888
 MIN_TIMER_WAIT: 0
 AVG_TIMER_WAIT: 265928484
 MAX_TIMER_WAIT: 6490658832
...
mysql&gt; SELECT * FROM file_summary_by_instance\G
...
*************************** 2. row ***************************
FILE_NAME: /var/mysql/share/english/errmsg.sys
   EVENT_NAME: wait/io/file/sql/ERRMSG
   EVENT_NAME: wait/io/file/sql/ERRMSG
OBJECT_INSTANCE_BEGIN: 4686193384
   COUNT_STAR: 5
 SUM_TIMER_WAIT: 13990154448
 MIN_TIMER_WAIT: 26349624
 AVG_TIMER_WAIT: 2798030607
 MAX_TIMER_WAIT: 8150662536
...
</pre>

<p>У каждой сводной таблицы ввода/вывода файла есть один или более
группирующихся столбцов, чтобы указать как табличные события объединяются.
Имена событий обращаются к названиям инструментов событий в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<ul><li><p><a href="#file-summary-tables"><code>
file_summary_by_event_name</code></a> имеет столбец
<code>EVENT_NAME</code>. Каждая строка суммирует события для
данного имени событий.</li>

<li><a href="#file-summary-tables"><code>file_summary_by_instance
</code></a> имеет столбцы <code>FILE_NAME</code>, <code>EVENT_NAME</code> и
<code>OBJECT_INSTANCE_BEGIN</code>. Каждая строка суммирует события для
данного файла и имени событий.</p></li></ul>

<p>У каждой сводной таблицы ввода/вывода файла есть следующие сводные
столбцы, содержащие соединенные значения. Некоторые столбцы являются более
общими и имеют значения, которые являются тем же самым, как сумма более
узконаправленных столбцов. Таким образом, данные в более высоких уровнях
доступны непосредственно без потребности в определяемых пользователем
представлениях, которые суммируют столбцы низшего уровня.</p>

<ul><li><p><code>COUNT_STAR</code>, <code>SUM_TIMER_WAIT</code>,
<code>MIN_TIMER_WAIT</code>, <code>AVG_TIMER_WAIT</code>,
<code>MAX_TIMER_WAIT</code>.</p>
<p>Эти столбцы агрегируют все операции ввода/вывода.</li>

<li><code>COUNT_READ</code>, <code>SUM_TIMER_READ</code>,
<code>MIN_TIMER_READ</code>, <code>AVG_TIMER_READ</code>,
<code>MAX_TIMER_READ</code>, <code>SUM_NUMBER_OF_BYTES_READ</code>.</p>
<p>Эти столбцы агрегируют все операции чтения, включая
<code>FGETS</code>, <code>FGETC</code>,
<code>FREAD</code> и <code>READ</code>.</li>

<li><code>COUNT_WRITE</code>, <code>SUM_TIMER_WRITE</code>,
<code>MIN_TIMER_WRITE</code>, <code>AVG_TIMER_WRITE</code>,
<code>MAX_TIMER_WRITE</code>, <code>SUM_NUMBER_OF_BYTES_WRITE</code></p>
<p>Эти столбцы агрегируют все операции записи, включая
<code>FPUTS</code>, <code>FPUTC</code>,
<code>FPRINTF</code>, <code>VFPRINTF</code>,
<code>FWRITE</code> и <code>PWRITE</code>.</li>

<li><code>COUNT_MISC</code>, <code>SUM_TIMER_MISC</code>,
<code>MIN_TIMER_MISC</code>, <code>AVG_TIMER_MISC</code>,
<code>MAX_TIMER_MISC</code></p>
<p>Эти столбцы агрегируют все другие операции ввода/вывода, включая
<code>CREATE</code>, <code>DELETE</code>, <code>OPEN</code>,
<code>CLOSE</code>, <code>STREAM_OPEN</code>, <code>STREAM_CLOSE</code>,
<code>SEEK</code>, <code>TELL</code>, <code>FLUSH</code>, <code>STAT</code>,
<code>FSTAT</code>, <code>CHSIZE</code>, <code>RENAME</code> и
<code>SYNC</code>. Нет никаких счетчиков байтов для этих операций.
</p></li></ul>

<p>Сводные таблицы ввода/вывода файла имеют индексы:</p>
<ul><li><p><a href="#file-summary-tables"><code>
file_summary_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#file-summary-tables"><code>
file_summary_by_instance</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>FILE_NAME</code>).</li>
<li>Индекс на (<code>EVENT_NAME</code>).</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
для сводных таблиц ввода/вывода файла. Это сбрасывает сводные столбцы к
нолю вместо того, чтобы удалить строки.</p>

<p>Сервер MySQL использует несколько методов, чтобы избежать операций
ввода/вывода, кэшируя информацию, считанную из файлов, таким образом,
возможно, что запросов, которых Вы могли бы ожидать, не будет. Вы можете
быть в состоянии гарантировать, что ввод/вывод действительно происходит,
сбрасывая кэши или перезапуская сервер, чтобы сбросить его состояние.</p>

<h4><a name="table-waits-summary-tables"></a>23.9.15.7.
Сводные таблицы ввода/вывода и ожидания блокировки</h4>
<p>Следующие разделы описывают табличный ввод/вывод и ожидание блокировки:
</p>

<ul><li><p><a href="#table-io-waits-summary-by-index-usage-table">
<code>table_io_waits_summary_by_index_usage</code></a>:
Табличный ввод/вывод на индекс.</li>

<li><a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a>:
Табличный ввод/вывод на таблицу.</li>

<li><a href="#table-lock-waits-summary-by-table-table"><code>
table_lock_waits_summary_by_table</code></a>:
Табличная блокировка на таблицу.</p></li></ul>

<h5><a name="table-io-waits-summary-by-table-table"></a>23.9.15.7.1.
Таблица table_io_waits_summary_by_table</h5>
<p><a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a>
собирает весь табличный ввод/вывод, произведенный инструментом
<code>wait/io/table/sql/handler</code>. Группировка таблицей.</p>

<p><a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a>
имеет эти столбцы группировки, чтобы указать как табличные события
объединены: <code>OBJECT_TYPE</code>, <code>OBJECT_SCHEMA</code> и
<code>OBJECT_NAME</code>. У этих столбцов есть то же самое значение, как в
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>. Они идентифицируют таблицу, к которой применяется строка.</p>

<p><a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a>
имеет следующие сводные столбцы, содержащие соединенные значения. Как
обозначено в описаниях столбца, некоторые столбцы являются более общими и
имеют значения, которые являются тем же самым как сумма значений более
детальных столбцов. Например, столбцы, которые собирают все записи, содержат
сумму соответствующих столбцов, которые собирают вставки, обновления и
удаления. Таким образом, данные в более высоких уровнях доступны
непосредственно без потребности в определяемых пользователем представлениях,
которые суммируют столбцы низшего уровня.</p>

<ul><li><p><code>COUNT_STAR</code>, <code>SUM_TIMER_WAIT</code>,
<code>MIN_TIMER_WAIT</code>, <code>AVG_TIMER_WAIT</code>,
<code>MAX_TIMER_WAIT</code>.</p>
<p>Эти столбцы собирают все операции ввода/вывода. Они то же самое, как сумма
столбцов <code><em><code>xxx</code></em>_READ</code> и
<code><em><code>xxx</code></em>_WRITE</code>.</li>

<li><code>COUNT_READ</code>, <code>SUM_TIMER_READ</code>,
<code>MIN_TIMER_READ</code>, <code>AVG_TIMER_READ</code>,
<code>MAX_TIMER_READ</code>.</p>
<p>Эти столбцы собирают все операции чтения. Они то же самое, как сумма
столбцов <code><em><code>xxx</code></em>_FETCH</code>.</li>

<li><code>COUNT_WRITE</code>, <code>SUM_TIMER_WRITE</code>,
<code>MIN_TIMER_WRITE</code>, <code>AVG_TIMER_WRITE</code>,
<code>MAX_TIMER_WRITE</code>.</p>
<p>Эти столбцы собирают все операции записи. Они то же самое, как сумма
столбцов <code><em><code>xxx</code></em>_INSERT</code>,
<code><em><code>xxx</code></em>_UPDATE</code> и
<code><em><code>xxx</code></em>_DELETE</code>.</li>

<li><code>COUNT_FETCH</code>, <code>SUM_TIMER_FETCH</code>,
<code>MIN_TIMER_FETCH</code>, <code>AVG_TIMER_FETCH</code>,
<code>MAX_TIMER_FETCH</code></p>
<p>Эти столбцы собирают все операции получения.</li>

<li><code>COUNT_INSERT</code>, <code>SUM_TIMER_INSERT</code>,
<code>MIN_TIMER_INSERT</code>, <code>AVG_TIMER_INSERT</code>,
<code>MAX_TIMER_INSERT</code></p>
<p>Эти столбцы собирают все операции вставки.</li>

<li><code>COUNT_UPDATE</code>, <code>SUM_TIMER_UPDATE</code>,
<code>MIN_TIMER_UPDATE</code>, <code>AVG_TIMER_UPDATE</code>,
<code>MAX_TIMER_UPDATE</code></p>
<p>Эти столбцы собирают все операции обновления.</li>

<li><code>COUNT_DELETE</code>, <code>SUM_TIMER_DELETE</code>,
<code>MIN_TIMER_DELETE</code>, <code>AVG_TIMER_DELETE</code>,
<code>MAX_TIMER_DELETE</code></p>
<p>Эти столбцы собирают все операции удаления.</p></li></ul>

<p>У <a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a> есть эти индексы:</p>
<ul><li><p>Индекс Unique на (<code>OBJECT_TYPE</code>,
<code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> разрешен
для табличных сводных таблиц ввода/вывода. Это сбрасывает сводные столбцы к
нолю вместо того, чтобы удалить строки. Усечение этой таблицы также усекает
<a href="#table-io-waits-summary-by-index-usage-table">
<code>table_io_waits_summary_by_index_usage</code></a>.</p>

<h5><a name="table-io-waits-summary-by-index-usage-table"></a>23.9.15.7.2.
Таблица table_io_waits_summary_by_index_usage</h5>
<p><a href="#table-io-waits-summary-by-index-usage-table"><code>
table_io_waits_summary_by_index_usage</code></a> собирает все события
ожидания ввода/вывода индексов как произведено инструментом
<code>wait/io/table/sql/handler</code>. Группировка по индексу таблицы.</p>

<p>Столбцы <a href="#table-io-waits-summary-by-index-usage-table">
<code>table_io_waits_summary_by_index_usage</code></a> почти идентичны
<a href="#table-io-waits-summary-by-table-table"><code>
table_io_waits_summary_by_table</code></a>. Единственная разница:
дополнительный групповой столбец <code>INDEX_NAME</code>,
который соответствует названию индекса, который использовался,
когда случай ожидания табличного ввода/вывода был зарегистрирован:</p>

<ul><li><p>Значение <code>PRIMARY</code> указывает, что табличный ввод/вывод
использовал первичный индекс.</li>
<li>Значение <code>NULL</code> указывает, что табличный ввод/вывод
не использовал индекс.</li>
<li>Вставки сосчитаны с учетом <code>INDEX_NAME = NULL</code>.</p></li></ul>

<p>У <a href="#table-io-waits-summary-by-index-usage-table">
<code>table_io_waits_summary_by_index_usage</code></a> есть эти индексы:</p>
<ul><li><p>Индекс Unique на (<code>OBJECT_TYPE</code>,
<code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>,
<code>INDEX_NAME</code>)</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
разрешен для сводных таблиц ввода/вывода. Это сбрасывает сводные столбцы к
нолю вместо того, чтобы удалить строки. Эта таблица является также усеченной
усечением <a href="#table-io-waits-summary-by-table-table">
<code>table_io_waits_summary_by_table</code></a>. Операция DDL, которая
изменяет индексную структуру таблицы, может вызвать
сброс статистики индексов.</p>

<h5><a name="table-lock-waits-summary-by-table-table"></a>23.9.15.7.3.
Таблица table_lock_waits_summary_by_table</h5>
<p><a href="#table-lock-waits-summary-by-table-table"><code>
table_lock_waits_summary_by_table</code></a> собирает все события ожидания
табличной блокировки как произведено инструментом
<code>wait/lock/table/sql/handler</code>. Группировка по таблице.</p>

<p>Эта таблица содержит информацию о внутренних и внешних блокировках:</p>
<ul><li><p>Внутренняя блокировка соответствует блокировке в уровне SQL. Это в
настоящее время осуществляется вызовом <code>thr_lock()</code>.
В строках событий эти блокировки отличаются столбцом <code>OPERATION</code>,
у которого есть одно из этих значений:
<pre>
read normal
read with shared locks
read high priority
read no insert
write allow write
write concurrent insert
write delayed
write low priority
write normal
</pre></li>

<li>Внешняя блокировка соответствует блокировке в уровне механизма хранения.
Это в настоящее время осуществляется вызовом
<code>handler::external_lock()</code>. В строках событий эти блокировки
отличаются столбцом <code>OPERATION</code>, у которого есть одно
из этих значений:
<pre>
read external
write external
</pre></li></ul>

<p>У <a href="#table-lock-waits-summary-by-table-table"><code>
table_lock_waits_summary_by_table</code></a>
есть эти столбцы группировки, чтобы указать как табличные события
объединяются: <code>OBJECT_TYPE</code>, <code>OBJECT_SCHEMA</code> и
<code>OBJECT_NAME</code>. У этих столбцов есть то же самое значение, как в
<a href="#events-waits-current-table"><code>events_waits_current
</code></a>. Они идентифицируют таблицу, к которой применяется строка.</p>

<p><a href="#table-lock-waits-summary-by-table-table">
<code>table_lock_waits_summary_by_table</code></a>
имеет следующие сводные столбцы, содержащие соединенные значения. Как
обозначено в описаниях столбца, некоторые столбцы являются более общими и
имеют значения, которые являются тем же самым, как сумма значений более
специальных столбцов. Например, столбцы, которые собирают все блокировки,
хранят сумму столбцов, соответствующих блокировкам чтения и записи.
Таким образом, данные в более высоких уровнях доступны непосредственно без
потребности в определяемых пользователем представлениях, которые суммируют
столбцы низшего уровня.</p>

<ul><li><p><code>COUNT_STAR</code>, <code>SUM_TIMER_WAIT</code>,
<code>MIN_TIMER_WAIT</code>, <code>AVG_TIMER_WAIT</code>,
<code>MAX_TIMER_WAIT</code></p>
<p>Эти столбцы агрегируют все операции блокировки. Они то же самое, как сумма
соответствующих столбцов <code><em><code>xxx</code></em>_READ</code> и
<code><em><code>xxx</code></em>_WRITE</code>.</li>

<li><code>COUNT_READ</code>, <code>SUM_TIMER_READ</code>,
<code>MIN_TIMER_READ</code>, <code>AVG_TIMER_READ</code>,
<code>MAX_TIMER_READ</code></p>
<p>Эти столбцы агрегируют все операции блокировки чтения. Они то же самое,
как сумма соответствующих столбцов <code><em><code>xxx</code></em>
_READ_NORMAL</code>, <code><em><code>xxx</code></em>_READ_WITH_SHARED_LOCKS
</code>, <code><em><code>xxx</code></em>_READ_HIGH_PRIORITY</code>
и <code><em><code>xxx</code></em>_READ_NO_INSERT</code>.</li>

<li><code>COUNT_WRITE</code>, <code>SUM_TIMER_WRITE</code>,
<code>MIN_TIMER_WRITE</code>, <code>AVG_TIMER_WRITE</code>,
<code>MAX_TIMER_WRITE</code></p>
<p>Эти столбцы агрегируют все операции блокировки записи. Они то же самое,
как сумма соответствующих столбцов
<code><em><code>xxx</code></em>_WRITE_ALLOW_WRITE</code>,
<code><em><code>xxx</code></em>_WRITE_CONCURRENT_INSERT</code>,
<code><em><code>xxx</code></em>_WRITE_LOW_PRIORITY</code> и
<code><em><code>xxx</code></em>_WRITE_NORMAL</code>.</li>

<li><code>COUNT_READ_NORMAL</code>, <code>SUM_TIMER_READ_NORMAL</code>,
<code>MIN_TIMER_READ_NORMAL</code>, <code>AVG_TIMER_READ_NORMAL</code>,
<code>MAX_TIMER_READ_NORMAL</code></p>
<p>Эти столбцы агрегируют все внутренние блокировки чтения.</li>

<li><code>COUNT_READ_WITH_SHARED_LOCKS</code>,
<code>SUM_TIMER_READ_WITH_SHARED_LOCKS</code>,
<code>MIN_TIMER_READ_WITH_SHARED_LOCKS</code>,
<code>AVG_TIMER_READ_WITH_SHARED_LOCKS</code>,
<code>MAX_TIMER_READ_WITH_SHARED_LOCKS</code></p>
<p>Эти столбцы агрегируют все внутренние блокировки чтения.</li>

<li><code>COUNT_READ_HIGH_PRIORITY</code>,
<code>SUM_TIMER_READ_HIGH_PRIORITY</code>,
<code>MIN_TIMER_READ_HIGH_PRIORITY</code>,
<code>AVG_TIMER_READ_HIGH_PRIORITY</code>,
<code>MAX_TIMER_READ_HIGH_PRIORITY</code></p>
<p>Эти столбцы агрегируют все внутренние блокировки чтения.</li>

<li><code>COUNT_READ_NO_INSERT</code>,
<code>SUM_TIMER_READ_NO_INSERT</code>,
<code>MIN_TIMER_READ_NO_INSERT</code>,
<code>AVG_TIMER_READ_NO_INSERT</code>,
<code>MAX_TIMER_READ_NO_INSERT</code></p>
<p>Эти столбцы агрегируют все внутренние блокировки чтения.</li>

<li><code>COUNT_READ_EXTERNAL</code>,
<code>SUM_TIMER_READ_EXTERNAL</code>,
<code>MIN_TIMER_READ_EXTERNAL</code>,
<code>AVG_TIMER_READ_EXTERNAL</code>,
<code>MAX_TIMER_READ_EXTERNAL</code></p>
<p>Эти столбцы агрегируют все внешние блокировки чтения.</li>

<li><code>COUNT_WRITE_ALLOW_WRITE</code>,
<code>SUM_TIMER_WRITE_ALLOW_WRITE</code>,
<code>MIN_TIMER_WRITE_ALLOW_WRITE</code>,
<code>AVG_TIMER_WRITE_ALLOW_WRITE</code>,
<code>MAX_TIMER_WRITE_ALLOW_WRITE</code></p>
<p>Эти столбцы агрегируют все внутренние блокировки записи.</li>

<li><code>COUNT_WRITE_CONCURRENT_INSERT</code>,
<code>SUM_TIMER_WRITE_CONCURRENT_INSERT</code>,
<code>MIN_TIMER_WRITE_CONCURRENT_INSERT</code>,
<code>AVG_TIMER_WRITE_CONCURRENT_INSERT</code>,
<code>MAX_TIMER_WRITE_CONCURRENT_INSERT</code></p>
<p>Эти столбцы агрегируют все внутренние блокировки записи.</li>

<li><code>COUNT_WRITE_LOW_PRIORITY</code>,
<code>SUM_TIMER_WRITE_LOW_PRIORITY</code>,
<code>MIN_TIMER_WRITE_LOW_PRIORITY</code>,
<code>AVG_TIMER_WRITE_LOW_PRIORITY</code>,
<code>MAX_TIMER_WRITE_LOW_PRIORITY</code></p>
<p>Эти столбцы агрегируют все внутренние блокировки записи.</li>

<li><code>COUNT_WRITE_NORMAL</code>, <code>SUM_TIMER_WRITE_NORMAL</code>,
<code>MIN_TIMER_WRITE_NORMAL</code>, <code>AVG_TIMER_WRITE_NORMAL</code>,
<code>MAX_TIMER_WRITE_NORMAL</code>.</p>
<p>Эти столбцы агрегируют все внутренние блокировки записи.</li>

<li><code>COUNT_WRITE_EXTERNAL</code>,
<code>SUM_TIMER_WRITE_EXTERNAL</code>,
<code>MIN_TIMER_WRITE_EXTERNAL</code>,
<code>AVG_TIMER_WRITE_EXTERNAL</code>,
<code>MAX_TIMER_WRITE_EXTERNAL</code></p>
<p>Эти столбцы агрегируют все внешние блокировки записи.</p></li></ul>

<p>У <a href="#table-lock-waits-summary-by-table-table">
<code>table_lock_waits_summary_by_table</code></a> есть эти индексы:</p>
<ul><li><p>Индекс Unique на (<code>OBJECT_TYPE</code>,
<code>OBJECT_SCHEMA</code>, <code>OBJECT_NAME</code>).</p></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
разрешен для сводных таблиц блокировки. Это сбрасывает сводные столбцы к нолю
вместо того, чтобы удалить строки.</p>

<h4><a name="socket-summary-tables"></a>23.9.15.8. Сводные таблицы сокета</h4>
<p>Эти сводные таблицы сокета агрегируют информацию таймера и число байт
для операций сокета:</p>

<ul><li><p><a href="#socket-summary-tables"><code>
socket_summary_by_event_name</code></a>:
Собирает статистику с инструментов <code>wait/io/socket/*</code>
для всех операций ввода/вывода сокета на инструмент сокета.</li>

<li><a href="#socket-summary-tables"><code>
socket_summary_by_instance</code></a>:
Собирает статистику с инструментов <code>wait/io/socket/*</code>
для всех операций ввода/вывода сокета случай сокета. Когда соединение
заканчивается, строка в <a href="#socket-summary-tables"><code>
socket_summary_by_instance</code></a> удалена.</p></li></ul>

<p>Сводные таблицы сокета не соединяют ожидания, произведенные событиями
<code>idle</code> в то время, как сокеты ждут следующего запроса от клиента.
Для агрегирования событий <code>idle</code>, используйте сводные таблицы
случаев ожидания, см.
<a href="#wait-summary-tables">раздел 23.9.15.1</a>.</p>

<p>У каждой сводной таблицы сокета есть один или более группирующихся
столбцов, чтобы указать как табличные события объединены.
Имена событий обращаются к названиям инструментов событий в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<ul><li><p><a href="#socket-summary-tables"><code>
socket_summary_by_event_name</code></a> имеет столбец
<code>EVENT_NAME</code>. Каждая строка суммирует события для
данного имени событий.</li>

<li><a href="#socket-summary-tables"><code>
socket_summary_by_instance</code></a> имеет столбец
<code>OBJECT_INSTANCE_BEGIN</code>.
Каждая строка суммирует события для данного объекта.</p></li></ul>

<p>У каждой сводной таблицы сокета есть эти сводные столбцы,
содержащие соединенные значения:</p>
<ul><li><p><code>COUNT_STAR</code>, <code>SUM_TIMER_WAIT</code>,
<code>MIN_TIMER_WAIT</code>, <code>AVG_TIMER_WAIT</code>,
<code>MAX_TIMER_WAIT</code></p>
<p>Эти столбцы агрегируют все операции.</li>

<li><code>COUNT_READ</code>, <code>SUM_TIMER_READ</code>,
<code>MIN_TIMER_READ</code>, <code>AVG_TIMER_READ</code>,
<code>MAX_TIMER_READ</code>, <code>SUM_NUMBER_OF_BYTES_READ</code></p>
<p>Эти столбцы агрегируют все операции получения
(<code>RECV</code>, <code>RECVFROM</code> и <code>RECVMSG</code>).</li>

<li><code>COUNT_WRITE</code>, <code>SUM_TIMER_WRITE</code>,
<code>MIN_TIMER_WRITE</code>, <code>AVG_TIMER_WRITE</code>,
<code>MAX_TIMER_WRITE</code>, <code>SUM_NUMBER_OF_BYTES_WRITE</code></p>
<p>Эти столбцы агрегируют все операции передачи
(<code>SEND</code>, <code>SENDTO</code> и <code>SENDMSG</code>).</li>

<li><code>COUNT_MISC</code>, <code>SUM_TIMER_MISC</code>,
<code>MIN_TIMER_MISC</code>, <code>AVG_TIMER_MISC</code>,
<code>MAX_TIMER_MISC</code></p>
<p>Эти столбцы агрегируют все прочие операции, такие как
<code>CONNECT</code>, <code>LISTEN</code>,
<code>ACCEPT</code>, <code>CLOSE</code> и <code>SHUTDOWN</code>.
Нет никаких счетчиков байтов для этих операций.</p></li></ul>

<p><a href="#socket-summary-tables"><code>
socket_summary_by_instance</code></a> также имеет столбец
<code>EVENT_NAME</code>, который указывает на класс сокета:
<code>client_connection</code>, <code>server_tcpip_socket</code>,
<code>server_unix_socket</code>.
Этот столбец может быть сгруппирован на изоляцию, например, деятельность
клиента, от которого сервер слушает сокеты.</p>

<p>Сводные таблицы сокета имеют индексы:</p>
<ul><li><p><a href="#socket-summary-tables"><code>
socket_summary_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#socket-summary-tables"><code>
socket_summary_by_instance</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>OBJECT_INSTANCE_BEGIN</code>).</li>
<li>Индекс на (<code>EVENT_NAME</code>).</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на сводных таблицах сокета. За исключением
<a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a>
это сбрасывает сводные столбцы к нолю вместо того, чтобы удалить строки.</p>

<h4><a name="memory-summary-tables"></a>23.9.15.9. Сводные таблицы памяти</h4>
<p>Инструментальное использование памяти Performance Schema и
статистика использования памяти детализирована этими факторами:</p>

<ul><li><p>Тип используемой памяти (различные кэши, внутренние буферы и т.д).
</li>
<li>Поток, учетная запись, пользователь, хост.</p></li></ul>

<p>Performance Schema инструментует следующие аспекты использования памяти:
</p>
<ul><li><p>Размеры памяти.</li>
<li>Количество работы.</li>
<li>Нижняя и верхняя метки.</p></li></ul>

<p>Размеры памяти помогают понять или настроить потребление памяти сервером.
</p>
<p>Графы работы помогают понять или настроить полное распределение памяти,
который оказывает влияние на работу. Выделение единственного байта один
миллион раз не является тем же самым как выделение мегабайта разово,
отслеживание количества и размеров может выставить различие.</p>

<p>Метки важны, чтобы обнаружить пики рабочей нагрузки, полную стабильность
рабочей нагрузки и возможные утечки памяти.</p>
<p>Сводные таблицы памяти не содержат информацию о синхронизации, потому что
события памяти не рассчитаны.</p>

<p>Информация о резюме событий памяти в качестве примера:
<pre>
mysql&gt; SELECT * FROM memory_summary_global_by_event_name
                   WHERE EVENT_NAME = 'memory/sql/TABLE'\G
*************************** 1. row ***************************
EVENT_NAME: memory/sql/TABLE
 COUNT_ALLOC: 1381
COUNT_FREE: 924
   SUM_NUMBER_OF_BYTES_ALLOC: 2059873
SUM_NUMBER_OF_BYTES_FREE: 1407432
  LOW_COUNT_USED: 0
CURRENT_COUNT_USED: 457
 HIGH_COUNT_USED: 461
LOW_NUMBER_OF_BYTES_USED: 0
CURRENT_NUMBER_OF_BYTES_USED: 652441
   HIGH_NUMBER_OF_BYTES_USED: 669269
</pre>

<p>У каждой сводной таблицы памяти есть один или более группирующихся
столбцов, чтобы указать как табличные события объединены. Имена событий
обращаются к названиям инструментов событий в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p>

<ul><li><p><a href="#memory-summary-tables"><code>
memory_summary_by_account_by_event_name</code></a> имеет столбцы
<code>USER</code>, <code>HOST</code> и <code>EVENT_NAME</code>. Каждая строка
суммирует события для сделанного отчета (комбинация пользователя и
узла) и имя событий.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_by_host_by_event_name</code></a> имеет столбцы
<code>HOST</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного узла и имени событий.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_by_thread_by_event_name</code></a> имеет столбцы
<code>THREAD_ID</code> и <code>EVENT_NAME</code>.
Каждая строка суммирует события для данного потока и имени событий.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_by_user_by_event_name</code></a> имеет столбцы
<code>USER</code> и <code>EVENT_NAME</code>. Каждая строка суммирует события
для данного пользователя и имени событий.</li>

<li><a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a> имеет столбец
<code>EVENT_NAME</code>. Каждая строка суммирует события для
данного имени событий.</p></li></ul>

<p>У каждой сводной таблицы памяти есть эти сводные столбцы,
содержащие соединенные значения:</p>
<ul><li><p><code>COUNT_ALLOC</code>, <code>COUNT_FREE</code></p>
<p>Соединенные числа вызовов функций, подобных malloc и free.</li>

<li><code>SUM_NUMBER_OF_BYTES_ALLOC</code>,
<code>SUM_NUMBER_OF_BYTES_FREE</code></p>
<p>Соединенные размеры выделенных и освобожденных блоков памяти.</li>

<li><code>CURRENT_COUNT_USED</code></p>
<p>Соединенное число в настоящее время выделяемых блоков, которые еще не были
освобождены. Это столбец удобства, равный
<code>COUNT_ALLOC</code> - <code>COUNT_FREE</code>.</li>

<li><code>CURRENT_NUMBER_OF_BYTES_USED</code></p>
<p>Соединенный размер в настоящее время выделяемых блоков памяти, которые еще
не были освобождены. Это столбец удобства, равный
<code>SUM_NUMBER_OF_BYTES_ALLOC</code>-<code>SUM_NUMBER_OF_BYTES_FREE</code>.
</li>

<li><code>LOW_COUNT_USED</code>, <code>HIGH_COUNT_USED</code></p>
<p>Метки, соответствующие столбцу <code>CURRENT_COUNT_USED</code>.</li>
<li><code>LOW_NUMBER_OF_BYTES_USED</code>,
<code>HIGH_NUMBER_OF_BYTES_USED</code></p>
<p>Метки, соответствующие столбцу <code>CURRENT_NUMBER_OF_BYTES_USED</code>.
</p></li></ul>

<p>Сводные таблицы памяти имеют индексы:</p>
<ul><li><p><a href="#memory-summary-tables"><code>
memory_summary_by_account_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>HOST</code>, <code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#memory-summary-tables"><code>
memory_summary_by_host_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#memory-summary-tables"><code>
memory_summary_by_thread_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#memory-summary-tables"><code>
memory_summary_by_user_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>EVENT_NAME</code>).</p></li></ul></li>

<li><p><a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>EVENT_NAME</code>).
</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на сводных таблицах памяти. Это имеет эффекты:</p>
<ul><li><p>Вообще, усечение сбрасывает базовую линию для статистики, но не
изменяет состояние сервера. Таким образом, усечение таблицы памяти
не освобождает память.</li>

<li><code>COUNT_ALLOC</code> и <code>COUNT_FREE</code>
сброшены к новой базовой линии, уменьшая каждый счетчик тем
же самым значением.</li>

<li>Аналогично <code>SUM_NUMBER_OF_BYTES_ALLOC</code> и
<code>SUM_NUMBER_OF_BYTES_FREE</code>
сброшены к новой базовой линии.</li>

<li><code>LOW_COUNT_USED</code> и <code>HIGH_COUNT_USED</code>
сброшены к <code>CURRENT_COUNT_USED</code>.</li>
<li><code>LOW_NUMBER_OF_BYTES_USED</code> и
<code>HIGH_NUMBER_OF_BYTES_USED</code> сброшены к
<code>CURRENT_NUMBER_OF_BYTES_USED</code>.</p></li></ul>

<p>Кроме того, каждая сводная таблица памяти, которая соединена с учетной
записью, узлом, пользователем или потоком, является неявно усеченной
усечением таблицы, от которой зависит, или усечением
<a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a>. Для деталей см.
<a href="#performance-schema-connection-tables">раздел 23.9.8</a>.
</p>

<h5><a name="memory-instrumentation-behavior"></a>
Поведение инструментовки памяти</h5>
<p>Большинство инструментов памяти отключено по умолчанию и может быть
включено или отключено динамически, обновляя столбец <code>ENABLED</code>
соответствующих инструментов в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. У инструментов памяти есть названия формы
<code>memory/<em><code>code_area</code></em>/<em><code>instrument_name</code>
</em></code>.</p>

<p>Чтобы включить все инструменты памяти, выполните этот запрос:
<pre>
mysql&gt; UPDATE setup_instruments SET ENABLED='YES'
                 WHERE NAME LIKE 'memory/%';
</pre>

<p>Инструменты с приставкой <code>memory/performance_schema/</code>
показывают, сколько памяти выделено для внутренних буферов в
Performance Schema непосредственно. Инструменты
<code>memory/performance_schema/</code> встроены, всегда включаются и не
могут быть отключены при запуске или во время выполнения. Встроенные
инструменты памяти выведены на экран только в таблице
<a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a>.</p>

<p>Для инструментов памяти столбец <code>TIMED</code> в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a> проигнорирован, потому что операции памяти не рассчитаны.</p>

<p>Когда поток в сервере выполняет распределение памяти, которое было
инструментовано, эти правила применяются:</p>
<ul><li><p>Если поток не инструментован или инструмент памяти не включен,
выделенный блок памяти не инструментован.</li>
<li>Иначе (то есть, поток и инструмент включены), выделенный
блок памяти инструментован.</p></li></ul>

<p>Для освобождения применяются эти правила:</p>
<ul><li><p>Если поток инструментован, а блок памяти не инструментован,
освобождение не инструментовано, никакие статистические данные не изменены.
</li>
<li>Если поток не инструментован, а блок памяти инструментован,
освобождение инструментовано, статистические данные изменены.</p></li></ul>

<p>Для статистики по потокам применяются следующие правила.</p>
<p>Когда инструментованный блок памяти размера
<em><code>N</code></em> выделен, Performance Schema
делает эти обновления столбцов сводной таблицы памяти:</p>

<ul><li><p><code>COUNT_ALLOC</code>: увеличен на 1.</li>
<li><code>CURRENT_COUNT_USED</code>: увеличен на 1.</li>
<li><code>HIGH_COUNT_USED</code>: увеличен, если
<code>CURRENT_COUNT_USED</code> новый максимум.</li>

<li><code>SUM_NUMBER_OF_BYTES_ALLOC</code>: увеличен на
<em><code>N</code></em>.</li>
<li><code>CURRENT_NUMBER_OF_BYTES_USED</code>:
увеличен на <em><code>N</code></em>.</li>
<li><code>HIGH_NUMBER_OF_BYTES_USED</code>: увеличен, если
<code>CURRENT_NUMBER_OF_BYTES_USED</code> новый максимум.</p></li></ul>

<p>Когда инструментованный блок памяти освобожден,
Performance Schema делает эти обновления столбцов сводной таблицы памяти:</p>
<ul><li><p><code>COUNT_FREE</code>: увеличен на 1.</li>
<li><code>CURRENT_COUNT_USED</code>: уменьшен на 1.</li>

<li><code>LOW_COUNT_USED</code>: уменьшена, если
<code>CURRENT_COUNT_USED</code> новый минимум.</li>
<li><code>SUM_NUMBER_OF_BYTES_FREE</code>: увеличен на
<em><code>N</code></em>.</li>

<li><code>CURRENT_NUMBER_OF_BYTES_USED</code>:
уменьшен на <em><code>N</code></em>.</li>
<li><code>LOW_NUMBER_OF_BYTES_USED</code>: уменьшен, если
<code>CURRENT_NUMBER_OF_BYTES_USED</code> новый минимум.</p></li></ul>

<p>Для высокоуровневых совокупностей (глобальной, учетной записи,
пользователя, узла) те же самые правила применяются.</p>
<ul><li><p><code>LOW_COUNT_USED</code> и
<code>LOW_NUMBER_OF_BYTES_USED</code> более низкие оценки. Значение, о
котором сообщает Performance Schema, будет меньше чем или равно самому
низкому размеру памяти, эффективно используемой во время выполнения.</li>

<li><code>HIGH_COUNT_USED</code> и
<code>HIGH_NUMBER_OF_BYTES_USED</code>
более высокие оценки. Значение, о котором сообщает Performance Schema,
будет больше чем или равным самому высокому размеру памяти, эффективно
используемой во время выполнения.</p></li></ul>

<p>Для более низких оценок в сводных таблицах кроме
<a href="#memory-summary-tables"><code>
memory_summary_global_by_event_name</code></a>,
возможны отрицательные значения, если память передана между потоками.</p>

<p>Вот пример оценочного вычисления,
отметьте, что оценочное выполнение подвержено изменениям:</p>
<p>Поток 1 использует память в диапазоне от 1 МБ до 2 МБ во время выполнения,
как сообщают столбцы <code>LOW_NUMBER_OF_BYTES_USED</code> и
<code>HIGH_NUMBER_OF_BYTES_USED</code> в
<a href="#memory-summary-tables"><code>
memory_summary_by_thread_by_event_name</code></a>.</p>

<p>Поток 2 использует память в диапазоне от 10 МБ до 12 МБ
во время выполнения.</p>
<p>Когда эти два потока принадлежат той же самой учетной записи пользователя,
резюме на учетную запись оценивает, что эта учетная запись использовала
память в диапазоне от 11 МБ до 14 МБ. Таким образом,
<code>LOW_NUMBER_OF_BYTES_USED</code> как высокоуровневая совокупность это
сумма всех <code>LOW_NUMBER_OF_BYTES_USED</code> (принятие худшего случая).
Аналогично <code>HIGH_NUMBER_OF_BYTES_USED</code> как
высокоуровневая совокупность это сумма всех
<code>HIGH_NUMBER_OF_BYTES_USED</code> (принятие худшего случая).</p>

<p>11MB более низкая оценка, которая может произойти, только если оба потока
в то же самое время проходят низкую метку использования.</p>
<p>14MB более высокая оценка, которая может произойти, только если оба потока
в то же самое время проходят высокую метку использования.</p>

<p>Реальное использование памяти для этой учетной записи, возможно, было в
диапазоне от 11.5MB до 13.5MB.</p>
<p>Для планирования мощностей, сообщение о худшем случае фактически желаемое
поведение, поскольку это показывает то, что может потенциально произойти,
когда сеансы являются некоррелироваными, что, как правило, имеет место.</p>

<h4><a name="error-summary-tables"></a>23.9.15.10. Сводные таблицы ошибок</h4>
<p>Performance Schema поддерживает сводные таблицы для того, чтобы соединить
статистическую информацию об ошибках и предупреждениях сервера. Для списка
ошибок сервера см. <a href="error.htm#error-messages-server">раздел B.3</a>.
</p>

<p>Сбором информации об ошибке управляет инструмент <code>error</code>,
который включен по умолчанию. Информация синхронизации не собрана.</p>
<p>У каждой сводной таблицы есть три столбца, которые идентифицируют ошибку:
</p>

<ul><li><p><code>ERROR_NUMBER</code> числовое значение
ошибки. Значение уникально.</li>
<li><code>ERROR_NAME</code> символическое имя, соответствующее
<code>ERROR_NUMBER</code>. Значение уникально.</li>
<li><code>SQLSTATE</code> значение SQLSTATE, соответствующее
<code>ERROR_NUMBER</code>. Значение не обязательно уникально.</p></li></ul>

<p>Например, если <code>ERROR_NUMBER</code> 1050, <code>ERROR_NAME</code>
<a href="error.htm#error_er_table_exists_error"><code>ER_TABLE_EXISTS_ERROR
</code></a> и <code>SQLSTATE</code> <code>42S01</code>.</p>

<p>Информация о резюме событий в качестве примера:
<pre>
mysql&gt; SELECT * FROM events_errors_summary_global_by_error
                   WHERE SUM_ERROR_RAISED &lt;&gt; 0\G
*************************** 1. row ***************************
 ERROR_NUMBER: 1064
 ERROR_NAME: ER_PARSE_ERROR
  SQL_STATE: 42000
 SUM_ERROR_RAISED: 1
SUM_ERROR_HANDLED: 0
 FIRST_SEEN: 2016-06-28 07:34:02
  LAST_SEEN: 2016-06-28 07:34:02
*************************** 2. row ***************************
 ERROR_NUMBER: 1146
 ERROR_NAME: ER_NO_SUCH_TABLE
  SQL_STATE: 42S02
 SUM_ERROR_RAISED: 2
SUM_ERROR_HANDLED: 0
 FIRST_SEEN: 2016-06-28 07:34:05
  LAST_SEEN: 2016-06-28 07:36:18
*************************** 3. row ***************************
 ERROR_NUMBER: 1317
 ERROR_NAME: ER_QUERY_INTERRUPTED
  SQL_STATE: 70100
 SUM_ERROR_RAISED: 1
SUM_ERROR_HANDLED: 0
 FIRST_SEEN: 2016-06-28 11:01:49
  LAST_SEEN: 2016-06-28 11:01:49
</pre>

<p>У каждой сводной таблицы есть один или более группирующихся столбцов,
чтобы указать как табличные ошибки объединяются:</p>
<ul><li><p><a href="#error-summary-tables"><code>
events_errors_summary_by_account_by_error</code></a> имеет столбцы
<code>USER</code>, <code>HOST</code> и <code>ERROR_NUMBER</code>.
Каждая строка суммирует события для сделанного отчета (комбинация
пользователя и узла) и ошибки.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_by_host_by_error</code></a> имеет столбцы
<code>HOST</code> и <code>ERROR_NUMBER</code>.
Каждая строка суммирует события для данного узла и ошибки.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_by_thread_by_error</code></a> имеет столбцы
<code>THREAD_ID</code> и <code>ERROR_NUMBER</code>.
Каждая строка суммирует события для данного потока и ошибки.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_by_user_by_error</code></a> имеет столбцы
<code>USER</code> и <code>ERROR_NUMBER</code>.
Каждая строка суммирует события для данного пользователя и ошибки.</li>

<li><a href="#error-summary-tables"><code>
events_errors_summary_global_by_error</code></a> имеет столбец
<code>ERROR_NUMBER</code>. Каждая строка суммирует события для данной ошибки.
</p></li></ul>

<p>У каждой сводной таблицы есть эти сводные столбцы,
содержащие соединенные значения:</p>
<ul><li><p><code>SUM_ERROR_RAISED</code></p>
<p>Этот столбец показывает, сколько раз ошибка произошла.</li>

<li><code>SUM_ERROR_HANDLED</code></p>
<p>Этот столбец показывает, сколько раз
ошибка была обработана обработчиком исключения SQL.</li>

<li><code>FIRST_SEEN</code>, <code>LAST_SEEN</code></p>
<p>Timestamp, указывающий, когда ошибка была замечена в
первый и в последний раз.</p></li></ul>

<p>Строка <code>NULL</code> в каждой сводной таблице нужна для
совокупной статистики для всех ошибок, которые лежат вне диапазона
инструментованных ошибок. Например, если ошибки MySQL Server
находятся в диапазоне от <em><code>M</code></em> до
<em><code>N</code></em> и ошибка поднята с номером
<em><code>Q</code></em> не в этом диапазоне, ошибка показана в строке
<code>NULL</code>. Это строка с <code>ERROR_NUMBER=0</code>,
<code>ERROR_NAME=NULL</code> и <code>SQLSTATE=NULL</code>.</p>

<p>Сводные таблицы ошибок имеют индексы:</p>
<ul><li><p><a href="#error-summary-tables"><code>
events_errors_summary_by_account_by_error</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>HOST</code>, <code>ERROR_NUMBER</code>).</p></li></ul></li>

<li><p><a href="#error-summary-tables"><code>
events_errors_summary_by_host_by_error</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>,
<code>ERROR_NUMBER</code>).</p></li></ul></li>

<li><p><a href="#error-summary-tables"><code>
events_errors_summary_by_thread_by_error</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>,
<code>ERROR_NUMBER</code>).</p></li></ul></li>

<li><p><a href="#error-summary-tables"><code>
events_errors_summary_by_user_by_error</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>ERROR_NUMBER</code>).</p></li></ul></li>

<li><p><a href="#error-summary-tables"><code>
events_errors_summary_global_by_error</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>ERROR_NUMBER</code>).
</p></li></ul></li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> позволен
на сводных таблицах ошибок. Это имеет эффекты:</p>
<ul><li><p>Для сводных таблиц, не соединенных учетной записью, узлом или
пользователем, усечение сбрасывает сводные столбцы к нолю или
<code>NULL</code> вместо того, чтобы удалять строки.</li>

<li>Для сводных таблиц, соединенных учетной записью, узлом или пользователем,
усечение удаляет строки для учетных записей, узлов или пользователей без
соединений и сбрасывает сводные столбцы к нолю или <code>NULL</code>
для остающихся строк.</p></li></ul>

<p>Кроме того, каждая сводная таблица, которая соединена учетной записью,
узлом, пользователем или потоком, является неявно усеченной усечением таблицы
соединения, от которой зависит, или усечением
<a href="#error-summary-tables">
<code>events_errors_summary_global_by_error</code></a>. Детали в
<a href="#performance-schema-connection-tables">разделе 23.9.8</a>.
</p>

<h4><a name="performance-schema-status-variable-summary-tables"></a>
23.9.15.11. Сводные таблицы переменных состояния</h4>
<p>Значение системной переменной
<a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56</code></a> затрагивает информацию, доступную из
таблиц, описанных здесь. Для деталей см. описание этой переменной в
<a href="server.htm#server-system-variables">разделе 6.1.5</a>.</p>

<p>Performance Schema делает доступной информацию о переменных
состояния в таблицах, описанных в
<a href="#performance-schema-status-variable-tables">разделе
23.9.14</a>. Это также делает соединенную информацию о переменной состояния
доступной в сводных таблицах, описанных здесь. У каждой сводной таблицы
переменной состояния есть один или более группирующихся столбцов, чтобы
указать, как таблица агрегирует переменные:</p>

<ul><li><p><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_account</code></a> имеет столбцы
<code>USER</code>, <code>HOST</code> и <code>VARIABLE_NAME</code>,
чтобы суммировать переменные состояния учетной записью.</li>

<li><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_host</code></a> имеет столбцы
<code>HOST</code> и <code>VARIABLE_NAME</code>, чтобы суммировать переменные
состояния узлом, от которого соединялись клиенты.</li>

<li><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_user</code></a> имеет столбцы
<code>USER</code> и <code>VARIABLE_NAME</code>, чтобы суммировать переменные
состояния именем пользователя клиента.</p></li></ul>

<p>У каждой сводной таблицы переменных состояния есть этот сводный столбец,
содержащий соединенные значения:</p>
<ul><li><p><code>VARIABLE_VALUE</code></p>
<p>Соединенное значение переменной состояния для
активных и законченных сеансов.</p></li></ul>

<p>Сводные таблицы переменной состояния имеют индексы:</p>
<ul><li><p><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_account</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>HOST</code>, <code>VARIABLE_NAME</code>).</p></li></ul></li>

<li><p><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_host</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>HOST</code>,
<code>VARIABLE_NAME</code>).</p></li></ul></li>

<li><p><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_user</code></a>:</p>
<ul><li><p>Первичный ключ на (<code>USER</code>,
<code>VARIABLE_NAME</code>).</p></li></ul></li></ul>

<p>Смысл <span>account</span> в этих таблицах подобно его значению в таблицах
привилегий MySQL системной базы данных <code>mysql</code>,
в том смысле, что термин относится к комбинации значений узла и пользователя.
Они отличаются тем, что для таблиц привилегий часть узла учетной записи может
быть образцом, тогда как для Performance Schema значение узла всегда
определенное имя хоста.</p>

<p>Состояние учетной записи собрано, когда сеансы заканчиваются.
Счетчики состояния сеанса добавлены к глобальным счетчикам состояния и
соответствующим счетчикам состояния учетной записи. Если статистические
данные учетной записи не собраны, состояние сеанса добавлено к состояниям
хоста и пользователя, если узел и пользовательское состояние собираются.</p>

<p>Учетная запись, узел и пользовательская статистика не собраны, если
переменные <a href="#sysvar_performance_schema_accounts_size">
<code>performance_schema_accounts_size</code></a>,
<a href="#sysvar_performance_schema_hosts_size"><code>
performance_schema_hosts_size</code></a> и
<a href="#sysvar_performance_schema_users_size"><code>
performance_schema_users_size</code></a>, соответственно, установлены в 0.
</p>

<p>Performance Schema поддерживает <a href="sql.htm#truncate-table"><code>
TRUNCATE TABLE</code></a> для сводных таблиц переменных состояния следующим
образом, во всех случаях состояние для активных сеансов не затронуто:</p>

<ul><li><p><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_account</code></a>: Совокупности считают состояние от
законченных сеансов до пользователя и размещают состояние, затем сбрасывает
состояние учетной записи.</li>

<li><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_host</code></a>:
Сброс состояний узла от законченных сеансов.</li>

<li><a href="#performance-schema-status-variable-summary-tables">
<code>status_by_user</code></a>:
Сброс состояний пользователя от законченных сеансов.</p></li></ul>

<p><a href="sql.htm#flush"><code>FLUSH STATUS</code></a>
добавляет состояние сеанса от всех активных сеансов к глобальным переменным
состояния, сбрасывает состояние всех активных сеансов и сбрасывает учетную
запись, узел и пользовательские значения состояния от разъединенных сеансов.
</p>

<h3><a name="performance-schema-miscellaneous-tables"></a>23.9.16.
Прочие таблицы Performance Schema</h3>
<p>Следующие разделы описывают таблицы, которые не попадают в табличные
категории, обсужденные в предыдущих разделах:</p>

<ul><li><p><a href="#host-cache-table"><code>host_cache</code></a>:
Информация от внутреннего кэша узла.</li>
<li><a href="#performance-timers-table"><code>performance_timers
</code></a>: Какие таймеры событий доступны.</li>
<li><a href="#threads-table"><code>threads</code></a>:
Информация о потоках сервера.</p></li></ul>

<h4><a name="host-cache-table"></a>23.9.16.1. Таблица host_cache</h4>
<p>Таблица <a href="#host-cache-table"><code>host_cache</code></a>
обеспечивает доступ к содержанию кэша узла, который содержит имя хоста
клиента и информацию об IP-адресе и используется, чтобы избежать поисков DNS
(см. <a href="optimiz.htm#host-cache"> раздел 9.12.4.2</a>).
<a href="#host-cache-table"><code>host_cache</code></a>
выставляет содержание кэша узла так, чтобы это могло быть исследовано,
используя <a href="sql.htm#select"><code>SELECT</code></a>. Performance
Schema должна быть включена, или эта таблица пуста.</p>

<p>У <a href="#host-cache-table"><code>host_cache</code></a>
есть эти столбцы:</p>
<ul><li><p><code>IP</code></p>
<p>IP-адрес клиента, который соединялся с сервером, выраженный как строка.
</li>

<li><code>HOST</code></p>
<p>Имя хоста DNS для IP клиента или <code>NULL</code>,
если имя неизвестно.</li>

<li><code>HOST_VALIDATED</code></p>
<p>Было ли разрешение DNS "имя к IP" или "IP к узлу" выполнено успешно для
IP клиента. Если <code>HOST_VALIDATED</code> = <code>YES</code>,
<code>HOST</code> используется в качестве имени хоста, соответствующего IP
так, чтобы вызовов DNS можно было избежать. В то время, как
<code>HOST_VALIDATED</code> = <code>NO</code>, разрешение DNS
предпринято снова для каждого соединения, пока оно в конечном счете не
завершается с допустимым результатом или с постоянной ошибкой.
Эта информация позволяет серверу избежать плохого кэширования или пропуска
имени хоста во время временных отказов DNS, которые затронули
бы клиентов навсегда.</li>

<li><code>SUM_CONNECT_ERRORS</code></p>
<p>Число ошибок соединения, которые считаются
<span>blocking</span> (оценены относительно переменной
<a href="server.htm#sysvar_max_connect_errors"><code>max_connect_errors
</code></a>). Только ошибки квитирования протокола посчитаны и только для
узлов, которые передали проверку допустимости
(<code>HOST_VALIDATED = YES</code>).</li>

<li><code>COUNT_HOST_BLOCKED_ERRORS</code></p>
<p>Число соединений, которые были заблокированы потому, что
<code>SUM_CONNECT_ERRORS</code> превышает значение переменной
of the <a href="server.htm#sysvar_max_connect_errors"><code>
max_connect_errors</code></a>.</li>

<li><code>COUNT_NAMEINFO_TRANSIENT_ERRORS</code></p>
<p>Число переходных ошибок во время разрешения DNS IP к имени хоста.</li>
<li><code>COUNT_NAMEINFO_PERMANENT_ERRORS</code></p>
<p>Число постоянных ошибок во время разрешения DNS IP к имени хоста.</li>

<li><code>COUNT_FORMAT_ERRORS</code></p>
<p>Число ошибок формата имени хоста. MySQL не выполняет соответствие
значения столбцов <code>Host</code> в <code>mysql.user</code>
именам хоста, для которых один или больше начальных компонентов имени
являются полностью числовыми (<code>1.2.example.com</code>).
IP-адрес клиента используется вместо этого. Для объяснения, почему этот тип
соответствия не происходит, см. <a href="security.html#account-names">раздел
7.2.3</a>.</li>

<li><code>COUNT_ADDRINFO_TRANSIENT_ERRORS</code></p>
<p>Число переходных ошибок во время разрешения DNS имени хоста к IP.</li>
<li><code>COUNT_ADDRINFO_PERMANENT_ERRORS</code></p>
<p>Число постоянных ошибок во время разрешения DNS имени хоста к IP.</li>

<li><code>COUNT_FCRDNS_ERRORS</code></p>
<p>Число передовых подтвержденных обратных ошибок DNS. Эти ошибки
происходят, когда разрешение DNS производит IP-адрес, который не
соответствует клиенту, порождающему IP-адрес.</li>

<li><code>COUNT_HOST_ACL_ERRORS</code></p>
<p>Число ошибок, которые происходят, потому что никакой пользователь с хоста
клиента не может возможно войти в систему. В таких случаях сервер
возвращает <a href="error.htm#error_er_host_not_privileged"><code>
ER_HOST_NOT_PRIVILEGED</code></a> и даже не просит имя
пользователя или пароль.</li>

<li><code>COUNT_NO_AUTH_PLUGIN_ERRORS</code></p>
<p>Число ошибок из-за запросов о недоступном плагине аутентификации. Плагин
может быть недоступным, если, например, он никогда не загружался, или
попытка загрузки провалилась.</li>

<li><code>COUNT_AUTH_PLUGIN_ERRORS</code></p>
<p>Число ошибок, сообщенных плагинами аутентификации.</p>
<p>Плагин аутентификации может сообщить, различные коды ошибки, которые
указывают на первопричину отказа. В зависимости от типа ошибки увеличен один
из этих столбцов: <code>COUNT_AUTHENTICATION_ERRORS</code>,
<code>COUNT_AUTH_PLUGIN_ERRORS</code>,
<code>COUNT_HANDSHAKE_ERRORS</code>. Новые коды возвращения это
дополнительное расширение к существующему API. Неизвестные или неожиданные
ошибки включены в столбец <code>COUNT_AUTH_PLUGIN_ERRORS</code>.</li>

<li><code>COUNT_HANDSHAKE_ERRORS</code></p>
<p>Число ошибок обнаружено на проводном уровне протокола.</li>
<li><code>COUNT_PROXY_USER_ERRORS</code></p>
<p>Число ошибок обнаружило, когда proxy-пользователь A передает доступ
другому пользователю B, который не существует.</li>

<li><code>COUNT_PROXY_USER_ACL_ERRORS</code></p>
<p>Число ошибок, когда proxy-пользователь A передает доступ другому
пользователю B, который действительно существует, но для кого A не имеет
привилегии <a href="security.html#priv_proxy"><code>PROXY</code></a>.</li>

<li><code>COUNT_AUTHENTICATION_ERRORS</code></p>
<p>Число ошибок вызвано неудавшейся аутентификацией.</li>
<li><code>COUNT_SSL_ERRORS</code></p>
<p>Число ошибок из-за проблем SSL.</li>

<li><code>COUNT_MAX_USER_CONNECTIONS_ERRORS</code></p>
<p>Число ошибок вызвано превышением доли соединения в расчёте на
пользователя. См. <a href="security.html#user-resources">раздел 7.3.5</a>.
</li>

<li><code>COUNT_MAX_USER_CONNECTIONS_PER_HOUR_ERRORS</code></p>
<p>Число ошибок вызвано, превышая доли соединений-за-час
в расчёте на пользователя. См.
<a href="security.html#user-resources">раздел 7.3.5</a>.</li>

<li><code>COUNT_DEFAULT_DATABASE_ERRORS</code></p>
<p>Число ошибок, связанных с базой данных по умолчанию. Например, база данных
не существовала, или у пользователя не было никаких привилегий для того,
чтобы получить доступ к ней.</li>

<li><code>COUNT_INIT_CONNECT_ERRORS</code></p>
<p>Число ошибок, вызванных отказами выполнения запросов в
<a href="server.htm#sysvar_init_connect"><code>init_connect</code></a>.</li>

<li><code>COUNT_LOCAL_ERRORS</code></p>
<p>Число ошибок, локальных к выполнению сервера и не связанных с сетью,
аутентификацией или разрешением. Например, условия переполнения памяти
попадают в эту категорию.</li>

<li><code>COUNT_UNKNOWN_ERRORS</code></p>
<p>Число других, неизвестных ошибок, не составляемых другими столбцами в этой
таблице. Этот столбец сохранен для будущего использования, в случае, если о
новых состояниях ошибки нужно сообщить, сохраняя обратную совместимость и
структуру таблицы <a href="#host-cache-table"><code>host_cache
</code></a>.</li>

<li><code>FIRST_SEEN</code></p>
<p>timestamp первой попытки соединения, замеченной
от клиента в <code>IP</code>.</li>

<li><code>LAST_SEEN</code></p>
<p>timestamp последней попытки соединения, замеченной
от клиента в <code>IP</code>.</li>

<li><code>FIRST_ERROR_SEEN</code></p>
<p>timestamp первой ошибки, замеченной от клиента в <code>IP</code>.</li>
<li><code>LAST_ERROR_SEEN</code></p>
<p>timestamp последней ошибки, замеченной от клиента в <code>IP</code>.
</p></li></ul>

<p>У <a href="#host-cache-table"><code>host_cache</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>IP</code>).</li>
<li>Индекс на (<code>HOST</code>).</p></li></ul>

<p><a href="sql.htm#flush"><code>FLUSH HOSTS</code></a> и
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE host_cache</code></a>
имеют тот же самый эффект: они очищают кэш узла. Это также удаляет строки из
<a href="#host-cache-table"><code>host_cache</code></a>
(потому что это видимое представление кэша) и открывает любые заблокированные
узлы (см. <a href="error.htm#blocked-host">раздел B.5.2.5</a>).
<a href="sql.htm#flush"><code>FLUSH HOSTS</code></a> требует привилегии
<a href="security.html#priv_reload"><code>RELOAD</code></a>.
<a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> требует
привилегии <a href="security.html#priv_drop"><code>DROP</code></a> для
<a href="#host-cache-table"><code>host_cache</code></a>.</p>

<h4><a name="performance-timers-table"></a>23.9.16.2.
Таблица performance_timers</h4>
<p><a href="#performance-timers-table"><code>performance_timers
</code></a> показывает, какие таймеры событий доступны:
<pre>
mysql&gt; SELECT * FROM performance_timers;
+-------------+-----------------+------------------+----------------+
| TIMER_NAME  | TIMER_FREQUENCY | TIMER_RESOLUTION | TIMER_OVERHEAD |
+-------------+-----------------+------------------+----------------+
| CYCLE       | 2389029850      | 1                | 72             |
| NANOSECOND  | 1000000000      | 1                | 112            |
| MICROSECOND |    1000000      | 1                | 136            |
| MILLISECOND |       1036      | 1                | 168            |
| TICK        |        105      | 1                | 2416           |
+-------------+-----------------+------------------+----------------+
</pre>

<p>Таймеры в <a href="#setup-timers-table"><code>setup_timers
</code></a>, которые Вы можете использовать, не имеют <code>NULL</code>
в других столбцах. Если значения, связанные с данным именем таймера,
<code>NULL</code>, этот таймер не поддержан на Вашей платформе.</p>

<p>У <a href="#performance-timers-table"><code>performance_timers
</code></a> есть эти столбцы:</p>
<ul><li><p><code>TIMER_NAME</code></p>
<p>Имя, которым можно обратиться к таймеру, конфигурируя
<a href="#setup-timers-table"><code>setup_timers</code></a>.</li>

<li><code>TIMER_FREQUENCY</code></p>
<p>Число модулей таймера в секунду. Для счетчика циклов частота вообще
связана со скоростью центрального процессора. Например, на системе с 2.4GHz
процессором <code>CYCLE</code> может быть близко к 2400000000.</li>

<li><code>TIMER_RESOLUTION</code></p>
<p>Указывает на число модулей таймера, которыми таймер оценивает увеличение.
Если у таймера есть разрешение 10, его значение увеличено на 10 каждый раз.
</li>

<li><code>TIMER_OVERHEAD</code></p>
<p>Минимальное число циклов, чтобы получить одну синхронизацию с данным
таймером. Performance Schema определяет это значение, вызывая таймер 20 раз
во время инициализации и выбирая самое маленькое значение. Общее количество
циклов дважды это количество, потому что инструментовка вызывает таймер в
запуске и конце каждого случая. Код таймера называют только для рассчитанных
событий, таким образом, это не влияет на нерассчитанные события.</li></ul>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#performance-timers-table"><code>
performance_timers</code></a>.</p>

<h4><a name="threads-table"></a>23.9.16.3. Таблица threads</h4>
<p>Таблица <a href="#threads-table"><code>threads</code></a>
содержит строку для каждого потока сервера. Каждая строка содержит информацию
о потоке и указывает, включен ли контроль и журналирование событий:
<pre>
mysql&gt; SELECT * FROM threads\G
*************************** 1. row ***************************
THREAD_ID: 1
   NAME: thread/sql/main
   TYPE: BACKGROUND
 PROCESSLIST_ID: NULL
   PROCESSLIST_USER: NULL
   PROCESSLIST_HOST: NULL
 PROCESSLIST_DB: NULL
PROCESSLIST_COMMAND: NULL
   PROCESSLIST_TIME: 80284
  PROCESSLIST_STATE: NULL
   PROCESSLIST_INFO: NULL
   PARENT_THREAD_ID: NULL
   ROLE: NULL
 INSTRUMENTED: YES
HISTORY: YES
CONNECTION_TYPE: NULL
 THREAD_OS_ID: 489803
...
*************************** 4. row ***************************
THREAD_ID: 51
   NAME: thread/sql/one_connection
   TYPE: FOREGROUND
 PROCESSLIST_ID: 34
   PROCESSLIST_USER: isabella
   PROCESSLIST_HOST: localhost
 PROCESSLIST_DB: performance_schema
PROCESSLIST_COMMAND: Query
   PROCESSLIST_TIME: 0
  PROCESSLIST_STATE: Sending data
   PROCESSLIST_INFO: SELECT * FROM threads
   PARENT_THREAD_ID: 1
   ROLE: NULL
 INSTRUMENTED: YES
HISTORY: YES
CONNECTION_TYPE: SSL/TLS
 THREAD_OS_ID: 755399
...
</pre>

<p>Когда Performance Schema инициализируется, она заполняет
<a href="#threads-table"><code>threads</code></a>, основываясь на
существующих потоках. После этого новая строка добавлена каждый раз, когда
сервер создает поток.</p>

<p>Столбцы <code>INSTRUMENTED</code> и <code>HISTORY</code>
для новых потоков определены содержанием
<a href="#setup-actors-table"><code>setup_actors</code></a>.
Для информации о том, как использовать
<a href="#setup-actors-table"><code>setup_actors</code></a>, чтобы
управлять этими столбцами, см.
<a href="#performance-schema-thread-filtering">раздел 23.2.3.6</a>.
</p>

<p>Удаление строк из <a href="#threads-table"><code>threads</code>
</a> происходит, когда потоки заканчиваются. Для потока, связанного с сеансом
клиента, происходит удаление, когда сеанс заканчивается. Если клиент имеет
включенную опцию auto-reconnect, и сеанс повторно соединяется после
разъединения, то этот сеанс становится связанным с новой строкой в
<a href="#threads-table"><code>threads</code></a>, у которой есть
другой <code>PROCESSLIST_ID</code>. Значения <code>INSTRUMENTED</code> и
<code>HISTORY</code> для нового потока
могут отличаться от таковых из оригинального потока:
<a href="#setup-actors-table"><code>setup_actors</code></a>,
возможно, изменилась тем временем, и если
<code>INSTRUMENTED</code> или <code>HISTORY</code>
для оригинального потока было изменено после того, как строка была
инициализирована, изменение не переносится на новый поток.</p>

<p>Столбцы таблицы <a href="#threads-table"><code>threads</code>
</a> с именами, имеющими приставку <code>PROCESSLIST_</code>,
предоставляют информацию, подобную доступной из
<a href="inform.htm#processlist-table"><code>INFORMATION_SCHEMA.PROCESSLIST
</code></a> или <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a>. Таким образом, все три источника предоставляют контролирующую
поток информацию. Использование
<a href="#threads-table"><code>threads</code></a>
отличается от использования других двух источников:</p>

<ul><li><p>Доступ к <a href="#threads-table"><code>threads</code>
</a> не требует mutex и оказывает минимальное влияние на работу сервера.
<a href="inform.htm#processlist-table"><code>INFORMATION_SCHEMA.PROCESSLIST
</code></a> и <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a> имеют отрицательные исполнительные последствия, потому что
они требуют mutex.</li>

<li><a href="#threads-table"><code>threads</code></a>
обеспечивает дополнительную информацию для каждого потока, такую как является
ли это фоновым потоком и местоположение в пределах
сервера, связанное с потоком.</li>

<li><a href="#threads-table"><code>threads</code></a>
предоставляет информацию о фоновых потоках, таким образом, она может
использоваться, чтобы контролировать деятельность, чего другие источники
информации о потоке не могут.</li>

<li>Вы можете включить или отключить контроль потока (то есть,
инструментованы ли события, запущенные потоком и журналирование событий.
Чтобы управлять начальным состоянием
<code>INSTRUMENTED</code> и <code>HISTORY</code>
для новых потоков переднего плана, используйте
<a href="#setup-actors-table"><code>setup_actors</code></a>.
Чтобы управлять этими аспектами существующих потоков, установите столбцы
<code>INSTRUMENTED</code> и <code>HISTORY</code> строк таблицы
<a href="#threads-table"><code>threads</code></a>.</p></li></ul>

<p>По этим причинам, DBA выполняет контроль сервера, используя
<a href="inform.htm#processlist-table"><code>INFORMATION_SCHEMA.PROCESSLIST
</code></a> или <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a> и может хотеть контролировать, используя вместо этого
<a href="#threads-table"><code>threads</code></a>.</p>

<p>Для <a href="inform.htm#processlist-table"><code>
INFORMATION_SCHEMA.PROCESSLIST</code></a>
и <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
информацию о потоках для других пользователей показывают, только если текущий
пользователь имеет привилегию
<a href="security.html#priv_process"><code>PROCESS</code></a>.
Это не так для таблицы <a href="#threads-table"><code>threads
</code></a>: все строки показывают любому пользователю, который имеет
привилегию <code>SELECT</code> для таблицы. Пользователям, которые не должны
быть в состоянии видеть потоки для других пользователей, нельзя
давать эту привилегию.</p>

<p>У <a href="#threads-table"><code>threads</code></a>
есть эти столбцы:</p>
<ul><li><p><code>THREAD_ID</code></p>
<p>Уникальный идентификатор потока.</li>

<li><code>NAME</code></p>
<p>Имя, связанное с кодом инструментовки потока в сервере. Например,
<code>thread/sql/one_connection</code> соответствует функции потока в коде,
ответственном за обработку пользовательского соединения, а
<code>thread/sql/main</code> для функции <code>main()</code> сервера.</li>

<li><code>TYPE</code></p>
<p>Тип потока: <code>FOREGROUND</code> или <code>BACKGROUND</code>.
Пользовательские потоки соединения это потоки переднего плана. Потоки,
связанные с внутренней деятельностью сервера, являются фоновыми потоками.
</li>

<li><code>PROCESSLIST_ID</code></p>
<p>Для потоков, которые выведены на экран в
<a href="inform.htm#processlist-table"><code>INFORMATION_SCHEMA.PROCESSLIST
</code></a> это значение столбца <code>ID</code> этой таблицы.
Это также значение, выведенное на экран в столбце <code>Id</code> вывода
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a> и
значение, возвращаемое функцией <a href="funct.htm#function_connection-id">
<code>CONNECTION_ID()</code></a> для потока.</p>

<p>Для фоновых потоков (потоки, не связанные с пользовательским соединением),
<code>PROCESSLIST_ID</code> <code>NULL</code>,
таким образом, значения не уникальны.</li>

<li><code>PROCESSLIST_USER</code></p>
<p>Пользователь, связанный с потоком переднего плана, <code>NULL</code>
для фонового потока.</li>

<li><code>PROCESSLIST_HOST</code></p>
<p>Имя хоста клиента, связанного с потоком переднего плана,
<code>NULL</code> для фонового потока.</p>

<p>В отличие от столбца <code>HOST</code> в <code>INFORMATION_SCHEMA</code>,
<a href="inform.htm#processlist-table"><code>PROCESSLIST</code></a> или
столбец <code>Host</code> вывода
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>,
столбец <code>PROCESSLIST_HOST</code> не включает номер порта для соединений
TCP/IP. Чтобы получить эту информацию из Performance Schema,
включите инструментовку сокета (которая не включена по умолчанию) и
исследуйте таблицу <a href="#socket-instances-table"><code>
socket_instances</code></a>:
<pre>
mysql&gt; SELECT * FROM setup_instruments WHERE NAME LIKE 'wait/io/socket%';
+----------------------------------------+---------+-------+
| NAME                                   | ENABLED | TIMED |
+----------------------------------------+---------+-------+
| wait/io/socket/sql/server_tcpip_socket | NO      | NO    |
| wait/io/socket/sql/server_unix_socket  | NO      | NO    |
| wait/io/socket/sql/client_connection   | NO      | NO    |
+----------------------------------------+---------+-------+
3 rows in set (0.01 sec)

mysql&gt; UPDATE setup_instruments SET ENABLED='YES'
                 WHERE NAME LIKE 'wait/io/socket%';
Query OK, 3 rows affected (0.00 sec)
Rows matched: 3  Changed: 3  Warnings: 0

mysql&gt; SELECT * FROM socket_instances\G
*************************** 1. row ***************************
 EVENT_NAME: wait/io/socket/sql/client_connection
OBJECT_INSTANCE_BEGIN: 140612577298432
THREAD_ID: 31
SOCKET_ID: 53
 IP: ::ffff:127.0.0.1
 PORT: 55642
STATE: ACTIVE
...
</pre></li>

<li><code>PROCESSLIST_DB</code></p>
<p>База данных значения по умолчанию для потока или
<code>NULL</code>, если нет.</li>

<li><code>PROCESSLIST_COMMAND</code></p>
<p>Для потоков переднего плана команда выполняется от имени клиента или
<code>Sleep</code>, если сессия спит. Для описаний команд потока см.
<a href="optimiz.htm#thread-information">раздел 9.14</a>.
Значение этого столбца соответствует командам
<code>COM_<em><code>xxx</code></em></code> протокола клиент-сервер и
переменным состояния <code>Com_<em><code>xxx</code></em></code>. См.
<a href="server.htm#server-status-variables">раздел 6.1.7</a>.</p>

<p>Фоновые потоки не выполняют команды от имени клиентов, таким образом,
этот столбец может быть <code>NULL</code>.</li>
<li><code>PROCESSLIST_TIME</code></p>
<p>Время в секундах, которое поток был в его текущем состоянии.</li>

<li><code>PROCESSLIST_STATE</code></p>
<p>Действие, случай или состояние, которое указывает на то, что делает поток.
Для описания значений <code>PROCESSLIST_STATE</code> см.
<a href="optimiz.htm#thread-information">раздел 9.14</a>. Если значение
<code>NULL</code>, поток может соответствовать неактивному сеансу клиента,
или работа, которую он делает, не инструментована с этапами.</p>
<p>Большинство состояний соответствует очень быстрым операциям. Если поток
остается в данном статусе в течение многих секунд, может быть проблема.</li>

<li><code>PROCESSLIST_INFO</code></p>
<p>Запрос, который поток выполняет, или <code>NULL</code>,
если это не выполняет запросы. Запрос мог быть послан в сервер или внутренним
запросом, если запрос выполняет другие запросы. Например, если
<code>CALL</code> выполняет хранимую процедуру, которая выполняет
<a href="sql.htm#select"><code>SELECT</code></a>, значение
<code>PROCESSLIST_INFO</code> показывает запрос
<a href="sql.htm#select"><code>SELECT</code></a>.</li>

<li><code>PARENT_THREAD_ID</code></p>
<p>Если этот поток подпоток (порожденный другим потоком), это
<code>THREAD_ID</code> основного потока.</li>

<li><code>ROLE</code></p>
<p>Не используется.</li>
<li><code>INSTRUMENTED</code></p>
<p>Инструментованы ли события, запущенные потоком.
Значения <code>YES</code> или <code>NO</code>.</p>

<ul><li><p>Для потоков переднего плана, начальное значение
<code>INSTRUMENTED</code> определено тем, соответствует ли учетная запись
пользователя, связанная с потоком, какой-либо строке в
<a href="#setup-actors-table"><code>setup_actors</code></a>.
Соответствие основано на значениях
<code>PROCESSLIST_USER</code> и <code>PROCESSLIST_HOST</code>.</p>

<p>Если поток порождает подпоток, соответствие происходит снова для
строки таблицы <a href="#threads-table"><code>threads</code></a>,
созданной для подпотока.</li>

<li>Для фоновых потоков <code>INSTRUMENTED</code> <code>YES</code>
по умолчанию. <a href="#setup-actors-table"><code>setup_actors
</code></a> не консультируется, потому что нет никакого связанного
пользователя для фоновых потоков.</li>
<li>Для любого потока значение <code>INSTRUMENTED</code>
может быть изменено во время жизни потока.</p></li></ul>

<p>Для того, чтобы контролировать события, запущенные потоком, эти вещи
должны быть истиной:</p>
<ul><li><p>Потребитель <code>thread_instrumentation</code> в
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
должен быть <code>YES</code>.</li>

<li>Столбец <code>threads.INSTRUMENTED</code> должен быть <code>YES</code>.
</li>
<li>Контроль происходит только для событий потока, произведенных из
инструментов, которые имеют столбец <code>ENABLED</code> <code>YES</code> в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p></li></ul></li>

<li><p><code>HISTORY</code></p>
<p>Зарегистрировать ли исторические события для потока. Значения
<code>YES</code> или <code>NO</code>.</p>

<ul><li><p>Для потоков переднего плана, начальное значение
<code>HISTORY</code> определено тем, соответствует ли учетная запись
пользователя, связанная с потоком, какой-либо строке в
<a href="#setup-actors-table"><code>setup_actors</code></a>.
Соответствие основано на значениях
<code>PROCESSLIST_USER</code> и <code>PROCESSLIST_HOST</code>.</p>

<p>Если поток порождает подпоток, соответствие происходит снова для
строки таблицы <a href="#threads-table"><code>threads</code></a>,
созданной для подпотока.</li>

<li>Для фоновых потоков <code>HISTORY</code> <code>YES</code> по умолчанию.
<a href="#setup-actors-table"><code>setup_actors</code></a>
не консультируется, потому что нет никакого связанного пользователя
для фоновых потоков.</li>
<li>Для любого потока значение <code>HISTORY</code>
может быть изменено во время жизни потока.</p></li></ul>

<p>Для журналирования исторического события для потока, эти вещи
должны быть истиной:</p>
<ul><li><p>Соответствующие связанные с историей потребители в
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
должны быть включены. Например, случай ожидания, протоколируемый в
таблицах <a href="#events-waits-history-table"><code>
events_waits_history</code></a> и
<a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a> требует соответствующих потребителй
<code>events_waits_history</code> и
<code>events_waits_history_long</code> в <code>YES</code>.</li>
<li>Столбец <code>threads.HISTORY</code> должен быть <code>YES</code>.</li>

<li>Журналирование происходит только для событий потока,
произведенных из инструментов, которые имеют
<code>ENABLED</code> <code>YES</code> в
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>.</p></li></ul></li>

<li><p><code>CONNECTION_TYPE</code></p>
<p>Протокол, по которому установлено соединение, или
<code>NULL</code> для фоновых потоков. Разрешенные значения:
<code>TCP/IP</code> (соединение TCP/IP, установленное без SSL),
<code>SSL/TLS</code> (соединение TCP/IP, установленное с SSL),
<code>Socket</code> (соединение файла сокета Unix),
<code>Named Pipe</code> (соединение канала Windows) и <code>Shared Memory
</code> (соединение совместно используемой памяти Windows).</li>

<li><code>THREAD_OS_ID</code></p>
<p>Поток или идентификатор задачи как определено основной операционной
системой, если есть:</p>

<ul><li><p>Когда поток MySQL связан с тем же самым потоком операционной
системы, <code>THREAD_OS_ID</code> содержит ID потока операционной системы.
</li>

<li>Когда поток MySQL не связан с тем же самым потоком операционной системы,
<code>THREAD_OS_ID</code> <code>NULL</code>.
Это типично для пользовательских сеансов, когда плагин потока используется
(см. <a href="../../../dev.mysql.com/doc/refman/5.7/en/thread-pool.html"
target="_top">MySQL Enterprise Thread Pool</a>).</p></li></ul>

<p>Для Windows <code>THREAD_OS_ID</code> соответствует ID потока,
видимому в Process Explorer
(<a href="../../../https@technet.microsoft.com/en-us/sysinternals/bb896653.aspx"
target="_top">https://technet.microsoft.com/en-us/sysinternals/bb896653.aspx
</a>).</p>

<p>Для Linux <code>THREAD_OS_ID</code> соответствует значению
функции <code>gettid()</code>. Это значение выставлено, например, используя
команды <span><strong>perf</strong></span> или <span><strong>ps -L</strong>
</span> или в файловой системе <code>proc</code>
(<code>/proc/<em><code>[pid]</code></em>/task/<em><code>[tid]</code></em>
</code>). Для получения дополнительной информации см.
<code>perf-stat(1)</code>, <code>ps(1)</code> и <code>proc(5)</code>.
</p></li></ul>

<p>У <a href="#threads-table"><code>threads</code></a>
есть эти индексы:</p>
<ul><li><p>Первичный ключ на (<code>THREAD_ID</code>).</li>
<li>Индекс на (<code>NAME</code>).</li>
<li>Индекс на (<code>PROCESSLIST_ID</code>).</li>
<li>Индекс на (<code>PROCESSLIST_USER</code>,
<code>PROCESSLIST_HOST</code>).</li>
<li>Индекс на (<code>PROCESSLIST_HOST</code>).</li>
<li>Индекс на (<code>THREAD_OS_ID</code>).</p></li></ul>
<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a> не
позволен для <a href="#threads-table"><code>threads</code></a>.</p>

<h2><a name="performance-schema-option-variable-reference"></a>23.10.
Обзор опций и переменных Performance Schema</h2>
<p><b>Таблица 23.3. Обзор переменных Performance Schema</b></p>
<table border="1">
<thead><tr><th scope="col">Имя</th><th scope="col">Cmd-Line</th>
<th scope="col">Файл опций</th><th scope="col">Системная</th>
<th scope="col">Статусная</th><th scope="col">Область действия</th>
<th scope="col">Динамическая</th></tr></thead>
<tbody><tr><td scope="row"><a href="#sysvar_performance_schema">
performance_schema</a></td><td>Да</td><td>Да</td><td>Да</td><td> </td>
<td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_accounts_lost">
Performance_schema_accounts_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_accounts_size">
performance_schema_accounts_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_cond_classes_lost">
Performance_schema_cond_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_cond_instances_lost">
Performance_schema_cond_instances_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-stages-current">
performance-schema-consumer-events-stages-current</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-stages-history">
performance-schema-consumer-events-stages-history</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-stages-history-long">
performance-schema-consumer-events-stages-history-long</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-statements-current">
performance-schema-consumer-events-statements-current</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-statements-history">
performance-schema-consumer-events-statements-history</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-statements-history-long">
performance-schema-consumer-events-statements-history-long</a></td>
<td>Да</td><td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-transactions-current">
performance-schema-consumer-events-transactions-current</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-transactions-history">
performance-schema-consumer-events-transactions-history</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-transactions-history-long">
performance-schema-consumer-events-transactions-history-long</a></td>
<td>Да</td><td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-waits-current">
performance-schema-consumer-events-waits-current</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-waits-history">
performance-schema-consumer-events-waits-history</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-events-waits-history-long">
performance-schema-consumer-events-waits-history-long</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-global-instrumentation">
performance-schema-consumer-global-instrumentation</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-statements-digest">
performance-schema-consumer-statements-digest</a></td><td>Да</td><td>Да</td>
<td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-consumer-thread-instrumentation">
performance-schema-consumer-thread-instrumentation</a></td><td>Да</td>
<td>Да</td><td> </td><td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_digest_lost">
Performance_schema_digest_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_digests_size">
performance_schema_digests_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_stages_history_long_size">
performance_schema_events_stages_history_long_size</a></td><td>Да</td>
<td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_stages_history_size">
performance_schema_events_stages_history_size</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_statements_history_long_size">
performance_schema_events_statements_history_long_size</a></td><td>Да</td>
<td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_statements_history_size">
performance_schema_events_statements_history_size</a></td><td>Да</td>
<td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_transactions_history_long_size">
performance_schema_events_transactions_history_long_size</a></td><td>Да</td>
<td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_transactions_history_size">
performance_schema_events_transactions_history_size</a></td><td>Да</td>
<td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_waits_history_long_size">
performance_schema_events_waits_history_long_size</a></td><td>Да</td>
<td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_events_waits_history_size">
performance_schema_events_waits_history_size</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_file_classes_lost">
Performance_schema_file_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_file_handles_lost">
Performance_schema_file_handles_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_file_instances_lost">
Performance_schema_file_instances_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_hosts_lost">
Performance_schema_hosts_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_hosts_size">
performance_schema_hosts_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#option_mysqld_performance-schema-instrument">
performance-schema-instrument</a></td><td>Да</td><td>Да</td><td> </td>
<td> </td><td> </td><td> </td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_locker_lost">
Performance_schema_locker_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_cond_classes">
performance_schema_max_cond_classes</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_cond_instances">
performance_schema_max_cond_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_digest_length">
performance_schema_max_digest_length</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_file_classes">
performance_schema_max_file_classes</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_file_handles">
performance_schema_max_file_handles</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_file_instances">
performance_schema_max_file_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_memory_classes">
performance_schema_max_memory_classes</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_metadata_locks">
performance_schema_max_metadata_locks</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_mutex_classes">
performance_schema_max_mutex_classes</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_mutex_instances">
performance_schema_max_mutex_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_prepared_statements_instances">
performance_schema_max_prepared_statements_instances</a></td><td>Да</td>
<td>Да</td><td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_program_instances">
performance_schema_max_program_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_rwlock_classes">
performance_schema_max_rwlock_classes</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_rwlock_instances">
performance_schema_max_rwlock_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_socket_classes">
performance_schema_max_socket_classes</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_socket_instances">
performance_schema_max_socket_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_stage_classes">
performance_schema_max_stage_classes</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_statement_classes">
performance_schema_max_statement_classes</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_statement_stack">
performance_schema_max_statement_stack</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_table_handles">
performance_schema_max_table_handles</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_table_instances">
performance_schema_max_table_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_thread_classes">
performance_schema_max_thread_classes</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_max_thread_instances">
performance_schema_max_thread_instances</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_memory_classes_lost">
Performance_schema_memory_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_metadata_lock_lost">
Performance_schema_metadata_lock_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_mutex_classes_lost">
Performance_schema_mutex_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_mutex_instances_lost">
Performance_schema_mutex_instances_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_nested_statement_lost">
Performance_schema_nested_statement_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_prepared_statements_lost">
Performance_schema_prepared_statements_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_program_lost">
Performance_schema_program_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_rwlock_classes_lost">
Performance_schema_rwlock_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_rwlock_instances_lost">
Performance_schema_rwlock_instances_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_session_connect_attrs_lost">
Performance_schema_session_connect_attrs_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_session_connect_attrs_size">
performance_schema_session_connect_attrs_size</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_setup_actors_size">
performance_schema_setup_actors_size</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_setup_objects_size">
performance_schema_setup_objects_size</a></td><td>Да</td><td>Да</td>
<td>Да</td><td> </td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_socket_classes_lost">
Performance_schema_socket_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_socket_instances_lost">
Performance_schema_socket_instances_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_stage_classes_lost">
Performance_schema_stage_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_statement_classes_lost">
Performance_schema_statement_classes_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_table_handles_lost">
Performance_schema_table_handles_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_table_instances_lost">
Performance_schema_table_instances_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_thread_classes_lost">
Performance_schema_thread_classes_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_thread_instances_lost">
Performance_schema_thread_instances_lost</a></td><td> </td><td> </td>
<td> </td><td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#statvar_Performance_schema_users_lost">
Performance_schema_users_lost</a></td><td> </td><td> </td><td> </td>
<td>Да</td><td>Глобальная</td><td>Нет</td></tr>
<tr><td scope="row">
<a href="#sysvar_performance_schema_users_size">
performance_schema_users_size</a></td><td>Да</td><td>Да</td><td>Да</td>
<td> </td><td>Глобальная</td><td>Нет</td></tr></tbody></table>

<h2><a name="performance-schema-options"></a>23.11.
Опции команд Performance Schema</h2>
<p>Параметры Performance Schema могут быть определены при запуске сервера в
командной строке или в файлах опции, чтобы сконфигурировать инструменты и
потребителей Performance Schema. Конфигурация во время выполнения также
возможна во многих случаях (см.
<a href="#performance-schema-runtime-configuration">раздел 23.2.3
</a>), но конфигурация запуска должна использоваться, когда конфигурация во
время выполнения должна слишком поздно затронуть инструменты,
которые были уже инициализированы во время процесса запуска.</p>

<p>Потребители и инструменты Performance Schema
могут быть сконфигурированы при запуске, используя следующий синтаксис.
Для дополнительных деталей см.
<a href="#performance-schema-startup-configuration">раздел 23.2.2
</a>.</p>

<ul><li><p><a name="option_mysqld_performance-schema-consumer-xxx"></a>
<a href="#option_mysqld_performance-schema-consumer-xxx"><code>
--performance-schema-consumer-<em><code>consumer_name</code></em>=<code>value
</code></code></a></p>
<p>Сконфигурируйте потребителя Performance Schema. Имена потребителей в
<a href="#setup-consumers-table"><code>setup_consumers</code></a>
используют подчеркивания, но для указания потребителя при запуске тире и
подчеркиваниях в пределах имени эквивалентны. Опции для того, чтобы
сконфигурировать отдельных потребителей детализированы позже в этом разделе.
</li>

<li><a name="option_mysqld_performance-schema-instrument"></a>
<a href="#option_mysqld_performance-schema-instrument">
<code>--performance-schema-instrument=<em><code>instrument_name</code>
</em>=<code>value</code></code></a></p>
<p>Сконфигурируйте инструмент Performance Schema. Имя может быть дано как
образец, чтобы сконфигурировать инструменты, которые соответствуют образцу.
</p></li></ul>

<p>Следующие элементы конфигурируют отдельных потребителей:</p>
<ul><li><p><a name="option_mysqld_performance-schema-consumer-events-stages-current">
</a><a href="#option_mysqld_performance-schema-consumer-events-stages-current">
<code>--performance-schema-consumer-events-stages-current=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>events-stages-current</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-stages-history">
</a><a href="#option_mysqld_performance-schema-consumer-events-stages-history">
<code>--performance-schema-consumer-events-stages-history=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>events-stages-history</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-stages-history-long">
</a>
<a href="#option_mysqld_performance-schema-consumer-events-stages-history-long">
<code>--performance-schema-consumer-events-stages-history-long=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>events-stages-history-long</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-statements-current">
</a><a href="#option_mysqld_performance-schema-consumer-events-statements-current">
<code>--performance-schema-consumer-events-statements-current=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>events-statements-current</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-statements-history">
</a><a href="#option_mysqld_performance-schema-consumer-events-statements-history">
<code>--performance-schema-consumer-events-statements-history=<code>value
</code></code></a></p>
<p>Сконфигурируйте потребитель <code>events-statements-history</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-statements-history-long">
</a><a href="#option_mysqld_performance-schema-consumer-events-statements-history-long">
<code>--performance-schema-consumer-events-statements-history-long=<code>value
</code></code></a></p>
<p>Сконфигурируйте потребитель <code>events-statements-history-long</code>.
</li>

<li><a name="option_mysqld_performance-schema-consumer-events-transactions-current">
</a><a href="#option_mysqld_performance-schema-consumer-events-transactions-current">
<code>--performance-schema-consumer-events-transactions-current=<code>value
</code></code></a></p>
<p>Сконфигурируйте потребитель <code>events-transactions-current</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-transactions-history">
</a><a href="#option_mysqld_performance-schema-consumer-events-transactions-history">
<code>--performance-schema-consumer-events-transactions-history=<code>value
</code></code></a></p>
<p>Сконфигурируйте потребитель Performance Schema
<code>events-transactions-history</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-transactions-history-long">
</a><a href="#option_mysqld_performance-schema-consumer-events-transactions-history-long">
<code>--performance-schema-consumer-events-transactions-history-long=<code>
value</code></code></a></p>
<p>Сконфигурируйте потребитель Performance Schema
<code>events-transactions-history-long</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-waits-current">
</a><a href="#option_mysqld_performance-schema-consumer-events-waits-current">
<code>--performance-schema-consumer-events-waits-current=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>events-waits-current</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-waits-history">
</a><a href="#option_mysqld_performance-schema-consumer-events-waits-history">
<code>--performance-schema-consumer-events-waits-history=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>events-waits-history</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-events-waits-history-long">
</a><a href="#option_mysqld_performance-schema-consumer-events-waits-history-long">
<code>--performance-schema-consumer-events-waits-history-long=<code>value
</code></code></a></p>
<p>Сконфигурируйте потребитель <code>events-waits-history-long</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-global-instrumentation">
</a><a href="#option_mysqld_performance-schema-consumer-global-instrumentation">
<code>--performance-schema-consumer-global-instrumentation=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель  <code>global-instrumentation</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-statements-digest">
</a><a href="#option_mysqld_performance-schema-consumer-statements-digest">
<code>--performance-schema-consumer-statements-digest=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>statements-digest</code>.</li>

<li><a name="option_mysqld_performance-schema-consumer-thread-instrumentation">
</a><a href="#option_mysqld_performance-schema-consumer-thread-instrumentation">
<code>--performance-schema-consumer-thread-instrumentation=<code>value</code>
</code></a></p>
<p>Сконфигурируйте потребитель <code>thread-instrumentation</code>.
</p></li></ul>

<h2><a name="performance-schema-system-variables"></a>23.12.
Системные переменные Performance Schema</h2>
<p>осуществляет несколько системных переменных, которые
предоставляют информацию о конфигурации:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'perf%';
+----------------------------------------------------------+-------+
| Variable_name                                            | Value |
+----------------------------------------------------------+-------+
| performance_schema                                       | ON    |
| performance_schema_accounts_size                         | -1    |
| performance_schema_digests_size                          | 10000 |
| performance_schema_events_stages_history_long_size       | 10000 |
| performance_schema_events_stages_history_size            | 10    |
| performance_schema_events_statements_history_long_size   | 10000 |
| performance_schema_events_statements_history_size        | 10    |
| performance_schema_events_transactions_history_long_size | 10000 |
| performance_schema_events_transactions_history_size      | 10    |
| performance_schema_events_waits_history_long_size        | 10000 |
| performance_schema_events_waits_history_size             | 10    |
| performance_schema_hosts_size                            | -1    |
| performance_schema_max_cond_classes                      | 80    |
| performance_schema_max_cond_instances                    | -1    |
| performance_schema_max_digest_length                     | 1024  |
| performance_schema_max_file_classes                      | 50    |
| performance_schema_max_file_handles                      | 32768 |
| performance_schema_max_file_instances                    | -1    |
| performance_schema_max_index_stat                        | -1    |
| performance_schema_max_memory_classes                    | 320   |
| performance_schema_max_metadata_locks                    | -1    |
| performance_schema_max_mutex_classes                     | 200   |
| performance_schema_max_mutex_instances                   | -1    |
| performance_schema_max_prepared_statements_instances     | -1    |
| performance_schema_max_program_instances                 | -1    |
| performance_schema_max_rwlock_classes                    | 40    |
| performance_schema_max_rwlock_instances                  | -1    |
| performance_schema_max_socket_classes                    | 10    |
| performance_schema_max_socket_instances                  | -1    |
| performance_schema_max_sql_text_length                   | 1024  |
| performance_schema_max_stage_classes                     | 150   |
| performance_schema_max_statement_classes                 | 192   |
| performance_schema_max_statement_stack                   | 10    |
| performance_schema_max_table_handles                     | -1    |
| performance_schema_max_table_instances                   | -1    |
| performance_schema_max_table_lock_stat                   | -1    |
| performance_schema_max_thread_classes                    | 50    |
| performance_schema_max_thread_instances                  | -1    |
| performance_schema_session_connect_attrs_size            | 512   |
| performance_schema_setup_actors_size                     | -1    |
| performance_schema_setup_objects_size                    | -1    |
| performance_schema_users_size                            | -1    |
+----------------------------------------------------------+-------+
</pre>

<p>Системные переменные Performance Schema могут быть установлены при запуске
сервера в командной строке или в файлах опции, и многие могут быть
установлены во времени выполнения. См.
<a href="#performance-schema-option-variable-reference">раздел
23.10</a>.</p>

<p>Performance Schema автоматически измеряет значения нескольких из ее
параметров при запуске сервера, если они не установлены явно.
Для получения дополнительной информации см.
<a href="#performance-schema-startup-configuration">раздел 23.2.2
</a>.</p>

<p>У системных переменных Performance Schema есть следующие значения:</p>
<ul><li><p><a name="sysvar_performance_schema"></a>
<a href="#sysvar_performance_schema"><code>performance_schema
</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td>
<td colspan="2"><code><a href="#sysvar_performance_schema">
performance_schema</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
boolean</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Значение этой переменной <code>ON</code> или <code>OFF</code>, чтобы
указать, включена ли Performance Schema. По умолчанию значение
<code>ON</code>. При запуске сервера Вы можете определить эту переменную без
значения, со значением <code>ON</code> (или 1), чтобы включить или со
значением <code>OFF</code> (или 0), чтобы выключить.</p>

<p>Даже когда Performance Schema отключена, она продолжает заполнять таблицы
populate the <a href="#performance-schema-system-variable-tables">
<code>global_variables</code></a>,
<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a>,
<a href="#performance-schema-status-variable-tables"><code>
global_status</code></a> и
<a href="#performance-schema-status-variable-tables"><code>
session_status</code></a>.
Это происходит по мере необходимости, чтобы разрешить результаты для
<a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a> и
<a href="sql.htm#show-status"><code>SHOW STATUS</code></a>, которые будут
оттянуты из тех таблиц, в зависимости от установки переменной
<code>show_compatibiliy_56</code>.</li>

<li><a name="sysvar_performance_schema_accounts_size"></a>
<a href="#sysvar_performance_schema_accounts_size"><code>
performance_schema_accounts_size</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_accounts_size=#</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_accounts_size">
performance_schema_accounts_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Число строк в <a href="#accounts-table"><code>accounts</code>
</a>. Если эта переменная 0, Performance Schema
не поддерживает статистику соединения в
<a href="#accounts-table"><code>accounts</code></a>
или информацию о переменных состояния в
<a href="#performance-schema-status-variable-summary-tables">
<code>status_by_account</code></a>.</li>

<li><a name="sysvar_performance_schema_digests_size"></a>
<a href="#sysvar_performance_schema_digests_size"><code>
performance_schema_digests_size</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_digests_size=#</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_digests_size">
performance_schema_digests_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>-1</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Максимальное количество строк в таблице
<a href="#statement-summary-tables">
<code>events_statements_summary_by_digest</code></a>.
Если этот максимум превышен таким образом, что обзор не может быть
инструментован, Performance Schema постепенно увеличивает переменную
<a href="#statvar_Performance_schema_digest_lost"><code>
Performance_schema_digest_lost</code></a>.</li>

<li><a name="sysvar_performance_schema_error_size"></a>
<a href="#sysvar_performance_schema_error_size"><code>
performance_schema_error_size</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_error_size</code></td>
</tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_error_size">
performance_schema_error_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>number of server error codes</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Число инструментованных кодов ошибки сервера. Значение по умолчанию:
фактическое число кодов ошибки сервера. Хотя значение может быть установлено
от 0 до максимума, намеченное использование должно установить его в любое
значение по умолчанию (чтобы инструментовать все ошибки) или 0 (чтобы
не инструментовать ошибки).</p>

<p>Информация об ошибке соединена в сводных таблицах, см.
<a href="#error-summary-tables">раздел 23.9.15.10</a>.
Если происходит ошибка, которая не инструментована, информация для
возникновения соединена к строке <code>NULL</code>
в каждой сводной таблице, то есть, к строке с
<code>ERROR_NUMBER=0</code>, <code>ERROR_NAME=NULL</code> и
<code>SQLSTATE=NULL</code>.</li>

<li><a name="sysvar_performance_schema_events_stages_history_long_size"></a>
<a href="#sysvar_performance_schema_events_stages_history_long_size">
<code>performance_schema_events_stages_history_long_size</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_events_stages_history_long_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_stages_history_long_size">
performance_schema_events_stages_history_long_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>
<p>Число строк в <a href="#events-stages-history-long-table"><code>
events_stages_history_long</code></a>.</li>

<li><a name="sysvar_performance_schema_events_stages_history_size"></a>
<a href="#sysvar_performance_schema_events_stages_history_size">
<code>performance_schema_events_stages_history_size</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_events_stages_history_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_stages_history_size">
performance_schema_events_stages_history_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>

<p>Число строк на поток в
<a href="#events-stages-history-table"><code>
events_stages_history</code></a>.</li>

<li><a name="sysvar_performance_schema_events_statements_history_long_size">
</a><a href="#sysvar_performance_schema_events_statements_history_long_size">
<code>performance_schema_events_statements_history_long_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_events_statements_history_long_size=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_statements_history_long_size">
performance_schema_events_statements_history_long_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>
<p>Число строк в <a href="#events-statements-history-long-table">
<code>events_statements_history_long</code></a>.</li>

<li><a name="sysvar_performance_schema_events_statements_history_size"></a>
<a href="#sysvar_performance_schema_events_statements_history_size">
<code>performance_schema_events_statements_history_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_events_statements_history_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_statements_history_size">
performance_schema_events_statements_history_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>

<p>Число строк на поток в
<a href="#events-statements-history-table">
<code>events_statements_history</code></a>.</li>

<li><a name="sysvar_performance_schema_events_transactions_history_long_size">
</a><a href="#sysvar_performance_schema_events_transactions_history_long_size">
<code>performance_schema_events_transactions_history_long_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_events_transactions_history_long_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_transactions_history_long_size">
erformance_schema_events_transactions_history_long_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>
<p>Число строк в <a href="#events-transactions-history-long-table">
<code>events_transactions_history_long</code></a>.</li>

<li><a name="sysvar_performance_schema_events_transactions_history_size"></a>
<a href="#sysvar_performance_schema_events_transactions_history_size">
<code>performance_schema_events_transactions_history_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_events_transactions_history_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_transactions_history_size">
performance_schema_events_transactions_history_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>

<p>Число строк на поток в
<a href="#events-transactions-history-table"><code>
events_transactions_history</code></a>.</li>

<li><a name="sysvar_performance_schema_events_waits_history_long_size"></a>
<a href="#sysvar_performance_schema_events_waits_history_long_size">
<code>performance_schema_events_waits_history_long_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_events_waits_history_long_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_waits_history_long_size">
performance_schema_events_waits_history_long_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>
<p>Число строк в <a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a>.</li>

<li><a name="sysvar_performance_schema_events_waits_history_size"></a>
<a href="#sysvar_performance_schema_events_waits_history_size">
<code>performance_schema_events_waits_history_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_events_waits_history_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_events_waits_history_size">
performance_schema_events_waits_history_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>

<p>Число строк на поток в
<a href="#events-waits-history-table"><code>events_waits_history
</code></a>.</li>

<li><a name="sysvar_performance_schema_hosts_size"></a>
<a href="#sysvar_performance_schema_hosts_size"><code>
performance_schema_hosts_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_hosts_size=#</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_hosts_size">
performance_schema_hosts_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Число строк в <a href="#hosts-table"><code>hosts</code></a>.
Если эта переменная 0, Performance Schema не поддерживает статистику
соединения в <a href="#hosts-table"><code>hosts</code></a>
или информацию о переменных состояния в
<a href="#performance-schema-status-variable-summary-tables">
<code>status_by_host</code></a>.</li>

<li><a name="sysvar_performance_schema_max_cond_classes"></a>
<a href="#sysvar_performance_schema_max_cond_classes">
<code>performance_schema_max_cond_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_cond_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_cond_classes">
performance_schema_max_cond_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>80</code></td></tr></tbody></table>
<p>Максимальное количество инструментованных условий.</li>

<li><a name="sysvar_performance_schema_max_cond_instances"></a>
<a href="#sysvar_performance_schema_max_cond_instances"><code>
performance_schema_max_cond_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_cond_instances=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_cond_instances">
performance_schema_max_cond_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Максимальное количество инструментованных объектов условия.</li>

<li><a name="sysvar_performance_schema_max_digest_length"></a>
<a href="#sysvar_performance_schema_max_digest_length">
<code>performance_schema_max_digest_length</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_digest_length=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_digest_length">
performance_schema_max_digest_length</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Максимальное количество байтов, доступных для вычислительных обзоров
(см. <a href="#performance-schema-statement-digests">раздел 23.7
</a>). Эта переменная походит на
<a href="server.htm#sysvar_max_digest_length"><code>max_digest_length</code>
</a>, но относится только к Performance Schema.
Для получения дополнительной информации см. описание этой переменной в
<a href="server.htm#server-system-variables">разделе 6.1.5</a>.</li>

<li><a name="sysvar_performance_schema_max_file_classes"></a>
<a href="#sysvar_performance_schema_max_file_classes"><code>
performance_schema_max_file_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_file_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_file_classes">
performance_schema_max_file_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>80</code></td></tr></tbody></table>
<p>Максимальное количество инструментов файла.</li>

<li><a name="sysvar_performance_schema_max_file_handles"></a>
<a href="#sysvar_performance_schema_max_file_handles"><code>
performance_schema_max_file_handles</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_file_handles=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_file_handles">
performance_schema_max_file_handles</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>32768</code></td></tr></tbody></table>
<p>Максимальное количество открытых объектов файла.</p>

<p>Значение <a href="#sysvar_performance_schema_max_file_handles">
<code>performance_schema_max_file_handles</code></a> должно быть больше, чем
значение <a href="server.htm#sysvar_open_files_limit"><code>open_files_limit
</code></a>: <a href="server.htm#sysvar_open_files_limit"><code>
open_files_limit</code></a> затрагивает максимальное количество открытых
дескрипторов, которые сервер может поддержать, а
<a href="#sysvar_performance_schema_max_file_handles"><code>
performance_schema_max_file_handles</code></a> указывает, сколько из этих
дескрипторов может быть инструментовано.</li>

<li><a name="sysvar_performance_schema_max_file_instances"></a>
<a href="#sysvar_performance_schema_max_file_instances"><code>
performance_schema_max_file_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_file_instances=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_file_instances">
performance_schema_max_file_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Максимальное количество инструментованных объектов файла.</li>

<li><a name="sysvar_performance_schema_max_index_stat"></a>
<a href="#sysvar_performance_schema_max_index_stat"><code>
performance_schema_max_index_stat</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_index_stat=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_index_stat">
performance_schema_max_index_stat</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>

<p>Максимальное количество индексов, для которых Performance Schema
поддерживает статистику. Если этот максимум превышен, статистика индексов
потеряна, а Performance Schema постепенно увеличивает переменную
<a href="#statvar_Performance_schema_index_stat_lost"><code>
Performance_schema_index_stat_lost</code></a>.
Значение по умолчанию задано, используя значение
<a href="#sysvar_performance_schema_max_table_instances"><code>
performance_schema_max_table_instances</code></a>.</li>

<li><a name="sysvar_performance_schema_max_memory_classes"></a>
<a href="#sysvar_performance_schema_max_memory_classes"><code>
performance_schema_max_memory_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_memory_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_memory_classes">
performance_schema_max_memory_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>320</code></td></tr></tbody></table>
<p>Максимальное количество инструментов памяти.</li>

<li><a name="sysvar_performance_schema_max_metadata_locks"></a>
<a href="#sysvar_performance_schema_max_metadata_locks"><code>
performance_schema_max_metadata_locks</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_metadata_locks=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_metadata_locks">
performance_schema_max_metadata_locks</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>

<p>Максимальное количество метаданных блокировки инструментов.
Это значение управляет размером таблицы
<a href="#metadata-locks-table"><code>metadata_locks</code></a>.
Если этот максимум превышен таким образом, что блокировка метаданных не может
быть инструментована, Performance Schema постепенно увеличивает
<a href="#statvar_Performance_schema_metadata_lock_lost"><code>
Performance_schema_metadata_lock_lost</code></a>.</li>

<li><a name="sysvar_performance_schema_max_mutex_classes"></a>
<a href="#sysvar_performance_schema_max_mutex_classes"><code>
performance_schema_max_mutex_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_mutex_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_mutex_classes">
performance_schema_max_mutex_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>200</code></td></tr></tbody></table>
<p>Максимальное количество инструментов mutex.</li>

<li><a name="sysvar_performance_schema_max_mutex_instances"></a>
<a href="#sysvar_performance_schema_max_mutex_instances"><code>
performance_schema_max_mutex_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_mutex_instances=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_mutex_instances">
performance_schema_max_mutex_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Максимальное количество инструментованных объектов mutex.</li>

<li><a name="sysvar_performance_schema_max_prepared_statements_instances">
</a><a href="#sysvar_performance_schema_max_prepared_statements_instances">
<code>performance_schema_max_prepared_statements_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_max_prepared_statements_instances=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_prepared_statements_instances">
performance_schema_max_prepared_statements_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>

<p>Максимальное количество строк в таблице
<a href="#prepared-statements-instances-table"><code>
prepared_statements_instances</code></a>. Если этот максимум превышен таким
образом, что готовый запрос не может быть инструментован, Performance Schema
постепенно увеличивает переменную
<a href="#statvar_Performance_schema_prepared_statements_lost">
<code>Performance_schema_prepared_statements_lost</code></a>.
Значение по умолчанию этой переменной задано, основываясь на значении
переменной <a href="server.htm#sysvar_max_prepared_stmt_count"><code>
max_prepared_stmt_count</code></a>.</li>

<li><a name="sysvar_performance_schema_max_rwlock_classes"></a>
<a href="#sysvar_performance_schema_max_rwlock_classes"><code>
performance_schema_max_rwlock_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_rwlock_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_rwlock_classes">
performance_schema_max_rwlock_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>40</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>20</code></td></tr></tbody></table>
<p>Максимальное количество rwlock инструментов.</li>

<li><a name="sysvar_performance_schema_max_program_instances"></a>
<a href="#sysvar_performance_schema_max_program_instances"><code>
performance_schema_max_program_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_max_program_instances=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_program_instances">
performance_schema_max_program_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>

<p>Максимальное количество сохраненных программ, для которых
Performance Schema поддерживает статистику. Если этот максимум превышен,
Performance Schema постепенно увеличивает переменную
<a href="#statvar_Performance_schema_program_lost"><code>
Performance_schema_program_lost</code></a>.</li>

<li><a name="sysvar_performance_schema_max_rwlock_instances"></a>
<a href="#sysvar_performance_schema_max_rwlock_instances">
<code>performance_schema_max_rwlock_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_rwlock_instances=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_rwlock_instances">
performance_schema_max_rwlock_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Максимальное количество инструментованных объектов rwlock.</li>

<li><a name="sysvar_performance_schema_max_socket_classes"></a>
<a href="#sysvar_performance_schema_max_socket_classes">
<code>performance_schema_max_socket_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_socket_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_socket_classes">
performance_schema_max_socket_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10</code></td></tr></tbody></table>
<p>Максимальное количество инструментов сокета.</li>

<li><a name="sysvar_performance_schema_max_socket_instances"></a>
<a href="#sysvar_performance_schema_max_socket_instances">
<code>performance_schema_max_socket_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_socket_instances=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_socket_instances">
performance_schema_max_socket_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Максимальное количество инструментованных объектов сокета.</li>

<li><a name="sysvar_performance_schema_max_sql_text_length"></a>
<a href="#sysvar_performance_schema_max_sql_text_length">
<code>performance_schema_max_sql_text_length</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_sql_text_length=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_sql_text_length">
performance_schema_max_sql_text_length</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Максимальное количество байтов, используемых, чтобы хранить запросы SQL в
столбце <code>SQL_TEXT</code> таблиц событий
<a href="#events-statements-current-table"><code>
events_statements_current</code></a>,
<a href="#events-statements-history-table"><code>
events_statements_history</code></a> и
<a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a>. Любые байты сверх
<a href="#sysvar_performance_schema_max_sql_text_length"><code>
performance_schema_max_sql_text_length</code></a> отказаны и не появляются в
столбце <code>SQL_TEXT</code>. Запросы, отличающиеся только после этих
начальных байтов, неразличимы в этом столбце.</p>

<p>Уменьшение значения <a href="#sysvar_performance_schema_max_sql_text_length">
<code>performance_schema_max_sql_text_length</code></a>
уменьшает использование памяти, но заставляет больше запросов становиться
неразличимыми, если они отличаются только в конце. Увеличение значения
увеличивает использование памяти, но разрешает более длинные
запросы, которые отличаются.</li>

<li><a name="sysvar_performance_schema_max_stage_classes"></a>
<a href="#sysvar_performance_schema_max_stage_classes"><code>
performance_schema_max_stage_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_stage_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_stage_classes">
performance_schema_max_stage_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>150</code></td></tr></tbody></table>
<p>Максимальное количество инструментов этапа.</li>

<li><a name="sysvar_performance_schema_max_statement_classes"></a>
<a href="#sysvar_performance_schema_max_statement_classes">
<code>performance_schema_max_statement_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_statement_classes=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_statement_classes">
performance_schema_max_statement_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>

<p>Максимальное количество инструментов запроса.
Значение по умолчанию вычислено в сервере, основываясь на числе команд в
протоколе клиент-сервер и числе типов запросов SQL, поддержанных сервером.</p>

<p>Эта переменная не должна быть заменена, если не установить ее в 0, чтобы
отключить всю инструментовку запросов и сохранить всю память, связанную с
нею. Установка переменной к ненулевым значениям кроме значения по умолчанию
не обладает никаким преимуществом, в частности значения, больше чем значение
по умолчанию, заставляют больше памяти быть выделенной.</li>

<li><a name="sysvar_performance_schema_max_statement_stack"></a>
<a href="#sysvar_performance_schema_max_statement_stack">
<code>performance_schema_max_statement_stack</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_statement_stack=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_statement_stack">
performance_schema_max_statement_stack</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10</code></td></tr></tbody></table>

<p>Максимальная глубина вложенных вызовов сохраненных программ, для которых
Performance Schema поддерживает статистику. Когда этот максимум превышен,
Performance Schema постепенно увеличивает переменную
<a href="#statvar_Performance_schema_nested_statement_lost"><code>
Performance_schema_nested_statement_lost</code></a> для каждой
выполненной сохраненной программы.</li>

<li><a name="sysvar_performance_schema_max_table_handles"></a>
<a href="#sysvar_performance_schema_max_table_handles">
<code>performance_schema_max_table_handles</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_table_handles=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_table_handles">
performance_schema_max_table_handles</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>

<p>Максимальное количество открытых табличных объектов. Это значение
управляет размером таблицы
<a href="#table-handles-table"><code>table_handles</code></a>.
Если этот максимум превышен таким образом, что табличный дескриптор не может
быть инструментован, Performance Schema постепенно увеличивает переменную
<a href="#statvar_Performance_schema_table_handles_lost"><code>
Performance_schema_table_handles_lost</code></a>.</li>

<li><a name="sysvar_performance_schema_max_table_instances"></a>
<a href="#sysvar_performance_schema_max_table_instances"><code>
performance_schema_max_table_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_table_instances=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_table_instances">
performance_schema_max_table_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Максимальное количество инструментованных табличных объектов.</li>

<li><a name="sysvar_performance_schema_max_table_lock_stat"></a>
<a href="#sysvar_performance_schema_max_table_lock_stat"><code>
performance_schema_max_table_lock_stat</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_table_lock_stat=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_table_lock_stat">
performance_schema_max_table_lock_stat</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr></tbody></table>

<p>Максимальное количество таблиц, для которых Performance Schema
поддерживает статистику блокировки. Если этот максимум превышен таким
образом, что табличные статистические данные блокировки потеряны,
Performance Schema увеличивает переменную
<a href="#statvar_Performance_schema_table_lock_stat_lost"><code>
Performance_schema_table_lock_stat_lost</code></a>.</li>

<li><a name="sysvar_performance_schema_max_thread_classes"></a>
<a href="#sysvar_performance_schema_max_thread_classes"><code>
performance_schema_max_thread_classes</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_thread_classes=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_thread_classes">
performance_schema_max_thread_classes</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>50</code></td></tr></tbody></table>
<p>Максимальное количество инструментов потока.</li>

<li><a name="sysvar_performance_schema_max_thread_instances"></a>
<a href="#sysvar_performance_schema_max_thread_instances"><code>
performance_schema_max_thread_instances</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_max_thread_instances=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_max_thread_instances">
performance_schema_max_thread_instances</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>

<p>Максимальное количество инструментованных объектов потока. Значение
управляет размером таблицы <a href="#threads-table"><code>threads
</code></a>. Если этот максимум превышен таким образом, что поток не может
быть инструментован, Performance Schema постепенно увеличивает переменную
<a href="#statvar_Performance_schema_thread_instances_lost"><code>
Performance_schema_thread_instances_lost</code></a>.</p>

<p>Переменная <a href="server.htm#sysvar_max_connections"><code>
max_connections</code></a> затрагивает, сколько потоков может работать в
сервере. <a href="#sysvar_performance_schema_max_thread_instances">
<code>performance_schema_max_thread_instances</code></a> указывает,
сколько из этих рабочих потоков может быть инструментовано.</p>

<p>Таблицы <a href="#performance-schema-system-variable-tables">
<code>variables_by_thread</code></a> и
<a href="#performance-schema-status-variable-tables"><code>
status_by_thread</code></a> содержат информацию только о потоках переднего
плана. Если не все потоки будут инструментованы Performance Schema,
то эта таблица пропустит некоторые строки. В этом случае переменная состояния
<a href="#statvar_Performance_schema_thread_instances_lost">
<code>Performance_schema_thread_instances_lost</code></a>
будет больше, чем ноль.</li>

<li><a name="sysvar_performance_schema_session_connect_attrs_size"></a>
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>
--performance_schema_session_connect_attrs_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_session_connect_attrs_size">
performance_schema_session_connect_attrs_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autosized)</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>-1</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Количество предварительно выделенной памяти на поток, чтобы держать
атрибуты соединения. Если совокупный размер данных о признаке соединения,
посланных клиентом, больше чем это количество, Performance Schema
усекает данные о признаке, увеличивая переменную
<a href="#statvar_Performance_schema_session_connect_attrs_lost">
<code>Performance_schema_session_connect_attrs_lost</code></a>
и пишет сообщение в журнал ошибок, указывающее, что усечение произошло, если
переменная <a href="server.htm#sysvar_log_warnings"><code>log_warnings</code>
</a> больше, чем ноль. Атрибут <code>_truncated</code> также добавлен к
признакам сеанса со значением, указывающим, сколько байтов было потеряно,
если у буфера признаков есть достаточное пространство. Это позволяет
Performance Schema выставить информацию об усечении на соединение в таблицах
атрибутов соединения. Эта информация может быть исследована, не имея
необходимость проверять журнал ошибок.</p>

<p>Значение по умолчанию
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>
задано при запуске сервера. Это значение может быть маленьким,
так, если усечение происходит
(<a href="#statvar_Performance_schema_session_connect_attrs_lost">
<code>Performance_schema_session_connect_attrs_lost</code></a>
становится отличным от нуля), Вы можете хотеть установить
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>
явно к большему значению.</p>

<p>Хотя максимум разрешенного значения
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>
составляет 1 МБ, эффективный максимум составляет 64 КБ, потому что сервер
налагает предел в 64 КБ на совокупный размер данных о признаке соединения.
Если клиент пытается послать больше чем 64 КБ данных о признаке, сервер
отклоняет соединение. Для получения дополнительной информации см.
<a href="#performance-schema-connection-attribute-tables">раздел
23.9.9</a>.</li>

<li><a name="sysvar_performance_schema_setup_actors_size"></a>
<a href="#sysvar_performance_schema_setup_actors_size"><code>
performance_schema_setup_actors_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_setup_actors_size=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_setup_actors_size">
performance_schema_setup_actors_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Число строк в таблице
<a href="#setup-actors-table"><code>setup_actors</code></a>.</li>

<li><a name="sysvar_performance_schema_setup_objects_size"></a>
<a href="#sysvar_performance_schema_setup_objects_size"><code>
performance_schema_setup_objects_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_setup_objects_size=#
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_setup_objects_size">
performance_schema_setup_objects_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td><td colspan="2"><code>
integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr></tbody></table>
<p>Число строк в таблице
<a href="#setup-objects-table"><code>setup_objects</code></a>.</li>

<li><a name="sysvar_performance_schema_users_size"></a>
<a href="#sysvar_performance_schema_users_size"><code>
performance_schema_users_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Формат командной строки</strong>
</span></td><td colspan="3"><code>--performance_schema_users_size=#</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_performance_schema_users_size">
performance_schema_users_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Область действия</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td><td><span><strong>Тип</strong></span></td>
<td colspan="2"><code>integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>-1 (autoscaled)</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1048576</code></td></tr></tbody></table>

<p>Число строк в таблице <a href="#users-table"><code>users</code>
</a>. Если эта переменная 0, Performance Schema не поддерживает статистику
соединения в <a href="#users-table"><code>users</code></a>
или информацию о переменных состояния в
<a href="#performance-schema-status-variable-summary-tables">
<code>status_by_user</code></a>.</p></li></ul>

<h2><a name="performance-schema-status-variables"></a>23.13.
Переменные состояния Performance Schema</h2>
<p>Performance Schema осуществляет несколько переменных состояния, которые
предоставляют информацию об инструментовке, которая не могла быть загружена
или создана из-за ограничений памяти:
<pre>
mysql&gt; SHOW STATUS LIKE 'perf%';
+-------------------------------------------+-------+
| Variable_name                             | Value |
+-------------------------------------------+-------+
| Performance_schema_accounts_lost          | 0     |
| Performance_schema_cond_classes_lost      | 0     |
| Performance_schema_cond_instances_lost    | 0     |
| Performance_schema_file_classes_lost      | 0     |
| Performance_schema_file_handles_lost      | 0     |
| Performance_schema_file_instances_lost    | 0     |
| Performance_schema_hosts_lost             | 0     |
| Performance_schema_locker_lost            | 0     |
| Performance_schema_mutex_classes_lost     | 0     |
| Performance_schema_mutex_instances_lost   | 0     |
| Performance_schema_rwlock_classes_lost    | 0     |
| Performance_schema_rwlock_instances_lost  | 0     |
| Performance_schema_socket_classes_lost    | 0     |
| Performance_schema_socket_instances_lost  | 0     |
| Performance_schema_stage_classes_lost     | 0     |
| Performance_schema_statement_classes_lost | 0     |
| Performance_schema_table_handles_lost     | 0     |
| Performance_schema_table_instances_lost   | 0     |
| Performance_schema_thread_classes_lost    | 0     |
| Performance_schema_thread_instances_lost  | 0     |
| Performance_schema_users_lost             | 0     |
+-------------------------------------------+-------+
</pre>

<p>У переменных состояния Performance Schema есть следующие значения:</p>
<ul><li><p><a name="statvar_Performance_schema_accounts_lost"></a>
<a href="#statvar_Performance_schema_accounts_lost"><code>
Performance_schema_accounts_lost</code></a></p>

<p>Сколько раз строка не могла быть добавлена к таблице
<a href="#accounts-table"><code>accounts</code></a> потому,
что она была полна.</li>

<li><a name="statvar_Performance_schema_cond_classes_lost"></a>
<a href="#statvar_Performance_schema_cond_classes_lost"><code>
Performance_schema_cond_classes_lost</code></a></p>
<p>Сколько инструментов условия не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_cond_instances_lost"></a>
<a href="#statvar_Performance_schema_cond_instances_lost"><code>
Performance_schema_cond_instances_lost</code></a></p>
<p>Сколько инструментальных случаев условия не могло быть создано.</li>

<li><a name="statvar_Performance_schema_digest_lost"></a>
<a href="#statvar_Performance_schema_digest_lost"><code>
Performance_schema_digest_lost</code></a></p>

<p>Число случаев обзора, которые не могли быть инструментованы в
<a href="#statement-summary-tables"><code>
events_statements_summary_by_digest</code></a>.
Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_digests_size"><code>
performance_schema_digests_size</code></a> является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_file_classes_lost"></a>
<a href="#statvar_Performance_schema_file_classes_lost"><code>
Performance_schema_file_classes_lost</code></a></p>
<p>Сколько инструментов файла не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_file_handles_lost"></a>
<a href="#statvar_Performance_schema_file_handles_lost"><code>
Performance_schema_file_handles_lost</code></a></p>
<p>Сколько инструментальных случаев файла не могло быть открыто.</li>

<li><a name="statvar_Performance_schema_file_instances_lost"></a>
<a href="#statvar_Performance_schema_file_instances_lost"><code>
Performance_schema_file_instances_lost</code></a></p>
<p>Сколько инструментальных случаев файла не могло быть создано.</li>

<li><a name="statvar_Performance_schema_hosts_lost"></a>
<a href="#statvar_Performance_schema_hosts_lost"><code>
Performance_schema_hosts_lost</code></a></p>
<p>Сколько раз строка не могла быть добавлена к таблице
<a href="#hosts-table"><code>hosts</code></a>
потому, что она была полна.</li>

<li><a name="statvar_Performance_schema_index_stat_lost"></a>
<a href="#statvar_Performance_schema_index_stat_lost">
<code>Performance_schema_index_stat_lost</code></a></p>

<p>Число индексов, для которых были потеряны статистические данные. Это может
быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_index_stat"><code>
performance_schema_max_index_stat</code></a> является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_locker_lost"></a>
<a href="#statvar_Performance_schema_locker_lost"><code>
Performance_schema_locker_lost</code></a></p>

<p>Сколько событий <span>потеряны</span>
или не зарегистрированы из-за следующих условий:</p>
<ul><li><p>События являются рекурсивными.</li>
<li>Глубина вложенного стека событий больше чем
предел, наложенный выполнением.</p></li></ul>
<p>События, зарегистрированные Performance Schema, не являются рекурсивными,
таким образом, эта переменная должна всегда быть 0.</li>

<li><a name="statvar_Performance_schema_memory_classes_lost"></a>
<a href="#statvar_Performance_schema_memory_classes_lost">
<code>Performance_schema_memory_classes_lost</code></a></p>
<p>Сколько раз инструмент памяти не мог быть загружен.</li>

<li><a name="statvar_Performance_schema_metadata_lock_lost"></a>
<a href="#statvar_Performance_schema_metadata_lock_lost">
<code>Performance_schema_metadata_lock_lost</code></a></p>

<p>Число блокировок метаданных, которые не могли быть инструментованы в
<a href="#metadata-locks-table"><code>metadata_locks</code></a>.
Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_metadata_locks"><code>
performance_schema_max_metadata_locks</code></a> является слишком маленьким.
</li>

<li><a name="statvar_Performance_schema_mutex_classes_lost"></a>
<a href="#statvar_Performance_schema_mutex_classes_lost">
<code>Performance_schema_mutex_classes_lost</code></a></p>
<p>Сколько инструментов mutex не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_mutex_instances_lost"></a>
<a href="#statvar_Performance_schema_mutex_instances_lost">
<code>Performance_schema_mutex_instances_lost</code></a></p>
<p>Сколько инструментальных случаев mutex не могло быть создано.</li>

<li><a name="statvar_Performance_schema_nested_statement_lost"></a>
<a href="#statvar_Performance_schema_nested_statement_lost">
<code>Performance_schema_nested_statement_lost</code></a></p>
<p>Число сохраненных запросов программы, для которых были потеряны
статистические данные. Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_statement_stack">
<code>performance_schema_max_statement_stack</code></a>
является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_prepared_statements_lost"></a>
<a href="#statvar_Performance_schema_prepared_statements_lost">
<code>Performance_schema_prepared_statements_lost</code></a></p>
<p>Число готовых запросов, которые не могли быть инструментованы в таблице
<a href="#prepared-statements-instances-table">
<code>prepared_statements_instances</code></a>.
Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_prepared_statements_instances">
<code>performance_schema_max_prepared_statements_instances</code></a>
является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_program_lost"></a>
<a href="#statvar_Performance_schema_program_lost"><code>
Performance_schema_program_lost</code></a></p>
<p>Число сохраненных программ, для которых были потеряны статистические
данные. Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_program_instances">
<code>performance_schema_max_program_instances</code></a>
является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_rwlock_classes_lost"></a>
<a href="#statvar_Performance_schema_rwlock_classes_lost">
<code>Performance_schema_rwlock_classes_lost</code></a></p>
<p>Сколько rwlock инструментов не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_rwlock_instances_lost"></a>
<a href="#statvar_Performance_schema_rwlock_instances_lost">
<code>Performance_schema_rwlock_instances_lost</code></a></p>
<p>Сколько rwlock инструментальных случаев не могло быть создано.</li>

<li><a name="statvar_Performance_schema_session_connect_attrs_longest_seen">
</a><a href="#statvar_Performance_schema_session_connect_attrs_longest_seen">
<code>Performance_schema_session_connect_attrs_longest_seen</code></a></p>
<p>В дополнение к проверке размера атрибутов соединения, выполненной
Performance Schema по значению системной переменной
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>,
сервер выполняет предварительную проверку, налагая предел 64 КБ на совокупный
размер данных о признаке соединения, который примет. Если клиент пытается
послать больше, чем 64 КБ данных о признаке, сервер отклоняет соединение.
Иначе, сервер полагает, что признак допустимый, и отслеживает размер самого
длинного буфера в переменной
<a href="#statvar_Performance_schema_session_connect_attrs_longest_seen">
<code>Performance_schema_session_connect_attrs_longest_seen</code></a>.
Если это значение больше, чем
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>, DBA
может хотеть увеличить последнее значение или заняться расследованиями, какие
клиенты посылают большое количество данных о признаке.</p></li>

<li><a name="statvar_Performance_schema_session_connect_attrs_lost"></a>
<a href="#statvar_Performance_schema_session_connect_attrs_lost">
<code>Performance_schema_session_connect_attrs_lost</code></a></p>
<p>Число соединений, для которых произошло усечение признака соединения. Для
данного соединения, если клиент посылает пары ключа/значения признака
соединения, для которых совокупный размер больше, чем разрешенное значение
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>, Performance
Schema усекает данные о признаке и увеличивает
<a href="#statvar_Performance_schema_session_connect_attrs_lost">
<code>Performance_schema_session_connect_attrs_lost</code></a>.
Если это значение является отличным от нуля, Вы можете хотеть установить
<a href="#sysvar_performance_schema_session_connect_attrs_size">
<code>performance_schema_session_connect_attrs_size</code></a>
к несколько большему значению.</p></li>

<li><a name="statvar_Performance_schema_socket_classes_lost"></a>
<a href="#statvar_Performance_schema_socket_classes_lost">
<code>Performance_schema_socket_classes_lost</code></a></p>
<p>Сколько инструментов сокета не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_socket_instances_lost"></a>
<a href="#statvar_Performance_schema_socket_instances_lost">
<code>Performance_schema_socket_instances_lost</code></a></p>
<p>Сколько инструментальных случаев сокета не могло быть создано.</li>

<li><a name="statvar_Performance_schema_stage_classes_lost"></a>
<a href="#statvar_Performance_schema_stage_classes_lost">
<code>Performance_schema_stage_classes_lost</code></a></p>
<p>Сколько инструментов этапа не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_statement_classes_lost"></a>
<a href="#statvar_Performance_schema_statement_classes_lost">
<code>Performance_schema_statement_classes_lost</code></a></p>
<p>Сколько инструментов запросы не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_table_handles_lost"></a>
<a href="#statvar_Performance_schema_table_handles_lost">
<code>Performance_schema_table_handles_lost</code></a></p>
<p>Сколько табличных инструментальных случаев не могло быть открыто.
Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_table_handles">
<code>performance_schema_max_table_handles</code></a>
является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_table_instances_lost"></a>
<a href="#statvar_Performance_schema_table_instances_lost">
<code>Performance_schema_table_instances_lost</code></a></p>
<p>Сколько табличных инструментальных случаев не могло быть создано.</li>

<li><a name="statvar_Performance_schema_table_lock_stat_lost"></a>
<a href="#statvar_Performance_schema_table_lock_stat_lost">
<code>Performance_schema_table_lock_stat_lost</code></a></p>
<p>Число таблиц, для которых были потеряны статистические данные блокировки.
Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_table_lock_stat">
<code>performance_schema_max_table_lock_stat</code></a>
является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_thread_classes_lost"></a>
<a href="#statvar_Performance_schema_thread_classes_lost">
<code>Performance_schema_thread_classes_lost</code></a></p>
<p>Сколько инструментов потока не могло быть загружено.</li>

<li><a name="statvar_Performance_schema_thread_instances_lost"></a>
<a href="#statvar_Performance_schema_thread_instances_lost">
<code>Performance_schema_thread_instances_lost</code></a></p>
<p>Число случаев потока, которые не могли быть инструментованы в
<a href="#threads-table"><code>threads</code></a>.
Это может быть отличным от нуля, если значение
<a href="#sysvar_performance_schema_max_thread_instances">
<code>performance_schema_max_thread_instances</code></a>
является слишком маленьким.</li>

<li><a name="statvar_Performance_schema_users_lost"></a>
<a href="#statvar_Performance_schema_users_lost"><code>
Performance_schema_users_lost</code></a></p>
<p>Сколько раз строка не могла быть добавлена к
<a href="#users-table"><code>users</code></a>, потому что
она была полна.</p></li></ul>

<p>Для информации об использовании этих переменных, чтобы проверить
статус Performance Schema, см.
<a href="#performance-schema-status-monitoring">раздел 23.5</a>.
</p>

<h2><a name="performance-schema-memory-model"></a>23.14.
Модель распределения памяти Performance Schema</h2>
<p>Performance Schema использует эту модель распределения памяти:</p>

<ul><li><p>Может выделить память при запуске сервера.</li>
<li>Может выделить дополнительную память во время работы сервера.</li>
<li>Никогда не освобождайте память во время работы сервера (хотя это могло
бы быть переработано).</li>
<li>Освобождает всю память при завершении работы.</p></li></ul>

<p>Результат состоит в том, чтобы ослабить ограничения памяти так, чтобы
Performance Schema могла использоваться с меньшим количеством конфигурации, и
уменьшить расход памяти так, чтобы потребление масштабировалось с загрузкой
сервера. Используемая память зависит от загрузки, фактически замеченной, не
оцененной загрузки или явно сконфигурированный.</p>

<p>Несколько измеряющих параметров Performance Schema автомасштабируются и не
должны быть сконфигурированы явно, если Вы не хотите установить явный предел
на распределение памяти:
<pre>
performance_schema_accounts_size
performance_schema_hosts_size
performance_schema_max_cond_instances
performance_schema_max_file_instances
performance_schema_max_index_stat
performance_schema_max_metadata_locks
performance_schema_max_mutex_instances
performance_schema_max_prepared_statements_instances
performance_schema_max_program_instances
performance_schema_max_rwlock_instances
performance_schema_max_socket_instances
performance_schema_max_table_handles
performance_schema_max_table_instances
performance_schema_max_table_lock_stat
performance_schema_max_thread_instances
performance_schema_users_size
</pre>

<p>Для автомасштабируемого параметра конфигурация работает так:</p>
<ul><li><p>С набором значений -1 (по умолчанию), автомасштабируется параметр:
</p>
<ul><li><p>Соответствующий внутренний буфер пуст первоначально, и никакая
память не выделена.</li>

<li>Поскольку Performance Schema собирает данные, память выделена в
соответствующем буфере. Размер буфера не ограничен, и
может вырасти с загрузкой.</p></li></ul></li>

<li><p>С набором значений 0:</p>
<ul><li><p>Соответствующий внутренний буфер пуст первоначально, и никакая
память не выделена.</p></li></ul></li>

<li><p>С набором значений <em><code>N</code></em> &gt; 0:</p>
<ul><li><p>Соответствующий внутренний буфер пуст первоначально, и никакая
память не выделена.</li>

<li>Поскольку Performance Schema собирает данные, память выделена в
соответствующем буфере, пока размер буфера не достигает
<em><code>N</code></em>.</li>

<li>Как только размер буфера достигает <em><code>N</code></em>,
больше памяти не выделено. Данные, собранные Performance Schema
для этого буфера, потеряны, и любой соответствующий счетчик
потерь постепенно увеличен.</p></li></ul></li></ul>

<p>Чтобы видеть, сколько памяти использует Performance Schema,
проверьте инструменты, разработанные с этой целью. Performance Schema
выделяет память внутренне и связывает каждый буфер со специализированным
инструментом так, чтобы потребление памяти могло быть прослежено к отдельным
буферам. Инструменты с приставкой <code>memory/performance_schema/</code>
покажут, сколько памяти выделено для этих внутренних буферов. Буферы
глобальны для сервера, таким образом, инструменты выведены на экран только в
таблице <a href="#memory-summary-tables">
<code>memory_summary_global_by_event_name</code></a>, а не в других таблицах
<code>memory_summary_by_<em><code>xxx</code></em>_by_event_name</code>.</p>

<p>Этот запрос показывает информацию, связанную с инструментами памяти:
<pre>
SELECT * FROM memory_summary_global_by_event_name
         WHERE EVENT_NAME LIKE 'memory/performance_schema/%';
</pre>

<h2><a name="performance-schema-and-plugins"></a>23.15.
Performance Schema и плагины</h2>
<p>Удаление плагина с <a href="sql.htm#uninstall-plugin"><code>UNINSTALL
PLUGIN</code></a> не затрагивает информацию, уже собранную для кода в этом
плагине. Время на выполнение кода, в то время как плагин был загружен, все
еще учтено, даже если плагин позже выгружен. Связанная информация о событии,
включая совокупную информацию, остается читаемой в таблицах базы данных
<code>performance_schema</code>. Для дополнительной информации об эффекте
установки и удаления плагина см.
<a href="#performance-schema-status-monitoring">раздел 23.5</a>.
</p>

<p>Конструктор плагина, который инструментует код, должен зарегистрировать
его характеристики инструментовки, чтобы позволить тем, кто загружает плагин,
составлять его требования. Например, имеющий отношение к третьей стороне
механизм хранения должен включать в документацию, в каком количестве памяти
механизм нуждается для mutex и других инструментов.</p>

<h2><a name="performance-schema-examples"></a>23.16.
Применение Performance Schema, чтобы диагностировать проблемы</h2>
<p>Performance Schema инструмент, чтобы помочь DBA сделать работу, проводя
реальные измерения вместо примерных. Этот раздел, демонстрирует некоторые
способы использовать Performance Schema с этой целью. Обсуждение здесь
полагается на использование фильтрации событий, которая описана в
<a href="#performance-schema-filtering">разделе 23.2.3.2</a>.</p>

<p>Следующий пример обеспечивает одну методологию, которую Вы можете
использовать, чтобы проанализировать повторимую проблему, такую как
исследование исполнительного узкого места. Чтобы начать, у Вас должен быть
повторимый случай использования, где работу считают <span>слишком медленной
</span> и нуждающейся в оптимизации, и Вы должны включить всю инструментовку
(никакой предварительной фильтрации вообще).</p>

<ol type="1"><li><p>Выполните случай использования.</li>
<li>Используя таблицы Performance Schema, проанализируйте первопричину
исполнительной проблемы. Этот анализ положится в большой
степени на постфильтрацию.</li>

<li>Для проблемных областей, которые исключены, отключите соответствующие
инструменты. Например, если анализ показывает, что проблема не связана с
вводом/выводом файла в особом механизме хранения, отключите инструменты
ввода/вывода файла для этого механизма. Затем усеките историю и сводные
таблицы, чтобы удалить ранее собранные события.</li>
<li>Повторите процесс в шаге 1.</p>

<p>При каждой итерации, вывод Performance Schema, особенно таблица
<a href="#events-waits-history-long-table"><code>
events_waits_history_long</code></a>
будет содержать всё меньше и меньше <span>шума</span>, вызванным незначащими
инструментами, а поскольку у этой таблицы есть фиксированный размер, она
будет содержать все больше данных, относящихся к анализу проблемы.</p>

<p>При каждой итерации исследование должно вести ближе и ближе к первопричине
проблемы, поскольку соотношение <span>сигнал/шум</span>
улучшится, делая легче анализ.</li>

<li>Как только первопричина исполнительного узкого места идентифицирована,
примите соответствующие меры по ликвидации последствий, такие как:</p>
<ul><li><p>Настройте параметры сервера (размеры кэша, памяти и т.д.).</li>
<li>Настройте запрос по-другому.</li>
<li>Настройте схему базы данных (таблицы, индексы и т.д.).</li>
<li>Настройте код (это относится только к механизму хранения
или разработчикам сервера).</p></li></ul></li>
<li><p>Начните снова с шага 1, чтобы видеть эффекты изменений.</p></li></ol>

<p>Столбцы <code>mutex_instances.LOCKED_BY_THREAD_ID</code> и
<code>rwlock_instances.WRITE_LOCKED_BY_THREAD_ID</code> чрезвычайно важны для
исследования исполнительных узких мест или тупиков. Это сделано возможным
инструментовкой Performance Schema следующим образом:</p>

<ol type="1"><li><p>Предположите, что поток 1
застревает, ожидая mutex.</li>
<li>Вы можете определить то, чего ждет поток:
<pre>
SELECT * FROM events_waits_current
         WHERE THREAD_ID = <em><code>thread_1</code></em>;
</pre>
<p>Скажите, что результат запроса идентифицирует, что поток ждет mutex A,
найденный в <code>events_waits_current.OBJECT_INSTANCE_BEGIN</code>.</li>

<li>Вы можете определить, какой поток держит mutex A:
<pre>
SELECT * FROM mutex_instances
         WHERE OBJECT_INSTANCE_BEGIN = <em><code>mutex_A</code></em>;
</pre>

<p>Скажите, что результат запроса идентифицирует, что это поток 2, который
держит mutex A, как найдено в
<code>mutex_instances.LOCKED_BY_THREAD_ID</code>.</li>

<li>Вы можете видеть, что делает поток 2:
<pre>
SELECT * FROM events_waits_current
         WHERE THREAD_ID = <em><code>thread_2</code></em>;
</pre></li></ol>

<h3><a name="performance-schema-query-profiling"></a>23.16.1.
Профилирование запроса, используя Performance Schema</h3>
<p>Следующий пример демонстрирует, как использовать события запросов
Performance Schema и события этапа, чтобы получить данные, сопоставимые с
профилированием информации, предоставленной <a href="sql.htm#show-profiles">
<code>SHOW PROFILES</code></a> и <a href="sql.htm#show-profile">
<code>SHOW PROFILE</code></a>.</p>

<p>Таблица <a href="#setup-actors-table"><code>setup_actors</code>
</a> может использоваться, чтобы ограничить набор исторических событий узлом,
пользователем или учетной записью, чтобы уменьшить время выполнения
и объем данных, собранный в таблицах истории. Первый шаг примера показывает,
как ограничить набор исторических событий определенному пользователю.</p>

<p>Performance Schema выводит на экран информацию о таймере событий в
пикосекундах, чтобы нормализовать данные о синхронизации к стандартному
модулю. В следующем примере <code>TIMER_WAIT</code> разделены на
1000000000000, чтобы показать данные в модулях секунд. Значения являются
также усеченными к 6 десятичным разрядам, чтобы вывести на экран данные в том
же самом формате, как <a href="sql.htm#show-profiles"><code>SHOW PROFILES
</code></a> и <a href="sql.htm#show-profile"><code>SHOW PROFILE</code></a>.
</p>

<ol type="1"><li><p>Ограничьте набор исторических событий пользователю,
который выполняет запрос. По умолчанию
<a href="#setup-actors-table"><code>setup_actors</code></a>
сконфигурирован, чтобы позволить контролировать набор исторических событий
для всех потоков переднего плана:
<pre>
mysql&gt; SELECT * FROM setup_actors;
+------+------+------+---------+---------+
| HOST | USER | ROLE | ENABLED | HISTORY |
+------+------+------+---------+---------+
| %    | %    | %    | YES     | YES     |
+------+------+------+---------+---------+
</pre>

<p>Обновите строку значения по умолчанию в
<a href="#setup-actors-table"><code>setup_actors</code></a>, чтобы
отключить сбор исторических событий для всех потоков переднего плана, и
вставить новую строку, которая позволяет контролировать и собирать
исторические события для пользователя, который выполняет запрос:
<pre>
mysql&gt; UPDATE performance_schema.setup_actors
                 SET ENABLED = 'NO', HISTORY = 'NO'
                 WHERE HOST = '%' AND USER = '%';

mysql&gt; INSERT INTO performance_schema.setup_actors(HOST,USER,ROLE,
                 ENABLED,HISTORY)
                 VALUES('localhost','test_user','%','YES','YES');
</pre>

<p>Данные в <a href="#setup-actors-table"><code>setup_actors</code>
</a> должны теперь казаться похожими на:
<pre>
mysql&gt; SELECT * FROM performance_schema.setup_actors;
+-----------+-----------+------+---------+---------+
| HOST      | USER      | ROLE | ENABLED | HISTORY |
+-----------+-----------+------+---------+---------+
| %         | %         | %    | NO      | NO      |
| localhost | test_user | %    | YES     | YES     |
+-----------+-----------+------+---------+---------+
</pre></li>

<li>Гарантируйте, что запрос и инструментовка включены, обновляя
<a href="#setup-instruments-table"><code>setup_instruments</code>
</a>. Некоторые инструменты могут уже быть включены по умолчанию.
<pre>
mysql&gt; UPDATE performance_schema.setup_instruments SET ENABLED = 'YES',
                 TIMED = 'YES' WHERE NAME LIKE '%statement/%';
mysql&gt; UPDATE performance_schema.setup_instruments SET ENABLED = 'YES',
                 TIMED = 'YES' WHERE NAME LIKE '%stage/%';
</pre></li>

<li>Гарантируйте, что потребители <code>events_statements_*</code> и
<code>events_stages_*</code> включены. Некоторые потребители уже
включены по умолчанию.
<pre>
mysql&gt; UPDATE performance_schema.setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%events_statements_%';
mysql&gt; UPDATE performance_schema.setup_consumers SET ENABLED = 'YES'
                 WHERE NAME LIKE '%events_stages_%';
</pre></li>

<li>Под учетной записью пользователя выполните запрос, который Вы
хотите профилировать. Например:
<pre>
mysql&gt; SELECT * FROM employees.employees WHERE emp_no = 10001;
+--------+------------+------------+-----------+--------+------------+
| emp_no | birth_date | first_name | last_name | gender | hire_date  |
+--------+------------+------------+-----------+--------+------------+
|  10001 | 1953-09-02 | Georgi     | Facello   | M      | 1986-06-26 |
+--------+------------+------------+-----------+--------+------------+
</pre></li>

<li>Идентифицируйте <code>EVENT_ID</code> из запроса, запрашивая таблицу
<a href="#events-statements-history-long-table"><code>
events_statements_history_long</code></a>. Этот шаг подобен выполнению
<a href="sql.htm#show-profiles"><code>SHOW PROFILES</code></a>, чтобы
идентифицировать <code>Query_ID</code>. Следующий запрос производит вывод,
подобный <a href="sql.htm#show-profiles"><code>SHOW PROFILES</code></a>:
<pre>
mysql&gt; SELECT EVENT_ID, TRUNCATE(TIMER_WAIT/1000000000000,6)
                 as Duration, SQL_TEXT
                 FROM performance_schema.events_statements_history_long
                 WHERE SQL_TEXT like '%10001%';
+----------+----------+--------------------------------------------------------+
| event_id | duration | sql_text                                               |
+----------+----------+--------------------------------------------------------+
| 31       | 0.028310 | SELECT * FROM employees.employees WHERE emp_no = 10001 |
+----------+----------+--------------------------------------------------------+
</pre></li>

<li>Запросите таблицу <a href="#events-stages-history-long-table">
<code>events_stages_history_long</code></a>, чтобы получить события этапа
запроса. Этапы соединены с запросами, используя вложение событий. У каждого
отчета этапа событий есть столбец <code>NESTING_EVENT_ID</code>, который
содержит <code>EVENT_ID</code> из родительского запроса.
<pre>
mysql&gt; SELECT event_name AS Stage, TRUNCATE(TIMER_WAIT/1000000000000,6)
                 AS Duration
                 FROM performance_schema.events_stages_history_long
                 WHERE NESTING_EVENT_ID=31;
+--------------------------------+----------+
| Stage                          | Duration |
+--------------------------------+----------+
| stage/sql/starting             | 0.000080 |
| stage/sql/checking permissions | 0.000005 |
| stage/sql/Opening tables       | 0.027759 |
| stage/sql/init                 | 0.000052 |
| stage/sql/System lock          | 0.000009 |
| stage/sql/optimizing           | 0.000006 |
| stage/sql/statistics           | 0.000082 |
| stage/sql/preparing            | 0.000008 |
| stage/sql/executing            | 0.000000 |
| stage/sql/Sending data         | 0.000017 |
| stage/sql/end                  | 0.000001 |
| stage/sql/query end            | 0.000004 |
| stage/sql/closing tables       | 0.000006 |
| stage/sql/freeing items        | 0.000272 |
| stage/sql/cleaning up          | 0.000001 |
+--------------------------------+----------+
</pre></li></ol>

<h2><a name="performance-schema-variable-table-migration"></a>23.17.
Переход к таблицам переменных системы и состояния Performance Schema</h2>
<p><code>INFORMATION_SCHEMA</code> имеет таблицы, которые содержат информацию
о переменных состояния (см. разделы <a href="inform.htm#variables-table">
22.10</a> и <a href="inform.htm#status-table">22.9</a>). Performance Schema
также содержит таблицы переменных системы и состояния (см. разделы
<a href="#performance-schema-system-variable-tables">23.9.13</a> и
<a href="#performance-schema-status-variable-tables">23.9.14</a>).
Таблицы Performance Schema предназначены, чтобы заменить
<code>INFORMATION_SCHEMA</code>, которые устарели с MySQL 5.7.6 и
будут удалены в будущем выпуске MySQL.</p>

<p>Этот раздел описывает намеченный миграционный путь с
<code>INFORMATION_SCHEMA</code> к соответствующим таблицам Performance
Schema. Разработчики приложений должны использовать эту информацию в качестве
руководства относительно изменений, требуемых, чтобы получить доступ к
системе и переменным состояния в MySQL.</p>

<p><span><strong>MySQL 5.6</strong></span></p>
<p>В MySQL 5.6 информация о переменных состояния доступна
через команду <code>SHOW</code>:
<pre>
SHOW VARIABLES
SHOW STATUS
</pre>

<p>И через таблицы <code>INFORMATION_SCHEMA</code>:
<pre>
INFORMATION_SCHEMA.GLOBAL_VARIABLES
INFORMATION_SCHEMA.SESSION_VARIABLES
INFORMATION_SCHEMA.GLOBAL_STATUS
INFORMATION_SCHEMA.SESSION_STATUS
</pre>

<p><span><strong>MySQL 5.7</strong></span></p>
<p>С MySQL 5.7.6 Performance Schema включает эти таблицы как новые источники
информации о переменных состояния:
<pre>
performance_schema.global_variables
performance_schema.session_variables
performance_schema.variables_by_thread
performance_schema.global_status
performance_schema.session_status
performance_schema.status_by_thread
performance_schema.status_by_account
performance_schema.status_by_host
performance_schema.status_by_user
</pre>

<p>MySQL 5.7.6 также добавляет системную переменную
<a href="server.htm#sysvar_show_compatibility_56"><code>show_compatibility_56
</code></a>, чтобы управлять, как сервер делает доступной
информацию о переменных состояния.</p>

<p>Когда <a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56</code></a> <code>ON</code>, совместимость с MySQL 5.6
включена. Более старая система и источники переменных состояния
(запросы <code>SHOW</code>, таблицы <code>INFORMATION_SCHEMA</code>)
доступны с семантикой, идентичной MySQL 5.6. Приложения должны работать без
изменений кода и должен видеть те же самые имена переменных и значения, как в
MySQL 5.6. Предупреждения происходят при этих обстоятельствах:</p>
<ul><li><p>Предупреждение поднято при выборе из
таблиц <code>INFORMATION_SCHEMA</code>.</p></li></ul>

<p>Когда <a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56</code></a> <code>OFF</code>,
совместимость с MySQL 5.6 отключена и несколько результатов изменены.
Приложения должны быть пересмотрены следующим образом, чтобы
работать должным образом:</p>

<ul><li><p>Выбор из таблицы <code>INFORMATION_SCHEMA</code>
производит ошибку. Приложения с доступом к
<code>INFORMATION_SCHEMA</code> должны быть пересмотрены, чтобы использовать
соответствующие таблицы Performance Schema.</p>

<p>До MySQL 5.7.9 выбор из <code>INFORMATION_SCHEMA</code>
производит пустой набор результатов плюс предупреждение об устаревании.
Это не было достаточным уведомлением, чтобы сигнализировать о потребности
мигрировать к соответствующей системе Performance Schema, если
<a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56=OFF</code></a>. Производство ошибки в MySQL 5.7.9 и
выше делает более очевидным, что приложение работает при условиях, которые
требуют модификации, так же как где проблема заключается.</li>

<li>Вывод для <code>SHOW</code> произведен, используя основные таблицы
Performance Schema. Приложения, написанные, чтобы использовать эти запросы,
могут все еще использовать их.</li>

<li>Эти переменные состояния <code>Slave_<em><code>xxx</code></em></code>
становятся недоступными через <a href="sql.htm#show-status"><code>SHOW STATUS
</code></a>:
<pre>
Slave_heartbeat_period
Slave_last_heartbeat
Slave_received_heartbeats
Slave_retried_transactions
Slave_running
</pre>

<p>Приложения, которые используют эти переменные состояния, должны быть
пересмотрены, чтобы получить эту информацию, используя связанные с
репликацией таблицы Performance Schema.</p></li></ul>

<p><span><strong>Миграция и привилегии</strong></span></p>
<p>Первоначально, с введением Performance Schema в MySQL 5.7.6, доступ к тем
таблицам требовал привилегии <a href="security.html#priv_select"><code>SELECT
</code></a>, так же, как для других таблиц Performance Schema.
Однако, у этого было последствие, когда
<a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56=OFF</code></a>,
<a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a> и
<a href="sql.htm#show-status"><code>SHOW STATUS</code></a> также потребовали
привилегию <a href="security.html#priv_select"><code>SELECT</code></a>:
с отключенной совместимостью вывод для тех запросов, был взят из таблиц
Performance Schema <a href="#performance-schema-system-variable-tables"><code>
global_variables</code></a>,
<a href="#performance-schema-system-variable-tables"><code>
session_variables</code></a>,
<a href="#performance-schema-status-variable-tables"><code>
global_status</code></a> и
<a href="#performance-schema-status-variable-tables"><code>
session_status</code></a>.</p>

<p>Эти таблицы Performance Schema доступны без привилегии
<a href="security.html#priv_select"><code>SELECT</code></a>. Следовательно,
<a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a> и
<a href="sql.htm#show-status"><code>SHOW STATUS</code></a> не требуют
привилегий на основных таблицах Performance Schema, из которых их вывод
произведен, когда <a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56=OFF</code></a>.</p>

<p><span><strong>Вне MySQL 5.7</strong></span></p>
<p>В будущем выпуске MySQL переменные таблицы <code>INFORMATION_SCHEMA</code>
и переменная <a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56</code></a> будут удалены, и вывод <code>SHOW</code>
всегда будет основан на основных таблицах Performance Schema.</p>

<p>Приложения, которые были пересмотрены, чтобы работать в MySQL 5.7, когда
<a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56=OFF</code></a>, должны работать без дальнейших
изменений, за исключением того, что не будет возможно проверить или
установить <a href="server.htm#sysvar_show_compatibility_56"><code>
show_compatibility_56</code></a> потому, что это не будет существовать.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
