<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 19. Репликация</title>
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="replication"></a>Глава 19. Репликация</h1>
<p>Репликация позволяет данным от одного сервера базы данных MySQL (ведущее
устройство) быть скопированными к одному или более серверам базы данных MySQL
(ведомые устройства). Репликация является асинхронной по умолчанию,
ведомые устройства не должны быть соединены надолго, чтобы получить
обновления от ведущего устройства. В зависимости от конфигурации, Вы можете
копировать все базы данных, выбранные базы данных или даже выбранные таблицы
в пределах базы данных.</p>

<p>Преимущества репликации в MySQL включают:</p>
<ul><li><p>Решения масштаба это распространение загрузки среди многократных
ведомых устройств, чтобы улучшить работу. В этой окружающей среде все записи
и обновления должны иметь место на главном сервере. Чтения, однако, могут
иметь место на одном или более ведомых устройствах. Эта модель может улучшить
скорость записи (так как ведущее устройство посвящено обновлениям), резко
увеличивая скорость чтения через увеличивающееся число ведомых устройств.
</li>

<li>Защита информации, потому что данные копируются к ведомому устройству, и
ведомое устройство может сделать паузу в процессе репликации, возможно
выполнить резервные службы на ведомое устройство,
не повреждая основные данные.</li>

<li>Аналитика: живые данные могут быть созданы на ведущем устройстве, в то
время как анализ информации может иметь место на ведомом устройстве, не
затрагивая мощности ведущего устройства.</li>

<li>Дальнее распределение данных: Вы можете использовать репликацию, чтобы
создать местную копию данных для удаленного сайта, чтобы использовать без
постоянного доступа к ведущему устройству.</p></li></ul>

<p>См. <a href="#replication-solutions">раздел 19.3</a>.</p>
<p>MySQL 8.0 понимает различные методы репликации. Традиционный метод основан
на мультиплицировании событий от двоичного журнала ведущего устройства и
требует, чтобы файлы системного журнала и позиции в них были синхронизированы
между ведущим устройством и ведомым устройством. Более новый метод,
основанный на <span>глобальных операционных идентификаторах</span> (GTID),
является транзакционным и поэтому не требует работы с файлами системного
журнала или позициями в пределах этих файлов, что очень упрощает много общих
задач репликации. Репликация используя GTIDs гарантирует последовательность
между ведущим устройством и ведомым устройством, пока все транзакции,
переданные на ведущем устройстве, были также применены на ведомое устройство.
Для получения дополнительной информации о GTIDs в MySQL см.
<a href="#replication-gtids">раздел 19.1.3</a>.</p>

<p>Репликация в MySQL поддерживает различные типы синхронизации. Оригинальный
тип синхронизации это односторонний, асинхронный, в котором один сервер
действует как ведущее устройство, в то время как один или более других
серверов действуют как ведомые устройства. В MySQL 8.0 полусинхронная
репликация поддержана в дополнение к встроенной асинхронной репликации.
С полусинхронной репликацией передача выполнена на основных блоках прежде,
чем возвратиться к сеансу, который выполнил транзакцию, пока по крайней мере
одно ведомое устройство не признает, что получило и зарегистрировало события
для транзакции, см. <a href="#replication-semisync">раздел 19.3.10
</a>. MySQL 8.0 также поддерживает отложенную репликацию таким образом, что
ведомый сервер сознательно отстает от ведущего устройства, по крайней мере на
указанное количество времени, см.
<a href="#replication-delayed">раздел 19.3.11</a>.
Для сценариев, где <span><em>синхронная</em></span>
репликация требуется, используйте MySQL Cluster (см.
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top">MySQL Cluster NDB 7.5</a>).</p>

<p>Есть много решений, доступных для репликации между серверами, и лучший
метод, чтобы использовать зависит от присутствия данных и типов механизма,
которые Вы используете. Для получения дополнительной информации о доступных
параметрах см. <a href="#replication-howto">раздел 19.1.2</a>.</p>

<p>Есть два основных типа формата репликации, основанная на запросе и на
строке. Вы можете также использовать также третий, смешанную репликацию.
См. <a href="#replication-formats">раздел 19.2.1</a>.</p>

<p>Репликацией управляют через многие различные опции
и переменные. Для получения дополнительной информации см.
<a href="#replication-options">раздел 19.1.6</a>.</p>

<p>Вы можете использовать репликацию, чтобы решить много различных проблем,
включая резервное копирование различных баз данных, и как часть решения
проблем с восстановлением после системных отказов. Для информации о том, как
обратиться к этим проблемам см.
<a href="#replication-solutions">раздел 19.3</a>.</p>

<p>Для примечаний и подсказок относительно того, как различные типы данных и
запросы обработаны во время репликации, включая детали особенностей
репликации, совместимости вариантов, обновления, потенциальные проблемы и их
разрешение см. <a href="#replication-notes">раздел 19.4</a>.</p>

<h2><a name="replication-configuration"></a>19.1. Конфигурирование репликации
</h2>
<p>Этот раздел описывает, как сконфигурировать различные типы репликации,
доступные в MySQL, и включает установку и конфигурацию, требуемую для
окружающей среды репликации, включая постепенные инструкции для того, чтобы
создать новую окружающую среду репликации. Главные компоненты этого раздела:
</p>

<ul><li><p>Для руководства по созданию двух или больше серверов для
репликации, используя двоичные позиции файла системного журнала
<a href="#replication-howto">раздел 19.1.2</a>
имеет дело с конфигурацией серверов и обеспечивает методы для того, чтобы они
скопировали данные между ведущим устройством и ведомыми устройствами.</li>

<li>Для руководства по созданию двух или больше серверов для
репликации, используя транзакции GTID
<a href="#replication-gtids">раздел 19.1.3</a>
имеет дело с конфигурацией серверов.</li>

<li>События в двоичном журнале зарегистрированы, используя много форматов.
Они упоминаются как основанная на запросе репликация (SBR) или основанная на
строке репликация (RBR). Третий тип, репликация смешанного формата (MIXED),
использует SBR или RBR автоматически, чтобы использовать в своих интересах
выгоду форматов SBR и RBR. Различные форматы обсуждены в
<a href="#replication-formats">разделе 19.2.1</a>.</li>

<li>Подробная информация о различных параметрах конфигурации и переменных,
которые относятся к репликации, обеспечена в
<a href="#replication-options">разделе 19.1.6</a>.</li>

<li>После того, как запущен, процесс репликации должен потребовать небольшого
контроля. Для советов относительно общих задач, которые Вы можете хотеть
выполнить, см. <a href="#replication-administration">раздел 19.1.7
</a>.</p></li></ul>

<h3><a name="binlog-replication-configuration-overview"></a>19.1.1.
Краткий обзор конфигурации репликации на основе
двоичной позиции файла системного журнала</h3>
<p>Этот раздел описывает репликацию между серверами MySQL, основанными на
двоичном методе позиции файла системного журнала, где случай MySQL,
действующий в качестве ведущего устройства (источник изменений базы данных),
пишет обновления и изменения как <span><span>события</span></span> в двоичный
журнал. Информация в двоичном журнале хранится в различных форматах
журналирования согласно зарегистрированным изменениям базы данных. Ведомые
устройства сконфигурированы, чтобы считать двоичной журнал от ведущего
устройства, и запускать события в местной базе
данных ведомого устройства.</p>

<p>Каждое ведомое устройство получает копию всего содержания двоичного
журнала. Обязанность ведомого устройства решить, какие запросы в двоичном
журнале должны быть выполнены. Если Вы не определяете иначе, все события в
основном двоичном журнале запущены на ведомом устройстве. Если требуется, Вы
можете сконфигурировать ведомое устройство, чтобы обработать только события,
которые относятся к особым базам данных или таблицам.</p>

<p>Вы не можете сконфигурировать ведущее устройство, чтобы зарегистрировать
только определенные события.</p>
<p>Каждое ведомое устройство ведет учет двоичных координат журнала:
имя файла и позиция в пределах файла, который это считало и обработало от
ведущего устройства. Это означает, что многократные ведомые устройства могут
быть соединены с ведущим устройством и выполнять различные части того же
самого двоичного журнала. Поскольку ведомые устройства управляют этим
процессом, отдельные ведомые устройства могут быть соединены и разъединены от
сервера, не затрагивая работу ведущего устройства. Кроме того, потому что
каждое ведомое устройство делает запись текущей позиции в пределах двоичного
журнала, для ведомых устройств возможно быть разъединенным, повторно
соединиться и затем продолжить обрабатывать.</p>

<p>Ведущее устройство и каждое ведомое устройство должны быть
сконфигурированы с уникальным ID (используя опцию
<a href="#option_mysqld_server-id"><code>server-id</code></a>).
Кроме того, каждое ведомое устройство должно быть сконфигурировано с
информацией об основном имени хоста, имени файла системного журнала и позиции
в пределах того файла. Этими деталями можно управлять изнутри сеанса MySQL,
используя команду <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO
</code></a> на ведомом устройстве. Детали сохранены в пределах основного
репозитария информации ведомого устройства, который может быть файлом или
таблицей (см. <a href="#slave-logs">раздел 19.2.4</a>).</p>

<h3><a name="replication-howto"></a>19.1.2.
Установка двоичной позиции файла системного журнала</h3>
<p>Этот раздел описывает, как настроить сервер MySQL, чтобы использовать
позиции двоичного файла системного журнала. Есть много различных методов для
того, чтобы настроить репликацию, и точный метод, чтобы использовать, зависит
от того, как Вы настраиваете репликацию, и есть ли у Вас уже данные в
пределах Вашей основной базы данных.</p>

<p>Есть некоторые задачи, которые характерны для всех установок:</p>
<ul><li><p>На ведущем устройстве Вы должны включить двоичное
журналирование и сконфигурировать уникальный ID сервера. Это могло бы
потребовать перезапуска сервера. См.
<a href="#replication-howto-masterbaseconfig">раздел 19.1.2.1</a>.
</li>

<li>На каждом ведомом устройстве, которое Вы хотите соединить с ведущим
устройством, Вы должны сконфигурировать уникальный ID сервера. Это могло бы
потребовать перезапуска сервера. См.
<a href="#replication-howto-slavebaseconfig">раздел 19.1.2.2</a>.
</li>

<li>Произвольно, создайте отдельного пользователя для своих ведомых
устройств, чтобы использовать во время аутентификации с ведущим устройством,
читая двоичной журнал для репликации. См.
<a href="#replication-howto-repuser">раздел 19.1.2.3</a>.</li>

<li>Прежде, чем создать снимок данных или запустить процесс репликации
на ведущем устройстве Вы должны сделать запись текущей позиции в двоичном
журнале. Вы нуждаетесь в этой информации, конфигурируя ведомое устройство
так, чтобы ведомое устройство знало, где в пределах двоичного журнала
начинать запускать события. См.
<a href="#replication-howto-masterstatus">раздел 19.1.2.4</a>.
</li>

<li>Если Вы уже имеете данные по ведущему устройству и хотите использовать
их, чтобы синхронизировать ведомое устройство, Вы должны создать снимок
данных, чтобы скопировать данные к ведомому устройству. Механизм хранения,
который Вы используете, оказывает влияние на то, как Вы создаете снимок.
Когда Вы используете <a href="storage.htm#myisam-storage-engine"><code>MyISAM
</code></a>, Вы должны прекратить обрабатывать запросы, чтобы получить
блокировку чтения, затем получить текущие двоичные координаты журнала и
вывести в дамп данные прежде, чем разрешить ведущему устройству продолжать
выполнять запросы. Если Вы не остановите выполнение запросов, то дамп данных
и основная информация о статусе не будут соответствовать, приводя к
непоследовательным или поврежденным базам данных на ведомых устройствах.
Для получения дополнительной информации о мультиплицировании см.
<a href="#replication-howto-masterstatus">раздел 19.1.2.4</a>.
Если Вы используете <a href="innodb.htm"><code>InnoDB</code></a>,
Вы не нуждаетесь в блокировке чтения, снимок данных достаточен. Для получения
дополнительной информации см.
<a href="innodb.htm#innodb-and-mysql-replication">раздел 16.18</a>.</li>

<li>Сконфигурируйте ведомое устройство с настройками для того, чтобы
соединиться с ведущим устройством, такими как имя хоста, параметры
входа в систему, двоичное имя файла системного журнала и позиция. См.
<a href="#replication-howto-slaveinit">раздел 19.1.2.7</a>.
</p></li></ul>

<p>Определенные шаги в пределах процесса установки требуют привилегии
<a href="security.html#priv_super"><code>SUPER</code></a>. Если у Вас нет
этой привилегии, может быть невозможно включить репликацию.</p>

<p>После конфигурирования основных опций, выберите свой сценарий:</p>
<ul><li><p>Чтобы настроить репликацию для новой установки ведущего устройства
и ведомых устройств, которые не содержат данных, см.
<a href="#replication-howto-newservers">раздел 19.1.2.6.1</a>.
</li>

<li>Чтобы настроить репликацию нового ведущего устройства, использующего
данные от существующего сервера MySQL, см.
<a href="#replication-howto-existingdata">раздел 19.1.2.6.2</a>.
</li>

<li>Чтобы добавить ведомые устройства репликации существующей окружающей
среды репликации, см.
<a href="#replication-howto-additionalslaves">раздел 19.1.2.8</a>.
</p></li></ul>

<p>Прежде, чем управлять серверами репликации MySQL, читайте всю эту главу и
попробуйте все запросы, упомянутые в разделах
<a href="sql.htm#replication-master-sql">14.4.1</a> и
<a href="sql.htm#replication-slave-sql">14.4.2</a>.
Также ознакомьтесь с опциями запуска репликации, описанными в
<a href="#replication-options">разделе 19.1.6</a>.</p>

<h4><a name="replication-howto-masterbaseconfig"></a>19.1.2.1.
Установка ведущей конфигурации репликации</h4>
<p>Чтобы сконфигурировать ведущее устройство, чтобы использовать двоичную
позицию файла системного журнала, Вы должны включить двоичное журналирование
и установить уникальный ID сервера. Если это не было уже сделано,
перезапуск сервера требуется.</p>

<p>Двоичное журналирование <span><em>должно</em></span> быть включено на
ведущем устройстве, потому что двоичной журнал это основание для того, чтобы
копировать изменения от ведущего устройства к его ведомым устройствам. Если
двоичное журналирование не включено на ведущем устройстве, использующем опцию
<code>log-bin</code>, репликация невозможна.</p>

<p>Каждый сервер в пределах группы репликации должен быть сконфигурирован с
уникальным ID. Этот ID используется, чтобы идентифицировать отдельные серверы
в пределах группы, и должно быть положительным целым числом между 1 и
(2<sup>32</sup>)-1. То, как Вы организуете и выбираете числа,
является Вашим выбором.</p>

<p>Чтобы сконфигурировать двоичной журнал и опции ID
сервера, закройте сервер MySQL и отредактируйте файл <code>my.cnf</code> или
<code>my.ini</code>. В раздел <code>[mysqld]</code>
конфигурационного файла добавляют опции <code>log-bin</code> и
<code>server-id</code>. Если эти опции уже существуют, но прокомментированы,
раскомментируют опции и изменяют их согласно Вашим потребностям. Например,
чтобы включить двоичное журналирование, используя файл системного журнала
с префиксом имени <code>mysql-bin</code> и сконфигурировать ID сервера 1,
используйте эти строки:
<pre>
[mysqld]
log-bin=mysql-bin
server-id=1
</pre>

<p>После произведения изменений, перезапустите сервер.</p>
<p>Следующие опции оказывают влияние на эту процедуру:</p>
<ul><li><p>Если Вы опускаете <a href="#option_mysqld_server-id">
<code>server-id</code></a> (или ставите это явно к его значению по умолчанию
0), ведущее устройство отказывается от любых соединений от ведомых устройств.
</li>

<li>Для самой большой длительности и последовательности в использовании
установки репликации <a href="innodb.htm"><code>InnoDB</code></a>
с транзакциями Вы должны использовать
<code>innodb_flush_log_at_trx_commit=1</code> и <code>sync_binlog=1</code>
в <code>my.cnf</code> на ведущем устройстве.</li>

<li>Гарантируйте, что <a href="server.htm#option_mysqld_skip-networking">
<code>skip-networking</code></a> не включена на Вашем ведущем устройстве
репликации. Если сеть была отключена, ведомое устройство не может общаться с
ведущим устройством, и репликация терпит неудачу.</p></li></ul>

<h4><a name="replication-howto-slavebaseconfig"></a>19.1.2.2.
Установка ведомой конфигурации репликации</h4>
<p>У каждого ведомого устройства репликации <span><em>должно</em></span> быть
уникальное ID сервера. Если это не было сделано, эта часть ведомой установки
требует перезапуска сервера.</p>

<p>Если ведомое ID сервера не установлено, или есть конфликты
со значением, которое Вы выбрали для главного сервера, закройте ведомый
сервер и редактируйте раздел <code>[mysqld]</code>
конфигурационного файла, чтобы определить уникальное ID сервера. Например:
<pre>
[mysqld]
server-id=2
</pre>

<p>После произведения изменений, перезапустите сервер.</p>
<p>Если Вы настраиваете многократные ведомые устройства, у каждого должно
быть уникальное <a href="#option_mysqld_server-id"><code>server-id
</code></a>, которое отличается от того из ведущего устройства и от любого
другого ведомого устройства.</p>

<p>Если Вы опускаете <a href="#option_mysqld_server-id"><code>
server-id</code></a> (или ставите это явно к его значению по умолчанию 0),
ведомое устройство отказывается соединиться с ведущим устройством.</p>

<p>Вы не должны настроить двоичное журналирование на ведомом устройстве.
Однако, если Вы включаете двоичное журналирование на ведомом устройстве, Вы
можете использовать двоичный журнал ведомого устройства для резервных
копирований данных, а также использовать ведомое устройство в качестве части
более сложной топологии репликации. Например, это ведомое устройство
действует как ведущее устройство для других ведомых устройств.</p>

<h4><a name="replication-howto-repuser"></a>19.1.2.3.
Создание пользователя для репликации</h4>
<p>Каждое ведомое устройство соединяется с ведущим устройством, используя имя
пользователя MySQL и пароль, таким образом должна быть учетная запись
пользователя на ведущем устройстве, которую ведомое устройство может
использовать, чтобы соединиться. Любая учетная запись может использоваться
для этой работы, если ей предоставили привилегию
<a href="security.html#priv_replication-slave"><code>REPLICATION SLAVE</code>
</a>. Вы можете хотеть создавать различные учетки на каждое ведомое
устройство или соединяться с ведущим устройством, используя одну и
ту же учетку.</p>

<p>Хотя Вы не должны создать учетную запись определенно для репликации,
Вы должны знать, что имя пользователя репликации и пароль сохранены простым
тексте в основном файле репозитария информации или таблице (см.
<a href="#slave-logs-status">раздел 19.2.4.2</a>).
Поэтому Вы можете хотеть создать отдельную учетную запись, у которой есть
привилегии только для процесса репликации, чтобы минимизировать возможность
проблем с этой стороны.</p>

<p>Чтобы создать новую учетную запись, надо использовать
<a href="sql.htm#create-user"><code>CREATE USER</code></a>.
Чтобы предоставить этой учетной записи привилегии, требуемые для репликации,
используйте <a href="sql.htm#grant"><code>GRANT</code></a>.
Если Вы создаете учетную запись исключительно в целях репликации, та учетная
запись нуждается только в привилегии
<a href="security.html#priv_replication-slave"><code>REPLICATION SLAVE</code>
</a>. Например, чтобы настроить нового пользователя <code>repl</code>,
который может соединиться для репликации от любого узла в пределах домена
<code>mydomain.com</code>, сделайте так на ведущем устройстве:
<pre>
mysql&gt; CREATE USER 'repl'@'%.mydomain.com' IDENTIFIED BY 'slavepass';
mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.mydomain.com';
</pre>
<p>См. <a href="sql.htm#account-management-sql">раздел 14.7.1</a>.</p>

<h4><a name="replication-howto-masterstatus"></a>19.1.2.4.
Получение ведущих координат двоичного журнала</h4>
<p>Чтобы сконфигурировать ведомое устройство, чтобы запустить процесс
репликации в правильном пункте, Вы должны отметить текущие координаты
ведущего устройства в пределах его двоичного журнала.</p>

<p>Эта процедура использует
<a href="sql.htm#flush"><code>FLUSH TABLES WITH READ LOCK</code></a>,
который блокирует <a href="sql.htm#commit"><code>COMMIT</code></a>
для таблиц <a href="innodb.htm"><code>InnoDB</code></a>.</p>

<p>Чтобы получить основные двоичные координаты журнала, следуйте этим шагам:
</p>
<ol type="1"><li><p>Запустите сеанс на ведущем устройстве, соединяясь с этим
клиентом командной строки, сбросьте все таблицы и заблокируйте запросы
записи, выполняя <a href="sql.htm#flush"><code>FLUSH TABLES WITH READ LOCK
</code></a>:
<pre>
mysql&gt; FLUSH TABLES WITH READ LOCK;
</pre>

<p>Оставьте клиента, от которого Вы выполнили
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a>,
так, чтобы блокировка чтения осталась в силе. Если Вы выходите из клиента,
блокировка будет снята.</p></li>

<li>В другом сеансе на ведущем устройстве, используйте
<a href="sql.htm#show-master-status"><code>SHOW MASTER STATUS</code></a>,
чтобы определить текущие имя файла и позицию двоичного системного журнала:
<pre>
mysql &gt; SHOW MASTER STATUS;
+------------------+----------+--------------+------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+
| mysql-bin.000003 | 73       | test         | manual,mysql     |
+------------------+----------+--------------+------------------+
</pre>

<p>Столбец <code>File</code> показывает название файла системного журнала и
столбец <code>Position</code> показывает позицию в пределах файла. В этом
примере двоичный файл системного журнала <code>mysql-bin.000003</code>,
позиция 73. Сделайте запись этих значений. Вы нуждаетесь в них позже, когда
Вы настраиваете ведомое устройство. Они представляют координаты репликации, в
которых ведомое устройство должно начать обрабатывать новые обновления
от ведущего устройства.</p>

<p>Если ведущее устройство работало ранее без включенного журналирования,
имя файла системного журнала и значения позиции, выведенные на экран
<a href="sql.htm#show-master-status"><code>SHOW MASTER STATUS</code></a> или
<a href="programs.htm#mysqldump"><span><strong>mysqldump --master-data
</strong></span></a> будут пусты. В этом случае значения, которые Вы должны
использовать позже, определяя файл системного журнала ведомого устройства и
позицию, являются пустой строкой (<code>''</code>) и <code>4</code>.
</p></li></ol>

<p>У Вас теперь есть информация, которую Вы должны указать
ведомому устройству начать читать из журнала, чтобы запустить репликацию.</p>
<p>Следующий шаг зависит от того, есть ли у Вас существующие данные на
ведущем устройстве. Выберите одну из следующих опций:</p>

<ul><li><p>Если у Вас есть существующие данные, которые должны быть
синхронизированы с ведомым устройством прежде, чем Вы запустите репликацию,
оставите клиента, чтобы блокировка осталась. Это предотвращает дальнейшие
произведенные изменения, чтобы данные, скопированные ведомому устройству,
были синхронны с ведущим устройством. Продолжите двигаться к
<a href="#replication-snapshot-method">разделу 19.1.2.5</a>.</li>

<li>Если Вы настраиваете новую основную и ведомую группу репликации,
Вы можете выйти из первого сеанса, чтобы выпустить блокировку чтения. См.
раздел 19.1.2.6.1</a>.</p></li></ul>

<h4><a name="replication-snapshot-method"></a>19.1.2.5.
Выбор метода для снимков данных</h4>
<p>Если основная база данных содержит существующие данные, необходимо
скопировать эти данные к каждому ведомому устройству. Есть различные способы
вывести данные от основной базы данных. Следующие разделы
описывают возможные варианты.</p>

<p>Чтобы выбрать соответствующий метод дампа базы данных, выберите
между этими опциями:</p>
<ul><li><p>Используйте <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a>, чтобы создать дамп всех баз данных, которые Вы
хотите копировать. Это рекомендуемый метод, особенно используя
<a href="innodb.htm"><code>InnoDB</code></a>.</li>

<li>Если Ваша база данных сохранена в двоичных портативных файлах, Вы можете
скопировать файлы необработанных данных к ведомому устройству. Это может быть
более эффективным, чем использование <a href="programs.htm#mysqldump"><span>
<strong>mysqldump</strong></span></a> и импортирование файла на каждом
ведомом устройстве, потому что это пропускает обновления индексов, когда
переигрываются запросы <code>INSERT</code>. С такими механизмами хранения,
как <a href="innodb.htm"><code>InnoDB</code></a> это не рекомендуется.
</p></li></ul>

<h5><a name="replication-howto-mysqldump"></a>19.1.2.5.1.
Создание снимка данных, используя mysqldump</h5>
<p>Чтобы создать снимок данных в существующей основной базе данных,
используйте <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a>. Как только дамп данных был завершен, импортируйте эти данные в
ведомое устройство прежде, чем запустить процесс репликации.</p>

<p>Следующий пример выводит все базы данных в файл <code>dbdump.db</code>
и включает опцию <a href="programs.htm#option_mysqldump_master-data"><code>
--master-data</code></a>, которая автоматически прилагает запрос
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>,
требуемый на ведомом устройстве, чтобы запустить процесс репликации:
<pre>
shell&gt; mysqldump --all-databases --master-data &gt; dbdump.db
</pre>

<p>Если Вы не используете
<a href="programs.htm#option_mysqldump_master-data"><code>
--master-data</code></a>, необходимо заблокировать все таблицы в отдельном
сеансе вручную. См. <a href="#replication-howto-masterstatus">
раздел 19.1.2.4</a>.</p>

<p>Возможно исключить определенные базы данных из дампа, используя
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>.
Если Вы хотите выбрать, которые базы данных включать в дамп, не надо
использовать <a href="programs.htm#option_mysqldump_all-databases"><code>
--all-databases</code></a>. Выберите одну из этих опций:</p>

<ul><li><p>Исключите все таблицы базы данных опцией
<a href="programs.htm#option_mysqldump_ignore-table"><code>--ignore-table
</code></a>.</li>

<li>Назовите только те базы данных, которые Вы хотите вывести, опцией
<a href="programs.htm#option_mysqldump_databases"><code>--databases</code>
</a>.</p></li></ul>
<p>См. <a href="programs.htm#mysqldump">раздел 5.5.4</a>.</p>

<p>Чтобы импортировать данные, скопируйте файл дампа к ведомому устройству
или получите доступ к файлу от ведущего устройства, соединяясь
удаленно с ведомым устройством.</p>

<h5><a name="replication-howto-rawdata"></a>19.1.2.5.2.
Создание снимка данных, используя файлы необработанных данных</h5>
<p>Этот раздел описывает, как создать снимок данных, используя сырые файлы,
которые составляют базу данных. Использование этого метода с таблицей,
используя механизм хранения, у которого есть сложные алгоритмы кэширования,
требует дополнительные шаги, чтобы произвести снимок: начальная
команда копии могла не учесть информацию о кэше и обновления, даже если Вы
приобрели глобальную блокировку чтения. Как механизм хранения отвечает,
зависит от его способностей к восстановлению катастрофического отказа.</p>

<p>Если Вы используете <a href="innodb.htm"><code>InnoDB</code></a>,
Вы можете использовать <span><strong>mysqlbackup</strong></span> из MySQL
Enterprise Backup, чтобы произвести последовательный снимок. Эта команда
делает запись имени журнала и смещения, соответствующего снимку, который
будет использоваться на ведомом устройстве. См.
<a href="mysql.htm#mysql-enterprise-backup">раздел 27.2</a>.</p>

<p>Этот метод также не работает достоверно, если у ведущего устройства и
ведомого устройства есть различные значения для
<a href="server.htm#sysvar_ft_stopword_file"><code>ft_stopword_file</code>
</a>, <a href="server.htm#sysvar_ft_min_word_len"><code>ft_min_word_len
</code></a> или <a href="server.htm#sysvar_ft_max_word_len"><code>
ft_max_word_len</code></a> и Вы копируете таблицы,
имеющие полнотекстовый индекс.</p>

<p>Принятие вышеупомянутых исключений не относится к Вашей базе данных,
используя метод <a href="glossary.htm#glos_cold_backup">холодного
резервирования</a>, чтобы получить надежный двоичный снимок таблиц
<code>InnoDB</code>: сделайте <a href="glossary.htm#glos_slow_shutdown">
медленное завершение работы</a> MySQL Server,
затем скопируйте файлы с данными вручную.</p>

<p>Чтобы создать снимок необработанных данных
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>, когда
Ваши файлы с данными MySQL существуют на единственной файловой системе, Вы
можете использовать стандартные инструменты копирования файла, такие как
<span><strong>cp</strong></span> или
<span><strong>copy</strong></span>, удаленный инструмент, например,
<span><strong>scp</strong></span> или <span><strong>rsync</strong></span>,
инструмент архивирования, например, <span><strong>zip</strong></span> или
<span><strong>tar</strong></span>, или такой инструмент снимка файловой
системы как <span><strong>dump</strong></span>.
Если Вы копируете только определенные базы данных, копируйте только те файлы,
которые касаются тех таблиц. Для <code>InnoDB</code>
все таблицы во всех базах данных сохранены в файлах
<a href="glossary.htm#glos_system_tablespace">табличного пространства</a>,
если Вы не имеете включенной опции
<a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>.</p>

<p>Следующие файлы не требуются для репликации:</p>
<ul><li><p>Файлы, касающиеся базы данных <code>mysql</code>.</li>
<li>Основной файл репозитария информации, если используется (см.
<a href="#slave-logs">раздел 19.2.4</a>).</li>
<li>Двоичные файлы системного журнала ведущего устройства.</li>
<li>Любые файлы системного журнала реле.</p></li></ul>

<p>В зависимости от того, используете ли Вы <code>InnoDB</code>
или нет, выберите одно из следующего:</p>
<p>Если Вы используете <a href="innodb.htm"><code>InnoDB</code></a>,
чтобы получить самые последовательные результаты со снимком необработанных
данных, закрывайте главный сервер следующим образом:</p>

<ol type="1"><li><p>Приобретите блокировку чтения и получите состояние
ведущего устройства. См.
<a href="#replication-howto-masterstatus">раздел 19.1.2.4</a>.
</li>

<li>В отдельном сеансе закройте главный сервер:
<pre>
shell&gt; mysqladmin shutdown
</pre></li>

<li>Сделайте копию файлов с данными MySQL. Следующие примеры показывают
распространенные способы сделать это. Вы должны выбрать только один из них:
<pre>
shell&gt; tar cf <em><code>/tmp/db.tar</code></em> <em><code>./data</code></em>
shell&gt; zip -r <em><code>/tmp/db.zip</code></em> <em><code>./data</code></em>
shell&gt; rsync --recursive <em><code>./data</code></em> <em><code>/tmp/dbdata</code></em>
</pre></li>
<li>Перезапустите главный сервер.</p></li></ol>

<p>Если Вы не используете <a href="innodb.htm"><code>InnoDB</code></a>,
Вы можете получить снимок системы от ведущего устройства, не закрывая сервер
как описано в следующих шагах:</p>

<ol type="1"><li><p>Приобретите блокировку чтения и получите состояние
ведущего устройства. См.
<a href="#replication-howto-masterstatus">раздел 19.1.2.4</a>.
</li>

<li>Сделайте копию файлов с данными MySQL. Следующие примеры показывают
распространенные способы сделать это. Вы должны выбрать только один из них:
<pre>
shell&gt; tar cf <em><code>/tmp/db.tar</code></em> <em><code>./data</code></em>
shell&gt; zip -r <em><code>/tmp/db.zip</code></em> <em><code>./data</code></em>
shell&gt; rsync --recursive <em><code>./data</code></em> <em><code>/tmp/dbdata</code></em>
</pre></li>

<li>В клиенте, где Вы приобретали блокировку чтения, выпустите блокировку:
<pre>
mysql&gt; UNLOCK TABLES;
</pre></li></ol>
<p>Как только Вы создали архив или копию базы данных, скопируйте файлы к
каждому ведомому устройству прежде, чем запустить ведомый процесс репликации.
</p>

<h4><a name="replication-setup-slaves"></a>19.1.2.6.
Установка ведомых устройств репликации</h4>
<p>Следующие разделы описывают, как настроить ведомые устройства. Прежде, чем
Вы продолжите гарантируйте, что имеете:</p>

<ul><li><p>Сконфигурированное ведущее устройство MySQL с необходимыми
свойствами конфигурации. См.
<a href="#replication-howto-masterbaseconfig">раздел 19.1.2.1</a>.
</li>

<li>Полученную основную информацию о статусе. См.
<a href="#replication-howto-masterstatus">раздел 19.1.2.4</a>.
</li>
<li>На ведущем устройстве освобожденную блокировку чтения:
<pre>
mysql&gt; UNLOCK TABLES;
</pre></li>

<li>На ведомом устройстве отредактированную конфигурация MySQL. См.
<a href="#replication-howto-slavebaseconfig">раздел 19.1.2.2</a>.
</p></li></ul>

<p>Следующие шаги зависят от того, есть ли у Вас существующие данные, чтобы
импортировать к ведомому устройству или нет. См.
<a href="#replication-snapshot-method">раздел 19.1.2.5</a>
для получения дополнительной информации. Выберите одно из следующего:</p>

<ul><li><p>Если у Вас нет снимка базы данных, чтобы импортировать, см.
<a href="#replication-howto-newservers">раздел 19.1.2.6.1</a>.
</li>

<li>Если у Вас есть снимок базы данных, чтобы импортировать, см.
<a href="#replication-howto-existingdata">раздел 19.1.2.6.2</a>.
</p></li></ul>

<h5><a name="replication-howto-newservers"></a>19.1.2.6.1.
Установка репликации с новыми ведущим и ведомым устройствами</h5>
<p>Когда нет никакого снимка предыдущей базы данных, чтобы импортировать,
сконфигурируйте ведомое устройство, чтобы запустить репликацию
от нового ведущего устройства.</p>

<p>Настройте репликацию между ведущим и новым ведомым устройствами:</p>
<ol type="1"><li><p>Запустите ведомое устройство MySQL.</li>
<li>Выполните <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO
</code></a>, чтобы установить основную конфигурацию сервера репликации. См.
<a href="#replication-howto-slaveinit">раздел 19.1.2.7</a>.
</p></li></ol>

<p>Выполните эти шаги установки на каждом ведомом устройстве.</p>
<p>Этот метод может также использоваться, если Вы настраиваете новые серверы,
но имеете существующий дамп баз данных от различного сервера, который Вы
хотите загрузить в Вашу конфигурацию репликации. Загружая данные в новое
ведущее устройство, данные автоматически копируются ведомым устройствам.</p>

<p>Если Вы настраиваете новую окружающую среду репликации, используя данные
от различного существующего сервера базы данных, чтобы создать новое ведущее
устройство, то выполняете файл дампа, произведенный от того сервера на новом
ведущем устройстве. Обновления базы данных автоматически
размножены к ведомым устройствам:
<pre>
shell&gt; mysql -h master &lt; fulldb.dump
</pre>

<h5><a name="replication-howto-existingdata"></a>19.1.2.6.2.
Установка репликации с существующими данными</h5>
<p>Настраивая репликацию с существующими данными, передайте снимок от
ведущего устройства к ведомому устройству перед запуском репликации.
Процесс для того, чтобы импортировать данные к ведомому устройству зависит от
того, как Вы создали снимок данных ведущего устройства.</p>

<p>Выберите одно из следующего:</p>
<p>Если Вы использовали <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a>:</p>

<ol type="1"><li><p>Запустите ведомое устройство, используя опцию
<a href="#option_mysqld_skip-slave-start"><code>
--skip-slave-start</code></a> так, чтобы репликация не запустилась.</li>

<li>Импортируйте файл дампа:
<pre>
shell&gt; mysql &lt; fulldb.dump
</pre></li></ol>

<p>Если Вы создали снимок, используя файлы необработанных данных:</p>
<ol type="1"><li><p>Извлеките файлы с данными в свой ведомый
каталог данных. Например:
<pre>
shell&gt; tar xvf dbdump.tar
</pre>

<p>Вы, возможно, должны установить разрешения и собственность на файлах так,
чтобы ведомый сервер мог получить доступ и изменить их.</li>
<li>Запустите ведомое устройство, используя опцию
<a href="#option_mysqld_skip-slave-start"><code>--skip-slave-start
</code></a>, чтобы репликация не запустилась.</li>

<li>Сконфигурируйте ведомое устройство с координатами репликации от ведущего
устройства. Это говорит ведомому устройству двоичный файл системного журнала
и позицию в пределах файла, где репликация должна запуститься. Кроме того,
сконфигурируйте ведомое устройство с параметрами входа в систему и именем
хоста ведущего устройства. Для получения дополнительной информации о
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a> см.
<a href="#replication-howto-slaveinit">раздел 19.1.2.7</a>.</li>

<li>Запустите ведомые потоки:
<pre>
mysql&gt; START SLAVE;
</pre></li></ol>

<p>После того, как Вы выполнили эту процедуру, ведомое устройство соединяется
с ведущим устройством и копирует любые обновления, которые произошли
на ведущем устройстве.</p>

<p>Если Вы забыли установить опцию
<a href="#option_mysqld_server-id"><code>server-id</code></a>
для ведущего устройства, ведомые устройства не могут соединиться с этим.</p>

<p>Если Вы забыли установить опцию
<a href="#option_mysqld_server-id"><code>server-id</code></a>
для ведомого устройства, Вы получаете следующую ошибку в журнале
ошибок ведомого устройства:
<pre>
Warning: You should set server-id to a non-0 value if master_host
is set; we will force server id to 2, but this MySQL server will
not act as a slave.
</pre>

<p>Вы также находите сообщения об ошибках в журнале ошибок ведомого
устройства, если он не в состоянии копировать по какой-либо другой причине.
</p>

<p>Ведомое устройство использует информацию в основном репозитарии
информации, чтобы отследить то, сколько из двоичного журнала ведущего
устройства это обработало. Репозитарий может быть в форме файлов или таблицы,
как определено набором значений для
<a href="#option_mysqld_master-info-repository"><code>
--master-info-repository</code></a>. Когда ведомое устройство работает с
<code>--master-info-repository=FILE</code>,
Вы можете найти в его каталоге данных два файла, названные
<code>master.info</code> и <code>relay-log.info</code>. Если
<code>--master-info-repository=TABLE</code>, эта информация сохранена в
таблице <code>master_slave_info</code> базы данных <code>mysql</code>.
Ни в коем случае <span><em>не</em></span> удаляйте или редактируйте файлы или
таблицу, если Вы не знаете точно, что Вы делаете и полностью понимаете
значения. Даже в этом случае лучше, если Вы используете
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>, чтобы
изменить параметры репликации. Ведомое устройство может использовать
значения, определенные в запросе, чтобы обновить файлы состояния
автоматически. См. <a href="#slave-logs">раздел 19.2.4</a>.</p>

<p>Содержание основного репозитария информации переопределяет некоторые
из параметров сервера, определенных в командной строке или в
<code>my.cnf</code>. См. <a href="#replication-options">раздел
19.1.6</a>.</p>

<p>Единственный снимок ведущего устройства достаточен для многократных
ведомых устройств. Чтобы настроить дополнительные ведомые устройства,
используйте тот же самый основной снимок и следуйте за
ведомой частью процедуры.</p>

<h4><a name="replication-howto-slaveinit"></a>19.1.2.7.
Установка основной конфигурации на ведомом устройстве</h4>
<p>Чтобы настроить ведомое устройство, чтобы общаться с ведущим устройством
для репликации, сконфигурируйте ведомое устройство с необходимой информацией
о соединении. Чтобы сделать это, выполните следующий запрос на ведомом
устройстве, заменяя значения опции фактическими значениями,
относящимися к Вашей системе:
<pre>
mysql&gt; CHANGE MASTER TO
    -&gt;        MASTER_HOST='<em><code>master_host_name</code></em>',
    -&gt;        MASTER_USER='<em><code>replication_user_name</code></em>',
    -&gt;        MASTER_PASSWORD='<em><code>replication_password</code></em>',
    -&gt;        MASTER_LOG_FILE='<em><code>recorded_log_file_name</code></em>',
    -&gt;        MASTER_LOG_POS=<em><code>recorded_log_position</code></em>;
</pre>

<p>Репликация не может использовать файлы сокета Unix.
Вы должны быть в состоянии соединиться с сервером ведущего устройства
MySQL по TCP/IP.</p>

<p><a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
имеет также и другие опции. Например, возможно настроить безопасную
репликацию, используя SSL. Для полного списка опций и информации о
максимальной допустимой длине для строк см.
<a href="sql.htm#change-master-to">раздел 14.4.2.1</a>.</p>

<h4><a name="replication-howto-additionalslaves"></a>19.1.2.8.
Добавление ведомых устройств окружающей среды репликации</h4>
<p>Вы можете добавить другое ведомое устройство существующей конфигурации
репликации, не останавливая ведущее устройство. Вместо этого настройте новое
ведомое устройство, делая копию существующего ведомого устройства, за
исключением того, что Вы конфигурируете новое ведомое устройство с отличным
<a href="#option_mysqld_server-id"><code>server-id</code></a>.</p>

<p>Дублировать существующее ведомое устройство:</p>
<ol type="1"><li><p>Закройте существующее ведомое устройство:
<pre>
shell&gt; mysqladmin shutdown
</pre></li>

<li>Скопируйте каталог данных от существующего ведомого устройства на новое
ведомое устройство. Вы можете сделать это, создавая архив, используя
<span><strong>tar</strong></span> или <code>WinZip</code>,
или выполняя прямую копию, используя такой инструмент, как
<span><strong>cp</strong></span> или <span><strong>rsync</strong></span>.
Гарантируйте, что Вы также копируете файлы системного журнала реле и
файлы системного журнала.</p>

<p>Типичная проблема, с которой сталкиваются, когда добавляют новые ведомые
устройства репликации состоит в том, что новое ведомое устройство терпит
неудачу с рядом предупреждающих сообщений и сообщений об ошибках:
<pre>
071118 16:44:10 [Warning] Neither --relay-log nor --relay-log-index were used; so
replication may break when this MySQL server acts as a slave and has his hostname
changed! Please use '--relay-log=<em><code>new_slave_hostname</code></em>-relay-bin'
to avoid this problem.
<span>071118 16:44:10 [ERROR] Failed to open the relay log
'./<em><code>old_slave_hostname</code></em>-relay-bin.003525'
(relay_log_pos 22940879)</span>
071118 16:44:10 <span>[ERROR] Could not find target log during relay log initialization</span>
071118 16:44:10 <span>[ERROR] Failed to initialize the master info structure</span>
</pre>

<p>Эта ситуация может произойти, если опция
<a href="#option_mysqld_relay-log"><code>--relay-log</code></a>
не определена, поскольку файлы системного журнала реле содержат имя хоста как
часть их имен файла. Это также верно для индексного файла журнала реле, если
не используется опция <a href="#option_mysqld_relay-log-index">
<code>--relay-log-index</code></a>, см.
<a href="#replication-options">раздел 19.1.6</a>.</p>

<p>Чтобы избежать этой проблемы, используйте то же самое значение для
<a href="#option_mysqld_relay-log"><code>--relay-log</code></a>
на новом ведомом устройстве, которое использовалось на существующем ведомом
устройстве. Если эта опция не была установлена явно на существующем ведомом
устройстве, надо использовать
<code><em><code>existing_slave_hostname</code></em>-relay-bin</code>.
Если это невозможно, скопируйте индексный файл реле существующего ведомого
устройства к новому ведомому устройству и установите опцию
<a href="#option_mysqld_relay-log-index"><code>--relay-log-index
</code></a> на новом ведомом устройстве, чтобы соответствовать значению, что
использовалось на существующем ведомом устройстве. Если эта опция не была
установлена явно на существующем ведомом устройстве, надо использовать
<code><em><code>existing_slave_hostname</code></em>-relay-bin.index</code>.
Альтернативно, если Вы уже попытались запустить новое ведомое устройство и
столкнулись с ошибками, как описанные ранее, то выполните следующие шаги:</p>

<ol type="a"><li><p>Если Вы еще этого не сделали, выполните
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> на
новом ведомом устройстве.</p>

<p>Если Вы уже запустили существующее ведомое устройство снова, выполните
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> на существующем
ведомом устройстве также.</li>

<li>Скопируйте содержание индексного файла журнала реле существующего
ведомого устройства в индексный файл журнала реле нового ведомого устройства,
перезаписывая любой контент в файле.</li>
<li>Возобновите остающиеся шаги в этом разделе.</p></li></ol></li>

<li>Скопируйте основную информацию и репозитарии информации журнала реле (см.
<a href="#slave-logs">раздел 19.2.4</a>)
от существующего ведомого устройства на новое ведомое устройство.
Они содержат текущие координаты журнала для двоичного журнала ведущего
устройства и журнала реле ведомого устройства.</li>

<li>Запустите существующее ведомое устройство.</li>
<li>На новом ведомом устройстве отредактируйте конфигурацию и дайте новому
ведомому устройству уникальный <a href="#option_mysqld_server-id">
<code>server-id</code></a> не используемый ведущим устройством или любым из
существующих ведомых устройств.</li>

<li>Запустите новое ведомое устройство. Ведомое устройство использует
информацию в своем основном репозитарии информации, чтобы
запустить процесс репликации.</p></li></ol>

<h3><a name="replication-gtids"></a>19.1.3.
Репликация с глобальными операционными идентификаторами</h3>
<p>Этот раздел объясняет основанную на транзакции репликацию, используя
<span>global transaction identifiers</span> (GTID).
Используя GTID, каждая транзакция может быть идентифицирована и прослежена,
поскольку это передано на сервере и применено любыми ведомыми устройствами,
это означает, что не надо, используя GTID, обращаться к файлам системного
журнала или позициям в пределах тех файлов, запуская новое ведомое
устройство, что очень упрощает эти задачи. Поскольку GTID-репликация основана
на транзакции, просто определить, последовательны ли ведущие устройства и
ведомые устройства: пока все транзакции, переданные на ведущем устройстве,
также переданы на ведомом устройстве, последовательность между этими двумя
гарантируется. Вы можете использовать основанную на запросе или на строке
репликацию с GTID (см. <a href="#replication-formats">
раздел 19.2.1</a>), однако, для лучших результатов, мы рекомендуем, чтобы Вы
использовали основанный на строке формат.</p>

<p>Этот раздел обсуждает следующие темы:</p>
<ul><li><p>Как GTID определены и созданы и как они представлены в
MySQL Server (см.
<a href="#replication-gtids-concepts">раздел 19.1.3.1</a>).</li>

<li>Общая процедура для установки и запуска GTID-репликации (см.
<a href="#replication-gtids-howto">раздел 19.1.3.2</a>).</li>
<li>Предложенные методы для того, чтобы обеспечить новые серверы репликации,
используя GTID (см. <a href="#replication-gtids-failover">
раздел 19.1.3.3</a>).</li>

<li>Ограничения и лимиты о которых Вы должны знать, используя GTID (см.
<a href="#replication-gtids-restrictions">раздел 19.1.3.4</a>).
</p></li></ul>

<p>Для информации о параметрах сервера MySQL и переменных, касающихся
GTID, см. раздел 19.1.6.5</a>. См. также
<a href="funct.htm#gtid-functions">раздел 13.17</a>,
который описывает функции SQL, поддержанные MySQL 8.0
для использования с GTID.</p>

<h4><a name="replication-gtids-concepts"></a>19.1.3.1. Понятия GTID</h4>
<p>Глобальный операционный идентификатор (GTID) является уникальным
идентификатором, создаваемым и связанным с каждой транзакцией, переданной на
сервере происхождения (ведущее устройство). Этот идентификатор уникален не
только для сервера, на котором он произошел, но и уникален через все серверы
в данной установке репликации. Есть 1 к 1 отображение между всеми
транзакциями и всеми GTID.</p>

<p>Следующие параграфы обеспечивают основное описание GTID:</p>
<ul><li><p><a href="#replication-gtids-concepts-gtid-sets">
Наборы GTID</a>.</li>
<li><a href="#replication-gtids-gtid-executed-table">
Таблица mysql.gtid_executed</a>.</li>
<li><a href="#replication-gtids-gtid-executed-table-compression">
Табличное сжатие mysql.gtid_executed</a>.</p></li></ul>

<p>GTID представлен как пара координат, отделенных символом двоеточия
(<code>:</code>), примерно в таком виде:
<pre>
GTID = <em><code>source_id</code></em>:<em><code>transaction_id</code></em>
</pre>

<p><em><code>source_id</code></em> идентифицирует происходящий сервер. Обычно
применяется <a href="#sysvar_server_uuid"><code>server_uuid</code>
</a> сервера. <em><code>transaction_id</code></em> порядковый номер,
определенный порядком, в котором транзакция была передана на этом сервере,
например, первая транзакция, которая будет передана, имеет <code>1</code> как
ее <em><code>transaction_id</code></em>, десятой транзакции, которая будет
передана на том же самом сервере возникновения, назначается
<em><code>transaction_id</code></em> = <code>10</code>.
Для транзакции невозможно иметь <code>0</code> как порядковый номер в GTID.
Например, двадцать третья транзакция, которая будет передана на сервере с
UUID <code>3E11FA47-71CA-11E1-9E33-C80AA9429562</code> имеет такой GTID:
<pre>
3E11FA47-71CA-11E1-9E33-C80AA9429562:23
</pre>

<p>Этот формат используется, чтобы представить GTID в выводе запросов
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
так же, как в двоичном журнале. Они могут также быть замечены, рассматривая
файл системного журнала с <a href="programs.htm#mysqlbinlog"><span><strong>
mysqlbinlog</strong></span></a>
<a href="programs.htm#option_mysqlbinlog_base64-output"><code>
--base64-output=DECODE-ROWS</code></a> или в выводе
<a href="sql.htm#show-binlog-events"><code>SHOW BINLOG EVENTS</code></a>.</p>

<p>Как написано в выводе запросов
<a href="sql.htm#show-master-status"><code>SHOW MASTER STATUS</code></a> или
<code>SHOW SLAVE STATUS</code>, последовательность GTID, происходящяя из того
же самого сервера, может быть свернута в единственное выражение,
как показано здесь.
<pre>
3E11FA47-71CA-11E1-9E33-C80AA9429562:1-5
</pre>

<p>Этот пример представляет с первой по пятую транзакции, происходящие на
MySQL Server с <a href="#sysvar_server_uuid"><code>server_uuid
</code></a> <code>3E11FA47-71CA-11E1-9E33-C80AA9429562</code>.</p>

<p>Этот формат также используется, чтобы поставлять параметр, требуемый
опциями <a href="sql.htm#start-slave"><code>START SLAVE</code></a>
<code>SQL_BEFORE_GTIDS</code> и <code>SQL_AFTER_GTIDS</code>.</p>

<h5><a name="replication-gtids-concepts-gtid-sets"></a>Наборы GTID</h5>
<p>Набор GTID это множество глобальных операционных идентификаторов, которое
представлен как показано здесь:
<pre>
<em><code>gtid_set</code></em>:
<em><code>uuid_set</code></em> [, <em><code>uuid_set</code></em>] ...
| ''

<em><code>uuid_set</code></em>:
<em><code>uuid</code></em>:<em><code>interval</code></em>[:<em><code>interval</code></em>]...

<em><code>uuid</code></em>:
<em><code>hhhhhhhh</code></em>-<em><code>hhhh</code></em>-<em><code>hhhh</code></em>-<em><code>hhhh</code></em>-<em><code>hhhhhhhhhhhh</code></em>
<em><code>h</code></em>:
[0-9|A-F]

<em><code>interval</code></em>:
<em><code>n</code></em>[-<em><code>n</code></em>]
(<em><code>n</code></em> &gt;= 1)
</pre>

<p>Наборы GTID используются в MySQL Server несколькими способами. Например,
значения, сохраненные в переменных
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a> и
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>
представлены как наборы GTID. Кроме того, функции
<a href="funct.htm#function_gtid-subset"><code>GTID_SUBSET()</code></a> и
<a href="funct.htm#function_gtid-subtract"><code>GTID_SUBTRACT()</code></a>
требуют наборов GTID как входных данных. Когда наборы GTID возвращены из
переменных сервера, UUID в алфавитном порядке и числовые интервалы
слиты в порядке возрастания.</p>

<p>GTID всегда сохраняются между ведущим устройством и ведомым устройством.
Это означает, что Вы можете всегда определять источник для любой транзакции,
примененной на любое ведомое устройство, исследуя его двоичной журнал. Кроме
того, как только транзакция с данным GTID передана на данном сервере, любая
последующая транзакция, имеющая тот же самый GTID, проигнорирована тем
сервером. Таким образом, транзакция, переданная на ведущем устройстве, может
быть применена не больше, чем однажды на ведомом устройстве, что
помогает гарантировать последовательность.</p>

<p>Когда GTID используются, у ведомого устройства нет никакой потребности в
любых нелокальных данных, таких как название файла на ведущем устройстве и
позиции в пределах того файла. Вся необходимая информация для того, чтобы
синхронизировать с ведущим устройством получена непосредственно из потока
данных репликации. GTID заменяют смещение в файле. Поэтому не надо включать
опции <code>MASTER_LOG_FILE</code> или <code>MASTER_LOG_POS</code> в
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
и направлять ведомое устройство, чтобы копировать от данного ведущего
устройства, вместо этого необходимо только включить опцию
<code>MASTER_AUTO_POSITION</code>. Для точных шагов, чтобы
сконфигурировать и запустить ведущие и ведомые устройства, используя GTID
см. <a href="#replication-gtids-howto">раздел 19.1.3.2</a>.</p>

<p>Генерация и жизненный цикл GTID состоят из следующих шагов:</p>
<ol type="1"><li><p>Транзакция выполнена и передана на ведущем устройстве.
</p>
<p>Этой транзакции назначают GTID с использованием UUID ведущего устройства и
самого маленького операционного порядкового номера, отличного от нуля,
используемого на этом сервере, GTID написан в двоичный журнал ведущего
устройства (немедленно перед транзакцией непосредственно в журнале).</li>

<li>После того, как двоичные данные о журнале переданы к ведомому устройству
и хранятся в журнале реле ведомого устройства (используя установленные
механизмы для этого, см.
<a href="#replication-implementation">раздел 19.2</a>),
ведомое устройство читает GTID и устанавливает значение
<a href="#sysvar_gtid_next"><code>gtid_next</code></a> в этот
GTID. Это говорит ведомому устройству, что следующая транзакция должна быть
зарегистрирована, используя этот GTID.</p>

<p>Важно отметить, что ведомое устройство устанавливает
<code>gtid_next</code> в контексте сеанса.</li>
<li>Ведомое устройство проверяет, что этот GTID не использовался, чтобы
зарегистрировать транзакцию в собственном двоичном журнале. Если этот GTID не
использовался, ведомое устройство пишет GTID, применяет транзакцию и пишет
транзакцию в свой двоичный журнал. Читая и проверяя GTID транзакции сначала,
прежде, чем обработать транзакцию непосредственно, ведомое устройство
гарантирует не только, что никакая предыдущая транзакция, имеющая этот GTID,
не была применена на ведомом устройстве, но также и что никакой другой сеанс,
который уже считал этот GTID, еще не передал связанную транзакцию. Другими
словами, многим клиентам не разрешают применить ту же
самую транзакцию одновременно.</li>

<li>Так как <a href="#sysvar_gtid_next"><code>gtid_next</code></a>
не пусто, ведомое устройство не пытается произвести GTID для этой транзакции,
но вместо этого пишет GTID, сохраненный в этой переменной,
то есть, GTID, полученный из ведущего немедленно перед
транзакцией в двоичном журнале.</p></li></ol>

<h5><a name="replication-gtids-gtid-executed-table"></a>
Таблица mysql.gtid_executed</h5>
<p>GTID сохранены в таблице <code>gtid_executed</code> базы данных
<code>mysql</code>. Строка в этой таблице содержит для каждого GTID или
набора GTID, который это представляет, UUID сервера происхождения, ID первой
и последней транзакции набора, для строки, ссылающейся только на единственный
GTID, эти последние два значения то же самое.</p>

<p>Таблица <code>mysql.gtid_executed</code> составлена (если она не
существует), когда MySQL Server установлен или обновлен, используя
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> подобно этому:
<pre>
CREATE TABLE gtid_executed (source_uuid CHAR(36) NOT NULL,
                            interval_start BIGINT(20) NOT NULL,
                            interval_end BIGINT(20) NOT NULL,
                            PRIMARY KEY (source_uuid, interval_start))
</pre>
<p>Как с другими системными таблицами MySQL, не пытайтесь создать или
изменить эту таблицу самостоятельно.</p>

<p>GTID сохранены в <code>mysql.gtid_executed</code> только, когда
<a href="#sysvar_gtid_mode"><code>gtid_mode=ON</code></a>,
и не сохранены, когда <code>gtid_mode</code> имеет некоторое другое значение.
GTID сохранены в этой таблице без отношения к тому, включено ли двоичное
журналирование. Однако, манера, в которой они сохранены, отличается в
зависимости от того <a href="#sysvar_log_bin"><code>log_bin</code>
</a> <code>ON</code> или <code>OFF</code>:</p>

<ul><li><p>Если двоичное журналирование отключено (<code>log_bin</code> =
<code>OFF</code>), сервер хранит GTID, принадлежащий каждой транзакции,
вместе с транзакцией в таблице.</p>
<p>Кроме того, когда двоичное журналирование отключено, эта таблица
периодически сжимается на конфигурируемом пользователем уровне.</li>

<li>Если двоичное журналирование включено  (<code>log_bin</code> =
<code>ON</code>), тогда в дополнение к хранению GTID в
<code>mysql.gtid_executed</code>, всякий раз, когда двоичной журнал
ротируется, или сервер закрыт, сервер пишет GTID для всех транзакций, которые
были написаны в предыдущий двоичной журнал, в новый двоичной журнал.</p>

<p>В случае сервера, останавливающегося неожиданно, набор GTID от предыдущего
двоичного журнала не сохранен в <code>mysql.gtid_executed</code>.
В этом случае эти GTID добавлены к таблице и к набору GTID в переменной
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
во время восстановления.</p></li></ul>
<p>Таблица <code>mysql.gtid_executed</code> сброшена
<a href="sql.htm#reset-master"><code>RESET MASTER</code></a>.</p>

<h5><a name="replication-gtids-gtid-executed-table-compression"></a>
Табличное сжатие mysql.gtid_executed</h5>
<p>Со временем таблица <code>mysql.gtid_executed</code>
может стать заполненной многими строками, обращающимися к отдельным GTID,
которые происходят на том же самом сервере, и чьи операционные ID составляют
последовательность, подобную тому, что показывают здесь:
<pre>
mysql&gt; SELECT * FROM mysql.gtid_executed;
+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 37           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 38             | 38           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 39             | 39           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 40             | 40           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 41             | 41           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 42             | 42           |
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 43             | 43           |
...
</pre>

<p>Значительное свободное место может быть оставлено, если эта таблица
периодически сжимается, заменяя каждый такой набор строк единственной
строкой, которая охватывает весь интервал операционных идентификаторов:
<pre>
+--------------------------------------+----------------+--------------+
| source_uuid                          | interval_start | interval_end |
|--------------------------------------+----------------+--------------|
| 3E11FA47-71CA-11E1-9E33-C80AA9429562 | 37             | 43           |
...
</pre>

<p>Когда GTID включены, сервер выполняет этот тип сжатия на
<code>mysql.gtid_executed</code> периодически. Вы можете управлять числом
транзакций, которым позволяют пройти прежде, чем таблица будет сжата, и таким
образом уровнем сжатия, устанавливая переменную
<a href="#sysvar_executed_gtids_compression_period"><code>
executed_gtids_compression_period</code></a>. Значение по умолчанию этой
переменной 1000 это означает, что, по умолчанию, сжатие таблицы выполнено
после каждой 1000 транзакции. Установка
<code>executed_gtid_compression_period</code> в 0
препятствует тому, чтобы сжатие было выполнено вообще, однако, Вы должны быть
подготовлены к потенциально значительному увеличению количества дискового
пространства, которое может требоваться <code>gtid_executed</code>.</p>

<p>Когда двоичное журналирование включено, значение
<a href="#sysvar_executed_gtids_compression_period">
<code>executed_gtids_compression_period</code></a>
<span><em>не</em></span> используется и <code>mysql.gtid_executed</code>
сжата на каждой ротации двоичного журнала.</p>

<p>Сжатие <code>mysql.gtid_executed</code> выполнено специализированным
потоком переднего плана, который создается всякий раз, когда GTID включены на
сервере. Этот поток не перечислен в выводе
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>,
но это может быть рассмотрено как строка в таблице
<a href="perfor.htm#threads-table"><code>threads</code></a>:
<pre>
mysql&gt; SELECT * FROM PERFORMANCE_SCHEMA.THREADS WHERE NAME LIKE '%gtid%'\G
*************************** 1. row ***************************
THREAD_ID: 21
 NAME: thread/sql/compress_gtid_table
 TYPE: FOREGROUND
 PROCESSLIST_ID: 139635685943104
 PROCESSLIST_USER: NULL
 PROCESSLIST_HOST: NULL
 PROCESSLIST_DB: NULL
PROCESSLIST_COMMAND: Daemon
 PROCESSLIST_TIME: 611
PROCESSLIST_STATE: Suspending
 PROCESSLIST_INFO: NULL
 PARENT_THREAD_ID: 1
 ROLE: NULL
 INSTRUMENTED: YES
</pre>

<p>У этого потока есть имя <code>thread/sql/compress_gtid_table</code>
и он обычно спит до выполнения <code>executed_gtids_compression_period</code>
транзакций, затем просыпается, чтобы выполнить сжатие таблицы
<code>mysql.gtid_executed</code>. Установка
<code>executed_gtids_compression_period</code> = 0, когда двоичное
журналирование отключено устанавливает, что поток всегда спит и
никогда не просыпается.</p>

<h4><a name="replication-gtids-howto"></a>19.1.3.2.
Настройка репликации, используя GTID</h4>
<p>Этот раздел описывает процесс для конфигурирования и запуска
GTID-репликации в MySQL 8.0. Это процедура, которая предполагает, что Вы
запускаете ведущее устройство репликации впервые, или что возможно его
остановить, для информации об обеспечивании ведомых устройств репликации,
используя GTID от рабочего ведущего устройства, см.
<a href="#replication-gtids-failover">раздел 19.1.3.3</a>.</p>

<p>Ключевые шаги в этом процессе запуска для самой простой репликации GTID
из одного ведущего устройства и одного ведомого следующие:</p>
<ol type="1"><li><p>Если репликация уже работает, синхронизируйте оба
сервера, делая их только для чтения.</li>

<li>Остановите оба сервера.</li>
<li>Перезапустите оба сервера с включенным GTID и
правильно сконфигурированными опциями.</p>

<p>Опции <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span>
</a>, необходимые, чтобы запустить серверы как описано, обсуждены в примере,
который следует позже в этом разделе.</p>

<p><a href="#sysvar_server_uuid"><code>server_uuid</code></a>
должен существовать для GTID, чтобы функционировать правильно.</p></li>
<li>Проинструктируйте ведомое устройство использовать ведущее устройство в
качестве хранилища данных репликации и использовать авторасположение, затем
запустите ведомое устройство.</p>

<p>Запросы SQL, чтобы достичь этого шага, описаны в примере, который следует
позже в этом разделе.</li>
<li>Включите режим чтения снова на обоих серверах, так, чтобы они
могли принять обновления.</p></li></ol>

<p>В следующем примере уже работают два сервера, ведущее устройство и
ведомое, используя двоичный журнал и основанный на позиции протокол
репликации. Если Вы запускаете с новых серверов, см. разделы
<a href="#replication-howto-repuser">19.1.2.3</a> и
<a href="#replication-howto-masterbaseconfig">19.1.2.1</a>.
Следующие примеры показывают, как использовать опции, запуская
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.
Альтернативно Вы можете сохранить опции запуска в файле опции, см.
<a href="programs.htm#option-files">раздел 5.2.6</a>.</p>

<p>Большинство шагов требуют использования MySQL <code>root</code>
или другой учетной записи пользователя MySQL, которая имеет привилегию
<a href="security.html#priv_super"><code>SUPER</code></a>.
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin</strong></span>
</a> <code>shutdown</code> требует привилегию <code>SUPER</code> или
<a href="security.html#priv_shutdown"><code>SHUTDOWN</code></a>.</p>

<p><b>Шаг 1: Синхронизируйте серверы. </b>
Сделайте серверы только для чтения. Чтобы сделать это, включите
<a href="server.htm#sysvar_read_only"><code>read_only</code></a>
на обоих серверах:
<pre>
mysql&gt; SET @@global.read_only = ON;
</pre>

<p>Позвольте ведомому устройству догонять ведущее устройство.
<span><em>Чрезвычайно важно, чтобы Вы удостоверились, что ведомое устройство
обработало все обновления перед продолжением</em></span>.</p>

<p><b>Шаг 2: Остановите оба сервера. </b>
Остановите каждый сервер, используя <a href="programs.htm#mysqladmin"><span>
<strong>mysqladmin</strong></span></a>, где <em><code>username</code></em>
это имя пользователя MySQL, имеющего достаточные привилегии,
чтобы закрыть сервер:
<pre>
shell&gt; mysqladmin -u <em><code>username</code></em> -p shutdown
</pre>

<p><b>Шаг 3: Перезапустите оба сервера с включенным GTID. </b>
Чтобы включить GTID-репликацию, каждый сервер должен быть запущен с
включенным режимом GTID, устанавливая опцию
<a href="#option_mysqld_gtid-mode"><code>--gtid-mode</code></a> в
<code>ON</code> и с включенной опцией
<a href="#option_mysqld_enforce-gtid-consistency"><code>
--enforce-gtid-consistency</code></a>, чтобы гарантировать, что только
запросы, которые безопасны для репликации GTID, зарегистрированы. Кроме того,
Вы должны запустить ведомое устройство с опцией
<a href="#option_mysqld_skip-slave-start"><code>--skip-slave-start
</code></a> прежде, чем сконфигурировать ведомые настройки. Для получения
дополнительной информации о связанных опциях GTID см.
<a href="#replication-options-gtids">раздел 19.1.6.5</a>.</p>

<p>Необязательно, чтобы использовать GTID, включать двоичное журналирование,
используя <a href="#replication-gtids-gtid-executed-table">таблицу
mysql.gtid_executed</a>. Это означает, что у Вас могут быть ведомые серверы,
используя GTID, но без двоичного журналирования. Ведущим устройствам
<span><em>нужно</em></span> всегда включать двоичное журналирование, чтобы
быть в состоянии копировать. Например, чтобы запустить ведомое устройство с
включенным GTID, но без двоичного журналирования, используйте, по крайней
мере, эти опции:
<pre>
shell&gt; mysqld --gtid_mode=ON --enforce-gtid-consistency &amp;
</pre>
<p>В зависимости от Вашей конфигурации, поставляйте дополнительные опции
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.</p>

<p><b>Шаг 4: Направьте ведомое устройство, чтобы использовать ведущее
устройство. </b>Скажите ведомому устройству использовать ведущее устройство в
качестве хранилища данных репликации и использовать GTID авторасположение, а
не основанное на файле расположение. Выполните
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
на ведомом устройстве, используя опцию <code>MASTER_AUTO_POSITION</code>,
чтобы сказать ведомому устройству, что транзакции
будут идентифицированы GTID.</p>

<p>Вы, возможно, также должны поставлять соответствующие значения для имени
хоста ведущего устройства и номера порта, так же как имя пользователя и
пароль для учетной записи пользователя репликации, которая может
использоваться ведомым устройством, чтобы соединиться с ведущим устройством,
если они были уже установлены до Шага 1 и никакие дальнейшие изменения не
должны быть произведены, соответствующие опции могут безопасно быть опущены
из запроса, показанного здесь.
<pre>
mysql&gt; CHANGE MASTER TO
     &gt;        MASTER_HOST = <em><code>host</code></em>,
     &gt;        MASTER_PORT = <em><code>port</code></em>,
     &gt;        MASTER_USER = <em><code>user</code></em>,
     &gt;        MASTER_PASSWORD = <em><code>password</code></em>,
     &gt;        MASTER_AUTO_POSITION = 1;
</pre>

<p>Ни одна опция <code>MASTER_LOG_FILE</code> и
<code>MASTER_LOG_POS</code> не может использоваться с
<code>MASTER_AUTO_POSITION</code> равной 1. Попытка сделать так вызовет
ошибку в <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code>
</a>.</p>

<p>Если запрос <code>CHANGE MASTER TO</code> преуспел, Вы можете тогда
запустить ведомое устройство:
<pre>
mysql&gt; START SLAVE;
</pre>

<p><b>Шаг 5: Отключите режим только для чтения. </b>
Позвольте ведущему устройству начинать принимать обновления еще раз,
выполняя следующий запрос:
<pre>
mysql&gt; SET @@global.read_only = OFF;
</pre>
<p>GTID-репликация должна теперь работать, и Вы можете начать
деятельность по ведущему устройству как прежде.</p>

<h4><a name="replication-gtids-failover"></a>19.1.3.3.
Использование GTID для Failover и Scaleout</h4>
<p>Есть много методов, использования MySQL Replication с
Global Transaction Identifiers (GTID) для того, чтобы обеспечить
новое ведомое устройство, которое может тогда использоваться для
scaleout, будучи продвинутым на ведущее устройство по мере необходимости.</p>

<p>Глобальные операционные идентификаторы были добавлены к репликации MySQL с
целью упрощения в общем менеджменте потока данных репликации. Каждый
идентификатор уникально идентифицирует ряд двоичных событий журнала, которые
вместе составляют транзакцию. GTID играют ключевую роль в применении
изменений базы данных: сервер автоматически пропускает любую транзакцию,
имеющую идентификатор, который сервер признает тем, что обработал прежде.
Это поведение важно для автоматического расположения репликации.</p>

<p>Отображение между идентификаторами и наборами событий, включающих данную
транзакцию, получено в двоичном журнале. Это ставит некоторые проблемы,
обеспечивая новый сервер с данными от другого существующего сервера. Чтобы
воспроизвести набор идентификаторов на новом сервере, необходимо скопировать
идентификаторы со старого сервера на новом и сохранить отношения между
идентификаторами и фактическими событиями. Это надо для того, чтобы
восстановить ведомое устройство, которое немедленно доступно как кандидат,
чтобы стать новым ведущим устройством.</p>

<p><a name="replication-gtids-failover-replicate"></a><b>
Простая репликация. </b>Самый легкий способ воспроизвести все идентификаторы
и транзакции на новом сервере состоит в том, чтобы превратить новый сервер в
ведомое устройство ведущего устройства, у которого есть вся история
выполнения, и включить глобальные операционные идентификаторы на обоих
серверах. См. <a href="#replication-gtids-howto">раздел 19.1.3.2
</a>.</p>

<p>Как только репликация запущена, новый сервер копирует весь двоичной журнал
от ведущего устройства и таким образом получает всю информацию обо всех GTID.
</p>

<p>Этот метод прост и эффективен, но требует, чтобы ведомое устройство
считало двоичной журнал от ведущего устройства, может иногда требоваться
сравнительно много времени для нового ведомого устройства, чтобы догнать
ведущее устройство, таким образом, этот метод не является подходящим для
быстрого восстанавливающий из резервного копирования. Этот раздел объясняет,
как избежать приносить всю историю выполнения от ведущего устройства, копируя
двоичные файлы системного журнала к новому серверу.</p>

<p><a name="replication-gtids-failover-copy"></a><b>
Копирование данных и транзакций к ведомому устройству. </b>
Воспроизведение всей операционной истории может быть отнимающим много
времени, и представляет главное узкое место, настраивая новое ведомое
устройство репликации. Чтобы устранить это требование, снимок набора данных,
двоичных журналов и глобальной информации о транзакции, которую содержит
ведущее устройство, должен быть импортирован в ведомое устройство.
Двоичный журнал воспроизведен, после чего репликация может быть запущена,
позволяя ведомому устройству стать актуальным с
любыми остающимися транзакциями.</p>

<p>Есть несколько разновидностей этого метода, различающиеся тем, каким
образом дампы данных и транзакции от двоичных журналов переданы ведомому
устройству, как обрисовано здесь в общих чертах:</p>

<table border="1">
<thead><tr><th scope="col">Набор данных</th>
<th scope="col">История транзакций</th></tr></thead>
<tbody><tr><td scope="row"><ul><li><p>
Используйте <a href="programs.htm#mysql"><span><strong>mysql</strong></span>
</a>, чтобы импортировать файл дампа, создаваемый
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>.
Используйте опцию <a href="programs.htm#option_mysqldump_master-data"><code>
--master-data</code></a>, чтобы включить двоичную информацию о журналировании
и установите <a href="programs.htm#option_mysqldump_set-gtid-purged"><code>
--set-gtid-purged</code></a> в <code>AUTO</code> (значение по умолчанию) или
<code>ON</code>, чтобы включить информацию о выполненных транзакциях. Вы
должны иметь <a href="#option_mysqld_gtid-mode"><code>
--gtid-mode=ON</code></a>, импортируя дамп на ведомом устройстве.</li>

<li>Остановите ведомое устройство, скопируйте содержание каталога данных
ведущего устройства к каталогу данных ведомого устройства, затем
перезапустите ведомое устройство.</p></li></ul></td>
<td><p>Если <a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
не <code>ON</code>, перезапустите сервер с включенным режимом GTID.</p>

<ul><li><p>Импортируйте двоичной журнал, используя
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> с <a href="programs.htm#option_mysqlbinlog_read-from-remote-server">
<code>--read-from-remote-server</code></a> и
<a href="programs.htm#option_mysqlbinlog_read-from-remote-master"><code>
--read-from-remote-master</code></a>.</li>

<li>Скопируйте двоичные файлы системного журнала ведущего устройства
к ведомому устройству. Вы можете сделать копии с ведомого устройства,
используя <a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a>
<a href="programs.htm#option_mysqlbinlog_read-from-remote-server"><code>
--read-from-remote-server</code></a>
<a href="programs.htm#option_mysqlbinlog_raw"><code>--raw</code></a>.
Они могут быть считаны в ведомое устройство любым из следующих способов:</p>

<ul><li><p>Обновите файл <code>binlog.index</code> ведомого устройства, чтобы
указать на скопированные файлы системного журнала. Тогда выполните
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
в <a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>, чтобы
указать на первый файл системного журнала, и
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>, чтобы считать их.
</li>

<li>Используйте <a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a> <code>&gt;</code>
<code><em><code>file</code></em></code> (без опции
<a href="programs.htm#option_mysqlbinlog_raw"><code>--raw</code></a>), чтобы
экспортировать двоичные файлы системного журнала в файлы SQL, которые могут
быть обработаны <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a>.</p></li></ul></li></ul></td></tr></tbody></table>
<p>См. <a href="programs.htm#mysqlbinlog-backup">раздел 5.6.8.3</a>.</p>

<p>У этого метода есть преимущество, что новый сервер доступен почти
немедленно, только те транзакции, которые были переданы, в то время как
файл снимка или дампа переигрывался, все еще будут получены от существующего
ведущего устройства. Это означает, что доступность ведомого устройства не
мгновенна, но только относительно короткий срок должен требоваться для
ведомого устройства, чтобы догнать эти немного остающихся транзакций.</p>

<p>Копирование по двоичным журналам к целевому серверу заранее обычно
быстрее, чем чтение всей операционной истории выполнения от ведущего
устройства в режиме реального времени. Однако, возможно, не всегда выполнимо
переместить эти файлы, когда требуется из-за размера или других соображений.
Два остающихся метода для того, чтобы обеспечить новое ведомое устройство,
обсуждаемые в этом разделе, используют другие средства, чтобы передать
информацию о транзакциях к новому ведомому устройству.</p>

<p><a name="replication-gtids-failover-empty"></a><b>
Впрыскивание пустых транзакций. </b>Глобальная переменная ведущего устройства
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
содержит набор всех транзакций, выполненных на ведущем устройстве. Вместо
того, чтобы копировать двоичные журналы, беря снимок, чтобы обеспечить новый
сервер, Вы можете вместо этого отметить контент <code>gtid_executed</code>
на сервере, от которого был взят снимок. Прежде чем добавить новый сервер к
цепочке репликации, просто передайте пустую транзакцию на новом сервере для
каждого операционного идентификатора, содержавшегося в
<code>gtid_executed</code> ведущего устройства:
<pre>
SET GTID_NEXT='aaa-bbb-ccc-ddd:N';
BEGIN;
COMMIT;
SET GTID_NEXT='AUTOMATIC';
</pre>

<p>Как только все операционные идентификаторы были восстановлены
таким образом, используя пустые транзакции, Вы должны сбросить
и произвести чистку двоичных журналов ведомого устройства, как показано
здесь, где <em><code>N</code></em> суффикс отличный от нуля текущего
имени двоичного файла системного журнала:
<pre>
FLUSH LOGS;
PURGE BINARY LOGS TO 'master-bin.00000<em><code>N</code></em>';
</pre>

<p>Вы должны сделать это, чтобы препятствовать тому, чтобы этот сервер
затопил поток репликации ложными транзакциями, когда это позже будет
продвинуто на ведущее устройство. <a href="sql.htm#flush"><code>FLUSH LOGS
</code></a> вызывает создание нового двоичного файла системного журнала,
<a href="sql.htm#purge-binary-logs"><code>PURGE BINARY LOGS</code></a>
производит чистку пустых транзакций, но сохраняет их идентификаторы.</p>

<p>Этот метод создает сервер, который является по существу снимком, но в
состоянии стать ведущим устройством, поскольку его двоичная история журнала
сходится с данными из потока репликации (то есть, поскольку это догоняет
ведущее устройство или ведущие устройства). Этот результат подобен в
действительности полученному с использованием метода, который мы
обсуждаем в следующих параграфах.</p>

<p><a name="replication-gtids-failover-gtid-purged"></a><b>
Исключая транзакции с gtid_purged. </b>Глобальная переменная
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>
ведущего устройства содержит набор всех транзакций, которые были вычищены из
двоичного журнала ведущего устройства. Как с методом, обсужденным ранее,
Вы можете сделать запись значения
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
на сервере, от которого снимок был взят (вместо копирования двоичных журналов
к новому серверу). В отличие от предыдущего метода, нет никакой потребности
передать пустые транзакции (или выполнить
<a href="sql.htm#purge-binary-logs"><code>PURGE BINARY LOGS</code></a>),
вместо этого Вы можете установить <a href="#sysvar_gtid_purged">
<code>gtid_purged</code></a> на ведомом устройстве непосредственно,
основываясь на значении <a href="#sysvar_gtid_executed"><code>
gtid_executed</code></a> сервера, от которого были взяты резервные
копии или снимок.</p>

<p>Как с методом пустых транзакций, этот метод создает сервер, который
является функционально снимком, но в состоянии стать ведущим устройством,
поскольку его двоичная история журнала сходится с историей
из ведущего устройства репликации или группы.</p>

<p><a name="replication-gtids-restoring-mysqlbinlog"></a><b>
Восстановление ведомых устройств режима GTID. </b>
Когда восстановление ведомого устройства в GTID-репликации сталкивается с
ошибкой, ввод пустой транзакции, возможно, не решает проблему, потому что у
события нет GTID.</p>

<p>Используйте <a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a>, чтобы найти следующую транзакцию, которая является,
вероятно, первой транзакцией в следующем файле системного журнала после
события. Скопируйте все до <a href="sql.htm#commit"><code>COMMIT</code></a>
для той транзакции, чтобы включить <code>SET @@SESSION.GTID_NEXT</code>.
Даже если Вы не используете основанную на строке репликацию, Вы можете все
еще выполнить двоичные события строки журнала в клиенте командной строки.</p>

<p>Остановите ведомое устройство и выполните транзакцию, которую Вы
скопировали. <a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a> выводит разделитель наборов как <code>/*!*/;</code>:
<pre>
mysql&gt; DELIMITER ;
</pre>

<p>Перезапустите репликацию от правильной позиции автоматически:
<pre>
mysql&gt; SET GTID_NEXT=automatic;
mysql&gt; RESET SLAVE;
mysql&gt; START SLAVE;
</pre>

<h4><a name="replication-gtids-restrictions"></a>19.1.3.4.
Ограничения на репликацию с GTID</h4>
<p>Поскольку GTID-репликация зависит от транзакций, некоторые функции, иначе
доступные в MySQL, не поддерживаются, используя ее.
Этот раздел предоставляет информацию об ограничениях репликации с GTID.</p>

<p><b>Обновления, вовлекающие нетранзакционные механизмы хранения. </b>
Используя GTID, обновления таблиц, использующие нетранзакционные механизмы
хранения, например, <a href="storage.htm#myisam-storage-engine"><code>MyISAM
</code></a>, не могут быть сделаны в том же самом запросе или транзакции как
обновления таблиц, использующих транзакционные механизмы хранения, например,
<a href="innodb.htm"><code>InnoDB</code></a>.</p>

<p>Это ограничение следствие того, что обновления таблиц, которые
используют нетранзакционной механизм хранения, смешанные с обновлениями
таблиц, которые используют транзакционной механизм хранения в пределах той же
самой транзакции, могут привести к многократным GTID, назначаемым
на ту же самую транзакцию.</p>

<p>Такие проблемы могут также произойти, когда ведущее и ведомое устройства
используют различные механизмы хранения для соответствующих версий той же
самой таблицы, где один механизм хранения является
транзакционным, а другой нет.</p>

<p>В любом из таких случаев непосредственная связь
между транзакциями и GTID сломана, так что в итоге GTID-репликация
не может функционировать правильно.</p>

<p><b>CREATE TABLE ... SELECT. </b>
<a href="sql.htm#create-table-select"><code>CREATE TABLE ... SELECT</code>
</a> не безопасны для основанной на запросе репликации. Используя основанную
на строке репликацию, этот запрос фактически зарегистрирован как два
отдельных события: одно для создания таблицы и другое для вставки строк от
исходной таблицы в новую таблицу. Когда этот запрос выполнен в пределах
транзакции, для этих двух событий возможно в некоторых случаях получить тот
же самый операционный идентификатор, что означает, что транзакция, содержащая
вставки, пропущена ведомым устройством. Поэтому <code>CREATE TABLE ...
SELECT</code> не поддержан, используя GTID-репликацию.</p>

<p><b>Временные таблицы. </b>
<a href="sql.htm#create-table"><code>CREATE TEMPORARY TABLE</code></a> и
<a href="sql.htm#drop-table"><code>DROP TEMPORARY TABLE</code></a> не
поддержаны в транзакциях, используя GTID (то есть, когда сервер был запущен с
опцией <a href="#option_mysqld_enforce-gtid-consistency"><code>
--enforce-gtid-consistency</code></a>). Возможно использовать эти запросы с
включенным GTID, но только за пределами любой транзакции и только с
<a href="server.htm#sysvar_autocommit"><code>autocommit=1</code></a>.</p>

<p><b>Предотвращение выполнения неподдержанных запросов. </b>
Чтобы предотвратить выполнение запросов, которые заставили бы GTID-репликацию
терпеть неудачу, все серверы должны быть запущены с опцией
<a href="#option_mysqld_enforce-gtid-consistency"><code>
--enforce-gtid-consistency</code></a>, включая GTID. Это заставляет запросы
любого из типов, обсужденных ранее в этом разделе терпеть неудачу с ошибкой.
</p>
<p>См. <a href="#replication-gtids-howto">раздел 19.1.3.2</a>.</p>

<p><a href="#sysvar_sql_slave_skip_counter"><code>
sql_slave_skip_counter</code></a> не поддержана, используя GTID. Если Вы
должны пропустить транзакции, используйте значение
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
от ведущего устройства.</p>

<p><a name="replication-gtids-restrictions-mysqldump"></a><b>
Режим GTID и mysqldump. </b>Возможно импортировать дамп из
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
в MySQL Server работающий с включенным режимом GTID, при условии, что нет
никаких GTID в двоичном журнале целевого сервера.</p>

<p><a name="replication-gtids-restrictions-mysql_upgrade"></a><b>
Режим GTID и mysql_upgrade. </b>Возможно, но не рекомендуется использовать
<a href="programs.htm#mysql-upgrade"><span><strong>mysql_upgrade</strong>
</span></a> на MySQL Server с
<a href="#option_mysqld_gtid-mode"><code>--gtid-mode=ON</code>
</a>, так как <a href="programs.htm#mysql-upgrade"><span><strong>
mysql_upgrade</strong></span></a> может произвести изменения в системных
таблицах, которые используют <a href="storage.htm#myisam-storage-engine">
<code>MyISAM</code></a>, который является нетранзакционным.</p>

<h3><a name="replication-multi-source"></a>19.1.4.
Репликация с нескольких источников</h3>
<p>Это позволяет Вам копировать от многократных
ведущих устройств параллельно.</p>

<h4><a name="replication-multi-source-overview"></a>19.1.4.1.
Обзор репликации с нескольких источников</h4>
<p>Репликация с нескольких источников позволяет ведомому устройству
репликации получить транзакции от многократных источников одновременно.
Это может использоваться, чтобы зарезервировать многократные серверы на
единственный сервер, слить таблицы и объединить данные от многократных
серверов на единственном сервере. Это не осуществляет обнаружения конфликта,
применяя транзакции, и оставляет эту задачу приложению, если надо.
В мультиисходной топологии репликации ведомое устройство создает канал
репликации для каждого ведущего устройства, из которого оно должно получить
транзакции. См. <a href="#replication-channels">раздел 19.2.3</a>.
</p>

<h4><a name="replication-multi-source-tutorials"></a>19.1.4.2.
Введение в репликацию с нескольких источников</h4>
<p>Этот раздел обеспечивает обучающие материалы о том, как сконфигурировать
ведущие устройства и ведомые устройства для мультирепликации
и как запустить, остановить и сбросить ведомые устройства.</p>

<h5><a name="replication-multi-source-configuration"></a>19.1.4.2.1.
Конфигурирование мультирепликации</h5>
<p>Этот раздел объясняет, как сконфигурировать топологию репликации и
обеспечивает детали о конфигурировании ведущих устройств и ведомых устройств.
Такая топология требует по крайней мере двух ведущих устройств и одного
сконфигурированного ведомого устройства.</p>

<p>Ведущие устройства в мультиисходной топологии репликации могут быть
сконфигурированы, чтобы использовать глобальный операционный идентификатор
(GTID) или основанную на позиции репликацию. См. разделы
<a href="#replication-gtids-howto">19.1.3.2</a>
и <a href="#replication-howto-masterbaseconfig">19.1.2.1</a>.</p>

<p>Ведомые устройства в мультиисходной топологии репликации требуют
репозитариев <code>TABLE</code>. Мультирепликация несовместима с
репозитариями <code>FILE</code>. Тип репозитария, используемого
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>,
может быть сконфигурирован при запуске или динамически.</p>

<p>Чтобы сконфигурировать тип репозитария, используемого ведомым устройством
репликации при запуске, запустите <a href="programs.htm#mysqld"><span>
<strong>mysqld</strong></span></a> со следующими опциями:
<pre>
--master-info-repository=TABLE --relay-log-info-repository=TABLE
</pre>

<p>Чтобы изменить существующее ведомое устройство репликации, которое
использует репозитарий <code>FILE</code> на <code>TABLE</code>,
преобразуйте существующие репозитарии репликации динамически,
выполняя следующие команды:
<pre>
STOP SLAVE;
SET GLOBAL master_info_repository = 'TABLE';
SET GLOBAL relay_log_info_repository = 'TABLE';
</pre>

<h5><a name="replication-multi-source-adding-gtid-master"></a>19.1.4.2.2.
Добавление GTID-ведущего устройства к ведомому устройству репликации</h5>
<p>Этот раздел предполагает, что Вы включили GTID на
ведущем устройстве с использованием <a href="#sysvar_gtid_mode">
<code>gtid_mode=ON</code></a>, включили пользователя репликации и обеспечили,
что ведомое устройство использует репозитарии <code>TABLE</code>.
Используйте <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code>
</a>, чтобы добавить новое ведущее устройство к каналу при использовании
<code>FOR CHANNEL <em><code>channel</code></em></code>. См.
<a href="#replication-channels">раздел 19.2.3</a>.</p>

<p>Например, чтобы добавить новое ведущее устройство с именем хоста
<em><code>master1</code></em> и портом <em><code>3451</code></em>
к каналу <em><code>master-1</code></em>:
<pre>
CHANGE MASTER TO MASTER_HOST='master1', MASTER_USER='rpl', \
       MASTER_PORT=3451, MASTER_PASSWORD='', \
       MASTER_AUTO_POSITION = 1 FOR CHANNEL 'master-1';
</pre>
<p>Мультирепликация совместима с авторасположением. См.
<a href="sql.htm#change-master-to">раздел 14.4.2.1</a>.</p>

<p>Повторите этот процесс для каждого дополнительного ведущего устройства,
которое Вы хотите добавить к каналу, изменяя имя хоста, порт и
канал как надо.</p>

<h5><a name="replication-multi-source-adding-binlog-master"></a>19.1.4.2.3.
Добавление двоичного журнала ведущего устройства к
ведомому устройству мультирепликации</h5>
<p>Этот раздел предполагает, что Вы включили двоичное журналирование
с использованием <a href="#sysvar_log_bin"><code>--log-bin</code>
</a>, включая пользователя репликации, текущую позицию регистрации
и обеспечили, что ведомое устройство использует репозитарии
<code>TABLE</code>. Вы должны знать текущие
<code>MASTER_LOG_FILE</code> и <code>MASTER_LOG_POSITION</code>. Используйте
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>, чтобы
добавить новое ведущее устройство к каналу, определяя <code>FOR CHANNEL
<em><code>channel</code></em></code>. Например, чтобы добавить новое ведущее
устройство с именем хоста <em><code>master1</code></em> и портом <em><code>
3451</code></em> к каналу <em><code>master-1</code></em>:
<pre>
CHANGE MASTER TO MASTER_HOST='master1', MASTER_USER='rpl', MASTER_PORT=3451, \
       MASTER_PASSWORD='' MASTER_LOG_FILE='master1-bin.000006', \
       MASTER_LOG_POS=628 FOR CHANNEL 'master-1';
</pre>
<p>Повторите этот процесс для каждого дополнительного ведущего устройства,
которое Вы хотите добавить к каналу, изменяя имя хоста, порт и канал.</p>

<h5><a name="replication-multi-source-start-slave"></a>19.1.4.2.4.
Запуск ведомых устройств мультирепликации</h5>
<p>Как только Вы добавили все каналы, которые Вы хотите использовать в
качестве ведущих устройств репликации, надо использовать <code>START SLAVE
<em><code>thread_types</code></em></code>, чтобы запустить репликацию. Когда
Вы включили многократным каналы на ведомом устройстве, Вы можете хотеть
запускать все каналы или выбирать определенный канал, чтобы запустить.</p>

<ul><li><p>Чтобы запустить все в настоящее время
сконфигурированные каналы репликации:
<pre>
START SLAVE <em><code>thread_types</code></em>;</pre></li>

<li>Чтобы запустить только названный канал, используйте <code>FOR CHANNEL
<em><code>channel</code></em></code>:
<pre>
START SLAVE <em><code>thread_types</code></em> FOR CHANNEL <em><code>channel</code></em>;
</pre></li></ul>

<p>Используйте опцию <em><code>thread_types</code></em>, чтобы выбрать
определенные потоки, которые Вы хотите запустить на ведомом устройстве. См.
<a href="sql.htm#start-slave">раздел 14.4.2.6</a>.</p>

<h5><a name="replication-multi-source-stop-slave"></a>19.1.4.2.5.
Остановка ведомых устройств мультирепликации</h5>
<p><code>STOP SLAVE</code> может использоваться, чтобы остановить
ведомое устройство репликации. По умолчанию, если Вы используете
<code>STOP SLAVE</code> на ведомом устройстве мультирепликации, все каналы
остановлены. Произвольно используйте
<code>FOR CHANNEL <em><code>channel</code></em></code>, чтобы остановить
только определенный канал.</p>

<ul><li><p>Чтобы остановить все в настоящее время
сконфигурированные каналы репликации:
<pre>
STOP SLAVE <em><code>thread_types</code></em>;
</pre></li>

<li>Чтобы остановить только названный канал, используйте <code>FOR CHANNEL
<em><code>channel</code></em></code>:
<pre>
STOP SLAVE <em><code>thread_types</code></em> FOR CHANNEL <em><code>channel</code></em>;
</pre></li></ul>

<p>Используйте опцию <em><code>thread_types</code></em>, чтобы выбрать
определенные потоки, которые Вы хотите остановилить на ведомом устройстве.
См. <a href="sql.htm#stop-slave">раздел 14.4.2.7</a>.</p>

<h5><a name="replication-multi-source-reset-slave"></a>19.1.4.2.6.
Сброс ведомых устройств мультирепликации</h5>
<p><code>RESET SLAVE</code> может использоваться, чтобы сбросить
ведомое устройство репликации. По умолчанию, если Вы используете
<code>RESET SLAVE</code> на ведомом устройстве репликации, все каналы
сброшены. Произвольно, используйте <code>FOR CHANNEL <em><code>channel</code>
</em></code>, чтобы сбросить только определенный канал.</p>

<ul><li><p>Сбросить все в настоящее время
сконфигурированные каналы репликации:
<pre>
RESET SLAVE;
</pre></li>

<li>Чтобы сбросить только названный канал, используйте <code>FOR CHANNEL
<em><code>channel</code></em></code>:
<pre>
RESET SLAVE FOR CHANNEL <em><code>channel</code></em>;
</pre></li></ul>
<p>См. <a href="sql.htm#reset-slave">раздел 14.4.2.4</a>.</p>

<h4><a name="replication-multi-source-monitoring"></a>19.1.4.3.
Контроль за мультирепликацией</h4>
<p>Чтобы контролировать состояние репликации есть варианты:</p>

<ul><li><p>Используя таблицы Performance Schema.
Первый столбец этих таблиц <code>Channel_Name</code>.
Это позволяет Вам написать сложные запросы, основанные на
<code>Channel_Name</code> как на ключе. См.
<a href="perfor.htm#performance-schema-replication-tables">раздел 23.9.11
</a>.</li>

<li>Используя <code>SHOW SLAVE STATUS FOR CHANNEL
<em><code>channel_name</code></em></code>. По умолчанию, если
<code>FOR CHANNEL <em><code>channel_name</code></em></code>
не используется, эта команда показывает ведомое состояние для всех каналов с
одной строкой на канал. Идентификатор <code>channel_name</code>
добавлен как столбец в наборе результатов. Если <code>FOR CHANNEL
<em><code>channel_name</code></em></code> обеспечен, результаты показывают
состояние только названного канала репликации.</p></li></ul>

<p><a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a>
не работает с многократными каналами репликации. Информация, которая была
доступна через эти переменные, мигрировала в таблицы репликации.
Использование <a href="sql.htm#show-variables"><code>SHOW VARIABLES</code>
</a> в топологии с многократными каналами показывает состояние только
канала по умолчанию.</p>

<h5><a name="replication-multi-source-monitoring-tutorial"></a>19.1.4.3.1.
Контроль каналов, используя таблицы Performance Schema</h5>
<p>Этот раздел объясняет, как использовать таблицы Performance Schema
репликации, чтобы контролировать каналы. Вы можете хотеть контролировать все
каналы или некое подмножество каналов.</p>

<p>Чтобы контролировать состояние соединения всех каналов:
<pre>
mysql&gt; SELECT * FROM replication_connection_status\G;
*************************** 1. row ***************************
CHANNEL_NAME: master1
GROUP_NAME:
SOURCE_UUID: 046e41f8-a223-11e4-a975-0811960cc264
THREAD_ID: 24
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 046e41f8-a223-11e4-a975-0811960cc264:4-37
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
*************************** 2. row ***************************
CHANNEL_NAME: master2
GROUP_NAME:
SOURCE_UUID: 7475e474-a223-11e4-a978-0811960cc264
THREAD_ID: 26
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 7475e474-a223-11e4-a978-0811960cc264:4-6
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
2 rows in set (0.00 sec)
</pre>

<p>В вышеупомянутом выводе есть два активных канала и как показано полем
<code>CHANNEL_NAME</code> их называют <code>master1</code> и <code>master2
</code>.</p>

<p>Добавление поля <code>CHANNEL_NAME</code> позволяет Вам запросить таблицы
Performance Schema для определенного канала. Чтобы контролировать состояние
соединения названного канала, используйте <code>WHERE channel_name=<em><code>
channel</code></em></code>:
<pre>
mysql&gt; SELECT * FROM replication_connection_status
                   WHERE channel_name='master1'\G
*************************** 1. row ***************************
CHANNEL_NAME: master1
GROUP_NAME:
SOURCE_UUID: 046e41f8-a223-11e4-a975-0811960cc264
THREAD_ID: 24
SERVICE_STATE: ON
COUNT_RECEIVED_HEARTBEATS: 0
LAST_HEARTBEAT_TIMESTAMP: 0000-00-00 00:00:00
RECEIVED_TRANSACTION_SET: 046e41f8-a223-11e4-a975-0811960cc264:4-37
LAST_ERROR_NUMBER: 0
LAST_ERROR_MESSAGE:
LAST_ERROR_TIMESTAMP: 0000-00-00 00:00:00
1 row in set (0.00 sec)
</pre>

<p>Точно так же <code>WHERE channel_name=<em><code>channel</code></em></code>
может использоваться, чтобы контролировать другие таблицы Performance Schema
репликации для определенного канала. Для получения дополнительной информации
см. <a href="perfor.htm#performance-schema-replication-tables">раздел 23.9.11
</a>.</p>

<h4><a name="replication-multi-source-error-messages"></a>19.1.4.4.
Сообщения об ошибках мультирепликации</h4>
<p>Коды ошибки и сообщения предоставляют информацию об ошибках, с которыми
сталкиваются в топологии репликации. Эти коды ошибки и сообщения появляются
только, когда мультирепликация включена и предоставляют информацию, связанную
с каналом, который произвел ошибку. Например:</p>

<p><span>Slave is already running</span> и
<span>Slave is already stopped</span> были заменены
<span>Replication thread(s) for channel channel_name are already running
</span> и <span>Replication threads(s) for channel channel_name are
already stopped</span> соответственно.</p>
<p>Сообщения журнала сервера были также изменены, чтобы указать, которые
каналы направляют сообщения журнала. Это делает отладку и рассмотрение легче.
</p>

<h3><a name="replication-mode-change-online"></a>19.1.5.
Изменение режимов репликации на серверах онлайн</h3>
<p>Этот раздел описывает, как изменить режим репликации,
не имея необходимости останавливать сервер.</p>

<h4><a name="replication-mode-change-online-concepts"></a>19.1.5.1.
Понятия режима репликации</h4>
<p>Чтобы быть в состоянии безопасно сконфигурировать режим репликации сервера
онлайн, важно понять некоторое ключевое понятие репликации. Этот раздел
объясняет эти понятия и является существенным прежде, чем попытаться изменить
режим репликации сервера онлайн.</p>

<p>Режимы репликации в MySQL полагаются на различные методы для того, чтобы
идентифицировать транзакции, которые зарегистрированы. Типы транзакций,
используемых репликацией, следующие:</p>

<ul><li><p>Транзакции GTID идентифицированы глобальным операционным
идентификатором (GTID) в форме <code>UUID:NUMBER</code>. Каждой транзакции
GTID в журнале всегда предшествует <code>Gtid_log_event</code>. Транзакции
GTID могут быть адресованы, используя GTID или имя файла и позицию.</li>

<li>Анонимным транзакциям не назначают GTID, и MySQL
гарантирует, что каждой анонимной транзакции в журнале предшествует
<code>Anonymous_gtid_log_event</code>. В предыдущих версиях анонимным
транзакциям не предшествовало никакое особое событие. Анонимные транзакции
могут быть адресованы только используя имя файла и позицию.</p></li></ul>

<p>Используя GTID, Вы можете использовать в своих интересах авторасположение
как использование <a href="funct.htm#function_wait-for-executed-gtid-set">
<code>WAIT_FOR_EXECUTED_GTID_SET()</code></a>,
<a href="server.htm#sysvar_session_track_gtids"><code>session_track_gtids
</code></a> и отслеживать копирование транзакций через Performance Schema. С
GTID не может использоваться
<a href="#sysvar_sql_slave_skip_counter"><code>
sql_slave_skip_counter</code></a>, вместо этого
используйте пустые транзакции.</p>

<p>Транзакциям в журнале реле, который был получен от ведущего устройства,
выполняющего предыдущую версию MySQL, не может предшествовать никакое особое
событие вообще, но будучи переигранными и записанными в двоичный журнал
ведомого устройства, они предваряются <code>Anonymous_gtid_log_event</code>.
</p>

<p>Способность сконфигурировать режим репликации онлайн означает, что
переменные <a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
и <a href="#sysvar_enforce_gtid_consistency"><code>
enforce_gtid_consistency</code></a> являются теперь динамическими и могут
быть установлены из высокоуровневого запроса. В MySQL 5.6 и ниже обе эти
переменные могли быть сконфигурированы только используя соответствующую опцию
при запуске сервера. То есть, изменения режима репликации требовали
перезапуска сервера. Во всех версиях <a href="#sysvar_gtid_mode">
<code>gtid_mode</code></a> может быть установлена в
<code>ON</code> или <code>OFF</code>, что соответствует тому, использовались
ли GTID, чтобы идентифицировать транзакции или нет. Когда
<a href="#sysvar_gtid_mode"><code>gtid_mode=ON</code></a>
невозможно копировать анонимные транзакции, а когда
<a href="#sysvar_gtid_mode"><code>gtid_mode=OFF</code></a>
только анонимные транзакции могут копироваться. Когда
<a href="#sysvar_gtid_mode"><code>gtid_mode=OFF_PERMISSIVE</code>
</a>, <span><em>новые</em></span> транзакции являются анонимными, в то время
как разрешается копировать GTID или анонимные транзакции. Когда
<a href="#sysvar_gtid_mode"><code>gtid_mode=ON_PERMISSIVE</code>
</a>, <span><em>новые</em></span> транзакции используют GTID, в то время как
разрешается копировать GTID или анонимные транзакции. Это означает, что
возможно иметь топологию репликации, у которой есть серверы, использующие
анонимные транзакции и GTID. Например, ведущее устройство с
<a href="#sysvar_gtid_mode"><code>gtid_mode=ON</code></a>
может копировать к ведомому устройству с
<a href="#sysvar_gtid_mode"><code>gtid_mode=ON_PERMISSIVE</code>
</a>. Допустимые значения для <a href="#sysvar_gtid_mode"><code>
gtid_mode</code></a> следующие и в этом порядке:</p>

<ul><li><p><code>OFF</code></li>
<li><code>OFF_PERMISSIVE</code></li>
<li><code>ON_PERMISSIVE</code></li>
<li><code>ON</code></p></li></ul>

<p>Важно отметить что статус <a href="#sysvar_gtid_mode"><code>
gtid_mode</code></a> может быть изменен только на один шаг за один раз,
основываясь на вышеупомянутом порядке. Например, если
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a> сейчас
<code>OFF_PERMISSIVE</code>, возможно изменить на
<code>OFF</code> или <code>ON_PERMISSIVE</code>, но не на <code>ON</code>.
Это должно гарантировать, что процесс изменения от анонимных транзакций до
транзакций GTID онлайн правильно обработан сервером. Когда Вы переключаетесь
между <a href="#sysvar_gtid_mode"><code>gtid_mode=ON</code></a> и
<a href="#sysvar_gtid_mode"><code>gtid_mode=OFF</code></a>,
статус GTID (другими словами значение
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>)
является постоянным. Это гарантирует, что набор GTID, который был применен
сервером, всегда сохраняется, независимо от изменений между типами
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>.</p>

<p>Области, связанные с GTID, выводят на экран правильную информацию
независимо от в настоящее время выбранного
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>.
Это означает, что области, которые выводят на экран наборы GTID, например,
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>,
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>,
<code>RECEIVED_TRANSACTION_SET</code> в таблице
<a href="perfor.htm#replication-connection-status-table"><code>
replication_connection_status</code></a> Performance Schema и связанные с
GTID результаты <a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS
</code></a>, теперь возвратят пустую строку, когда нет никаких существующих
GTID. Области, которые выводят на экран единственный GTID, например,
<code>CURRENT_TRANSACTION</code> в таблице
<a href="perfor.htm#replication-applier-status-by-worker-table">
<code>replication_applier_status_by_worker</code></a> Performance Schema
теперь выведут на экран <code>ANONYMOUS</code>,
когда транзакции GTID не используются.</p>

<p>Репликация от ведущего, использующего
<a href="#sysvar_gtid_mode"><code>gtid_mode=ON</code></a>
обеспечивает способность использовать авторасположение, сконфигурированное
использованием <code>CHANGE MASTER TO MASTER_AUTO_POSITION = 1;</code>.
Топология репликации, использующая то, возможно ли позволить авторасположение
или нет, как эта особенность, полагается на GTID и несовместима с анонимными
транзакциями. Ошибка произведена, если авторасположение включено и
сталкиваются с анонимной транзакцией. Сильно рекомендуется гарантировать, что
нет никаких анонимных транзакций, остающихся в топологии прежде, чем
позволить авторасположение, см.
<a href="#replication-mode-change-online-enable-gtids">
раздел 19.1.5.2</a>. Допустимые комбинации
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
и авторасположения на ведущем и ведомом устройствах показывают в следующей
таблице, где <a href="#sysvar_gtid_mode"><code>gtid_mode</code>
</a> ведущего устройства показано по горизонтали, а
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
ведомого по вертикали:</p>

<a name="idm139965309550896"></a><p><b>Таблица 19.1. Допустимые комбинации
gtid_mode ведущего и ведомого устройств</b></p>
<table border="1">
<thead><tr><th scope="col">Ведущее/Ведомое устройство
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a></th>
<th scope="col"><pre>OFF</pre></th>
<th scope="col"><pre>OFF_PERMISSIVE</pre></th>
<th scope="col"><pre>ON_PERMISSIVE</pre></th>
<th scope="col"><pre>ON</pre></th></tr></thead>
<tbody><tr><td scope="row"><pre>OFF</pre></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N</p></td>
<td><p>N</p></td></tr>
<tr><td scope="row">
<pre>
OFF_PERMISSIVE
</pre></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y*</p></td></tr>
<tr><td scope="row">
<pre>
ON_PERMISSIVE
</pre></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y*</p></td></tr>
<tr><td scope="row"><pre>ON</pre></td>
<td><p>N</p></td>
<td><p>N</p></td>
<td><p>Y</p></td>
<td><p>Y*</p></td></tr></tbody></table>

<p>В вышеупомянутой таблице записи:</p>
<ul><li><p><code>Y</code>: <a href="#sysvar_gtid_mode"><code>
gtid_mode</code></a> ведущего и ведомого устройств совместимы.</li>

<li><code>N</code>: <a href="#sysvar_gtid_mode"><code>gtid_mode
</code></a> ведущего и ведомого устройств несовместимы.</li>
<li><code>*</code>: авторасположение может использоваться.</p></li></ul>

<p>В настоящее время выбираемое <a href="#sysvar_gtid_mode"><code>
gtid_mode</code></a> также воздействует на
<a href="#sysvar_gtid_next"><code>gtid_next</code></a>.
Следующая таблица показывает поведение сервера для различных значений
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a> и
<a href="#sysvar_gtid_next"><code>gtid_next</code></a>.</p>

<a name="idm139965309508048"></a><p><b>Таблица 19.2. Допустимые комбинации
gtid_mode и gtid_next</b></p>
<table border="1">
<thead><tr><th scope="col"><p>
<a href="#sysvar_gtid_next"><code>gtid_next</code></a></p></th>
<th scope="col"><p>AUTOMATIC</p><p>binary log on</p></th>
<th scope="col"><p>AUTOMATIC</p><p>binary log off</p></th>
<th scope="col"><p>ANONYMOUS</p></th>
<th scope="col"><p>UUID:NUMBER</p></th></tr></thead>

<tbody><tr><td scope="row"><pre>OFF</pre></td>
<td><p>ANONYMOUS</p></td>
<td><p>ANONYMOUS</p></td>
<td>ANONYMOUS</td>
<td><p>Ошибка</p></td></tr>
<tr><td scope="row"><pre>OFF_PERMISSIVE</pre></td>
<td><p>ANONYMOUS</p></td>
<td><p>ANONYMOUS</p></td>
<td><p>ANONYMOUS</p></td>
<td><p>UUID:NUMBER</p></td></tr>
<tr><td scope="row"><pre>ON_PERMISSIVE</pre></td>
<td><p>Новый GTID</p></td>
<td><p>ANONYMOUS</p></td>
<td><p>ANONYMOUS</p></td>
<td><p>UUID:NUMBER</p></td></tr>
<tr><td scope="row"><pre>ON</pre></td>
<td><p>Новый GTID</p></td>
<td><p>ANONYMOUS</p></td>
<td><p>Ошибка</p></td>
<td><p>UUID:NUMBER</p></td></tr></tbody></table>

<p>В вышеупомянутой таблице записи:</p>
<ul><li><p><code>ANONYMOUS</code>: произведет анонимную транзакцию.</li>
<li><code>Ошибка</code>: произведет ошибку и не в состоянии выполнить
<code>SET GTID_NEXT</code>.</li>
<li><code>UUID:NUMBER</code>: произведет GTID с указанным UUID:NUMBER.</li>
<li><code>Новый GTID</code>: произведет
GTID с автоматически произведенным числом.</p></li></ul>

<p>Когда двоичной журнал выключен и
<a href="#sysvar_gtid_next"><code>gtid_next</code></a> =
<code>AUTOMATIC</code>, GTID не произведен. Это совместимо с
поведением предыдущих версий.</p>

<h4><a name="replication-mode-change-online-enable-gtids"></a>19.1.5.2.
Включение транзакции GTID онлайн</h4>
<p>Этот раздел описывает, как включить транзакции GTID и произвольно
авторасположение на серверах, которые уже используют анонимныме транзакции.
Эта процедура не требует останова сервера и подходит для использования в
производстве. Однако, если у Вас есть возможность остановить сервер, включая
транзакциям GTID, этот процесс легче.</p>

<p>Прежде, чем Вы начнете, гарантируйте, что серверы удовлетворяют
следующим предварительным условиям:</p>
<ul><li><p><span><em>ВСЕ</em></span> серверы в Вашей топологии должны
использовать MySQL 5.7.6 или позже. Вы не можете включить транзакциям GTID
онлайн на любом единственном сервере, если не <span><em>все</em></span>
серверы, которые находятся в топологии, используют эту версию.</li>
<li>Все серверы имеют <a href="#sysvar_gtid_mode"><code>gtid_mode
</code></a> в значении по умолчанию <code>OFF</code>.</p></li></ul>

<p>Следующая процедура может быть поставлена на паузу в любое время и позже
возобновлена или отменена, чтобы отключить GTID. Это делает процедуру
отказоустойчивой, потому что любые несвязанные проблемы, которые могут
появиться в середине процедуры, могут быть обработаны как обычно, а
затем процедура продолжена.</p>

<p>Крайне важно, чтобы Вы завершили каждый шаг прежде, чем
перейти к следующему шагу.</p>
<p>Чтобы включить транзакции GTID:</p>
<ol type="1"><li><p>На каждом сервере выполните:
<pre>
SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = WARN;
</pre>

<p>Позвольте серверу работать некоторое время с Вашей нормальной рабочей
нагрузкой и контролируйте журналы. Если этот шаг вызывает какие-либо
предупреждения в журнале, скорректируйте свое приложение так, чтобы это
использовало только GTID-совместимые функции и не произвело предупреждений.
</p>

<p>Это первый важный шаг. Вы должны гарантировать, что никакие предупреждения
не производятся в журналах ошибок прежде, чем идти дальше.</p></li>
<li>На каждом сервере выполните:
<pre>
SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = ON;
</pre></li>

<li>На каждом сервере выполните:
<pre>
SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;
</pre>

<p>Не имеет значения, какой сервер выполняет этот запрос сначала, но важно,
чтобы все серверы завершили этот шаг прежде, чем любой сервер
начнет следующий шаг.</li>

<li>На каждом сервере выполните:
<pre>
SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;
</pre>
<p>Не имеет значения, какой сервер выполняет этот запрос сначала.</li>

<li>На каждом сервере ждите, пока переменная
<code>ONGOING_ANONYMOUS_TRANSACTION_COUNT</code> не станет 0.
Это может быть проверено, используя:
<pre>
SHOW STATUS LIKE 'ONGOING_ANONYMOUS_TRANSACTION_COUNT';
</pre>

<p>На ведомом устройстве репликации теоретически возможно, что это показывает
ноль и затем отличное от нуля значение снова. Это не проблема, достаточно,
что переменная показывает ноль однажды.</p></li>

<li>Ждите всех транзакций, произведенных к шагу 5, чтобы копировать ко всем
серверам. Вы можете сделать это, не останавливая обновления: единственная
важная вещь состоит в том, что копируются все анонимные транзакции.</p>

<p>См. <a href="#replication-mode-change-online-verify-transactions">
раздел 19.1.5.4</a> для одного метода проверки, что все анонимные транзакции
скопировались ко всем серверам.</li>

<li>Если Вы используете двоичные журналы для чего-нибудь кроме репликации,
например, резервного копирования момента времени и восстановления, ждете,
пока Вы не нуждаетесь в старых двоичных журналах, имеющих
транзакции без GTID.</p>

<p>Например, после того, как шаг 6 завершился, Вы можете выполнить
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a> на сервере, где Вы берете
резервные копии. Тогда явно выполните резервное копирование или ждите
следующей итерации любой периодической резервной подпрограммы, которую
Вы, возможно, настроили.</p>

<p>Идеально надо произвести чистку всех двоичных журналов,
которые существовали, когда шаг 6 был завершен.
Также ждите любого резервного копирования перед шагом 6.</p>

<p>Это второй важный момент. Жизненно важно понять, что двоичные журналы,
содержащие анонимные транзакции без GTID, не могут использоваться после
следующего шага. После этого шага Вы должны убедиться, что транзакции без
GTID не существуют нигде в топологии.</li>

<li>На каждом сервере выполните:
<pre>
SET @@GLOBAL.GTID_MODE = ON;
</pre></li>

<li>На каждом сервере добавьте <code>gtid-mode=ON</code> в
файл <code>my.cnf</code>.</p>
<p>Вы теперь гарантируете, что у всех транзакций есть GTID (кроме транзакций,
произведенных в шаге 5 или ранее, которые были уже обработаны).
Чтобы начать использовать протокол GTID так, чтобы Вы могли позже
работать автоматически, выполните следующее на каждом ведомом устройстве.
Произвольно, если Вы используете мультирепликацию, сделайте это для каждого
канала и включите <code>FOR CHANNEL <em><code>channel</code></em></code>:
<pre>
STOP SLAVE [FOR CHANNEL 'channel'];
CHANGE MASTER TO MASTER_AUTO_POSITION = 1 [FOR CHANNEL 'channel'];
START SLAVE [FOR CHANNEL 'channel'];
</pre></li></ol>

<h4><a name="replication-mode-change-online-disable-gtids"></a>19.1.5.3.
Отключение транзакции GTID онлайн</h4>
<p>Этот раздел описывает, как отключить транзакции GTID на серверах,
которые уже онлайн. Эта процедура не требует останова сервера
и подходит для использования в производстве. Однако, если у Вас есть
возможность останова сервера, отключая режим GTID, этот процесс легче.</p>

<p>Процесс подобен включению транзакций GTID, когда
сервер онлайн, но с изменением шагов. Единственной вещью, которая отличается,
является пункт, в котором Вы ждете копирования зарегистрированных транзакций.
</p>

<p>Прежде, чем Вы начнете, гарантируйте, что серверы удовлетворяют
следующим предварительным условиям:</p>
<ul><li><p><span><em>ВСЕ</em></span> серверы в Вашей топологии должны
использовать MySQL 5.7.6 или позже. Вы не можете включить транзакциям GTID
онлайн на любом единственном сервере, если не <span><em>все</em></span>
серверы, которые находятся в топологии, используют эту версию.</li>
<li>Все серверы имеют <a href="#sysvar_gtid_mode"><code>
gtid_mode</code></a> в значение <code>ON</code>.</p></li></ul>

<ol type="1"><li><p>Выполните следующее для каждого ведомого устройства, и
если Вы используете мультирепликацию, сделайте это для каждого канала и
включите <code>FOR CHANNEL</code>:
<pre>
STOP SLAVE [FOR CHANNEL 'channel'];
CHANGE MASTER TO MASTER_AUTO_POSITION = 0, MASTER_LOG_FILE = file, \
       MASTER_LOG_POS = position [FOR CHANNEL 'channel'];
START SLAVE [FOR CHANNEL 'channel'];
</pre></li>

<li>На каждом сервере выполните:
<pre>
SET @@GLOBAL.GTID_MODE = ON_PERMISSIVE;
</pre></li>

<li>На каждом сервере выполните:
<pre>
SET @@GLOBAL.GTID_MODE = OFF_PERMISSIVE;
</pre></li>

<li>На каждом сервере ждите, пока переменная @@GLOBAL.GTID_OWNED не станет
пустой строкой, проверить это можно так:
<pre>
SELECT @@GLOBAL.GTID_OWNED;
</pre>
<p>На ведомом устройстве репликации теоретически возможно, что это пусто и
затем не пусто снова. Это не проблема, достаточно, что это пусто однажды.
</li>

<li>Ждите копирования всех транзакций, которые в настоящее время существуют в
любом двоичном журнале, ко всем ведомым устройствам. См.
<a href="#replication-mode-change-online-verify-transactions">
раздел 19.1.5.4</a> для одного метода проверки, что все анонимные транзакции
скопировались ко всем серверам.</li>

<li>Если Вы используете двоичные журналы для чего-либо еще, кроме репликации,
например, чтобы сделать копию момента времени, ждите, пока Вы
не нуждаетесь в старых двоичных журналах, имеющих транзакции GTID.</p>

<p>Например, после того, как шаг 5 завершился, Вы можете выполнить
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a> на сервере, где Вы
делаете резервное копирование. Тогда явно выполните резервное копирование или
ждите следующей итерации любой периодической резервной подпрограммы, которую
Вы, возможно, настроили.</p>

<p>Идеально произведите чистку всех двоичных журналов, которые существовали,
когда шаг 5 был завершен.</p>
<p>Это важный момент во время этой процедуры. Важно понять, что журналы,
содержащие транзакции GTID, не могут использоваться после следующего шага.
Прежде чем продолжить, Вы должны убедиться, что транзакции GTID
не существуют нигде в топологии.</p></li>

<li>На каждом сервере выполните:
<pre>
SET @@GLOBAL.GTID_MODE = OFF;
</pre></li>
<li>На каждом сервере установите в <code>my.cnf</code>
<a href="#sysvar_gtid_mode"><code>gtid-mode=OFF</code></a>.</p>

<p>Если Вы хотите установить
<a href="#sysvar_enforce_gtid_consistency"><code>
enforce_gtid_consistency=OFF</code></a>, Вы можете сделать это
теперь. После установки этого Вы должны добавить
<a href="#sysvar_enforce_gtid_consistency"><code>
enforce_gtid_consistency=OFF</code></a> к Вашему конфигурационному файлу.
</p></li></ol>
<p>Если Вы хотите откатиться к более ранней версии MySQL, Вы можете сделать
это теперь, используя нормальную процедуру.</p>

<h4><a name="replication-mode-change-online-verify-transactions"></a>
19.1.5.4. Подтверждение репликации анонимных транзакций</h4>
<p>Этот раздел объясняет, как контролировать топологию репликации и
проверить, что скопировались все анонимные транзакции. Это полезно, изменяя
режим репликации онлайн, поскольку Вы можете проверить, что безопасно
измениться на транзакции GTID.</p>

<p>Есть несколько возможных способов ждать, чтобы скопировать транзакции:</p>
<p>-Самый простой метод, который работает независимо от Вашей топологии,
но полагается на синхронизацию, следующий: если Вы уверены, что ведомое
устройство никогда не задерживается больше, чем на N секунд,
только ждите некоторое время больше, чем N секунд. Или ждите в течение дня,
или безотносительно периода времени, который Вы считаете безопасным
для Вашего развертывания.</p>

<p>Более безопасный метод в том смысле, что это не зависит от синхронизации:
если у Вас есть ведущее устройство с одним или более ведомыми
устройствами, сделайте следующее:</p>

<ol type="1"><li><p>На ведущем устройстве выполните:
<pre>
SHOW MASTER STATUS;
</pre>
<p>Запишите значения в столбцах <code>File</code> и <code>Position</code>.
</li>

<li>На каждом ведомом устройстве, используйте информацию
от ведущего устройства, чтобы выполнить:
<pre>
SELECT MASTER_POS_WAIT(file, position);
</pre></li></ol>

<p>Если у Вас есть ведущее устройство и несколько уровней ведомых устройств,
или другими словами Вы имеете ведомые устройства ведомых устройств,
повторите шаг 2 на каждом уровне.</p>

<p>Если Вы используете круговую топологию репликации, где много серверов
могут иметь много пишущих клиентов, выполните шаг 2 для каждого основного
ведомого соединения, пока Вы не завершили полный круг. Повторите процесс так,
чтобы Вы сделали полный круг <span><em>дважды</em></span>.</p>

<p>Например, предположите, что у Вас есть три сервера A, B и C, копирующие по
кругу так, чтобы A -&gt; B -&gt; C -&gt; A. Процедура тогда:</p>
<ul><li><p>Сделайте шаг 1 на A и шаг 2 на B.</li>
<li>Сделайте шаг 1 на B и шаг 2 на C.</li>

<li>Сделайте шаг 1 на C и шаг 2 на A.</li>
<li>Сделайте шаг 1 на A и шаг 2 на B.</li>
<li>Сделайте шаг 1 на B и шаг 2 на C.</li>
<li>Сделайте шаг 1 на C и шаг 2 на A.</p></li></ul>

<h3><a name="replication-options"></a>19.1.6.
Репликация и опции двоичного журналирования</h3>
<p>Следующие разделы содержат информацию об опциях
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
и переменных сервера, которые используются в репликации и для того, чтобы
управлять двоичным журналом. Опции и переменные для использования на ведущих
устройствах репликации и ведомых устройствах репликации рассмотрены
отдельно, как опции и переменные, касающиеся двоичного журналирования
и глобальных операционных идентификаторов (GTID). Ряд таблиц, обеспечивающих
основную информацию об этих опциях и переменных, также есть.</p>

<p><a name="option_mysqld_server-id"></a>Из особого значения
<a href="#option_mysqld_server-id"><code>--server-id</code></a>.
</p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--server-id=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_server_id">server_id</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Эта опция характерна для основных и для ведомых серверов репликации и
используется в репликации, чтобы позволить основным и ведомым серверам
идентифицировать себя уникально. Для дополнительной информации см. разделы
<a href="#replication-options-master">19.1.6.2</a> и
<a href="#replication-options-slave">19.1.6.3</a>.</p>

<p>На ведущем устройстве и каждом ведомом устройстве, Вы <span><em>должны
</em></span> использовать <a href="#option_mysqld_server-id">
<code>--server-id</code></a>, чтобы установить уникальный ID репликации в
диапазоне от 1 до 2<sup>32</sup>-1. <span><span>Уникальный</span></span>
значит, что каждый ID должен отличаться от любого ID в использовании любым
другим ведущим устройством репликации или ведомым устройством. Например,
<code>server-id=3</code>.</p>

<p><code>--server-id</code> должен использоваться, если двоичное
журналирование включено, и значение 0 не изменено сервером. Если Вы
определяете <a href="#option_mysqld_server-id"><code>--server-id
</code></a> без параметра эффект тот же самый, как использование 0. В любом
случае, если <code>server_id</code> = 0, двоичное журналирование имеет место,
но ведомые устройства не могут соединиться с ведущим устройством, и при этом
любые другие серверы не могут соединиться с ним как ведомые устройства
(Bug #11763963, Bug #56718).</p>
<p>См. <a href="#replication-howto-slavebaseconfig">раздел
19.1.2.2</a>.</p>

<p><a name="sysvar_server_uuid"></a>
<a href="#sysvar_server_uuid"><code>server_uuid</code></a></p>
<p>В MySQL 8.0 сервер производит истинный UUID в дополнение к
<a href="#option_mysqld_server-id"><code>--server-id</code></a>,
поставляемому пользователем. Это доступно как глобальная переменная только
для чтения <a href="#sysvar_server_uuid"><code>server_uuid</code>
</a>.</p>

<p>Присутствие <a href="#sysvar_server_uuid"><code>server_uuid
</code></a> в MySQL 8.0 не изменяет требование того, чтобы был установлен
уникальный <a href="#option_mysqld_server-id"><code>--server-id
</code></a> для каждого сервера MySQL как часть подготовки и выполнения
репликации MySQL, как описано ранее в этом разделе.</p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_server_uuid">server_uuid</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Запускаясь, сервер MySQL автоматически получает UUID следующим образом:
</p>
<ol type="1"><li><p>Попытаться считать и использовать UUID, написанный в
файле <code><em><code>data_dir</code></em>/auto.cnf</code>
(<em><code>data_dir</code></em> это каталог данных сервера).</li>

<li>Если <code><em><code>data_dir</code></em>/auto.cnf</code>
не найден, произвести новый UUID и сохранить его в этом файле, создавая
файл в случае необходимости.</p></li></ol>

<p><code>auto.cnf</code> имеет формат похожий на <code>my.cnf</code> или
<code>my.ini</code>. В MySQL 8.0 <code>auto.cnf</code> имеет только один
раздел <code>[auto]</code> раздел, содержащий параметр
<a href="#sysvar_server_uuid"><code>server_uuid</code></a>,
содержание файла кажется подобным тому, что показывают здесь:
<pre>
[auto]
server_uuid=8a94f357-aab4-11df-86ab-c80aa9429562
</pre>
<p><code>auto.cnf</code> автоматически произведен, не пытайтесь написать или
изменить этот файл.</p>

<p>Используя репликацию MySQL, ведущие и ведомые устройства знают UUID друг
друга. Значение UUID ведомого устройства может быть замечено в выводе
<a href="sql.htm#show-slave-hosts"><code>SHOW SLAVE HOSTS</code></a>.
Когда <a href="sql.htm#start-slave"><code>START SLAVE</code></a>
был выполнен, значение UUID ведущего устройства доступно на ведомом
устройстве в выводе <a href="sql.htm#show-slave-status"><code>
SHOW SLAVE STATUS</code></a>.</p>

<p><a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> или
<a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a>
<span><em>не</em></span> сбрасывает UUID ведущего устройства как
использующийся на ведомом устройстве.</p>

<p>Серверный <code>server_uuid</code> также используется в GTID для
транзакций, происходящих на том сервере. Для получения дополнительной
информации см. <a href="#replication-gtids">раздел 19.1.3</a>.</p>

<p>Запускаясь, ведомый поток ввода/вывода производит ошибку и прерывается,
если UUID ведущего устройства не равен собственному, если установлена опция
<a href="#option_mysqld_replicate-same-server-id"><code>
--replicate-same-server-id</code></a>. Кроме того, ведомый поток ввода/вывода
производит предупреждение, если любое из следующего истина:</p>

<ul><li><p>Не найдено никакое ведущее устройство, имеющее ожидаемый
<a href="#sysvar_server_uuid"><code>server_uuid</code></a>.</li>
<li><a href="#sysvar_server_uuid"><code>server_uuid</code></a>
ведущего устройства изменился, хотя не было запроса
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>.
</p></li></ul>

<h4><a name="replication-options-table"></a>19.1.6.1.
Репликация и опции двоичного журналирования</h4>
<p>Следующие таблицы приводят основную информацию о параметрах командной
строки MySQL и системных переменных, применимых к
репликации и двоичному журналу.</p>

<a name="replication-optvar-summary-table"></a>
<p><b>Таблица 19.3. Обзор опций и переменных репликации в MySQL 8.0</b></p>
<table>
<thead><tr><th colspan="3" align="center">Имя</th></tr>
<tr><th>Командная строка</th><th>Системная?</th>
<th>Статусная?</th></tr><tr><th>Файл опций</th><th>Контекст</th>
<th>Динамическая?</th></tr><tr><th colspan="3">Примечания</th></tr></thead>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#option_mysqld_abort-slave-event-count">
abort-slave-event-count</a></code></p></td></tr>
<tr><td>Да</td>
<td>Нет</td>
<td>Нет</td></tr>
<tr><td>Да</td>
<td></td>
<td>Нет</td></tr>
<tr><td colspan="3">ОПИСАНИЕ: Опция, используемая mysql-test
для отладки и тестирования репликации.</p></td></tr>
<tr><td colspan="3" align="center"><code>
<a href="#sysvar_binlog_gtid_simple_recovery">
binlog_gtid_simple_recovery</a></code></p></td></tr>
<tr><td>Да</td>
<td>Да</td>
<td>Нет</td></tr>
<tr><td>Да</td>
<td>Глобальная</td>
<td>Нет</td></tr>
<tr><td colspan="3">ОПИСАНИЕ: Средство управления, как двоичные журналы
повторены во время восстановления GTID.</p></td></tr>
<tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_change_master</a></code>
</p></td></tr>
<tr><td headers="rowCom_change_master replicationcli">Нет</td>
<td headers="rowCom_change_master replicationsysvar">Нет</td>
<td headers="rowCom_change_master replicationstatvar">Да</td></tr>
<tr><td headers="rowCom_change_master replicationoptfile">Нет</td>
<td headers="rowCom_change_master replicationscope">Both</td>
<td headers="rowCom_change_master replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Счетчик CHANGE MASTER TO</p></td></tr></tbody>

<tbody><tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_show_master_status</a></code>
</p></td></tr>
<tr><td headers="rowCom_show_master_status replicationcli">Нет</td>
<td headers="rowCom_show_master_status replicationsysvar">Нет</td>
<td headers="rowCom_show_master_status replicationstatvar">Да</td></tr>
<tr><td headers="rowCom_show_master_status replicationoptfile">Нет</td>
<td headers="rowCom_show_master_status replicationscope">Both</td>
<td headers="rowCom_show_master_status replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Счетчик SHOW MASTER STATUS</p></td></tr></tbody>

<tbody><tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_show_new_master</a></code>
</p></td></tr>
<tr><td headers="rowCom_show_new_master replicationcli">Нет</td>
<td headers="rowCom_show_new_master replicationsysvar">Нет</td>
<td headers="rowCom_show_new_master replicationstatvar">Да</td></tr>
<tr><td headers="rowCom_show_new_master replicationoptfile">Нет</td>
<td headers="rowCom_show_new_master replicationscope">Both</td>
<td headers="rowCom_show_new_master replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowCom_show_new_master replicationnotes"><p>
Счетчик SHOW NEW MASTER</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_show_slave_hosts</a></code>
</p></td></tr>
<tr><td headers="rowCom_show_slave_hosts replicationcli">Нет</td>
<td headers="rowCom_show_slave_hosts replicationsysvar">Нет</td>
<td headers="rowCom_show_slave_hosts replicationstatvar">Да</td></tr>
<tr><td headers="rowCom_show_slave_hosts replicationoptfile">Нет</td>
<td headers="rowCom_show_slave_hosts replicationscope">Both</td>
<td headers="rowCom_show_slave_hosts replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Счетчик SHOW SLAVE HOSTS</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_show_slave_status</a></code>
</p></td></tr>
<tr><td headers="rowCom_show_slave_status replicationcli">Нет</td>
<td headers="rowCom_show_slave_status replicationsysvar">Нет</td>
<td headers="rowCom_show_slave_status replicationstatvar">Да</td></tr>
<tr><td headers="rowCom_show_slave_status replicationoptfile">Нет</td>
<td headers="rowCom_show_slave_status replicationscope">Both</td>
<td headers="rowCom_show_slave_status replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Счетчик SHOW SLAVE STATUS</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_show_slave_status_nonblocking
</a></code></p></td></tr>
<tr><td headers="rowCom_show_slave_status_nonblocking replicationcli">Нет</td>
<td headers="rowCom_show_slave_status_nonblocking replicationsysvar">Нет</td>
<td headers="rowCom_show_slave_status_nonblocking replicationstatvar">Да
</td></tr>
<tr><td headers="rowCom_show_slave_status_nonblocking replicationoptfile">
Нет</td>
<td headers="rowCom_show_slave_status_nonblocking replicationscope">Both</td>
<td headers="rowCom_show_slave_status_nonblocking replicationdynamic">Нет
</td></tr>
<tr><td colspan="3"><p>Счетчик SHOW SLAVE STATUS NONBLOCKING</p>
</td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_slave_start</a></code>
</p></td></tr>
<tr><td headers="rowCom_slave_start replicationcli">Нет</td>
<td headers="rowCom_slave_start replicationsysvar">Нет</td>
<td headers="rowCom_slave_start replicationstatvar">Да</td></tr>
<tr><td headers="rowCom_slave_start replicationoptfile">Нет</td>
<td headers="rowCom_slave_start replicationscope">Both</td>
<td headers="rowCom_slave_start replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Счетчик START SLAVE</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_slave_stop</a></code>
</p></td></tr>
<tr><td headers="rowCom_slave_stop replicationcli">Нет</td>
<td headers="rowCom_slave_stop replicationsysvar">Нет</td>
<td headers="rowCom_slave_stop replicationstatvar">Да</td></tr>
<tr><td headers="rowCom_slave_stop replicationoptfile">Нет</td>
<td headers="rowCom_slave_stop replicationscope">Both</td>
<td headers="rowCom_slave_stop replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Счетчик STOP SLAVE</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#option_mysqld_disconnect-slave-event-count">
disconnect-slave-event-count</a></code>
</p></td></tr>
<tr><td headers="rowdisconnect-slave-event-count replicationcli">Да</td>
<td headers="rowdisconnect-slave-event-count replicationsysvar">Нет</td>
<td headers="rowdisconnect-slave-event-count replicationstatvar">Нет</td></tr>
<tr><td headers="rowdisconnect-slave-event-count replicationoptfile">Да</td>
<td headers="rowdisconnect-slave-event-count replicationscope"></td>
<td headers="rowdisconnect-slave-event-count replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Опция, используемая mysql-test для
отладки и тестирования репликации.</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#option_mysqld_enforce-gtid-consistency">
enforce-gtid-consistency</a></code></p></td></tr>
<tr><td headers="rowenforce-gtid-consistency replicationcli">Да</td>
<td headers="rowenforce-gtid-consistency replicationsysvar">Да</td>
<td headers="rowenforce-gtid-consistency replicationstatvar">Нет</td></tr>
<tr><td headers="rowenforce-gtid-consistency replicationoptfile">Да</td>
<td headers="rowenforce-gtid-consistency replicationscope">Глобальная</td>
<td headers="rowenforce-gtid-consistency replicationdynamic">Да</td></tr>
<tr><td colspan="3"><p>Предотвращает выполнение запросов, которые не могут
быть зарегистрированы транзакционным образом.</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#sysvar_enforce_gtid_consistency">
enforce_gtid_consistency</a></code></p></td></tr>
<tr><td headers="rowenforce_gtid_consistency replicationcli">Да</td>
<td headers="rowenforce_gtid_consistency replicationsysvar">Да</td>
<td headers="rowenforce_gtid_consistency replicationstatvar">Нет</td></tr>
<tr><td headers="rowenforce_gtid_consistency replicationoptfile">Да</td>
<td headers="rowenforce_gtid_consistency replicationscope">Глобальная</td>
<td headers="rowenforce_gtid_consistency replicationdynamic">Да</td></tr>
<tr><td colspan="3"><p>Предотвращает выполнение запросов, которые не могут
быть зарегистрированы транзакционным образом.</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#option_mysqld_executed-gtids-compression-period">
executed-gtids-compression-period</a></code></p></td></tr>
<tr><td headers="rowexecuted-gtids-compression-period replicationcli">Да</td>
<td headers="rowexecuted-gtids-compression-period replicationsysvar">Нет</td>
<td headers="rowexecuted-gtids-compression-period replicationstatvar">Нет
</td></tr>
<tr><td headers="rowexecuted-gtids-compression-period replicationoptfile">
Да</td>
<td headers="rowexecuted-gtids-compression-period replicationscope"></td>
<td headers="rowexecuted-gtids-compression-period replicationdynamic">Нет
</td></tr>
<tr><td colspan="3"><p>Устарел и будет удален в будущей версии. Используйте
gtid-executed-compression-period.</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#sysvar_executed_gtids_compression_period">
executed_gtids_compression_period</a></code></p></td></tr>
<tr><td headers="rowexecuted_gtids_compression_period replicationcli">Нет</td>
<td headers="rowexecuted_gtids_compression_period replicationsysvar">Да</td>
<td headers="rowexecuted_gtids_compression_period replicationstatvar">Нет
</td></tr>
<tr><td headers="rowexecuted_gtids_compression_period replicationoptfile">
Нет</td>
<td headers="rowexecuted_gtids_compression_period replicationscope">
Глобальная</td>
<td headers="rowexecuted_gtids_compression_period replicationdynamic">
Да</td></tr>
<tr><td colspan="3"><p>Устарел и будет удален в будущей версии. Используйте
gtid_executed_compression_period.</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#option_mysqld_gtid-executed-compression-period">
gtid-executed-compression-period</a></code></p></td></tr>
<tr><td headers="rowgtid-executed-compression-period replicationcli">Да</td>
<td headers="rowgtid-executed-compression-period replicationsysvar">Нет</td>
<td headers="rowgtid-executed-compression-period replicationstatvar">Нет</td>
</tr>
<tr><td headers="rowgtid-executed-compression-period replicationoptfile">Да
</td>
<td headers="rowgtid-executed-compression-period replicationscope"></td>
<td headers="rowgtid-executed-compression-period replicationdynamic">Нет</td>
</tr>
<tr><td colspan="3"><p>Сжать таблицу каждый раз, когда выполнено
gtid_executed транзакций. 0 никогда не сжимает эту таблицу.
Применяется только, когда двоичное журналирование отключено.</p></td>
</tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#option_mysqld_gtid-mode">gtid-mode</a></code>
</p></td></tr>
<tr><td headers="rowgtid-mode replicationcli">Да</td>
<td headers="rowgtid-mode replicationsysvar">Да</td>
<td headers="rowgtid-mode replicationstatvar">Нет</td></tr>
<tr><td headers="rowgtid-mode replicationoptfile">Да</td>
<td headers="rowgtid-mode replicationscope">Глобальная</td>
<td headers="rowgtid-mode replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowgtid-mode replicationnotes"><p>
Средство управления включено ли журналирование GTID, и
какие транзакции журналы могут содержать.</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#sysvar_gtid_executed">gtid_executed</a></code>
</p></td></tr>
<tr><td headers="rowgtid_executed replicationcli">Нет</td>
<td headers="rowgtid_executed replicationsysvar">Да</td>
<td headers="rowgtid_executed replicationstatvar">Нет</td></tr>
<tr><td headers="rowgtid_executed replicationoptfile">Нет</td>
<td headers="rowgtid_executed replicationscope">Глобальная</td>
<td headers="rowgtid_executed replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Все GTID в двоичном журнале (глобальная) или текущая
транзакция (сеансовая). Только для чтения.</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#sysvar_gtid_executed_compression_period">
gtid_executed_compression_period</a></code></p></td></tr>
<tr><td headers="rowgtid_executed_compression_period replicationcli">Нет</td>
<td headers="rowgtid_executed_compression_period replicationsysvar">Да</td>
<td headers="rowgtid_executed_compression_period replicationstatvar">Нет</td>
</tr>
<tr><td headers="rowgtid_executed_compression_period replicationoptfile">Нет
</td>
<td headers="rowgtid_executed_compression_period replicationscope">Глобальная
</td>
<td headers="rowgtid_executed_compression_period replicationdynamic">Да</td>
</tr>
<tr><td colspan="3"><p>Сжать таблицу gtid_executed каждое число транзакций. 0
значит не сжмать вообще. Применяется только, когда
двоичное журналирование отключено.</p></td></tr></tbody>

<tbody><tr><td colspan="3" align="center"><p>
<code><a href="#sysvar_gtid_mode">gtid_mode</a></code>
</p></td></tr>
<tr><td headers="rowgtid_mode replicationcli">Нет</td>
<td headers="rowgtid_mode replicationsysvar">Да</td>
<td headers="rowgtid_mode replicationstatvar">Нет</td></tr>
<tr><td headers="rowgtid_mode replicationoptfile">Нет</td>
<td headers="rowgtid_mode replicationscope">Глобальная</td>
<td headers="rowgtid_mode replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowgtid_mode replicationnotes"><p>
Управляет включено ли GTID журналирование, и какие транзакции
журналы могут содержать.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_gtid_next">gtid_next</a></code></p>
</td></tr>
<tr><td headers="rowgtid_next replicationcli">Нет</td>
<td headers="rowgtid_next replicationsysvar">Да</td>
<td headers="rowgtid_next replicationstatvar">Нет</td></tr>
<tr><td headers="rowgtid_next replicationoptfile">Нет</td>
<td headers="rowgtid_next replicationscope">Session</td>
<td headers="rowgtid_next replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowgtid_next replicationnotes"><p>
Определяет GTID для следующего запроса, чтобы выполнить.
См. документацию для деталей.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_gtid_owned">gtid_owned</a></code>
</p></td></tr>
<tr><td headers="rowgtid_owned replicationcli">Нет</td>
<td headers="rowgtid_owned replicationsysvar">Да</td>
<td headers="rowgtid_owned replicationstatvar">Нет</td></tr>
<tr><td headers="rowgtid_owned replicationoptfile">Нет</td>
<td headers="rowgtid_owned replicationscope">Both</td>
<td headers="rowgtid_owned replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowgtid_owned replicationnotes"><p>
Набор GTID, принадлежащий этому клиенту (сеанс) или всем клиентам, вместе с
ID потока (глобально) владельца. Только для чтения.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_gtid_purged">gtid_purged</a></code>
</p></td></tr>
<tr><td headers="rowgtid_purged replicationcli">Нет</td>
<td headers="rowgtid_purged replicationsysvar">Да</td>
<td headers="rowgtid_purged replicationstatvar">Нет</td></tr>
<tr><td headers="rowgtid_purged replicationoptfile">Нет</td>
<td headers="rowgtid_purged replicationscope">Глобальная</td>
<td headers="rowgtid_purged replicationdynamic">Да</td></tr>
<tr><td colspan="3"><p>
Набор всех GTID, которые были вычищены из двоичного журнала.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_init_slave">init_slave</a></code>
</p></td></tr>
<tr><td headers="rowinit_slave replicationcli">Да</td>
<td headers="rowinit_slave replicationsysvar">Да</td>
<td headers="rowinit_slave replicationstatvar">Нет</td></tr>
<tr><td headers="rowinit_slave replicationoptfile">Да</td>
<td headers="rowinit_slave replicationscope">Глобальная</td>
<td headers="rowinit_slave replicationdynamic">Да</td></tr>
<tr><td colspan="3"><p>
Запросы, которые выполнены, когда ведомое устройство соединяется с ведущим.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3"><p><code>
<a href="#option_mysqld_log-slave-updates">log-slave-updates</a>
</code></p></td></tr>
<tr><td headers="rowlog-slave-updates replicationcli">Да</td>
<td headers="rowlog-slave-updates replicationsysvar">Да</td>
<td headers="rowlog-slave-updates replicationstatvar">Нет</td></tr>
<tr><td headers="rowlog-slave-updates replicationoptfile">Да</td>
<td headers="rowlog-slave-updates replicationscope">Глобальная</td>
<td headers="rowlog-slave-updates replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowlog-slave-updates replicationnotes"><p>
Говорит ведомому устройству регистрировать обновления,
выполненные его потоком SQL, в его собственном двоичном журнале.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_log_slave_updates">log_slave_updates</a>
</code></p></td></tr>
<tr><td headers="rowlog_slave_updates replicationcli">Да</td>
<td headers="rowlog_slave_updates replicationsysvar">Да</td>
<td headers="rowlog_slave_updates replicationstatvar">Нет</td></tr>
<tr><td headers="rowlog_slave_updates replicationoptfile">Да</td>
<td headers="rowlog_slave_updates replicationscope">Глобальная</td>
<td headers="rowlog_slave_updates replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowlog_slave_updates replicationnotes"><p>
Должно ли ведомое устройство зарегистрировать обновления, выполненные его
потоком SQL в его собственном двоичном журнале. Только для чтения,
устанавливается, используя параметр сервера --log-slave-updates.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_log_statements_unsafe_for_binlog">
log_statements_unsafe_for_binlog</a></code></p></td></tr>
<tr><td headers="rowlog_statements_unsafe_for_binlog replicationcli">Нет</td>
<td headers="rowlog_statements_unsafe_for_binlog replicationsysvar">Да</td>
<td headers="rowlog_statements_unsafe_for_binlog replicationstatvar">
Нет</td></tr>
<tr><td headers="rowlog_statements_unsafe_for_binlog replicationoptfile">Нет
</td>
<td headers="rowlog_statements_unsafe_for_binlog replicationscope">Глобальная
</td>
<td headers="rowlog_statements_unsafe_for_binlog replicationdynamic">Да</td>
</tr>
<tr><td colspan="3"><p>
Отключает ошибку 1592, написанную в журнал ошибок.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_master-info-file">master-info-file
</a></code></p></td></tr>
<tr><td headers="rowmaster-info-file replicationcli">Да</td>
<td headers="rowmaster-info-file replicationsysvar">Нет</td>
<td headers="rowmaster-info-file replicationstatvar">Нет</td></tr>
<tr><td headers="rowmaster-info-file replicationoptfile">Да</td>
<td headers="rowmaster-info-file replicationscope"></td>
<td headers="rowmaster-info-file replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>
Местоположение и название файла, который помнит ведущее устройство и где
поток ввода/вывода репликации находится в двоичных
журналах ведущего устройства.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_master-info-repository">
master-info-repository</a></code></p></td></tr>
<tr><td headers="rowmaster-info-repository replicationcli">Да</td>
<td headers="rowmaster-info-repository replicationsysvar">Нет</td>
<td headers="rowmaster-info-repository replicationstatvar">Нет</td></tr>
<tr><td headers="rowmaster-info-repository replicationoptfile">Да</td>
<td headers="rowmaster-info-repository replicationscope"></td>
<td headers="rowmaster-info-repository replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>
Написать ли основную информацию о статусе и местоположении потока
ввода/вывода репликации в двоичных журналах ведущего устройства в
файл или в таблицу.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_master-retry-count">
master-retry-count</a></code></p></td></tr>
<tr><td headers="rowmaster-retry-count replicationcli">Да</td>
<td headers="rowmaster-retry-count replicationsysvar">Нет</td>
<td headers="rowmaster-retry-count replicationstatvar">Нет</td></tr>
<tr><td headers="rowmaster-retry-count replicationoptfile">Да</td>
<td headers="rowmaster-retry-count replicationscope"></td>
<td headers="rowmaster-retry-count replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>
Число попыток, которые ведомое устройство делает, чтобы соединиться с ведущим
устройством перед отказом.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_master_info_repository">
master_info_repository</a></code></p></td></tr>
<tr><td headers="rowmaster_info_repository replicationcli">Да</td>
<td headers="rowmaster_info_repository replicationsysvar">Да</td>
<td headers="rowmaster_info_repository replicationstatvar">Нет</td></tr>
<tr><td headers="rowmaster_info_repository replicationoptfile">Да</td>
<td headers="rowmaster_info_repository replicationscope">Глобальная</td>
<td headers="rowmaster_info_repository replicationdynamic">Да</td></tr>
<tr><td colspan="3"><p>
Написать ли основную информацию о статусе и местоположении потока
ввода/вывода репликации в двоичных журналах ведущего устройства в
файл или в таблицу.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_relay-log">relay-log</a></code>
</p></td></tr>
<tr><td headers="rowrelay-log replicationcli">Да</td>
<td headers="rowrelay-log replicationsysvar">Да</td>
<td headers="rowrelay-log replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay-log replicationoptfile">Да</td>
<td headers="rowrelay-log replicationscope">Глобальная</td>
<td headers="rowrelay-log replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay-log replicationnotes"><p>
Местоположение и имя, чтобы использовать для журналов реле.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_relay-log-index">
relay-log-index</a></code></p></td></tr>
<tr><td headers="rowrelay-log-index replicationcli">Да</td>
<td headers="rowrelay-log-index replicationsysvar">Да</td>
<td headers="rowrelay-log-index replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay-log-index replicationoptfile">Да</td>
<td headers="rowrelay-log-index replicationscope">Глобальная</td>
<td headers="rowrelay-log-index replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay-log-index replicationnotes"><p>
Местоположение и имя, чтобы использовать для файла, который сохраняет список
последних журналов реле.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_relay-log-info-file">
relay-log-info-file</a></code></p></td></tr>
<tr><td headers="rowrelay-log-info-file replicationcli">Да</td>
<td headers="rowrelay-log-info-file replicationsysvar">Нет</td>
<td headers="rowrelay-log-info-file replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay-log-info-file replicationoptfile">Да</td>
<td headers="rowrelay-log-info-file replicationscope"></td>
<td headers="rowrelay-log-info-file replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay-log-info-file replicationnotes"><p>
Местоположение и название файла, который помнит, где поток репликации SQL
находится в журналах реле.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_relay-log-info-repository">
relay-log-info-repository</a></code></p></td></tr>
<tr><td headers="rowrelay-log-info-repository replicationcli">Да</td>
<td headers="rowrelay-log-info-repository replicationsysvar">Нет</td>
<td headers="rowrelay-log-info-repository replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay-log-info-repository replicationoptfile">Да</td>
<td headers="rowrelay-log-info-repository replicationscope"></td>
<td headers="rowrelay-log-info-repository replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Написать местоположение потока SQL в журнале реле в
файл или в таблицу.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_relay-log-recovery">
relay-log-recovery</a></code></p></td></tr>
<tr><td headers="rowrelay-log-recovery replicationcli">Да</td>
<td headers="rowrelay-log-recovery replicationsysvar">Нет</td>
<td headers="rowrelay-log-recovery replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay-log-recovery replicationoptfile">Да</td>
<td headers="rowrelay-log-recovery replicationscope"></td>
<td headers="rowrelay-log-recovery replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay-log-recovery replicationnotes"><p>
Включает автоматическое восстановление файлов системного журнала реле от
ведущего устройства при запуске.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_relay_log_basename">relay_log_basename</a>
</code></p></td></tr>
<tr><td headers="rowrelay_log_basename replicationcli">Нет</td>
<td headers="rowrelay_log_basename replicationsysvar">Да</td>
<td headers="rowrelay_log_basename replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay_log_basename replicationoptfile">Нет</td>
<td headers="rowrelay_log_basename replicationscope">Глобальная</td>
<td headers="rowrelay_log_basename replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay_log_basename replicationnotes"><p>
Полный путь к журналу реле, включая имя файла.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_relay_log_index">relay_log_index</a></code>
</p></td></tr>
<tr><td headers="rowrelay_log_index replicationcli">Да</td>
<td headers="rowrelay_log_index replicationsysvar">Да</td>
<td headers="rowrelay_log_index replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay_log_index replicationoptfile">Да</td>
<td headers="rowrelay_log_index replicationscope">Глобальная</td>
<td headers="rowrelay_log_index replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay_log_index replicationnotes"><p>
Название индексного файла журнала реле.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_relay_log_info_file">
relay_log_info_file</a></code></p></td></tr>
<tr><td headers="rowrelay_log_info_file replicationcli">Да</td>
<td headers="rowrelay_log_info_file replicationsysvar">Да</td>
<td headers="rowrelay_log_info_file replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay_log_info_file replicationoptfile">Да</td>
<td headers="rowrelay_log_info_file replicationscope">Глобальная</td>
<td headers="rowrelay_log_info_file replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay_log_info_file replicationnotes"><p>
Название файла, в котором ведомое устройство делает запись
информации о журналах реле.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_relay_log_info_repository">
relay_log_info_repository</a></code></p></td></tr>
<tr><td headers="rowrelay_log_info_repository replicationcli">Нет</td>
<td headers="rowrelay_log_info_repository replicationsysvar">Да</td>
<td headers="rowrelay_log_info_repository replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay_log_info_repository replicationoptfile">Нет</td>
<td headers="rowrelay_log_info_repository replicationscope">Глобальная</td>
<td headers="rowrelay_log_info_repository replicationdynamic">Да</td></tr>
<tr><td colspan="3"><p>Написать местоположение потока SQL в журнале реле в
файл или таблицу.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="server.htm#sysvar_relay_log_purge">relay_log_purge</a></code>
</p></td></tr>
<tr><td headers="rowrelay_log_purge replicationcli">Да</td>
<td headers="rowrelay_log_purge replicationsysvar">Да</td>
<td headers="rowrelay_log_purge replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay_log_purge replicationoptfile">Да</td>
<td headers="rowrelay_log_purge replicationscope">Глобальная</td>
<td headers="rowrelay_log_purge replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrelay_log_purge replicationnotes"><p>
Определяет, очищены ли журналы реле.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#sysvar_relay_log_recovery">relay_log_recovery</a>
</code></p></td></tr>
<tr><td headers="rowrelay_log_recovery replicationcli">Да</td>
<td headers="rowrelay_log_recovery replicationsysvar">Да</td>
<td headers="rowrelay_log_recovery replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay_log_recovery replicationoptfile">Да</td>
<td headers="rowrelay_log_recovery replicationscope">Глобальная</td>
<td headers="rowrelay_log_recovery replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrelay_log_recovery replicationnotes"><p>
Включено ли автоматическое восстановление файлов системного журнала реле от
ведущего устройства при запуске, должно быть включено для защиты от
катастрофического отказа ведомого устройства.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrelay_log_space_limit" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_relay_log_space_limit">relay_log_space_limit
</a></code></p></td></tr>
<tr><td headers="rowrelay_log_space_limit replicationcli">Да</td>
<td headers="rowrelay_log_space_limit replicationsysvar">Да</td>
<td headers="rowrelay_log_space_limit replicationstatvar">Нет</td></tr>
<tr><td headers="rowrelay_log_space_limit replicationoptfile">Да</td>
<td headers="rowrelay_log_space_limit replicationscope">Глобальная</td>
<td headers="rowrelay_log_space_limit replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowrelay_log_space_limit replicationnotes"><p>
Максимальное пространство, чтобы использовать для всех журналов реле.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreplicate-do-db" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_replicate-do-db">replicate-do-db</a>
</code></p></td></tr>
<tr><td headers="rowreplicate-do-db replicationcli">Да</td>
<td headers="rowreplicate-do-db replicationsysvar">Нет</td>
<td headers="rowreplicate-do-db replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-do-db replicationoptfile">Да</td>
<td headers="rowreplicate-do-db replicationscope"></td>
<td headers="rowreplicate-do-db replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreplicate-do-db replicationnotes"><p>
Говорит ведомому потоку SQL ограничивать репликацию указанной базой данных.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreplicate-do-table" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_replicate-do-table">
replicate-do-table</a></code></p></td></tr>
<tr><td headers="rowreplicate-do-table replicationcli">Да</td>
<td headers="rowreplicate-do-table replicationsysvar">Нет</td>
<td headers="rowreplicate-do-table replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-do-table replicationoptfile">Да</td>
<td headers="rowreplicate-do-table replicationscope"></td>
<td headers="rowreplicate-do-table replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreplicate-do-table replicationnotes"><p>
Говорит ведомому потоку SQL ограничивать репликацию указанной таблицей.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_replicate-ignore-db">
replicate-ignore-db</a></code></p></td></tr>
<tr><td headers="rowreplicate-ignore-db replicationcli">Да</td>
<td headers="rowreplicate-ignore-db replicationsysvar">Нет</td>
<td headers="rowreplicate-ignore-db replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-ignore-db replicationoptfile">Да</td>
<td headers="rowreplicate-ignore-db replicationscope"></td>
<td headers="rowreplicate-ignore-db replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreplicate-ignore-db replicationnotes"><p>
Говорит ведомому потоку SQL не копировать к указанной базе данных.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreplicate-ignore-table" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_replicate-ignore-table">
replicate-ignore-table</a></code>
</p></td></tr>
<tr><td headers="rowreplicate-ignore-table replicationcli">Да</td>
<td headers="rowreplicate-ignore-table replicationsysvar">Нет</td>
<td headers="rowreplicate-ignore-table replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-ignore-table replicationoptfile">Да</td>
<td headers="rowreplicate-ignore-table replicationscope"></td>
<td headers="rowreplicate-ignore-table replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreplicate-ignore-table replicationnotes"><p>
Говорит ведомому потоку SQL не копировать к указанной таблице.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreplicate-rewrite-db" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_replicate-rewrite-db">
replicate-rewrite-db</a></code></p></td></tr>
<tr><td headers="rowreplicate-rewrite-db replicationcli">Да</td>
<td headers="rowreplicate-rewrite-db replicationsysvar">Нет</td>
<td headers="rowreplicate-rewrite-db replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-rewrite-db replicationoptfile">Да</td>
<td headers="rowreplicate-rewrite-db replicationscope"></td>
<td headers="rowreplicate-rewrite-db replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreplicate-rewrite-db replicationnotes"><p>
Обновления базы данных с другим именем, чем оригинал.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreplicate-same-server-id" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_replicate-same-server-id">
replicate-same-server-id</a></code></p></td></tr>
<tr><td headers="rowreplicate-same-server-id replicationcli">Да</td>
<td headers="rowreplicate-same-server-id replicationsysvar">Нет</td>
<td headers="rowreplicate-same-server-id replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-same-server-id replicationoptfile">Да</td>
<td headers="rowreplicate-same-server-id replicationscope"></td>
<td headers="rowreplicate-same-server-id replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>
В репликации, если установлено в 1, не пропускать события, имеющие
id нашего сервера.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreplicate-wild-do-table" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_replicate-wild-do-table">
replicate-wild-do-table</a></code></p></td></tr>
<tr><td headers="rowreplicate-wild-do-table replicationcli">Да</td>
<td headers="rowreplicate-wild-do-table replicationsysvar">Нет</td>
<td headers="rowreplicate-wild-do-table replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-wild-do-table replicationoptfile">Да</td>
<td headers="rowreplicate-wild-do-table replicationscope"></td>
<td headers="rowreplicate-wild-do-table replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreplicate-wild-do-table replicationnotes"><p>
Говорит ведомому потоку ограничивать репликацию таблицами, которые
соответствуют указанному подстановочномму образцу.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreplicate-wild-ignore-table" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_replicate-wild-ignore-table">
replicate-wild-ignore-table</a></code></p></td></tr>
<tr><td headers="rowreplicate-wild-ignore-table replicationcli">Да</td>
<td headers="rowreplicate-wild-ignore-table replicationsysvar">Нет</td>
<td headers="rowreplicate-wild-ignore-table replicationstatvar">Нет</td></tr>
<tr><td headers="rowreplicate-wild-ignore-table replicationoptfile">Да</td>
<td headers="rowreplicate-wild-ignore-table replicationscope"></td>
<td headers="rowreplicate-wild-ignore-table replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>
Говорит ведомому потоку не копировать к таблицам, которые соответствуют
данному подстановочному образцу.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreport-host" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_report-host">report-host</a></code>
</p></td></tr>
<tr><td headers="rowreport-host replicationcli">Да</td>
<td headers="rowreport-host replicationsysvar">Да</td>
<td headers="rowreport-host replicationstatvar">Нет</td></tr>
<tr><td headers="rowreport-host replicationoptfile">Да</td>
<td headers="rowreport-host replicationscope">Глобальная</td>
<td headers="rowreport-host replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreport-host replicationnotes"><p>
Имя хоста или IP ведомого устройства, о котором сообщат ведущему устройству
во время ведомой регистрации.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="#option_mysqld_report-password">
report-password</a></code></p></td></tr>
<tr><td headers="rowreport-password replicationcli">Да</td>
<td headers="rowreport-password replicationsysvar">Да</td>
<td headers="rowreport-password replicationstatvar">Нет</td></tr>
<tr><td headers="rowreport-password replicationoptfile">Да</td>
<td headers="rowreport-password replicationscope">Глобальная</td>
<td headers="rowreport-password replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreport-password replicationnotes"><p>
Произвольный пароль, о котором ведомый сервер должен сообщить ведущему
устройству. Не то же самое как пароль для учетной записи
пользователя репликации MySQL.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreport-port" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_report-port">report-port</a></code>
</p></td></tr>
<tr><td headers="rowreport-port replicationcli">Да</td>
<td headers="rowreport-port replicationsysvar">Да</td>
<td headers="rowreport-port replicationstatvar">Нет</td></tr>
<tr><td headers="rowreport-port replicationoptfile">Да</td>
<td headers="rowreport-port replicationscope">Глобальная</td>
<td headers="rowreport-port replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreport-port replicationnotes"><p>
Порт для того, чтобы соединиться с ведомым устройством,
указан ведущему устройству во время ведомой регистрации.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowreport-user" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_report-user">report-user</a></code>
</p></td></tr>
<tr><td headers="rowreport-user replicationcli">Да</td>
<td headers="rowreport-user replicationsysvar">Да</td>
<td headers="rowreport-user replicationstatvar">Нет</td></tr>
<tr><td headers="rowreport-user replicationoptfile">Да</td>
<td headers="rowreport-user replicationscope">Глобальная</td>
<td headers="rowreport-user replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowreport-user replicationnotes"><p>
Произвольное имя пользователя, о котором ведомый сервер должен сообщить
ведущему устройству. Не то же самое, как имя, которое используется с учетной
записью пользователя репликации MySQL.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_clients" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_clients">
Rpl_semi_sync_master_clients</a></code></p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_clients replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_clients replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_clients replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_clients replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_clients replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_clients replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>Число полусинхронных ведомых устройств.</p></td>
</tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_semi_sync_master_enabled" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_master_enabled">
rpl_semi_sync_master_enabled</a></code></p></td></tr>
<tr><td headers="rowrpl_semi_sync_master_enabled replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_master_enabled replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_master_enabled replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_master_enabled replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_master_enabled replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_master_enabled replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_semi_sync_master_enabled replicationnotes"><p>
Включена ли полусинхронная репликация на ведущем устройстве.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_net_avg_wait_time" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_net_avg_wait_time">
Rpl_semi_sync_master_net_avg_wait_time</a></code></p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationstatvar">Да</td>
</tr>
<tr><td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_net_avg_wait_time replicationdynamic">Нет</td></tr>
<tr><td colspan="3"><p>
Среднее время, которое ведущее устройство ждало ответа ведомого.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_net_wait_time" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_net_wait_time">Rpl_semi_sync_master_net_wait_time</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_net_wait_time replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_net_wait_time replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_net_wait_time replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_net_wait_time replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_net_wait_time replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_net_wait_time replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_net_wait_time replicationnotes"><p>
Полное время, которое ведущее устройство ждало ответа ведомого.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_net_waits" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_net_waits">Rpl_semi_sync_master_net_waits</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_net_waits replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_net_waits replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_net_waits replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_net_waits replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_net_waits replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_net_waits replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_net_waits replicationnotes"><p>
Общее количество времени, которое ведущее устройство ждало ответа ведомых
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_no_times" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_no_times">Rpl_semi_sync_master_no_times</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_no_times replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_no_times replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_no_times replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_no_times replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_no_times replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_no_times replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_no_times replicationnotes"><p>
Число раз, которое ведущее устройство выключило полусинхронную репликацию.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_no_tx" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_no_tx">Rpl_semi_sync_master_no_tx</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_no_tx replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_no_tx replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_no_tx replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_no_tx replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_no_tx replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_no_tx replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_no_tx replicationnotes"><p>
Число передач, не признанных успешными.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_status" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_status">Rpl_semi_sync_master_status</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_status replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_status replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_status replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_status replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_status replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_status replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_status replicationnotes"><p>
Является ли полусинхронная репликация операционной на ведущем устройстве.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_timefunc_failures" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_timefunc_failures">Rpl_semi_sync_master_timefunc_failures</a></code>
</p></td></tr>
<tr><td>Нет</td>
<td>Нет</td>
<td>Да</td></tr>
<tr><td>Нет</td>
<td>Глобальная</td>
<td>Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_timefunc_failures replicationnotes"><p>
Число раз, которое ведущее устройство потерпело неудачу,
вызывая функции времени.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_semi_sync_master_timeout" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_master_timeout">rpl_semi_sync_master_timeout</a></code>
</p></td></tr>
<tr><td headers="rowrpl_semi_sync_master_timeout replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_master_timeout replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_master_timeout replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_master_timeout replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_master_timeout replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_master_timeout replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_semi_sync_master_timeout replicationnotes"><p>
Число миллисекунд, чтобы ждать ответа ведомого.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_semi_sync_master_trace_level" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_master_trace_level">rpl_semi_sync_master_trace_level</a></code>
</p></td></tr>
<tr><td headers="rowrpl_semi_sync_master_trace_level replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_master_trace_level replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_master_trace_level replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_master_trace_level replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_master_trace_level replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_master_trace_level replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_semi_sync_master_trace_level replicationnotes"><p>
Уровень трассировки полусинхронной репликации на ведущем устройстве.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_tx_avg_wait_time" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_tx_avg_wait_time">Rpl_semi_sync_master_tx_avg_wait_time</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_tx_avg_wait_time replicationnotes"><p>
Среднее время, которое ведущее устройство ждало каждой транзакции.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_tx_wait_time" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_tx_wait_time">Rpl_semi_sync_master_tx_wait_time</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_tx_wait_time replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_wait_time replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_wait_time replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_tx_wait_time replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_wait_time replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_tx_wait_time replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_tx_wait_time replicationnotes"><p>
Полное время, которое ведущее устройство ждало транзакций.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_tx_waits" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_tx_waits">Rpl_semi_sync_master_tx_waits</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_tx_waits replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_waits replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_waits replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_tx_waits replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_tx_waits replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_tx_waits replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_tx_waits replicationnotes"><p>
Общее количество времени, которое ведущее устройство ждало транзакций.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_semi_sync_master_wait_for_slave_count" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_master_wait_for_slave_count">rpl_semi_sync_master_wait_for_slave_count</a></code>
</p></td></tr>
<tr><td headers="rowrpl_semi_sync_master_wait_for_slave_count replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_master_wait_for_slave_count replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_master_wait_for_slave_count replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_master_wait_for_slave_count replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_master_wait_for_slave_count replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_master_wait_for_slave_count replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_semi_sync_master_wait_for_slave_count replicationnotes"><p>
Сколько ответов от ведомого ведущее устройство должно получить за
транзакцию перед обработкой.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_semi_sync_master_wait_no_slave" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_master_wait_no_slave">rpl_semi_sync_master_wait_no_slave</a></code>
</p></td></tr>
<tr><td headers="rowrpl_semi_sync_master_wait_no_slave replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_master_wait_no_slave replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_master_wait_no_slave replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_master_wait_no_slave replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_master_wait_no_slave replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_master_wait_no_slave replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_semi_sync_master_wait_no_slave replicationnotes"><p>
Ждет ли ведущее устройство тайм-аута даже без ведомых устройств.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_master_wait_point">
rpl_semi_sync_master_wait_point</a></code></p></td></tr>
<tr><td headers="rowrpl_semi_sync_master_wait_point replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_master_wait_point replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_master_wait_point replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_master_wait_point replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_master_wait_point replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_master_wait_point replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_semi_sync_master_wait_point replicationnotes"><p>
Точка лжидания подтверждения получения ведомой транзакции.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_wait_pos_backtraverse" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_wait_pos_backtraverse">Rpl_semi_sync_master_wait_pos_backtraverse</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_wait_pos_backtraverse replicationnotes"><p>
Сколько раз ведущее устройство ждало события
с двоичными координатами ниже, чем события раньше.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_wait_sessions" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_wait_sessions">Rpl_semi_sync_master_wait_sessions</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_wait_sessions replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_wait_sessions replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_wait_sessions replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_wait_sessions replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_wait_sessions replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_wait_sessions replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_wait_sessions replicationnotes"><p>
Число сеансов, в настоящее время ожидающих ответов ведомых.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_master_yes_tx" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_master_yes_tx">Rpl_semi_sync_master_yes_tx</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_master_yes_tx replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_master_yes_tx replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_master_yes_tx replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_master_yes_tx replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_master_yes_tx replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_master_yes_tx replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_master_yes_tx replicationnotes"><p>
Число передач, признанных успешными.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_semi_sync_slave_enabled" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_slave_enabled">rpl_semi_sync_slave_enabled</a></code>
</p></td></tr>
<tr><td headers="rowrpl_semi_sync_slave_enabled replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_slave_enabled replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_slave_enabled replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_slave_enabled replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_slave_enabled replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_slave_enabled replicationdynamic">Да</td></tr>
<tr><td colspan="3"><p>
Включена ли полусинхронная репликация на ведомом устройстве.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowRpl_semi_sync_slave_status" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Rpl_semi_sync_slave_status">Rpl_semi_sync_slave_status</a></code>
</p></td></tr>
<tr><td headers="rowRpl_semi_sync_slave_status replicationcli">Нет</td>
<td headers="rowRpl_semi_sync_slave_status replicationsysvar">Нет</td>
<td headers="rowRpl_semi_sync_slave_status replicationstatvar">Да</td></tr>
<tr><td headers="rowRpl_semi_sync_slave_status replicationoptfile">Нет</td>
<td headers="rowRpl_semi_sync_slave_status replicationscope">Глобальная</td>
<td headers="rowRpl_semi_sync_slave_status replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowRpl_semi_sync_slave_status replicationnotes"><p>
Является ли полусинхронная репликация операционной на ведомом устройстве.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_semi_sync_slave_trace_level" headers="replicationoptvar"><p>
<code><a href="server.htm#sysvar_rpl_semi_sync_slave_trace_level">rpl_semi_sync_slave_trace_level</a></code>
</p></td></tr>
<tr><td headers="rowrpl_semi_sync_slave_trace_level replicationcli">Нет</td>
<td headers="rowrpl_semi_sync_slave_trace_level replicationsysvar">Да</td>
<td headers="rowrpl_semi_sync_slave_trace_level replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_semi_sync_slave_trace_level replicationoptfile">Нет</td>
<td headers="rowrpl_semi_sync_slave_trace_level replicationscope">Глобальная</td>
<td headers="rowrpl_semi_sync_slave_trace_level replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_semi_sync_slave_trace_level replicationnotes"><p>
Уровень трассировки полусинхронной репликации на ведомом устройстве.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowrpl_stop_slave_timeout" headers="replicationoptvar"><p>
<code><a href="#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout</a></code>
</p></td></tr>
<tr><td headers="rowrpl_stop_slave_timeout replicationcli">Да</td>
<td headers="rowrpl_stop_slave_timeout replicationsysvar">Да</td>
<td headers="rowrpl_stop_slave_timeout replicationstatvar">Нет</td></tr>
<tr><td headers="rowrpl_stop_slave_timeout replicationoptfile">Да</td>
<td headers="rowrpl_stop_slave_timeout replicationscope">Глобальная</td>
<td headers="rowrpl_stop_slave_timeout replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowrpl_stop_slave_timeout replicationnotes"><p>
Определить число секунд, которые STOP SLAVE ждет перед синхронизацией.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowserver_uuid" headers="replicationoptvar"><p>
<code><a href="#sysvar_server_uuid">server_uuid</a></code>
</p></td></tr>
<tr><td headers="rowserver_uuid replicationcli">Нет</td>
<td headers="rowserver_uuid replicationsysvar">Да</td>
<td headers="rowserver_uuid replicationstatvar">Нет</td></tr>
<tr><td headers="rowserver_uuid replicationoptfile">Нет</td>
<td headers="rowserver_uuid replicationscope">Глобальная</td>
<td headers="rowserver_uuid replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowserver_uuid replicationnotes"><p>
Глобальный уникальный ID сервера, автоматически
произведенный при запуске сервера.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowshow-slave-auth-info" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_show-slave-auth-info">show-slave-auth-info</a></code>
</p></td></tr>
<tr><td headers="rowshow-slave-auth-info replicationcli">Да</td>
<td headers="rowshow-slave-auth-info replicationsysvar">Нет</td>
<td headers="rowshow-slave-auth-info replicationstatvar">Нет</td></tr>
<tr><td headers="rowshow-slave-auth-info replicationoptfile">Да</td>
<td headers="rowshow-slave-auth-info replicationscope"></td>
<td headers="rowshow-slave-auth-info replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowshow-slave-auth-info replicationnotes"><p>
Показать имя пользователя и пароль в SHOW SLAVE HOSTS
на этом ведущем устройстве.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowsimplified_binlog_gtid_recovery" headers="replicationoptvar"><p>
<code><a href="#sysvar_simplified_binlog_gtid_recovery">simplified_binlog_gtid_recovery</a></code>
</p></td></tr>
<tr><td headers="rowsimplified_binlog_gtid_recovery replicationcli">Да</td>
<td headers="rowsimplified_binlog_gtid_recovery replicationsysvar">Да</td>
<td headers="rowsimplified_binlog_gtid_recovery replicationstatvar">Нет</td></tr>
<tr><td headers="rowsimplified_binlog_gtid_recovery replicationoptfile">Да</td>
<td headers="rowsimplified_binlog_gtid_recovery replicationscope">Глобальная</td>
<td headers="rowsimplified_binlog_gtid_recovery replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowsimplified_binlog_gtid_recovery replicationnotes"><p>
Средство управления, как двоичные журналы повторены во
время восстановления GTID.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowskip-slave-start" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_skip-slave-start">skip-slave-start</a></code>
</p></td></tr>
<tr><td headers="rowskip-slave-start replicationcli">Да</td>
<td headers="rowskip-slave-start replicationsysvar">Нет</td>
<td headers="rowskip-slave-start replicationstatvar">Нет</td></tr>
<tr><td headers="rowskip-slave-start replicationoptfile">Да</td>
<td headers="rowskip-slave-start replicationscope"></td>
<td headers="rowskip-slave-start replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowskip-slave-start replicationnotes"><p>
Если установлено, ведомое устройство не запущено автоматически.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-checkpoint-group" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-checkpoint-group">slave-checkpoint-group</a></code>
</p></td></tr>
<tr><td headers="rowslave-checkpoint-group replicationcli">Да</td>
<td headers="rowslave-checkpoint-group replicationsysvar">Нет</td>
<td headers="rowslave-checkpoint-group replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-checkpoint-group replicationoptfile">Да</td>
<td headers="rowslave-checkpoint-group replicationscope"></td>
<td headers="rowslave-checkpoint-group replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-checkpoint-group replicationnotes"><p>
Максимальное количество транзакций, обработанных мультипоточным ведомым
устройством перед работой контрольной точки, чтобы обновить состояние.
Не поддержан MySQL Cluster.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-checkpoint-period" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-checkpoint-period">slave-checkpoint-period</a></code>
</p></td></tr>
<tr><td headers="rowslave-checkpoint-period replicationcli">Да</td>
<td headers="rowslave-checkpoint-period replicationsysvar">Нет</td>
<td headers="rowslave-checkpoint-period replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-checkpoint-period replicationoptfile">Да</td>
<td headers="rowslave-checkpoint-period replicationscope"></td>
<td headers="rowslave-checkpoint-period replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-checkpoint-period replicationnotes"><p>
Обновить состояние продвижения мультипоточного ведомого устройства и сбросить
на диск журнал реле после этого числа миллисекунд.
Не поддержан MySQL Cluster.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-load-tmpdir" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-load-tmpdir">slave-load-tmpdir</a></code>
</p></td></tr>
<tr><td headers="rowslave-load-tmpdir replicationcli">Да</td>
<td headers="rowslave-load-tmpdir replicationsysvar">Да</td>
<td headers="rowslave-load-tmpdir replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-load-tmpdir replicationoptfile">Да</td>
<td headers="rowslave-load-tmpdir replicationscope">Глобальная</td>
<td headers="rowslave-load-tmpdir replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-load-tmpdir replicationnotes"><p>
Куда ведомое устройство должно поместить свои временные файлы, копируя
LOAD DATA INFILE.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-max-allowed-packet" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-max-allowed-packet">slave-max-allowed-packet</a></code>
</p></td></tr>
<tr><td headers="rowslave-max-allowed-packet replicationcli">Да</td>
<td headers="rowslave-max-allowed-packet replicationsysvar">Нет</td>
<td headers="rowslave-max-allowed-packet replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-max-allowed-packet replicationoptfile">Да</td>
<td headers="rowslave-max-allowed-packet replicationscope"></td>
<td headers="rowslave-max-allowed-packet replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-max-allowed-packet replicationnotes"><p>
Максимальный размер в байтах пакета, который можно послать от ведущего
устройства репликации в ведомое устройство, переопределяет
max_allowed_packet.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_net_timeout" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-net-timeout">slave_net_timeout</a></code>
</p></td></tr>
<tr><td headers="rowslave_net_timeout replicationcli">Да</td>
<td headers="rowslave_net_timeout replicationsysvar">Да</td>
<td headers="rowslave_net_timeout replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_net_timeout replicationoptfile">Да</td>
<td headers="rowslave_net_timeout replicationscope">Глобальная</td>
<td headers="rowslave_net_timeout replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_net_timeout replicationnotes"><p>
Число секунд, которое надо ждать большего количества данных от
основного/ведомого соединения прежде, чем прервать чтение.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-parallel-type" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-parallel-type">slave-parallel-type</a></code>
</p></td></tr>
<tr><td headers="rowslave-parallel-type replicationcli">Да</td>
<td headers="rowslave-parallel-type replicationsysvar">Нет</td>
<td headers="rowslave-parallel-type replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-parallel-type replicationoptfile">Да</td>
<td headers="rowslave-parallel-type replicationscope"></td>
<td headers="rowslave-parallel-type replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-parallel-type replicationnotes"><p>
Говорит ведомому устройству использовать базу данных (DATABASE)
или информацию timestamp (LOGICAL_CLOCK) от ведущего устройства,
чтобы обеспечить параллельность транзакциям. Значение по умолчанию DATABASE.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-parallel-workers" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-parallel-workers">slave-parallel-workers</a></code>
</p></td></tr>
<tr><td headers="rowslave-parallel-workers replicationcli">Да</td>
<td headers="rowslave-parallel-workers replicationsysvar">Нет</td>
<td headers="rowslave-parallel-workers replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-parallel-workers replicationoptfile">Да</td>
<td headers="rowslave-parallel-workers replicationscope"></td>
<td headers="rowslave-parallel-workers replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-parallel-workers replicationnotes"><p>
Число рабочих потоков для того, чтобы запустить события параллельно.
0 (по умолчанию) отключает ведомую мультипоточную обработку.
Не поддержан MySQL Cluster.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-pending-jobs-size-max" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-pending-jobs-size-max">slave-pending-jobs-size-max</a></code>
</p></td></tr>
<tr><td headers="rowslave-pending-jobs-size-max replicationcli">Да</td>
<td headers="rowslave-pending-jobs-size-max replicationsysvar">Нет</td>
<td headers="rowslave-pending-jobs-size-max replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-pending-jobs-size-max replicationoptfile">Нет</td>
<td headers="rowslave-pending-jobs-size-max replicationscope"></td>
<td headers="rowslave-pending-jobs-size-max replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-pending-jobs-size-max replicationnotes"><p>
Максимальный размер очередей ведомого, хранящих еще не примененные события.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-rows-search-algorithms" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-rows-search-algorithms">slave-rows-search-algorithms</a></code>
</p></td></tr>
<tr><td headers="rowslave-rows-search-algorithms replicationcli">Да</td>
<td headers="rowslave-rows-search-algorithms replicationsysvar">Нет</td>
<td headers="rowslave-rows-search-algorithms replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-rows-search-algorithms replicationoptfile">Да</td>
<td headers="rowslave-rows-search-algorithms replicationscope"></td>
<td headers="rowslave-rows-search-algorithms replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-rows-search-algorithms replicationnotes"><p>
Определяет алгоритмы поиска, используемые для ведомого группирования
обновления. Любые 2 или 3 из списка INDEX_SEARCH, TABLE_SCAN, HASH_SCAN, по
умолчанию TABLE_SCAN, INDEX_SCAN.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave-skip-errors" headers="replicationoptvar"><p>
<code><a href="#option_mysqld_slave-skip-errors">slave-skip-errors</a></code>
</p></td></tr>
<tr><td headers="rowslave-skip-errors replicationcli">Да</td>
<td headers="rowslave-skip-errors replicationsysvar">Да</td>
<td headers="rowslave-skip-errors replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave-skip-errors replicationoptfile">Да</td>
<td headers="rowslave-skip-errors replicationscope">Глобальная</td>
<td headers="rowslave-skip-errors replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-skip-errors replicationnotes"><p>
Говорит ведомому потоку продолжать репликацию, когда запрос возвращает ошибку
из обеспеченного списка.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_checkpoint_group" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_checkpoint_group">slave_checkpoint_group</a></code>
</p></td></tr>
<tr><td headers="rowslave_checkpoint_group replicationcli">Да</td>
<td headers="rowslave_checkpoint_group replicationsysvar">Да</td>
<td headers="rowslave_checkpoint_group replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_checkpoint_group replicationoptfile">Да</td>
<td headers="rowslave_checkpoint_group replicationscope">Глобальная</td>
<td headers="rowslave_checkpoint_group replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_checkpoint_group replicationnotes"><p>
Максимальное количество транзакций, обработанных мультипоточным ведомым
устройством перед работой контрольной точки, чтобы обновить состояние.
Не поддержан MySQL Cluster.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_checkpoint_period" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_checkpoint_period">slave_checkpoint_period</a></code>
</p></td></tr>
<tr><td headers="rowslave_checkpoint_period replicationcli">Да</td>
<td headers="rowslave_checkpoint_period replicationsysvar">Да</td>
<td headers="rowslave_checkpoint_period replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_checkpoint_period replicationoptfile">Да</td>
<td headers="rowslave_checkpoint_period replicationscope">Глобальная</td>
<td headers="rowslave_checkpoint_period replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_checkpoint_period replicationnotes"><p>
Обновить состояние продвижения мультипоточного ведомого устройства и сбросить
на диск журнал реле после этого числа миллисекунд.
Не поддержан MySQL Cluster.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_compressed_protocol" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_compressed_protocol">slave_compressed_protocol</a></code>
</p></td></tr>
<tr><td headers="rowslave_compressed_protocol replicationcli">Да</td>
<td headers="rowslave_compressed_protocol replicationsysvar">Да</td>
<td headers="rowslave_compressed_protocol replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_compressed_protocol replicationoptfile">Да</td>
<td headers="rowslave_compressed_protocol replicationscope">Глобальная</td>
<td headers="rowslave_compressed_protocol replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_compressed_protocol replicationnotes"><p>
Использовать сжатие на основном/ведомом протоколе.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_exec_mode" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_exec_mode">slave_exec_mode</a></code>
</p></td></tr>
<tr><td headers="rowslave_exec_mode replicationcli">Да</td>
<td headers="rowslave_exec_mode replicationsysvar">Да</td>
<td headers="rowslave_exec_mode replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_exec_mode replicationoptfile">Да</td>
<td headers="rowslave_exec_mode replicationscope">Глобальная</td>
<td headers="rowslave_exec_mode replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_exec_mode replicationnotes"><p>
Учитывает переключение ведомого потока между режимом IDEMPOTENT
(ключ и некоторыми другими ошибки подавлены) и режимом STRICT (по умолчанию,
за исключением MySQL Cluster, где IDEMPOTENT всегда используется).
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowSlave_heartbeat_period" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Slave_heartbeat_period">Slave_heartbeat_period</a></code>
</p></td></tr>
<tr><td headers="rowSlave_heartbeat_period replicationcli">Нет</td>
<td headers="rowSlave_heartbeat_period replicationsysvar">Нет</td>
<td headers="rowSlave_heartbeat_period replicationstatvar">Да</td></tr>
<tr><td headers="rowSlave_heartbeat_period replicationoptfile">Нет</td>
<td headers="rowSlave_heartbeat_period replicationscope">Глобальная</td>
<td headers="rowSlave_heartbeat_period replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowSlave_heartbeat_period replicationnotes"><p>
Интервал биения репликации ведомого устройства в секундах.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_max_allowed_packet" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_max_allowed_packet">slave_max_allowed_packet</a></code>
</p></td></tr>
<tr><td headers="rowslave_max_allowed_packet replicationcli">Нет</td>
<td headers="rowslave_max_allowed_packet replicationsysvar">Да</td>
<td headers="rowslave_max_allowed_packet replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_max_allowed_packet replicationoptfile">Нет</td>
<td headers="rowslave_max_allowed_packet replicationscope">Глобальная</td>
<td headers="rowslave_max_allowed_packet replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_max_allowed_packet replicationnotes"><p>
Максимальный размер в байтах пакета, который можно послать от ведущего
устройства репликации в ведомое устройство, переопределение
max_allowed_packet.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowSlave_open_temp_tables" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Slave_open_temp_tables">Slave_open_temp_tables</a></code>
</p></td></tr>
<tr><td headers="rowSlave_open_temp_tables replicationcli">Нет</td>
<td headers="rowSlave_open_temp_tables replicationsysvar">Нет</td>
<td headers="rowSlave_open_temp_tables replicationstatvar">Да</td></tr>
<tr><td headers="rowSlave_open_temp_tables replicationoptfile">Нет</td>
<td headers="rowSlave_open_temp_tables replicationscope">Глобальная</td>
<td headers="rowSlave_open_temp_tables replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowSlave_open_temp_tables replicationnotes"><p>
Число временных таблиц, которые ведомый поток SQL в настоящее время открыл.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_parallel_type" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_parallel_type">slave_parallel_type</a></code>
</p></td></tr>
<tr><td headers="rowslave_parallel_type replicationcli">Нет</td>
<td headers="rowslave_parallel_type replicationsysvar">Да</td>
<td headers="rowslave_parallel_type replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_parallel_type replicationoptfile">Нет</td>
<td headers="rowslave_parallel_type replicationscope">Глобальная</td>
<td headers="rowslave_parallel_type replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_parallel_type replicationnotes"><p>
Говорит ведомому устройству использовать базу данных (DATABASE)
или информацию timestamp (LOGICAL_CLOCK) от ведущего устройства,
чтобы обеспечить параллельность транзакциям. Значение по умолчанию DATABASE.
</p></td></tr></tbody><tbody><tr>
<td colspan="3" align="center" id="rowslave_parallel_workers" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_parallel_workers">slave_parallel_workers</a></code>
</p></td></tr>
<tr><td headers="rowslave_parallel_workers replicationcli">Да</td>
<td headers="rowslave_parallel_workers replicationsysvar">Да</td>
<td headers="rowslave_parallel_workers replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_parallel_workers replicationoptfile">Нет</td>
<td headers="rowslave_parallel_workers replicationscope">Глобальная</td>
<td headers="rowslave_parallel_workers replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_parallel_workers replicationnotes"><p>
Число рабочих потоков для того, чтобы запустить события параллельно.
Установка в 0 (значение по умолчанию) отключает ведомую мультипоточную
обработку. Не поддержан MySQL Cluster.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_pending_jobs_size_max" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_pending_jobs_size_max">slave_pending_jobs_size_max</a></code>
</p></td></tr>
<tr><td headers="rowslave_pending_jobs_size_max replicationcli">Нет</td>
<td headers="rowslave_pending_jobs_size_max replicationsysvar">Да</td>
<td headers="rowslave_pending_jobs_size_max replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_pending_jobs_size_max replicationoptfile">Нет</td>
<td headers="rowslave_pending_jobs_size_max replicationscope">Глобальная</td>
<td headers="rowslave_pending_jobs_size_max replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_pending_jobs_size_max replicationnotes"><p>
Максимальный размер очередей ведомого для хранения еще
не примененных событий.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_preserve_commit_order" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_preserve_commit_order">slave_preserve_commit_order</a></code>
</p></td></tr>
<tr><td headers="rowslave_preserve_commit_order replicationcli">Да</td>
<td headers="rowslave_preserve_commit_order replicationsysvar">Да</td>
<td headers="rowslave_preserve_commit_order replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_preserve_commit_order replicationoptfile">Нет</td>
<td headers="rowslave_preserve_commit_order replicationscope">Глобальная</td>
<td headers="rowslave_preserve_commit_order replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_preserve_commit_order replicationnotes"><p>
Гарантирует, что все передачи ведомых выполнены в том же самом порядке, как
на ведущем устройстве, что поддерживает последовательность,
используя параллельные потоки.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowSlave_retried_transactions" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Slave_retried_transactions">Slave_retried_transactions</a></code>
</p></td></tr>
<tr><td headers="rowSlave_retried_transactions replicationcli">Нет</td>
<td headers="rowSlave_retried_transactions replicationsysvar">Нет</td>
<td headers="rowSlave_retried_transactions replicationstatvar">Да</td></tr>
<tr><td headers="rowSlave_retried_transactions replicationoptfile">Нет</td>
<td headers="rowSlave_retried_transactions replicationscope">Глобальная</td>
<td headers="rowSlave_retried_transactions replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowSlave_retried_transactions replicationnotes"><p>
Сколько раз начиная с запуска поток SQL ведомого
устройства повторил транзакции.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_rows_search_algorithms" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_rows_search_algorithms">slave_rows_search_algorithms</a></code>
</p></td></tr>
<tr><td headers="rowslave_rows_search_algorithms replicationcli">Нет</td>
<td headers="rowslave_rows_search_algorithms replicationsysvar">Да</td>
<td headers="rowslave_rows_search_algorithms replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_rows_search_algorithms replicationoptfile">Нет</td>
<td headers="rowslave_rows_search_algorithms replicationscope">Глобальная</td>
<td headers="rowslave_rows_search_algorithms replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_rows_search_algorithms replicationnotes"><p>
Определяет алгоритмы поиска, используемые для ведомого
группирования обновления. Любые 2 или 3 из списка INDEX_SEARCH,
TABLE_SCAN, HASH_SCAN, по умолчанию TABLE_SCAN, INDEX_SCAN.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowSlave_running" headers="replicationoptvar"><p>
<code><a href="server.htm#statvar_Slave_running">Slave_running</a></code>
</p></td></tr>
<tr><td headers="rowSlave_running replicationcli">Нет</td>
<td headers="rowSlave_running replicationsysvar">Нет</td>
<td headers="rowSlave_running replicationstatvar">Да</td></tr>
<tr><td headers="rowSlave_running replicationoptfile">Нет</td>
<td headers="rowSlave_running replicationscope">Глобальная</td>
<td headers="rowSlave_running replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowSlave_running replicationnotes"><p>
Статус этого сервера как ведомого устройства репликации (ведомое состояние
потока ввода/вывода).</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_transaction_retries" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_transaction_retries">slave_transaction_retries</a></code>
</p></td></tr>
<tr><td headers="rowslave_transaction_retries replicationcli">Да</td>
<td headers="rowslave_transaction_retries replicationsysvar">Да</td>
<td headers="rowslave_transaction_retries replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_transaction_retries replicationoptfile">Да</td>
<td headers="rowslave_transaction_retries replicationscope">Глобальная</td>
<td headers="rowslave_transaction_retries replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_transaction_retries replicationnotes"><p>
Сколько раз ведомый поток SQL повторит транзакцию в случае, если это
потерпело неудачу с тупиком или тайм-аутом блокировки перед отказом.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowslave_type_conversions" headers="replicationoptvar"><p>
<code><a href="#sysvar_slave_type_conversions">slave_type_conversions</a></code>
</p></td></tr>
<tr><td headers="rowslave_type_conversions replicationcli">Да</td>
<td headers="rowslave_type_conversions replicationsysvar">Да</td>
<td headers="rowslave_type_conversions replicationstatvar">Нет</td></tr>
<tr><td headers="rowslave_type_conversions replicationoptfile">Да</td>
<td headers="rowslave_type_conversions replicationscope">Глобальная</td>
<td headers="rowslave_type_conversions replicationdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave_type_conversions replicationnotes"><p>
Средство управления конверсионным режимом на ведомом устройстве репликации.
Значение список из ноля или большего количества элементов из списка:
ALL_LOSSY, ALL_NON_LOSSY. Установите к пустой строке, чтобы отвергнуть
преобразования типа между ведущим устройством и ведомым устройством.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowsql_slave_skip_counter" headers="replicationoptvar"><p>
<code><a href="#sysvar_sql_slave_skip_counter">sql_slave_skip_counter</a></code>
</p></td></tr>
<tr><td headers="rowsql_slave_skip_counter replicationcli">Нет</td>
<td headers="rowsql_slave_skip_counter replicationsysvar">Да</td>
<td headers="rowsql_slave_skip_counter replicationstatvar">Нет</td></tr>
<tr><td headers="rowsql_slave_skip_counter replicationoptfile">Нет</td>
<td headers="rowsql_slave_skip_counter replicationscope">Глобальная</td>
<td headers="rowsql_slave_skip_counter replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowsql_slave_skip_counter replicationnotes"><p>
Число событий от ведущего устройства, которое должен пропустить ведомый
сервер. Несовместимо с репликацией GTID.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowsync_binlog" headers="replicationoptvar"><p>
<code><a href="#sysvar_sync_binlog">sync_binlog</a></code>
</p></td></tr>
<tr><td headers="rowsync_binlog replicationcli">Да</td>
<td headers="rowsync_binlog replicationsysvar">Да</td>
<td headers="rowsync_binlog replicationstatvar">Нет</td></tr>
<tr><td headers="rowsync_binlog replicationoptfile">Да</td>
<td headers="rowsync_binlog replicationscope">Глобальная</td>
<td headers="rowsync_binlog replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowsync_binlog replicationnotes"><p>
Синхронно сбросить двоичной журнал к диску после каждого #-го события.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowsync_master_info" headers="replicationoptvar"><p>
<code><a href="#sysvar_sync_master_info">sync_master_info</a></code>
</p></td></tr>
<tr><td headers="rowsync_master_info replicationcli">Да</td>
<td headers="rowsync_master_info replicationsysvar">Да</td>
<td headers="rowsync_master_info replicationstatvar">Нет</td></tr>
<tr><td headers="rowsync_master_info replicationoptfile">Да</td>
<td headers="rowsync_master_info replicationscope">Глобальная</td>
<td headers="rowsync_master_info replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowsync_master_info replicationnotes"><p>
Синхронизировать master.info с диском после каждого #-го события.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowsync_relay_log" headers="replicationoptvar"><p>
<code><a href="#sysvar_sync_relay_log">sync_relay_log</a></code>
</p></td></tr>
<tr><td headers="rowsync_relay_log replicationcli">Да</td>
<td headers="rowsync_relay_log replicationsysvar">Да</td>
<td headers="rowsync_relay_log replicationstatvar">Нет</td></tr>
<tr><td headers="rowsync_relay_log replicationoptfile">Да</td>
<td headers="rowsync_relay_log replicationscope">Глобальная</td>
<td headers="rowsync_relay_log replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowsync_relay_log replicationnotes"><p>
Синхронизировать журнал реле с диском после каждого #-го события.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowsync_relay_log_info" headers="replicationoptvar"><p>
<code><a href="#sysvar_sync_relay_log_info">sync_relay_log_info</a></code>
</p></td></tr>
<tr><td headers="rowsync_relay_log_info replicationcli">Да</td>
<td headers="rowsync_relay_log_info replicationsysvar">Да</td>
<td headers="rowsync_relay_log_info replicationstatvar">Нет</td></tr>
<tr><td headers="rowsync_relay_log_info replicationoptfile">Да</td>
<td headers="rowsync_relay_log_info replicationscope">Глобальная</td>
<td headers="rowsync_relay_log_info replicationdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowsync_relay_log_info replicationnotes"><p>
Синхронизировать файл relay.info с диском после каждого #-го события.
</p></td></tr></tbody></table>

<p><a href="#replication-options-master">Раздел 19.1.6.2</a>
обеспечивает более подробную информацию об опциях и переменных, касающихся
главных серверов репликации. Для получения дополнительной информации об
опциях и переменных, касающихся ведомых устройств репликации, см.
<a href="#replication-options-slave">раздел 19.1.6.3</a>.</p>

<a name="binlog-optvar-summary-table"></a><p><b>Таблица 19.4.
Опции и переменные двоичного журналирования в MySQL 8.0</b></p>
<table>
<thead><tr><th colspan="3">Имя</th></tr>
<tr><th id="binlogcli" abbr="CLI">Командная строка</th>
<th id="binlogsysvar" abbr="System">Системная?</th>
<th id="binlogstatvar" abbr="Status">Статусная?</th></tr>
<tr><th id="binlogoptfile" abbr="File">Файл опций</th>
<th id="binlogscope">Контекст</th>
<th id="binlogdynamic">Динамическая?</th></tr>
<tr><th id="binlognotes" colspan="3">Примечания</th></tr></thead>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog-checksum" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_binlog-checksum">binlog-checksum</a></code>
</p></td></tr>
<tr><td headers="rowbinlog-checksum binlogcli">Да</td>
<td headers="rowbinlog-checksum binlogsysvar">Нет</td>
<td headers="rowbinlog-checksum binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog-checksum binlogoptfile">Да</td>
<td headers="rowbinlog-checksum binlogscope"></td>
<td headers="rowbinlog-checksum binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowbinlog-checksum binlognotes"><p>
Включить/отключить контрольные суммы двоичного журнала.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog-do-db" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_binlog-do-db">binlog-do-db</a></code>
</p></td></tr>
<tr><td headers="rowbinlog-do-db binlogcli">Да</td>
<td headers="rowbinlog-do-db binlogsysvar">Нет</td>
<td headers="rowbinlog-do-db binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog-do-db binlogoptfile">Да</td>
<td headers="rowbinlog-do-db binlogscope"></td>
<td headers="rowbinlog-do-db binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowbinlog-do-db binlognotes"><p>
Ограничить двоичное журналирование к определенным базам данных.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_format" headers="binlogoptvar"><p>
<code><a href="server.htm#option_mysqld_binlog-format">binlog_format</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_format binlogcli">Да</td>
<td headers="rowbinlog_format binlogsysvar">Да</td>
<td headers="rowbinlog_format binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_format binlogoptfile">Да</td>
<td headers="rowbinlog_format binlogscope">Both</td>
<td headers="rowbinlog_format binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_format binlognotes"><p>
Определяет формат двоичного журнала.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog-ignore-db" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_binlog-ignore-db">binlog-ignore-db</a></code>
</p></td></tr>
<tr><td headers="rowbinlog-ignore-db binlogcli">Да</td>
<td headers="rowbinlog-ignore-db binlogsysvar">Нет</td>
<td headers="rowbinlog-ignore-db binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog-ignore-db binlogoptfile">Да</td>
<td headers="rowbinlog-ignore-db binlogscope"></td>
<td headers="rowbinlog-ignore-db binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowbinlog-ignore-db binlognotes"><p>
Говорит ведущему устройству, которое обновляет эту базу данных, не
регистрировать в двоичном журнале.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog-row-event-max-size" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_binlog-row-event-max-size">binlog-row-event-max-size</a></code>
</p></td></tr>
<tr><td headers="rowbinlog-row-event-max-size binlogcli">Да</td>
<td headers="rowbinlog-row-event-max-size binlogsysvar">Нет</td>
<td headers="rowbinlog-row-event-max-size binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog-row-event-max-size binlogoptfile">Да</td>
<td headers="rowbinlog-row-event-max-size binlogscope"></td>
<td headers="rowbinlog-row-event-max-size binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowbinlog-row-event-max-size binlognotes"><p>
Максимальный размер события в двоичном журнале.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog-rows-query-log-events" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_binlog-rows-query-log-events">binlog-rows-query-log-events</a></code>
</p></td></tr>
<tr><td headers="rowbinlog-rows-query-log-events binlogcli">Да</td>
<td headers="rowbinlog-rows-query-log-events binlogsysvar">Нет</td>
<td headers="rowbinlog-rows-query-log-events binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog-rows-query-log-events binlogoptfile">Да</td>
<td headers="rowbinlog-rows-query-log-events binlogscope"></td>
<td headers="rowbinlog-rows-query-log-events binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowbinlog-rows-query-log-events binlognotes"><p>
Позволяет регистрировать события запроса строк, используя основанное на
строке журналирование. Отключен по умолчанию. Не включайте, производя журналы
для ведомых устройств pre-5.6.2.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowBinlog_cache_disk_use" headers="binlogoptvar"><p>
<code><a href="server.htm#statvar_Binlog_cache_disk_use">Binlog_cache_disk_use</a></code>
</p></td></tr>
<tr><td headers="rowBinlog_cache_disk_use binlogcli">Нет</td>
<td headers="rowBinlog_cache_disk_use binlogsysvar">Нет</td>
<td headers="rowBinlog_cache_disk_use binlogstatvar">Да</td></tr>
<tr><td headers="rowBinlog_cache_disk_use binlogoptfile">Нет</td>
<td headers="rowBinlog_cache_disk_use binlogscope">Глобальная</td>
<td headers="rowBinlog_cache_disk_use binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowBinlog_cache_disk_use binlognotes"><p>
Число транзакций, которые использовали временный файл вместо
двоичного кэша журнала.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_cache_size" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_cache_size">binlog_cache_size</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_cache_size binlogcli">Да</td>
<td headers="rowbinlog_cache_size binlogsysvar">Да</td>
<td headers="rowbinlog_cache_size binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_cache_size binlogoptfile">Да</td>
<td headers="rowbinlog_cache_size binlogscope">Глобальная</td>
<td headers="rowbinlog_cache_size binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_cache_size binlognotes"><p>
Размер кэша, чтобы хранить запросы SQL для двоичного журнала
во время транзакции.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowBinlog_cache_use" headers="binlogoptvar"><p>
<code><a href="server.htm#statvar_Binlog_cache_use">Binlog_cache_use</a></code>
</p></td></tr>
<tr><td headers="rowBinlog_cache_use binlogcli">Нет</td>
<td headers="rowBinlog_cache_use binlogsysvar">Нет</td>
<td headers="rowBinlog_cache_use binlogstatvar">Да</td></tr>
<tr><td headers="rowBinlog_cache_use binlogoptfile">Нет</td>
<td headers="rowBinlog_cache_use binlogscope">Глобальная</td>
<td headers="rowBinlog_cache_use binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowBinlog_cache_use binlognotes"><p>
Число транзакций, которые использовали временный кэш журнала.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_checksum" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_checksum">binlog_checksum</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_checksum binlogcli">Нет</td>
<td headers="rowbinlog_checksum binlogsysvar">Да</td>
<td headers="rowbinlog_checksum binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_checksum binlogoptfile">Нет</td>
<td headers="rowbinlog_checksum binlogscope">Глобальная</td>
<td headers="rowbinlog_checksum binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_checksum binlognotes"><p>
Включить/отключить контрольные суммы двоичного журнала.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_direct_non_transactional_updates" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_direct_non_transactional_updates">binlog_direct_non_transactional_updates</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_direct_non_transactional_updates binlogcli">Да</td>
<td headers="rowbinlog_direct_non_transactional_updates binlogsysvar">Да</td>
<td headers="rowbinlog_direct_non_transactional_updates binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_direct_non_transactional_updates binlogoptfile">Да</td>
<td headers="rowbinlog_direct_non_transactional_updates binlogscope">Both</td>
<td headers="rowbinlog_direct_non_transactional_updates binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_direct_non_transactional_updates binlognotes"><p>
Обновления, использующие формат запроса к нетранзакционным механизмам,
будут написаны непосредственно двоичному журналу.
См. документацию перед использованием.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_error_action" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_error_action">binlog_error_action</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_error_action binlogcli">Да</td>
<td headers="rowbinlog_error_action binlogsysvar">Да</td>
<td headers="rowbinlog_error_action binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_error_action binlogoptfile">Да</td>
<td headers="rowbinlog_error_action binlogscope">Both</td>
<td headers="rowbinlog_error_action binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_error_action binlognotes"><p>
Средство управления, что происходит, когда сервер не может
написать в двоичный журнал.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_group_commit_sync_delay" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_group_commit_sync_delay">binlog_group_commit_sync_delay</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_group_commit_sync_delay binlogcli">Да</td>
<td headers="rowbinlog_group_commit_sync_delay binlogsysvar">Да</td>
<td headers="rowbinlog_group_commit_sync_delay binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_group_commit_sync_delay binlogoptfile">Да</td>
<td headers="rowbinlog_group_commit_sync_delay binlogscope">Глобальная</td>
<td headers="rowbinlog_group_commit_sync_delay binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_group_commit_sync_delay binlognotes"><p>
Определяет сколько микросекунд ждать прежде, чем
синхронизировать транзакции с диском.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_group_commit_sync_no_delay_count" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_group_commit_sync_no_delay_count">binlog_group_commit_sync_no_delay_count</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_group_commit_sync_no_delay_count binlogcli">Да</td>
<td headers="rowbinlog_group_commit_sync_no_delay_count binlogsysvar">Да</td>
<td headers="rowbinlog_group_commit_sync_no_delay_count binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_group_commit_sync_no_delay_count binlogoptfile">Да</td>
<td headers="rowbinlog_group_commit_sync_no_delay_count binlogscope">Глобальная</td>
<td headers="rowbinlog_group_commit_sync_no_delay_count binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_group_commit_sync_no_delay_count binlognotes"><p>
Устанавливает максимальное количество транзакций, которое ждать прежде, чем
прервать текущую задержку, определенную binlog_group_commit_sync_delay.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_max_flush_queue_time" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_max_flush_queue_time">binlog_max_flush_queue_time</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_max_flush_queue_time binlogcli">Нет</td>
<td headers="rowbinlog_max_flush_queue_time binlogsysvar">Да</td>
<td headers="rowbinlog_max_flush_queue_time binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_max_flush_queue_time binlogoptfile">Нет</td>
<td headers="rowbinlog_max_flush_queue_time binlogscope">Глобальная</td>
<td headers="rowbinlog_max_flush_queue_time binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_max_flush_queue_time binlognotes"><p>
Сколько времени читать транзакции прежде, чем сбросить в двоичный журнал.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_order_commits" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_order_commits">binlog_order_commits</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_order_commits binlogcli">Нет</td>
<td headers="rowbinlog_order_commits binlogsysvar">Да</td>
<td headers="rowbinlog_order_commits binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_order_commits binlogoptfile">Нет</td>
<td headers="rowbinlog_order_commits binlogscope">Глобальная</td>
<td headers="rowbinlog_order_commits binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_order_commits binlognotes"><p>
Передать ли в том же самом порядке, как записано в двоичном журнале.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_row_image" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_row_image">binlog_row_image</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_row_image binlogcli">Да</td>
<td headers="rowbinlog_row_image binlogsysvar">Да</td>
<td headers="rowbinlog_row_image binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_row_image binlogoptfile">Да</td>
<td headers="rowbinlog_row_image binlogscope">Both</td>
<td headers="rowbinlog_row_image binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_row_image binlognotes"><p>
Использовать полные или минимальные образы, регистрируя изменения строки.
Позволенные значения full, minimal и noblob.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_rows_query_log_events" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_rows_query_log_events">binlog_rows_query_log_events</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_rows_query_log_events binlogcli">Нет</td>
<td headers="rowbinlog_rows_query_log_events binlogsysvar">Да</td>
<td headers="rowbinlog_rows_query_log_events binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_rows_query_log_events binlogoptfile">Нет</td>
<td headers="rowbinlog_rows_query_log_events binlogscope">Both</td>
<td headers="rowbinlog_rows_query_log_events binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_rows_query_log_events binlognotes"><p>
Когда TRUE, позволяет регистрировать события запроса строк в основанном на
строке режиме журналирования. FALSE по умолчанию. Не включайте, производя
журналы для ведомых устройств репликации pre-5.6.2.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowBinlog_stmt_cache_disk_use" headers="binlogoptvar"><p>
<code><a href="server.htm#statvar_Binlog_stmt_cache_disk_use">
Binlog_stmt_cache_disk_use</a></code>
</p></td></tr>
<tr><td headers="rowBinlog_stmt_cache_disk_use binlogcli">Нет</td>
<td headers="rowBinlog_stmt_cache_disk_use binlogsysvar">Нет</td>
<td headers="rowBinlog_stmt_cache_disk_use binlogstatvar">Да</td></tr>
<tr><td headers="rowBinlog_stmt_cache_disk_use binlogoptfile">Нет</td>
<td headers="rowBinlog_stmt_cache_disk_use binlogscope">Глобальная</td>
<td headers="rowBinlog_stmt_cache_disk_use binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowBinlog_stmt_cache_disk_use binlognotes"><p>
Число нетранзакционных запросов, которые использовали временный файл вместо
кэша запросов журнала.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlog_stmt_cache_size" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size</a></code>
</p></td></tr>
<tr><td headers="rowbinlog_stmt_cache_size binlogcli">Да</td>
<td headers="rowbinlog_stmt_cache_size binlogsysvar">Да</td>
<td headers="rowbinlog_stmt_cache_size binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlog_stmt_cache_size binlogoptfile">Да</td>
<td headers="rowbinlog_stmt_cache_size binlogscope">Глобальная</td>
<td headers="rowbinlog_stmt_cache_size binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlog_stmt_cache_size binlognotes"><p>
Размер кэша, чтобы содержать нетранзакционные запросы для двоичного журнала
во время транзакции.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowBinlog_stmt_cache_use" headers="binlogoptvar"><p>
<code><a href="server.htm#statvar_Binlog_stmt_cache_use">
Binlog_stmt_cache_use</a></code></p></td></tr>
<tr><td headers="rowBinlog_stmt_cache_use binlogcli">Нет</td>
<td headers="rowBinlog_stmt_cache_use binlogsysvar">Нет</td>
<td headers="rowBinlog_stmt_cache_use binlogstatvar">Да</td></tr>
<tr><td headers="rowBinlog_stmt_cache_use binlogoptfile">Нет</td>
<td headers="rowBinlog_stmt_cache_use binlogscope">Глобальная</td>
<td headers="rowBinlog_stmt_cache_use binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowBinlog_stmt_cache_use binlognotes"><p>
Число запросов, которые использовали временный кэш запросов журнала.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowbinlogging_impossible_mode" headers="binlogoptvar"><p>
<code><a href="#sysvar_binlogging_impossible_mode">
binlogging_impossible_mode</a></code></p></td></tr>
<tr><td headers="rowbinlogging_impossible_mode binlogcli">Да</td>
<td headers="rowbinlogging_impossible_mode binlogsysvar">Да</td>
<td headers="rowbinlogging_impossible_mode binlogstatvar">Нет</td></tr>
<tr><td headers="rowbinlogging_impossible_mode binlogoptfile">Да</td>
<td headers="rowbinlogging_impossible_mode binlogscope">Both</td>
<td headers="rowbinlogging_impossible_mode binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowbinlogging_impossible_mode binlognotes"><p>
Устарел и будет удален в будущей версии. Используйте binlog_error_action.
</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowCom_show_binlog_events" headers="binlogoptvar"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_show_binlog_events</a></code>
</p></td></tr>
<tr><td headers="rowCom_show_binlog_events binlogcli">Нет</td>
<td headers="rowCom_show_binlog_events binlogsysvar">Нет</td>
<td headers="rowCom_show_binlog_events binlogstatvar">Да</td></tr>
<tr><td headers="rowCom_show_binlog_events binlogoptfile">Нет</td>
<td headers="rowCom_show_binlog_events binlogscope">Both</td>
<td headers="rowCom_show_binlog_events binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowCom_show_binlog_events binlognotes"><p>
Счетчик SHOW BINLOG EVENTS.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowCom_show_binlogs" headers="binlogoptvar"><p>
<code><a href="server.htm#statvar_Com_xxx">Com_show_binlogs</a></code>
</p></td></tr>
<tr><td headers="rowCom_show_binlogs binlogcli">Нет</td>
<td headers="rowCom_show_binlogs binlogsysvar">Нет</td>
<td headers="rowCom_show_binlogs binlogstatvar">Да</td></tr>
<tr><td headers="rowCom_show_binlogs binlogoptfile">Нет</td>
<td headers="rowCom_show_binlogs binlogscope">Both</td>
<td headers="rowCom_show_binlogs binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowCom_show_binlogs binlognotes"><p>
Счетчик SHOW BINLOGS.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowlog-bin-use-v1-row-events" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_log-bin-use-v1-row-events">log-bin-use-v1-row-events</a></code>
</p></td></tr>
<tr><td headers="rowlog-bin-use-v1-row-events binlogcli">Да</td>
<td headers="rowlog-bin-use-v1-row-events binlogsysvar">Да</td>
<td headers="rowlog-bin-use-v1-row-events binlogstatvar">Нет</td></tr>
<tr><td headers="rowlog-bin-use-v1-row-events binlogoptfile">Да</td>
<td headers="rowlog-bin-use-v1-row-events binlogscope">Глобальная</td>
<td headers="rowlog-bin-use-v1-row-events binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowlog-bin-use-v1-row-events binlognotes"><p>
Использовать первую версию событий строки.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowlog_bin_basename" headers="binlogoptvar"><p>
<code><a href="#sysvar_log_bin_basename">log_bin_basename</a></code>
</p></td></tr>
<tr><td headers="rowlog_bin_basename binlogcli">Нет</td>
<td headers="rowlog_bin_basename binlogsysvar">Да</td>
<td headers="rowlog_bin_basename binlogstatvar">Нет</td></tr>
<tr><td headers="rowlog_bin_basename binlogoptfile">Нет</td>
<td headers="rowlog_bin_basename binlogscope">Глобальная</td>
<td headers="rowlog_bin_basename binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowlog_bin_basename binlognotes"><p>
Полный путь к двоичному журналу, включая имя файла.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowlog_bin_use_v1_row_events" headers="binlogoptvar"><p>
<code><a href="#sysvar_log_bin_use_v1_row_events">
log_bin_use_v1_row_events</a></code></p></td></tr>
<tr><td headers="rowlog_bin_use_v1_row_events binlogcli">Да</td>
<td headers="rowlog_bin_use_v1_row_events binlogsysvar">Да</td>
<td headers="rowlog_bin_use_v1_row_events binlogstatvar">Нет</td></tr>
<tr><td headers="rowlog_bin_use_v1_row_events binlogoptfile">Да</td>
<td headers="rowlog_bin_use_v1_row_events binlogscope">Глобальная</td>
<td headers="rowlog_bin_use_v1_row_events binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowlog_bin_use_v1_row_events binlognotes"><p>
Использует ли сервер первую версию событий строки.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowmaster-verify-checksum" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_master-verify-checksum">master-verify-checksum</a></code>
</p></td></tr>
<tr><td headers="rowmaster-verify-checksum binlogcli">Да</td>
<td headers="rowmaster-verify-checksum binlogsysvar">Нет</td>
<td headers="rowmaster-verify-checksum binlogstatvar">Нет</td></tr>
<tr><td headers="rowmaster-verify-checksum binlogoptfile">Да</td>
<td headers="rowmaster-verify-checksum binlogscope"></td>
<td headers="rowmaster-verify-checksum binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowmaster-verify-checksum binlognotes"><p>
Ведущее устройство должно исследовать контрольные суммы, читая
из двоичного журнала.</p></td></tr></tbody>
<tbody><tr>
<td colspan="3" align="center" id="rowmaster_verify_checksum" headers="binlogoptvar"><p>
<code><a href="#sysvar_master_verify_checksum">master_verify_checksum</a></code>
</p></td></tr>
<tr><td headers="rowmaster_verify_checksum binlogcli">Нет</td>
<td headers="rowmaster_verify_checksum binlogsysvar">Да</td>
<td headers="rowmaster_verify_checksum binlogstatvar">Нет</td></tr>
<tr><td headers="rowmaster_verify_checksum binlogoptfile">Нет</td>
<td headers="rowmaster_verify_checksum binlogscope">Глобальная</td>
<td headers="rowmaster_verify_checksum binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowmaster_verify_checksum binlognotes"><p>
Ведущее устройство должно читать контрольные суммы из двоичного журнала.
</p></td></tr></tbody>
<tbody><tr><td colspan="3" align="center" id="rowmax-binlog-dump-events" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_max-binlog-dump-events">max-binlog-dump-events</a></code>
</p></td></tr>
<tr><td headers="rowmax-binlog-dump-events binlogcli">Да</td>
<td headers="rowmax-binlog-dump-events binlogsysvar">Нет</td>
<td headers="rowmax-binlog-dump-events binlogstatvar">Нет</td></tr>
<tr><td headers="rowmax-binlog-dump-events binlogoptfile">Да</td>
<td headers="rowmax-binlog-dump-events binlogscope"></td>
<td headers="rowmax-binlog-dump-events binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowmax-binlog-dump-events binlognotes"><p>
Опция, используемая mysql-test для отладки репликации.</p></td></tr></tbody>

<tbody><tr><td colspan="3" align="center" id="rowmax_binlog_cache_size" headers="binlogoptvar"><p>
<code><a href="#sysvar_max_binlog_cache_size">max_binlog_cache_size</a></code>
</p></td></tr>
<tr><td headers="rowmax_binlog_cache_size binlogcli">Да</td>
<td headers="rowmax_binlog_cache_size binlogsysvar">Да</td>
<td headers="rowmax_binlog_cache_size binlogstatvar">Нет</td></tr>
<tr><td headers="rowmax_binlog_cache_size binlogoptfile">Да</td>
<td headers="rowmax_binlog_cache_size binlogscope">Глобальная</td>
<td headers="rowmax_binlog_cache_size binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowmax_binlog_cache_size binlognotes"><p>
Может использоваться, чтобы ограничить полный размер, используемый, чтобы
кэшировать транзакцию мультизапроса.</p></td></tr></tbody>

<tbody><tr><td colspan="3" align="center" id="rowmax_binlog_size" headers="binlogoptvar"><p>
<code><a href="#sysvar_max_binlog_size">max_binlog_size</a></code>
</p></td></tr>
<tr><td headers="rowmax_binlog_size binlogcli">Да</td>
<td headers="rowmax_binlog_size binlogsysvar">Да</td>
<td headers="rowmax_binlog_size binlogstatvar">Нет</td></tr>
<tr><td headers="rowmax_binlog_size binlogoptfile">Да</td>
<td headers="rowmax_binlog_size binlogscope">Глобальная</td>
<td headers="rowmax_binlog_size binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowmax_binlog_size binlognotes"><p>
Двоичный журнал будет ротирован автоматически, когда размер
превысит это значение.</p></td></tr></tbody>

<tbody><tr><td colspan="3" align="center" id="rowmax_binlog_stmt_cache_size" headers="binlogoptvar"><p>
<code><a href="#sysvar_max_binlog_stmt_cache_size">max_binlog_stmt_cache_size</a></code>
</p></td></tr>
<tr><td headers="rowmax_binlog_stmt_cache_size binlogcli">Да</td>
<td headers="rowmax_binlog_stmt_cache_size binlogsysvar">Да</td>
<td headers="rowmax_binlog_stmt_cache_size binlogstatvar">Нет</td></tr>
<tr><td headers="rowmax_binlog_stmt_cache_size binlogoptfile">Да</td>
<td headers="rowmax_binlog_stmt_cache_size binlogscope">Глобальная</td>
<td headers="rowmax_binlog_stmt_cache_size binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowmax_binlog_stmt_cache_size binlognotes"><p>
Может использоваться, чтобы ограничить полный размер, используемый,
чтобы кэшировать все нетранзакционные запросы во время транзакции.
</p></td></tr></tbody>

<tbody><tr><td colspan="3" align="center" id="rowslave-sql-verify-checksum" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_slave-sql-verify-checksum">slave-sql-verify-checksum</a></code>
</p></td></tr>
<tr><td headers="rowslave-sql-verify-checksum binlogcli">Да</td>
<td headers="rowslave-sql-verify-checksum binlogsysvar">Нет</td>
<td headers="rowslave-sql-verify-checksum binlogstatvar">Нет</td></tr>
<tr><td headers="rowslave-sql-verify-checksum binlogoptfile">Да</td>
<td headers="rowslave-sql-verify-checksum binlogscope"></td>
<td headers="rowslave-sql-verify-checksum binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowslave-sql-verify-checksum binlognotes"><p>
Заставить ведомое устройство исследовать контрольные суммы, читая
из журнала реле.</p></td></tr></tbody>

<tbody><tr>
<td colspan="3" align="center" id="rowslave_sql_verify_checksum" headers="binlogoptvar"><p>
<code><a href="#sysvar_slave_sql_verify_checksum">slave_sql_verify_checksum</a></code>
</p></td></tr>
<tr><td headers="rowslave_sql_verify_checksum binlogcli">Нет</td>
<td headers="rowslave_sql_verify_checksum binlogsysvar">Да</td>
<td headers="rowslave_sql_verify_checksum binlogstatvar">Нет</td></tr>
<tr><td headers="rowslave_sql_verify_checksum binlogoptfile">Нет</td>
<td headers="rowslave_sql_verify_checksum binlogscope">Глобальная</td>
<td headers="rowslave_sql_verify_checksum binlogdynamic">Да</td></tr>
<tr><td colspan="3" headers="rowslave_sql_verify_checksum binlognotes"><p>
Заставить ведомое устройство исследовать контрольные суммы, читая
из журнала реле.</p></td></tr></tbody>

<tbody><tr>
<td colspan="3" align="center" id="rowsporadic-binlog-dump-fail" headers="binlogoptvar"><p>
<code><a href="#option_mysqld_sporadic-binlog-dump-fail">sporadic-binlog-dump-fail</a></code>
</p></td></tr>
<tr><td headers="rowsporadic-binlog-dump-fail binlogcli">Да</td>
<td headers="rowsporadic-binlog-dump-fail binlogsysvar">Нет</td>
<td headers="rowsporadic-binlog-dump-fail binlogstatvar">Нет</td></tr>
<tr><td headers="rowsporadic-binlog-dump-fail binlogoptfile">Да</td>
<td headers="rowsporadic-binlog-dump-fail binlogscope"></td>
<td headers="rowsporadic-binlog-dump-fail binlogdynamic">Нет</td></tr>
<tr><td colspan="3" headers="rowsporadic-binlog-dump-fail binlognotes"><p>
Опция, используемая mysql-test для отладки и тестирования.
</p></td></tr></tbody></table>

<p><a href="#replication-options-binary-log">Раздел 19.1.6.4</a>
обеспечивает более подробную информацию об опциях и переменных, касающихся
двоичного журналирования. Для дополнительной общей информации о двоичном
журнале см. <a href="server.htm#binary-log">раздел 6.4.4</a>.</p>

<p>Для информации о переменных
<a href="server.htm#sysvar_sql_log_bin"><code>sql_log_bin</code></a> и
<a href="server.htm#sysvar_sql_log_off"><code>sql_log_off</code></a> см.
<a href="server.htm#server-system-variables">раздел 6.1.5</a>.</p>

<p>Для таблицы, показывающей <span><em>все</em></span> параметры командной
строки и переменные состояния, используемые с <a href="programs.htm#mysqld">
<span><strong>mysqld</strong></span></a>, см
<a href="server.htm#mysqld-option-tables">раздел 6.1.3</a>.</p>

<h4><a name="replication-options-master"></a>19.1.6.2.
Ведущие опции и переменные репликации</h4>
<p>Этот раздел описывает параметры сервера и системные переменные, которые Вы
можете использовать на главных серверах репликации. Вы можете определить
опции в <a href="programs.htm#command-line-options">командной строке</a>
или в <a href="programs.htm#option-files">файле опций</a>.
Вы можете определить значения переменных с использование
<a href="sql.htm#set-variable"><code>SET</code></a>.</p>

<p>На ведущем устройстве и каждом ведомом устройстве Вы должны использовать
опцию <a href="#option_mysqld_server-id"><code>server-id</code>
</a>, чтобы установить уникальный ID репликации. Для каждого сервера Вы
должны выбрать уникальное положительное целое число в диапазоне от 1 до
2<sup>32</sup> - 1, каждый ID должно отличаться от любого ID в использовании
любым другим ведущим устройством репликации или ведомым устройством. Пример:
<code>server-id=3</code>.</p>

<p>Для опций, используемых на ведущем устройстве для того, чтобы управлять
двоичным журналированием, см.
<a href="#replication-options-binary-log">раздел 19.1.6.4</a>.
</p>

<h5><a name="replication-sysvars-masters"></a>
Системные переменные, используемые на ведущих устройствах репликации</h5>
<p>Следующие системные переменные используются, чтобы управлять
ведущими устройствами репликации:</p>

<ul><li><p><a name="sysvar_auto_increment_increment"></a>
<a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_auto_increment_increment">
auto_increment_increment</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>65535</code></td></tr></tbody></table>

<p><a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a> и
<a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a>
предназначены для использования с репликацией от ведущего устройства к
ведущему устройству и могут использоваться, чтобы управлять работой
столбцов <code>AUTO_INCREMENT</code>. Обе переменные имеют значения
глобальное и сеанса, каждая может принять целочисленное значение между 1 и
65535 включительно. Установка значения любой из этих двух переменных к 0
установит значение в 1 вместо этого. Попытка установить значение любой из
этих двух переменных к целому числу, больше 65535 или меньше 0 установит
значение 65535. Попытка установить значение
<a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a> или
<a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a> к нецелому числу производит ошибку, и
фактическое значение переменной остается неизменным.</p>

<p><a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a> предназначена для использования с
MySQL Cluster, который в настоящее время не поддерживается в MySQL 8.0.</p>

<p>Эти две переменные влияют на поведение столбца
<code>AUTO_INCREMENT</code> следующим образом:</p>
<ul><li><p><a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a> управляет интервалом между
последовательными значениями столбца. Например:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'auto_inc%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 1     |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; CREATE TABLE autoinc1
    -&gt;        (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
Query OK, 0 rows affected (0.04 sec)

mysql&gt; SET @@auto_increment_increment=10;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SHOW VARIABLES LIKE 'auto_inc%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 1     |
+--------------------------+-------+
2 rows in set (0.01 sec)

mysql&gt; INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
Query OK, 4 rows affected (0.00 sec)
Records: 4 Duplicates: 0 Warnings: 0

mysql&gt; SELECT col FROM autoinc1;
+-----+
| col |
+-----+
|  1  |
| 11  |
| 21  |
| 31  |
+-----+
4 rows in set (0.00 sec)
</pre></li>

<li><a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a> определяет начальную точку для значения
<code>AUTO_INCREMENT</code>. Рассмотрите следующее, предполагая, что эти
запросы выполнены во время того же самого сеанса, как пример, данный в
описании <a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a>:
<pre>
mysql&gt; SET @@auto_increment_offset=5;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SHOW VARIABLES LIKE 'auto_inc%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; CREATE TABLE autoinc2
    -&gt;        (col INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
Query OK, 0 rows affected (0.06 sec)

mysql&gt; INSERT INTO autoinc2 VALUES (NULL), (NULL), (NULL), (NULL);
Query OK, 4 rows affected (0.00 sec)
Records: 4 Duplicates: 0 Warnings: 0

mysql&gt; SELECT col FROM autoinc2;
+-----+
| col |
+-----+
|  5  |
| 15  |
| 25  |
| 35  |
+-----+
4 rows in set (0.02 sec)
</pre>

<p>Когда значение <a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a> больше, чем
<a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a>, значение
<a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a> проигнорировано.</p></li></ul>

<p>Если любая из этих переменных изменена, а затем новые строки, вставлены
в таблицу, содержащую <code>AUTO_INCREMENT</code>,
результаты могут казаться парадоксальными потому, что серия
<code>AUTO_INCREMENT</code> вычислены без отношения к любым значениям, уже
существующим в столбце, и следующее вставленное значение является наименьшим
в ряду, который больше, чем максимальное существующее значение в
<code>AUTO_INCREMENT</code>. Ряд вычислен так:</p>

<p><code>auto_increment_offset</code> +
<em><code>N</code></em> * <code>auto_increment_increment</code></p>
<p>где <em><code>N</code></em> положительное целочисленное значение в ряду
[1, 2, 3, ...]:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'auto_inc%';
+--------------------------+-------+
| Variable_name            | Value |
+--------------------------+-------+
| auto_increment_increment | 10    |
| auto_increment_offset    | 5     |
+--------------------------+-------+
2 rows in set (0.00 sec)

mysql&gt; SELECT col FROM autoinc1;
+-----+
| col |
+-----+
|  1  |
| 11  |
| 21  |
| 31  |
+-----+
4 rows in set (0.00 sec)

mysql&gt; INSERT INTO autoinc1 VALUES (NULL), (NULL), (NULL), (NULL);
Query OK, 4 rows affected (0.00 sec)
Records: 4 Duplicates: 0 Warnings: 0

mysql&gt; SELECT col FROM autoinc1;
+-----+
| col |
+-----+
|   1 |
|  11 |
|  21 |
|  31 |
|  35 |
|  45 |
|  55 |
|  65 |
+-----+
8 rows in set (0.00 sec)
</pre>

<p>Значения, показанные для
<a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a> и
<a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a> производят ряд
5 + <em><code>N</code></em> * 10, то есть, [5, 15, 25, 35, 45, ...].
Самое высокое значение, существующее в столбце <code>col</code>
до <a href="sql.htm#insert"><code>INSERT</code></a> 31,
следующее доступное значение в <code>AUTO_INCREMENT</code> 35,
таким образом, вставленные значения для <code>col</code> начнутся в этом
пункте, результаты показаны для <a href="sql.htm#select"><code>SELECT
</code></a>.</p>

<p>Невозможно ограничить эффекты этих двух переменных единственной таблицей,
эти переменные управляют поведением всех столбцов <code>AUTO_INCREMENT</code>
во <span><em>всех</em></span> таблицах на сервере MySQL. Если глобальное
значение переменной установлено, ее эффекты сохраняются, пока глобальное
значение не изменено или переопределено, устанавливая значение сеанса, или
пока <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
не перезапущен. Если местное значение установлено, новые значения
<code>AUTO_INCREMENT</code> действуют для всех таблиц, в которые новые строки
вставлены текущим пользователем в сеансе, если значения не изменены
во время сеанса.</p>

<p>Значение по умолчанию
<a href="#sysvar_auto_increment_increment">
<code>auto_increment_increment</code></a> 1. См.
<a href="#replication-features-auto-increment">раздел 19.4.1.1
</a>.</li>

<li><a name="sysvar_auto_increment_offset"></a>
<a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_auto_increment_offset">auto_increment_offset</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>65535</code></td></tr></tbody></table>

<p>У этой переменной есть значение по умолчанию 1. Для получения
дополнительной информации см. описание для
<a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a>.</p>

<p><a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a> предназначена для использования с
MySQL Cluster, который в настоящее время не поддерживается в MySQL 8.0.
</p></li></ul>

<h4><a name="replication-options-slave"></a>19.1.6.3.
Ведомые опции и переменные репликации</h4>
<p>Этот раздел объясняет параметры сервера и системные переменные, которые
относятся к ведомым серверам репликации.</p>

<p>Определите опции в <a href="programs.htm#command-line-options">командной
строке</a> или в <a href="programs.htm#option-files">файле опций</a>.
Многие из опций могут быть установлены в то время, как сервер работает при
использовании <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO
</code></a>. Определите значение переменной с использованием
<a href="sql.htm#set-variable"><code>SET</code></a>.</p>

<p><b>ID сервера. </b>На ведущем устройстве и на каждом ведомом устройстве Вы
должны использовать <a href="#option_mysqld_server-id"><code>
server-id</code></a>, чтобы установить уникальный ID репликации в диапазоне
от 1 до 2<sup>32</sup>-1. <span><span>Уникальный</span></span> означает, что
каждый ID должен отличаться от любого ID в использовании любым другим ведущим
устройством репликации или ведомым устройством.
Пример файла <code>my.cnf</code>:
<pre>
[mysqld]
server-id=3
</pre>

<h5><a name="replication-optvars-slaves"></a>
Опции запуска для ведомых устройств репликации</h5>
<p>Этот раздел объясняет опции запуска для того, чтобы управлять ведомыми
серверами репликации. Многие из этих опций могут быть установлены в то время,
как сервер работает, с помощью <a href="sql.htm#change-master-to"><code>
CHANGE MASTER TO</code></a>. Другие, например, опции
<code>--replicate-*</code> могут быть установлены только, когда ведомый
сервер запускается. Связанные с репликацией системные переменные обсуждены
позже в этом разделе.</p>

<ul><li><p><a name="option_mysqld_log-slave-updates"></a>
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--log-slave-updates</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_slave_updates">log_slave_updates</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Обычно ведомое устройство не пишет обновлений, которые получены от
главного сервера в собственный двоичный журнал. Эта опция заставляет ведомое
устройство писать обновления, выполненные его потоком SQL к его собственному
двоичному журналу. Для работы этой опции ведомое устройство должно быть
запущено также с опцией <a href="#option_mysqld_log-bin"><code>
--log-bin</code></a>, чтобы включить двоичное журналирование.
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a> используется, когда Вы хотите объединить
серверы репликации в цепочку. Например, Вы могли бы хотеть настроить серверы
репликации, используя это расположение:
<pre>
A -&gt; B -&gt; C
</pre>

<p>Здесь <code>A</code> служит ведущим устройством для ведомого устройства
<code>B</code>, <code>B</code> служит ведущим устройством для ведомого
устройства <code>C</code>. Для того, чтобы работать, <code>B</code>
должно быть ведущим <span><em>и</em></span> ведомым устройством. Вы должны
запустить <code>A</code> и <code>B</code> с
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>, чтобы
включить двоичное журналирование, и <code>B</code> с
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a> так, чтобы обновления из <code>A</code>
были зарегистрированы <code>B</code> в его двоичном журнале.</li>

<li><a href="server.htm#option_mysqld_log-warnings"><code>
--log-warnings[=<em><code>level</code></em>]</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.7.2</td></tr>
<tr><td scope="row"><span><strong>Командная строка</strong></span></td>
<td colspan="3"><code>--log-warnings[=#]</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_log_warnings">log_warnings</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>2</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>2</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p><a href="server.htm#sysvar_log_error_verbosity"><code>
log_error_verbosity</code></a> должна использоваться вместо опции
<a href="server.htm#option_mysqld_log-warnings"><code>--log-warnings</code>
</a> или переменной <a href="server.htm#sysvar_log_warnings"><code>
log_warnings</code></a>. См. описания
<a href="server.htm#sysvar_log_error_verbosity"><code>log_error_verbosity
</code></a> и <a href="server.htm#sysvar_log_warnings"><code>log_warnings
</code></a>. Опция <a href="server.htm#option_mysqld_log-warnings"><code>
--log-warnings</code></a> и переменная
<a href="server.htm#sysvar_log_warnings"><code>log_warnings</code></a>
устарели и будут удалены в будущем выпуске MySQL.</p>

<p>Заставляет сервер делать запись большего количества сообщений в
журнал ошибок о том, что это делает. Относительно репликации сервер
производит предупреждения, что это преуспело в том, чтобы повторно
соединиться после отказа сети или соединения и предоставляет информацию о
том, как каждый ведомый поток запускался. Эта переменная включена по
умолчанию со значением 2. Чтобы отключить это, установите в 0. Сервер
регистрирует сообщения о запросах, которые опасны для основанного на запросе
журналирования, если значение больше 0. Прерванные соединения и ошибки
запрета доступа для новых попыток соединения зарегистрированы, если значение
больше 1. См. <a href="error.htm#communication-errors">раздел B.5.2.10</a>.
</p>
<p>Эффекты этой опции не ограничены репликацией. Это производит
предупреждения для разных действий сервера.</p></li>

<li><a name="option_mysqld_master-info-file"></a>
<a href="#option_mysqld_master-info-file"><code>
--master-info-file=<em><code>file_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--master-info-file=file_name</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>master.info</code></td></tr></tbody></table>

<p>Имя, чтобы использовать для файла, в котором ведомое устройство делает
запись информации о ведущем устройстве. Имя по умолчанию
<code>master.info</code> в каталоге данных. Для информации о формате этого
файла см. <a href="#slave-logs-status">раздел 19.2.4.2</a>.</li>

<li><a name="option_mysqld_master-retry-count"></a>
<a href="#option_mysqld_master-retry-count"><code>
--master-retry-count=<em><code>count</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.6.1</td></tr>
<tr><td scope="row"><span><strong>Командная строка</strong></span></td>
<td colspan="3"><code>--master-retry-count=#</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>86400</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>86400</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Число раз, которое ведомое устройство пытается соединиться с ведущим
устройством перед отказом. Повторные соединения предприняты с промежутками,
установленными опцией <code>MASTER_CONNECT_RETRY</code> в
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
(по умолчанию 60). Повторное соединение вызвано, когда данные читаются
ведомым согласно опции <a href="#option_mysqld_slave-net-timeout">
<code>--slave-net-timeout</code></a>. Значение по умолчанию 86400. Значение 0
указывает, что ведомое устройство пытается соединиться всегда.</p>

<p>Эта опция устарела и будет удалена в будущем выпуске MySQL. Приложения
должны быть обновлены, чтобы использовать <code>MASTER_RETRY_COUNT</code> в
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>.</li>

<li><a name="option_mysqld_max-relay-log-size"></a>
<a href="#option_mysqld_max-relay-log-size"><code>
--max-relay-log-size=<em><code>size</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--max_relay_log_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_max_relay_log_size">max_relay_log_size</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr></tbody></table>

<p>Размер, в котором сервер ротирует файлы системного журнала реле
автоматически. Если это значение является отличным от нуля, журнал реле
ротируется автоматически, когда его размер превышает это значение.
Если это значение ноль (значение по умолчанию), размер, в котором происходит
ротация журнала реле, определен значением
<a href="#sysvar_max_binlog_size"><code>max_binlog_size</code>
</a>. См. <a href="#slave-logs-relaylog">раздел 19.2.4.1</a>.</li>

<li><a name="option_mysqld_relay-log"></a>
<a href="#option_mysqld_relay-log"><code>
--relay-log=<em><code>file_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log=file_name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log">relay_log</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr></tbody></table>

<p>Базовое имя для журнала реле. Для канала репликации по умолчанию
базовое имя по умолчанию для журналов реле
<code><em><code>host_name</code></em>-relay-bin</code>.
Для каналов репликации не по умолчанию базовое имя по умолчанию для журналов
реле <code><em><code>host_name</code></em>-<em><code>channel</code></em>-relay-bin</code>,
где <em><code>channel</code></em> название канала репликации,
зарегистрированного в этом журнале реле. Сервер пишет файл в каталоге данных,
если базовое имя не дано с ведущим абсолютным путем, чтобы определить
отличный каталог. Сервер создает файлы системного журнала реле в
последовательности, добавляя числовой суффикс к базовому имени.</p>

<p>Из-за манеры, в которой MySQL разбирает параметры сервера, если Вы
определяете эту опцию, Вы должны поставлять значение,
<span><em>базовое имя по умолчанию используется, только если опция фактически
не определена</em></span>. Если Вы используете
<a href="#option_mysqld_relay-log"><code>--relay-log</code></a>
не определяя значение, неожиданное поведение, вероятно, будет, это поведение
зависит от других используемых опций, порядка, в котором они определены, и
определены ли они на командной строке или в файле опции. Для получения
дополнительной информации о том, как MySQL обрабатывает параметры сервера см.
<a href="programs.htm#program-options">раздел 5.2.3</a>.</p>

<p>Если Вы определяете эту опцию, определенное значение также используется
как базовое имя для индексного файла журнала реле.
Вы можете переопределить это поведение, определяя другое
базовое имя индексного файла, используя опцию
<a href="#option_mysqld_relay-log-index"><code>--relay-log-index
</code></a>.</p>

<p>Когда сервер читает запись из индексного файла, он проверяет, содержит ли
она относительный путь. Если это так, относительная часть пути заменена
абсолютным путем, используя <code>--relay-log</code>.
Абсолютный путь остается неизменным, в таком случае индексирование должно
быть отредактировано вручную, чтобы позволить новому пути или путям
использоваться. Ранее ручное вмешательство требовалось, перемещая двоичный
журнал или файлы системного журнала реле (Bug #11745230, Bug #12133).</p>

<p>Вы можете найти опцию <a href="#option_mysqld_relay-log">
<code>--relay-log</code></a> полезной в выполнении следующих задач:</p>
<ul><li><p>Создание журналов реле, чьи имена независимы от имен хоста.</li>

<li>Если Вы должны поместить журнал реле в некоторую область кроме каталога
данных, потому что Ваши журналы реле имеют тенденцию быть очень большими, и
Вы не хотите уменьшать <a href="server.htm#sysvar_max_relay_log_size"><code>
max_relay_log_size</code></a>.</li>
<li>Увеличить скорость при использовании балансирования
загрузки между дисками.</p></li></ul>

<p>Вы можете получить имя файла системного журнала реле (и путь) из
переменной <a href="#sysvar_relay_log_basename">
<code>relay_log_basename</code></a>.</li>

<li><a name="option_mysqld_relay-log-index"></a>
<a href="#option_mysqld_relay-log-index"><code>
--relay-log-index=<em><code>file_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log-index=file_name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log_index">relay_log_index</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr></tbody></table>

<p>Имя, чтобы использовать для индексного файла журнала реле.
Имя по умолчанию <code><em><code>host_name</code></em>-relay-bin.index</code>
в каталоге данных, где <em><code>host_name</code></em> название сервера. Для
канала репликации по умолчанию имя по умолчанию
<code><em><code>host_name</code></em>-relay-bin.index</code>.
Для каналов репликации не по умолчанию имя по умолчанию
<code><em><code>host_name</code></em>-<em><code>channel</code></em>-relay-bin.index</code>,
где <em><code>channel</code></em> название канала репликации,
зарегистрированного в этом журнале реле.</p>

<p>Из-за манеры, в которой MySQL разбирает параметры сервера, если Вы
определяете эту опцию, Вы должны поставлять значение,
<span><em>базовое имя значения по умолчанию используется, только если опция
фактически не определена</em></span>. Если Вы используете опцию
<a href="#option_mysqld_relay-log-index"><code>--relay-log-index</code></a>
не определяя значение, неожиданное поведение, вероятно, будет,
это поведение зависит от других используемых опций, порядка, в котором они
определены, и определены ли они в командной строке или в файле опции. Для
получения дополнительной информации о том, как MySQL обрабатывает параметры
сервера см. <a href="programs.htm#program-options">раздел 5.2.3</a>.</p>

<p>Если Вы определяете эту опцию, определенное значение также используется в
качестве базового имени для журналов реле. Вы можете переопределить это
поведение, определяя различное базовое имя файла системного журнала реле,
используя опцию <a href="#option_mysqld_relay-log"><code>
--relay-log</code></a>.</li>

<li><a name="option_mysqld_relay-log-info-file"></a>
<a href="#option_mysqld_relay-log-info-file"><code>
--relay-log-info-file=<em><code>file_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log-info-file=file_name</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>relay-log.info</code></td></tr></tbody></table>

<p>Имя, чтобы использовать для файла, в котором ведомое устройство делает
запись информации о журналах реле. Имя по умолчанию
<code>relay-log.info</code> в каталоге данных. Для информации о формате этого
файла см. <a href="#slave-logs-status">раздел 19.2.4.2</a>.</li>

<li><a name="option_mysqld_relay-log-purge"></a>
<a href="#option_mysqld_relay-log-purge"><code>
--relay-log-purge={0|1}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay_log_purge</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_relay_log_purge">relay_log_purge</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>TRUE</code></td></tr></tbody></table>

<p>Отключить или включить автоматическую чистку
журналов реле, как только они больше не нужны. Значение по умолчанию 1
(включить). Это глобальная переменная, которая может быть изменена
динамически с <code>SET GLOBAL relay_log_purge = <em><code>N</code></em></code>.
Отключение чистки журнала реле, используя опцию
<a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery</code></a> рискует последовательностью данных и поэтому
не безопасна от катастрофического отказа.</li>

<li><a name="option_mysqld_relay-log-recovery"></a>
<a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery={0|1}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log-recovery</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Немедленно включает автоматическое восстановление журнала реле после
запуска сервера. Процесс восстановления создает новый файл системного журнала
реле, инициализирует позицию потока SQL к этому новому журналу реле и
инициализирует поток ввода/вывода к позиции потока SQL. Чтение журнала реле
от ведущего устройства продолжается. Это должно использоваться после
катастрофического отказа на ведомом устройстве репликации, чтобы
гарантировать, что поврежденные журналы реле обработаны.
Значение по умолчанию 0 (отключено).</p>

<p>Чтобы обеспечить безопасное от катастрофического отказа ведомое
устройство, эта опция должна быть включена (установлена в 1),
<a href="#option_mysqld_relay-log-info-repository"><code>
--relay-log-info-repository</code></a> должен быть установлен в
<code>TABLE</code>, а <a href="server.htm#sysvar_relay_log_purge"><code>
relay-log-purge</code></a> включена. Включение
<a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery</code></a>, когда
<a href="server.htm#sysvar_relay_log_purge"><code>relay-log-purge</code></a>
выключена содержит риск чтения журнала реле из файлов, которые не были
очищены, приводя к несогласованности данных, а поэтому не безопасно
от катастрофического отказа.</p>

<p>Используя мультипоточное ведомое устройство (другими словами
<a href="#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> больше 0), несогласованности, такие как
промежутки, могут произойти в последовательности транзакций, которые были
выполнены от журнала реле. Включение
<a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery</code></a>, когда есть несогласованности, вызывает
ошибку, и опция не имеет никакого эффекта. Решение в этой ситуации состоит в
том, чтобы скомандовать <a href="sql.htm#start-slave"><code>START
SLAVE UNTIL SQL_AFTER_MTS_GAPS</code></a>, что приводит сервер в более
последовательный статус, затем <a href="sql.htm#reset-slave"><code>RESET
SLAVE</code></a>, чтобы удалить журналы реле. См.
<a href="#replication-features-transaction-inconsistencies">
раздел 19.4.1.34</a>.</li>

<li><a name="option_mysqld_relay-log-space-limit"></a>
<a href="#option_mysqld_relay-log-space-limit"><code>
--relay-log-space-limit=<em><code>size</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay_log_space_limit=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_relay_log_space_limit">relay_log_space_limit</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Эта опция устанавливает верхнюю границу полного размера в байтах всего
журнала реле ведомое устройство. Значение 0 отменяет лимит. Это полезно для
ведомого узла сервера, который ограничил дисковое пространство. Когда предел
достигнут, поток ввода/вывода прекращает читать двоичные события журнала с
главного сервера, пока поток SQL не нагонит и удалит некоторые
неиспользованные журналы реле. Отметьте, что этот предел не является
абсолютным: есть случаи, где поток SQL нуждается в большем количестве событий
прежде, чем он сможет удалить журналы реле. В этом случае поток ввода/вывода
превышает предел, пока для потока SQL не становится возможно удалить
некоторые журналы реле, потому что не выполнение этого вызвало бы тупик.
Вы не должны установить
<a href="#option_mysqld_relay-log-space-limit"><code>
--relay-log-space-limit</code></a> меньше чем два значения
<a href="#option_mysqld_max-relay-log-size"><code>
--max-relay-log-size</code></a> (или
<a href="#sysvar_max_binlog_size"><code>
--max-binlog-size</code></a>, если
<a href="#option_mysqld_max-relay-log-size"><code>
--max-relay-log-size</code></a> = 0).
В этом случае есть шанс, что поток ввода/вывода ждет свободного пространства,
потому что <a href="#option_mysqld_relay-log-space-limit"><code>
--relay-log-space-limit</code></a> превышен, но поток SQL не имеет никакого
журнала реле, чтобы произвести чистку и неспособен удовлетворить поток
ввода/вывода. Это вынуждает поток ввода/вывода проигнорировать временно
<a href="#option_mysqld_relay-log-space-limit">
<code>--relay-log-space-limit</code></a>.</li>

<li><a name="option_mysqld_replicate-do-db"></a>
<a href="#option_mysqld_replicate-do-db">
<code>--replicate-do-db=<em><code>db_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-do-db=name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Создает фильтр репликации, используя название базы данных.
Такие фильтры могут также быть созданы, используя
<a href="sql.htm#change-replication-filter"><code>CHANGE
REPLICATION FILTER REPLICATE_DO_DB</code></a>. Точный эффект этой фильтрации
зависит от того основанная на запросе или строке репликация используется и
описан в следующих нескольких параграфах.</p>

<p><b>Основанная на запросе репликация. </b>
Говорит ведомому потоку SQL ограничивать репликацию запросами, где база
данных значения по умолчанию (то есть, выбрана через
<a href="sql.htm#use"><code>USE</code></a>) <em><code>db_name</code></em>.
Чтобы определить больше, чем одну базу данных, используйте эту опцию
многократно, однажды для каждой базы данных,
однако, выполнение этого <span><em>не</em></span> копирует запросы
между базами данных, такие как <code>UPDATE <em><code>some_db.some_table
</code></em> SET foo='bar'</code> в то время, как различная база данных (или
никакая база данных) выбрана.</p>

<p>Чтобы определить многократные базы данных, Вы <span><em>должны</em></span>
использовать многократные копии этой опции.
Поскольку имена базы данных могут содержать запятые, если Вы будете
поставлять список разделенных запятой значений, то список будет обработан как
название единственной базы данных.</p>

<p>Пример того, что не работает, как Вы могли бы ожидать, используя
основанную на запросе репликацию: если ведомое устройство запущено с
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db=sales</code></a> и Вы делаете следующие запросы на ведущем
устройстве, <a href="sql.htm#update"><code>UPDATE</code></a>
<span><em>не</em></span> копируется:
<pre>
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre>

<p>Главная причина для этого <span><span>проверяется только значение базы
данных по умолчанию</span></span>. Трудно из одного только запроса знать,
должно ли это копироваться (например, если Вы используете многотабличные
запросы <a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>, которые действуют через
многие базы данных). Также быстрее проверить только базу данных по умолчанию,
а не все базы данных, если нет никакой потребности.</p>

<p><b>Основанная на строке репликация. </b>
Говорит ведомому потоку SQL ограничивать репликацию базой данных
<em><code>db_name</code></em>. Только таблицы, принадлежащие
<em><code>db_name</code></em> изменены, текущая база данных не имеет никакого
влияния на это. Предположите, что ведомое устройство запущено с
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db=sales</code></a>, основанная на строке репликация в
действительности, затем следующие запросы выполнены на ведущем устройстве:
<pre>
USE prices;
UPDATE sales.february SET amount=amount+100;
</pre>

<p>Таблица <code>february</code> в базе данных <code>sales</code>
на ведомом устройстве изменена <a href="sql.htm#update"><code>UPDATE</code>
</a>, это происходит безотносительно
<a href="sql.htm#use"><code>USE</code></a>. Однако, выполнение следующих
запросов на ведущем устройстве не имеет никакого эффекта на ведомое
устройство, используя основанную на строке репликацию и
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db=sales</code></a>:
<pre>
USE prices;
UPDATE prices.march SET amount=amount-25;
</pre>

<p>Даже если запрос <code>USE prices</code> был изменен на
<code>USE sales</code>, <a href="sql.htm#update"><code>UPDATE</code></a>
все еще не скопировались бы.</p>

<p>Другое важное различие того, как
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a> обработана в основанной на запросе репликации в
противоположность основанной на строке репликации, происходит относительно
запросов, которые относятся к многим базам данных. Предположите, что ведомое
устройство запущено с <a href="#option_mysqld_replicate-do-db">
<code>--replicate-do-db=db1</code></a>
и следующие запросы выполнены на ведущем устройстве:
<pre>
USE db1;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre>

<p>Если Вы используете основанную на запросе репликацию, то обе таблицы
обновлены на ведомом устройстве. Однако, используя основанную на строке
репликацию, только <code>table1</code> затронута на ведомом устройстве, с тех
пор <code>table2</code> находится в другой базе данных, <code>table2</code>
на ведомом устройстве не изменена <a href="sql.htm#update"><code>UPDATE
</code></a>. Теперь предположите, что вместо <code>USE db1</code>
выполнен <code>USE db4</code>:
<pre>
USE db4;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre>

<p>В этом случае <a href="sql.htm#update"><code>UPDATE</code></a>
не имел бы никакого эффекта на ведомое устройство, используя основанную на
запросе репликацию. Однако, если Вы используете основанную
на строке репликацию, <a href="sql.htm#update"><code>UPDATE</code></a>
изменил бы <code>table1</code> на ведомом устройстве, но не
<code>table2</code>. Другими словами, только таблицы в базе данных, названной
<a href="#option_mysqld_replicate-do-db"><code>--replicate-do-db
</code></a> изменены, и выбор базы данных значения по умолчанию не имеет
никакого эффекта на это поведение.</p>

<p>Если Вы нуждаетесь в обновлениях нескольких баз данных, используйте
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table=<em><code>db_name</code></em>.%</code></a>. См.
<a href="#replication-rules">раздел 19.2.5</a>.</p>

<p>Эта опция затрагивает репликацию в той же самой манере, как
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db</code>
</a> журналирование и эффекты формата репликации как из формата
журналирования в <a href="#option_mysqld_binlog-do-db"><code>
--binlog-do-db</code></a>.</p>

<p>Эта опция не имеет никакого эффекта на
<a href="sql.htm#commit"><code>BEGIN</code></a>,
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.</p></li>

<li><a name="option_mysqld_replicate-ignore-db"></a>
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db=<em><code>db_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-ignore-db=name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Создает фильтр репликации, используя название базы данных. Такие фильтры
могут также быть созданы, используя
<a href="sql.htm#change-replication-filter"><code>CHANGE
REPLICATION FILTER REPLICATE_IGNORE_DB</code></a>. Как с
<a href="#option_mysqld_replicate-do-db"><code>--replicate-do-db
</code></a>, точный эффект этой фильтрации зависит от формата репликации.</p>

<p><b>Основанная на запросе репликация. </b>
Говорит ведомому потоку SQL не копировать любой запрос где база данных по
умолчанию (то есть, выбранная <a href="sql.htm#use"><code>USE</code></a>)
<em><code>db_name</code></em>.</p>

<p><b>Основанная на строке репликация. </b>Говорит ведомому потоку SQL не
обновлять любые таблицы в базе данных <em><code>db_name</code></em>. База
данных по умолчанию не имеет никакого эффекта.</p>

<p>Используя основанную на запросе репликацию следующий пример не работает,
как Вы могли бы ожидать. Предположите, что ведомое устройство запущено с
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db=sales</code></a>
и Вы делаете следующие запросы на ведущем устройстве:
<pre>
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre>

<p><a href="sql.htm#update"><code>UPDATE</code></a>
копируется в таком случае потому, что
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a> применяется только к базе данных по
умолчанию (определенной <a href="sql.htm#use"><code>USE</code></a>).
Поскольку база данных <code>sales</code> была определена явно в запросе,
запрос не фильтровался. Однако, используя основанную на строке репликацию
запросы <a href="sql.htm#update"><code>UPDATE</code></a>
<span><em>не</em></span> размножены к ведомому устройству, и копия
ведомого устройства таблицы <code>sales.january</code> неизменна, в этом
случае <a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db=sales</code></a> причина того, что <span><em>все</em>
</span> изменения, произведенные в таблицах в копии базы данных ведущего
устройства <code>sales</code> будут проигнорированы ведомым устройством.</p>

<p>Чтобы определить больше, чем одну базу данных, чтобы проигнорировать,
используйте эту опцию многократно, однажды для каждой базы данных.
Поскольку имена базы данных могут содержать запятые, если Вы будете
поставлять список разделенных запятой значений, то список будет обработан как
название единственной базы данных.</p>

<p>Вы не должны использовать эту опцию, если Вы используете обновления
между базами данных, см. <a href="#replication-rules">раздел
19.2.5</a>.</p>

<p>Если Вы нуждаетесь в обновлениях между базами данных, примените
<a href="#option_mysqld_replicate-wild-ignore-table"><code>
--replicate-wild-ignore-table=<em><code>db_name</code></em>.%</code></a>,
см. <a href="#replication-rules">раздел 19.2.5</a>.</p>

<p>Эта опция не имеет никакого эффекта на
<a href="sql.htm#commit"><code>BEGIN</code></a>,
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.</p></li>

<li><a name="option_mysqld_replicate-do-table"></a>
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table=<em><code>db_name.tbl_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-do-table=name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Создает фильтр репликации, говоря ведомому потоку SQL ограничить
репликацию данной таблицей. Чтобы определить больше, чем одну таблицу,
используйте эту опцию многократно, однажды для каждой таблицы. Это работает
на обновлениях между базами данных и на обновлениях базы данных по умолчанию,
в отличие от <a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a>. См.
<a href="#replication-rules">раздел 19.2.5</a>.</p>

<p>Вы можете также создать такой фильтр, выполняя
<a href="sql.htm#change-replication-filter"><code>CHANGE
REPLICATION FILTER REPLICATE_DO_TABLE</code></a>.</p>

<p>Эта опция затрагивает только запросы, которые относятся к таблицам.
Это не затрагивает запросы, которые применяются только к другим объектам базы
данных, таким как сохраненные подпрограммы.
Чтобы фильтровать запросы, воздействующие на сохраненные подпрограммы,
используйте одну или больше опций <code>--replicate-*-db</code>.</li>

<li><a name="option_mysqld_replicate-ignore-table"></a>
<a href="#option_mysqld_replicate-ignore-table"><code>
--replicate-ignore-table=<em><code>db_name.tbl_name</code></em>
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-ignore-table=name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Создает фильтр репликации, говоря ведомому потоку SQL не копировать любой
запрос, который обновляет указанную таблицу, даже если какие-либо другие
таблицы могли бы быть обновлены тем же самым запросом. Чтобы определить
больше, чем одну таблицу, чтобы проигнорировать, используйте эту опцию
многократно, однажды для каждой таблицы. Это работает на обновления между
базами данных, в отличие от
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a>. См.
<a href="#replication-rules">раздел 19.2.5</a>.</p>

<p>Вы можете также создать такой фильтр с помощью
<a href="sql.htm#change-replication-filter"><code>CHANGE
REPLICATION FILTER REPLICATE_IGNORE_TABLE</code></a>.</p>

<p>Эта опция затрагивает только запросы, которые относятся к таблицам. Это не
затрагивает запросы, которые применяются только к другим объектам базы
данных, таким как сохраненные подпрограммы. Чтобы фильтровать запросы,
воздействующие на сохраненные подпрограммы, используйте одну или больше опций
<code>--replicate-*-db</code>.</li>

<li><a name="option_mysqld_replicate-rewrite-db"></a>
<a href="#option_mysqld_replicate-rewrite-db"><code>
--replicate-rewrite-db=<em><code>from_name</code></em>-&gt;<em><code>to_name
</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-rewrite-db=old_name-&gt;new_name
</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Говорит ведомому устройству создавать фильтр репликации, который
преобразовывает базу данных по умолчанию (то есть, выбранную
<a href="sql.htm#use"><code>USE</code></a>) в
<em><code>to_name</code></em>, если это было
<em><code>from_name</code></em> на ведущем устройстве.
Только запросы, вовлекающие таблицы, затронуты (не такие запросы, как
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>,
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a> и
<a href="sql.htm#alter-database"><code>ALTER DATABASE</code></a>),
и только если <em><code>from_name</code></em> база данных по умолчанию на
ведущем устройстве. Чтобы определить многократные перезаписи, используйте эту
опцию многократно. Сервер использует первое значение
<em><code>from_name</code></em>, которое соответствует. Перевод имени базы
данных сделан <span><em>перед</em></span>
проверкой правила <code>--replicate-*</code>.</p>

<p>Вы можете также создать такой фильтр командой
<a href="sql.htm#change-replication-filter"><code>CHANGE
REPLICATION FILTER REPLICATE_REWRITE_DB</code></a>.</p>

<p>Запросы, в которых имена таблиц квалифицированы с именами базы данных,
используя эту опцию, не работают с опциями фильтрации репликации на уровне
таблицы, например, <a href="#option_mysqld_replicate-do-table">
<code>--replicate-do-table</code></a>. Предположите, что нам назвали базу
данных <code>a</code> на ведущем устройстве и <code>b</code>
на ведомом устройстве, каждая содержит таблицу <code>t</code>, и запустили
ведущее устройство с <code>--replicate-rewrite-db='a-&gt;b'</code>.
В более позднем моменте времени мы выполняем
<a href="sql.htm#delete"><code>DELETE FROM a.t</code></a>.
В этом случае нет соответствующих правил фильтрации по
причинам, показанным здесь:</p>

<ol type="1"><li><p><code>--replicate-do-table=a.t</code>
не работает, потому что у ведомого устройства есть таблица
<code>t</code> в <code>b</code>.</li>
<li><code>--replicate-do-table=b.t</code> не соответствует
оригинальному запросу и проигнорировано.</li>

<li><code>--replicate-do-table=*.t</code> обработан тождественно к
<code>--replicate-do-table=a.t</code> и таким образом не работает также.
</p></li></ol>

<p>Точно так же опция <code>--replication-rewrite-db</code>
не работает с обновлениями между базами данных.</p>
<p>Если Вы используете эту опцию на командной строке и символ
<code>&gt;</code> является специальным для Вашего интерпретаторы команд,
заключите значение опции в кавычки. Например:
<pre>
shell&gt; mysqld --replicate-rewrite-db="<em><code>olddb</code></em>-&gt;<em><code>newdb</code></em>"
</pre></li>

<li><a name="option_mysqld_replicate-same-server-id"></a>
<a href="#option_mysqld_replicate-same-server-id"><code>
--replicate-same-server-id</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-same-server-id</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Применяется на ведомых серверах. Обычно Вы должны использовать настройку
по умолчанию 0, чтобы предотвратить бесконечные петли, вызванные круговой
репликацией. Если установлено в 1, ведомое устройство не пропускает события,
имеющие его собственный ID сервера. Обычно это полезно только в редких
конфигурациях. Не может быть установлен в 1, если используется
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a>. По умолчанию ведомый поток ввода/вывода не
пишет двоичные события журнала журналу реле, если у них есть ID сервера
ведомого устройства (эта оптимизация помогает сохранить диск).
Если Вы хотите использовать
<a href="#option_mysqld_replicate-same-server-id"><code>
--replicate-same-server-id</code></a>,
убедитесь, что запустили ведомое устройство с этой опции прежде, чем Вы
заставите ведомое устройство читать свои собственные события, которые Вы
хотите, чтобы ведомый поток SQL запустил.</li>

<li><a name="option_mysqld_replicate-wild-do-table"></a>
<a href="#option_mysqld_replicate-wild-do-table">
<code>--replicate-wild-do-table=<em><code>db_name.tbl_name</code></em>
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-wild-do-table=name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Создает фильтр репликации, говоря ведомому потоку ограничить
репликацию запросами, где любая из обновленных таблиц соответствует указанной
базе данных и образцам имени таблицы. Образцы могут содержать <code>%</code>
и <code>_</code>, у которых есть то же самое значение, что касается
оператора <a href="funct.htm#operator_like"><code>LIKE</code></a>.
Чтобы определить больше, чем одну таблицу, используйте эту опцию многократно,
однажды для каждой таблицы. Это работает на обновлениях между базами данных.
См. <a href="#replication-rules">раздел 19.2.5</a>.</p>

<p>Вы можете также создать такой фильтр через
<a href="sql.htm#change-replication-filter"><code>CHANGE
REPLICATION FILTER REPLICATE_WILD_DO_TABLE</code></a>.</p>

<p>Эта опция относится к таблицам, представлениям и триггерам.
Это не относится к хранимым процедурам и функциям или событиям. Чтобы
фильтровать запросы, воздействующие на последние объекты, используйте одну
или больше опций <code>--replicate-*-db</code>.
</p>

<p>Пример: <a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table=foo%.bar%</code></a> копирует только обновления,
которые используют таблицу, где имя базы данных начинается с <code>foo</code>
и имя таблицы начинается с <code>bar</code>.</p>

<p>Если образец имени таблицы <code>%</code>, это соответствует любому
имени таблицы и опция также относится к запросам на уровне базы данных
(<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>,
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a> и
<a href="sql.htm#alter-database"><code>ALTER DATABASE</code></a>).
Например, если Вы используете
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table=foo%.%</code></a>, запросы на уровне базы данных
копируются, если имя базы данных соответствует образцу <code>foo%</code>.</p>

<p>Чтобы включать буквальные подстановочные символы в имя базы данных или
образцы имени таблицы, выйдите из них с наклонной чертой влево. Например,
чтобы копировать все таблицы базы данных, которую называют
<code>my_own%db</code>, но не копировать таблицы от
базы данных <code>my1ownAABCdb</code>, Вы должны экранировать
<code>_</code> и <code>%</code>:
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table=my\_own\%db</code></a>.
Если Вы используете опцию в командной строке, Вы, возможно, должны были бы
удвоить наклонные черты влево или заключить значение опции в кавычки, в
зависимости от Вашего интерпретатора команды. Например, с оболочкой
<span><strong>bash</strong></span>, Вы должны были бы ввести
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table=my\\_own\\%db</code></a>.</li>

<li><a name="option_mysqld_replicate-wild-ignore-table"></a>
<a href="#option_mysqld_replicate-wild-ignore-table">
<code>--replicate-wild-ignore-table=<em><code>db_name.tbl_name</code></em>
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--replicate-wild-ignore-table=name</code>
</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Создает фильтр репликации, который препятствует ведомому потоку
копировать запрос, в котором любая таблица соответствует данному
подстановочному образцу. Чтобы определить больше, чем одну таблицу, чтобы
проигнорировать, используйте эту опцию многократно, однажды для каждой
таблицы. Это работает на обновлениях между базами данных. См.
<a href="#replication-rules">раздел 19.2.5</a>.</p>

<p>Вы можете также создать такой фильтр через
<a href="sql.htm#change-replication-filter"><code>CHANGE
REPLICATION FILTER REPLICATE_WILD_IGNORE_TABLE</code></a>.</p>

<p>Пример: <a href="#option_mysqld_replicate-wild-ignore-table">
<code>--replicate-wild-ignore-table=foo%.bar%</code></a>
не копирует обновления, которые используют таблицу, где имя базы данных
начинается с <code>foo</code> и имя таблицы начинается с <code>bar</code>.
</p>

<p>Для информации о том, как соответствие работает, см. описание опции
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a>.
Правила для включения буквальных подстановочных символов в значении опции
являются теми же самыми, что касается
<a href="#option_mysqld_replicate-wild-ignore-table"><code>
--replicate-wild-ignore-table</code></a>.</li>

<li><a name="option_mysqld_report-host"></a>
<a href="#option_mysqld_report-host"><code>
--report-host=<em><code>host_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--report-host=host_name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_report_host">report_host</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Имя хоста или IP-адрес ведомого устройства, о котором сообщат
ведущему устройству во время ведомой регистрации. Это значение появляется
в выводе <a href="sql.htm#show-slave-hosts"><code>SHOW SLAVE HOSTS</code></a>
на главном сервере. Оставьте значение неопределенным, если Вы не хотите,
чтобы ведомое устройство зарегистрировало себя в ведущем устройстве.
</p>

<p>Недостаточно для ведущего устройства просто считать IP-адрес ведомого
устройства от TCP/IP после того, как ведомое устройство соединяется. Из-за
NAT и других проблем маршрутизации, тот IP, возможно, недопустим для того,
чтобы соединиться с ведомым устройством от ведущего устройства
или других узлов.</p></li>

<li><a name="option_mysqld_report-password"></a>
<a href="#option_mysqld_report-password"><code>
--report-password=<em><code>password</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--report-password=name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_report_password">report_password</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Пароль учетной записи ведомого устройства, о котором сообщат
ведущему устройству во время ведомой регистрации. Это значение появляется
в выводе <a href="sql.htm#show-slave-hosts"><code>SHOW SLAVE HOSTS</code></a>
на главном сервере, если дана опция
<a href="#option_mysqld_show-slave-auth-info"><code>
--show-slave-auth-info</code></a>.</p>

<p>Хотя название этой опции могло бы подразумевать иное,
<code>--report-password</code> не соединен с пользовательской системой
привилегии MySQL и также не обязательно тот же самый, как пароль для учетной
записи пользователя репликации MySQL.</li>

<li><a name="option_mysqld_report-port"></a>
<a href="#option_mysqld_report-port"><code>
--report-port=<em><code>slave_port_num</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--report-port=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_report_port">report_port</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>[slave_port]</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>65535</code></td></tr></tbody></table>

<p>Номер порта TCP/IP для того, чтобы соединиться с ведомым устройством,
сообщен ведущему устройству во время ведомой регистрации. Установите это,
только если ведомое устройство слушает на порту не по умолчанию или если у
Вас есть специальный туннель от ведущего устройства или других клиентов к
ведомому устройству. Если Вы не уверены, не используйте эту опцию.</p>

<p>Значение по умолчанию для этой опции номер
порта, фактически используемый ведомым устройством (Bug #13333431).
Это также значение по умолчанию, выведенное на экран
<a href="sql.htm#show-slave-hosts"><code>SHOW SLAVE HOSTS</code></a>.</li>

<li><a name="option_mysqld_report-user"></a>
<a href="#option_mysqld_report-user"><code>
--report-user=<em><code>user_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--report-user=name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_report_user">report_user</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Имя пользователя учетной записи ведомого устройства, о котором сообщат
ведущему устройству во время ведомой регистрации. Это значение появляется в
выводе <a href="sql.htm#show-slave-hosts"><code>SHOW SLAVE HOSTS</code></a>
на главном сервере, если задана опция
<a href="#option_mysqld_show-slave-auth-info"><code>
--show-slave-auth-info</code></a>.</p>

<p>Хотя название этой опции могло бы подразумевать иное,
<code>--report-user</code> не соединен с пользовательской системой привилегии
MySQL и не обязательно то же самое, как название учетной записи
пользователя репликации MySQL.</li>

<li><a name="option_mysqld_show-slave-auth-info"></a>
<a href="#option_mysqld_show-slave-auth-info"><code>
--show-slave-auth-info</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--show-slave-auth-info</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Вывести на экран ведомые имена пользователя и пароли в выводе
<a href="sql.htm#show-slave-hosts"><code>SHOW SLAVE HOSTS</code></a>
на главном сервере для ведомых устройств, запущенных с опциями
<a href="#option_mysqld_report-user"><code>--report-user</code>
</a> и <a href="#option_mysqld_report-password"><code>
--report-password</code></a>.</li>

<li><a name="option_mysqld_slave-checkpoint-group"></a>
<a href="#option_mysqld_slave-checkpoint-group"><code>
--slave-checkpoint-group=<em><code>#</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-checkpoint-group=#</code></td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>512</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>32</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>524280</code></td></tr>
<tr><td scope="row"><span><strong>Block Size</strong></span></td>
<td colspan="2"><code>8</code></td></tr></tbody></table>

<p>Устанавливает максимальное количество транзакций, которые могут быть
обработаны мультипоточным ведомым устройством прежде, чем вызовут работу
контрольной точки, чтобы обновить ее состояние как показано
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.
Установка этой опции не имеет никакого эффекта на ведомые устройства, для
которых не включена мультипоточная обработка.</p>

<p>Эта опция работает в комбинации с
<a href="#option_mysqld_slave-checkpoint-period"><code>
--slave-checkpoint-period</code></a>
таким способом, которым, когда любой предел превышен,
контрольная точка выполнена и счетчики, отслеживающие число транзакций и
время, начиная с последней контрольной точки, сброшены.</p>

<p>Минимальное позволенное значение для этой опции 32, если сервер не был
создан, используя <a href="install.htm#option_cmake_with_debug"><code>
-DWITH_DEBUG</code></a>, когда минимальное значение 1. Действующее значение
всегда кратно числу 8, Вы можете установить это в значение, которое не
является таким кратным числом, но сервер округляет это в меньшую сторону к
следующему кратному 8 прежде, чем сохранить значение.
<span><em>Исключение</em></span>: Никакое округление не выполнено сервером
для отладки. Независимо от того, как сервер был создан, значение по умолчанию
512, и максимальное позволенное значение 524280.</li>

<li><a name="option_mysqld_slave-checkpoint-period"></a>
<a href="#option_mysqld_slave-checkpoint-period"><code>
--slave-checkpoint-period=<em><code>#</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-checkpoint-period=#</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>300</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4G</code></td></tr></tbody></table>

<p>Устанавливает максимальное время (в миллисекундах), которому позволяют
пройти прежде, чем вызовут работу контрольной точки
, чтобы обновить состояние мультипоточного ведомого устройства как показано
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.
Установка этой опции не имеет никакого эффекта на ведомые устройства, для
которых не включена мультипоточная обработка.</p>

<p>Эта опция работает в комбинации с
<a href="#option_mysqld_slave-checkpoint-group"><code>
--slave-checkpoint-group</code></a>
таким способом, которым, когда любой предел превышен,
контрольная точка выполнена и счетчики, отслеживающие число транзакций и
время, начиная с последней контрольной точки, сброшены.</p>

<p>Минимальное позволенное значение для этой опции 1, если сервер не был
создан, используя <a href="install.htm#option_cmake_with_debug"><code>
-DWITH_DEBUG</code></a>, когда минимальное значение 0. Независимо от того,
как был создан сервер, значение по умолчанию 300 и максимальное
возможное значение 4294967296 (4GB).</li>

<li><a name="option_mysqld_slave-parallel-workers"></a>
<a href="#option_mysqld_slave-parallel-workers"><code>
--slave-parallel-workers</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-parallel-workers=#</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr></tbody></table>

<p>Определяет число применяющих потоков ведомого устройства
для того, чтобы выполнить транзакции репликации параллельно.
Установка этой переменной к числу, больше чем 0, создает мультипоточное
ведомое устройство с этим числом потоков. Когда установлено в 0 (значение по
умолчанию) параллельное выполнение отключено, и ведомое устройство
использует единственный поток.</p>

<p>Мультипоточное ведомое устройство обеспечивает параллельное выполнение при
использовании потока координатора и числа потоков применения,
сконфигурированных этой опцией. Способ, которым транзакции распределены среди
потоков, сконфигурирован <a href="#option_mysqld_slave-parallel-type">
<code>--slave-parallel-type</code></a>. Для получения дополнительной
информации о мультипоточных ведомых устройствах см.
<a href="#sysvar_slave_parallel_workers"><code>
slave-parallel-workers</code></a>.</li>

<li><a name="option_mysqld_slave-pending-jobs-size-max"></a>
<a href="#option_mysqld_slave-pending-jobs-size-max"><code>
--slave-pending-jobs-size-max=<em><code>#</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-pending-jobs-size-max=#</code></td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>16M</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18EB</code></td></tr>
<tr><td scope="row"><span><strong>Block Size</strong></span></td>
<td colspan="2"><code>1024</code></td></tr></tbody></table>

<p>Для мультипоточных ведомых устройств эта опция устанавливает
максимальный объем памяти (в байтах) доступный очередям, хранящим еще не
примененные события. Установка этой опции не имеет никакого эффекта на
ведомые устройства, для которых не включена мультипоточная обработка.</p>

<p>Минимальное возможное значение для этой опции 1024,
значение по умолчанию составляет 16 МБ. Максимальное возможное значение
18446744073709551615 (16 exabytes). Значения, которые не являются точно
кратными 1024, округлены в меньшую сторону к следующему самому большому
кратному 1024 числу до того, как будут сохранены.</p>

<p>Значение для этой опции не должно быть меньше, чем значение ведущего
устройства для <a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a>, иначе очередь может стать полной, в то время
как там остаются события, прибывающие от ведущего устройства,
чтобы быть обработанными.</p></li>

<li><a name="option_mysqld_skip-slave-start"></a>
<a href="#option_mysqld_skip-slave-start"><code>
--skip-slave-start</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--skip-slave-start</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Говорит ведомому серверу не запускать ведомые потоки, когда сервер
запускается. Чтобы запустить потоки позже, используйте
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>.</li>

<li><a name="option_mysqld_slave_compressed_protocol"></a>
<a href="#sysvar_slave_compressed_protocol"><code>
--slave_compressed_protocol={0|1}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave_compressed_protocol</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_compressed_protocol">
slave_compressed_protocol</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Если эта опция установлена в 1, используйте сжатие для
ведомого/основного протокола если ведомое и основное устройства
его понимают. Значение по умолчанию 0 (никакого сжатия).</li>

<li><a name="option_mysqld_slave-load-tmpdir"></a>
<a href="#option_mysqld_slave-load-tmpdir"><code>
--slave-load-tmpdir=<em><code>dir_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-load-tmpdir=dir_name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_load_tmpdir">slave_load_tmpdir</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>
directory name</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>/tmp</code></td></tr></tbody></table>

<p>Название каталога, где ведомое устройство создает временные файлы.
Эта опция по умолчанию равна значению
<a href="server.htm#sysvar_tmpdir"><code>tmpdir</code></a>.
Когда ведомый поток SQL копирует <a href="sql.htm#load-data"><code>LOAD DATA
INFILE</code></a>, это извлекает файл, который будет загружен из журнала реле
во временные файлы, и затем загружает их в таблицу. Если файл, загруженный на
ведущем устройстве, огромен, временные файлы на ведомом устройстве также
огромны. Поэтому могло бы быть желательно использовать эту опцию, чтобы
сказать ведомому устройству помещать временные файлы в каталог, расположенный
в некоторой файловой системе, у которой есть много свободного места.
В этом случае журналы реле также огромны, таким образом, Вы могли бы также
хотеть использовать <a href="#option_mysqld_relay-log"><code>
--relay-log</code></a>, чтобы поместить журналы реле туда, где есть место.
</p>

<p>Каталог, определенный этой опцией, должен быть расположен в основанной
на диске файловой системе (не основанной на памяти файловой системе),
потому что временные файлы для копирования
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>
должны пережить машинные перезапуски. Каталог также не должен быть тем,
который очищен операционной системой во время системного процесса запуска.
</li>

<li><a name="option_mysqld_slave-max-allowed-packet"></a>
<a href="#option_mysqld_slave-max-allowed-packet"><code>
slave-max-allowed-packet=<em><code>bytes</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-max-allowed-packet=#</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr></tbody></table>

<p>Эта опция устанавливает максимальный пакетный размер в байтах
для ведомого SQL и потоков ввода/вывода, чтобы большие обновления, используя
основанную на строке репликацию не заставили репликацию терпеть неудачу,
потому что обновление превысило
<a href="server.htm#sysvar_max_allowed_packet"><code>max_allowed_packet
</code></a> (Bug #12400221, Bug #60926).</p>

<p>Соответствующая переменная сервера
<a href="#sysvar_slave_max_allowed_packet"><code>
slave_max_allowed_packet</code></a>
всегда имеет значение, которое является положительным целым числом, кратным
1024, если Вы устанавливаете это в некоторое значение, которое не является
таким кратным числом, значение автоматически округлено в меньшую сторону к
следующему самому большому числу, кратному 1024. Например, если Вы запускаете
сервер с <code>--slave-max-allowed-packet=10000</code>,
используемое значение 9216, установка 0 заставляет использоваться 1024.
Предупреждение выпущено в таких случаях.</p>
<p>Максимум (и значение по умолчанию)
значение 1073741824 (1 GB), минимум 1024.</li>

<li><a name="option_mysqld_slave-net-timeout"></a>
<a href="#option_mysqld_slave-net-timeout"><code>
--slave-net-timeout=<em><code>seconds</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-net-timeout=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_net_timeout">slave_net_timeout</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>3600</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>60</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr></tbody></table>

<p>Число секунд, чтобы ждать большего количества данных от ведущего
устройства перед тем, как ведомое устройство считает соединение сломанным,
прерывает чтение и пытается повторно соединиться. Первая повторная попытка
происходит немедленно после тайм-аута. Интервалом между повторениями
управляет опция <code>MASTER_CONNECT_RETRY</code> в
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>,
число попыток пересоединения ограничено
<a href="#option_mysqld_master-retry-count"><code>
--master-retry-count</code></a>. Значение по умолчанию составляет 60
секунд (одна минута).</li>

<li><a name="option_mysqld_slave-parallel-type"></a>
<a href="#option_mysqld_slave-parallel-type"><code>
--slave-parallel-type=<em><code>type</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-parallel-type=type</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>DATABASE</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>DATABASE</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>LOGICAL_CLOCK</code></td>
</tr></tbody></table>

<p>Используя мультипоточное ведомое устройство
(<a href="#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> больше 0),
эта опция определяет, какая политика решает, которым транзакциям позволяют
выполниться параллельно на ведомом устройстве. Возможные значения:</p>

<ul><li><p><code>DATABASE</code>: транзакции, которые обновляют различные
базы данных, применены параллельно. Это значение является соответствующим
только, если данные разделены на многие базы данных, которые обновляются
независимо и одновременно на ведущем устройстве. Рекомендуется только, если
нет никаких ограничений между базами данных, ограничения как таковые могут
быть нарушены на ведомом устройстве.</li>

<li><code>LOGICAL_CLOCK</code>: транзакции, которые являются частью той же
самой двоичной группы журнала на ведущем устройстве, применены параллельно на
ведомом устройстве. Нет никаких ограничений базы данных, и данные не должны
быть разделены на много баз данных.</p></li></ul>

<p>Независимо от значения этой переменной нет никакой специальной
конфигурации, требуемой на ведущем устройстве. Когда
<a href="#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order=1</code></a>, Вы можете использовать только
<code>LOGICAL_CLOCK</code>. Если Ваша топология репликации использует
многократные уровни ведомых устройств, <code>LOGICAL_CLOCK</code>
может достигнуть меньшей параллельности для каждого уровня.</li>

<li><a name="option_mysqld_slave-rows-search-algorithms"></a>
<a href="#option_mysqld_slave-rows-search-algorithms"><code>
slave-rows-search-algorithms=<em><code>list</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-rows-search-algorithms=list</code>
</td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>set</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>TABLE_SCAN,INDEX_SCAN</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>
TABLE_SCAN,INDEX_SCAN</code></td></tr>
<tr><td scope="row" colspan="2"><code>INDEX_SCAN,HASH_SCAN</code></td></tr>
<tr><td scope="row" colspan="2"><code>TABLE_SCAN,HASH_SCAN</code></td></tr>
<tr><td scope="row" colspan="2"><code>TABLE_SCAN,INDEX_SCAN,HASH_SCAN</code>
(equivalent to INDEX_SCAN,HASH_SCAN)</td></tr></tbody></table>

<p>Готовя пакеты строк для основанного на строке журналирования и репликации,
эта опция управляет, как строки разыскиваются, то есть, используется ли
хеширование для поисков, используя основной или уникальный ключ, некоторый
другой ключ или никакой ключ вообще. Эта опция берет список разделенных
запятой любых 2 (или возможно 3) значений из списка
<code>INDEX_SCAN</code>, <code>TABLE_SCAN</code>, <code>HASH_SCAN</code>.
Список не должен быть заключен в кавычки, но не должен содержать пробелы.
Возможные комбинации (списки) и их эффекты показывают в следующей таблице:
</p>

<table border="1">
<thead><tr><th scope="col">Используемый индекс/значение опции</th>
<th scope="col"><code>INDEX_SCAN,HASH_SCAN</code> или
<code>INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code></th>
<th scope="col"><code>INDEX_SCAN,TABLE_SCAN</code></th>
<th scope="col"><code>TABLE_SCAN,HASH_SCAN</code></th></tr></thead>
<tbody><tr><td scope="row"><span><em>Первичный или уникальный ключ</em>
</span>.</td><td>Просмотр индекса.</td><td>Просмотр индекса.</td>
<td>Просмотр хеш-индекса.</td></tr>
<tr><td scope="row"><span><em>(Другой) ключ</em></span></td>
<td>Просмотр хеш-индекса.</td><td>Просмотр индекса.</td>
<td>Просмотр хеш-индекса.</td></tr>
<tr><td scope="row"><span><em>Индекс не применен.</em></span></td>
<td>Просмотр хеша.</td><td>Сканирование таблицы.</td>
<td>Просмотр хеша.</td></tr></tbody></table>

<p>Порядок, в котором алгоритмы определены в списке, не имеет никакого
значения в порядке, в котором они выведены на экран
<a href="sql.htm#select"><code>SELECT</code></a> или
<a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a>
(который является тем же самым, как используемый в показанной таблице).
Значение по умолчанию <code>TABLE_SCAN,INDEX_SCAN</code>,
что означает, что все поиски, которые могут использовать индекс,
действительно используют их, и поиски без индексов
используют сканирование таблицы.</p>

<p>Указание <code>INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code> аналогично
<code>INDEX_SCAN,HASH_SCAN</code>. Чтобы использовать хеширование для любых
поисков, которые не используют основной или уникальный ключ, устанавливайте
эту опцию в <code>INDEX_SCAN,HASH_SCAN</code>. Чтобы вызвать хеширование для
<span><em>всех</em></span> поисков, установите это в
<code>TABLE_SCAN,HASH_SCAN</code>.</p>

<p>Есть исполнительное преимущество для <code>INDEX_SCAN</code> и
<code>HASH_SCAN</code> только, если события строки являются достаточно
большими. Размер событий строки сконфигурирован, используя
<code>--binlog-row-event-max-size</code>. Например, предположите, что
<a href="sql.htm#delete"><code>DELETE</code></a>,
который удаляет 25000 строк, производит большое событие
<code>Delete_row_event</code>. В этом случае если
<a href="#sysvar_slave_rows_search_algorithms"><code>
slave_rows_search_algorithms</code></a> установлен в
<code>INDEX_SCAN</code> или <code>HASH_SCAN</code> есть прибавка в скорости.
Однако, если есть 25000 запросов <a href="sql.htm#delete"><code>DELETE</code>
</a> и каждый представлен отдельным событием, тогда установка
<a href="#sysvar_slave_rows_search_algorithms"><code>
slave_rows_search_algorithms</code></a> в <code>INDEX_SCAN</code> или
<code>HASH_SCAN</code> не обеспечивает исполнительного ускорения, запуская
эти отдельные события.</p></li>

<li><a name="option_mysqld_slave-skip-errors"></a>
<a href="#option_mysqld_slave-skip-errors"><code>
--slave-skip-errors=[<em><code>err_code1</code></em>,<em><code>
err_code2</code></em>,...|all|ddl_exist_errors]</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-skip-errors=name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_skip_errors">slave_skip_errors</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>[list of error codes]</code></td></tr>
<tr><td scope="row" colspan="2"><code>all</code></td></tr>
<tr><td scope="row" colspan="2"><code>ddl_exist_errors</code></td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>[list of error codes]</code></td></tr>
<tr><td scope="row" colspan="2"><code>all</code></td></tr>
<tr><td scope="row" colspan="2"><code>ddl_exist_errors</code></td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>[list of error codes]</code></td></tr>
<tr><td scope="row" colspan="2"><code>all</code></td></tr>
<tr><td scope="row" colspan="2"><code>ddl_exist_errors</code>
</td></tr></tbody></table>

<p>Обычно репликация останавливается, когда ошибка происходит на
ведомом устройстве, что дает Вам возможность решить несогласованность в
данных вручную. Эта опция заставляет ведомый поток SQL продолжать репликацию,
когда запрос возвращает любую из ошибок, перечисленных в значении опции.
</p>

<p>Не используйте эту опцию, если Вы полностью не понимаете, почему Вы
получаете ошибки. Если нет никаких ошибок в Вашей установке репликации и
программах клиента и никаких ошибок в MySQL непосредственно, ошибка, которая
останавливает репликацию, никогда не должна происходить. Неразборчивое
использование этой опции приводит к ведомым устройствам, безнадежно вышедшими
из синхронизации с ведущим устройством, а Вы понятия не имеете,
почему это произошло.</p>

<p>Для кодов ошибки Вы должны использовать числа, обеспеченные сообщением об
ошибке в Вашем ведомом журнале ошибок и в выводе
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.
<a href="error.htm">Приложение B</a> перечисляет коды ошибок сервера.</p>

<p>Вы можете также (но не должны) использовать очень нерекомендуемое значение
<code>all</code>, чтобы заставить ведомое устройство игнорировать все
сообщения об ошибках и продолжать работу независимо от того, что происходит.
Само собой разумеется, если Вы используете <code>all</code>,
нет никаких гарантий относительно целостности Ваших данных. Пожалуйста, не
жалуйтесь в этом случае, если данные ведомого устройства близко не похожи на
то, что находится на ведущем устройстве.
<span><em>Вы были предупреждены</em></span>.</p>

<p>MySQL 8.0 понимает дополнительное значение
<code>ddl_exist_errors</code>, которое эквивалентно списку кодов ошибки
<code>1007,1008,1050,1051,1054,1060,1061,1068,1094,1146</code>.</p>

<p>Примеры:
<pre>
--slave-skip-errors=1062,1053
--slave-skip-errors=all
--slave-skip-errors=ddl_exist_errors
</pre></li>

<li><a name="option_mysqld_slave-sql-verify-checksum"></a>
<a href="#option_mysqld_slave-sql-verify-checksum"><code>
--slave-sql-verify-checksum={0|1}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-sql-verify-checksum=value</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>0</code></td>
</tr><tr><td scope="row" colspan="2"><code>1</code></td></tr></tbody></table>

<p>Когда эта опция включена, ведомое устройство исследует контрольные суммы,
считанные из журнала реле, в случае несоответствия встает с ошибкой.
Отключена по умолчанию.</p></li></ul>

<p>Следующие опции используются внутренне испытательным набором MySQL для
тестирования репликации и отладки. Они не предназначены для
использования в производственной установке.</p>

<ul><li><p><a name="option_mysqld_abort-slave-event-count"></a>
<a href="#option_mysqld_abort-slave-event-count"><code>
--abort-slave-event-count</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--abort-slave-event-count=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr></tbody></table>

<p>Когда эта опция установлена в некоторое положительное целое число
<em><code>value</code></em> не 0 (по умолчанию)
это затрагивает поведение репликации следующим образом: после того, как
ведомый поток SQL запустился, <em><code>value</code></em>
событиям журнала разрешают быть запущенными,
после этого ведомый поток SQL больше не получает события, как если бы сетевое
соединение от ведущего устройства было отключено.
Ведомый поток продолжает работать, и вывод
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
покажет <code>Yes</code> в обоих столбцах
<code>Slave_IO_Running</code> и <code>Slave_SQL_Running</code>,
но никакие дальнейшие события не считаны из журнала реле.</li></ul>

<h5><a name="replication-options-slave-log-tables"></a>
Опции для журналирования состояния ведомого в таблицы</h5>
<p>MySQL 8.0 допускает журналирование ведомой информации о статусе репликации
к таблицам, а не файлам. Запись основного журнала информации и журнала
информации журнала реле может быть сконфигурировано, отдельно используя эти
два параметра сервера, перечисленные здесь:</p>

<ul><li><p><a name="option_mysqld_master-info-repository"></a>
<a href="#option_mysqld_master-info-repository"><code>
--master-info-repository={FILE|TABLE}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--master-info-repository=FILE|TABLE</code>
</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FILE</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>FILE</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>TABLE</code></td></tr></tbody></table>

<p>Эта опция заставляет сервер писать свой основной журнал информации в
файл или таблицу. Имя файла по умолчанию <code>master.info</code>,
Вы можете поменять имя файла, используя опцию
<a href="#option_mysqld_master-info-file"><code>
--master-info-file</code></a>.</p>

<p>Значение по умолчанию для этой опции <code>FILE</code>.
Если Вы используете <code>TABLE</code>, журнал написан в таблицу
<code>slave_master_info</code> базы данных <code>mysql</code>.</li>

<li><a name="option_mysqld_relay-log-info-repository"></a>
<a href="#option_mysqld_relay-log-info-repository"><code>
--relay-log-info-repository={FILE|TABLE}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log-info-repository=FILE|TABLE</code>
</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FILE</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>FILE</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>TABLE</code></td></tr></tbody></table>

<p>Эта опция заставляет сервер регистрировать свою информацию журнала реле
в файле или таблице. Имя файла по умолчанию <code>relay-log.info</code>,
Вы можете поменять имя файла, используя опцию
<a href="#option_mysqld_relay-log-info-file">
<code>--relay-log-info-file</code></a>.</p>

<p>Значение по умолчанию для этой опции <code>FILE</code>.
Если Вы используете <code>TABLE</code>, журнал написан в таблицу
<code>slave_relay_log_info</code> базы данных <code>mysql</code>.</p>

<p>Для репликации, чтобы быть безопасной от катастрофического отказа, эта
опция должна быть установлена в <code>TABLE</code>, кроме того опция
<a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery</code></a> должна быть включена.</p></li></ul>

<p>Таблицы журнала информации и их содержание считают местными к данному
MySQL Server. Они не копируются, и изменения в них не
написаны в двоичный журнал.</p>
<p>См. <a href="#slave-logs">раздел 19.2.4</a>.</p>

<h5><a name="replication-sysvars-slaves"></a>
Системные переменные, используемые на ведомых устройствах репликации</h5>
<p>Следующий список описывает системные переменные для того, чтобы
управлять ведомыми серверами репликации. Они могут быть установлены при
запуске сервера и некоторые из них могут быть изменены во время выполнения
при использовании <a href="sql.htm#set-variable"><code>SET</code></a>.
Параметры сервера, используемые с ведомыми устройствами репликации,
перечислены ранее в этом разделе.</p>

<ul><li><a name="sysvar_slave_allow_batching"></a><p>
<a href="#sysvar_slave_allow_batching"><code>
slave_allow_batching</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-allow-batching</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_allow_batching">slave_allow_batching</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>off</code></td></tr></tbody></table>
<p>Включены ли пакетные обновления на ведомых устройствах репликации.</li>

<li><a name="sysvar_init_slave"></a>
<a href="#sysvar_init_slave"><code>init_slave</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--init-slave=name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_init_slave">init_slave</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Эта переменная подобна
<a href="server.htm#sysvar_init_connect"><code>init_connect</code></a>,
но строка будет выполнена ведомым сервером каждый раз, когда поток SQL
запускается. Формат строки тот же самый, что касается
<a href="server.htm#sysvar_init_connect"><code>init_connect</code></a>.
Установка этой переменной вступает в силу для последующего
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>.</p>

<p>Поток SQL посылает ответ клиенту прежде, чем выполнит
<a href="#sysvar_init_slave"><code>init_slave</code></a>.
Поэтому не гарантируется, что <a href="#sysvar_init_slave"><code>
init_slave</code></a> был выполнен вместе с
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>, см.
<a href="sql.htm#start-slave">раздел 14.4.2.6</a>.</p></li>

<li><a name="sysvar_log_slow_slave_statements"></a>
<a href="#sysvar_log_slow_slave_statements"><code>
log_slow_slave_statements</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_slow_slave_statements">
log_slow_slave_statements</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Когда медленный журнал запроса включен, эта переменная позволяет
регистрировать запросы, которые взяли больше, чем
<a href="server.htm#sysvar_long_query_time"><code>long_query_time</code></a>
секунд, чтобы выполниться на ведомом устройстве. Установка этой переменной не
имеет никакого непосредственного эффекта. статус переменной применяется на
всех последующих <a href="sql.htm#start-slave"><code>START SLAVE</code></a>.
</li>

<li><a name="sysvar_master_info_repository"></a>
<a href="#sysvar_master_info_repository"><code>
master_info_repository</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--master-info-repository=FILE|TABLE</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_master_info_repository">master_info_repository
</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FILE</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>FILE</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>TABLE</code></td></tr></tbody></table>

<p>Установка этой переменной определяет, регистрирует ли ведомое устройство
основное состояние и информацию о соединении в
<code>FILE</code> (<code>master.info</code>) или в <code>TABLE</code>
(<code>mysql.slave_master_info</code>).
Вы можете изменить значение этой переменной только, когда никакие потоки
репликации не выполняются.</p>

<p>У установки этой переменной также есть непосредственное воздействие на
эффект <a href="#sysvar_sync_master_info"><code>sync_master_info
</code></a>.</p>

<p>Эта переменная должна быть установлена в <code>TABLE</code> прежде, чем
сконфигурировать многократные каналы репликации. Если Вы используете
многократные каналы репликации, Вы не можете установить
эту переменную в <code>FILE</code>.</li>

<li><a name="sysvar_relay_log"></a>
<a href="#sysvar_relay_log"><code>relay_log</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log=file_name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log">relay_log</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr></tbody></table>

<p>Базовое имя файла системного журнала реле без путей и
расширения файла. По умолчанию <code>relay-log</code>.
Имена отдельных файлов для канала репликации по умолчанию
<code>relay-log.XXXXXX</code>, для дополнительных каналов репликации
<code>relay-log-<em><code>channel</code></em>.XXXXXX</code>.</li>

<li><a name="sysvar_relay_log_basename"></a>
<a href="#sysvar_relay_log_basename"><code>relay_log_basename
</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log_basename">relay_log_basename</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>datadir + '/' + hostname + '-relay-bin'</code></td>
</tr></tbody></table>
<p>Имя и полный путь к файлу системного журнала реле.</li>

<li><a name="sysvar_relay_log_index"></a>
<a href="#sysvar_relay_log_index"><code>relay_log_index</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log-index</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log_index">relay_log_index</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>*host_name*-relay-bin.index</code></td>
</tr></tbody></table>

<p>Имя индексного файла журнала реле для канала репликации
по умолчанию. Имя по умолчанию
<code><em><code>host_name</code></em>-relay-bin.index</code>
в каталоге данных, где <em><code>host_name</code></em>
название ведомого сервера.</li>

<li><a name="sysvar_relay_log_info_file"></a>
<a href="#sysvar_relay_log_info_file"><code>relay_log_info_file
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log-info-file=file_name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log_info_file">relay_log_info_file</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>relay-log.info</code></td></tr></tbody></table>

<p>Название файла, в котором ведомое устройство делает запись информации о
журналах реле, когда
<a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository=FILE</code></a>. Если
<a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository=TABLE</code></a>,
это имя файла, которое использовалось бы в случае, если бы репозитарий был
изменен на <code>FILE</code>). Имя по умолчанию
<code>relay-log.info</code> в каталоге данных.</li>

<li><a name="sysvar_relay_log_info_repository"></a>
<a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log_info_repository">
relay_log_info_repository</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FILE</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>FILE</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>TABLE</code></td></tr></tbody></table>

<p>Эта переменная определяет, написана ли позиция ведомого устройства в
журналах реле в <code>FILE</code> (<code>relay-log.info</code>) или
<code>TABLE</code> (<code>mysql.slave_relay_log_info</code>).
Вы можете изменить значение этой переменной, только когда никакие потоки
репликации не выполняются.</p>

<p>У установки этой переменной также есть непосредственное воздействие на
<a href="#sysvar_sync_relay_log_info"><code>sync_relay_log_info
</code></a>.</p>

<p>Эта переменная должна быть установлена в <code>TABLE</code> прежде, чем
сконфигурировать многократные каналы репликации. Если Вы используете
многократные каналы репликации, Вы не можете установить
эту переменную к <code>FILE</code>.</li>

<li><a name="sysvar_relay_log_recovery"></a>
<a href="#sysvar_relay_log_recovery"><code>
relay_log_recovery</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--relay-log-recovery</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_relay_log_recovery">relay_log_recovery</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Включает автоматическое восстановление журнала реле после запуска сервера.
Процесс восстановления создает новый файл системного журнала реле,
инициализирует позицию потока SQL к этому новому журналу реле и
инициализирует поток ввода/вывода к позиции потока SQL. Чтение журнала реле
от ведущего устройства тогда продолжается. В MySQL 5.7 эта глобальная
переменная только для чтения, значение может быть изменено, запуская ведомое
устройство с опцией <a href="#option_mysqld_relay-log-recovery">
<code>--relay-log-recovery</code></a>, которая должна использоваться после
катастрофического отказа на ведомом устройстве репликации, чтобы
гарантировать, что поврежденные журналы реле обработаны, и должна
использоваться, чтобы гарантировать безопасное от катастрофического отказа
ведомое устройство. Значение по умолчанию 0 (отключена).</p>

<p>Эта переменная также взаимодействует с
<a href="server.htm#sysvar_relay_log_purge"><code>relay-log-purge</code></a>,
которая управляет чисткой журналов, когда они больше не необходимы. Включение
<a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery</code></a>, когда выключена
<a href="server.htm#sysvar_relay_log_purge"><code>relay-log-purge</code></a>
это риск чтения журнала реле из файлов, которые не были очищены, приводя к
несогласованности данных, поэтому не безопасно от катастрофического отказа.
</p>

<p>Когда <code>relay_log_recovery</code> включена и ведомое устройство
остановилось из-за ошибок, с которыми сталкиваются, работая в виде
мультидерева сообщений, Вы можете использовать
<a href="sql.htm#start-slave"><code>START SLAVE UNTIL SQL_AFTER_MTS_GAPS
</code></a>, чтобы гарантировать, что все промежутки обработаны прежде, чем
переключиться назад на единственное дерево сообщений или выполнить
<code>CHANGE MASTER TO</code>.</li>

<li><a name="sysvar_rpl_stop_slave_timeout"></a>
<a href="#sysvar_rpl_stop_slave_timeout"><code>
rpl_stop_slave_timeout</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--rpl-stop-slave-timeout=seconds</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_rpl_stop_slave_timeout">rpl_stop_slave_timeout
</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>31536000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>2</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>31536000</code></td></tr></tbody></table>

<p>Вы можете управлять отрезком времени (в секундах), который
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>
ждет перед синхронизацией, устанавливая эту переменную. Это может
использоваться, чтобы избежать тупиков между <code>STOP SLAVE</code> и
другими ведомыми запросами SQL, используя различные соединения клиента с
ведомым устройством. Максимальное и значение по умолчанию
<code>rpl_stop_slave_timeout</code> 31536000 секунд (1 год). Минимум
составляет 2 секунды. Изменения этой переменной вступают в силу для
последующего <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>.
Эта переменная затрагивает только клиента, который скомандовал
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>.
Когда тайм-аут достигнут, клиент прекращает ждать ведомых потоков, чтобы
остановиться, но ведомые потоки продолжают пытаться остановиться.</li>

<li><a name="sysvar_slave_checkpoint_group"></a>
<a href="#sysvar_slave_checkpoint_group"><code>
slave_checkpoint_group</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-checkpoint-group=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
slave_checkpoint_group=#</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>512</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>32</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>524280</code></td></tr>
<tr><td scope="row"><span><strong>Block Size</strong></span></td>
<td colspan="2"><code>8</code></td></tr></tbody></table>

<p>Устанавливает максимальное количество транзакций, которые могут быть
обработаны мультипоточным ведомым устройством прежде, чем работу контрольной
точки вызовут, чтобы обновить ее состояние как показано
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.
Установка этой переменной не имеет никакого эффекта на ведомые устройства,
для которых не включена мультипоточная обработка. Установка этой переменной
не имеет никакого непосредственного эффекта. статус переменной применяется на
всех последующих <a href="sql.htm#start-slave"><code>START SLAVE</code></a>.
</p>

<p>Эта переменная работает в комбинации с
<a href="#sysvar_slave_checkpoint_period"><code>
slave_checkpoint_period</code></a>
таким способом, которым, когда любой предел превышен,
контрольная точка выполнена и счетчики, отслеживающие
число транзакций и время, начиная с последней контрольной точки сброшены.</p>

<p>Минимальное позволенное значение для этой переменной 32, если сервер не
был создан, используя
<a href="install.htm#option_cmake_with_debug"><code>-DWITH_DEBUG</code></a>,
тогда минимальное значение 1. Действующее значение всегда кратно числу 8, Вы
можете установить это в значение, которое не является таким кратным числом,
но сервер округляет это в меньшую сторону к следующему кратному
8 прежде, чем сохранить значение. <span><em>Исключение</em></span>:
никакое округление не выполнено сервером отладки. Независимо от того, как
сервер был создан, значение по умолчанию 512 и
максимальное позволенное значение 524280.</li>

<li><a name="sysvar_slave_checkpoint_period"></a>
<a href="#sysvar_slave_checkpoint_period"><code>
slave_checkpoint_period</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-checkpoint-period=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
slave_checkpoint_period=#</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>300</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4G</code></td></tr></tbody></table>

<p>Устанавливает максимальное время (в миллисекундах), которому позволяют
пройти прежде, чем работу контрольной точки вызовут, чтобы обновить состояние
мультипоточного ведомого устройства как показано
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.
Установка этой переменной не имеет никакого эффекта на ведомые устройства,
для которых не включена мультипоточная обработка. Установка этой переменной
немедленно вступает в силу для всех каналов репликации,
включая рабочие каналы.</p>

<p>Эта переменная работает в комбинации с
<a href="#sysvar_slave_checkpoint_group"><code>
slave_checkpoint_group</code></a>
таким способом, которым, когда любой предел превышен, контрольная точка
выполнена и счетчики, отслеживающие число транзакций и время,
начиная с последней контрольной точки сброшены.</p>

<p>Минимальное позволенное значение для этой переменной 1, если сервер не был
создан, используя <a href="install.htm#option_cmake_with_debug"><code>
-DWITH_DEBUG</code></a>, тогда минимальное значение 0. Независимо от того,
как был создан сервер, значение по умолчанию 300 и максимальное
возможное значение 4294967296 (4GB).</li>

<li><a name="sysvar_slave_compressed_protocol"></a>
<a href="#sysvar_slave_compressed_protocol"><code>
slave_compressed_protocol</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave_compressed_protocol</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_compressed_protocol">
slave_compressed_protocol</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Использовать ли сжатие ведомого/основного протокола, если ведущее и
ведомое устройства это понимают. Изменения этой переменной вступают в силу на
последующих попытках соединения, это включается после
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>, так же как
пересоединения, сделанные рабочим потоком ввода/вывода (например, после
<code>CHANGE MASTER TO MASTER_RETRY_COUNT</code>).</li>

<li><a name="sysvar_slave_exec_mode"></a>
<a href="#sysvar_slave_exec_mode"><code>slave_exec_mode</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-exec-mode=mode</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_exec_mode">slave_exec_mode</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>STRICT</code> (ALL)</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>IDEMPOTENT</code> (NDB)</td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>IDEMPOTENT
</code></td></tr>
<tr><td scope="row" colspan="2"><code>STRICT</code></td></tr></tbody></table>

<p>Средство управления, как ведомый поток решает конфликты и ошибки во
время репликации. <code>IDEMPOTENT</code> вызывает подавление ошибок
дубликата ключа и отсутствия ключа. Этот режим должен использоваться в
мультиосновной репликации, круговой репликации и некоторых других специальных
сценариях репликации. <code>STRICT</code> значение по умолчанию, и является
подходящим для большинства других случаев. Установка этой переменной
немедленно вступает в силу для всех каналов репликации,
включая рабочие каналы.</li>

<li><a name="sysvar_slave_load_tmpdir"></a>
<a href="#sysvar_slave_load_tmpdir"><code>slave_load_tmpdir
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-load-tmpdir=dir_name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_load_tmpdir">slave_load_tmpdir</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>
directory name</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>/tmp</code></td></tr></tbody></table>

<p>Название каталога, где ведомое устройство создает временные файлы для
того, чтобы копировать <a href="sql.htm#load-data"><code>LOAD DATA INFILE
</code></a>. Установка этой переменной немедленно вступает в силу для всех
каналов репликации, включая рабочие каналы.</li>

<li><a name="sysvar_slave_max_allowed_packet"></a>
<a href="#sysvar_slave_max_allowed_packet"><code>
slave_max_allowed_packet</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_max_allowed_packet">
slave_max_allowed_packet</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr></tbody></table>

<p>Эта переменная устанавливает максимальный пакетный размер для ведомых
потоков SQL и ввода/вывода, чтобы большие обновления, используя основанную на
строке репликацию не заставили репликацию терпеть неудачу, потому что
обновление превысило <a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a>. Установка этой переменной немедленно вступает
в силу для всех каналов репликации, включая рабочие каналы.</p>

<p>У этой глобальной переменной всегда есть значение, которое является
положительным целым числом, кратным 1024, если Вы устанавливаете это в
некоторое значение, которое не является кратным 1024, значение округлено в
меньшую сторону к следующему самому большому кратному 1024 числу, установка
<code>slave_max_allowed_packet</code> в 0 установит 1024.
Предупреждение выпущено во всех таких случаях. Значение по умолчанию и
максимальное значение 1073741824 (1 GB), минимум 1024.</p>

<p><code>slave_max_allowed_packet</code> может также быть установлена
при запуске, используя опцию
<a href="#option_mysqld_slave-max-allowed-packet">
<code>--slave-max-allowed-packet</code></a>.</li>

<li><a name="sysvar_slave_net_timeout"></a>
<a href="#sysvar_slave_net_timeout"><code>slave_net_timeout
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-net-timeout=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_net_timeout">slave_net_timeout</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>3600</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>60</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1</code></td></tr></tbody></table>

<p>Число секунд, чтобы ждать большего количества данных от основного/ведомого
соединения прежде, чем прервать чтение. Установка этой переменной не имеет
никакого непосредственного эффекта. Статус переменной применяется на всех
последующих <a href="sql.htm#start-slave"><code>START SLAVE</code></a>.</li>

<li><a name="sysvar_slave_parallel_type"></a>
<a href="#sysvar_slave_parallel_type"><code>slave_parallel_type=
<em><code>type</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-parallel-type=type</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>DATABASE</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2">
<code>DATABASE</code></td></tr>
<tr><td scope="row" colspan="2"><code>LOGICAL_CLOCK</code></td>
</tr></tbody></table>

<p>Используя мультипоточное ведомое устройство
(<a href="#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> больше 0), эта переменная определяет
политику, решающую, которые транзакции позволить выполнить параллельно
на ведомом устройстве.</li>

<li><a name="sysvar_slave_parallel_workers"></a>
<a href="#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-parallel-workers=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_parallel_workers">slave_parallel_workers
</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr></tbody></table>

<p>Определяет число потоков применения ведомого устройства
для того, чтобы выполнить транзакции репликации параллельно. Установка этой
переменной к числу больше 0 создает мультипоточное ведомое устройство с этим
числом потоков. Когда установлено в 0 (значение по умолчанию) параллельное
выполнение отключено, и ведомое устройство использует единственный поток.
Установка <a href="#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> не имеет никакого непосредственного
эффекта. Статус переменной применяется на всех последующих
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>.
Повторение транзакций поддержано, когда мультипоточная обработка включена
на ведомом устройстве.</p>

<p>Мультипоточное ведомое устройство обеспечивает параллельное выполнение
при использовании потока координатора и потоков применения,
сконфигурированных этой переменной. Способ, которым транзакции распределены
среди потоков, сконфигурирован
<a href="#sysvar_slave_parallel_type"><code>slave_parallel_type
</code></a>. Транзакции, которые ведомое устройство применяет параллельно,
могут передать не в том порядке, если
<a href="#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order=1</code></a>.
Поэтому проверка последней выполненной транзакции не гарантирует, что все
предыдущие транзакции от ведущего устройства были выполнены на ведомом
устройстве. У этого есть значения для журналирования и восстановления,
используя мультипоточное ведомое устройство. Например, на мультипоточном
ведомом устройстве <a href="sql.htm#start-slave"><code>START SLAVE
UNTIL</code></a> поддерживает использование только
<code>SQL_AFTER_MTS_GAPS</code>.</li>

<li><a name="sysvar_slave_pending_jobs_size_max"></a>
<a href="#sysvar_slave_pending_jobs_size_max"><code>
slave_pending_jobs_size_max</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_pending_jobs_size_max">
slave_pending_jobs_size_max</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>16M</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>1024</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18EB</code></td></tr>
<tr><td scope="row"><span><strong>Block Size</strong></span></td>
<td colspan="2"><code>1024</code></td></tr></tbody></table>

<p>Для мультипоточных ведомых устройств эта переменная устанавливает
максимальный объем памяти (в байтах) доступный очередям, хранящим
еще не примененные транзакции. Установка этой переменной не имеет никакого
эффекта на ведомые устройства, для которых не включена мультипоточная
обработка. Установка этой переменной не имеет никакого непосредственного
эффекта. Статус переменной применяется на всех последующих
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>.</p>

<p>Минимальное возможное значение для этой переменной 1024,
значение по умолчанию составляет 16 МБ. Максимальное возможное значение
18446744073709551615 (16 exabytes). Значения, которые не являются кратными
1024 округлены в меньшую сторону к следующему самому большому
кратному 1024 числу до того, как сохранены.</p>

<p>Значение этой переменной не должно быть меньше чем значение ведущего
устройства для <a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a>, иначе очередь может стать полной, в то время
как там остаются события, прибывающие от ведущего устройства,
чтобы быть обработанными.</p></li>

<li><a name="sysvar_slave_preserve_commit_order"></a>
<a href="#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-preserve-commit-order=value</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_preserve_commit_order">
slave_preserve_commit_order</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>0</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>1</code></td></tr></tbody></table>

<p>Для мультипоточных ведомых устройств включение этой переменной
гарантирует, что транзакции воплощены на ведомом устройстве в том же самом
порядке, как они появляются в журнале реле ведомого устройства. Установка
этой переменной не имеет никакого эффекта на ведомые устройства, для которых
не включена мультипоточная обработка. Все потоки репликации (для всех каналов
репликации, если Вы используете многократные каналы репликации) должны быть
остановлены прежде, чем менять это значение.
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a> и
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a> должны быть включены на ведомом устройстве.
Кроме того, <code>--slave-parallel-type</code> должна быть
установлена в <code>LOGICAL_CLOCK</code>.</p>

<p>Как только мультипоточное ведомое устройство было запущено, транзакции
могут начать выполняться параллельно. С включенной
<a href="#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order</code></a> поток выполнения ждет, пока все
предыдущие транзакции не переданы перед совершением. В то время как ведомый
поток ждет других, чтобы передать их транзакции, он сообщает о своем
состоянии как <code>Waiting for preceding transaction to commit</code>.
Включение этого режима на мультипоточном ведомом устройстве гарантирует, что
никогда не будет статуса, в котором не было ведущее устройство. Это делает
его хорошо подходящим для использования репликации для масштабирования
чтения. См. <a href="#replication-solutions-scaleout">раздел
19.3.5</a>.</p>

<p>Используя мультипоточное ведомое устройство, если не включена
<a href="#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order</code></a>
есть шанс промежутков в последовательности транзакций, которые были выполнены
от журнала реле ведомого устройства. Когда эта опция включена, нет этого
шанса промежутков, но <code>Exec_master_log_pos</code>
может быть позади позиции, до которой был выполнен. См.
<a href="#replication-features-transaction-inconsistencies">
раздел 19.4.1.34</a>.</li>

<li><a name="sysvar_slave_rows_search_algorithms"></a>
<a href="#sysvar_slave_rows_search_algorithms"><code>
slave_rows_search_algorithms</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
slave_rows_search_algorithms=list</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>set</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>TABLE_SCAN,INDEX_SCAN</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2">
<code>TABLE_SCAN,INDEX_SCAN</code></td></tr>
<tr><td scope="row" colspan="2"><code>INDEX_SCAN,HASH_SCAN</code></td></tr>
<tr><td scope="row" colspan="2"><code>TABLE_SCAN,HASH_SCAN</code></td></tr>
<tr><td scope="row" colspan="2"><code>TABLE_SCAN,INDEX_SCAN,HASH_SCAN</code>
(аналог INDEX_SCAN,HASH_SCAN)</td></tr></tbody></table>

<p>Готовя пакеты строк для основанного на строке журналирования и репликации,
эта переменная управляет, как строки разыскиваются, то есть, используется ли
хеширование для поисков, используется ли основной, уникальный ключ
или некоторый другой ключ, или не используются ключи вообще. Установка этой
переменной немедленно вступает в силу для всех каналов репликации,
включая рабочие каналы.</p>

<p>Эта переменная берет список разделенных запятой значений по крайней мере
2 значений из списка <code>INDEX_SCAN</code>, <code>TABLE_SCAN</code>,
<code>HASH_SCAN</code>. Значение, ожидаемое как строка, должно быть заключено
в кавычки.Кроме того, значение не должно содержать пробелы. Возможные
комбинации (списки) и их эффекты показаны в следующей таблице:</p>

<table border="1">
<thead><tr><th scope="col">Значение опции и используемые индексы</th>
<th scope="col"><code>INDEX_SCAN,HASH_SCAN</code> или
<code>INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code></th>
<th scope="col"><code>INDEX_SCAN,TABLE_SCAN</code></th>
<th scope="col"><code>TABLE_SCAN,HASH_SCAN</code></th></tr></thead>
<tbody><tr><td scope="row"><span><em>Первичный или уникальный ключ</em>
</span>.</td><td>Индексный просмотр.</td>
<td>Индексный просмотр.</td><td>Индексный хэш.</td></tr>
<tr><td scope="row"><span><em>(Другой) ключ</em></span></td>
<td>Индексный хэш.</td><td>Индексный просмотр.</td>
<td>Индексный хэш.</td></tr>
<tr><td scope="row"><span><em>Индекс не используется.</em></span></td>
<td>Табличный хэш.</td><td>Табличный просмотр.</td>
<td>Табличный хэш.</td></tr></tbody></table>

<p>Порядок, в котором алгоритмы определены в списке, не имеет никакого
значения в порядке, в котором они выведены на экран
<a href="sql.htm#select"><code>SELECT</code></a> или
<a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a>,
как показано здесь:
<pre>
mysql&gt; SET GLOBAL slave_rows_search_algorithms = "INDEX_SCAN,TABLE_SCAN";
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SHOW VARIABLES LIKE '%algorithms%';
+------------------------------+-----------------------+
| Variable_name                | Value                 |
+------------------------------+-----------------------+
| slave_rows_search_algorithms | TABLE_SCAN,INDEX_SCAN |
+------------------------------+-----------------------+
1 row in set (0.00 sec)

mysql&gt; SET GLOBAL slave_rows_search_algorithms = "TABLE_SCAN,INDEX_SCAN";
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SHOW VARIABLES LIKE '%algorithms%';
+------------------------------+-----------------------+
| Variable_name                | Value                 |
+------------------------------+-----------------------+
| slave_rows_search_algorithms | TABLE_SCAN,INDEX_SCAN |
+------------------------------+-----------------------+
1 row in set (0.00 sec)
</pre>

<p>Значение по умолчанию <code>TABLE_SCAN,INDEX_SCAN</code>
означает, что все поиски, которые могут использовать индексы, действительно
используют их, и поиски без индекса используют сканирование таблицы.</p>

<p>Определение <code>INDEX_SCAN,TABLE_SCAN,HASH_SCAN</code>
имеет тот же самый эффект как определение <code>INDEX_SCAN,HASH_SCAN</code>.
Чтобы использовать хеширование для любых поисков, которые не используют
основной или уникальный ключ, устанавливайте эту переменную в
<code>INDEX_SCAN,HASH_SCAN</code>. Чтобы вызвать хеширование для
<span><em>всех</em></span> поисков, установите это в
<code>TABLE_SCAN,HASH_SCAN</code>.</li>

<li><a name="sysvar_slave_skip_errors"></a>
<a href="#sysvar_slave_skip_errors"><code>slave_skip_errors</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave-skip-errors=name</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_skip_errors">slave_skip_errors</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>[list of error codes]</code></td></tr>
<tr><td scope="row" colspan="2"><code>all</code></td></tr>
<tr><td scope="row" colspan="2"><code>ddl_exist_errors</code></td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>[список кодов ошибок]</code></td></tr>
<tr><td scope="row" colspan="2"><code>all</code></td></tr>
<tr><td scope="row" colspan="2"><code>ddl_exist_errors</code></td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>[список кодов ошибок]</code></td></tr>
<tr><td scope="row" colspan="2"><code>all</code></td></tr>
<tr><td scope="row" colspan="2"><code>ddl_exist_errors</code></td>
</tr></tbody></table>

<p>Обычно репликация останавливается, когда ошибка происходит на ведомом
устройстве, которое дает Вам возможность решить несогласованность в данных
вручную. Эта переменная заставляет ведомый поток SQL продолжать репликацию,
когда запрос возвращает любую из ошибок, перечисленных в переменном значении.
Установка этой переменной немедленно вступает в силу, даже для
рабочих потоков репликации.</li>

<li><a name="sysvar_slave_sql_verify_checksum"></a>
<a href="#sysvar_slave_sql_verify_checksum"><code>
slave_sql_verify_checksum</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_sql_verify_checksum">
slave_sql_verify_checksum</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>0</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>1</code></td></tr></tbody></table>

<p>Заставьте ведомый поток SQL проверять данные, используя контрольные суммы,
считанные из журнала реле. В случае несоответствия ведомое устройство
останавливается с ошибкой. Установка этой переменной немедленно вступает в
силу для всех каналов репликации, включая рабочие каналы.</p>
<p>Ведомый поток ввода/вывода всегда читает контрольные суммы, если
возможно, принимая события из сети.</p></li>

<li><a name="sysvar_slave_transaction_retries"></a>
<a href="#sysvar_slave_transaction_retries"><code>
slave_transaction_retries</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave_transaction_retries=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_transaction_retries">
slave_transaction_retries</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Если поток SQL ведомого устройства не в состоянии выполнить транзакцию
из-за тупика <a href="innodb.htm"><code>InnoDB</code></a>
или потому что превышено время выполнения транзакции
<a href="innodb.htm"><code>InnoDB</code></a>
<a href="innodb.htm#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a>, это автоматически повторяет
<a href="#sysvar_slave_transaction_retries"><code>
slave_transaction_retries</code></a> раз прежде, чем остановиться с ошибкой.
Значение по умолчанию 10. Установка этой переменной немедленно вступает в
силу для всех каналов репликации, включая рабочие каналы.</p>

<p>Повторение транзакций поддержано, когда мультипоточная обработка включена
на ведомом устройстве. В предыдущих версиях
<a href="#sysvar_slave_transaction_retries"><code>
slave_transaction_retries</code></a> была обработана как 0, когда
использовались мультипоточныые ведомые устройства.</li>

<li><a name="sysvar_slave_type_conversions"></a>
<a href="#sysvar_slave_type_conversions"><code>
slave_type_conversions</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--slave_type_conversions=set</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_slave_type_conversions">slave_type_conversions
</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>set</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code></code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2">
<code>ALL_LOSSY</code></td></tr>
<tr><td scope="row" colspan="2"><code>ALL_NON_LOSSY</code></td></tr>
<tr><td scope="row" colspan="2"><code>ALL_SIGNED</code></td></tr>
<tr><td scope="row" colspan="2"><code>ALL_UNSIGNED</code></td></tr>
</tbody></table>

<p>Управляет конверсионным режимом типа на ведомом устройстве, используя
основанную на строке репликацию. Его значение разграниченный запятой набор
из ноля или большего количества элементов списка:
<code>ALL_LOSSY</code>, <code>ALL_NON_LOSSY</code>,
<code>ALL_SIGNED</code>, <code>ALL_UNSIGNED</code>.
Установите эту переменную в пустую строку, чтобы отвергнуть преобразования
типа между ведущим и ведомым устройствами. Установка этой переменной
немедленно вступает в силу для всех каналов репликации,
включая рабочие каналы.</p></li>

<li><a name="sysvar_sql_slave_skip_counter"></a>
<a href="#sysvar_sql_slave_skip_counter"><code>
sql_slave_skip_counter</code></a></p>

<table summary="Options for sql_slave_skip_counter" border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_sql_slave_skip_counter">sql_slave_skip_counter
</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr></tbody></table>

<p>Число событий от ведущего устройства, которое должен пропустить
ведомый сервер. Установка опции не имеет никакого непосредственного эффекта.
Переменная относится к следующему вызову <a href="sql.htm#start-slave"><code>
START SLAVE</code></a>, следующий <a href="sql.htm#start-slave"><code>START
SLAVE</code></a> также изменяет значение назад на 0. Когда эта переменная
установлена в ненулевое значение и есть многократные сконфигурированные
каналы репликации, <a href="sql.htm#start-slave"><code>START SLAVE</code></a>
может использоваться только с <code>FOR CHANNEL <em><code>channel</code></em>
</code>.</p>

<p>Эта опция является несовместимой с GTID-репликацией и не должна быть
установлена в ненулевое значение, когда
<a href="#option_mysqld_gtid-mode"><code>--gtid-mode=ON</code>
</a>. Если Вы должны пропустить транзакции, используя GTID, надо использовать
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
от ведущего устройства вместо этого.</p>

<p>Если пропуск числа событий, определенных, устанавливая эту переменную,
заставил бы ведомое устройство начинать в середине группы событий, ведомое
устройство продолжает пропускать транзакции, пока не находит начало следующей
группы событий и начинается с того пункта. Для получения дополнительной
информации см. <a href="sql.htm#set-global-sql-slave-skip-counter">
раздел 14.4.2.5</a>.</li>

<li><a name="sysvar_sync_master_info"></a>
<a href="#sysvar_sync_master_info"><code>sync_master_info</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--sync-master-info=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_sync_master_info">sync_master_info</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Эффекты этой переменной на ведомом устройстве репликации зависят того,
как установлена <a href="#sysvar_master_info_repository"><code>
master_info_repository</code></a>: <code>FILE</code> или <code>TABLE</code>.
</p>

<p><b>master_info_repository = FILE. </b>
Если <code>sync_master_info</code> больше 0,
ведомое устройство синхронизирует
<code>master.info</code> с диском через <code>fdatasync()</code> каждые
<code>sync_master_info</code> событий. Если это 0, MySQL
не выполняет синхронизации <code>master.info</code> с диском,
вместо этого, сервер полагается на операционную систему, чтобы периодически
сбросить содержание как с любым другим файлом.</p>

<p><b>master_info_repository = TABLE. </b>
Если <code>sync_master_info</code> больше 0,
ведомое устройство обновляет свою основную таблицу репозитария информации
после каждых <code>sync_master_info</code> событий. Если это 0,
таблица никогда не обновляется.</p>

<p>Значение по умолчанию для <code>sync_master_info</code> 10000. Установка
этой переменной немедленно вступает в силу для всех каналов репликации,
включая рабочие каналы.</li>

<li><a name="sysvar_sync_relay_log"></a>
<a href="#sysvar_sync_relay_log"><code>sync_relay_log</code></a>
</p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--sync-relay-log=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_sync_relay_log">sync_relay_log</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Если значение этой переменной больше 0, сервер MySQL синхронизирует свой
журнал реле с диском (с использованием <code>fdatasync()</code>) каждые
<code>sync_relay_log</code> событий. Установка этой переменной немедленно
вступает в силу для всех каналов репликации, включая рабочие каналы.</p>

<p>Установка <code>sync_relay_log</code> = 0 значит, что никакая
синхронизация не будет сделана, в этом случае сервер полагается на
операционную систему, чтобы время от времени сбросить содержание журнала
реле, что касается любого другого файла.</p>

<p>Значение 1 является самым безопасным выбором, потому что в случае
катастрофического отказа Вы теряете самое большее одно событие
журнала реле. Однако, это также самый медленный выбор (если у диска нет
поддержанного батареей кэша, который делает синхронизацию очень быстро).</li>

<li><a name="sysvar_sync_relay_log_info"></a>
<a href="#sysvar_sync_relay_log_info"><code>sync_relay_log_info
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--sync-relay-log-info=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_sync_relay_log_info">sync_relay_log_info</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>10000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Эффекты этой переменной на ведомом устройстве зависят от серверной
<a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository</code></a>, если это <code>TABLE</code>,
дополнительно от того, является ли механизм хранения, используемый таблицей
информации журнала реле, транзакционным.
Эффекты этих факторов на поведение сервера для
<code>sync_relay_log_info</code> = 0 или больше
показываются в следующей таблице:</p>

<table border="1">
<thead><tr><th scope="col" rowspan="3"><code>sync_relay_log_info</code></th>
<th scope="col" colspan="3"><code>relay_log_info_repository</code></th></tr>
<tr><th scope="col" rowspan="2"><code>FILE</code></th>
<th scope="col" colspan="2"><code>TABLE</code></th></tr>
<tr><th scope="col">Транзакционный</th>
<th scope="col">Нетранзакционный</th></tr></thead>
<tbody><tr><td scope="row"><code><em><code>N</code></em> &gt; 0</code></td>
<td><p>Ведомое устройство синхронизирует <code>relay-log.info</code> на диск
(через <code>fdatasync()</code>) каждые <em><code>N</code></em> транзакций.
</p></td>
<td rowspan="2"><p>Таблица обновлена после каждой транзакции.
<em><code>N</code></em> игнорируется.</p></td>
<td><p>Таблица обновлена после каждого
<em><code>N</code></em>-го события.</p></td></tr>
<tr><td scope="row"><code>0</code></td>
<td><p>Сервер MySQL не выполняет синхронизацию
<code>relay-log.info</code> с диском, полагаясь на ОС.</p></td>
<td><p>Таблица никогда не обновляется.</p></td></tr></tbody></table>

<p>Значение по умолчанию для <code>sync_relay_log_info</code> 10000.
Установка этой переменной немедленно вступает в силу для всех каналов
репликации, включая рабочие каналы.</p></li></ul>

<h4><a name="replication-options-binary-log"></a>19.1.6.4.
Опции и переменные двоичного журналирования</h4>
<p>Вы можете использовать опции и системные переменные
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>,
которые описаны в этом разделе, чтобы затронуть работу двоичного журнала так
же как управлять, какие запросы написаны двоичному журналу. Для
дополнительной информации о двоичном журнале см.
<a href="server.htm#binary-log">раздел 6.4.4</a>.</p>

<h5><a name="replication-optvars-binlog"></a>
Опции запуска, используемые с двоичным журналированием</h5>
<p>Следующий список описывает опции запуска для включения и конфигурирования
двоичного журнала. Системные переменные, используемые с двоичным
журналированием, обсуждены позже в этом разделе.</p>

<ul><li><p><a name="option_mysqld_binlog-row-event-max-size"></a>
<a href="#option_mysqld_binlog-row-event-max-size"><code>
--binlog-row-event-max-size=<em><code>N</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-row-event-max-size=#</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8192</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>256</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>8192</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>256</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Определите максимальный размер основанного на строке события двоичного
журнала в байтах. Строки сгруппированы в события, меньшие чем этот размер,
если возможно. Значение должно быть кратным числу 256.
Значение по умолчанию 8192. См. <a href="#replication-formats">
раздел 19.2.1</a>.</li>

<li><a name="option_mysqld_log-bin"></a>
<a href="#option_mysqld_log-bin"><code>
--log-bin[=<em><code>base_name</code></em>]</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--log-bin</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_bin">log_bin</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr></tbody></table>

<p>Включить двоичное журналирование. Сервер регистрирует все запросы,
об изменении данных в двоичном журнале, который используется для резервного
копирования и репликации. См. <a href="server.htm#binary-log">раздел 6.4.4
</a>.</p>

<p>Значение опции, если дано, является базовым именем для последовательности
журнала. Сервер создает двоичные файлы системного журнала в
последовательности, добавляя числовой суффикс к базовому имени.
Рекомендуется, чтобы Вы определили базовое имя (см. <a href="error.htm#bugs">
раздел B.5.7</a>). Иначе MySQL использует как базовое имя
<code><em><code>host_name</code></em>-bin</code>.</p>

<p>Когда сервер читает запись из индексного файла, он проверяет, содержит ли
она относительный путь, и если это так, относительная часть пути замена
абсолютным путем, используя опцию <code>--log-bin</code>.
Абсолютный путь остается неизменным, в таком случае индексирование должно
быть отредактировано вручную, чтобы позволить новому пути или путям
использоваться. В более старых версиях MySQL ручное вмешательство
требовалось, перемещая двоичной журнал или файлы системного журнала
реле (Bug #11745230, Bug #12133).</p>

<p>Установка этой опции вызывает установку
<a href="#sysvar_log_bin"><code>log_bin</code></a> в
<code>ON</code> (или <code>1</code>), а не к базовому имени.
Имя файла системного журнала (с путем) доступно как
<a href="#sysvar_log_bin_basename"><code>log_bin_basename</code>
</a>.</p>

<p>Если Вы определяете эту опцию, также не определяя
<a href="#option_mysqld_server-id"><code>--server-id</code></a>,
сервер не запустится (Bug #11763963, Bug #56739).</li>

<li><a name="option_mysqld_log-bin-index"></a>
<a href="#option_mysqld_log-bin-index"><code>
--log-bin-index[=<em><code>file_name</code></em>]</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--log-bin-index=file_name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr></tbody></table>

<p>Индексный файл для файла системного журнала. См.
<a href="server.htm#binary-log">раздел 6.4.4</a>.
Если Вы опускаете имя файла, и если Вы не определяли его с
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>, MySQL
использует <code><em><code>host_name</code></em>-bin.index</code>.</li>

<li><a name="option_mysqld_log-bin-trust-function-creators"></a>
<a href="#option_mysqld_log-bin-trust-function-creators"><code>
--log-bin-trust-function-creators[={0|1}]</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--log-bin-trust-function-creators</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="server.htm#sysvar_log_bin_trust_function_creators">
log_bin_trust_function_creators</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Эта опция устанавливает соответствующую системную переменную
<a href="server.htm#sysvar_log_bin_trust_function_creators"><code>
log_bin_trust_function_creators</code></a>. Если никакой параметр не дан,
опция устанавливает переменную в 1.
<a href="server.htm#sysvar_log_bin_trust_function_creators"><code>
log_bin_trust_function_creators</code></a> управляет,
как MySQL проводит в жизнь ограничения на создание триггеров и сохраненных
функций. См. <a href="stored.htm#stored-programs-logging">раздел 21.7</a>.
</li>

<li><a name="option_mysqld_log-bin-use-v1-row-events"></a>
<a href="#option_mysqld_log-bin-use-v1-row-events"><code>
--log-bin-use-v1-row-events[={0|1}]</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--log-bin-use-v1-row-events[={0|1}]</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_bin_use_v1_row_events">
log_bin_use_v1_row_events</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr></tbody></table>

<p>MySQL 8.0 применяет Version 2 событий строки, которые не могут быть
считаны выпусками MySQL Server до MySQL 5.6.6. Установка этой опции к 1
предписывает <a href="programs.htm#mysqld"><span><strong>mysqld</strong>
</span></a> писать двоичной журнал, используя события журналирования
Version 1, которая является единственной версией двоичных событий журнала,
используемых в предыдущих выпусках, и таким образом производит двоичные
журналы, которые могут быть считаны более старыми ведомыми устройствами.
Установка <code>--log-bin-use-v1-row-events</code> = 0
(значение по умолчанию) заставляет
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
использовать события журнала Version 2.</p>

<p>Значение, используемое для этой опции, может быть получено из
переменной только для чтения
<a href="#sysvar_log_bin_use_v1_row_events">
<code>log_bin_use_v1_row_events</code></a>.</p></li></ul>

<p><b>Опции выбора запроса. </b>Опции в следующем списке определяют, которые
запросы написаны двоичному журналу, и таким образом посланы главным сервером
репликации в его ведомые устройства. Есть также опции для ведомых серверов,
которые управляют, какие запросы, полученные от ведущего устройства, должны
быть выполнены или проигнорированы. Для деталей см.
<a href="#replication-options-slave">раздел 19.1.6.3</a>.</p>

<ul><li><p><a name="option_mysqld_binlog-do-db"></a>
<a href="#option_mysqld_binlog-do-db"><code>
--binlog-do-db=<em><code>db_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-do-db=name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Эта опция затрагивает журналирование аналогично
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a>.</p>

<p>Эффекты этой опции зависят от того, используется ли основанный на запросе
или основанный на строке формат журналирования таким же образом, как
<a href="#option_mysqld_replicate-do-db"><code>--replicate-do-db
</code></a>. Вы должны иметь в виду, что формат, используемый, чтобы
зарегистрировать данный запрос, возможно, не тот же самый, как обозначено
значением <a href="#sysvar_binlog_format"><code>binlog_format
</code></a>. Например, запросы DDL <a href="sql.htm#create-table"><code>
CREATE TABLE</code></a> и <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> всегда регистрируются как запросы без
отношения к формату журналирования.</p>

<p><b>Основанное на запросе журналирование. </b>
Только те запросы написаны двоичному журналу, где база данных по умолчанию
(то есть, выбранная <a href="sql.htm#use"><code>USE</code></a>)
<em><code>db_name</code></em>. Чтобы определить больше, чем одну базу данных,
используйте эту опцию многократно, однажды для каждой базы данных, однако,
выполнение этого <span><em>не</em></span> регистрирует запросы между базами
данных, например, <code>UPDATE <em><code>some_db.some_table</code></em> SET
foo='bar'</code> в то время, как другая база данных выбрана (или никакая
база данных не выбрана вообще).</p>

<p>Чтобы определить многократные базы данных, Вы <span><em>должны</em></span>
использовать многократные копии этой опции. Поскольку имена базы данных могут
содержать запятые, список будет обработан как название единственной базы
данных, если Вы будете поставлять список разделенных запятой значений.</p>

<p>Пример того, что не работает, как Вы могли бы ожидать, используя
основанное на запросе журналирование: если сервер запущен с
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db=sales
</code></a> и Вы делаете следующие запросы,
<a href="sql.htm#update"><code>UPDATE</code></a>
<span><em>не</em></span> будет зарегистрирован:
<pre>
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre>

<p>Главная причина для этой <span><span>проверки, что значение база
данных по умолчанию</span></span> то, что трудно из одного только запроса
знать, должно ли это копироваться (например, если Вы используете
многотабличный <a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>, которые действуют через
многократные базы данных). Также быстрее проверить только базу данных по
умолчанию, а не все базы данных, если в этом нет никакой потребности.</p>

<p>Другой случай, который, возможно, не самоочевиден, происходит, когда
данная база данных копируется даже при том, что это не было определено,
устанавливая опцию. Если сервер запущен с
<code>--binlog-do-db=sales</code>, следующий
<a href="sql.htm#update"><code>UPDATE</code></a>
зарегистрирован даже при том, что <code>prices</code>
не была включена, устанавливая <code>--binlog-do-db</code>:
<pre>
USE sales;
UPDATE prices.discounts SET percentage = percentage + 10;
</pre>

<p>Так как <code>sales</code> база данных по умолчанию, когда выполнен
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> зарегистрирован.</p>

<p><b>Основанное на строке журналирование. </b>Журналирование ограничено
базой данных <em><code>db_name</code></em>. Только изменения таблиц,
принадлежащих <em><code>db_name</code></em> зарегистрированы, база данных по
умолчанию не имеет никакого эффекта на это. Предположите, что сервер запущен
с <a href="#option_mysqld_binlog-do-db"><code>
--binlog-do-db=sales</code></a> и основанное на строке журналирование
включено, затем следующие запросы выполнены:
<pre>
USE prices;
UPDATE sales.february SET amount=amount+100;
</pre>

<p>Изменения таблицы <code>february</code> в базе данных <code>sales</code>
зарегистрированы в соответствии с <a href="sql.htm#update"><code>UPDATE
</code></a>, это происходит независимо от <a href="sql.htm#use"><code>USE
</code></a>. Однако, используя основанный на строке формат журналирования и
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db=sales
</code></a>, изменения, произведенные следующим <a href="sql.htm#update">
<code>UPDATE</code></a> не зарегистрированы:
<pre>
USE prices;
UPDATE prices.march SET amount=amount-25;
</pre>

<p>Даже если <code>USE prices</code> было изменено на <code>USE sales</code>,
<a href="sql.htm#update"><code>UPDATE</code></a> эффекты запроса все
еще не были бы написаны в двоичный журнал.</p>

<p>Другое важное различие в <a href="#option_mysqld_binlog-do-db">
<code>--binlog-do-db</code></a> обработка для основанного на запросе
журналирования в противоположность основанному на строке журналированию
происходит относительно запросов, которые относятся к многим базам данных.
Предположите, что сервер запущен с
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db=db1
</code></a> и следующие запросы выполнены:
<pre>
USE db1;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre>

<p>Если Вы используете основанное на запросе журналирование, обновления
обеих таблиц написаны в двоичный журнал. Однако, используя основанный на
строке формат, только изменения <code>table1</code> зарегистрированы,
<code>table2</code> находится в другой базе данных, таким образом, это не
изменено <a href="sql.htm#update"><code>UPDATE</code></a>. Теперь
предположите, что вместо <code>USE db1</code>
использован <code>USE db4</code>:
<pre>
USE db4;
UPDATE db1.table1 SET col1 = 10, db2.table2 SET col2 = 20;
</pre>

<p>В этом случае <a href="sql.htm#update"><code>UPDATE</code></a>
не написан в двоичный журнал, используя основанное на запросе журналирование.
Однако, используя основанное на строке журналирование, изменение
<code>table1</code> зарегистрировано, но не <code>table2</code>,
другими словами, только изменения таблиц в базе данных, названной
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db</code>
</a> зарегистрированы, и выбор базы данных значения по умолчанию не имеет
никакого эффекта на это поведение.</li>

<li><a name="option_mysqld_binlog-ignore-db"></a>
<a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db=<em><code>db_name</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-ignore-db=name</code></td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Эта опция затрагивает журналирование аналогично
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a>.</p>

<p>Эффекты этой опции зависят от того, используется ли основанный на запросе
или основанный на строке формат журналирования, таким же образом, как
эффекты <a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a>.
Вы должны иметь в виду, что формат, используемый, чтобы зарегистрировать
данный запрос, возможно, не тот же самый как обозначен значением
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>.
Например, запросы DDL <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> и <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> всегда регистрируются как запросы, без
отношения к формату журналирования.</p>

<p><b>Основанное на запросе журналирование. </b>Говорит серверу не
регистрировать любой запрос, где база данных по умолчанию (выбрана через
<a href="sql.htm#use"><code>USE</code></a>) <em><code>db_name</code></em>.
</p>

<p>Когда нет никакой базы данных по умолчанию,
опция <code>--binlog-ignore-db</code> не применена и
такие запросы всегда регистрируются (Bug #11829838, Bug #60188).</p>

<p><b>Основанный на строке формат. </b>Говорит серверу не регистрировать
обновления любых таблиц в базе данных <em><code>db_name</code></em>.
Текущая база данных не имеет никакого эффекта.</p>

<p>Используя основанное на запросе журналирование, следующий пример не
работает, как Вы могли бы ожидать. Предположите, что сервер запущен с
<a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db=sales</code></a> и Вы делаете следующие запросы:
<pre>
USE prices;
UPDATE sales.january SET amount=amount+1000;
</pre>

<p><a href="sql.htm#update"><code>UPDATE</code></a> зарегистрирован,
потому что <a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db</code></a> применяется только к базе данных по
умолчанию (определенной <a href="sql.htm#use"><code>USE</code></a>).
Поскольку база данных <code>sales</code> была определена явно в запросе,
запрос не фильтровался. Однако, используя основанное на строке
журналирование, <a href="sql.htm#update"><code>UPDATE</code></a>
<span><em>не</em></span> написан в двоичный журнал, что означает что никакие
изменения <code>sales.january</code> не зарегистрированы, в этом случае
<a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db=sales</code></a> не пишет <span><em>все</em></span>
изменения, произведенные в таблицах в копии ведущего устройства
базы данных <code>sales</code>.</p>

<p>Чтобы определить больше, чем одну базу данных, чтобы проигнорировать,
используйте эту опцию многократно, однажды для каждой базы данных.
Поскольку имена базы данных могут содержать запятые, список будет обработан
как название единственной базы данных, если Вы будете поставлять список
разделенных запятой значений.</p>

<p>Вы не должны использовать эту опцию, если Вы используете обновления между
базами данных, и Вы не хотите, чтобы эти обновления были зарегистрированы.
</p></li></ul>

<p><b>Опции контрольной суммы. </b>MySQL 8.0 понимает чтение и запись
контрольных сумм журнала. Они включены, используя эти две опции:</p>
<ul><li><p><a name="option_mysqld_binlog-checksum"></a>
<a href="#option_mysqld_binlog-checksum"><code>
--binlog-checksum={NONE|CRC32}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-checksum=type</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>CRC32</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>NONE</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>CRC32</code></td></tr></tbody></table>

<p>Включение этой опции заставляет ведущее устройство писать контрольные
суммы для событий, написанных двоичному журналу. Установите в
<code>NONE</code>, чтобы выключить или в название алгоритма, который будет
использоваться для того, чтобы произвести контрольные суммы, в настоящее
время поддержаны только контрольные суммы CRC32, CRC32 значение по умолчанию.
</li>

<li><a name="option_mysqld_master-verify-checksum"></a>
<a href="#option_mysqld_master-verify-checksum"><code>
--master-verify-checksum={0|1}</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--master-verify-checksum=name</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включение этой опции заставляет ведущее устройство проверять события
от двоичного журнала, используя контрольные суммы, и останавливаться с
ошибкой в случае несоответствия. Отключена по умолчанию.</p></li></ul>

<p>Чтобы управлять чтением контрольных сумм ведомым устройством от реле,
используйте <a href="#option_mysqld_slave-sql-verify-checksum">
<code>--slave-sql-verify-checksum</code></a>.</p>

<p><b>Тестирование и отладка опций. </b>Следующие опции журнала
используются в тестировании репликации и отладке. Они не предназначены для
использования в нормальном функционировании.</p>

<ul><li><p><a name="option_mysqld_max-binlog-dump-events"></a>
<a href="#option_mysqld_max-binlog-dump-events"><code>
--max-binlog-dump-events=<em><code>N</code></em></code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--max-binlog-dump-events=#</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr></tbody></table>
<p>Эта опция используется внутренне испытательным набором MySQL для
тестирования репликации и отладки.</li>

<li><a name="option_mysqld_sporadic-binlog-dump-fail"></a>
<a href="#option_mysqld_sporadic-binlog-dump-fail"><code>
--sporadic-binlog-dump-fail</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--sporadic-binlog-dump-fail</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>
<p>Эта опция используется внутренне испытательным набором MySQL для
тестирования репликации и отладки.</li>

<li><a name="option_mysqld_binlog-rows-query-log-events"></a>
<a href="#option_mysqld_binlog-rows-query-log-events"><code>
--binlog-rows-query-log-events</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-rows-query-log-events</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Эта опция включает
<a href="#sysvar_binlog_rows_query_log_events"><code>
binlog_rows_query_log_events</code></a>.</p></li></ul>

<h5><a name="replication-sysvars-binlog"></a>
Системные переменные, используемые с двоичным журналированием</h5>
<p>Следующий список описывает системные переменные для того, чтобы управлять
двоичным журналированием. Они могут быть установлены при запуске сервера,
некоторые из них могут быть изменены во время выполнения при использовании
<a href="sql.htm#set-variable"><code>SET</code></a>.
Параметры сервера, используемые, чтобы управлять двоичным журналированием,
перечислены ранее в этом разделе. Для информации о
<a href="server.htm#sysvar_sql_log_bin"><code>sql_log_bin</code></a> и
<a href="server.htm#sysvar_sql_log_off"><code>sql_log_off</code></a> см.
<a href="server.htm#server-system-variables">раздел 6.1.5</a>.</p>

<ul><li><p><a name="sysvar_binlog_cache_size"></a>
<a href="#sysvar_binlog_cache_size"><code>binlog_cache_size</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog_cache_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_cache_size">binlog_cache_size</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>32768</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>32768</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Размер кэша, чтобы содержать изменения двоичного журнала во время
транзакции. Кэш журнала выделен для каждого клиента, если сервер поддерживает
какие-либо транзакционные механизмы хранения и если у сервера есть двоичный
включенный журнал (<a href="#option_mysqld_log-bin"><code>
--log-bin</code></a>). Если Вы часто используете большие транзакции, Вы
можете увеличить этот размер кэша, чтобы получить лучшую работу.
<a href="server.htm#statvar_Binlog_cache_use"><code>Binlog_cache_use</code>
</a> и <a href="server.htm#statvar_Binlog_cache_disk_use"><code>
Binlog_cache_disk_use</code></a>
могут быть полезными для настройки размера этой переменной. См.
<a href="server.htm#binary-log">раздел 6.4.4</a>.</p>

<p><code>binlog_cache_size</code> устанавливает размер только для
операционного кэша, размером кэша запроса управляет
<a href="#sysvar_binlog_stmt_cache_size"><code>
binlog_stmt_cache_size</code></a>.</li>

<li><a name="sysvar_binlog_checksum"></a>
<a href="#sysvar_binlog_checksum"><code>binlog_checksum</code></a>
</p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_checksum">binlog_checksum</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>CRC32</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>NONE</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>CRC32</code></td></tr></tbody></table>

<p>Когда включена, эта переменная заставляет ведущее устройство писать
контрольную сумму для каждого события в двоичном журнале.
<code>binlog_checksum</code> допускает значения <code>NONE</code> (отключена)
и <code>CRC32</code>. Значение по умолчанию <code>CRC32</code>.</p>

<p>Когда <code>binlog_checksum</code> выключена (<code>NONE</code>),
сервер проверяет, что пишет только полные события в двоичный
журнал при записи и проверяя длину событий (а не контрольную сумму)
для каждого события.</p>

<p>Изменение значения этой переменной заставляет двоичной журнал
ротировать, контрольные суммы всегда пишутся всему файлу системного журнала,
и никогда только части.</p>

<p>Установка этой переменной на ведущем устройстве к значению, не признанному
ведомым устройством, заставляет ведомое устройство устанавливать свое
собственное значение <code>binlog_checksum</code> в <code>NONE</code>
и остановить репликацию с ошибкой (Bug #13553750, Bug #61096).
Если обратная совместимость с более старыми ведомыми устройствами это
проблема, Вы можете хотеть установить значение явно в <code>NONE</code>.</li>

<li><a name="sysvar_binlog_direct_non_transactional_updates"></a>
<a href="#sysvar_binlog_direct_non_transactional_updates"><code>
binlog_direct_non_transactional_updates</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog_direct_non_transactional_updates[=value]
</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_direct_non_transactional_updates">
binlog_direct_non_transactional_updates</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Из-за проблем параллелизма, ведомое устройство может стать
непоследовательным, когда транзакция содержит обновления
транзакционных и нетранзакционных таблиц. MySQL пытается сохранить причинную
связь среди этих запросов при записи нетранзакционных запросов операционному
кэшу, который сбрасывается при передаче. Однако, проблемы возникают, когда
модификации, сделанные к нетранзакционным таблицам от имени транзакции,
немедленно становятся видимыми другим соединениям, потому что эти изменения
не могут быть немедленно написаны в двоичной журнал.</p>

<p><a href="#sysvar_binlog_direct_non_transactional_updates">
<code>binlog_direct_non_transactional_updates</code></a>
предлагает одно возможное обходное решение этой проблемы.
По умолчанию эта переменная отключена. Включение
<a href="#sysvar_binlog_direct_non_transactional_updates"><code>
binlog_direct_non_transactional_updates</code></a> делает так, что
обновления нетранзакционных таблиц будут написаны непосредственно
двоичному журналу, а не операционному кэшу.</p>

<p><span><em><a href="#sysvar_binlog_direct_non_transactional_updates">
<code>binlog_direct_non_transactional_updates</code></a>
работает только для запросов, которые копируются, используя основанный на
запросе двоичной формат журналирования</em></span>,
то есть, это работает только когда значение
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>
<code>STATEMENT</code> или <code>MIXED</code> и данный запрос копируется,
используя основанный на запросе формат. Эта переменная не имеет никакого
эффекта, когда двоичной формат журнала <code>ROW</code> или
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>
<code>MIXED</code> и данный запрос копируется, используя основанный
на строке формат.</p>

<p>Прежде, чем включить эту переменную, Вы должны удостовериться, что нет
никаких зависимостей между транзакционными и нетранзакционными таблицами,
примером такой зависимости был бы запрос <code>INSERT INTO myisam_table
SELECT * FROM innodb_table</code>. Иначе такие запросы, вероятно, заставят
ведомое устройство отклоняться от ведущего устройства.</p>
<p>В MySQL 8.0 эта переменная не имеет никакого эффекта, когда двоичный
формат журнала <code>ROW</code> или <code>MIXED</code> (Bug #51291).</li>

<li><a name="sysvar_binlog_error_action"></a>
<a href="#sysvar_binlog_error_action"><code>binlog_error_action
</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog_error_action[=value]</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_error_action">binlog_error_action</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>IGNORE_ERROR</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2">
<code>IGNORE_ERROR</code></td></tr>
<tr><td scope="row" colspan="2"><code>ABORT_SERVER</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ABORT_SERVER</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>IGNORE_ERROR
</code></td></tr>
<tr><td scope="row" colspan="2"><code>ABORT_SERVER</code></td>
</tr></tbody></table>

<p>Средство управления, что происходит, когда сервер сталкивается с ошибкой,
такой как неспособность написать, сбросить или синхронизировать двоичный
журнал, что может заставить журнал ведущего устройства становиться
непоследовательным и ведомые устройства репликации потерять синхронизацию.
</p>

<p>Значение по умолчанию <code>ABORT_SERVER</code>
заставляет сервер остановить журналирование и закрыться всякий раз, когда это
сталкивается с такой ошибкой с двоичным журналом.
На перезапуске сервера переданы все ранее готовые и зарегистрированные
транзакции, в то время как любые транзакции, которые были подготовлены, но не
зарегистрированы из-за ошибки прерваны.</p>

<p>Когда <code>binlog_error_action</code> = <code>IGNORE_ERROR</code>,
если сервер сталкивается с такой ошибкой, это продолжает транзакцию,
регистрирует ошибку, останавливает журналирование и продолжает выполнять
обновления. ЧСтобы возобновить двоичное журналирование
<a href="#sysvar_log_bin"><code>log_bin</code></a>
должен быть включен снова. Это предоставляет обратную совместимость с
более старыми версиями MySQL.</p>

<p>В предыдущих выпусках эту переменную называли
<a href="#sysvar_binlogging_impossible_mode"><code>
binlogging_impossible_mode</code></a>.</li>

<li><a name="sysvar_binlog_format"></a>
<a href="#sysvar_binlog_format"><code>binlog_format</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-format=format</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_format">binlog_format</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ROW</code></td></tr>
<tr><td scope="row" rowspan="3" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>ROW
</code></td></tr>
<tr><td scope="row" colspan="2"><code>STATEMENT</code></td></tr>
<tr><td scope="row" colspan="2"><code>MIXED</code></td></tr></tbody></table>

<p>Эта переменная устанавливает двоичный формат журналирования и может быть
любым значением из <code>STATEMENT</code>, <code>ROW</code> или
<code>MIXED</code>. См. <a href="#replication-formats">раздел
19.2.1</a>. <a href="#sysvar_binlog_format"><code>binlog_format
</code></a> установлена <a href="server.htm#option_mysqld_binlog-format">
<code>--binlog-format</code></a> при запуске или
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>
во время выполнения.</p>

<p>В то время как Вы можете изменить формат журналирования во время
выполнения, <span><em>не</em></span> рекомендуется, чтобы Вы изменили это в
то время, как репликация работает.</p>

<p>Значение по умолчанию <code>ROW</code>.</p>
<p>Вы должны иметь привилегию <a href="security.html#priv_super"><code>SUPER
</code></a>, чтобы установить глобальное или сеансовое значение
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>.
</p>

<p>Управление правилами, когда изменения этой переменной вступают в силу и
сколько времени эффект длится, является тем же самым, что касается других
системных переменных сервера MySQL. Для получения дополнительной информации
см. <a href="sql.htm#set-variable">раздел 14.7.4.1</a>.</p>

<p>Когда указано <code>MIXED</code>, основанная на запросе репликация
используется, за исключением случаев, где только основанная на строке
репликация приведет к надлежащим результатам. Например, это происходит, когда
запросы содержат определяемые пользователем функции (UDF) или
<a href="funct.htm#function_uuid"><code>UUID()</code></a>.
Исключение к этому правилу: <code>MIXED</code> всегда использует основанную
на запросе репликацию для сохраненных функций и триггеров.</p>

<p>Есть исключения, когда Вы не можете переключить формат репликации
во время выполнения:</p>
<ul><li><p>Изнутри сохраненной функции или триггера.</li>

<li>Если сеанс в настоящее время находится в основанном на строке режиме
репликации и имеет открытые временные таблицы.</li>
<li>Изнутри транзакции.</p></li></ul>

<p>Попытка переключить формат в тех случаях приводит к ошибке.</p>
<p>Двоичный формат журнала затрагивает поведение
следующих параметров сервера:</p>

<ul><li><p><a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a></li>
<li><a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a></li>
<li><a href="#option_mysqld_binlog-do-db"><code>
--binlog-do-db</code></a></li>
<li><a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db</code></a></p></li></ul>
<p>Эти эффекты обсуждены подробно в описаниях отдельных опций.</li>

<li><a name="sysvar_binlog_group_commit_sync_delay"></a>
<a href="#sysvar_binlog_group_commit_sync_delay"><code>
binlog_group_commit_sync_delay</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-group-commit-sync-delay=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_group_commit_sync_delay">
binlog_group_commit_sync_delay</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000000</code></td></tr></tbody></table>

<p>Средство управления, сколько микросекунд двоичный журнал ждет прежде, чем
синхронизировать файл системного журнала с диском. По умолчанию
<a href="#sysvar_binlog_group_commit_sync_delay"><code>
binlog-group-commit-sync-delay</code></a> = 0, означая, что нет никакой
задержки. Установка <a href="#sysvar_binlog_group_commit_sync_delay">
<code>binlog-group-commit-sync-delay</code></a>
к микросекундной задержке позволяет большему количеству транзакций быть
синхронизированным вместе с диском сразу, уменьшая полное время, чтобы
передать группу транзакций, потому что более многочисленные группы требуют
меньшего количества единиц времени на группу. С правильной настройкой это
может увеличить ведомую работу, не ставя под угрозу пропускную
способность ведущего устройства.</li>

<li><a name="sysvar_binlog_group_commit_sync_no_delay_count"></a>
<a href="#sysvar_binlog_group_commit_sync_no_delay_count"><code>
binlog_group_commit_sync_no_delay_count</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-group-commit-sync-no-delay-count=#</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_group_commit_sync_no_delay_count">
binlog_group_commit_sync_no_delay_count</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1000000</code></td></tr></tbody></table>

<p>Максимальное количество транзакций, чтобы ждать прежде,
чем прервать текущую задержку как определено
<code>binlog-group-commit-sync-delay</code>. Если
<code>binlog-group-commit-sync-delay</code> = 0,
эта опция не имеет никакого эффекта.</li>

<li><a name="sysvar_binlogging_impossible_mode"></a>
<a href="#sysvar_binlogging_impossible_mode"><code>
binlogging_impossible_mode</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.7.6</td></tr>
<tr><td scope="row"><span><strong>Командная строка</strong></span></td>
<td colspan="3"><code>--binlogging_impossible_mode[=value]</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlogging_impossible_mode">
binlogging_impossible_mode</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>IGNORE_ERROR</code></td></tr>
<tr><td scope="row" rowspan="2" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>IGNORE_ERROR
</code></td></tr>
<tr><td scope="row" colspan="2"><code>ABORT_SERVER</code></td>
</tr></tbody></table>

<p>Эта опция устарела и будет удалена в будущем выпуске MySQL. Используйте
<a href="#sysvar_binlog_error_action"><code>binlog_error_action
</code></a>, чтобы управлять, что происходит, когда сервер не может
написать двоичный журнал.</li>

<li><a name="sysvar_binlog_max_flush_queue_time"></a>
<a href="#sysvar_binlog_max_flush_queue_time"><code>
binlog_max_flush_queue_time</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.7.9</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_max_flush_queue_time">
binlog_max_flush_queue_time</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>100000</code></td></tr></tbody></table>

<p>Прежде, это управляло временем в микросекундах, чтобы продолжить
читать транзакции из очереди потока прежде, чем продолжение группы передано.
В MySQL 8.0 эта переменная больше не имеет эффекта.</p>
<p><code>binlog_max_flush_queue_time</code> устарела в MySQL 5.7.9,
и отмечена для возможного удаления в будущем выпуске MySQL.</li>

<li><a name="sysvar_binlog_order_commits"></a>
<a href="#sysvar_binlog_order_commits"><code>binlog_order_commits
</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_order_commits">binlog_order_commits</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Когда эта переменная включена на ведущем устройстве (значение по
умолчанию), транзакции воплощены в том же самом порядке, как они написаны
двоичному журналу. Если отключено, транзакции могут быть переданы
параллельно. В некоторых случаях отключение этой переменной могло бы
произвести улучшение производительности.</li>

<li><a name="sysvar_binlog_row_image"></a>
<a href="#sysvar_binlog_row_image"><code>binlog_row_image</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-row-image=image_type</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
binlog_row_image=image_type</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>full</code></td></tr>
<tr><td scope="row" rowspan="3" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>full</code>
(Зарегистрировать все столбцы.)</td></tr>
<tr><td scope="row" colspan="2"><code>minimal</code>
(Зарегистрировать только измененные столбцы
и столбцы, нужные чтобы идентифицировать строки.)</td></tr>
<tr><td scope="row" colspan="2"><code>noblob</code> (Зарегистрировать все
столбцыLog, за исключением ненужных столбцов BLOB и TEXT.)
</td></tr></tbody></table>

<p>В основанной на строке репликации каждый случай изменения строки содержит
два образа: <span><span>до</span></span>, столбцы которого являются
соответствующими при поиске строки, которая будет обновлена, и
<span><span>после</span></span>, содержащий изменения. Обычно MySQL
регистрирует все строки (то есть, все столбцы) для обоих образов.
Однако, не строго необходимо включать каждый столбец в оба образа
и мы можем часто сэкономить диск, память и сеть, регистрируя только те
столбцы, которые фактически требуются.</p>

<p>Удаляя строку, только исходный вид записи зарегистрирован,
так как нет никаких измененных значений после удаления. Вставляя строку,
образ записан только после, так как нет никакой существующей строки, которая
будет соответствующей. Только обновление строки требует образов прежде и
после, и оба написаны в двоичный журнал.</p>

<p>Для исходного вида записи необходимо только, чтобы минимальный набор
столбцов, требуемых, чтобы уникально идентифицировать строки, был
зарегистрирован. Если у таблицы, содержащей строку, есть первичный ключ, то
только столбец первичного ключа (или столбцы) написаны в двоичный журнал.
Иначе, если у таблицы есть уникальный ключ, у которого все столбцы <code>NOT
NULL</code>, только столбцы в уникальнои ключе зарегистрированы.
Если у таблицы нет ни первичного, ни уникального ключа без столбцов
<code>NULL</code>, все столбцы должны использоваться в исходном виде записи и
зарегистрированы. В образе после необходимо зарегистрировать только столбцы,
которые фактически изменились.</p>

<p>Вы можете заставить сервер регистрировать все или минимальные строки,
используя <code>binlog_row_image</code>. Эта переменная фактически берет одно
из трех возможных значений, как показано в следующем списке:</p>

<ul><li><p><code>full</code>: Зарегистрировать все столбцы в
образах до и после.</li>
<li><code>minimal</code>: Зарегистрировать только те столбцы в исходном виде
записи, которые обязаны идентифицировать строку, которая будет изменена,
регистрировать только те столбцы в образе после, которые фактически изменены.
</li>

<li><code>noblob</code>: Аналог <code>full</code>, кроме
<a href="types.htm#blob"><code>BLOB</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>, которые не обязаны
идентифицировать строки или не изменились.</p></li></ul>

<p>Значение по умолчанию <code>full</code>.</p>
<p>Применяя <code>minimal</code> или <code>noblob</code>
удаления и обновления будут работать правильно с данной таблицей, если и
только если следующие условия истина для источника и для целевых таблиц:</p>

<ul><li><p>Все столбцы должны присутствовать и в том же самом порядке,
каждый столбец должен использовать тот же самый тип данных
в качестве своего коллеги в другой таблице.</li>
<li>У таблиц должны быть идентичные определения первичного ключа.
</p></li></ul>

<p>Другими словами, таблицы должны быть идентичными с возможным исключением
индексов, которые не являются частью первичных ключей таблиц.</p>
<p>Если эти условия не соблюдаются, возможно, что значения столбцов
первичного ключа в целевой таблице могут оказаться недостаточными, чтобы
обеспечить уникальное соответствие для удаления или обновления.
В этом случае никакое предупреждение или ошибка не выпущены, ведущее и
ведомое устройства тихо отклоняются, таким образом ломая последовательность.
</p>

<p>Установка этой переменной не имеет никакого эффекта, когда двоичной формат
журналирования <code>STATEMENT</code>. Когда
<a href="#sysvar_binlog_format"><code>binlog_format</code>
</a> = <code>MIXED</code>, <code>binlog_row_image</code>
применена к изменениям, которые зарегистрированы, используя основанный на
строке формат, но эта установка не имеет никакого эффекта на изменения,
зарегистрированные как запросы.</p>

<p>Установка <code>binlog_row_image</code> на глобальном уровне или на уровне
сеанса не вызывает неявной передачи, это означает, что эта переменная может
быть изменена в то время, как транзакция происходит,
не затрагивая транзакцию.</li>

<li><a name="sysvar_binlog_rows_query_log_events"></a>
<code>binlog_rows_query_log_events</code></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_rows_query_log_events">
binlog_rows_query_log_events</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p><a href="#sysvar_binlog_rows_query_log_events"><code>
binlog_rows_query_log_events</code></a>
затрагивает только основанное на строке журналирование.
Когда включено, это заставляет MySQL Server писать информационные события
журнала, такие как события журнала запроса строки в его двоичной журнал.
Эта информация может использоваться для отладки и связанных целей,
такой как получение оригинального запроса, выпущенного на ведущем устройстве,
когда это не может быть восстановлено из обновлений строки.</p>

<p>Эти события обычно игнорируются программами MySQL, читая двоичный журнал
и не вызывают проблемы, копируя или восстанавливая от резервного копирования.
Чтобы рассмотреть их, увеличьте уровень подробностей при использовании
опции <a href="programs.htm#option_mysqlbinlog_verbose"><code>--verbose
</code></a> в mysqlbinlog дважды, например,
"-vv" или "--verbose --verbose".</li>

<li><a name="sysvar_binlog_stmt_cache_size"></a>
<a href="#sysvar_binlog_stmt_cache_size"><code>
binlog_stmt_cache_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog_stmt_cache_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_stmt_cache_size">binlog_stmt_cache_size
</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>32768</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>32768</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr></tbody></table>

<p>Эта переменная определяет размер кэша для двоичного журнала, чтобы считать
нетранзакционные запросы выпущенными во время транзакции. Кэш запроса
выделен для каждого клиента, если сервер поддерживает какие-либо
транзакционные механизмы хранения и если у сервера есть двоичной включенный
журнал (<a href="#option_mysqld_log-bin"><code>--log-bin</code>
</a>). Если Вы часто используете большие нетранзакционные запросы во время
транзакций, Вы можете увеличить этот размер кэша, чтобы получить лучшую
работу. <a href="server.htm#statvar_Binlog_stmt_cache_use"><code>
Binlog_stmt_cache_use</code></a> и
<a href="server.htm#statvar_Binlog_stmt_cache_disk_use"><code>
Binlog_stmt_cache_disk_use</code></a>
могут быть полезными для настройки размера этой переменной. См.
<a href="server.htm#binary-log">раздел 6.4.4</a>.</p>
<p><a href="#sysvar_binlog_cache_size"><code>binlog_cache_size
</code></a> устанавливает размер для операционного кэша.</li>

<li><a name="sysvar_log_bin"></a>
<a href="#sysvar_log_bin"><code>log_bin</code></a></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_bin">log_bin</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr></tbody></table>

<p>Включен ли двоичной журнал. Если
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>
используется, тогда значение этой переменной <code>ON</code>, иначе
<code>OFF</code>. Эта переменная сообщает только относительно состояния
журналирования (включено или отключено), это не сообщает о значении
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>.
</p>
<p>См. <a href="server.htm#binary-log">раздел 6.4.4</a>.</li>

<li><a name="sysvar_log_bin_basename"></a>
<a href="#sysvar_log_bin_basename"><code>log_bin_basename</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_bin_basename">log_bin_basename</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>datadir + '/' + hostname + '-bin'</code></td>
</tr></tbody></table>

<p>Имя и полный путь к двоичному файлу системного журнала. В отличие от
<a href="#sysvar_log_bin"><code>log_bin</code></a>,
<a href="#sysvar_log_bin_basename"><code>log_bin_basename</code>
</a> отражает имя, заданное опцией
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>.</li>

<li><a name="sysvar_log_bin_index"></a>
<a href="#sysvar_log_bin_index"><code>log_bin_index</code></a></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_bin_index">log_bin_index</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>file name
</code></td></tr></tbody></table>
<p>Индексный файл для файла двоичного системного журнала.</li>

<li><a name="sysvar_log_bin_use_v1_row_events"></a>
<a href="#sysvar_log_bin_use_v1_row_events"><code>
log_bin_use_v1_row_events</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--log-bin-use-v1-row-events[={0|1}]</code>
</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_bin_use_v1_row_events">
log_bin_use_v1_row_events</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr></tbody></table>

<p>Используется ли журналирование Version 2. Значение 1 указывает, что сервер
пишет двоичной журнал, используя события журналирования
Version 1 (единственная версия двоичных событий журнала, используемая в
предыдущих выпусках), и таким образом производит двоичный журнал, который
может быть считан более старыми ведомыми устройствами.
0 указывает, что события журнала используют Version 2.</p>

<p>Эта переменная только для чтения. Чтобы переключиться между
журналированием Version 1 и Version 2, необходимо перезапустить
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
с опцией <a href="#option_mysqld_log-bin-use-v1-row-events">
<code>--log-bin-use-v1-row-events</code></a>.</li>

<li><a name="sysvar_log_slave_updates"></a>
<a href="#sysvar_log_slave_updates"><code>log_slave_updates</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--log-slave-updates</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_slave_updates">log_slave_updates</a></code>
</td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Должны ли обновления, полученные ведомым сервером от главного
быть зарегистрированы в собственном двоичном журнале ведомого устройства.
Двоичное журналирование должно быть позволено на ведомом устройстве для
работы этой переменной. См.
<a href="#replication-options">раздел 19.1.6</a>.</li>

<li><a name="sysvar_log_statements_unsafe_for_binlog"></a>
<a href="#sysvar_log_statements_unsafe_for_binlog"><code>
log_statements_unsafe_for_binlog</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_log_statements_unsafe_for_binlog">
log_statements_unsafe_for_binlog</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>ON</code></td></tr></tbody></table>
<p>Если ошибка 1592 происходит, добавлены ли произведенные предупреждения к
журналу ошибок или нет.</li>

<li><a name="sysvar_master_verify_checksum"></a>
<a href="#sysvar_master_verify_checksum"><code>
master_verify_checksum</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_master_verify_checksum">master_verify_checksum
</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr></tbody></table>

<p>Включение этой переменной заставляет ведущее устройство исследовать
контрольные суммы, читая из двоичного журнала.
<code>master_verify_checksum</code> отключена по умолчанию, в этом случае
ведущее устройство использует длину событий от двоичного журнала, чтобы
проверить события, чтобы только полные события были считаны
из двоичного журнала.</li>

<li><a name="sysvar_max_binlog_cache_size"></a>
<a href="#sysvar_max_binlog_cache_size"><code>
max_binlog_cache_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--max_binlog_cache_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_max_binlog_cache_size">max_binlog_cache_size</a>
</code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709551615</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Если транзакция требует больше этого числа байтов памяти, сервер
производит ошибку <span>Multi-statement transaction required more than
'max_binlog_cache_size' bytes of storage</span>.
Минимальное значение 4096. Максимальное 16EB (exabytes).
Максимальное рекомендуемое значение 4GB, это следствие того,
что MySQL в настоящее время не может работать с двоичными позициями
журнала больше 4GB.</p>

<p><code>max_binlog_cache_size</code> устанавливает размер для операционного
кэша, верхним пределом для кэша запроса управляет
<a href="#sysvar_max_binlog_stmt_cache_size">
<code>max_binlog_stmt_cache_size</code></a>.</p>

<p>В MySQL 8.0 видимость к сеансам <code>max_binlog_cache_size</code>
соответствует <a href="#sysvar_binlog_cache_size"><code>
binlog_cache_size</code></a>, другими словами, изменение значения
действует только на новые сеансы, которые запущены после изменения.</li>

<li><a name="sysvar_max_binlog_size"></a>
<a href="#sysvar_max_binlog_size"><code>max_binlog_size</code>
</a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--max_binlog_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_max_binlog_size">max_binlog_size</a></code></td>
</tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>1073741824</code></td></tr></tbody></table>

<p>Если запись в двоичный журнал заставляет текущий размер файла системного
журнала превышать значение этой переменной, сервер ротирует
двоичные журналы (закрывает текущий файл и открывает следующий). Минимальное
значение составляет 4096 байтов. Максимальное и значение по умолчанию 1GB.
</p>

<p>Транзакция написана в одном куске в двоичный журнал, таким образом, это
никогда не разделяется между несколькими двоичными журналами. Поэтому, если у
Вас есть большие транзакции, Вы могли бы видеть двоичные файлы системного
журнала, больше <a href="#sysvar_max_binlog_size"><code>
max_binlog_size</code></a>.</p>

<p>Если <a href="server.htm#sysvar_max_relay_log_size"><code>
max_relay_log_size</code></a> = 0,
<a href="#sysvar_max_binlog_size"><code>max_binlog_size</code></a>
относится также к журналам реле.</li>

<li><a name="sysvar_max_binlog_stmt_cache_size"></a>
<a href="#sysvar_max_binlog_stmt_cache_size"><code>
max_binlog_stmt_cache_size</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--max_binlog_stmt_cache_size=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_max_binlog_stmt_cache_size">
max_binlog_stmt_cache_size</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>18446744073709547520</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>4096</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>18446744073709547520</code></td></tr></tbody></table>

<p>Если нетранзакционные запросы в пределах транзакции требуют больше,
чем это количество памяти, сервер производит ошибку. Минимальное значение
4096. Максимальные и значения по умолчанию 4GB на 32-битовых платформах и
16EB (exabytes) на 64-битовых платформах.</p>

<p><code>max_binlog_stmt_cache_size</code> устанавливает размер только для
кэша запроса, верхним пределом для операционного кэша управляет исключительно
<a href="#sysvar_max_binlog_cache_size">
<code>max_binlog_cache_size</code></a>.</li>

<li><a name="sysvar_sync_binlog"></a>
<a href="#sysvar_sync_binlog"><code>sync_binlog</code></a></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--sync-binlog=#</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code
><a href="#sysvar_sync_binlog">sync_binlog</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (32-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span> (64-bit platforms)</td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Средство управления числом групп двоичного журнала, чтобы собрать
прежде, чем синхронизировать двоичный журнал с диском. Когда
<a href="#sysvar_sync_binlog"><code>sync_binlog=0</code></a>,
двоичный журнал никогда не синхронизируется с диском, когда
<a href="#sysvar_sync_binlog"><code>sync_binlog</code></a>
больше 0, это число групп журнала периодически синхронизируется. Когда
<a href="#sysvar_sync_binlog"><code>sync_binlog=1</code></a>,
все транзакции синхронизированы с двоичным журналом прежде, чем они будут
переданы. Поэтому даже в случае неожиданного перезапуска, любые транзакции,
которые отсутствуют в двоичном журнале, находятся только в готовом состоянии.
Это заставляет автоматическую подпрограмму восстановления сервера удалять те
транзакции.Это гарантирует, что никакая транзакция не потеряна из двоичного
журнала и является самой безопасной. Однако у этого может быть негативное
воздействие на работу из-за увеличенного числа записей на диск.
Использование более высокого значения улучшает работу, но с увеличенным
риском потери данных.</p>

<p>Когда <a href="#sysvar_sync_binlog"><code>sync_binlog=0</code>
</a> или <a href="#sysvar_sync_binlog"><code>sync_binlog</code>
</a> больше 1, транзакции переданы, не будучи синхронизированными с
диском. Поэтому в случае перебоя в питании или катастрофического отказа
операционной системы, возможно, что сервер передал некоторые транзакции,
которые не были синхронизированы с двоичным журналом. Поэтому для
подпрограммы восстановления невозможно возвратить эти транзакции и они будут
потеряны из двоичного журнала.</p>

<p>Значение по умолчанию <a href="#sysvar_sync_binlog"><code>
sync_binlog</code></a> = 1 является самым безопасным выбором, но, как
отмечено выше, может воздействовать на работу.</p>

<p>До MySQL 5.7.7 значение по умолчанию было 0, которое
не конфигурирует синхронизацию, в этом случае сервер полагается на
операционную систему, чтобы время от времени сбросить
содержание двоичного журнала.</p></li></ul>

<h4><a name="replication-options-gtids"></a>19.1.6.5.
Опции и переменные глобального операционного ID</h4>
<h5><a name="replication-optvars-gtids"></a>
Опции запуска, используемые с репликацией GTID</h5>
<p>Следующие опции запуска сервера используются с GTID-репликацией:</p>

<ul><li><p><a name="option_mysqld_enforce-gtid-consistency"></a>
<code>--enforce-gtid-consistency</code></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--enforce-gtid-consistency[=value]</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_enforce_gtid_consistency">
enforce_gtid_consistency</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="3" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>ON</code></td></tr>
<tr><td scope="row" colspan="2"><code>WARN</code></td></tr></tbody></table>

<p>Когда включено, сервер проводит в жизнь последовательность GTID,
позволяя выполнение только запросов, которые могут быть безопасно
зарегистрированы, используя GTID. Вы <span><em>должны</em></span> установить
эту опцию в <code>ON</code> прежде, чем включить GTID-репликацию.</p>

<p>Значения <a href="#option_mysqld_enforce-gtid-consistency">
<code>--enforce-gtid-consistency</code></a>
может быть сконфигурировано к:</p>

<ul><li><p><code>OFF</code>: всем транзакциям позволяют
нарушить последовательность GTID.</li>
<li><code>ON</code>: никакой транзакции не позволяют
нарушить последовательность GTID.</li>
<li><code>WARN</code>: всем транзакциям позволяют нарушить последовательность
GTID, но предупреждение произведено в этом случае.</p></li></ul>

<p>Установка <a href="#option_mysqld_enforce-gtid-consistency">
<code>--enforce-gtid-consistency</code></a>
без значения это псевдоним для
<a href="#option_mysqld_enforce-gtid-consistency"><code>
--enforce-gtid-consistency=ON</code></a>.
Это воздействует на поведение переменной, см.
<a href="#sysvar_enforce_gtid_consistency"><code>
enforce_gtid_consistency</code></a>.</p>

<p>Только запросы, которые могут быть зарегистрированы, используя GTID,
могут быть зарегистрированы, когда
<a href="#sysvar_enforce_gtid_consistency"><code>
enforce-gtid-consistency</code></a> = <code>ON</code>,
таким образом, операции, перечисленные здесь, не могут
использоваться с этой опцией:</p>

<ul><li><p><a href="sql.htm#create-table-select"><code>
CREATE TABLE ... SELECT</code></a>.</li>
<li><a href="sql.htm#create-table"><code>CREATE TEMPORARY TABLE</code></a>
или <a href="sql.htm#drop-table"><code>DROP TEMPORARY TABLE
</code></a> в транзакциях.</li>

<li>Транзакции или запросы, которые обновляют транзакционные и
нетранзакционные таблицы. Есть исключение, что нетранзакционный DML позволен
в той же самой транзакции или в том же самом запросе, как транзакционный DML,
если все <span><em>нетранзакционные</em></span> таблицы являются временными.
</p></li></ul>
<p>См. <a href="#replication-gtids-restrictions">
раздел 19.1.3.4</a>.</li>

<li><a name="option_mysqld_executed-gtids-compression-period"></a>
<a href="#option_mysqld_executed-gtids-compression-period"><code>
--executed-gtids-compression-period</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.7.6</td></tr>
<tr><td scope="row"><span><strong>Командная строка</strong></span></td>
<td colspan="3"><code>--executed-gtids-compression-period=#</code></td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>
<p>Эта опция устарела и будет удалена в будущем выпуске MySQL. Используйте
gtid_executed_compression_period.</li>

<li><a name="option_mysqld_gtid-mode"></a><code>--gtid-mode</code></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--gtid-mode=MODE</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_mode">gtid_mode</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code>
</td></tr>
<tr><td scope="row" colspan="2"><code>OFF_PERMISSIVE</code></td></tr>
<tr><td scope="row" colspan="2"><code>ON_PERMISSIVE</code></td></tr>
<tr><td scope="row" colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Эта опция определяет, используются ли глобальные операционные
идентификаторы (GTID), чтобы идентифицировать транзакции. Установка этой
опции в <a href="#option_mysqld_gtid-mode"><code>--gtid-mode=ON
</code></a> требует <a href="#option_mysqld_enforce-gtid-consistency">
<code>enforce-gtid-consistency</code></a> = <code>ON</code>.
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
переменная является динамической и позволяет репликации GTID быть
сконфигурированной онлайн. Перед использованием этой особенности см.
<a href="#replication-mode-change-online">раздел 19.1.5</a>.</li>

<li><a name="option_mysqld_gtid-executed-compression-period"></a>
<a href="#option_mysqld_gtid-executed-compression-period"><code>
--gtid-executed-compression-period</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--gtid-executed-compression-period=#</code>
</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Сжать таблицу <code>mysql.gtid_executed</code> каждое указанное число
транзакций. Установка 0 говорит, что эта таблица не сжата. Никакое сжатие
таблицы не происходит, когда двоичное журналирование включено, поэтому опция
не имеет никакого эффекта, если
<a href="#sysvar_log_bin"><code>log_bin</code></a> =
<code>OFF</code>.</p></li></ul>

<h5><a name="replication-sysvars-gtids"></a>
Системные переменные, используемые с репликацией GTID</h5>
<p>Следующие системные переменные используются с GTID-репликацией:</p>
<ul><li><p><a name="sysvar_binlog_gtid_simple_recovery"></a>
<a href="#sysvar_binlog_gtid_simple_recovery"><code>
binlog_gtid_simple_recovery</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--binlog-gtid-simple-recovery</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_binlog_gtid_simple_recovery">
binlog_gtid_simple_recovery</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2">
<code>boolean</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>TRUE</code></td></tr></tbody></table>

<p>Эта переменная управляет, как двоичные файлы системного журнала повторены
во время поиска GTID, когда MySQL запускается или перезапускается.</p>
<p>Когда <a href="#sysvar_binlog_gtid_simple_recovery"><code>
binlog_gtid_simple_recovery=FALSE</code></a>,
метод повторения двоичных файлов системного журнала:</p>

<ul><li><p>Чтобы инициализировать <a href="#sysvar_gtid_executed">
<code>gtid_executed</code></a>, файлы системного журнала повторены от
новейшего файла, останавливаясь в первом двоичном журнале, у которого есть
любой <code>Previous_gtids_log_event</code>. Все GTID из
<code>Previous_gtids_log_event</code> и <code>Gtid_log_events</code>
считаны из этого двоичного файла системного журнала. Этот набор GTID сохранен
внутренне и назван <code>gtids_in_binlog</code>. Значение
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
вычислено как союз этого набора и GTID, сохраненного в таблице
<code>mysql.gtid_executed</code>.</p>

<p>Этот процесс может занять много времени, если у Вас большое количество
двоичных файлов системного журнала без событий GTID, например, создаваемых,
когда <a href="#sysvar_gtid_mode"><code>gtid_mode=OFF</code></a>.
</li>

<li>Чтобы инициализировать <a href="#sysvar_gtid_purged"><code>
gtid_purged</code></a>, двоичные файлы системного журнала повторены от самого
старого до новейшего, останавливаясь на первом двоичном журнале, который
содержит любой <code>Previous_gtids_log_event</code>, который не пуст (у
которого есть по крайней мере один GTID), или у этого есть по крайней мере
один <code>Gtid_log_event</code>. От этого двоичного журнала это читает
<code>Previous_gtids_log_event</code>. Этот набор GTID вычтен из
<code>gtids_in_binlog</code> и результат сохранен во внутренней переменной
<code>gtids_in_binlog_not_purged</code>. Значение
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>
инициализировано к значению
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
минус <code>gtids_in_binlog_not_purged</code>.</p></li></ul>

<p>Когда <a href="#sysvar_binlog_gtid_simple_recovery"><code>
binlog_gtid_simple_recovery=TRUE</code></a>, что является значением по
умолчанию, сервер повторяет только самый старый и новейший двоичные файлы
системного журнала и значения
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a> и
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
вычислены, базируясь только на <code>Previous_gtids_log_event</code> или
<code>Gtid_log_event</code>, найденных в этих файлах. Это гарантирует, что
только два двоичных файла системного журнала повторены во время перезапуска
сервера или когда двоичные журналы очищаются.</p>

<p>Если эта опция включена,
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a> и
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>
могут быть инициализированы неправильно в следующих ситуациях:</p>

<ul><li><p>Новейший двоичный журнал был произведен MySQL 5.7.5 или более
старый, и <a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
<code>ON</code> для некоторых двоичных журналов, но
<code>OFF</code> для новейшего двоичного журнала.</li>

<li><code>SET GTID_PURGED</code> был сделан на версии MySQL до 5.7.7, и
двоичной журнал, который был активным во время
<code>SET GTID_PURGED</code> еще не был очищен.</p></li></ul>

<p>Если неправильный набор GTID будет вычислен в любой ситуации, то останется
неправильным, даже если сервер будет позже перезапущен, независимо от
значения этой опции.</p></li>

<li><a name="sysvar_enforce_gtid_consistency"></a>
<code>enforce_gtid_consistency</code></p>
<table border="1">
<tbody><tr><td scope="row"><span><strong>Командная строка</strong></span>
</td><td colspan="3"><code>--enforce-gtid-consistency[=value]</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_enforce_gtid_consistency">
enforce_gtid_consistency</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="3" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2">
<code>OFF</code></td></tr>
<tr><td scope="row" colspan="2"><code>ON</code></td></tr>
<tr><td scope="row" colspan="2"><code>WARN</code></td></tr></tbody></table>

<p>В зависимости от значения этой переменной сервер проводит в жизнь
последовательность GTID, позволяя выполнение только запросов, которые
могут быть безопасно зарегистрированы, используя GTID. Вы
<span><em>должны</em></span> установить эту переменную в
<code>ON</code> прежде, чем включить GTID-репликацию.</p>

<p>Значение <a href="#sysvar_enforce_gtid_consistency"><code>
enforce_gtid_consistency</code></a> может быть сконфигурирован к:</p>
<ul><li><p><code>OFF</code>: всем транзакциям позволяют
нарушить последовательность GTID.</li>

<li><code>ON</code>: никакой транзакции не позволяют
нарушить последовательность GTID.</li>
<li><code>WARN</code>: всем транзакциям позволяют нарушить последовательность
GTID, но предупреждение произведено в этом случае.</p></li></ul>

<p>До MySQL 5.7.6 <a href="#sysvar_enforce_gtid_consistency">
<code>enforce-gtid-consistency</code></a> по умолчанию была <code>OFF</code>.
Чтобы поддержать совместимость с предыдущими версиями, в MySQL 5.7.6 значение
по умолчанию <code>OFF</code> и
<a href="#option_mysqld_enforce-gtid-consistency"><code>
--enforce-gtid-consistency</code></a> без значения интерпретируется как
установка значения <code>ON</code>. У переменной также есть многократные
текстовые псевдонимы для значений: <code>0=OFF=FALSE</code>,
<code>1=ON=TRUE</code>,<code>2=WARN</code>. Это отличается от другого
перечисления, но поддерживает совместимость с булевым типом, используемым в
предыдущих версиях. Эти изменения воздействуют на то, что возвращено
переменной. Используя <code>SELECT @@ENFORCE_GTID_CONSISTENCY</code>,
<code>SHOW VARIABLES LIKE 'ENFORCE_GTID_CONSISTENCY'</code> и
<code>SELECT * FROM INFORMATION_SCHEMA.VARIABLES WHERE
'VARIABLE_NAME' = 'ENFORCE_GTID_CONSISTENCY'</code>, все возвращается в
текстовой форме, не числовой. Это несовместимое изменение, с тех пор как
<code>@@ENFORCE_GTID_CONSISTENCY</code> возвращает числовую форму для
boolean, но возвращает текстовую форму для
<code>SHOW</code> и Information Schema.</li>

<li><a name="sysvar_executed_gtids_compression_period"></a>
<a href="#sysvar_executed_gtids_compression_period"><code>
executed_gtids_compression_period</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.7.6</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_executed_gtids_compression_period">
executed_gtids_compression_period</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Эта опция устарела и будет удалена в будущем выпуске MySQL. Используйте
<a href="#sysvar_gtid_executed_compression_period"><code>
gtid_executed_compression_period</code></a>.</li>

<li><a name="sysvar_gtid_executed"></a>
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_executed">gtid_executed</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_executed">gtid_executed</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Когда используется с глобальным контекстом, эта переменная содержит
представление набора всех транзакций, выполненных на сервере и GTID, которые
были установлены <a href="sql.htm#set-variable"><code>SET</code></a>
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>.
Это то же самое, как значение столбца <code>Executed_Gtid_Set</code> в
<a href="sql.htm#show-master-status"><code>SHOW MASTER STATUS</code></a> и
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.
Значение этой переменной набор GTID.</p>

<p>Когда сервер запускается, <code>@@global.gtid_executed</code>
инициализирована. GTID тогда добавлены к набору, поскольку транзакции
выполнены, или если выполнен любой
<a href="sql.htm#set-variable"><code>SET</code></a>
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>.</p>

<p>Набор транзакций, которые могут быть найдены в двоичных журналах в
любой момент времени, равен
<a href="funct.htm#function_gtid-subtract"><code>
GTID_SUBTRACT(@@global.gtid_executed, @@global.gtid_purged)</code></a>,
то есть, всем транзакциям в двоичном журнале, которые еще не были очищены.
</p>

<p><a href="sql.htm#reset-master"><code>RESET MASTER</code></a>
заставляет глобальное значение (но не значение сеанса) этой переменной быть
сброшенным к пустой строке. GTID иначе не удалены из этого набора кроме того,
когда набор очищен из-за <code>RESET MASTER</code>.</p>

<p>До MySQL 5.7.7 эта переменная могла также использоваться с контекстом
сеанса, где это содержало представление набора транзакций, которые написаны
кэшу в текущем сеансе. Контекст сеанса устарел в MySQL 5.7.7.</li>

<li><a name="sysvar_gtid_executed_compression_period"></a>
<a href="#sysvar_gtid_executed_compression_period"><code>
gtid_executed_compression_period</code></a></p>

<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_executed_compression_period">
gtid_executed_compression_period</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="4"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>integer
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>1000</code></td></tr>
<tr><td scope="row"><span><strong>Минимум</strong></span></td>
<td colspan="2"><code>0</code></td></tr>
<tr><td scope="row"><span><strong>Максимум</strong></span></td>
<td colspan="2"><code>4294967295</code></td></tr></tbody></table>

<p>Сжать таблицу <code>mysql.gtid_executed</code> каждые раз, когда
выполнено число транзакций, заданных переменной. Установка 0 указывает,
что эта таблица не сжата. Так как никакое сжатие таблицы не происходит, когда
используется двоичный журнал, установка значение переменной не имеет никакого
эффекта, если двоичное журналирование не отключено.</p></li>

<li><a name="sysvar_gtid_mode"></a>
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_mode">gtid_mode</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="6"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>OFF</code></td></tr>
<tr><td scope="row" rowspan="4" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2"><code>OFF</code></td>
</tr>
<tr><td scope="row" colspan="2"><code>OFF_PERMISSIVE</code></td></tr>
<tr><td scope="row" colspan="2"><code>ON_PERMISSIVE</code></td></tr>
<tr><td scope="row" colspan="2"><code>ON</code></td></tr></tbody></table>

<p>Средство управления, включено до GTID-журналирование и какие транзакции
журналы могут содержать. До MySQL 5.7.6 эти переменные были только для чтения
и были установлены, используя
<a href="#option_mysqld_gtid-mode"><code>--gtid-mode</code></a>.
MySQL 5.7.6 позволяет этой переменной быть установленной динамически. Вы
должны иметь привилегию <a href="security.html#priv_super"><code>SUPER</code>
</a>, чтобы установить эту переменную.
<a href="#sysvar_enforce_gtid_consistency"><code>
enforce_gtid_consistency</code></a> должна быть истина прежде, чем Вы сможете
установить <a href="#sysvar_gtid_mode"><code>gtid_mode=ON</code>
</a>. Прежде чем изменить эту переменную, см.
<a href="#replication-mode-change-online">раздел 19.1.5</a>.</p>

<p>Зарегистрированные транзакции могут быть анонимными или использовать GTID.
Анонимные транзакции полагаются на двоичной файл системного журнала и
позицию, чтобы идентифицировать определенные транзакции.
У транзакций GTID есть уникальный идентификатор, который используется, чтобы
обратиться к транзакциям. Различные режимы:</p>

<ul><li><p><code>OFF</code>: Новые и копируемые транзакции
должны быть анонимными.</li>
<li><code>OFF_PERMISSIVE</code>: Новые транзакции являются анонимными.
Копируемые транзакции могут быть анонимными или транзакциями GTID.</li>

<li><code>ON_PERMISSIVE</code>: Новые транзакции GTID. Копируемые транзакции
могут быть анонимными или транзакциями GTID.</li>
<li><code>ON</code>: Новые и копируемые транзакции должны
быть транзакциями GTID.</p></li></ul>

<p>Изменения от одного значения до другого могут быть только пошаговыми
за один раз. Например, если
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a> сейчас
<code>OFF_PERMISSIVE</code>, возможно изменить на <code>OFF</code> или
<code>ON_PERMISSIVE</code>, но не на <code>ON</code>.</p>

<p><a href="#sysvar_gtid_purged"><code>gtid_purged</code></a> и
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
являются постоянными независимо от значения
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>.
Поэтому даже после изменения
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
эти переменные содержат правильные значения.</li>

<li><a name="sysvar_gtid_next"></a>
<a href="#sysvar_gtid_next"><code>gtid_next</code></a></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_next">gtid_next</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Session</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row" rowspan="5"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>enumeration
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>AUTOMATIC</code></td></tr>
<tr><td scope="row" rowspan="3" valign="top"><span><strong>
Допустимые значения</strong></span></td><td colspan="2">
<code>AUTOMATIC</code></td></tr>
<tr><td scope="row" colspan="2"><code>ANONYMOUS</code></td></tr>
<tr><td scope="row" colspan="2"><code>UUID:NUMBER</code></td>
</tr></tbody></table>

<p>Эта переменная используется, чтобы определить,
как следующий GTID получен. <code>gtid_next</code> может взять
любое из следующих значений:</p>

<ul><li><p><code>AUTOMATIC</code>: Используйте следующее автоматически
произведенное глобальное операционное ID.</li>
<li><code>ANONYMOUS</code>: Транзакции не имеют глобальных идентификаторов
и идентифицированы только файлом и позицией.</li>
<li>Глобальное операционное ID в формате
<em><code>UUID</code></em>:<em><code>NUMBER</code></em>.</p></li></ul>

<p>Точно то, какие из вышеупомянутых опций допустимы, зависит от установки
setting of <a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>,
см. <a href="#replication-mode-change-online-concepts">
раздел 19.1.5.1</a>. Установка этой переменной не имеет никакого эффекта,
если <a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>
<code>OFF</code>.</p>

<p>После того, как эта переменная была установлена в
<em><code>UUID</code></em>:<em><code>NUMBER</code></em>
и транзакция была передана или удалена, явное <code>SET GTID_NEXT</code>
должно снова быть сделано перед любым другим запросом.</p>

<p><a href="sql.htm#drop-table"><code>DROP TABLE</code></a> или
<a href="sql.htm#drop-table"><code>DROP TEMPORARY TABLE</code></a>
терпит неудачу с явной ошибкой, когда используется на комбинации
невременных таблиц с временными таблицами или временных таблиц, используя
транзакционные механизмы хранения с временными таблицами, используя
нетранзакционные механизмы хранения.</li>

<li><a name="sysvar_gtid_owned"></a>
<a href="#sysvar_gtid_owned"><code>gtid_owned</code></a></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_owned">gtid_owned</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная и сеансовая</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Эта переменная только для чтения содержит список, содержание которого
зависит от его контекста. Когда используется с контекстом сеанса, список
содержит все GTID, которые принадлежат этому клиенту, когда используется
с глобальным контекстом, это содержит список всех GTID с их владельцами.</li>

<li><a name="sysvar_gtid_purged"></a>
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a></p>
<table border="1">
<tbody><tr><td scope="row" rowspan="3"><span><strong>Системная</strong>
</span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_gtid_purged">gtid_purged</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Да</td></tr>
<tr><td scope="row"><span><strong>Допустимые значения</strong></span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>string</code>
</td></tr></tbody></table>

<p>Набор всех транзакций, которые были вычищены из
двоичного журнала. Это подмножество набора транзакций в
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>.
Значение этой переменной набор GTID.</p>

<p>Когда сервер запускается, глобальное значение
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>
инициализировано к ряду GTID. <a href="sql.htm#reset-master"><code>RESET
MASTER</code></a> заставляет значение этой переменной быть
сброшенным к пустой строке.</p>

<p>Возможно обновить значение этой переменной, но только когда
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>
пустая строка, и поэтому
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a>
пустая строка. Это может произойти когда репликация не была запущена ранее
или когда репликация ранее не использовала GTID.
Эта переменная устанавливается независимо от значения
<a href="#sysvar_gtid_mode"><code>gtid_mode</code></a>.</p>

<p>Если все существующие двоичные журналы были произведены, используя
MySQL 5.7.6 или позже, после <code>SET gtid_purged</code>
<a href="#sysvar_binlog_gtid_simple_recovery"><code>
binlog_gtid_simple_recovery=TRUE</code></a>
(настройка по умолчанию в MySQL 5.7.7 и позже) может безопасно
использоваться. Если двоичные журналы от MySQL 5.7.7 или ранее существуют,
есть шанс, что <a href="#sysvar_gtid_purged"><code>gtid_purged
</code></a> может быть вычислен неправильно. Если Вы используете MySQL 5.7.7
или ранее, после <code>SET gtid_purged</code>
запрос записывает текущее двоичное имя файла системного журнала, которое
может быть проверено, используя
<a href="sql.htm#show-master-status"><code>SHOW MASTER STATUS</code></a>.
Если сервер перезапущен прежде, чем этот файл был очищен, то Вы должны
использовать <a href="#sysvar_binlog_gtid_simple_recovery"><code>
binlog_gtid_simple_recovery=FALSE</code></a>, чтобы избегать неправильного
<a href="#sysvar_gtid_purged"><code>gtid_purged</code></a> или
<a href="#sysvar_gtid_executed"><code>gtid_executed</code></a>.
</p></li>

<li><a name="sysvar_simplified_binlog_gtid_recovery"></a>
<a href="#sysvar_simplified_binlog_gtid_recovery"><code>
simplified_binlog_gtid_recovery</code></a></p>

<table border="1">
<tbody><tr><td scope="row"><span><strong>Устаревшая</strong></span></td>
<td colspan="3">5.7.6</td></tr>
<tr><td scope="row"><span><strong>Командная строка</strong></span></td>
<td colspan="3"><code>--simplified-binlog-gtid-recovery</code></td></tr>
<tr><td scope="row" rowspan="3"><span><strong>Системная</strong></span></td>
<td><span><strong>Имя</strong></span></td><td colspan="2"><code>
<a href="#sysvar_simplified_binlog_gtid_recovery">
simplified_binlog_gtid_recovery</a></code></td></tr>
<tr><td scope="row"><span><strong>Контекст переменной</strong></span></td>
<td colspan="2">Глобальная</td></tr>
<tr><td scope="row"><span><strong>Динамическая</strong></span></td>
<td colspan="2">Нет</td></tr>
<tr><td scope="row" rowspan="2"><span><strong>Допустимые значения</strong>
</span></td>
<td><span><strong>Тип</strong></span></td><td colspan="2"><code>boolean
</code></td></tr>
<tr><td scope="row"><span><strong>Значение по умолчанию</strong></span></td>
<td colspan="2"><code>FALSE</code></td></tr></tbody></table>

<p>Эта опция устарела и будет удалена в будущем выпуске MySQL. Используйте
<a href="#sysvar_binlog_gtid_simple_recovery"><code>
binlog_gtid_simple_recovery</code></a>.</p></li></ul>

<h3><a name="replication-administration"></a>19.1.7.
Общие задачи управления репликацией</h3>
<p>Как только репликация был запущена, она выполняется, не требуя большого
регулярного вмешательства. Этот раздел описывает, как проверить состояние
репликации и как сделать паузу.</p>

<h4><a name="replication-administration-status"></a>19.1.7.1.
Проверка состояния репликации</h4>
<p>Наиболее распространенная задача, управления процессом репликации состоит
в том, чтобы гарантировать, что репликация имеет место и что не было никаких
ошибок между ведомым и ведущим устройствами. Основной запрос для этого
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>,
который Вы должны выполнить на каждом ведомом устройстве:
<pre>
mysql&gt; SHOW SLAVE STATUS\G
*************************** 1. row ***************************
 Slave_IO_State: Waiting for master to send event
Master_Host: master1
Master_User: root
Master_Port: 3306
Connect_Retry: 60
Master_Log_File: mysql-bin.000004
Read_Master_Log_Pos: 931
 Relay_Log_File: slave1-relay-bin.000056
Relay_Log_Pos: 950
Relay_Master_Log_File: mysql-bin.000004
 Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Replicate_Do_DB:
Replicate_Ignore_DB:
 Replicate_Do_Table:
 Replicate_Ignore_Table:
Replicate_Wild_Do_Table:
Replicate_Wild_Ignore_Table:
 Last_Errno: 0
 Last_Error:
 Skip_Counter: 0
Exec_Master_Log_Pos: 931
Relay_Log_Space: 1365
Until_Condition: None
 Until_Log_File:
Until_Log_Pos: 0
 Master_SSL_Allowed: No
 Master_SSL_CA_File:
 Master_SSL_CA_Path:
Master_SSL_Cert:
Master_SSL_Cipher:
 Master_SSL_Key:
Seconds_Behind_Master: 0
Master_SSL_Verify_Server_Cert: No
Last_IO_Errno: 0
Last_IO_Error:
 Last_SQL_Errno: 0
 Last_SQL_Error:
Replicate_Ignore_Server_Ids: 0
</pre>

<p>Поля из отчета о состоянии:</p>
<ul><li><p><code>Slave_IO_State</code>: Текущий статус ведомого устройства.
См. разделы <a href="optimiz.htm#slave-io-thread-states">9.14.5</a> и
<a href="optimiz.htm#slave-sql-thread-states">9.14.6</a>.</li>

<li><code>Slave_IO_Running</code>: Работает ли поток ввода/вывода для того,
чтобы считать двоичный журнал ведущего устройства. Обычно Вы хотите, чтобы
это было <code>Yes</code>, если Вы еще не запустили репликацию или явно
остановили ее с <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>.
</li>

<li><code>Slave_SQL_Running</code>: Работает ли поток SQL для того, чтобы
запустить события в журнале реле. Как с потоком ввода/вывода, это должно
обычно быть <code>Yes</code>.</li>

<li><code>Last_IO_Error</code>, <code>Last_SQL_Error</code>:
Последние ошибки, зарегистрированные вводом/выводом и SQL,
обрабатывая журнал реле. Идеально они должны быть пробелом, не указывая
ни на какие ошибки.</li>

<li><code>Seconds_Behind_Master</code>: Число секунд, на которые ведомый
поток SQL находится позади обработки основного двоичного журнала. Высокое
число (или увеличивающееся) может указать, что ведомое устройство неспособно
обработать события от ведущего устройства своевременно.</p>

<p>Значение 0 для <code>Seconds_Behind_Master</code>
может обычно интерпретироваться как то, что ведомое устройство догнало
ведущее устройство, но есть некоторые случаи, где это не строго истинно.
Например, это может произойти, если сетевое соединение между ведущим
устройством и ведомым устройством сломано, но ведомый поток ввода/вывода еще
не заметил этого, то есть,
<a href="#sysvar_slave_net_timeout"><code>
slave_net_timeout</code></a> еще не прошел.</p>

<p>Это также возможно тот переходный процесс значения для
<code>Seconds_Behind_Master</code> не отражает ситуацию точно. Когда ведомый
поток SQL нагнал во вводе/выводе, <code>Seconds_Behind_Master</code>
покажет 0,но когда ведомый поток ввода/вывода все еще держит в очереди
новое событие, <code>Seconds_Behind_Master</code> может показать большое
значение, пока поток SQL не заканчивает запуск события.
Это особенно вероятно, когда у событий есть старый timestamp, в таких
случаях, если Вы выполняете
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
несколько раз за относительно короткий период, Вы можете видеть, что это
значение изменяется назад и вперед неоднократно между 0 и
относительно большим значением.</p></li></ul>

<p>Несколько пар областей предоставляют информацию о продвижении ведомого
устройства в чтении событий от основного двоичного журнала и обработки
их в журнале реле:</p>

<ul><li><p>(<code>Master_Log_file</code>, <code>Read_Master_Log_Pos</code>):
Координаты в основном двоичном журнале, указывающем, как далеко ведомый поток
ввода/вывода считал события из журнала.</li>

<li>(<code>Relay_Master_Log_File</code>, <code>Exec_Master_Log_Pos</code>):
Координаты в основном двоичном журнале, указывающем, как далеко ведомый поток
SQL запустил события, полученные от журнала.</li>

<li>(<code>Relay_Log_File</code>, <code>Relay_Log_Pos</code>):
Координаты в ведомом журнале реле, указывающие,
как далеко ведомый поток SQL выполнил журнал реле.
Они соответствуют предыдущим координатам, но выражены в ведомых координатах
журнала реле, а не основных двоичных координатах журнала.</p></li></ul>

<p>На ведущем устройстве Вы можете проверить состояние соединенного ведомого
использованием <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a>, чтобы исследовать список выполнения процессов. Ведомые
соединения имеют <code>Binlog Dump</code> в поле <code>Command</code>:
<pre>
mysql&gt; SHOW PROCESSLIST \G;
*************************** 4. row ***************************
 Id: 10
 User: root
 Host: slave1:58371
 db: NULL
Command: Binlog Dump
 Time: 777
State: Has sent all binlog to slave; waiting for binlog to be updated
 Info: NULL
</pre>
<p>Поскольку это ведомое устройство, которое управляет процессом репликации,
очень небольшая информация доступна в этом отчете.</p>

<p>Для ведомых устройств, которые были запущены с опцией
<a href="#option_mysqld_report-host"><code>--report-host</code>
</a> и соединены с ведущим устройством, запрос
<a href="sql.htm#show-slave-hosts"><code>SHOW SLAVE HOSTS</code></a>
о ведущем устройстве показывает основную информацию о ведомых устройствах.
Вывод включает ID ведомого сервера, значение опции
<a href="#option_mysqld_report-host"><code>--report-host</code>
</a>, порт соединения и ID:
<pre>
mysql&gt; SHOW SLAVE HOSTS;
+-----------+--------+------+-------------------+-----------+
| Server_id | Host   | Port | Rpl_recovery_rank | Master_id |
+-----------+--------+------+-------------------+-----------+
| 10        | slave1 | 3306 | 0                 | 1         |
+-----------+--------+------+-------------------+-----------+
1 row in set (0.00 sec)
</pre>

<h4><a name="replication-administration-pausing"></a>19.1.7.2.
Пауза репликации на ведомом устройстве</h4>
<p>Вы можете остановить и запустить репликацию на ведомом устройстве,
используя <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> и
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>.</p>

<p>Чтобы прекратить обрабатывать двоичный журнал
от ведущего устройства, надо использовать
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>:
<pre>
mysql&gt; STOP SLAVE;
</pre>

<p>Когда репликация остановлена, ведомый поток ввода/вывода прекращает читать
события из основного двоичного журнала и писать их в журнал реле, а поток SQL
прекращает читать события из журнала реле и выполнять их. Вы можете сделать
паузу ввода/вывода или потока SQL индивидуально, определяя тип потока:
<pre>
mysql&gt; STOP SLAVE IO_THREAD;
mysql&gt; STOP SLAVE SQL_THREAD;
</pre>

<p>Чтобы запустить выполнение снова, используйте
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>:
<pre>
mysql&gt; START SLAVE;
</pre>

<p>Чтобы запустить особый поток, определите тип потока:
<pre>
mysql&gt; START SLAVE IO_THREAD;
mysql&gt; START SLAVE SQL_THREAD;
</pre>

<p>Для ведомого устройства, которое выполняет только обновления, обрабатывая
события от ведущего устройства, остановить только поток SQL, может быть
полезным, если Вы хотите выполнить резервное копирование или другую задачу.
Поток ввода/вывода продолжит читать события от ведущего устройства, но они не
выполнены. Это облегчает для ведомого устройства нагнать, когда Вы
перезапускаете поток SQL.</p>

<p>Остановка только потока ввода/вывода позволяет событиям в журнале реле
быть запущенными потоком SQL до того пункта, где журнал реле заканчивается.
Это может быть полезно, когда Вы хотите к выполнению паузы догнать события,
уже полученные от ведущего устройства, когда Вы хотите выполнить задачи
администрирования на ведомом устройстве, но также и гарантировать, что это
обработало все обновления отдельного момента. Этот метод может также
использоваться для паузы событий на ведомом устройстве, в то время как Вы
проводите администрирование на ведущем устройстве. Остановка потока
ввода/вывода, но разрешение потоку SQL работать помогает гарантировать, что
нет массивного отставания событий, которые будут выполнены, когда
репликация запущена снова.</p>

<h2><a name="replication-implementation"></a>19.2. Выполнение репликации</h2>
<p>Репликация основана на главном сервере, отслеживающем все изменения
его баз данных (обновления, удаления и так далее) в его двоичном журнале.
Двоичный журнал служит отчетом обо всех событиях, которые изменяют структуру
базы данных или контент (данные) с момента, когда сервер был запущен.
Как правило, <a href="sql.htm#select"><code>SELECT</code></a>
не зарегистрированы, потому что они не изменяют ни структуры базы
данных, ни контента.</p>

<p>Каждое ведомое устройство, которое соединяется с ведущим устройством,
просит копию двоичного журнала. Таким образом, это вытягивает данные от
ведущего устройства, а не ведущее устройство продвигает данные к ведомому
устройству. Ведомое устройство также запускает события от двоичного журнала,
который оно получает. Это имеет эффект повторения оригинальных изменений так
же, как они были сделаны на ведущем устройстве. Таблицы составлены или их
структура изменена, а данные вставлены, удалены и обновлены согласно
изменениям, которые были первоначально произведены на ведущем устройстве.</p>

<p>Поскольку каждое ведомое устройство независимо, переигрывание изменений
от двоичного журнала ведущего устройства происходит независимо на каждом
ведомом устройстве, которое соединено с ведущим устройством. Кроме того,
потому что каждое ведомое устройство получает копию двоичного журнала, только
прося это от ведущего устройства, ведомое устройство в состоянии считать и
обновить копию базы данных в собственном темпе и может запустить и остановить
процесс репликации по желанию, не затрагивая способность обновиться к
последнему состоянию базы данных на основной или на ведомой стороне.</p>
<p>См. <a href="#replication-implementation-details">
раздел 19.2.2</a>.</p>

<p>Ведущие и ведомые устройства сообщают о своем состоянии относительно
процесса репликации регулярно так, чтобы Вы могли контролировать их. См.
<a href="optimiz.htm#thread-information">раздел 9.14</a>.</p>

<p>Основной двоичный журнал написан местному журналу реле на
ведомом устройстве прежде, чем это будет обработано. Ведомое устройство также
делает запись информации о текущей позиции в двоичным журнале ведущего
устройства и местном журнале реле. См. <a href="#slave-logs">
раздел 19.2.4</a>.</p>

<p>Изменения базы данных фильтруются на ведомом устройстве согласно
ряду правил, которые применены согласно различным параметрам конфигурации
и переменным оценки управления событиями. Для деталей о том, как эти правила
применены см. <a href="#replication-rules">раздел 19.2.5</a>.</p>

<h3><a name="replication-formats"></a>19.2.1. Форматы репликации</h3>
<p>Репликация работает, потому что события, написанные
двоичному журналу, считаны от ведущего устройства и затем обработаны на
ведомом устройстве. События зарегистрированы в пределах двоичного журнала
в различных форматах, согласно типу события. Различные используемые форматы
репликации соответствуют двоичному формату журналирования, используемому,
когда события были зарегистрированы в двоичном журнале ведущего устройства.
Корреляция между двоичными форматами журналирования и терминами,
использованными во время репликации:</p>

<ul><li><p>Используя основанное на запросе двоичное журналирование, ведущее
устройство пишет запросы SQL в двоичный журнал. Репликация ведущего
устройства к ведомому устройству работает, выполняя запросы SQL о ведомом
устройстве. Это называют <span>основанной на запросе репликацией</span>
(часто сокращаемой как <span> <span>SBR</span>), что соответствует
стандартному MySQL основанному на запросе двоичному формату журналирования.
Репликация в версии MySQL 5.1.4 и ранее использует этот формат исключительно.
</li>

<li>Используя основанное на строке журналирование, ведущее устройство пишет
<span>события</span> в двоичный журнал, которые указывают, как изменены
отдельные строки таблицы. Репликация ведущего устройства к ведомому
устройству работает, копируя события, представляющие изменения строк таблицы
к ведомому устройству. Это называют <span>основанной на строке репликацией
</span> (часто сокращенной как <span>RBR</span>).</p>

<p>Основанное на строке журналирование это метод по умолчанию.</li>
<li>Вы можете также сконфигурировать MySQL, чтобы использовать соединение
основанного на запросе и основанного на строке журналирования,
в зависимости от того, что является самым подходящим для изменения, которое
будет зарегистрировано. Это называют <span>журналированием смешанного формата
</span>. Используя журналирование смешанного формата, основанный на запросе
журнал используется по умолчанию. В зависимости от определенных запросов и
используемого механизма хранения, журнал автоматически переключен на
основанный на строке в особых случаях. Репликация используя смешанный формат
часто упоминается как <span>репликация смешанного формата</span>. Для
получения дополнительной информации см.
<a href="server.htm#binary-log-mixed">раздел 6.4.4.3</a>.</p></li></ul>

<p>Используя формат <code>MIXED</code>, двоичный формат журналирования
определен частично используемым механизмом хранения и выполняемым запросом.
Для получения дополнительной информации о журналировании смешанного формата и
правилах, управляющих поддержкой различных форматов журналирования см.
<a href="server.htm#binary-log-mixed">раздел 6.4.4.3</a>.</p>

<p>Форматом журналирования в рабочем сервере MySQL управляют, устанавливая
переменную <a href="#sysvar_binlog_format"><code>binlog_format
</code></a>. Эта переменная может быть установлена с сеансовым
или глобальным контекстом. Управление правилами, когда и как новая установка
вступает в силу, является тем же самым, что касается других переменных,
установка переменной для текущего сеанса длится только до конца этого сеанса
и изменение невидимо другим сеансам, установка переменной глобально требует
перезапуска сервера. См. <a href="sql.htm#set-variable">раздел 14.7.4.1</a>.
</p>

<p>Есть условия, при которых Вы не можете изменить двоичной формат
журналирования во время выполнения, см.
<a href="server.htm#binary-log-setting">раздел 6.4.4.2</a>.</p>

<p>Вы должны иметь привилегию <a href="security.html#priv_super"><code>SUPER
</code></a>, чтобы установить глобальное или сеансовое значение
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>.
</p>

<p>У основанных на запросе и основанных на строке форматов репликации есть
другие вопросы и ограничения. Для сравнения их относительных преимуществ и
недостатков см. <a href="#replication-sbr-rbr">раздел 19.2.1.1
</a>.</p>

<p>С основанной на запросе репликацией Вы можете столкнуться с проблемами с
мультиплицированием сохраненных подпрограмм или триггеров. Вы можете избежать
этих проблем при использовании основанной на строке репликации вместо этого.
Для получения дополнительной информации см.
<a href="stored.htm#stored-programs-logging">раздел 21.7</a>.</p>

<h4><a name="replication-sbr-rbr"></a>19.2.1.1.
Преимущества и недостатки основанной на запросе и строке репликации</h4>
<p>У каждого двоичного формата журналирования есть преимущества и недостатки.
Для большинства пользователей смешанный формат репликации должен обеспечить
лучшую комбинацию целостности данных и работы. Если, однако, Вы хотите
использовать в своих интересах особенности, определенные для основанного на
запросе или основанного на строке формата репликации, выполняя определенные
задачи, Вы можете использовать информацию в этом разделе,
который обеспечивает резюме их относительных преимуществ и недостатков, чтобы
определить, что лучше для Ваших потребностей.</p>

<h5><a name="replication-sbr-rbr-sbr-advantages"></a>
Преимущества основанной на запросе репликации</h5>
<ul><li><p>Доказанная технология.</li>
<li>Меньше данных, написанных файлам системного журнала.
Когда обновления или удаления обрабатывают много строк, это приводит к
<span><em>намного</em></span> меньшему количеству места для хранения,
требуемого для файлов системного журнала. Это также означает, что взятие и
восстановление от резервных копий могут быть достигнуты более быстро.</li>

<li>Файлы системного журнала содержат все запросы, которые производили
любые изменения, таким образом, они могут использоваться, чтобы
ревизовать базу данных.</p></li></ul>

<h5><a name="replication-sbr-rbr-sbr-disadvantages"></a>
Недостатки основанной на запросе репликации</h5>
<ul><li><p><b>Запросы, которые опасны для SBR. </b>
Не все запросы, которые изменяют данные (например,
<a href="sql.htm#insert"><code>INSERT</code></a>
<a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#replace"><code>REPLACE</code></a>)
могут копироваться, используя основанную на запросе репликацию. Любое
недетерминированное поведение трудно копировать, используя основанную на
запросе репликацию. Примеры такой ситуации это запросы Data
Modification Language (DML):</p>

<ul><li><p>Запрос, который зависит от UDF или сохраненной программы, которая
недетерминирована, начиная со значения, возвращенного таким UDF или
сохраненной программой, или зависит от факторов кроме параметров. Основанная
на строке репликация, однако, просто копирует значение, возвращенное UDF или
сохраненной программой, таким образом, ее эффект на строки таблицы и данные
тот же самый на ведущем и на ведомом устройстве. См.
<a href="#replication-features-invoked">раздел 19.4.1.12</a>.</li>

<li><a href="sql.htm#delete"><code>DELETE</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>, использующие
<code>LIMIT</code> без <code>ORDER BY</code> недетерминированы. См.
<a href="#replication-features-limit">раздел 19.4.1.17</a>.</li>

<li>Детерминированный UDF должен быть применен на ведомом устройстве.</li>
<li>Запросы, использующие любую из следующих функций, не могут копироваться
должным образом, используя основанную на запросе репликацию:</p>

<ul><li><p><a href="funct.htm#function_load-file"><code>LOAD_FILE()</code>
</a></li>
<li><a href="funct.htm#function_uuid"><code>UUID()</code></a>,
<a href="funct.htm#function_uuid-short"><code>UUID_SHORT()</code></a></li>
<li><a href="funct.htm#function_user"><code>USER()</code></a></li>
<li><a href="funct.htm#function_found-rows"><code>FOUND_ROWS()</code></a>
</li>

<li><a href="funct.htm#function_sysdate"><code>SYSDATE()</code></a>
(если и ведущее устройство и ведомое устройство не запущены с
<a href="server.htm#option_mysqld_sysdate-is-now">
<code>--sysdate-is-now</code></a>).</li>

<li><a href="funct.htm#function_get-lock"><code>GET_LOCK()</code></a></li>
<li><a href="funct.htm#function_is-free-lock"><code>IS_FREE_LOCK()</code></a>
</li>
<li><a href="funct.htm#function_is-used-lock"><code>IS_USED_LOCK()</code></a>
</li>
<li><a href="funct.htm#function_master-pos-wait"><code>MASTER_POS_WAIT()
</code></a></li>
<li><a href="funct.htm#function_rand"><code>RAND()</code></a></li>
<li><a href="funct.htm#function_release-lock"><code>RELEASE_LOCK()</code></a>
</li>
<li><a href="funct.htm#function_sleep"><code>SLEEP()</code></a></li>
<li><a href="funct.htm#function_version"><code>VERSION()</code></a>
</p></li></ul>

<p>Однако, все другие функции копируются, правильно используя основанную на
запросе репликацию, включая <a href="funct.htm#function_now"><code>NOW()
</code></a>.</p>
<p>См. <a href="#replication-features-functions">раздел 19.4.1.16
</a>.</p></li></ul>

<p>Запросы, которые не могут копироваться правильно, используя основанную на
запросе репликацию, зарегистрированы с предупреждением, как показано здесь:
<pre>
[Warning] Statement is not safe to log in statement format.
</pre>

<p>Подобное предупреждение также выпущено клиенту в таких случаях.
Клиент может вывести на экран это с использованием
<a href="sql.htm#show-warnings"><code>SHOW WARNINGS</code></a>.</li>

<li><a href="sql.htm#insert"><code>INSERT ... SELECT</code></a>
требует большего числа блокировок на уровне строки,
чем с основанной на строке репликацией.</li>

<li><a href="sql.htm#update"><code>UPDATE</code></a>, которые требуют
сканирования таблицы (потому что индекс не используется в
<code>WHERE</code>), должны заблокировать большее число строк, чем с
основанной на строке репликацией.</li>

<li>Для <a href="innodb.htm"><code>InnoDB</code></a>:
<a href="sql.htm#insert"><code>INSERT</code></a>, который использует
<code>AUTO_INCREMENT</code>, блокировка не конфликтует с
<a href="sql.htm#insert"><code>INSERT</code></a>.</li>

<li>Для сложных запросов запрос должен быть оценен и выполнен на
ведомом устройстве прежде, чем строки будут обновлены или вставлены.
С основанной на строке репликацией ведомое устройство должно изменить только
затронутые строки, а не выполнить полный запрос.</li>

<li>Если есть ошибка в оценке на ведомом устройстве, особенно выполняя
сложные запросы, основанная на запросе репликация может медленно увеличивать
предел погрешности через затронутые строки в течение долгого времени. См.
<a href="#replication-features-slaveerrors">раздел 19.4.1.28</a>.
</li>

<li>Сохраненные функции выполняются с тем же самым значением
<a href="funct.htm#function_now"><code>NOW()</code></a>, как при вызове.
Однако, это неверно для хранимых процедур.</li>

<li>Детерминированный UDF должен быть применен на ведомом устройстве.</li>
<li>Табличные определения должны быть (почти) идентичными на ведущем
и ведомом устройстве. См.
<a href="#replication-features-differing-tables">
раздел 19.4.1.10</a>.</p></li></ul>

<h5><a name="replication-sbr-rbr-rbr-advantages"></a>
Преимущества основанной на строке репликации</h5>
<ul><li><p>Все изменения могут копироваться.
Это самая безопасная форма репликации.</p>

<p>Запросы, которые обновляют информацию в базе данных
<code>mysql</code>, например,
<a href="sql.htm#grant"><code>GRANT</code></a>,
<a href="sql.htm#revoke"><code>REVOKE</code></a> и манипуляции триггерами,
сохраненными подпрограммами (включая хранимые процедуры) и представлениями,
все копируются к ведомым устройствам, используя основанную
на запросе репликацию.</p>

<p>Для запросов <a href="sql.htm#create-table"><code>CREATE TABLE
... SELECT</code></a>, a <code>CREATE</code>
запрос произведен из табличного определения и копируется, используя
основанный на запросе формат, в то время как вставки строки копируются,
используя основанный на строке формат.</p></li>

<li>Меньше блокировок строки требуется на ведущем устройстве, которое
таким образом достигает более высокого параллелизма, для
следующих типов запросов:</p>

<ul><li><p><a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>
</li>
<li><a href="sql.htm#insert"><code>INSERT</code></a> с
<code>AUTO_INCREMENT</code>.</li>

<li><a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a> с <code>WHERE</code>,
которые не используют ключи или не изменяют большинство исследованных строк.
</p></li></ul></li>

<li>Меньше блокировок строки требуется на ведомом устройстве для любого
запроса <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>.</p></li></ul>

<h5><a name="replication-sbr-rbr-rbr-disadvantages"></a>
Недостатки основанной на строке репликации</h5>
<ul><li><p>RBR может произвести больше данных, которые должны быть
зарегистрированы. Чтобы копировать запрос DML
(<a href="sql.htm#update"><code>UPDATE</code></a> или
<a href="sql.htm#delete"><code>DELETE</code></a>),
основанная на запросе репликация пишет только запрос двоичному журналу. В
отличие от этого, основанная на строке репликация пишет каждую измененную
строку двоичному журналу. Если запрос изменяет много строк, основанная на
строке репликация может написать значительно больше данных, это истина даже
для запросов, которые отменены. Это также означает, что создание и
восстановление резервного копирования могут потребовать большего количества
времени. Кроме того, двоичной журнал заблокирован в течение более длительного
времени, чтобы написать данные, которые могут вызвать проблемы параллелизма.
Использование <a href="#sysvar_binlog_row_image"><code>
binlog_row_image=minimal</code></a> значительно уменьшает этот недостаток.
</li>

<li>Детерминированные UDF, которые производят большие
<a href="types.htm#blob"><code>BLOB</code></a> занимают больше времени, чтобы
копировать с основанной на строке репликацией, чем с основанной на запросе
репликацией. Это потому, что зарегистрировано значение столбца
<a href="types.htm#blob"><code>BLOB</code></a>, а не
запрос, производящий данные.</li>

<li>Вы не можете видеть на ведомом устройстве, какие запросы были получены от
ведущего устройства и выполнены. Однако, Вы можете видеть, какие данные были
изменены, используя <a href="programs.htm#mysqlbinlog"><span>
<strong>mysqlbinlog</strong></span></a> с опциями
<a href="programs.htm#option_mysqlbinlog_base64-output"><code>
--base64-output=DECODE-ROWS</code></a> и
<a href="programs.htm#option_mysqlbinlog_verbose"><code>--verbose</code></a>.
</p>

<p>Альтернативно используйте <a href="#sysvar_binlog_rows_query_log_events">
<code>binlog_rows_query_log_events</code></a>, которая если включена
добавляет событие с <code>Rows_query</code> к выводу
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a>, когда используется <code>-vv</code>.</li>

<li>Для таблиц, используя <a href="storage.htm#myisam-storage-engine"><code>
MyISAM</code></a>, более сильная блокировка требуется на ведомом устройстве
для <a href="sql.htm#insert"><code>INSERT</code></a>, применяя их как
основанные на строке события к двоичному журналу, чем применяя их как
запросы. Это означает что параллельные вставки на таблицах
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>
не поддержаны, используя основанную на строке репликацию.</p></li></ul>

<h4><a name="replication-rbr-usage"></a>19.2.1.2.
Использование основанного на строке журналирования и репликации</h4>
<p>MySQL использует основанное на запросе журналирование (SBL),
основанное на строке журналирование (RBL) или журналирование смешанного
формата. Тип двоичного журнала определяет размер и эффективность
журналирования. Поэтому выбор между основанной на строке репликацией (RBR)
или основанной на запросе репликацией (SBR) зависит от Вашего приложения и
окружающей среды. Этот раздел описывает известные проблемы, используя
основанный на строке формат журнала и описывает некоторые лучшие методы,
используя это в репликации.</p>

<ul><li><p><a name="replication-rbr-usage-temptables"></a><b>
Основанное на строке журналирование временных таблиц. </b>
Как отмечено в <a href="#replication-features-temptables">
разделе 19.4.1.24</a>, временные таблицы не копируются, используя основанный
на строке формат. Когда идет использование смешанного журналирования формата,
<span><span>безопасные</span></span> запросы, вовлекающие временные таблицы,
зарегистрированы, используя основанный на запросе формат.
Для получения дополнительной информации см.
<a href="#replication-sbr-rbr">раздел 19.2.1.1</a>.</p>

<p>В MySQL 8.0 Вы можете переключиться с основанного на запросе на
основанное на строке журналирование, даже когда временные таблицы были
составлены. Однако, используя основанный на строке формат, сервер MySQL не
может определить режим журналирования, который был в действительности, когда
данная временная таблица была составлена. Поэтому сервер в таких случаях
регистрирует запрос <a href="sql.htm#drop-table"><code>DROP TEMPORARY
TABLE IF EXISTS</code></a> для каждой временной таблицы, которая все еще
существует для данного сеанса клиента, когда сеанс заканчивается. В то время
как это означает, что возможно, что ненужный <code>DROP TEMPORARY TABLE
</code> мог бы быть зарегистрирован в некоторых случаях, запрос безопасен и
не вызывает ошибку, даже если таблица не существует из-за присутствия
<code>IF EXISTS</code> опции.</p>

<p>Временные таблицы не копируются, используя основанный на строке формат,
потому что нет никакой потребности. Кроме того, потому что временные таблицы
могут быть только для чтения для потока, который создал их, редко есть
какая-либо выгода из мультиплицирования их, используя основанный
на запросе формат.

<p>Нетранзакционные запросы DML, вовлекающие временные таблицы, позволены,
используя <a href="#sysvar_binlog_format"><code>binlog_format=ROW
</code></a>, пока любые нетранзакционные таблицы, затронутые запросами,
являются временными таблицами (Bug #14272672).</li>

<li><b>RBL и синхронизация нетранзакционных таблиц. </b>
Когда много строк затронуты, набор изменений разделен на несколько событий;
когда запрос передается, все эти события написаны двоичному журналу. Выполняя
на ведомом устройстве, табличная блокировка взята на всех вовлеченных
таблицах, затем строки применены в пакетном режиме.
В зависимости от механизма, используемого для копии ведомого устройства
таблицы, это может быть неэффективно.</li>

<li><b>Время ожидания и размер журнала. </b>
RBL пишет изменения для каждой строки к двоичному журналу и таким образом
его размер может увеличиться быстро. Это может значительно увеличить время,
требуемое, чтобы производить изменения на ведомом устройстве, которые
соответствуют изменениям на ведущем устройстве. Вы должны знать о потенциале
для этой задержки Ваших приложений.</li>

<li><b>Чтение двоичного журнала. </b>
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> выводит на экран основанные на строке события в двоичном журнале,
используя <code>BINLOG</code> (см. <a href="sql.htm#binlog">раздел 14.7.6.1
</a>). Этот запрос выводит на экран событие как закодированную строку,
значение которой не очевидно. Когда вызвано с
<a href="programs.htm#option_mysqlbinlog_base64-output"><code>
--base64-output=DECODE-ROWS</code></a> и
<a href="programs.htm#option_mysqlbinlog_verbose"><code>--verbose</code></a>,
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> форматирует содержание двоичного журнала, чтобы быть удобочитаемым.
Когда двоичные события журнала были написаны в основанном на строке формате,
и Вы хотите читать их, можете использовать эту команду, чтобы считать
содержание двоичного журнала. См.
<a href="programs.htm#mysqlbinlog-row-events">раздел 5.6.8.2</a>.</li>

<li><b>Ошибки выполнения журнала и slave_exec_mode. </b>
Если <a href="#sysvar_slave_exec_mode"><code>slave_exec_mode
</code></a> = <code>IDEMPOTENT</code>,
нельзя применить изменения от RBL, потому что оригинальная строка не может
быть найдена, не вызывает ошибку или заставляет репликацию терпеть неудачу.
Это означает, что возможно, что обновления применены на ведомом
устройстве так, чтобы ведущее и ведомое устройства больше не были
синхронизированы. Проблемы времени ожидания и использование нетранзакционных
таблиц с RBR, когда <a href="#sysvar_slave_exec_mode"><code>
slave_exec_mode</code></a> = <code>IDEMPOTENT</code>
может заставить ведущее и ведомое устройства отклоняться еще далее. Для
получения дополнительной информации о
<a href="#sysvar_slave_exec_mode"><code>slave_exec_mode</code>
</a> см. <a href="server.htm#server-system-variables">раздел 6.1.5</a>.</p>

<p><a href="#sysvar_slave_exec_mode"><code>
slave_exec_mode=IDEMPOTENT</code></a> вообще полезно только для круговой
репликации или мультирепликации с MySQL Cluster, для которой
<code>IDEMPOTENT</code> значение по умолчанию.</p>

<p>Для других сценариев установка
<a href="#sysvar_slave_exec_mode"><code>slave_exec_mode</code></a>
в <code>STRICT</code> обычно достаточна, это значение по умолчанию для
механизмов хранения кроме
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>.</p>

<p><a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDBCLUSTER</code></a>
в настоящее время не поддерживается в MySQL 8.0. См.
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top">MySQL Cluster NDB 7.5</a>.</li>

<li><b>Нехватка контрольных сумм журнала. </b>RBL не использует контрольные
суммы, так сеть, диск и другие ошибки не могут быть идентифицированы,
обрабатывая двоичной журнал. Чтобы гарантировать, что данные переданы без
сетевого повреждения, используют SSL для соединений репликации.
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
имеет опции, чтобы включить репликации по SSL. См. также
<a href="sql.htm#change-master-to">раздел 14.4.2.1</a>.</li>

<li><b>Фильтрация, основанная на ID сервера, не поддержана. </b>
В MySQL 8.0 Вы можете фильтровать основываясь на ID при использовании
<code>IGNORE_SERVER_IDS</code> в <a href="sql.htm#change-master-to"><code>
CHANGE MASTER TO</code></a>. Эта опция работает с основанным на запросе и
основанным на строке форматами журналирования. Другой метод, чтобы
отфильтровать изменения на некоторых ведомых устройствах должен использовать
<code>WHERE</code>, который включает отношение
<code>@@server_id &lt;&gt; <em><code>id_value</code></em></code> с
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>. Например,
<code>WHERE @@server_id &lt;&gt; 1</code>.
Однако, это не работает правильно с основанным на строке журналированием.
Используйте переменную <a href="server.htm#sysvar_server_id"><code>server_id
</code></a> для фильтрации запросов, используя основанное
на запросе журналирование.</li>

<li><b>Опции репликации на уровне базы данных. </b>Действие опций
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a>,
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a> и
<a href="#option_mysqld_replicate-rewrite-db"><code>
--replicate-rewrite-db</code></a>
отличается значительно в зависимости от типа журналирования. Поэтому
рекомендуется избежать опций на уровне базы данных и вместо этого
использовать опции на уровне таблицы, например,
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table</code></a> и
<a href="#option_mysqld_replicate-ignore-table"><code>
--replicate-ignore-table</code></a>. См.
<a href="#replication-options">раздел 19.1.6</a>.</li>

<li><b>RBL, нетранзакционные таблицы и остановленные ведомые устройства. </b>
Используя основанное на строке журналирование, если ведомый сервер
остановлен, в то время как ведомый поток обновляет нетранзакционную таблицу,
ведомая база данных может достигнуть непоследовательного состояния.
Поэтому рекомендуется, чтобы Вы использовали транзакционной механизм
хранения, такой как <a href="innodb.htm"><code>InnoDB</code></a>
для всех таблиц, копируемых, используя основанный на строке формат.
Использование <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> или
<a href="sql.htm#stop-slave"><code>STOP SLAVE SQL_THREAD</code></a>
до закрытия ведомого сервера MySQL помогает препятствовать тому, чтобы
проблемы произошли, и всегда рекомендуется независимо от формата
журналирования или механизма хранения, который Вы используете.</p></li></ul>

<h4><a name="replication-rbr-safe-unsafe"></a>19.2.1.3.
Определение безопасных и опасных запросов в двоичном журналировании</h4>
<p>Безопасность запросов в репликации MySQL обращается к тому, могут ли
запрос и его эффекты копироваться правильно, используя основанный на запросе
формат. Если это верно для запроса, мы ссылаемся на запрос как на
<span>безопасный</span>, иначе как на <span>опасный</span>.</p>

<p>Вообще, запрос безопасен, если он детерминированный, и опасный, если это
не так. Однако, определенные недетерминированные функции
<span><em>не</em></span> считают опасными. Кроме того, запросы используя
следствия математики с плавающей запятой, являются определенными аппаратными
средствами, их всегда считают опасными (см.
<a href="#replication-features-floatvalues">раздел 19.4.1.13</a>).
</p>

<p><b>Обработка безопасных и опасных запросов. </b>Запрос обработан
по-разному в зависимости от того, считают ли запрос безопасным и относительно
двоичного формата журналирования (то есть, текущего значения
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>).
</p>

<ul><li><p>Используя основанное на строке журналирование, никакое различие не
сделано в обработке безопасных и опасных запросов.</li>
<li>Используя журналирование смешанного формата, запросы, отмеченные как
опасные, зарегистрированы, используя основанный на строке формат,
запросы, расцененные как безопасные,
зарегистрированы, используя основанный на запросе формат.</li>

<li>Используя основанное на запросе журналирование, запросы, отмеченные как
опасные, производят предупреждение с этой целью. Безопасные
запросы обычно регистрируются.</p></li></ul>

<p>Каждый запрос, отмеченный как опасный, производит предупреждение.
Прежде, если бы большое количество таких запросов было выполнено на ведущем
устройстве, то это могло бы привести к чрезмерно большим файлам журнала
ошибок. Чтобы предотвратить это, MySQL 5.7 обеспечивает механизм подавления
предупреждения, который ведет себя следующим образом:
всякий раз, когда новые 50 предупреждений
<a href="error.htm#error_er_binlog_unsafe_statement"><code>
ER_BINLOG_UNSAFE_STATEMENT</code></a>
были произведены больше 50 раз в любой 50-секундный период, подавление
включено.  Когда активировано, это заставляет такие предупреждения не быть
написанными в журнал ошибок, вместо этого, для каждых 50 предупреждений этого
типа пишется примечание <code>The last warning was repeated <em><code>N
</code></em> times in last <em><code>S</code></em> seconds</code>.
Это продолжается пока 50 новых таких предупреждений были выпущены за 50
секунд или меньше, как только уровень уменьшился ниже этого порога,
предупреждения обычно регистрируются один раз. Подавление предупреждений не
имеет никакого эффекта на то, как безопасность запросов для основанного на
запросе журналирования определена, ни на то, как предупреждения посылают
клиенту. Клиенты MySQL все еще получают предупреждение для
каждого такого запроса.</p>
<p>См. <a href="#replication-formats">раздел 19.2.1</a>.</p>

<p><b>Опасные запросы. </b>Запросы со следующими
характеристиками считают опасными:</p>
<ul><li><p><b>Запросы, содержащие системные функции, которые могут возвратить
отличное значение на ведомом устройстве. </b>Эти функции включают
<a href="funct.htm#function_found-rows"><code>FOUND_ROWS()</code></a>,
<a href="funct.htm#function_get-lock"><code>GET_LOCK()</code></a>,
<a href="funct.htm#function_is-free-lock"><code>IS_FREE_LOCK()</code></a>,
<a href="funct.htm#function_is-used-lock"><code>IS_USED_LOCK()</code></a>,
<a href="funct.htm#function_load-file"><code>LOAD_FILE()</code></a>,
<a href="funct.htm#function_master-pos-wait"><code>MASTER_POS_WAIT()</code>
</a>, <a href="funct.htm#function_password"><code>PASSWORD()</code></a>,
<a href="funct.htm#function_rand"><code>RAND()</code></a>,
<a href="funct.htm#function_release-lock"><code>RELEASE_LOCK()</code></a>,
<a href="funct.htm#function_row-count"><code>ROW_COUNT()</code></a>,
<a href="funct.htm#function_session-user"><code>SESSION_USER()</code></a>,
<a href="funct.htm#function_sleep"><code>SLEEP()</code></a>,
<a href="funct.htm#function_sysdate"><code>SYSDATE()</code></a>,
<a href="funct.htm#function_system-user"><code>SYSTEM_USER()</code></a>,
<a href="funct.htm#function_user"><code>USER()</code></a>,
<a href="funct.htm#function_uuid"><code>UUID()</code></a> и
<a href="funct.htm#function_uuid-short"><code>UUID_SHORT()</code></a>.</p>

<p><a name="replication-rbr-safe-unsafe-not"></a><b>
Недетерминированные функции, которые не рассматривают как опасные. </b>
Хотя эти функции не детерминированы, они обработаны как безопасные:
<a href="funct.htm#function_connection-id"><code>CONNECTION_ID()</code></a>,
<a href="funct.htm#function_curdate"><code>CURDATE()</code></a>,
<a href="funct.htm#function_current-date"><code>CURRENT_DATE()</code></a>,
<a href="funct.htm#function_current-time"><code>CURRENT_TIME()</code></a>,
<a href="funct.htm#function_current-timestamp"><code>CURRENT_TIMESTAMP()
</code></a>, <a href="funct.htm#function_curtime"><code>CURTIME()</code></a>,
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()</code></a>,
<a href="funct.htm#function_localtime"><code>LOCALTIME()</code></a>,
<a href="funct.htm#function_localtimestamp"><code>LOCALTIMESTAMP()</code></a>,
<a href="funct.htm#function_now"><code>NOW()</code></a>,
<a href="funct.htm#function_unix-timestamp"><code>UNIX_TIMESTAMP()</code></a>,
<a href="funct.htm#function_utc-date"><code>UTC_DATE()</code></a>,
<a href="funct.htm#function_utc-time"><code>UTC_TIME()</code></a> и
<a href="funct.htm#function_utc-timestamp"><code>UTC_TIMESTAMP()</code>
</a>.</p>
<p>См. <a href="#replication-features-functions">раздел 19.4.1.16
</a>.</li>

<li><b>Ссылки на системные переменные. </b>Большинство системных переменных
не копируется правильно, используя основанный на запросе формат. См. разделы
<a href="#replication-features-variables">19.4.1.38</a> и
<a href="server.htm#binary-log-mixed">6.4.4.3</a>.</li>

<li><b>UDF. </b>Так как мы не имеем никакого контроля над тем, что делает
UDF, мы должны предположить, что он выполняет опасные запросы.</li>
<li><b>Плагин Fulltext. </b>Этот плагин может вести себя по-другому на
различных серверах MySQL, поэтому у запросов в зависимости от этого могли
быть различные результаты. Поэтому все запросы, полагающиеся на плагин
fulltext, обработаны как опасные в MySQL.</li>

<li><b>Триггер или сохраненная программа обновляет таблицу, имеющую
столбец AUTO_INCREMENT. </b>Это опасно, потому что порядок, в котором
обновлены строки, может разойтись в ведущем и ведомом устройствах.</p>

<p>Кроме того, <a href="sql.htm#insert"><code>INSERT</code></a> в
таблицу, у которой есть сложный первичный ключ, содержащий
<code>AUTO_INCREMENT</code>, который не является первым столбцом этого
сложного ключа, опасен.</p>
<p>См. <a href="#replication-features-auto-increment">
раздел 19.4.1.1</a>.</li>

<li><b>INSERT ... ON DUPLICATE KEY UPDATE
запросы о таблицах с первичными или уникальными ключами. </b>
Когда выполнено для таблицы, которая содержит больше, чем один основной или
уникальный ключ, этот запрос считают опасным, будучи чувствительным к
порядку, в котором механизм хранения проверяет ключи, который не
детерминирован и от которого зависит выбор строк, обновленных MySQL Server.
</p>

<p><a href="sql.htm#insert-on-duplicate"><code>INSERT ... ON DUPLICATE KEY
UPDATE</code></a> запрос для таблицы, имеющей больше, чем один уникальный или
первичный ключ, отмечен как опасный для основанной на запросе
репликации (Bug #11765650, Bug #58637).</li>

<li><b>Обновления используя LIMIT. </b>
Порядок, в котором получены строки, не определен и поэтому считается опасным.
См. <a href="#replication-features-limit">раздел 19.4.1.17</a>.
</li>

<li><b>Доступы или ссылки к таблицам журнала. </b>
Содержание системной таблицы журнала может отличаться между
ведущим и ведомым устройствами.</li>

<li><b>Нетранзакционные операции после транзакционных операций. </b>
В пределах транзакции, позволяя любые нетранзакционные чтения или
записи, чтобы выполнить после любых транзакционных чтений или
записей, считается опасным.</p>
<p>См. <a href="#replication-features-transactions">раздел
19.4.1.33</a>.</li>

<li><b>Доступы или ссылки к таблицам регистрации. </b>
Все чтения и записи к таблицам журналирования считаются опасными.
В пределах транзакции любые запросы после чтения или записи
также считаются опасными.</li>

<li><b>LOAD DATA INFILE. </b>
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>
считается опасным, это вызывает предупреждение в основанном на запросе
режиме и переключает к основанному на строке формату, используя
журналирование смешанного формата. См.
<a href="#replication-features-load-data">раздел 19.4.1.18</a>.
</p></li></ul>
<p>См. <a href="#replication-features">раздел 19.4.1</a>.</p>

<h3><a name="replication-implementation-details"></a>19.2.2.
Детали выполнения репликации</h3>
<p>Способности репликации MySQL осуществлены, используя три потока,
один на главном сервере и два на ведомом устройстве:</p>

<ul><li><p><b>Поток Binlog dump. </b>Ведущее устройство создает поток, чтобы
послать двоичное содержание журнала в ведомое устройство, когда ведомое
устройство соединяется. Этот поток может быть идентифицирован в выводе
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
на ведущем устройстве как <code>Binlog Dump</code>.</p>

<p>Поток дампа журнала приобретает блокировку на двоичном журнале ведущего
устройства для того, чтобы считать каждое событие, которое нужно послать в
ведомое устройство. Как только событие было считано, блокировка выпущена даже
прежде, чем событие посылают в ведомое устройство.</li>

<li><b>Ведомый поток ввода/вывода. </b>Когда <a href="sql.htm#start-slave">
<code>START SLAVE</code></a> сделан на ведомом сервере, ведомое устройство
создает поток ввода/вывода, который соединяется с ведущим устройством и
просит послать обновления.</p>

<p>Ведомый поток ввода/вывода читает обновления, посланные потоком
<code>Binlog Dump</code> (см. предыдущий элемент) и копирует их к местным
файлам, которые включают журнал реле ведомого устройства.</p>

<p>Статус этого потока показывают как <code>Slave_IO_running</code> в выводе
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a> или
<a href="server.htm#statvar_Slave_running"><code>Slave_running</code></a> в
выводе <a href="sql.htm#show-status"><code>SHOW STATUS</code></a>.</li>

<li><b>Ведомый поток SQL. </b>Ведомое устройство создает поток SQL, чтобы
читать журнал реле, который написан ведомым вводом/выводом,
и запускать события, содержащиеся там.</p></li></ul>

<p>В предыдущем описании есть три потока на основное/ведомое соединение.
Ведущее устройство, у которого есть многократные ведомые устройства, создает
один двоичной поток дампа журнала для каждого в настоящее время соединяемого
ведомого устройства, и у каждого ведомого устройства есть свой собственный
ввод/вывод и поток SQL.</p>

<p>Ведомое устройство использует два потока, чтобы отделить обновления
от ведущего устройства и выполнение их в независимые задачи. Таким образом,
задача чтения запросов не замедлена, если выполнение запросов медленное.
Например, если ведомый сервер не работал некоторое время, его поток
ввода/вывода может быстро принести все двоичное содержание журнала от
ведущего устройства, когда ведомое устройство запускается, даже если поток
SQL отстает. Если ведомое устройство останавливается прежде, чем поток SQL
выполнил все принесенные запросы, поток ввода/вывода, по крайней мере, принес
все так, чтобы безопасная копия запросов была сохранена в местном масштабе в
журналах реле ведомого устройства, готовых к выполнению в следующий раз,
когда ведомое устройство запускается.</p>

<p><a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
предоставляет информацию, которая говорит Вам, что происходит на ведущем
устройстве и на ведомом устройстве относительно репликации.
Для информации об основных статусах см.
<a href="optimiz.htm#master-thread-states">раздел 9.14.4</a>.
Для статусов ведомого см. разделы
<a href="optimiz.htm#slave-io-thread-states">9.14.5</a> и
<a href="optimiz.htm#slave-sql-thread-states">9.14.6</a>.</p>

<p>Следующий пример иллюстрирует, как три потока обнаруживаются в выводе от
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>.</p>
<p>На главном сервере вывод
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
похож на это:
<pre>
mysql&gt; SHOW PROCESSLIST\G
*************************** 1. row ***************************
 Id: 2
 User: root
 Host: localhost:32931
 db: NULL
Command: Binlog Dump
 Time: 94
State: Has sent all binlog to slave; waiting for binlog to
 be updated
 Info: NULL
</pre>

<p>Здесь поток 2 это <code>Binlog Dump</code>, который обслуживает
соединенное ведомое устройство. <code>State</code> указывает, что все
обновления послали в ведомое устройство и что ведущее устройство ждет
большего количества обновлений. Если Вы не видите поток <code>Binlog Dump
</code> на главном сервере, это означает, что репликация не работает, то
есть, никакие ведомые устройства в настоящее время не соединяются.</p>

<p>На ведомом сервере вывод <a href="sql.htm#show-processlist"><code>SHOW
PROCESSLIST</code></a> похож на это:
<pre>
mysql&gt; SHOW PROCESSLIST\G
*************************** 1. row ***************************
 Id: 10
 User: system user
 Host:
 db: NULL
Command: Connect
 Time: 11
State: Waiting for master to send event
 Info: NULL
*************************** 2. row ***************************
 Id: 11
 User: system user
 Host:
 db: NULL
Command: Connect
 Time: 11
State: Has read all relay log; waiting for the slave I/O
 thread to update it
 Info: NULL
</pre>

<p><code>State</code> указывает, что поток 10 это поток ввода/вывода,
который общается с главным сервером, а поток 11 является потоком SQL, который
обрабатывает обновления, сохраненные в журналах реле. В то время, когда
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
был выполнен, оба потока были неактивны, ожидая дальнейших обновлений.</p>

<p>Значение в <code>Time</code> может показать, как отстает ведомое
устройство по сравнению с ведущим устройством. См.
<a href="faqs.html#faqs-replication">раздел A.13</a>.
Если достаточное количество времени протекает на основной стороне без
деятельности <code>Binlog Dump</code>, ведущее устройство решает, что ведомое
устройство больше не соединено. Что касается любого другого соединения
клиента, тайм-ауты для этого зависят от значений
<code>net_write_timeout</code> и <code>net_retry_count</code>, см.
<a href="server.htm#server-system-variables">раздел 6.1.5</a>.</p>

<p><a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
обеспечивает дополнительную информацию об обработке репликации на ведомом
сервере. См. <a href="#replication-administration-status">
раздел 19.1.7.1</a>.</p>

<h3><a name="replication-channels"></a>19.2.3. Каналы репликации</h3>
<p>Каналы репликации представляют путь транзакций, вытекающих из ведущего
устройства к ведомому устройству. Этот раздел описывает, как каналы могут
использоваться в топологии репликации, и влияние, которое они
оказывают на репликацию.</p>

<p>Чтобы предоставить совместимость с предыдущими версиями, сервер MySQL
автоматически создает на запуске канал по умолчанию, имя которого пустая
строка (<code>""</code>). Этот канал всегда присутствует, это не может быть
создано или разрушено пользователем. Если никакие другие каналы (имеющие
непустые названия) не были созданы, запросы репликации выполняются только
на канале по умолчанию, чтобы все запросы репликации от более старой ведомой
функции работали, как ожидалось (см.
<a href="#channels-with-prev-replication">раздел 19.2.3.2</a>.
Запросы, относящиеся к каналам репликации как описано в этом разделе, могут
использоваться только, когда есть по крайней мере один названный канал.</p>

<p>Канал репликации охватывает путь транзакций, переданных от ведущего
устройства к ведомому. В мультиисходной репликации ведомое устройство
открывает многократные каналы, один на ведущее устройство, и у каждого канала
есть свой собственный журнал реле и поток SQL. Как только транзакции получены
получателем канала репликации (ввод/вывод), они добавлены к файлу системного
журнала реле канала и проходят к потоку применения.
Это позволяет каналам функционировать независимо.</p>

<p>Канал репликации также связан с именем хоста и портом.
Вы можете назначить многократные каналы на ту же самую комбинацию имени
хоста и порта, в MySQL 8.0 максимальное количество каналов, которые могут
быть добавлены к одному ведомому устройству в мультиисходной топологии
репликации, 256. У каждого канала репликации должно быть уникальное
(непустое) имя (см. <a href="#channels-naming-conventions">
раздел 19.2.3.4</a>). Каналы могут быть сконфигурированы независимо.</p>

<h4><a name="channels-commands-single-channel"></a>19.2.3.1.
Команды для операций на единственном канале</h4>
<p>Чтобы позволить существующим запросым репликации MySQL действовать на
отдельные каналы репликации, MySQL вводит опцию <code>FOR
CHANNEL <em><code>channel_name</code></em></code> для использования со
следующими запросыми репликации в управлении каналом репликации независимо
от других каналов:</p>

<ul><li><p><a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code>
</a></li>
<li><a href="sql.htm#start-slave"><code>START SLAVE</code></a></li>
<li><a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a></li>
<li><a href="sql.htm#show-relaylog-events"><code>SHOW RELAYLOG EVENTS</code>
</a></li>
<li><a href="sql.htm#flush"><code>FLUSH RELAY LOGS</code></a></li>
<li><a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
</li>
<li><a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a></p></li></ul>

<p>Точно так же дополнительный параметр <code>channel_name</code>
введен для следующих функций:</p>
<ul><li><p><a href="funct.htm#function_master-pos-wait"><code>
MASTER_POS_WAIT()</code></a></li>
<li><a href="funct.htm#function_wait-until-sql-thread-after-gtids"><code>
WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()</code></a></p></li></ul>

<p>Следующие запросы отвергнуты для канала
<code>group_replication_recovery</code>.</p>
<ul><li><p><a href="sql.htm#start-slave"><code>START SLAVE</code></a></li>
<li><a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a></p></li></ul>

<h4><a name="channels-with-prev-replication"></a>19.2.3.2.
Совместимость с предыдущими запросами репликации</h4>
<p>Когда у ведомого устройства репликации есть многократные каналы и опция
<code>FOR CHANNEL <em><code>channel_name</code></em></code>
не определена, допустимый запрос действует на все доступные каналы.</p>

<p>Например, следующие запросы ведут себя как ожидалось:</p>
<ul><li><p><a href="sql.htm#start-slave"><code>START SLAVE</code></a>
запускает потоки репликации для всех каналов, кроме
<code>group_replication_recovery</code>.</li>

<li><a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>
останавливает репликацию для всех каналов, кроме
<code>group_replication_recovery</code>.</li>

<li><a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
сообщает состояние для всех каналов.</li>
<li><a href="sql.htm#flush"><code>FLUSH RELAY LOGS</code></a> сбрасывает
журналы реле для всех каналов.</li>
<li><a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a>
перезапускает все каналы.</p></li></ul>

<p>Применяйте <code>RESET SLAVE</code> с осторожностью, поскольку эта команда
удаляет все существующие каналы, производит чистку их файлов системного
журнала реле и обновляет только канал по умолчанию.</p>

<p>Некоторые запросы репликации не могут воздействовать на все каналы.
В этом случае выводится ошибка 1964 <span>Multiple channels exist on the
slave. Please provide channel name as an argument</span>.
Следующие запросы и функции производят эту ошибку, когда используются в
мультиисходной топологии репликации и опция
<code>FOR CHANNEL <em><code>channel_name</code></em></code>
не используется, чтобы определить, на который канал действовать:</p>

<ul><li><p><a href="sql.htm#show-relaylog-events"><code>SHOW RELAYLOG EVENTS
</code></a></li>
<li><a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a></li>
<li><a href="funct.htm#function_master-pos-wait"><code>MASTER_POS_WAIT()
</code></a></li>
<li><a href="funct.htm#function_wait-until-sql-thread-after-gtids"><code>
WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS()</code></a></li>
<li><a href="funct.htm#function_wait-for-executed-gtid-set"><code>
WAIT_FOR_EXECUTED_GTID_SET()</code></a></p></li></ul>

<p>Отметьте, что канал по умолчанию всегда существует в единственной исходной
топологии репликации, где запросы и функции ведут себя как в
предыдущих версиях MySQL.</p>

<h4><a name="channels-startup-options"></a>19.2.3.3.
Опции запуска и каналы репликации</h4>
<p>Этот раздел описывает опции запуска, на которые воздействует
добавление каналов репликации.</p>

<p>Следующие опции запуска <span><em>должны</em></span> быть сконфигурированы
правильно, чтобы использовать мультиисходную репликацию.</p>
<ul><li><p><a href="#sysvar_relay_log_info_repository"><code>
--relay-log-info-repository</code></a></p>
<p>Это должно быть установлено в <code>TABLE</code>. Если эта опция
установлена в <code>FILE</code>, попытка добавить больше источников к
ведомому устройству терпит неудачу с
<span>ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY</span>.</li>

<li><code>--master-info-repository</code></p>
<p>Это должно быть установлено в <code>TABLE</code>. Если эта опция
установлена <code>FILE</code>, попытка добавить больше источников к ведомому
устройству терпит неудачу с
<span>ER_SLAVE_NEW_CHANNEL_WRONG_REPOSITORY</span>.</p></li></ul>

<p>Следующие опции запуска теперь затрагивают <span><em>все</em></span>
каналы в топологии репликации.</p>
<ul><li><p><a href="#sysvar_log_slave_updates"><code>
--log-slave-updates</code></a></p>
<p>Все транзакции, полученные ведомым устройством (даже из многократных
источников), написаны в двоичный журнал.</li>

<li><a href="server.htm#sysvar_relay_log_purge"><code>--relay-log-purge
</code></a></p>
<p>Когда установлено, каждый канал производит чистку своего собственного
журнала реле автоматически.</li>

<li><a href="#sysvar_slave_transaction_retries"><code>
--slave_transaction_retries</code></a></p>
<p>Потоки применения всех каналов повторяют транзакции.</li>

<li><a href="#option_mysqld_skip-slave-start"><code>
--skip-slave-start</code></a></p>
<p>Никакие потоки репликации не запускаются ни на каких каналах.</li>

<li><a href="#sysvar_slave_skip_errors"><code>
--slave-skip-errors</code></a></p>
<p>Выполнение продолжается, ошибки пропущены для всех каналов.</p></li></ul>

<p>Набор значений для следующих опций запуска применяется на каждый канал,
так как это опции запуска <a href="programs.htm#mysqld"><span><strong>mysqld
</strong></span></a>, они применены на каждый канал.</p>

<ul><li><p><code>--max-relay-log-size=<em><code>size</code></em></code></p>
<p>Максимальный размер отдельного файла системного журнала реле
для каждого канала, после достижения этого предела файл ротируется.</li>

<li><code>--relay-log-space-limit=<em><code>size</code></em></code></p>
<p>Верхний предел для полного размера всех журналов реле
для каждого отдельного канала. Для <em><code>N</code></em>
каналов объединенный размер этих журналов ограничен
<a href="server.htm#sysvar_relay_log_space_limit"><code>
relay_log_space_limit * <em><code>N</code></em></code></a>.</li>

<li><code>--slave-parallel-workers=<em><code>value</code></em></code></p>
<p>Число ведомых параллельных потоков на канал.</li>
<li><code>--slave-checkpoint-group</code></p>
<p>Время ожидания вводом/выводом для каждого источника.</li>

<li><code>--relay-log-index=filename</code></p>
<p>Базовое имя для индексного файла журнала реле каждого канала, см.
<a href="#channels-naming-conventions">раздел 19.2.3.4</a>.</li>

<li><code>--relay-log=filename</code></p>
<p>Обозначает базовое имя файла системного журнала реле каждого канала. См.
See <a href="#channels-naming-conventions">раздел 19.2.3.4
</a>.</li>

<li><code>--slave_net-timeout=N</code></p>
<p>Это значение установлено на канал, чтобы каждый канал ждал
<em><code>N</code></em> секунд, чтобы проверить на сломанное соединение.</li>

<li><code>--slave-skip-counter=N</code></p>
<p>Это значение установлено на канал, чтобы каждый канал пропустил
<em><code>N</code></em> событий от его ведущего устройства.</p></li></ul>

<h4><a name="channels-naming-conventions"></a>19.2.3.4.
Соглашения о присвоении имен канала репликации</h4>
<p>Этот раздел описывает, как на соглашения о присвоении имен
воздействуют каналы репликации.</p>

<p>У каждого канала репликации есть уникальное имя, которое является строкой
с максимальной длиной 64 символа и является нечувствительным к регистру.
Поскольку названия канала используются в ведомых таблицах, набором символов,
используемым для них, всегда является UTF-8. Хотя Вы вообще свободны
использовать любое название каналов, следующие имена сохранены:</p>
<ul><li><p><code>group_replication_applier</code></li>
<li><code>group_replication_recovery</code></p></li></ul>

<p>Имя, которое Вы выбираете для канала репликации, также влияет на имена
файла, используемые ведомым устройством мультирепликации.
Файлы системного журнала реле и индексные файлы для каждого канала называют
<code><em><code>base_name</code></em>-relay-bin-<em><code>channel_name</code>
</em>.0000x</code>, где <em><code>base_name</code></em>
имя хоста (если не определено использованием
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>) и
<em><code>channel_name</code></em>
название канала, зарегистрированного к этому файлу.</p>

<h3><a name="slave-logs"></a>19.2.4. Реле репликации и журналы состояния</h3>
<p>Во время репликации ведомый сервер создает несколько журналов,
которые хранят события, переданные от ведущего к ведомому устройству и делают
запись информации о текущем статусе и местоположении в пределах журнала реле.
Есть три типа журналов, используемых в процессе, перечисленных здесь:</p>

<ul><li><p><span><em>Журнал реле</em></span> состоит из событий, считанных из
двоичного журнала ведущего устройства и написанный ведомым потоком
ввода/вывода. События в журнале реле запущены на ведомом устройстве как
часть потока SQL.</li>

<li><span>Основной журнал информации</span> содержит состояние и текущую
информацию о конфигурации для соединения ведомого устройства с ведущим
устройством. Этот журнал содержит информацию об основном имени хоста,
параметрах входа в систему и координатах, указывающих, где ведомое устройство
читает из двоичного журнала ведущего устройства.</p>

<p>Этот журнал может быть написан в таблицу
<code>mysql.slave_master_info</code> вместо файла, запуская ведомое
устройство с опцией <a href="#option_mysqld_master-info-repository">
<code>--master-info-repository=TABLE</code></a>.</li>

<li><span>Журнал информации журнала реле</span>
содержит информацию о статусе выполнения в пределах журнала
реле ведомого устройства.</p>

<p>Этот журнал может быть написан в таблицу
<code>mysql.slave_relay_log_info</code>
вместо файла, запуская ведомое устройство с
<a href="#option_mysqld_relay-log-info-repository"><code>
--relay-log-info-repository=TABLE</code></a>.</p></li></ul>

<p><a name="replication-implementation-crash-safe"></a>
<b>Безопасная от катастрофического отказа репликация. </b>
Для репликации, чтобы быть безопасной от катастрофического отказа, используя
таблицы для того, чтобы зарегистрировать состояние и информацию о реле, эти
таблицы должны использовать транзакционной механизм хранения, такой как
<a href="innodb.htm"><code>InnoDB</code></a>. В MySQL 8.0
эти таблицы составлены, используя <code>InnoDB</code>.</p>

<p>Поэтому, чтобы гарантировать безопасность при столкновении на ведомом
устройстве, Вы должны выполнить ведомое устройство с включенной опцией
<a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery</code></a> в дополнение к установке
<a href="#option_mysqld_relay-log-info-repository"><code>
--relay-log-info-repository</code></a> = <code>TABLE</code>.</p>

<p>В MySQL 8.0 дано предупреждение, когда
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
неспособен инициализировать таблицы журналирования репликации, но ведомому
устройству позволяют продолжить запускаться. Эта ситуация, наиболее вероятно,
произойдет, обновляясь от версии MySQL, которая не поддерживает ведомые
таблицы журналирования к той, в которой они поддержаны.</p>

<p>В MySQL 8.0 выполнение любого запроса, требующего блокировки записи
одной или обеих таблиц <code>slave_master_info</code> и
<code>slave_relay_log_info</code> отвергнуто в то время, как репликация
работает, но запросы, которые выполняют только чтение,
разрешены в любое время.</p>

<p>Не пытайтесь обновить или вставить строки в таблицы
<code>slave_master_info</code> или <code>slave_relay_log_info</code>
вручную. Выполнение этого может вызвать неопределенное
поведение и не поддержано.</p>

<h4><a name="slave-logs-relaylog"></a>19.2.4.1. Ведомый журнал реле</h4>
<p>Журнал реле как двоичной журнал состоит из ряда пронумерованных файлов,
содержащих события, которые описывают изменения базы данных, и индексного
файла, который содержит названия всех используемых файлов
системного журнала реле.</p>

<p>Термин <span><span>файл журнала реле</span></span> вообще обозначает
отдельный пронумерованный файл, содержащий события базы данных. Термин
<span><span>журнал реле</span></span> обозначает набор пронумерованных файлов
системного журнала реле плюс индексный файл.</p>

<p>Файлы системного журнала реле имеют тот же самый формат как
двоичные файлы системного журнала и могут быть считаны, используя
<a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog</strong></span>
</a> (см. <a href="programs.htm#mysqlbinlog">раздел 5.6.8</a>).</p>

<p>По умолчанию у имен файла системного журнала реле есть форма
<code><em><code>host_name</code></em>-relay-bin.<em><code>nnnnnn</code>
</em></code> в каталоге данных, где
<em><code>host_name</code></em> название ведомого узла сервера и
<em><code>nnnnnn</code></em> порядковый номер. Последовательные файлы
системного журнала реле создаются, используя последовательные порядковые
номера, начиная с <code>000001</code>. Ведомое устройство использует
индексный файл, чтобы отследить использующиеся в настоящее время файлы
системного журнала реле. Имя индексного файла журнала реле по умолчанию
<code><em><code>host_name</code></em>-relay-bin.index
</code> в каталоге данных.</p>

<p>Файл системного журнала реле по умолчанию и имена индексного файла
журнала реле могут быть переопределены, соответственно, опциями сервера
<a href="#option_mysqld_relay-log"><code>--relay-log</code></a> и
<a href="#option_mysqld_relay-log-index"><code>--relay-log-index
</code></a> (см. <a href="#replication-options">раздел 19.1.6</a>).
</p>

<p>Если ведомое устройство использует значение по умолчанию основанное
на имени файла системного журнала реле, изменение имени хоста ведомого
устройства после того, как репликация была настроена, может заставить
репликацию терпеть неудачу с ошибками <span>Failed
to open the relay log</span> и <span>Could not find
target log during relay log initialization</span>.
Это известная проблема (см. Bug #2122). Если Вы ожидаете, что имя хоста
ведомого устройства могло бы измениться в будущем (например, если сети
настроены на ведомом устройстве, таким образом, что его имя хоста может быть
изменено, используя DHCP), Вы можете избежать этой проблемы полностью при
использовании опций <a href="#option_mysqld_relay-log"><code>
--relay-log</code></a> и <a href="#option_mysqld_relay-log-index">
<code>--relay-log-index</code></a>, чтобы определить файл системного журнала
реле явно, когда Вы первоначально настраиваете ведомое устройство. Это
сделает имена независимыми от изменений имени хоста сервера.</p>

<p>Если Вы сталкиваетесь с проблемой после того, как репликация уже
запущена, один способ ее решить состоит в том, чтобы остановить ведомый
сервер, перенести содержание старого индексного файла журнала реле
в новый, а затем перезапустить ведомое устройство. На системе Unix это может
быть сделано как показано здесь:
<pre>
shell&gt; cat <em><code>new_relay_log_name</code></em>.index &gt;&gt; <em><code>old_relay_log_name</code></em>.index
shell&gt; mv <em><code>old_relay_log_name</code></em>.index <em><code>new_relay_log_name</code></em>.index
</pre>

<p>Ведомый сервер создает новый файл системного журнала реле
при следующих условиях:</p>
<ul><li><p>Каждый раз, когда поток ввода/вывода запускается.</li>
<li>Когда журналы сброшены, например, с
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a> или
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin flush-logs
</strong></span></a>.</li>

<li>Когда размер текущего файла системного журнала реле становится
<span><span>слишком большим</span></span>, что определено следующим образом:
</p>
<ul><li><p>Если значение <a href="server.htm#sysvar_max_relay_log_size">
<code>max_relay_log_size</code></a> больше 0, что
является максимальным размером файла системного журнала реле.</li>

<li>Если значение <a href="server.htm#sysvar_max_relay_log_size"><code>
max_relay_log_size</code></a> = 0,
<a href="#sysvar_max_binlog_size"><code>max_binlog_size</code></a>
определяет максимальный размер файла системного журнала реле.
</p></li></ul></li></ul>

<p>Поток SQL автоматически удаляет каждый файл системного журнала реле,
как только это запустило все события в файле и больше не нуждается в этом.
Нет никакого явного механизма для того, чтобы удалить журналы реле, потому
что поток SQL заботится о выполнении. Однако,
<a href="sql.htm#flush"><code>FLUSH LOGS</code></a>
ротирует журналы реле, что влияет на то, когда поток SQL удаляет их.</p>

<h4><a name="slave-logs-status"></a>19.2.4.2. Ведомые журналы состояния</h4>
<p>Ведомый сервер репликации создает два журнала. По умолчанию эти журналы
файлы <code>master.info</code> и <code>relay-log.info</code>,
создаваемые в каталоге данных. Названия и местоположение этих файлов могут
быть изменены при использовании опций
<a href="#option_mysqld_master-info-file"><code>--master-info-file
</code></a> и <a href="#option_mysqld_relay-log-info-file"><code>
--relay-log-info-file</code></a>. В MySQL 8.0 один или оба из этих журналов
могут также быть написаны в таблицы в базе данных <code>mysql</code>
с соответствующей опции: надо использовать
<a href="#option_mysqld_master-info-repository"><code>
--master-info-repository</code></a>, чтобы иметь основной журнал информации,
написанный в таблицу <code>mysql.slave_master_info</code>, и
<a href="#option_mysqld_relay-log-info-repository"><code>
--relay-log-info-repository</code></a>, чтобы иметь журнал реле, написанный
в таблицу <code>mysql.slave_relay_log_info</code>, см.
<a href="#replication-options">раздел 19.1.6</a>.</p>

<p>Два журнала состояния содержат информацию как показано в выводе
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>,
который обсужден в <a href="sql.htm#replication-slave-sql">разделе 14.4.2
</a>. Поскольку журналы состояния сохранены на диске, они переживают
завершение работы ведомого сервера. В следующий раз, когда ведомое устройство
запускается, оно читает два журнала, чтобы определить, как далеко оно ушло
в чтении двоичных журналов от ведущего устройства и в обработке его
собственных журналов реле.</p>

<p>Основной файл системного журнала информации или таблица должны быть
защищены, потому что это содержит пароль для того, чтобы соединиться с
ведущим устройством. См. <a href="security.html#password-logging">раздел
7.1.2.3</a>.</p>

<p>Ведомый поток ввода/вывода обновляет основной журнал информации.
Следующая таблица показывает связь между строками в файле
<code>master.info</code>, столбцами в таблице
<code>mysql.slave_master_info</code> и столбцами, выведенными на экран
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Строка в файле <code>master.info</code></th>
<th scope="col">Столбец таблицы <code>slave_master_info</code></th>
<th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row">1</td>
<td><code>Number_of_lines</code></td>
<td>[None]</td>
<td>Число строк в файле или столбцов в таблице.</td></tr>
<tr><td scope="row">2</td>
<td><code>Master_log_name</code></td>
<td><code>Master_Log_File</code></td>
<td>Название основного двоичного журнала в настоящее время считанного
от ведущего устройства.</td></tr>
<tr><td scope="row">3</td>
<td><code>Master_log_pos</code></td>
<td><code>Read_Master_Log_Pos</code></td>
<td>Текущая позиция в пределах основного двоичного журнала, которая была
считаны от ведущего устройства.</td></tr>
<tr><td scope="row">4</td>
<td><code>Host</code></td>
<td><code>Master_Host</code></td>
<td>Имя хоста ведущего устройства.</td></tr>
<tr><td scope="row">5</td>
<td><code>User_name</code></td>
<td><code>Master_User</code></td>
<td>Имя пользователя, чтобы соединяться с ведущим устройством.</td></tr>
<tr><td scope="row">6</td>
<td><code>User_password</code></td>
<td>Пароль (не показан <a href="sql.htm#show-slave-status"><code>
SHOW SLAVE STATUS</code></a>)</td>
<td>Пароль для связи с ведущим устройством.</td></tr>
<tr><td scope="row">7</td>
<td><code>Port</code></td>
<td><code>Master_Port</code></td>
<td>Сетевой порт, чтобы соединяться с ведущим устройством.</td></tr>
<tr><td scope="row">8</td>
<td><code>Connect_retry</code></td>
<td><code>Connect_Retry</code></td>
<td>Период (в секундах), который ведомое устройство будет ждать прежде, чем
попытаться повторно соединиться с ведущим устройством.</td></tr>
<tr><td scope="row">9</td>
<td><code>Enabled_ssl</code></td>
<td><code>Master_SSL_Allowed</code></td>
<td>Указывает, поддерживает ли сервер соединения SSL.</td></tr>
<tr><td scope="row">10</td>
<td><code>Ssl_ca</code></td>
<td><code>Master_SSL_CA_File</code></td>
<td>Файл, используемый для сертификата центра сертификации (CA).</td></tr>
<tr><td scope="row">11</td>
<td><code>Ssl_capath</code></td>
<td><code>Master_SSL_CA_Path</code></td>
<td>Путь к сертификату центра сертификации (CA).</td></tr>
<tr><td scope="row">12</td>
<td><code>Ssl_cert</code></td>
<td><code>Master_SSL_Cert</code></td>
<td>Название файла сертификата SSL.</td></tr>
<tr><td scope="row">13</td>
<td><code>Ssl_cipher</code></td>
<td><code>Master_SSL_Cipher</code></td>
<td>Список возможных шифров для соединения SSL.</td></tr>
<tr><td scope="row">14</td>
<td><code>Ssl_key</code></td>
<td><code>Master_SSL_Key</code></td>
<td>Название файла ключа SSL.</td></tr>
<tr><td scope="row">15</td>
<td><code>Ssl_verify_server_cert</code></td>
<td><code>Master_SSL_Verify_Server_Cert</code></td>
<td>Проверить ли сертификат сервера.</td></tr>
<tr><td scope="row">16</td>
<td><code>Heartbeat</code></td>
<td>[None]</td>
<td>Интервал между тактами репликации в секундах.</td></tr>
<tr><td scope="row">17</td>
<td><code>Bind</code></td>
<td><code>Master_Bind</code></td>
<td>Какой из сетевых интерфейсов ведомого устройства должен использоваться
для того, чтобы соединиться с ведущим устройством.</td></tr>
<tr><td scope="row">18</td>
<td><code>Ignored_server_ids</code></td>
<td><code>Replicate_Ignore_Server_Ids</code></td>
<td>Список ID сервера, которые будут проигнорированы.
Отметьте, что списку <code>Ignored_server_ids</code>
предшествует общее количество ID сервера, чтобы проигнорировать.</td></tr>
<tr><td scope="row">19</td>
<td><code>Uuid</code></td>
<td><code>Master_UUID</code></td>
<td>Уникальный ID ведущего устройства.</td></tr>
<tr><td scope="row">20</td>
<td><code>Retry_count</code></td>
<td><code>Master_Retry_Count</code></td>
<td>Максимальное количество попыток пересоединения.</td></tr>
<tr><td scope="row">21</td>
<td><code>Ssl_crl</code></td>
<td>[None]</td>
<td>Путь к файлу перечня аннулированных сертификатов ssl.</td></tr>
<tr><td scope="row">22</td>
<td><code>Ssl_crl_path</code></td>
<td>[None]</td>
<td>Путь к каталогу, содержащему файлы списка аннулирования ssl.</td></tr>
<tr><td scope="row">23</td>
<td><code>Enabled_auto_position</code></td>
<td><code>Auto_position</code></td>
<td>Авторасположение используется или нет.</td></tr>
<tr><td scope="row">24</td>
<td><code>Channel_name</code></td>
<td><code>Channel_name</code></td>
<td>Название канала репликации.</td></tr></tbody></table>

<p>Ведомый поток SQL обновляет журнал информации журнала реле. В MySQL 8.0
файл <code>relay-log.info</code> включает количество строк и значение
задержки репликации. Следующая таблица показывает связь между строками в
файле <code>relay-log.info</code>, столбцов таблицы
<code>mysql.slave_relay_log_info</code> и столбцов
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Строка файла <code>relay-log.info</code></th>
<th scope="col">Столбец таблицы <code>slave_relay_log_info</code></th>
<th scope="col">Столбец <code>SHOW SLAVE STATUS</code></th>
<th scope="col">Описание</th></tr></thead>
<tbody><tr><td scope="row">1</td>
<td><code>Number_of_lines</code></td>
<td>[None]</td>
<td>Число строк в файле или столбцов в таблице.</td></tr>
<tr><td scope="row">2</td>
<td><code>Relay_log_name</code></td>
<td><code>Relay_Log_File</code></td>
<td>Название текущего файла системного журнала реле.</td></tr>
<tr><td scope="row">3</td>
<td><code>Relay_log_pos</code></td>
<td><code>Relay_Log_Pos</code></td>
<td>Текущая позиция в пределах файла системного журнала реле,
события до этой позиции были запущены на ведомой базе данных.</td></tr>
<tr><td scope="row">4</td>
<td><code>Master_log_name</code></td>
<td><code>Relay_Master_Log_File</code></td>
<td>Название основного двоичного файла системного журнала, из которого были
считаны события в файле системного журнала реле.</td></tr>
<tr><td scope="row">5</td>
<td><code>Master_log_pos</code></td>
<td><code>Exec_Master_Log_Pos</code></td>
<td>Эквивалентная позиция в пределах двоичного файла системного журнала
ведущего устройства событий, которые были уже запущены.</td></tr>
<tr><td scope="row">6</td>
<td><code>Sql_delay</code></td>
<td><code>SQL_Delay</code></td>
<td>Число секунд, на которое ведомое устройство отстает от ведущего.
</td></tr>
<tr><td scope="row">7</td>
<td><code>Number_of_workers</code></td>
<td>[None]</td>
<td>Число потоков для того, чтобы запустить события
репликации (транзакции) параллельно.</td></tr>
<tr><td scope="row">8</td>
<td><code>Id</code></td>
<td>[None]</td>
<td>ID используется во внутренних целях, в настоящее время это всегда 1.
</td></tr>
<tr><td scope="row">9</td>
<td><code>Channel_name</code></td>
<td>Channel_name</td>
<td>Название канала репликации.</td></tr></tbody></table>

<p>В более старых версиях MySQL (до MySQL 5.6) файл
<code>relay-log.info</code> не включает количество строк или значение
задержки (и таблица <code>slave_relay_log_info</code> недоступна).</p>

<p>Если Вы понижаете ведомый сервер к версии, более старой, чем MySQL 5.6,
более старый сервер не читает файл <code>relay-log.info</code> как надо.
Чтобы обратиться к этому, измените файл в текстовом редакторе, удаляя
начальную строку, содержащую число строк.</p>

<p>Содержание <code>relay-log.info</code> и статусы из
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
не могут соответствовать, если <code>relay-log.info</code>
не сброшен на диск. Идеально, Вы должны только рассмотреть
<code>relay-log.info</code> на ведомом устройстве, которое является
офлайновым (то есть, <code>mysqld</code> не работает).
Для рабочей системы Вы можете использовать
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
или запросить таблицы <code>slave_master_info</code> и
<code>slave_relay_log_info</code>, если Вы пишете
журналы состояния в таблицы.</p>

<p>Когда Вы поддерживаете данные ведомого устройства, Вы должны поддержать
эти два журнала состояния, наряду с файлами системного журнала реле.
Журналы состояния необходимы, чтобы возобновить репликацию после того,
как Вы восстанавливаете данные от ведомого устройства. Если Вы теряете
журналы реле, но все еще имеете журнал информации журнала реле, Вы можете
проверить это, чтобы определить, как далеко поток SQL ушел
в основных двоичных журналах. Тогда Вы можете использовать
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
с опциями <code>MASTER_LOG_FILE</code> и <code>MASTER_LOG_POS</code>, чтобы
сказать ведомому устройству перечитывать двоичные журналы.
Конечно, это требует, чтобы двоичные журналы все еще существовали
на ведущем устройстве.</p>

<h3><a name="replication-rules"></a>19.2.5.
Как серверы оценивают правила фильтрации репликации</h3>
<p>Если главный сервер не пишет запрос своему двоичному журналу,
запрос не копируется. Если сервер действительно регистрирует запрос,
запрос посылают во все ведомые устройства, и каждое ведомое устройство
определяет, выполнить или проигнорировать это.</p>

<p>На ведущем устройстве Вы можете управлять, которые базы данных
регистрируют изменения при использовании опций
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db</code>
</a> и <a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db</code></a>, чтобы управлять двоичным журналированием.
Для описания правил, применяемых сервером при оценке этих опций, см.
<a href="#replication-rules-db-options">раздел 19.2.5.1</a>.
Вы не должны использовать эти опции, чтобы управлять, какие базы данных и
таблицы копируются. Вместо этого используйте фильтрацию на ведомом
устройстве, чтобы управлять событиями, которые запущены на ведомом.</p>

<p>На ведомой стороне решения о том, выполнить или проигнорировать запросы,
полученные от ведущего устройства, приняты согласно опциям
<code>--replicate-*</code>, с которыми было запущено ведомое устройство. См.
<a href="#replication-options">раздел 19.1.6</a>.
Фильтры, которыми управляют эти опции, могут также быть установлены
динамически, используя <code>CHANGE REPLICATION FILTER</code>.
Правила, управляющие такими фильтрами, являются теми же самыми, создаются ли
они при использовании опций запуска <code>--replicate-*</code> или в то
время, как ведомый сервер выполняет <code>CHANGE REPLICATION FILTER</code>.
</p>

<p>В самом простом случае, когда нет опций <code>--replicate-*</code>,
ведомое устройство выполняет все запросы, что оно получает от ведущего
устройства. Иначе результат зависит от особых данных опций.</p>

<p>Опции на уровне базы данных
(<a href="#option_mysqld_replicate-do-db"><code>--replicate-do-db
</code></a>,
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a>) проверены сначала, см.
<a href="#replication-rules-db-options">раздел 19.2.5.1</a>
для описания этого процесса. Если никакие опции на уровне базы данных не
используются, проверка опции переходит к любым опциям на уровне таблицы,
которые могут использоваться (см.
<a href="#replication-rules-table-options">раздел 19.2.5.2</a>).
Если одна или более опций на уровне базы данных используются, но ни одна
не соответствует, запрос не копируется.</p>

<p>Для запросов, затрагивающих только базы данных (то есть,
<a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>,
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a> и
<a href="sql.htm#alter-database"><code>ALTER DATABASE</code></a>),
опции на уровне базы данных всегда имеют приоритет перед любыми
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a>. Другими словами, для таких запросов
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a> проверены, если и только если нет
никаких опций на уровне базы данных, которые применяются. Это изменение в
поведении от предыдущих версий MySQL, где запрос
<a href="sql.htm#create-database"><code>CREATE DATABASE dbx</code></a>
не копировался, если ведомое устройство было запущено с
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db=dbx</code></a>
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table=db%.t1</code></a> (Bug #46110).</p>

<p>Чтобы облегчить определять, какой эффект будет иметь набор опций,
рекомендуется, чтобы Вы избегали смешивать опции <span><span>do</span></span>
и <span><span>ignore</span></span> или неподстановочные и подстановочные.</p>

<p>Если любые опции <a href="#option_mysqld_replicate-rewrite-db">
<code>--replicate-rewrite-db</code></a> были определены, они
применены перед <code>--replicate-*</code>.</p>

<p>В MySQL 8.0 все опции фильтрации репликации следуют тем же самым правилам
для чувствительности к регистру, которые относятся к названиям баз данных и
таблиц в другом месте в сервере MySQL, включая эффекты
<a href="server.htm#sysvar_lower_case_table_names"><code>
lower_case_table_names</code></a>.</p>
<p>Это изменение от предыдущих версий MySQL (Bug #51639).</p>

<h4><a name="replication-rules-db-options"></a>19.2.5.1.
Оценка репликации на уровне базы данных и опций двоичного журналирования</h4>
<p>Оценивая опции репликации, ведомое устройство начинает с проверки, есть ли
какие-то <a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a> или
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a>. Используя
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db</code>
</a> или <a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db</code></a>,
процесс подобен, но опции проверены на ведущем устройстве.</p>

<p>С основанной на запросе репликацией база данных по умолчанию проверена на
соответствие. С основанной на строке репликацией база данных, где данные
должны быть изменены, является базой данных, которая проверена.
Независимо от двоичного формата журналирования проверка опций на уровне базы
данных продолжается как показано в следующей диаграмме.</p>

<img src="repfilt.png" width="600" height="635">
<p>Вовлеченные шаги перечислены здесь:</p>
<ol type="1"><li><p>Есть ли любые
<a href="#option_mysqld_replicate-do-db"><code>--replicate-do-db
</code></a>?</p>

<ul><li><p><b>Да. </b>Какая-либо из них соответствует базе данных?</p>
<ul><li><p><b>Да. </b>Выполнить запрос.</li>
<li><b>Нет. </b>Проигнорировать запрос.</p></li></ul></li>
<li><b>Нет. </b>Пеерйти на шаг 2.</p></li></ul></li>

<li>Есть ли любая опция
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a>?

<ul><li><p><b>Да. </b>Какая-либо из них соответствует базе данных?</p>
<ul><li><p><b>Да. </b>Проигнорировать запрос.</li>
<li><b>Нет. </b>Перейти на шаг 3.</p></li></ul></li>
<li><b>Нет. </b>Перейти на шаг 3.</p></li></ul></li>

<li>Продолжите двигаться к проверке опций репликации на уровне таблицы,
если они есть. Для описания того, как эти опции проверены, см.
<a href="#replication-rules-table-options">раздел 19.2.5.2</a>.
</p>

<p>Запрос, который все еще разрешен на данном этапе, фактически еще не
выполнен. Запрос не выполнен, пока все опции на уровне таблицы (если есть)
не были также проверены, и результат этого процесса
разрешает выполнение запроса.

<p>Для двоичного журналирования вовлеченные шаги перечислены здесь:</p>
<ol type="1"><li><p>Есть ли любые опции
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db</code>
</a> или <a href="#option_mysqld_binlog-ignore-db"><code>
--binlog-ignore-db</code></a>?</p>

<ul><li><p><b>Да. </b>Перейти на шаг 2.</li>
<li><b>Нет. </b>Зарегистрировать запрос.</p></li></ul></li>
<li>Есть ли база данных по умолчанию (имеется любая база данных, выбранная
<a href="sql.htm#use"><code>USE</code></a>)?</p>
<ul><li><p><b>Да. </b>Перейти на шаг 3.</li>
<li><b>Нет. </b>Проигнорировать запрос.</p></li></ul></li>

<li>Есть база данных по умолчанию. Есть ли любая опция
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db</code>
</a>?</p>
<ul><li><p><b>Да. </b>Какая-либо из них соответствует базе данных?
<ul><li><p><b>Да. </b>Зарегистрировать запрос.</li>
<li><b>Нет. </b>Проигнорировать запрос.</p></li></ul></li>
<li><b>Нет. </b>Перейти на шаг 4.</p></li></ul></li>

<li>Любая из опций <a href="#option_mysqld_binlog-ignore-db">
<code>--binlog-ignore-db</code></a> соответствуют базе данных?</p>
<ul><li><p><b>Да. </b>Проигнорировать запрос.</li>
<li><b>Нет. </b>Зарегистрировать запрос.</p></li></ul></li></ol>

<p>Для основанного на запросе журналирования исключение сделано в правилах,
для <a href="sql.htm#create-database"><code>CREATE DATABASE</code></a>,
<a href="sql.htm#alter-database"><code>ALTER DATABASE</code></a> и
<a href="sql.htm#drop-database"><code>DROP DATABASE</code></a>.
В тех случаях база данных заменяет базу данных по умолчанию определяя,
зарегистрировать или проигнорировать обновления.</p>

<p><a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db
</code></a> может иногда означать <span><span>игнорировать другие базы данных
</span></span>. Например, используя основанное на запросе журналирование,
сервер, работающий только с
<a href="#option_mysqld_binlog-do-db"><code>--binlog-do-db=sales
</code></a> не пишет в двоичный журнал запросы, для которых база данных по
умолчанию отличается от <code>sales</code>. Используя основанное на строке
журналирование с той же самой опцией, сервер регистрирует только обновления
об изменении в <code>sales</code>.</p>

<h4><a name="replication-rules-table-options"></a>19.2.5.2.
Оценка опций репликации на уровне таблицы</h4>
<p>Ведомое устройство проверяет и оценивает табличные опции, только если
любое из следующих двух условий истина:</p>

<ul><li><p>Никакие опции базы данных соответствия не были найдены.</li>
<li>Одна или более опций базы данных были найдены и оценены, чтобы достигнуть
<span><span>выполнения</span></span> условия согласно правилам, описанным в
предыдущем разделе (см. <a href="#replication-rules-db-options">
раздел 19.2.5.1</a>).</p></li></ul>

<p>Как предварительное условие, ведомое устройство проверяет,
включена ли основанная на запросе репликация. Если это так, и запрос
происходит в пределах сохраненной функции, ведомое устройство выполняет
запрос. Если основанная на строке репликация включена, ведомое устройство не
знает, произошел ли запрос в пределах сохраненной функции на ведущем
устройстве, таким образом, это условие не применяется.</p>

<p>Для основанной на запросе репликации события представляют
запросы (все изменения, составляющие данное событие, связаны с единственным
запросом SQL), для основанной на строке репликации каждое событие
представляет изменение в единственной строке таблицы (таким образом,
единственный запрос, такой как <code>UPDATE mytable SET mycol = 1</code>
может привести ко многим основанным на строке событиям). Когда
рассматривается с точки зрения событий, процесс проверки опций таблицы
тот же самый для основанной на строке и для основанной на запросе репликации.
</p>

<p>Достигнув этой точки, если нет никаких табличных опций, ведомое устройство
просто запускает все события. Если есть
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table</code></a> или
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a>, событие должно соответствовать одной из
них, если это должно быть выполнено, иначе это проигнорировано. Если есть
<a href="#option_mysqld_replicate-ignore-table"><code>
--replicate-ignore-table</code></a> или
<a href="#option_mysqld_replicate-wild-ignore-table"><code>
--replicate-wild-ignore-table</code></a>, все события запущены кроме тех,
которые соответствуют любой из этих опций. Этот процесс проиллюстрирован
на следующей диаграмме.</p>

<img src="reptbl.png" width="585" height="1245">
<p>Следующие шаги описывают эту оценку более подробно:</p>
<ol type="1"><li><p>Есть ли какие-либо табличные опции?</p>
<ul><li><p><b>Да. </b>Перейти на шаг 2.</li>
<li><b>Нет. </b>Выполнить событие.</p></li></ul></li>

<li>Есть ли любая опция
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table</code></a>?</p>

<ul><li><p><b>Да. </b>Таблица соответствует какой-то из них?</p>
<ul><li><p><b>Да. </b>Выполнить событие.</li>
<li><b>Нет. </b>Перейти на шаг 3.</p></li></ul></li>
<li><b>Нет. </b>Перейти на шаг 3.</p></li></ul></li>

<li>Есть ли любая опция
<a href="#option_mysqld_replicate-ignore-table"><code>
--replicate-ignore-table</code></a>?</p>

<ul><li><p><b>Да. </b>Таблица соответствует какой-то из них?</p>
<ul><li><p><b>Да. </b>Проигнорировать событие.</li>
<li><b>Нет. </b>Перейти на шаг 4.</p></li></ul></li>
<li><b>Нет. </b>Перейти на шаг 4.</p></li></ul></li>

<li>Есть ли любая опция
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a>?</p>

<ul><li><p><b>Да. </b>Таблица соответствует какой-то из них?</p>
<ul><li><p><b>Да. </b>Выполнить событие.</li>
<li><b>Нет. </b>Перейти на шаг 5.</p></li></ul></li>
<li><b>Нет. </b>Перейти на шаг 5.</p></li></ul></li>
<li>Есть ли любая опция
<a href="#option_mysqld_replicate-wild-ignore-table"><code>
--replicate-wild-ignore-table</code></a>?</p>

<ul><li><p><b>Да. </b>Таблица соответствует какой-то из них?</p>
<ul><li><p><b>Да. </b>Проигнорировать событие.</li>
<li><b>Нет. </b>Перейти на шаг 6.</p></li></ul></li>
<li><b>Нет. </b>Перейти на шаг 6.</p></li></ul></li>

<li>Есть ли любая опция
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table</code></a> или
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a>?</p>
<ul><li><p><b>Да. </b>Проигнорировать событие.</li>
<li><b>Нет. </b>Выполнить событие.</p></li></ul></li></ol>

<h4><a name="replication-rules-examples"></a>19.2.5.3.
Правила репликации</h4>
<p>Этот раздел обеспечивает дополнительное объяснение и примеры использования
для различных комбинаций опций фильтрации репликации.</p>

<p>Некоторые типичные комбинации типов правила фильтра репликации
даны в следующей таблице:</p>
<table border="1">
<thead><tr><th scope="col">Выражение (типы опций)</th>
<th scope="col">Результат</th></tr></thead>
<tbody><tr><td scope="row">Нет опций <code>--replicate-*</code> вообще:</td>
<td>Ведомое устройство запускает все события, которые оно получает
от ведущего устройства.</td></tr>
<tr><td scope="row">Опции <code>--replicate-*-db</code> есть, но
нет табличных опций:</td>
<td>Ведомое устройство принимает или игнорирует события, используя опции базы
данных. Это запускает все события, разрешенные теми опциями, потому что нет
никаких табличных ограничений.</td></tr>
<tr><td scope="row">Есть опции <code>--replicate-*-table</code>, но нет опций
базы данных:</td><td>Все события приняты на проверяющем базу данных этапе,
потому что нет никаких условий базы данных. Ведомое устройство запускает или
игнорирует события, базируемые исключительно на табличных опциях.</td></tr>
<tr><td scope="row">Комбинация опций базы данных и таблицы:</td>
<td>Ведомое устройство принимает или игнорирует события, используя опции базы
данных. Тогда это оценивает все события, разрешенные теми опциями согласно
табличным опциям. Это может иногда приводить к результатам, которые кажутся
парадоксальными, и может отличаться в зависимости от того, используете ли Вы
основанную на запросе или строке репликацию, см. текст для примера.
</td></tr></tbody></table>

<p>Более сложный пример следует, в котором мы исследуем результаты и
настройки, основанные на запросе и строке.</p>
<p>Предположите, что у нас есть две таблицы <code>mytbl1</code> в базе данных
<code>db1</code> и <code>mytbl2</code> в базе данных <code>db2</code>
на ведущем устройстве, и ведомое устройство работает со следующими опциями (и
ни с какими другими опциями фильтрации репликации):
<pre>
replicate-ignore-db = db1
replicate-do-table= db2.tbl2
</pre>

<p>Теперь мы выполняем следующие запросы на ведущем устройстве:
<pre>
USE db1;
INSERT INTO db2.tbl2 VALUES (1);
</pre>

<p>Результаты на ведомом устройстве изменяются значительно в зависимости
от двоичного формата журнала и, возможно, не соответствуют начальным
ожиданиям в любом случае.</p>

<p><b>Основанная на запросе репликация. </b><code>USE</code> указывает
<code>db1</code> быть базой данных по умолчанию. Таким образом,
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a> соответствует <span><em>и
<a href="sql.htm#insert"><code>INSERT</code></a> проигнорирован</em></span>.
Табличные опции не проверены.</p>

<p><b>Основанная на строке репликация. </b>База данных по умолчанию не имеет
никакого эффекта на то, как ведомое устройство читает опции базы данных,
используя основанную на строке репликацию. Таким образом,
<a href="sql.htm#use"><code>USE</code></a> не имеет никакого значения в
том, как <a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a> обработана, база данных, определенная этой
опцией, не соответствует базе данных, где <a href="sql.htm#insert"><code>
INSERT</code></a> меняет данные, таким образом, ведомое устройство продолжает
проверять табличные опции. Таблица, определенная
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table</code></a>, соответствует таблице, которая будет
обновлена, <span><em>и строка вставлена</em></span>.</p>

<h2><a name="replication-solutions"></a>19.3. Решения для репликации</h2>
<p>Репликация может использоваться во многих окружающих средах для широкого
диапазона целей. Этот раздел обеспечивает общие сведения относительно
использования репликации для определенных типов решений.</p>

<p>Для информации об использовании репликации в резервной окружающей среде,
включая примечания по установке и резервной процедуре, см.
<a href="#replication-solutions-backups">раздел 19.3.1</a>.</p>

<p>Чтобы обезопасить Вашу коммуникацию репликации, Вы можете зашифровать
канал связи. Для инструкций см.
<a href="#replication-solutions-secure-connections">раздел 19.3.9
</a>.</p>

<h3><a name="replication-solutions-backups"></a>19.3.1.
Использование репликации для резервных копий</h3>
<p>Чтобы использовать репликацию в качестве резервного решения, копируйте
данные от ведущего устройства к ведомому, а затем зарезервируйте ведомое
устройство данных. Ведомое устройство может быть поставлено на паузу и
закрыто, не затрагивая рабочую работу ведущего устройства, таким образом, Вы
можете произвести эффективный снимок <span><span>живых</span></span> данных,
которые иначе потребовали бы, чтобы ведущее устройство было закрыто.</p>

<p>То, как Вы поддерживаете базу данных, зависит от ее размера
и поддерживаете ли Вы только данные, или данные и состояние
репликации так, чтобы Вы могли восстановить ведомое устройство в случае
отказа. Есть поэтому два выбора:</p>

<ul><li><p>Если Вы используете репликацию в качестве решения, чтобы позволить
Вам поддержать данные по ведущему устройству, и размер Вашей базы данных не
является слишком большим, <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> может помочь, см.
<a href="#replication-solutions-backups-mysqldump">раздел 19.3.1.1
</a>.</li>

<li>Для больших баз данных, где <a href="programs.htm#mysqldump"><span>
<strong>mysqldump</strong></span></a> был бы непрактичен или неэффективен, Вы
можете поддержать файлы необработанных данных вместо этого. Использование
опции файлов необработанных данных также означает, что Вы можете поддержать
двоичный и журнал реле, которые позволят Вам обновить ведомое устройство в
случае отказа. Для получения дополнительной информации см.
<a href="#replication-solutions-backups-rawdata">раздел 19.3.1.2
</a>.</p></li></ul>

<p>Другая резервная стратегия, которая может использоваться
для основных или для ведомых серверов, состоит в том, чтобы поместить сервер
в статус только для чтения. Резервное копирование выполнено на сервере только
для чтения, который сразу изменен назад на его обычное операционное состояние
чтения-записи. См.
<a href="#replication-solutions-backups-read-only">раздел 19.3.1.3
</a>.</p>

<h4><a name="replication-solutions-backups-mysqldump"></a>19.3.1.1.
Поддержка ведомого устройства используя mysqldump</h4>
<p>Использование <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a>, чтобы создать копию базы данных позволяет Вам получить
все данные в базе данных в формате, который позволяет информации быть
импортированной в другой MySQL Server (см.
<a href="programs.htm#mysqldump">раздел 5.5.4</a>).
Поскольку формат информации это запросы SQL, файл может легко быть
распределен на рабочие серверы, когда Вы нуждаетесь в доступе к данным в
чрезвычайной ситуации. Однако, если размер Вашего набора данных является
очень большим, <a href="programs.htm#mysqldump">
<span><strong>mysqldump</strong></span></a> может быть непрактичным.</p>

<p>Используя <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a>, Вы должны остановить репликацию на ведомом устройстве
прежде, чем запустить процесс дампа, чтобы гарантировать, что дамп содержит
непротиворечивое множество данных:</p>

<ol type="1"><li><p>Остановите обработку запросов на ведомом.
Вы можете остановить репликацию полностью на ведомом устройстве, используя
<a href="programs.htm#mysqladmin"><span><strong>mysqladmin</strong></span>
</a>:
<pre>
shell&gt; mysqladmin stop-slave
</pre>

<p>Альтернативно, Вы можете остановить только ведомый поток SQL:
<pre>
shell&gt; mysql -e 'STOP SLAVE SQL_THREAD;'
</pre>

<p>Это позволяет ведомому устройству продолжить получать события изменения
данных от двоичного журнала ведущего устройства, регистрирует и хранит их в
журналах реле, используя поток ввода/вывода, но препятствует тому, чтобы
ведомое устройство запустило эти события и изменило данные. В пределах
занятой окружающей среды репликации, разрешение потоку ввода/вывода работать
во время резервного копирования может ускорить процесс, когда Вы
перезапускаете ведомый поток SQL.</li>

<li>Выполните <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a>, чтобы вывести Ваши базы данных в дамп. Вы можете
вывести все базы данных или выбрать базы данных, которые будут выведены.
Например, чтобы вывести все базы данных:
<pre>
shell&gt; mysqldump --all-databases &gt; fulldb.dump
</pre></li>

<li>Как только дамп завершился, запустите ведомые операции снова:
<pre>
shell&gt; mysqladmin start-slave
</pre></li></ol>

<p>В предыдущем примере Вы можете хотеть добавить параметры
входа в систему (имя пользователя, пароль) к командам и связать процесс в
скрипт, который Вы можете выполнять автоматически каждый день.</p>

<p>Если Вы используете этот подход, удостоверьтесь, что Вы контролируете
ведомый процесс репликации, чтобы гарантировать, что время, потраченное,
чтобы выполнить резервное копирование, не затрагивает способность ведомого
устройства не отставать от событий от ведущего устройства. См.
<a href="#replication-administration-status">раздел 19.1.7.1</a>.
Если ведомое устройство неспособно поддержать производительность на высоком
уровне, Вы можете хотеть добавить другое ведомое устройство и распределить
резервный процесс. Для примера того, как сконфигурировать этот сценарий, см.
<a href="#replication-solutions-partitioning">раздел 19.3.6</a>.
</p>

<h4><a name="replication-solutions-backups-rawdata"></a>19.3.1.2.
Поддержка необработанных данных от ведомого устройства</h4>
<p>Чтобы гарантировать целостность файлов, которые скопированы, поддерживая
файлы необработанных данных на Вашем ведомом устройстве репликации MySQL,
это должно иметь место в то время, как Ваш ведомый сервер закрыт.
Если сервер MySQL все еще работает, фоновые задачи могут все еще обновлять
файлы базы данных, особенно те, которые вовлекают механизмы хранения с
фоновыми процессами, например, <code>InnoDB</code>. С <code>InnoDB</code>
эти проблемы должны быть решены во время восстановления катастрофического
отказа, но так как ведомый сервер может быть закрыт во время резервного
процесса, не затрагивая выполнение ведущего устройства, имеет смысл
использовать в своих интересах эту способность.</p>

<p>Закрыть сервер и зарезервировать файлы:</p>
<ol type="1"><li><p>Закройте ведомый сервер MySQL:
<pre>
shell&gt; mysqladmin shutdown
</pre></li>

<li>Скопируйте файлы с данными. Вы можете использовать любое подходящее
копирование, включая <span><strong>cp</strong></span>,
<span><strong>tar</strong></span> или <span><strong>WinZip</strong></span>.
Например, предполагая, что каталог данных расположен под текущим каталогом,
Вы можете заархивировать весь каталог следующим образом:
<pre>
shell&gt; tar cf /tmp/dbbackup.tar ./data
</pre></li>

<li>Запустите сервер MySQL снова. Под Unix:
<pre>
shell&gt; mysqld_safe &amp;
</pre>

<p>В Windows:
<pre>
C:\&gt; "C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqld"
</pre></li></ol>

<p>Обычно Вы должны поддержать весь каталог данных для ведомого сервера
MySQL. Если Вы хотите быть в состоянии восстановить данные и действовать в
качестве ведомого устройства (например, в случае отказа ведомого устройства),
то в дополнение к данным ведомого устройства, Вы должны также поддержать
ведомые файлы состояния, основную информацию и репозитарии информации журнала
реле и файлы системного журнала реле. Эти файлы необходимы, чтобы возобновить
репликацию после того, как Вы восстанавливаете данные ведомого устройства.
</p>

<p>Если Вы теряете журналы реле, но все еще имеете файл
<code>relay-log.info</code>, Вы можете проверить это, чтобы определить, как
далеко поток SQL ушел в основных двоичных журналах. Тогда Вы можете
использовать <a href="sql.htm#change-master-to"><code>CHANGE MASTER
TO</code></a> с опциями <code>MASTER_LOG_FILE</code> и
<code>MASTER_LOG_POS</code>. Это требует, чтобы двоичные журналы все еще
существовали на главном сервере.</p>

<p>Если Ваше ведомое устройство копирует <a href="sql.htm#load-data"><code>
LOAD DATA INFILE</code></a>, Вы должны также поддержать файлы
<code>SQL_LOAD-*</code>, которые существуют в каталоге, который ведомое
устройство использует с этой целью. Ведомое устройство нуждается в этих
файлах, чтобы возобновить репликацию любого прерванного
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>.
Местоположение этого каталога это значение опции
<a href="#option_mysqld_slave-load-tmpdir"><code>
--slave-load-tmpdir</code></a>. Если сервер не был запущен с этой опцией,
местоположение каталога это значение переменной
<a href="server.htm#sysvar_tmpdir"><code>tmpdir</code></a>.</p>

<h4><a name="replication-solutions-backups-read-only"></a>19.3.1.3.
Поддержка ведущего или ведомого устройства, делая его только для чтения</h4>
<p>Возможно поддержать основные или ведомые серверы в установке репликации,
приобретая глобальную блокировку чтения и управляя переменной
<a href="server.htm#sysvar_read_only"><code>read_only</code></a>, чтобы
изменить статус "только для чтения" сервера, который будет сохранен:</p>

<ol type="1"><li><p>Сделайте сервер только для чтения, так, чтобы он
обработал только извлечения и заблокировал обновления.</li>
<li>Выполните резервное копирование.</li>
<li>Измените сервер назад на его нормальный статус чтения-записи.
</p></li></ol>

<p>Инструкции в этом разделе помещают сервер, который будет поддержан, в
статус, который безопасен для резервных методов, которые получают данные от
сервера, таких как <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a> (см. <a href="programs.htm#mysqldump">раздел 5.5.4</a>).
Вы не должны пытаться использовать эти инструкции, чтобы сделать двоичное
резервное копирование, копируя файлы непосредственно, потому что сервер,
возможно, все еще изменяет данные, кэшируемые в памяти, и не сбросил
их на диск.</p>

<p>Следующие инструкции описывают, как сделать это для главного сервера
и для ведомого сервера. Для обоих сценариев, обсужденных здесь, предположите,
что у Вас есть следующая установка репликации:</p>

<ul><li><p>Главный сервер M1.</li>
<li>Ведомый сервер S1, у которого есть M1 как его ведущее устройство.</li>
<li>Клиент К1 соединяется с M1.</li>
<li>Клиент К2 соединяется с S1.</p></li></ul>

<p>В любом сценарии, запросы, чтобы приобрести глобальную блокировку чтения и
управлять переменной <a href="server.htm#sysvar_read_only"><code>read_only
</code></a> выполнены на сервере, который будет поддержан, и не размножаются
ни к каким ведомым устройствам того сервера.</p>

<p><span><strong>Сценарий 1: Резервное копирование с ведущим устройством
только для чтения</strong></span></p>
<p>Поместите ведущее устройство М1 в статус только для чтения,
выполняя эти запросы:
<pre>
mysql&gt; FLUSH TABLES WITH READ LOCK;
mysql&gt; SET GLOBAL read_only = ON;
</pre>

<p>В то время как M1 находится в состоянии только для чтения,
следующие свойства истина:</p>
<ul><li><p>Запросы об обновлениях, посланные C1 в M1, заблокируют, потому что
сервер находится в режиме только для чтения.</li>

<li>Запросы о результатах запроса, посланные C1 в M1, преуспеют.</li>
<li>Создание резервного копирования на M1 безопасно.</li>
<li>Создание резервного копирования на S1 не безопасно.
Этот сервер все еще работает и мог бы обрабатывать двоичный журнал или
обновления, прибывающие от клиента К2.</p></li></ul>

<p>В то время как M1 только для чтения, выполните резервное копирование.
Например, Вы можете использовать <a href="programs.htm#mysqldump"><span>
<strong>mysqldump</strong></span></a>.</p>

<p>После того, как резервная работа на M1 завершается, восстановите M1 к его
нормальному рабочему состоянию, выполняя эти запросы:
<pre>
mysql&gt; SET GLOBAL read_only = OFF;
mysql&gt; UNLOCK TABLES;
</pre>

<p>Хотя выполнение резервного копирования на M1 безопасно, это не оптимально
для работы, потому что клиенты M1 заблокированы на выполнение обновлений.</p>
<p>Эта стратегия относится к поддержке главного сервера в установке
репликации, но может также использоваться для единственного
сервера в установке нерепликации.</p>

<p><span><strong>Сценарий 2: Резервное копирование с ведомым устройством
только для чтения</strong></span></p>
<p>Поместите ведомого S1 в статус только для чтения, выполняя эти запросы:
<pre>
mysql&gt; FLUSH TABLES WITH READ LOCK;
mysql&gt; SET GLOBAL read_only = ON;
</pre>

<p>В то время как S1 находится в состоянии
только для чтения, следующие свойства истина:</p>
<ul><li><p>Ведущее устройство М1 продолжит действовать, так что создание
резервного копирования на ведущем устройстве не безопасно.</li>
<li>Ведомый S1 остановлен, таким образом делая резервное копирование
на ведомом S1 безопасным.</p></li></ul>

<p>Эти свойства обеспечивают основание для популярного резервного сценария:
наличие одного ведомого занятого выполнением резервного копирования некоторое
время не является проблемой, потому что это не затрагивает всю сеть, и
система все еще работает во время резервного копирования.
В частности, клиенты могут все еще выполнить обновления на главном сервере,
который остается не затронут резервной деятельностью на ведомом устройстве.
</p>

<p>В то время как S1 только для чтения, выполните резервное копирование.
Например, Вы можете использовать <a href="programs.htm#mysqldump"><span>
<strong>mysqldump</strong></span></a>.</p>

<p>После того, как резервная работа на S1 завершается, восстановите S1
к его нормальному рабочему состоянию, выполняя эти запросы:
<pre>
mysql&gt; SET GLOBAL read_only = OFF;
mysql&gt; UNLOCK TABLES;
</pre>

<p>После того, как ведомое устройство восстановлено к нормальному
функционированию, оно снова синхронизируется с ведущим устройством, догоняя
любые обновления от двоичного журнала ведущего устройства.</p>

<h3><a name="replication-solutions-unexpected-slave-halt"></a>19.3.2.
Обработка неожиданного останова ведомого устройства репликации</h3>
<p>Для репликации, чтобы быть эластичной к неожиданным остановам сервера
(иногда описываемой как безопасной от катастрофического отказа)
для ведомого устройства должно быть возможно возвратить
свой статус перед остановкой. Этот раздел описывает воздействие неожиданного
останова ведомого устройства во время репликации и как сконфигурировать
ведомое устройство для лучшей возможности восстановления.</p>

<p>После неожиданного останова ведомого устройства при перезапуске
поток ввода/вывода должен возвратить информацию, о которой были получены
транзакции, и поток SQL должен установить, какие транзакции уже были
выполнены. Для информации о ведомых журналах, требуемых для восстановления,
см. <a href="#slave-logs">раздел 19.2.4</a>.
Информация, требуемая для восстановления, традиционно хранилась в файлах, у
которых был риск сбоя синхронизации с ведущим устройством, зависящим от
того, на котором этапе обработки транзакции ведомое устройство остановилось.
В MySQL 8.0 Вы можете вместо этого использовать таблицы, чтобы хранить эту
информацию. Эти таблицы составлены, используя <a href="innodb.htm"><code>
InnoDB</code></a>, и при использовании этого транзакционного механизма
хранения информация всегда восстанавливаема. Чтобы сконфигурировать MySQL
8.0, чтобы хранить информацию репликации в таблицах, надо установить
переменные <a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository</code></a> и
<a href="#sysvar_master_info_repository"><code>
master_info_repository</code></a> в <code>TABLE</code>.
Сервер тогда хранит информацию, требуемую для восстановления потока
ввода/вывода в таблице <code>mysql.slave_master_info</code>
а информацию для восстановления потока SQL в таблице
<code>mysql.slave_relay_log_info</code>.</p>

<p>Следующая таблица показывает воздействие различных факторов на то, как
однопоточное ведомое устройство восстанавливается от неожиданного останова.
</p>
<p><b>Таблица 19.5. Факторы, влияющие на восстановление
однопоточного ведомого.</b></p>
<table border="1">
<thead><tr><th scope="col" align="center"><p>GTID</p></th>
<th scope="col" align="center"><p>MASTER_AUTO_POSITION</p></th>
<th scope="col" align="center"><p>
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery
</code></a></p></th>
<th scope="col" align="center"><p>
<a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository</code></a></p></th>
<th scope="col" align="center"><p>Тип катастрофического отказа</p></th>
<th scope="col" align="center"><p>Восстановление гарантировано?</p></th>
<th scope="col" align="center"><p>Воздействие на журнал реле</p>
</th></tr></thead>
<tbody><tr valign="middle"><td scope="row" align="center" valign="middle"><p>
OFF</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>OFF</p>
</td><td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Server</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>OFF</p>
</td><td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>OS</p></td>
<td align="center" valign="middle"><p>Нет</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>OFF</p>
</td><td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Server</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>OFF</p>
</td><td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>OS</p></td>
<td align="center" valign="middle"><p>Нет</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>ON</p>
</td><td align="center" valign="middle"><p>ON</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>ON</p>
</td><td align="center" valign="middle"><p>OFF</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Server</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>ON</p>
</td><td align="center" valign="middle"><p>OFF</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>OS</p></td>
<td align="center" valign="middle"><p>Нет</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr></tbody></table>

<p>Поскольку таблица показывает, используя однопоточное ведомое устройство,
следующие конфигурации наиболее эластичны к неожиданным остановам:</p>
<ul><li><p>Используя GTID и <code>MASTER_AUTO_POSITION</code>, установите
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=0
</code></a>. С этой конфигурацией установка
<a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository</code></a>
и другие переменные не воздействуют на восстановление.</li>

<li>Когда используется репликацуя на основе позиции файла, установите
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=1
</code></a> и <a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository=TABLE</code></a>.</p>
<p>Во время восстановления потерян журнал реле.</p></li></ul>

<p>Следующая таблица показывает воздействие этих различных факторов
на то, как мультипоточное ведомое устройство восстанавливается
от неожиданного останова.</p>

<a name="idm139965301244464"></a><p><b>Таблица 19.6. Факторы, влияющие
на восстановление мультипоточного ведомого</b></p>
<table border="1">
<thead><tr><th scope="col" align="center"><p>GTID</p></th>
<th scope="col" align="center"><p>
<a href="#sysvar_sync_relay_log"><code>sync_relay_log</code></a>
</p></th>
<th scope="col" align="center"><p><code>MASTER_AUTO_POSITION</code></p></th>
<th scope="col" align="center"><p>
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery
</code></a></p></th>
<th scope="col" align="center"><p>
<a href="#sysvar_relay_log_info_repository">
<code>relay_log_info_repository</code></a></p></th>
<th scope="col" align="center"><p>Тип повреждения</p></th>
<th scope="col" align="center"><p>Восстановление гарантируется?</p></th>
<th scope="col" align="center"><p>Воздействие на журнал реле</p>
</th></tr></thead>
<tbody><tr valign="middle"><td scope="row" align="center" valign="middle">
<p>OFF</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>OFF</p>
</td><td align="center" valign="middle"><p>&gt;1</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Server</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>OFF</p>
</td><td align="center" valign="middle"><p>&gt;1</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>OS</p></td>
<td align="center" valign="middle"><p>Нет</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>
OFF</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Server</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>
OFF</p></td><td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>OS</p></td>
<td align="center" valign="middle"><p>Нет</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>
ON</p></td><td align="center" valign="middle">Любой</td>
<td align="center" valign="middle"><p>ON</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Потерян</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle"><p>
ON</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>OFF</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>TABLE</p></td>
<td align="center" valign="middle"><p>Server</p></td>
<td align="center" valign="middle"><p>Да</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr>
<tr valign="middle"><td scope="row" align="center" valign="middle">
<p>ON</p></td>
<td align="center" valign="middle"><p>1</p></td>
<td align="center" valign="middle"><p>OFF</p></td>
<td align="center" valign="middle"><p>0</p></td>
<td align="center" valign="middle"><p>Любой</p></td>
<td align="center" valign="middle"><p>OS</p></td>
<td align="center" valign="middle"><p>Нет</p></td>
<td align="center" valign="middle"><p>Остается</p></td></tr></tbody></table>

<p>Как таблица показывает, используя мультипоточное ведомое устройство,
следующие конфигурации наиболее эластичны к неожиданным остановам:</p>
<ul><li><p>Используя GTID и <code>MASTER_AUTO_POSITION</code>, установите
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=0
</code></a>. С этой конфигурацией установка
<a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository</code></a> и другие переменные не
воздействуют на восстановление.</li>

<li>Когда используется позиция файла, установите
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=1
</code></a>,
<a href="#sysvar_sync_relay_log"><code>sync_relay_log=1</code></a>
и <a href="#sysvar_relay_log_info_repository"><code>
relay_log_info_repository=TABLE</code></a>.</p>
<p>Во время восстановления потерян журнал реле.</p></li></ul>

<p>Важно отметить воздействие
<a href="#sysvar_sync_relay_log"><code>sync_relay_log=1</code>
</a>, который требует записи в журнал реле на транзакцию. Хотя эта установка
является самой эластичной к неожиданному останову, с самое большее одной
ненаписанной потерянной транзакцией, у этого также есть потенциал, чтобы
очень увеличить загрузку на диск. Без
<a href="#sysvar_sync_relay_log"><code>sync_relay_log=1</code>
</a> эффект неожиданного останова зависит от того, как журнал реле обработан
операционной системой. Также отметьте, что когда
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=0
</code></a> и ведомое устройство запущено после неожиданного останова, журнал
реле обработан как часть восстановления. После того как этот процесс
завершается, журнал реле удален.</p>

<p>Неожиданный останов мультипоточного ведомого устройства репликации и
использование рекомендуемой позиции файла может привести к журналу реле с
операционными несогласованностями (промежутки в последовательности
транзакций), вызванными неожиданным остановом. См.
<a href="#replication-features-transaction-inconsistencies">
раздел 19.4.1.34</a>. В MySQL 5.7.13 и позже, если процесс восстановления
журнала реле сталкивается с такими операционными несогласованностями,
процесс восстановления продолжается автоматически. В версиях MySQL до 5.7.13
этот процесс не является автоматическим и требует запуска сервера с
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=0
</code></a>, запуска ведомого устройства с <a href="sql.htm#start-slave">
<code>START SLAVE UNTIL SQL_AFTER_MTS_GAPS</code></a>, чтобы исправить
любые операционные несогласованности и затем перезапуска ведомого устройства
с <a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=1
</code></a>.</p>

<p>Когда Вы используете мультирепликацию и
<a href="#sysvar_relay_log_recovery"><code>relay_log_recovery=1
</code></a>, после перезапуска из-за неожиданного останова все каналы
репликации проходят процесс восстановления журнала реле. Любые
несогласованности, найденные в журнале реле из-за неожиданного останова
мультипоточного ведомого устройства, заполнены.</p>

<h3><a name="replication-solutions-rbr-monitoring"></a>19.3.3.
Контроль основанной на строке репликации</h3>
<p>В MySQL 5.7.16 и позже текущее продвижение потока SQL репликации,
используя основанную на строке репликацию проверено через инструменты
Performance Schema, позволяя Вам отследить обработку операций и проверить
завершенный объем работы и оценить работу. Когда эти инструментальные этапы
Performance Schema включены, таблица
<a href="perfor.htm#events-stages-current-table"><code>events_stages_current
</code></a> показывает этапы для потоков и их продвижения. Для вводной
информации см. <a href="perfor.htm#performance-schema-stage-tables">раздел
23.9.5</a>.</p>

<p>Чтобы отследить продвижение всех трех основанных на строке типов
репликации событий (write, update, delete):</p>
<ul><li><p>Включите три этапа Performance Schema:
<pre>
mysql&gt; UPDATE performance_schema.setup_instruments SET ENABLED = 'YES'
    -&gt;        WHERE NAME LIKE 'stage/sql/Applying batch of row changes%';
</pre></li>

<li>Ждите некоторых событий, которые будут обработаны репликацией
и затем проверяйте продвижение, изучая таблицу
<a href="perfor.htm#events-stages-current-table">
<code>events_stages_current</code></a>. Например получить продвижение
для событий <code>update</code>:
<pre>
mysql&gt; SELECT WORK_COMPLETED, WORK_ESTIMATED
                 FROM performance_schema.events_stages_current
    -&gt;        WHERE EVENT_NAME
                 LIKE 'stage/sql/Applying batch of row changes (update)'
</pre></li>

<li>Если <a href="#sysvar_binlog_rows_query_log_events"><code>
binlog_rows_query_log_events</code></a> включена, информация о запросах
хранится в двоичном журнале и выставлена в поле <code>processlist_info
</code>. Чтобы увидеть оригинальный запрос, который вызвал это событие:
<pre>
mysql&gt; SELECT db, processlist_state, processlist_info
                 FROM performance_schema.threads
    -&gt;        WHERE processlist_state
                 LIKE 'stage/sql/Applying batch of row changes%' AND
                      thread_id = N;
</pre></li></ul>

<h3><a name="replication-solutions-diffengines"></a>19.3.4.
Используя репликацию с различными основными и ведомыми механизмами хранения
</h3>
<p>Не имеет значения для процесса репликации, используют ли исходная таблица
на ведущем устройстве и копируемая таблица на ведомом различный механизм.
Фактически переменная <a href="server.htm#sysvar_default_storage_engine">
<code>default_storage_engine</code></a> не копируется.</p>

<p>Это обеспечивает много выгод в процессе репликации,
в котором Вы можете использовать в своих интересах различные типы механизма
для различных сценариев репликации. Например, в типичном сценарии
масштаба (см. <a href="#replication-solutions-scaleout">раздел
19.3.5</a>) Вы хотите использовать <code>InnoDB</code>
на ведущем устройстве, чтобы использовать в своих интересах транзакционную
функциональность, но <code>MyISAM</code> на ведомых устройствах, где
операционная поддержка не требуется, потому что данные только считаны.
Используя репликацию в регистрирующей данные окружающей среде, Вы можете
хотеть использовать на ведомом устройстве <code>Archive</code>.</p>

<p>Конфигурирование различных механизмов на ведущем устройстве и ведомом
устройстве зависит от того, как Вы настраиваете начальный процесс репликации:
</p>
<ul><li><p>Если бы Вы использовали <a href="programs.htm#mysqldump"><span>
<strong>mysqldump</strong></span></a>, чтобы создать снимок базы данных на
Вашем ведущем устройстве, то Вы могли бы отредактировать текст файла дампа,
чтобы изменить тип механизма, используемый на каждой таблице.</p>

<p>Другая альтернатива для <a href="programs.htm#mysqldump"><span><strong>
mysqldump</strong></span></a> должна отключить типы механизма, которые Вы не
хотите использовать на ведомом устройстве перед использованием дампа,
чтобы создать данные по ведомому устройству. Например, Вы можете добавить
опцию <a href="innodb.htm#option_mysqld_innodb"><code>--skip-federated</code>
</a> на Вашем ведомом устройстве, чтобы отключить механизм
<code>FEDERATED</code>. Если определенный механизм не будет существовать для
таблицы, которая будет создаваться, то MySQL будет использовать тип механизма
по умолчанию, обычно <code>MyISAM</code>. Это требует отключения SQL-режима
<a href="server.htm#sqlmode_no_engine_substitution"><code>
NO_ENGINE_SUBSTITUTION</code></a>. Если Вы хотите отключить дополнительные
механизмы таким образом, Вы можете хотеть создать специальный исполняемый
модуль, который используется на ведомом устройстве, которое поддерживает
только нужные механизмы.</li>

<li>Если Вы будете использовать файлы необработанных данных (двоичное
резервное копирование), чтобы настроить ведомое устройство, то Вы не будете
способны изменить начальный формат таблицы. Вместо этого используйте
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, чтобы изменить
табличные типы после того, как ведомое устройство было запущено.</li>

<li>Для новых основных/ведомых установок репликации, где в настоящее время
нет никаких таблиц на ведущем устройстве, избегайте определять тип механизма,
составляя новые таблицы.</p></li></ul>

<p>Если Вы уже выполняете решение для репликации и хотите преобразовать Ваши
существующие таблицы в другой тип механизма, надо следовать этим шагам:</p>
<ol type="1"><li><p>Запретите ведомому устройству
выполнить обновления репликации:
<pre>
mysql&gt; STOP SLAVE;
</pre>

<p>Это позволит Вам изменить типы механизма без прерываний.</li>
<li>Выполните <code>ALTER TABLE ... ENGINE='<em><code>engine_type</code>
</em>'</code> для каждой таблицы, которая будет изменена.</li>

<li>Запустите ведомый процесс репликации снова:
<pre>
mysql&gt; START SLAVE;
</pre></li></ol>

<p>Хотя <a href="server.htm#sysvar_default_storage_engine"><code>
default_storage_engine</code></a> не копируется, надо знать, что
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> и
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, которые
включают спецификацию механизма, будут правильно копироваться к ведомому
устройству. Например, если у Вас есть таблица CSV, и Вы выполняете:
<pre>
mysql&gt; ALTER TABLE csvtable Engine='MyISAM';
</pre>

<p>Вышеупомянутый запрос будет копироваться к ведомому устройству,
и тип механизма на ведомом устройстве будет преобразован в
<code>MyISAM</code>, даже если Вы ранее изменили табличный тип на ведомом
устройстве. Если Вы хотите сохранить различия в механизме на ведущем
устройстве и ведомом устройстве, Вы должны использовать
<a href="server.htm#sysvar_default_storage_engine"><code>
default_storage_engine</code></a> на ведущем устройстве, составляя
новую таблицу. Например, вместо:
<pre>
mysql&gt; CREATE TABLE tablea (columna int) Engine=MyISAM;
</pre>

<p>Используйте этот формат:
<pre>
mysql&gt; SET default_storage_engine=MyISAM;
mysql&gt; CREATE TABLE tablea (columna int);
</pre>

<p>Когда копируется, <a href="server.htm#sysvar_default_storage_engine">
<code>default_storage_engine</code></a> будет проигнорирована, и
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a> выполнится на
ведомом устройстве, используя механизм по умолчанию ведомого устройства.</p>

<h3><a name="replication-solutions-scaleout"></a>19.3.5.
Использование репликации для масштаба</h3>
<p>Вы можете использовать репликацию в качестве решения масштаба,
то есть, где Вы хотите разделить загрузку запросов базы данных на много
серверов базы данных, в пределах некоторых разумных ограничений.</p>

<p>Поскольку репликация работает от распределения одного ведущего устройства
к одному или более ведомым устройствам, использовать репликация для работ
масштаба лучше всего в окружающей среде, где у Вас есть высокое число чтений
и низкое число обновлений. Большинство веб-сайтов вписываются в эту
категорию, где пользователи просматривают сайт, читая статьи, сообщения или
рассматривая продукты. Обновления происходят только во время управления
сеансом, делая покупку или добавляя комментарий/сообщение к форуму.</p>

<p>Репликация в этой ситуации позволяет Вам распределить чтения по ведомым
устройствам репликации, все еще позволяя Вашим веб-серверам общаться с
ведущим устройством репликации, когда нужна запись. Вы можете видеть типовое
расположение репликации для этого сценария на
<a href="#figure_replication-scaleout">рис. 19.1</a>.</p>

<a name="figure_replication-scaleout"></a><p><b>Рис. 19.1.
Использование репликации, чтобы улучшить работу</b></p>
<img src="scale.png" width="687" height="340">

<p>Если часть Вашего кода, который отвечает за доступ к базе данных, должным
образом собиралась из блоков, преобразование этого, чтобы работать с
копируемой установкой, должно быть очень гладким и легким. Измените
выполнение своего доступа к базе данных, чтобы послать все записи
ведущему устройству, а чтения послать ведущему или ведомому устройству. Если
у Вашего кода нет этого уровня абстракции, тогда придется повозиться.
Начните с создания библиотеки обертки или модуля, который
осуществляет следующие функции:</p>

<ul><li><p><code>safe_writer_connect()</code></li>
<li><code>safe_reader_connect()</code></li>
<li><code>safe_reader_statement()</code></li>
<li><code>safe_writer_statement()</code></p></li></ul>

<p><code>safe_</code> в каждом имени функции говорит, что функция заботится
об обработке всех состояний ошибки. Вы можете использовать различные названия
функций. Важная вещь состоит в том, чтобы иметь объединенный интерфейс для
того, чтобы соединиться для чтений и записей.</p>

<p>Тогда преобразуйте свой код клиента, чтобы пользоваться библиотекой
обертки. Это может быть болезненным и страшным процессом сначала, но
это окупается в конечном счете. Все приложения, которые используют только
что описанный подход, в состоянии использовать в своих интересах
основную/ведомую конфигурацию, даже вовлекающие многократные ведомые
устройства. Код намного легче поддержать, поиск неисправностей тривиален. Вы
должны изменить только одну или две функции, например, чтобы
зарегистрировать, сколько времени каждый запрос взял,
или какой запрос среди выпущенных дал Вам ошибку.</p>

<p>Если Вы написали много кода, Вы можете хотеть автоматизировать
конверсионную задачу при использовании утилиты
<a href="programs.htm#replace-utility">
<span><strong>replace</strong></span></a>, которая идет со стандартными
пакетами MySQL, или напишите свой собственный конверсионный скрипт. Идеально,
если Ваш код использует последовательные программные соглашения стиля.</p>

<h3><a name="replication-solutions-partitioning"></a>19.3.6.
Мультиплицирование различных баз данных к различным ведомым устройствам</h3>
<p>Могут быть ситуации, где Вы имеете единственное ведущее устройство и
хотите копировать различные базы данных к различным ведомым устройствам.
Например, Вы можете хотеть распределить различные данные о сбыте различным
отделам, чтобы помочь распространить загрузку во время анализа данных.
Образец этого расположения показывают на
<a href="#figure_replication-multi-db">рис. 19.2</a>.</p>

<a name="figure_replication-multi-db"></a><p><b>Рис. 19.2.
Использование репликации, чтобы копировать базы данных, чтобы отделить
ведомые устройства репликации</b></p>
<img src="multi-db.png" width="424" height="178">

<p>Вы можете достигнуть этого разделения, конфигурируя ведущее устройство
и ведомые устройства как обычно, затем ограничивая двоичные запросы журнала,
которые каждое ведомое устройство обрабатывает при использовании
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a> на каждом ведомом устройстве.</p>

<p>Вы не должны использовать
<a href="#option_mysqld_replicate-do-db"><code>--replicate-do-db
</code></a> с этой целью, используя основанную на запросе репликацию, так как
основанная на запросе репликация заставляет эффекты этой опции изменяться
согласно базе данных, которая в настоящее время выбирается. Это относится к
репликации смешанного формата также, так как это позволяет некоторым
обновлениям копироваться, используя основанный на запросе формат.</p>

<p>Однако, должно быть безопасно использовать
<a href="#option_mysqld_replicate-do-db"><code>--replicate-do-db
</code></a> с этой целью, если Вы используете только основанную на строке
репликацию, так как в этом случае в настоящее время выбираемая база данных не
имеет никакого влияния на работу опции.</p>

<p>Например, чтобы поддержать разделение как показано на
<a href="#figure_replication-multi-db">рис. 19.2</a>,
Вы должны сконфигурировать каждое ведомое устройство репликации следующим
образом, перед выполнением <a href="sql.htm#start-slave"><code>START SLAVE
</code></a>:</p>

<ul><li><p>Ведомое устройство репликации 1 должно использовать
<code>--replicate-wild-do-table=databaseA.%</code>.</li>
<li>Ведомое устройство репликации 2 должно использовать
<code>--replicate-wild-do-table=databaseB.%</code>.</li>
<li>Ведомое устройство репликации 3 должно использовать
<code>--replicate-wild-do-table=databaseC.%</code>.</p></li></ul>

<p>Каждое ведомое устройство в этой конфигурации получает весь двоичный
журнал от ведущего устройства, но запускает только те события, которые
относятся к базам данных и таблицам, включенным на том ведомом устройстве
опцией <a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a>.</p>

<p>Если у Вас есть данные, которые должны быть синхронизированы к ведомым
устройствам прежде, чем репликация запустится, у Вас есть выбор:</p>
<ul><li><p>Синхронизируйте все данные к каждому ведомому устройству и удалите
базы данных, таблицы, все, что Вы не хотите сохранять.</li>

<li>Используйте <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a>, чтобы создать отдельный файл дампа для каждой базы
данных и загрузить соответствующий файл дампа на каждом ведомом устройстве.
</li>

<li>Используйте дамп файла необработанных данных и включите только
определенные файлы и базы данных, в которых Вы нуждаетесь для
каждого ведомого устройства.</p>

<p>Это не работает с <a href="innodb.htm"><code>InnoDB</code></a>, если Вы
не используете <a href="innodb.htm#sysvar_innodb_file_per_table"><code>
innodb_file_per_table</code></a>.</p></li></ul>

<h3><a name="replication-solutions-performance"></a>19.3.7.
Улучшение работы репликации</h3>
<p>Поскольку число ведомых устройств, соединяющихся с ведущим устройством,
увеличивается, загрузка, хотя и минимально, также увеличивается, поскольку
каждое ведомое устройство использует соединение клиента с ведущим
устройством. Кроме того, поскольку каждое ведомое устройство должно получить
полную копию основного двоичного журнала, сетевая загрузка на ведущем
устройстве может также увеличить и создать узкое место.</p>

<p>Если Вы используете большое количество ведомых устройств, соединенных с
одним ведущим устройством, и ведущее устройство также занято, обрабатывая
запросы (например, как часть решения масштаба),
то Вы можете хотеть улучшить исполнение процесса репликации.</p>

<p>Один способ улучшить исполнение процесса репликации состоит в том, чтобы
создать более глубокую структуру репликации, которая позволяет ведущему
устройству копировать только к одному ведомому устройству, а остающиеся
ведомые устройства должны соединиться с этим основным ведомым устройством для
их отдельных требований репликации. Образец этой структуры показывают на
<a href="#figure_replication-performance">рис. 19.3</a>.</p>

<a name="figure_replication-performance"></a><p><b>Рис. 19.3.
Использование дополнительного узла репликации, чтобы улучшить работу</b></p>
<img src="submast.png" width="534" height="179">
<p>Вы должны сконфигурировать экземпляры MySQL следующим образом:</p>

<ul><li><p>Ведущее устройство 1 является основным ведущим устройством,
где все изменения и обновления написаны в базу данных.
Двоичное журналирование должно быть включено на этой машине.</li>

<li>Ведущее устройство 2 является ведомым устройством ведущего устройства 1,
которое обеспечивает функциональность репликации ведомым устройствам в
структуре репликации. Ведущее устройство 2 является единственной машиной,
которой разрешено соединяться с ведущим устройством 1. Ведущему устройству 2
также надо включить двоичное журналирование и опцию
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a>, чтобы инструкции репликации от ведущего
устройства 1 были также написаны ведущему устройству 2 в двоичный журнал так,
чтобы они могли оттуда копироваться истинно ведомым устройствам.</li>

<li>Ведомые устройства 1, 2 и 3 работают как ведомые устройства ведущего
устройства 2 и копируют информацию от ведущего устройства 2, которая
фактически состоит из обновлений с ведущего устройства 1.</p></li></ul>

<p>Вышеупомянутое решение уменьшает загрузку клиента и сетевого
интерфейса на основном ведущем устройстве, что должно улучшить эффективность
работы основного ведущего устройства, когда используется в качестве прямого
решения для базы данных.</p>

<p>Если Ваши ведомые устройства испытывают затруднения, отставая
от процесса репликации на ведущем устройстве, есть много доступных опций:</p>
<ul><li><p>Если возможно, поместите журналы реле и файлы с данными на
различных физических дисках. Чтобы сделать это, используйте опцию
<a href="#option_mysqld_relay-log"><code>--relay-log</code></a>,
чтобы определить местоположение журнала реле.</li>

<li>Если ведомые устройства значительно медленнее,
чем ведущее устройство, Вы можете хотеть разделить работу
по мультиплицированию различных баз данных различным ведомым устройствам. См.
<a href="#replication-solutions-partitioning">раздел 19.3.6</a>.
</li>

<li>Если Ваше ведущее устройство использует транзакции, и Вы не обеспокоены
операционной поддержкой на Ваших ведомых устройствах, используйте
<code>MyISAM</code> или другой нетранзакционной механизм на ведомых
устройствах. См. <a href="#replication-solutions-diffengines">
раздел 19.3.4</a>.</li>

<li>Если Ваши ведомые устройства не действуют как ведущие устройства,
и у Вас есть потенциальное решение, чтобы гарантировать, что Вы можете
восстановить ведущее устройство в случае отказа, то Вы можете выключить
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a>. Это защищает ведомые устройства от
журналирования событий, которые они запустили, в их
собственный двоичный журнал.</p></li></ul>

<h3><a name="replication-solutions-switch"></a>19.3.8.
Переключающиеся ведущие устройства</h3>
<p>Используя репликацию с GTID (см. <a href="#replication-gtids">
раздел 19.1.3</a>), Вы можете обеспечить переключение между ведущим и
ведомыми устройствами в случае отказа, используя
<span><strong>mysqlfailover</strong></span>, который обеспечен
MySQL Utilities, см.
<a href="../../../dev.mysql.com/doc/mysql-utilities/1.5/en/mysqlfailover.html"
target="_top"><span><strong>mysqlfailover</strong></span></a>.
Если Вы не используете GTID и поэтому не можете использовать
<span><strong>mysqlfailover</strong></span>, Вы должны настроить ведущее
устройство и одно или более ведомых устройств, Вы должны также написать
приложение или скрипт, который контролирует ведущее устройство, чтобы
проверить, работает ли оно, и инструктирует ведомые устройства и приложения
изменяться на другое ведущее устройство в случае отказа. Этот раздел
обсуждает некоторые из проблем, с которыми сталкиваются, настраивая
систему таким образом.</p>

<p>Вы можете сказать ведомому устройству изменяться на новое ведущее
устройство, используя <a href="sql.htm#change-master-to"><code>CHANGE MASTER
TO</code></a>. Ведомое устройство не проверяет, совместимы ли базы данных по
ведущему устройству, это просто начинает читать и запускать события от
указанных координат в двоичном журнале нового ведущего устройства.
Все серверы в группе, как правило, запускают те же самые события от того же
самого двоичного файла системного журнала, так что изменение источника
событий не должно затронуть структуру или целостность базы данных при
условии, что Вы осуществляете заботу о произведении изменения.</p>

<p>Ведомые устройства должны быть выполнены с
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>,
если они не используют GTID, тогда они должны также быть выполнены без
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a>. Таким образом, ведомое устройство готово
стать ведущим устройством, не перезапуская ведомое устройство
<a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>.
Предположите, что Вам показали структуру на
<a href="#figure_replication-redundancy-before">рис. 19.4</a>.</p>

<a name="figure_replication-redundancy-before"></a>
<p><b>Рис. 19.4. Использование начальной структуры репликации</b></p>
<img src="before.png" width="504" height="353">

<p>В этой диаграмме <code>MySQL Master</code> содержит основную базу данных,
узлы <code>MySQL Slave</code> это ведомые устройства репликации, а <code>Web
Client</code> ведут чтения и записи базы данных. Веб-клиенты, которые
выпускают только чтения (и обычно соединялись бы с ведомыми устройствами), не
показывают, поскольку они не должны переключиться на новый сервер в случае
отказа. Для более подробного примера структуры репликации масштаба
чтения-записи см.
<a href="#replication-solutions-scaleout">раздел 19.3.5</a>.</p>

<p>Каждый MySQL Slave (<code>Slave 1</code>, <code>Slave 2</code> и
<code>Slave 3</code>) это ведомое устройство, работающее с
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a> и
без <a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a>. Поскольку обновления, полученные ведомым
устройством от ведущего не зарегистрированы в двоичный журнал, если задана
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a>, каждое ведомое устройство пусто
первоначально. Если по некоторым причинам <code>MySQL Master</code>
становится недоступным, Вы можете выбрать одно из ведомых устройств, чтобы
стать новым ведущим устройством. Например, если Вы выбираете <code>Slave 1
</code>, все <code>Web Clients</code> должны быть перенаправлены к
<code>Slave 1</code>, который пишет обновления его двоичного журнала.
<code>Slave 2</code> и <code>Slave 3</code> должны тогда
копировать от <code>Slave 1</code>.</p>

<p>Причина выполнения ведомого устройства без
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a> необходимость препятствовать тому, чтобы
ведомые устройства получили обновления дважды в случае, если Вы заставляете
одно из ведомых устройств становиться новым ведущим устройством. Если
<code>Slave 1</code> имеет включенную опцию
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a>, это пишет любые обновления, которые получает
от <code>Master</code> в его собственный двоичный журнал. Это означает, что
когда <code>Slave 2</code> меняется от <code>Master</code> на
<code>Slave 1</code> как его ведущее устройство, это может получить
обновления из <code>Slave 1</code>, которые это уже получило от <code>Master
</code>.</p>

<p>Удостоверьтесь, что все ведомые устройства обработали любые запросы в
своем журнале реле. На каждом ведомом устройстве выполните <code>STOP SLAVE
IO_THREAD</code>, проверьте вывод
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>,
пока Вы не увидите <code>Has read all relay log</code>. Когда это истина для
всех ведомых устройств, они могут быть реконфигурированы к новой установке.
На ведомом устройстве <code>Slave 1</code>, чтобы стать ведущим устройством,
выполните <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> и
<a href="sql.htm#reset-master"><code>RESET MASTER</code></a>.</p>

<p>На других ведомых устройствах <code>Slave 2</code> и <code>Slave3</code>,
используйте <a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> и
<code>CHANGE MASTER TO MASTER_HOST='Slave1'</code> (где <code>'Slave1'</code>
представляет реальное имя хоста <code>Slave 1</code>). Чтобы применить
<code>CHANGE MASTER TO</code>, добавьте всю информацию о том, как соединиться
с <code>Slave 1</code> из <code>Slave 2</code> или
<code>Slave 3</code> (<em><code>user</code></em>,
<em><code>password</code></em>, <em><code>port</code></em>).
Командуя <code>CHANGE MASTER TO</code>, нет никакой потребности определить
название файла системного журнала или позицию журнала на <code>Slave 1
</code>: начало первого файла двоичного системного журнала и позиция 4
являются значениями по умолчанию. Наконец, надлежит выполнить
<a href="sql.htm#start-slave"><code>START SLAVE</code></a> на
машинах <code>Slave 2</code> и <code>Slave 3</code>.</p>

<p>Как только новая установка репликации находится где должна, Вы должны
сказать каждому из <code>Web Client</code> направить его запросы на
<code>Slave 1</code>. Теперь все запросы обновлений, посланные
<code>Web Client</code> к <code>Slave 1</code> написаны двоичному журналу
<code>Slave 1</code>, который содержит каждый запрос обновления, посланный в
<code>Slave 1</code> после отказа <code>Master</code>.</p>

<p>Получающяяся структура серверов показана на
<a href="#figure_replication-redundancy-after">рис. 19.5</a>.</p>
<a name="figure_replication-redundancy-after"></a>
<p><b>Рис. 19.5. Использование репликации после сбоя</b></p>
<img src="after.png" width="538" height="432">

<p>Когда <code>Master</code> становится доступным снова, Вы должны сделать
его ведомым устройством <code>Slave 1</code>. Чтобы сделать это, на
<code>Master</code> выполните <a href="sql.htm#change-master-to">
<code>CHANGE MASTER TO</code></a> как ранее на <code>Slave 2</code> и
<code>Slave 3</code>. <code>Master</code> становится ведомым устройством
<code>S1ave 1</code> и пишет события за время своего отключения.</p>

<p>Чтобы сделать <code>Master</code> ведущим устройством снова, используйте
предыдущую процедуру как будто <code>Slave 1</code> недоступно и
<code>Master</code> должно быть новым ведущим устройством. Во время этой
процедуры не забывайте выполнить <a href="sql.htm#reset-master"><code>RESET
MASTER</code></a> на <code>Master</code> прежде, чем сделать <code>Slave
1</code>, <code>Slave 2</code> и <code>Slave 3</code> ведомыми устройствами
<code>Master</code>. Если Вы не в состоянии сделать это, ведомые устройства
могут устаревшее состояние до пункта, в котором
<code>Master</code> стал недоступным.</p>

<p>Вы должны знать, что нет никакой синхронизации между ведомыми
устройствами, даже когда они совместно используют то же самое ведущее
устройство, и таким образом некоторые ведомые устройства могут значительно
отличаться. Это означает, что в некоторых случаях процедура, обрисованная в
общих чертах в предыдущем примере, не могла бы работать как ожидалось.
Практически, однако, все ведомые устройства должны быть относительно
близко друг к другу.</p>

<p>Один способ держать приложения в курсе местоположения ведущего устройства
состоит в том, чтобы иметь динамическую запись DNS для ведущего устройства. С
<code>bind</code> можно применить <code>nsupdate</code>, чтобы
обновить DNS динамически.</p>

<h3><a name="replication-solutions-secure-connections"></a>19.3.9.
Настройка репликации, чтобы использовать безопасные соединения</h3>
<p>Чтобы использовать безопасное соединение для того, чтобы зашифровать
передачу двоичного журнала, требуемого во время репликации,
ведущее и ведомые устройства должны поддерживать зашифрованные сетевые
соединения. Если сервер не поддерживает безопасные соединения (потому что он
не был собран или сконфигурирован для них), репликация через
зашифрованное соединение невозможна.</p>

<p>Устанавливание безопасных соединений для репликации подобно выполнению
этого для соединений клиент-сервер. Вы должны получить (или создать),
подходящий сертификат безопасности, что Вы можете использовать на ведущем
устройстве, и сертификат (из того же самого центра сертификации) на каждом
ведомом устройстве. Вы должны также получить подходящие ключевые файлы.</p>
<p>См. <a href="security.html#using-secure-connections">раздел 7.4.4</a>.</p>

<p>Чтобы включить безопасные соединения на ведущем устройстве, Вы должны
создать или получить подходящий сертификат и ключевые файлы, затем добавить
следующие параметры к конфигурации ведущего устройства в пределах раздела
<code>[mysqld]</code> файл <code>my.cnf</code> ведущего устройства,
изменяя имена файлов по мере необходимости:
<pre>
[mysqld]
ssl-ca=cacert.pem
ssl-cert=server-cert.pem
ssl-key=server-key.pem
</pre>

<p>Пути к файлам могут быть относительными или абсолютными,
мы рекомендуем, чтобы Вы всегда использовали полные пути.</p>
<p>Опции здесь следующие:</p>
<ul><li><p><a href="security.html#option_general_ssl-ca"><code>ssl-ca</code>
</a> сертификат Certificate Authority (CA).</li>

<li><a href="security.html#option_general_ssl-cert"><code>ssl-cert</code></a>
сертификат открытого ключа сервера. Это можно послать клиенту и
заверено сертификатом CA.</li>
<li><a href="security.html#option_general_ssl-key"><code>ssl-key</code></a>
частный ключ сервера.</p></li></ul>

<p>На ведомом устройстве есть два способа определить информацию, запрошенную
для того, чтобы соединиться надежно с ведущим устройством. Вы можете назвать
ведомый сертификат и ключевые файлы в разделе <code>[client]</code> файла
<code>my.cnf</code> ведомого устройства
или Вы можете явно определить ту информацию, используя
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>:</p>

<ul><li><p>Чтобы назвать ведомый сертификат и ключевые файлы, используя файл
опции, добавьте следующие строки к разделу <code>[client]</code> файла
<code>my.cnf</code> ведомого устройства, изменяя имена файлов
по мере необходимости:
<pre>
[client]
ssl-ca=cacert.pem
ssl-cert=client-cert.pem
ssl-key=client-key.pem
</pre>

<p>Перезапустите ведомый сервер, используя опцию
<a href="#option_mysqld_skip-slave-start"><code>
--skip-slave-start</code></a>, чтобы препятствовать тому, чтобы ведомое
устройство соединилось с ведущим устройством. Используйте
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>,
чтобы определить основную конфигурацию, используя опцию
<code>MASTER_SSL</code>, чтобы соединиться надежно:
<pre>
mysql&gt; CHANGE MASTER TO MASTER_HOST='master_hostname',
    -&gt;        MASTER_USER='replicate',
    -&gt;        MASTER_PASSWORD='password', MASTER_SSL=1;
</pre></li>

<li>Чтобы определить сертификат и ключевые имена, используя
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>,
приложите соответствующие опции <code>MASTER_SSL_<em><code>xxx</code></em>
</code>:
<pre>
mysql&gt; CHANGE MASTER TO MASTER_HOST='master_hostname',
    -&gt;        MASTER_USER='replicate', MASTER_PASSWORD='password',
    -&gt;        MASTER_SSL=1, MASTER_SSL_CA = 'ca_file_name',
    -&gt;        MASTER_SSL_CAPATH = 'ca_directory_name',
    -&gt;        MASTER_SSL_CERT = 'cert_file_name',
    -&gt;        MASTER_SSL_KEY = 'key_file_name';
</pre></li></ul>

<p>После того, как основная информация была обновлена, запустите
ведомый процесс репликации:
<pre>
mysql&gt; START SLAVE;
</pre>

<p>Вы можете использовать <a href="sql.htm#show-slave-status"><code>SHOW
SLAVE STATUS</code></a>, чтобы подтвердить, что безопасное соединение
было установлено успешно.</p>
<p>См. <a href="sql.htm#change-master-to">раздел 14.4.2.1</a>.</p>

<p>Если Вы хотите провести в жизнь использование безопасных соединений во
время репликации, надо создать пользователя и использовать опцию
<code>REQUIRE SSL</code>, затем предоставить тому пользователю привилегию
<a href="security.html#priv_replication-slave"><code>REPLICATION SLAVE</code>
</a>:
<pre>
mysql&gt; CREATE USER 'repl'@'%.mydomain.com'
    -&gt;        IDENTIFIED BY 'slavepass' REQUIRE SSL;
mysql&gt; GRANT REPLICATION SLAVE ON *.* TO 'repl'@'%.mydomain.com';
</pre>

<p>Если учетная запись уже существует, Вы можете добавить <code>REQUIRE
SSL</code> с этим запросом:
<pre>
mysql&gt; ALTER USER 'repl'@'%.mydomain.com' REQUIRE SSL;
</pre>

<h3><a name="replication-semisync"></a>19.3.10. Полусинхронная репликация
</h3>
<p>В дополнение к встроенной асинхронной репликации, MySQL 8.0 поддерживает
интерфейс к полусинхронной репликации, который осуществлен плагинами. Этот
раздел обсуждает то, что такое полусинхронная репликация и как это работает.
Следующие разделы покрывают административный интерфейс к полусинхронной
репликации и как установить, сконфигурировать и контролировать это.</p>

<p>Репликация MySQL по умолчанию является асинхронной.
Ведущее устройство пишет события в двоичный журнал, но не знает, что с ними
дальше будет. С асинхронной репликацией, если ведущее устройство отказывает,
транзакции, которые оно передало, возможно, не были переданы ни к какому
ведомому устройству. Это может привести к серверу, который пропускает
транзакции относительно ведущего устройства.</p>

<p>Полусинхронная репликация может использоваться в качестве
альтернативы асинхронной репликации:</p>
<ul><li><p>Ведомое устройство указывает, полусинхронно-способно ли оно,
когда это соединяется с ведущим устройством.</li>

<li>Если полусинхронная репликация включена на основной стороне и есть по
крайней мере одно полусинхронное ведомое устройство, поток, который выполняет
транзакцию, передает на ведущем устройстве, блокирует и ждет, пока по
крайней мере одно полусинхронное ведомое устройство не признает, что получило
все события для транзакции, или пока тайм-аут не происходит.</li>

<li>Ведомое устройство подтверждает получение событий транзакции только
после того, как события были написаны журналу реле и сброшены на диск.</li>
<li>Если тайм-аут происходит без какого-либо ведомого устройства,
признававшего транзакцию, ведущее устройство возвращается к асинхронной
репликации. Когда по крайней мере одно полусинхронное ведомое устройство
нагоняет, ведущее устройство возвращается к полусинхронной репликации.</li>

<li>Полусинхронная репликация должна быть включена на основных и на ведомых
сторонах. Если полусинхронная репликация отключена или включена на ведущем
устройстве, но не вкючена ни на каких ведомых устройствах, ведущее устройство
использует асинхронную репликацию.</p></li></ul>

<p>В то время как ведущее устройство блокирует (ждет признания от ведомого
устройства), оно не возвращается к сеансу, который выполнил транзакцию. Когда
блок заканчивается, ведущее устройство возвращается к сеансу, который тогда
может продолжить выполнять другие запросы. В этом пункте транзакция передана
на основной стороне, и получение ее событий было подтверждено по крайней мере
одним ведомым устройством.</p>

<p>Число признаний, которое ведущее устройство должно получить на транзакцию
перед переходом, является конфигурируемым с использованием переменной
<a href="server.htm#sysvar_rpl_semi_sync_master_wait_for_slave_count"><code>
rpl_semi_sync_master_wait_for_slave_count</code></a>. По умолчанию 1.</p>

<p>Блокирование также происходит после отмен, которые написаны в двоичный
журнал, что происходит, когда транзакция, которая изменяет нетранзакционные
таблицы, удалена. Отмененная транзакция зарегистрирована даже при том, что
она не имеет никакого эффекта для транзакционных таблиц, потому что
модификации нетранзакционных таблиц не могут быть удалены и должны быть
посланы в ведомые устройства.</p>

<p>Для запросов, которые не происходят в транзакционном контексте (то есть,
когда никакая транзакция не была запущена с
<a href="sql.htm#commit"><code>START TRANSACTION</code></a> или
<a href="sql.htm#set-variable"><code>SET autocommit = 0</code></a>),
autocommit включен и каждый запрос передается неявно. С полусинхронной
репликацией ведущее устройство блокирует для каждого такого запроса, как это
делается для явной передачи транзакции.</p>

<p>Чтобы понять значение "полу" в полусинхронной репликации, сравните это с
асинхронной и полностью синхронной репликацией:</p>
<ul><li><p>С асинхронной репликацией ведущее устройство пишет события в
двоичный журнал, и ведомые устройства просят их, когда они готовы. Нет
никакой гарантии, что любое событие будет когда-либо достигать
любого ведомого устройства.</li>

<li>С полностью синхронной репликацией, когда ведущее устройство передает
транзакцию, все ведомые устройства также передадут транзакцию прежде, чем
ведущее устройство возвратится к сеансу, который выполнил транзакцию.
Недостаток этого состоит в том, что могло бы быть много задержек,
чтобы завершить транзакцию.</li>

<li>Полусинхронная репликация между асинхронной и полностью синхронной
репликацией. Ведущее устройство ждет только, пока по крайней мере одно
ведомое устройство не получило и зарегистрировало события.
Это не ждет всех ведомых устройств, чтобы подтвердить получение, и это
требует только подтверждения, а не того, чтобы события были полностью
запущены и переданы на ведомой стороне.</p></li></ul>

<p>По сравнению с асинхронной репликацией, полусинхронная репликация
обеспечивает улучшенную целостность данных потому что, когда передача
успешна, известно, что данные существуют по крайней мере в двух местах.
Пока полусинхронное ведущее устройство не получает признание от числа ведомых
устройств, сконфигурированных <a href="server.htm#sysvar_rpl_semi_sync_master_wait_for_slave_count">
<code>rpl_semi_sync_master_wait_for_slave_count</code></a>,
транзакция в ожидании и не передана.</p>

<p>Полусинхронная репликация также помещает ограничение скорости в занятые
сеансы, ограничивая скорость, на которой двоичные события журнала можно
послать от ведущего устройства в ведомое. Когда один пользователь будет
слишком занят, это замедлит его, что
полезно в некоторых ситуациях с развертыванием.</p>

<p>Полусинхронная репликация действительно оказывает некоторое исполнительное
влияние, потому что передачи происходят медленнее из-за потребности ждать
ведомые устройства. Это плата за увеличенную целостность данных. Количество
замедления по крайней мере, время, чтобы послать по TCP/IP туда и обратно
данные ведомому устройству и ждать признания ведомым устройством.
Это означает, что полусинхронная репликация работает лучше всего на близких
серверах, общающихся по быстрым сетям.</p>

<p><a href="server.htm#sysvar_rpl_semi_sync_master_wait_point"><code>
rpl_semi_sync_master_wait_point</code></a>управляет пунктом, в котором
полусинхронное ведущее устройство репликации ждет ведомого признания
прежде, чем возвратить состояние клиенту, который передал транзакцию.
Эти значения разрешены:</p>

<ul><li><p><code>AFTER_SYNC</code> (по умолчанию):
ведущее устройство пишет каждую транзакцию своему двоичному журналу и
ведомому устройству и синхронизирует двоичный журнал с диском. Ведущее
устройство ждет от ведомого признания после синхронизации. После получения
признания ведущее устройство передает транзакцию механизму хранения и
возвращает результат клиенту, который тогда может продолжить работу.</li>

<li><code>AFTER_COMMIT</code>: Ведущее устройство пишет каждую транзакцию
в свой двоичный журнал и ведомому устройству, синхронизирует двоичной журнал
и передает транзакцию механизму хранения. Ведущее устройство ждет от ведомого
признания после передачи. После получения признания ведущее устройство
возвращает результат клиенту, который тогда может продолжить работу.
</p></li></ul>

<p>Характеристики репликации этих настроек отличаются следующим образом:</p>
<ul><li><p>С <code>AFTER_SYNC</code> все клиенты видят переданную транзакцию
в то же самое время: после того, как это было признано ведомым устройством и
передано механизму хранения на ведущем устройстве. Таким образом, все клиенты
видят те же самые данные по ведущему устройству.</p>

<p>В случае основного отказа все транзакции, переданные на ведущем
устройстве, скопировались к ведомому устройству (сохранены в его журнале
реле). Катастрофический отказ ведущего устройства и переход
к ведомому устройству будут без потерь, потому что
ведомое устройство современно.</li>

<li>С <code>AFTER_COMMIT</code> клиент, выпускающий транзакцию, получает
статус возврата только после того, как сервер передает механизму хранения и
получает ведомое признание. После передачи и перед ведомым признанием, другие
клиенты могут видеть переданную транзакцию перед commit клиента.</p>

<p>Если что-то идет не так, как надо, таким образом, что ведомое устройство
не обрабатывает транзакцию, то в случае основного катастрофического отказа и
перехода к ведомому устройству, возможно, что такие клиенты будут видеть
потерю данных относительно того, что они видели на ведущем устройстве.
</p></li></ul>

<h4><a name="replication-semisync-interface"></a>19.3.10.1.
Административный интерфейс полусинхронной репликации</h4>
<p>У административного интерфейса к полусинхронной
репликации есть несколько компонентов:</p>

<ul><li><p>Два плагина осуществляют полусинхронную способность. Есть один
плагин для основной стороны и один для ведомой стороны.</li>
<li>Системные переменные управляют логикой плагина:</p>

<ul><li><p><a href="server.htm#sysvar_rpl_semi_sync_master_enabled"><code>
rpl_semi_sync_master_enabled</code></a></p>
<p>Средство управления, включена ли полусинхронная репликация на ведущем
устройстве. Чтобы включить или отключить плагин, установите эту переменную в
1 или 0, соответственно. Значение по умолчанию 0 (off).</li>

<li><a href="server.htm#sysvar_rpl_semi_sync_master_timeout"><code>
rpl_semi_sync_master_timeout</code></a></p>
<p>Значение в миллисекундах, которое управляет, сколько времени ведущее
устройство ждет при передаче признания от ведомого устройства перед
синхронизацией и возвратом к асинхронной репликации.
Значение по умолчанию 10000 (10 секунд).</li>

<li><a href="server.htm#sysvar_rpl_semi_sync_slave_enabled"><code>
rpl_semi_sync_slave_enabled</code></a></p>
<p>Аналогично <a href="server.htm#sysvar_rpl_semi_sync_master_enabled"><code>
rpl_semi_sync_master_enabled</code></a>, но управляет ведомым плагином.
</p></li></ul>

<p>Все переменные <code>rpl_semi_sync_<em><code>xxx</code></em></code>
рассмотрены в <a href="server.htm#server-system-variables">разделе 6.1.5</a>.
</li>
<li>Переменные состояния включают контроль полусинхронной
репликации. Некоторые примеры:</p>

<ul><li><p><a href="server.htm#statvar_Rpl_semi_sync_master_clients"><code>
Rpl_semi_sync_master_clients</code></a></p>
<p>Число полусинхронных ведомых устройств.</li>

<li><a href="server.htm#statvar_Rpl_semi_sync_master_status"><code>
Rpl_semi_sync_master_status</code></a></p>
<p>Является ли полусинхронная репликация в настоящее время работающей
на ведущем устройстве. Значение 1, если плагин был включен, и передача
признания не произошла. Это 0, если плагин не включен, или ведущее устройство
отступило к асинхронной репликации.</li>

<li><a href="server.htm#statvar_Rpl_semi_sync_master_no_tx"><code>
Rpl_semi_sync_master_no_tx</code></a></p>
<p>Число передач, которые не были признаны успешно ведомым устройством.</li>

<li><a href="server.htm#statvar_Rpl_semi_sync_master_yes_tx"><code>
Rpl_semi_sync_master_yes_tx</code></a></p>
<p>Число передач, которые были признаны успешно ведомым устройством.</li>

<li><a href="server.htm#statvar_Rpl_semi_sync_slave_status"><code>
Rpl_semi_sync_slave_status</code></a></p>
<p>Является ли полусинхронная репликация в настоящее время рабочей
на ведомом устройстве. Это 1, если плагин был включен, и ведомый поток
ввода/вывода работает, 0 иначе.</p></li></ul>

<p>Все переменные <code>Rpl_semi_sync_<em><code>xxx</code></em></code>
рассмотрены в <a href="server.htm#server-status-variables">разделе 6.1.7</a>.
</p></li></ul>

<p>Переменные состояния доступны, только если соответствующий основной или
ведомый плагин был установлен с
<a href="sql.htm#install-plugin"><code>INSTALL PLUGIN</code></a>.</p>

<h4><a name="replication-semisync-installation"></a>19.3.10.2.
Полусинхронная репликация: установка и конфигурация</h4>
<p>Полусинхронная репликация осуществлена, используя плагины, таким образом,
плагины должны быть установлены в сервер, чтобы сделать их доступными.
После того, как плагин был установлен, Вы управляете им посредством системных
переменных, связанных с ним. Эти системные переменные недоступны, пока
связанный плагин не был установлен.</p>

<p>Этот раздел описывает, как установить полусинхронные плагины репликации.
Для общей информации об установке плагинов см.
<a href="server.htm#server-plugin-loading">раздел 6.6.2</a>.</p>

<p>Чтобы использовать полусинхронную репликацию, следующие требования
должны быть удовлетворены:</p>
<ul><li><p>MySQL 5.5 или выше.</li>

<li>Способность установки плагинов требует сервера MySQL, который
поддерживает динамическую загрузку. Чтобы проверить это, проверьте что
значение <a href="server.htm#sysvar_have_dynamic_loading"><code>
have_dynamic_loading</code></a> = <code>YES</code>. Двоичные дистрибутивы
должны поддерживать динамическую загрузку.</li>

<li>Репликация должна уже работать, см.
<a href="#replication-configuration">раздел 19.1</a>.</li>
<li>Не должно быть многократных сконфигурированных каналов репликации.
Полусинхронная репликация совместима только с каналом репликации по
умолчанию. См. <a href="#replication-channels">раздел 19.2.3</a>.
</p></li></ul>

<p>Чтобы настроить полусинхронную репликацию, используйте следующие
инструкции. <a href="sql.htm#install-plugin"><code>INSTALL PLUGIN</code></a>,
<a href="sql.htm#set-variable"><code>SET GLOBAL</code></a>,
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> и
<a href="sql.htm#start-slave"><code>START SLAVE</code></a>, упомянутые здесь,
требуют привилегии <a href="security.html#priv_super"><code>SUPER</code></a>.
</p>

<p>Дистрибутивы MySQL включают полусинхронные файлы плагина репликации для
основной и ведомой сторон.</p>
<p>Чтобы быть применимым основным или ведомым сервером, соответствующий
файл библиотеки должен быть расположен в каталоге плагинов MySQL (каталог,
названный переменной <a href="server.htm#sysvar_plugin_dir"><code>plugin_dir
</code></a>). В случае необходимости, установите значение
<a href="server.htm#sysvar_plugin_dir"><code>plugin_dir</code></a>
при запуске сервера, чтобы сказать серверу местоположение каталога.</p>

<p>Базовые имена файла библиотеки <code>semisync_master</code> и
<code>semisync_slave</code>. Суффикс имени файла отличается в зависимости от
платформы (например, <code>.so</code> в Unix и <code>.dll</code> в Windows).
</p>

<p>Основной файл библиотеки должен присутствовать в каталоге плагинов
главного сервера. Ведомый файл библиотеки должен присутствовать в каталоге
плагинов каждого ведомого сервера.</p>

<p>Чтобы загрузить плагины, используйте <a href="sql.htm#install-plugin">
<code>INSTALL PLUGIN</code></a> на ведущем устройстве и на каждом ведомом
устройстве, которое должно быть полусинхронным (корректируйте
<code>.so</code> для Вашей платформы по мере необходимости).</p>

<p>На ведущем устройстве:
<pre>
INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
</pre>

<p>На каждом ведомом устройстве:
<pre>
INSTALL PLUGIN rpl_semi_sync_slave SONAME 'semisync_slave.so';
</pre>

<p>Если попытка установить плагин приводит к ошибке в Linux,
подобной показанной здесь, Вы должны установить <code>libimf</code>:
<pre>
mysql&gt; INSTALL PLUGIN rpl_semi_sync_master SONAME 'semisync_master.so';
ERROR 1126 (HY000): Can't open shared library
'/usr/local/mysql/lib/plugin/semisync_master.so'
(errno: 22 libimf.so: cannot open shared object file:
No such file or directory)
</pre>

<p>Вы можете получить <code>libimf</code> на
<a href="../../../dev.mysql.com/downloads/os-linux.html" target="_top">
http://dev.mysql.com/downloads/os-linux.html</a>.</p>

<p>Чтобы видеть, какие плагины установлены, используйте
<a href="sql.htm#show-plugins"><code>SHOW PLUGINS</code></a> или запросите
таблицу <a href="inform.htm#plugins-table"><code>INFORMATION_SCHEMA.PLUGINS
</code></a>.</p>

<p>Чтобы проверить установку, исследуйте таблицу
<a href="inform.htm#plugins-table"><code>INFORMATION_SCHEMA.PLUGINS</code>
</a> или используйте <a href="sql.htm#show-plugins"><code>SHOW PLUGINS</code>
</a> (см. <a href="server.htm#obtaining-plugin-information">раздел 6.6.3
</a>):
<pre>
mysql&gt; SELECT PLUGIN_NAME, PLUGIN_STATUS FROM INFORMATION_SCHEMA.PLUGINS
    -&gt;        WHERE PLUGIN_NAME LIKE '%semi%';
+----------------------+---------------+
| PLUGIN_NAME          | PLUGIN_STATUS |
+----------------------+---------------+
| rpl_semi_sync_master | ACTIVE        |
+----------------------+---------------+
</pre>

<p>После того, как полусинхронный плагин репликации был установлен,
он отключен по умолчанию. Плагины должны быть включены на основной и на
ведомой сторонах, чтобы включить полусинхронную репликацию. Если только одна
сторона будет включена, то репликация будет асинхронной.</p>

<p>Чтобы управлять, включен ли установленный плагин, устанавливайте
соответствующие системные переменные. Вы можете установить эти переменные при
использовании во время выполнения <a href="sql.htm#set-variable"><code>SET
GLOBAL</code></a> при запуске сервера в командной строке или в файле опций.
</p>

<p>Во время выполнения эти системные переменные основной стороны доступны:
<pre>
SET GLOBAL rpl_semi_sync_master_enabled = {0|1};
SET GLOBAL rpl_semi_sync_master_timeout = <em><code>N</code></em>;
</pre>

<p>На ведомой стороне эта системная переменная доступна:
<pre>
SET GLOBAL rpl_semi_sync_slave_enabled = {0|1};
</pre>

<p>Для <a href="server.htm#sysvar_rpl_semi_sync_master_enabled"><code>
rpl_semi_sync_master_enabled</code></a> или
<a href="server.htm#sysvar_rpl_semi_sync_slave_enabled"><code>
rpl_semi_sync_slave_enabled</code></a>
значение должно быть 1, чтобы позволить полусинхронную репликацию,
или 0, чтобы ее отключить. По умолчанию эти переменные установлены в 0.</p>

<p>Для <a href="server.htm#sysvar_rpl_semi_sync_master_timeout"><code>
rpl_semi_sync_master_timeout</code></a> значение <em><code>N</code></em> дано
в миллисекундах. Значение по умолчанию 10000 (10 секунд).</p>

<p>Если Вы включаете полусинхронную репликацию на ведомом устройстве во время
выполнения, Вы должны также запустить ведомый поток ввода/вывода (остановите
это сначала, если это уже работает), чтобы заставить ведомое устройство
соединяться с ведущим устройством и зарегистрироваться как
полусинхронное ведомое устройство:
<pre>
STOP SLAVE IO_THREAD;
START SLAVE IO_THREAD;
</pre>

<p>Если поток ввода/вывода уже работает, и Вы не перезапускаете его,
ведомое устройство продолжает использовать асинхронную репликацию.</p>
<p>При запуске сервера переменные, которые управляют полусинхронной
репликацией, могут быть установлены как параметры командной строки или в
файле опции. Установка, перечисленная в файле опции, вступает в силу каждый
раз, когда сервер запускается. Например, Вы можете установить переменные в
файлах <code>my.cnf</code> на основных и ведомых сторонах следующим образом.
</p>

<p>На ведущем устройстве:
<pre>
[mysqld]
rpl_semi_sync_master_enabled=1
rpl_semi_sync_master_timeout=1000   # 1 second
</pre>

<p>На каждом ведомом устройстве:
<pre>
[mysqld]
rpl_semi_sync_slave_enabled=1
</pre>

<h4><a name="replication-semisync-monitoring"></a>19.3.10.3.
Полусинхронный контроль репликации</h4>
<p>Плагины для полусинхронной репликации выставляют несколько переменных
состояния, которые Вы можете исследовать, чтобы определить его
конфигурацию и рабочее состояние.</p>

<p>Системная переменная отражает, как полусинхронная репликация
сконфигурирована. Чтобы проверить их значения, надо использовать
<a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a>:
<pre>
mysql&gt; SHOW VARIABLES LIKE 'rpl_semi_sync%';
</pre>

<p>Переменные состояния позволяют Вам контролировать работу полусинхронной
репликации. Чтобы проверить их значения, надо использовать
<a href="sql.htm#show-status"><code>SHOW STATUS</code></a>:
<pre>
mysql&gt; SHOW STATUS LIKE 'Rpl_semi_sync%';
</pre>

<p>Когда ведущее устройство переключается между асинхронной
или полусинхронной репликацией из-за тайм-аута или наверстывания ведомым,
это устанавливает значение
<a href="server.htm#statvar_Rpl_semi_sync_master_status"><code>
Rpl_semi_sync_master_status</code></a> соответственно. Автоматическое
отступление от полусинхронной до асинхронной репликации на ведущем устройстве
означает, что возможно для
<a href="server.htm#sysvar_rpl_semi_sync_master_enabled"><code>
rpl_semi_sync_master_enabled</code></a>
иметь значение 1 на основной стороне, даже когда полусинхронная репликация
является фактически не рабочей в настоящее время. Вы можете контролировать
<a href="server.htm#statvar_Rpl_semi_sync_master_status"><code>
Rpl_semi_sync_master_status</code></a>, чтобы определить, использует ли
ведущее устройство в настоящее время асинхронную
или полусинхронную репликацию.</p>

<p>Чтобы видеть, сколько полусинхронных ведомых устройств соединено,
надо проверить <a href="server.htm#statvar_Rpl_semi_sync_master_clients">
<code>Rpl_semi_sync_master_clients</code></a>.</p>

<p>Число передач, которые были признаны успешно или неудачно
ведомыми устройствами, обозначено
<a href="server.htm#statvar_Rpl_semi_sync_master_yes_tx"><code>
Rpl_semi_sync_master_yes_tx</code></a> и
<a href="server.htm#statvar_Rpl_semi_sync_master_no_tx">
<code>Rpl_semi_sync_master_no_tx</code></a>.</p>

<p>На ведомой стороне
<a href="server.htm#statvar_Rpl_semi_sync_slave_status"><code>
Rpl_semi_sync_slave_status</code></a> указывает, является ли полусинхронная
репликация в настоящее время рабочей.</p>

<h3><a name="replication-delayed"></a>19.3.11. Отсроченная репликация</h3>
<p>MySQL 8.0 поддерживает отложенную репликацию, таким образом, что ведомый
сервер сознательно отстает от ведущего устройства, по крайней мере, на
указанное количество времени. Задержка по умолчанию составляет 0 секунд.
Используйте опцию <code>MASTER_DELAY</code> в
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>,
чтобы установить задержку в to <em><code>N</code></em> секунд:
<pre>
CHANGE MASTER TO MASTER_DELAY = <em><code>N</code></em>;
</pre>

<p>Событие от ведущего устройства, не запущено, по крайней мере,
<em><code>N</code></em> секунд после его выполнения на ведущем устройстве.
Исключение: нет никакой задержки событий описания формата или ротации файла
системного журнала, которые затрагивают только внутреннее
состояние потока SQL.</p>

<p>Отсроченная репликация может использоваться в нескольких целях:</p>
<ul><li><p>Защищать от ошибок пользователя на ведущем устройстве. DBA может
откатить отсроченное ведомое устройство до прежнего уровня времени.</li>

<li>Проверить, как система ведет себя, когда есть задержка. Например, в
приложении задержка могла бы быть вызвана тяжелой задачей на ведомом
устройстве. Однако, может быть трудно воспроизвести этот уровень загрузки.
Отсроченная репликация может моделировать задержку, не имея необходимости
моделировать нагрузку. Это может также использоваться, чтобы отладить
условия, связанные с отстающим ведомым устройством.</li>

<li>Осмотреть, на что база данных была похожа давно, не имея необходимости
перезагружать резервное копирование. Например, если задержка одна неделя, и
DBA должен видеть то, на что была похожа база данных прежде, отсроченное
ведомое устройство может быть осмотрено.</p></li></ul>

<p><a href="sql.htm#start-slave"><code>START SLAVE</code></a> и
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> вступают в силу
немедленно и проигнорируют любую задержку. <a href="sql.htm#reset-slave">
<code>RESET SLAVE</code></a> сбрасывает задержку к 0.</p>

<p><a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
имеет три области, которые предоставляют информацию о задержке:</p>
<ul><li><p><code>SQL_Delay</code>: Неотрицательное целое число, указывающее
на число секунд, на которое ведомое устройство должно
изолировать ведущее устройство.</li>

<li><code>SQL_Remaining_Delay</code>:
Когда <code>Slave_SQL_Running_State</code> = <code>Waiting
until MASTER_DELAY seconds after master executed event</code>,
эта область содержит целое число, указывающее на число секунд,
оставшейся задержки. В других случаях эта область <code>NULL</code>.</li>

<li><code>Slave_SQL_Running_State</code>:
Строка, указывающая на статус потока SQL (аналог
<code>Slave_IO_State</code>). Значение идентично
<code>State</code> потока SQL как выведено на экран
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>.
</p></li></ul>

<p>Когда ведомый поток SQL ждет задержки прежде, чем запустить
событие, <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
показывает <code>State</code> как <code>Waiting until MASTER_DELAY seconds
after master executed event</code>.</p>

<h2><a name="replication-notes"></a>19.4. Примечания и подсказки репликации
</h2>
<h3><a name="replication-features"></a>19.4.1.
Особенности и проблемы репликации</h3>
<p>Следующие разделы предоставляют информацию о том, что поддержано в
репликации MySQL и о специфических вопросах и ситуациях, которые могут
произойти, копируя определенные запросы.</p>

<p>Основанная на запросе репликация зависит от совместимости на уровне SQL
между ведущим и ведомым устройствами. SBR требует, чтобы любые используемые
функции SQL поддерживались ведущим устройством и ведомыми серверами.
Например, если Вы используете функцию на главном сервере, которая доступна
только в MySQL 8.0 (или позже), Вы не можете копировать к ведомому
устройству, которое использует MySQL 5.7 (или ранее).</p>

<p>Такие несовместимости также могут произойти в пределах ряда выпуска,
используя выпуски подготовки производства MySQL. Например, функция
<a href="funct.htm#function_sleep"><code>SLEEP()</code></a>
доступна, начиная с MySQL 5.0.12. Если Вы используете эту функцию на ведущем
устройстве, Вы не можете копировать к ведомому устройству, которое использует
MySQL 5.0.11 или ранее.</p>

<p>Поэтому используйте Generally Available (GA) MySQL
для основанной на запросе репликации в производственной установке, так как мы
не вводим новые запросы SQL или изменяем их поведение в пределах данного ряда
выпуска, как только этот ряд достигает состояния выпуска GA.</p>

<p>Если Вы планируете использовать основанную на запросе репликацию
между MySQL 8.0 и предыдущей серией выпуска MySQL, также хорошая идея
консультироваться с выпуском <em>MySQL Reference Manual</em>
более раннего ряда выпуска для информации относительно характеристик
репликации того ряда.</p>

<p>С основанной на запросе репликацией MySQL могут быть проблемы с
мультиплицированием сохраненных подпрограмм или триггеров. Вы можете избежать
этих проблем при использовании основанной на строке репликации MySQL вместо
этого. Для подробного списка проблем см.
<a href="stored.htm#stored-programs-logging">раздел 21.7</a>.</p>

<h4><a name="replication-features-auto-increment"></a>19.4.1.1.
Репликация и AUTO_INCREMENT</h4>
<p>В основанной на запросе репликации <code>AUTO_INCREMENT</code>,
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()</code>
</a> и <a href="types.htm#datetime"><code>TIMESTAMP</code></a>
сделаны правильно согласно следующим исключениям:</p>

<ul><li><p>Запрос, вызывающий триггер или функцию, которая вызывает
обновление <code>AUTO_INCREMENT</code> не копируется правильно, используя
основанную на запросе репликацию. В MySQL 8.0 такие запросы отмечены
как опасные (Bug #45677).</li>

<li><a href="sql.htm#insert"><code>INSERT</code></a> в таблицу, у которой
есть сложный первичный ключ, который включает столбец
<code>AUTO_INCREMENT</code>, который не является первым столбцом этого
сложного ключа, не безопасен для основанного на запросе журналирования или
репликации. В MySQL 8.0 и позже такие запросы отмечены как
опасные (Bug #11754117, Bug #45670).</p>

<p>Эта проблема не затрагивает таблицы, используя
<a href="innodb.htm"><code>InnoDB</code></a> со столбцом
<a href="glossary.htm#glos_auto_increment">AUTO_INCREMENT</a>
требует по крайней мере одного ключа, где столбец auto-increment
единственный или крайний левый столбец.</li>

<li>Добавление <code>AUTO_INCREMENT</code> к таблице с
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
не мог бы произвести то же самое упорядочивание строк на ведомом и
ведущем устройствах. Это происходит, потому что порядок, в котором
пронумерованы строки, зависит от определенного механизма хранения,
используемого для таблицы и порядка, в который были вставлены строки.
Если важно иметь тот же самый порядок, строки должны быть упорядочены прежде,
чем назначить <code>AUTO_INCREMENT</code>. Допустим, что Вы хотите добавить
<code>AUTO_INCREMENT</code> в таблицу <code>t1</code>, у которой есть столбцы
<code>col1</code> и <code>col2</code>, следующие запросы производят новую
таблицу <code>t2</code> идентичную <code>t1</code>, но со
столбцом <code>AUTO_INCREMENT</code>:
<pre>
CREATE TABLE t2 LIKE t1;
ALTER TABLE t2 ADD id INT AUTO_INCREMENT PRIMARY KEY;
INSERT INTO t2 SELECT * FROM t1 ORDER BY col1, col2;
</pre>

<p>Чтобы гарантировать то же самое упорядочивание, <code>ORDER BY</code>
должен назвать <span><em>все</em></span> столбцы <code>t1</code>.</p>
<p>Эти инструкции подвергаются ограничениям
<a href="sql.htm#create-table-like"><code>CREATE TABLE ... LIKE</code></a>:
определения внешнего ключа проигнорированы, как и опции
<code>DATA DIRECTORY</code> и <code>INDEX DIRECTORY</code>.
Если табличное определение включает какую-либо из тех характеристик, надо
создать <code>t2</code> через <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a>, который идентичен тому, которым создали <code>t1</code>,
но с добавкой столбца <code>AUTO_INCREMENT</code>.</p>

<p>Независимо от метода, используемого, чтобы создать и заполнить копию,
имеющую столбец <code>AUTO_INCREMENT</code>, заключительный шаг должен
удалить оригинальную таблицу и затем переименовать копию:
<pre>
DROP t1;
ALTER TABLE t2 RENAME t1;
</pre>
<p>См. <a href="error.htm#alter-table-problems">раздел B.5.6.1</a>.
</p></li></ul>

<h4><a name="replication-features-blackhole"></a>19.4.1.2.
Репликация и таблицы BLACKHOLE</h4>
<p><a href="storage.htm#blackhole-storage-engine"><code>BLACKHOLE</code></a>
принимает данные, но отказывается от них и не хранит их. Выполняя двоичное
журналирование, все вставки к таким таблицам, всегда регистрируются,
независимо от формата журналирования. Обновления и удаления обработаны
по-другому в зависимости от того, какой формат журналирования применен.
С форматом регистрации запросов все воздействие на таблицу
<code>BLACKHOLE</code> зарегистрировано, но эффекты проигнорированы.
Когда используется основанное на строке журналирование, обновления и удаления
к таким таблицам просто пропущены, они не написаны в двоичный журнал.
Предупреждение зарегистрировано всякий раз, когда это происходит.</p>

<p>По этой причине мы рекомендуем, когда Вы копируете к таблицам, используя
<a href="storage.htm#blackhole-storage-engine"><code>BLACKHOLE</code></a>,
установить <a href="#sysvar_binlog_format"><code>binlog_format
</code></a> в <code>STATEMENT</code>, а не
<code>ROW</code> или <code>MIXED</code>.</p>

<h4><a name="replication-features-charset"></a>19.4.1.3.
Репликация и наборы символов</h4>
<p>Следующее относится к репликации между серверами MySQL, которые используют
различные наборы символов:</p>

<ul><li><p>Если у ведущего устройства есть базы данных с набором символов,
отличающимся от глобального <a href="server.htm#sysvar_character_set_server">
<code>character_set_server</code></a>,
Вы должны разработать Ваши <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> так, чтобы они неявно не положились на набор символов по
умолчанию базы данных. Хорошее обходное решение должно заявить набор символов
и сопоставление явно в <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a>.</p></li></ul>

<h4><a name="replication-features-checksum-table"></a>19.4.1.4.
Репликация и CHECKSUM TABLE</h4>
<p><a href="sql.htm#checksum-table"><code>CHECKSUM TABLE</code></a>
возвращает контрольную сумму, которая является расчетной строкой, используя
метод, который зависит от формата хранения строки таблицы, который, как
гарантируют, не останется тем же самым между выпусками MySQL. Например,
формат хранения для временных типов
<a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> и
<a href="types.htm#datetime"><code>TIMESTAMP</code></a> изменен в MySQL 5.6
до MySQL 5.6.5, так что, если таблицы 5.5 обновлены до MySQL 5.6, значение
контрольной суммы может измениться.</p>

<h4><a name="replication-features-create-if-not-exists"></a>19.4.1.5.
Репликация CREATE ... IF NOT EXISTS</h4>
<p>MySQL применяет эти правила, когда копирует различные
<code>CREATE ... IF NOT EXISTS</code>:</p>

<ul><li><p>Каждый <a href="sql.htm#create-database"><code>CREATE
DATABASE IF NOT EXISTS</code></a> копируется безотносительно того, существует
ли база данных уже на ведущем устройстве.</li>

<li>Точно так же каждый <a href="sql.htm#create-table"><code>CREATE TABLE
IF NOT EXISTS</code></a> без
<a href="sql.htm#select"><code>SELECT</code></a> копируется, существует ли
таблица уже на ведущем устройстве. Это включает
<a href="sql.htm#create-table-like"><code>CREATE TABLE IF NOT EXISTS ... LIKE
</code></a>. Репликация <a href="sql.htm#create-table-select"><code>CREATE
TABLE IF NOT EXISTS ... SELECT</code></a> следует несколько иным правилам,
см. <a href="#replication-features-create-select">раздел 19.4.1.6
</a>.</li>

<li><a href="sql.htm#create-event"><code>CREATE EVENT IF NOT EXISTS</code>
</a> всегда копируется в MySQL 8.0, неважно, существует ли событие, названное
в запросе, на ведущем устройстве.</p></li></ul>
<p>См. также Bug #45574.</p>

<h4><a name="replication-features-create-select"></a>19.4.1.6.
Репликация CREATE TABLE ... SELECT</h4>
<p>Этот раздел обсуждает, как MySQL копирует
<a href="sql.htm#create-table-select"><code>CREATE TABLE ... SELECT</code>
</a>.</p>

<p>MySQL 8.0 не позволяет <a href="sql.htm#create-table-select"><code>CREATE
TABLE ... SELECT</code></a>, чтобы произвести любые изменения в таблицах
кроме таблицы, которая составлена запросом. Некоторые более старые версии
MySQL разрешали этим запросым делать такое, это означает что, используя
основанную на запросе репликацию между MySQL 5.6 или более поздним ведомым
устройством и ведущим устройством, выполняющим предыдущую версию MySQL,
<a href="sql.htm#create-table-select"><code>CREATE TABLE ... SELECT</code>
</a>, вызывающий изменения в других таблицах на ведущем устройстве, терпит
неудачу на ведомом устройстве, заставляя репликацию остановиться.
Чтобы предотвратить это, Вы должны использовать основанную на строке
репликацию, переписать незаконное запрос прежде, чем выполнить это на ведущем
устройстве или обновить ведущее устройство до MySQL 8.0.
Если Вы хотите обновлять ведущее устройство, имейте в виду, что
<a href="sql.htm#create-table-select"><code>CREATE TABLE ... SELECT</code>
</a> терпит неудачу после обновления, если это не переписано, чтобы удалить
любые побочные эффекты на других таблицах. Это не проблема, используя
основанную на строке репликацию, потому что запрос зарегистрирован как
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
с любыми изменениями табличных данных, зарегистрированных, как вставка строк,
а не как <a href="sql.htm#create-table-select"><code>CREATE TABLE ... SELECT
</code></a>.</p>

<p>Эти поведения не зависят от версии MySQL:</p>
<ul><li><p><a href="sql.htm#create-table-select"><code>CREATE
TABLE ... SELECT</code></a> всегда неявно передает
(<a href="sql.htm#implicit-commit">раздел 14.3.3</a>).</li>

<li>Если целевая таблица не существует, журналирование происходит следующим
образом. Не имеет значения <code>IF NOT EXISTS</code>.</p>
<ul><li><p><code>STATEMENT</code> или <code>MIXED</code>:
запрос зарегистрирован как написан.</li>

<li><code>ROW</code>: запрос зарегистрирован как
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
с серией событий вставки строк.</p></li></ul></li>

<li>Если запрос терпит неудачу, ничто не зарегистрировано. Это включает
случай, что целевая таблица существует и нет <code>IF NOT EXISTS</code>.
</p></li></ul>

<p>Когда целевая таблица существует и задано <code>IF NOT EXISTS</code>,
MySQL 8.0 игнорирует запрос полностью; ничто не вставлено или
зарегистрировано. Обработка таких запросов в этом отношении изменилась
значительно в предыдущих выпусках MySQL, если Вы копируете от MySQL 5.5.6 или
ведущего устройства старшего возраста к более новому ведомому устройству, см.
<a href="../../../dev.mysql.com/doc/refman/5.5/en/replication-features-create-if-not-exists.html"
target="_top">Replication of CREATE ... IF NOT EXISTS Statements</a>.</p>

<h4><a name="replication-features-create-alter-drop-server"></a>19.4.1.7.
Репликация CREATE SERVER, ALTER SERVER и DROP SERVER</h4>
<p>В MySQL 8.0 <a href="sql.htm#create-server"><code>CREATE SERVER</code>
</a>, <a href="sql.htm#alter-server"><code>ALTER SERVER</code></a> и
<a href="sql.htm#drop-server"><code>DROP SERVER</code></a>
не написаны в двоичный журнал, независимо от двоичного формата
журналирования, который используется.</p>

<h4><a name="replication-features-current-user"></a>19.4.1.8.
Репликация CURRENT_USER()</h4>
<p>Следующие запросы поддерживают использование
<a href="funct.htm#function_current-user"><code>CURRENT_USER()</code></a>,
чтобы взять место названия (и, возможно, узел) пользователя или определителя,
в таких случаях <a href="funct.htm#function_current-user"><code>
CURRENT_USER()</code></a> расширен как и где необходимо:</p>

<ul><li><p><a href="sql.htm#drop-user"><code>DROP USER</code></a></li>
<li><a href="sql.htm#rename-user"><code>RENAME USER</code></a></li>
<li><a href="sql.htm#grant"><code>GRANT</code></a></li>
<li><a href="sql.htm#revoke"><code>REVOKE</code></a></li>
<li><a href="sql.htm#create-function"><code>CREATE FUNCTION</code></a></li>
<li><a href="sql.htm#create-procedure"><code>CREATE PROCEDURE</code></a></li>
<li><a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a></li>
<li><a href="sql.htm#create-event"><code>CREATE EVENT</code></a></li>
<li><a href="sql.htm#create-view"><code>CREATE VIEW</code></a></li>
<li><a href="sql.htm#alter-event"><code>ALTER EVENT</code></a></li>
<li><a href="sql.htm#alter-view"><code>ALTER VIEW</code></a></li>
<li><a href="sql.htm#set-password"><code>SET PASSWORD</code></a>
</p></li></ul>

<p>Когда <a href="funct.htm#function_current-user"><code>CURRENT_USER()
</code></a> или <a href="funct.htm#function_current-user"><code>
CURRENT_USER</code></a> используется в качестве определителя в любом из
запросов <a href="sql.htm#create-function"><code>CREATE FUNCTION</code></a>,
<a href="sql.htm#create-procedure"><code>CREATE PROCEDURE</code></a>,
<a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a>,
<a href="sql.htm#create-event"><code>CREATE EVENT</code></a>,
<a href="sql.htm#create-view"><code>CREATE VIEW</code></a> или
<a href="sql.htm#alter-view"><code>ALTER VIEW</code></a>,
когда двоичное журналирование включено, функциональная ссылка расширена
прежде, чем это будет написано в двоичный журнал, чтобы запрос отнесся к тому
же самому пользователю на ведущем и на ведомом устройствах, когда запрос
копируется. <a href="funct.htm#function_current-user"><code>CURRENT_USER()
</code></a> или <a href="funct.htm#function_current-user"><code>CURRENT_USER
</code></a> также расширен до того, как написан в двоичный журнал, когда
используется в <a href="sql.htm#drop-user"><code>DROP USER</code></a>,
<a href="sql.htm#rename-user"><code>RENAME USER</code></a>,
<a href="sql.htm#grant"><code>GRANT</code></a>,
<a href="sql.htm#revoke"><code>REVOKE</code></a> или
<a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>.</p>

<h4><a name="replication-features-drop-if-exists"></a>19.4.1.9.
Репликация DROP ... IF EXISTS</h4>
<p><a href="sql.htm#drop-database"><code>DROP DATABASE IF EXISTS</code></a>,
<a href="sql.htm#drop-table"><code>DROP TABLE IF EXISTS</code></a> и
<a href="sql.htm#drop-view"><code>DROP VIEW IF EXISTS</code></a>
всегда копируются, даже если база данных, таблица или представление, которое
будет удалено, не существуют на ведущем устройстве. Это должно гарантировать,
что объект, который будет удален, не существует на ведущем или на ведомом
устройстве, когда ведомое устройство догонит ведущее.</p>

<p><code>DROP ... IF EXISTS</code> для сохраненных программ (хранимые
процедуры и функции, триггеры и события) также копируются, даже если
сохраненная программа, которая будет удалена, не существует
на ведущем устройстве.</p>

<h4><a name="replication-features-differing-tables"></a>19.4.1.10.
Репликация с отличающимися табличными определениями на
ведущем и ведомом устройствах</h4>
<p>Исходные и целевые таблицы для репликации не должны быть идентичными.
Таблица на ведущем устройстве может иметь больше или меньше столбцов, чем
копия на ведомом. Кроме того, соответствующие столбцы таблицы на ведущем
и ведомом устройствах могут использовать различные типы данных,
согласно определенным условиям.</p>

<p>Репликация между таблицами, которые разделены по-разному, не поддержана.
См. <a href="#replication-features-partitioning">раздел 19.4.1.19
</a>.</p>

<p>Во всех случаях, где у исходных и целевых таблиц нет идентичных
определений, имена базы данных и таблицы должны быть теми же самыми на
ведущем и ведомом устройствах. Дополнительные условия обсуждены с примерами
в следующих двух разделах.</p>

<h5><a name="replication-features-more-columns"></a>19.4.1.10.1.
Репликация с большим количеством столбцов на ведущем или ведомом устройстве
</h5>
<p>Вы можете копировать таблицу от ведущего устройства к ведомому
таким образом, что у основных и ведомых копий таблицы есть отличающееся число
столбцов согласно следующим условиям:</p>

<ul><li><p>Столбцы, характерные для обеих версий таблицы, должны быть
определены в том же самом порядке на ведущем и ведомом устройствах.</p>
<p>Это истина, даже если у обеих таблиц есть то же самое число столбцов.</li>

<li>Столбцы, характерные для обеих версий таблицы, должны быть определены
перед любыми дополнительными столбцами.</p>
<p>Это означает, что выполнение <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> на ведомом устройстве, где новый столбец вставлен в таблицу
в пределах диапазона столбцов, характерных для обеих таблиц, заставляет
репликацию терпеть неудачу, как показано в следующем примере:</p>

<p>Допустим, что таблица <code>t</code> на ведущем и ведомом устройствах
определена следующим запросом
<a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE t (c1 INT, c2 INT, c3 INT);
</pre>

<p>Допустим, что <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a>, показанный здесь, выполнен на ведомом устройстве:
<pre>
ALTER TABLE t ADD COLUMN cnew1 INT AFTER c3;
</pre>

<p>Предыдущий <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>
разрешен на ведомом устройстве, потому что столбцы
<code>c1</code>, <code>c2</code> и <code>c3</code>
характерны для обеих версий таблицы <code>t</code> и
останутся сгруппированными в обеих версиях таблицы перед любыми
столбцами, которые отличаются.</p>

<p>Однако, следующий <a href="sql.htm#alter-table"><code>ALTER
TABLE</code></a> не может быть выполнен
на ведомом устройстве, не заставляя репликацию сломаться:
<pre>
ALTER TABLE t ADD COLUMN cnew2 INT AFTER c2;
</pre>

<p>Репликация терпит неудачу после выполнения на ведомом устройстве
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>, потому что новый
столбец <code>cnew2</code> между столбцами, характерными для обеих версий
<code>t</code>.</li>

<li>У каждого столбца <span><span>extra</span></span> в версии таблицы,
имеющей больше столбцов, должно быть значение по умолчанию.</p>
<p>Значение по умолчанию столбца определено многими факторами, включая его
тип, определен ли он с <code>DEFAULT</code>, объявлено ли это как
<code>NULL</code> и серверный режим SQL во время его создания, для получения
дополнительной информации см. <a href="types.htm#data-type-defaults">
раздел 12.7</a>.</p></li></ul>

<p>Кроме того, когда у копии ведомого устройства таблицы есть больше
столбцов, чем у копии ведущего устройства, каждый столбец, характерный для
таблиц, должен использовать тот же самый тип данных в обеих таблицах.</p>

<p><b>Примеры. </b>Следующие примеры иллюстрируют некоторые допустимые
и недопустимые табличные определения:</p>

<p><b>Больше столбцов на ведущем устройстве. </b>
Следующие табличные определения допустимы и скопируются правильно:
<pre>
master&gt; CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
slave&gt;  CREATE TABLE t1 (c1 INT, c2 INT);
</pre>

<p>Следующие табличные определения подняли бы ошибку, потому что
определения столбцов, характерных для обеих версий таблицы, находятся
в различном порядке на ведомом устройстве, чем на ведущем:
<pre>
master&gt; CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
slave&gt;  CREATE TABLE t1 (c2 INT, c1 INT);
</pre>

<p>Следующие табличные определения также подняли бы ошибку, потому что
определение дополнительного столбца на ведущем устройстве появляется перед
определениями столбцов, характерных для обеих версий таблицы:
<pre>
master&gt; CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
slave&gt;  CREATE TABLE t1 (c1 INT, c2 INT);
</pre>

<p><b>Больше столбцов на ведомом устройстве. </b>
Следующие табличные определения допустимы и cкопируютcя правильно:
<pre>
master&gt; CREATE TABLE t1 (c1 INT, c2 INT);
slave&gt;  CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
</pre>

<p>Следующие определения поднимают ошибку, потому что столбцы, характерные
для обеих версий таблицы, не определены в том же самом порядке:
<pre>
master&gt; CREATE TABLE t1 (c1 INT, c2 INT);
slave&gt;  CREATE TABLE t1 (c2 INT, c1 INT, c3 INT);
</pre>

<p>Следующие табличные определения также поднимают ошибку, потому что
определение для дополнительного столбца в версии ведомого устройства таблицы
появляется перед определениями для столбцов, которые характерны для
обеих версий таблицы:
<pre>
master&gt; CREATE TABLE t1 (c1 INT, c2 INT);
slave&gt;  CREATE TABLE t1 (c3 INT, c1 INT, c2 INT);
</pre>

<p>Следующие табличные определения терпят неудачу, потому что у версии
ведомого устройства таблицы есть дополнительные столбцы по сравнению с
версией ведущего устройства, и две версии таблицы используют различные типы
данных для общего столбца <code>c2</code>:
<pre>
master&gt; CREATE TABLE t1 (c1 INT, c2 BIGINT);
slave&gt;  CREATE TABLE t1 (c1 INT, c2 INT, c3 INT);
</pre>

<h5><a name="replication-features-different-data-types"></a>19.4.1.10.2.
Репликация столбцов, имеющих различные типы данных</h5>
<p>У соответствующих столбцов на ведущем устройстве и копии ведомого
устройства той же самой таблицы идеально должен быть тот же самый тип данных.
Однако, это не всегда строго проводится в жизнь, пока
определенные условия соблюдены.</p>

<p>Обычно возможно копировать от столбца типа определенных данных к другому
столбцу того же самого типа и того же самого размера или ширины или больше.
Например, Вы можете копировать от <code>CHAR(10)</code> к другому
<code>CHAR(10)</code> или из <code>CHAR(10)</code> в <code>CHAR(25)</code>
без любых проблем. В определенных случаях также возможно копировать от
столбца, имеющего один тип данных (на ведущем устройстве) к столбцу, имеющему
различный тип данных (на ведомом устройстве), когда тип данных версии
ведущего устройства столбца копируется на тип, который имеет тот же самый
размер или больше на ведомом устройстве, это известно
как <span>продвижение признака</span>.</p>

<p>Продвижение признака может использоваться с основанной на запросе и строке
репликацией и не зависит от механизма хранения. Однако, выбор формата
журналирования действительно имеет эффект на преобразования типа, которые
разрешены, подробные сведения обсуждены позже в этом разделе.</p>

<p>Используете ли Вы основанную на запросе или строке репликацию, копия
ведомого устройства таблицы не может содержать больше столбцов, чем копия
ведущего устройства, если Вы хотите использовать продвижение признака.</p>

<p><b>Основанная на запросе репликация. </b>Если бы запрос, выполненный на
ведущем устройстве, также выполнился бы успешно на ведомом, это должно также
скопироваться нормально. Другими словами, если запрос использует значение,
которое совместимо с типом данного столбца на ведомом устройстве, запрос
может копироваться. Например, Вы можете вставить любое значение, которое
помещается в <code>TINYINT</code>, в столбец <code>BIGINT</code>,
из этого следует, что, даже если Вы изменяете тип столбца
<code>TINYINT</code> в копии ведомого устройства таблицы на
<code>BIGINT</code>, любая вставка в этот столбец на ведущем устройстве,
которое преуспевает, должна также преуспеть на ведомом устройстве, так как
невозможно иметь <code>TINYINT</code>, которое является достаточно большим,
чтобы превысить <code>BIGINT</code>.</p>

<p><a name="replication-features-attribute-promotion"></a><b>
Основанная на строке репликация: продвижение признака. </b>
Основанная на строке репликация в MySQL 8.0 поддерживает продвижение
между меньшими типами данных и большими типами. Также возможно определить,
преобразование с потерями или нет удаленных для значений столбцов, как
объяснено позже в этом разделе.</p>

<p><b>Преобразование с потерями и без потерь. </b>
Когда целевой тип не может представить вставляемое значение, решение должно
быть принято о том, как обработать преобразование.
Если мы разрешаем преобразование, но усекаем (или иначе изменяем) исходное
значение, чтобы достигнуть <span><span>заполнения</span></span>
в целевом столбце, мы делаем то, что известно как <span>преобразование с
потерями</span>. Преобразование, которое не требует, чтобы усечение или
подобные модификации приспособили исходное значение столбца в целевом
столбце, является преобразованием <span>без потерь</span>.</p>

<p><b>Конверсионные режимы (переменная slave_type_conversions). </b>
Глобальная переменная сервера <code>slave_type_conversions</code> управляет
конверсионным режимом типа, используемым на ведомом устройстве. Эта
переменная берет ряд значений от следующей таблицы, которая показывает
эффекты каждого режима на поведении преобразования типа ведомого устройства:
</p>

<table border="1">
<thead><tr><th scope="col">Режим</th>
<th scope="col">Эффект</th></tr></thead>
<tbody><tr><td scope="row"><code>ALL_LOSSY</code></td>
<td><p>В этом режиме разрешены преобразования, которые означали бы, что
потеря информации разрешена.</p>

<p>Это не подразумевает, что преобразования не с потерями разрешены,
просто что только случаи, требующие преобразования с потерями или никакого
преобразования вообще, разрешены, например, включение
<span><em>только</em></span> этого режима разрешает сконвертировать
<code>INT</code> в <code>TINYINT</code> (преобразование с потерями), но не
<code>TINYINT</code> в <code>INT</code> (не с потерями).
Попытка последнего преобразования в этом случае заставила бы репликацию
останавливаться с ошибкой на ведомом устройстве.</p></td></tr>

<tr><td scope="row"><code>ALL_NON_LOSSY</code></td>
<td><p>Этот режим разрешает преобразования, которые не требуют усечения или
другой специальной обработки исходного значения, то есть, это разрешает
преобразования, где у целевого типа есть более широкий диапазон,
чем исходный тип.</p>

<p>У установки этого режима нет никакого ограничения, разрешены ли
преобразования с потерями, этим управляют с помощью режима
<code>ALL_LOSSY</code>. Если только <code>ALL_NON_LOSSY</code> установлен,
но нет <code>ALL_LOSSY</code>, тогда делая попытку преобразования, которое
привело бы к потере данных (например, <code>INT</code> в <code>TINYINT
</code>) ведомое устройство останавливается с ошибкой.</p></td></tr>

<tr><td scope="row"><code>ALL_LOSSY,ALL_NON_LOSSY</code></td>
<td><p>Когда этот режим установлен, все поддержанные
преобразования типа разрешены.</p></td></tr>

<tr><td scope="row"><code>ALL_SIGNED</code></td>
<td><p>Обработайте продвинутые типы целого числа как
значения со знаком (поведение по умолчанию).</p></td></tr>

<tr><td scope="row"><code>ALL_UNSIGNED</code></td>
<td><p>Обработайте продвинутые типы целого числа как
значения без знака.</p></td></tr>

<tr><td scope="row"><code>ALL_SIGNED,ALL_UNSIGNED</code></td>
<td><p>Обработайте продвинутые типы целого числа как со знаком, если
возможно, иначе как без знака.</p></td></tr>

<tr><td scope="row">[<span><em>empty</em></span>]</td>
<td><p>Когда не задано <code>slave_type_conversions</code>,
никакое продвижение признака не разрешено, это означает, что все столбцы в
исходных и целевых таблицах должны иметь те же самые типы.</p>
<p>Это режим по умолчанию.</p></td></tr></tbody></table>

<p>Когда тип целого числа продвинут, его знаковость не сохранена.
По умолчанию ведомое устройство обрабатывает все такие значения как
со знаком. Вы можете управлять этим с использованием
<code>ALL_SIGNED</code>, <code>ALL_UNSIGNED</code> или обоих.
<code>ALL_SIGNED</code> говорит ведомому устройству обрабатывать все
продвинутые типы целого числа как знаковые, <code>ALL_UNSIGNED</code>
инструктирует обрабатывать их как без знака. Определение обеих опций
предписывает ведомому устройству обработать значение как со знаком, если
возможно, иначе обработать это как без знака, порядок, в котором они
перечислены, не является существенным. <code>ALL_SIGNED</code> или
<code>ALL_UNSIGNED</code> не имеют эффекта, если также не применен
<code>ALL_LOSSY</code> или <code>ALL_NONLOSSY</code>.</p>

<p>Изменение конверсионного режима типа требует перезапуска ведомого
устройства с новым значением <code>slave_type_conversions</code>.</p>
<p><b>Поддержанные преобразования. </b>
Поддержанные преобразования между различными но подобными типами данных
показывают в следующем списке:</p>

<ul><li><p>Между любым из типов целого числа
<a href="types.htm#integer-types"><code>TINYINT</code></a>,
<a href="types.htm#integer-types"><code>SMALLINT</code></a>,
<a href="types.htm#integer-types"><code>MEDIUMINT</code></a>,
<a href="types.htm#integer-types"><code>INT</code></a> и
<a href="types.htm#integer-types"><code>BIGINT</code></a>.</p>

<p>Это включает преобразования между версиями со знаком и без
знака этих типов.</p>
<p>Преобразования с потерями сделаны, усекая исходное значение к максимуму
(или минимуму), разрешенному целевым столбцом. Для того, чтобы гарантировать
преобразования не с потерями, переходя от значения без знака к типу со
знаком, целевой столбец должен быть достаточно большим, чтобы приспособить
диапазон значений в исходном столбце. Например, Вы можете конвертировать
<code>TINYINT UNSIGNED</code> не с потерями к <code>SMALLINT</code>,
но не к <code>TINYINT</code>.</li>

<li>Между любым из десятичных типов
<a href="types.htm#fixed-point-types"><code>DECIMAL</code></a>,
<a href="types.htm#floating-point-types"><code>FLOAT</code></a>,
<a href="types.htm#floating-point-types"><code>DOUBLE</code></a> и
<a href="types.htm#fixed-point-types"><code>NUMERIC</code></a>.</p>

<p><code>FLOAT</code> в <code>DOUBLE</code> конвертируется без потерь,
<code>DOUBLE</code> в <code>FLOAT</code>может быть обработано только с
потерями. Преобразование от
<code>DECIMAL(<em><code>M</code></em>,<em><code>D</code></em>)</code>
в <code>DECIMAL(<em><code>M'</code></em>,<em><code>D'</code></em>)</code>,
где <code><em><code>D'</code></em> &gt;= <em><code>D</code></em></code> и
<code>(<em><code>M'</code></em>-<em><code>D'</code></em>)
&gt;= (<em><code>M</code></em>-<em><code>D</code></em></code>)
без потерь, для любого случая, где
<code><em><code>M'</code></em> &lt; <em><code>M</code></em></code>,
<code><em><code>D'</code></em> &lt; <em><code>D</code></em></code> или оба
только преобразование с потерями может быть сделано.</p>

<p>Для любого из десятичных типов, если значение, которое будет сохранено,
не может поместиться в целевой тип, значение округлено в меньшую сторону
согласно правилам, определенным для сервера в другом месте в документации.
См. <a href="funct.htm#precision-math-rounding">раздел 13.20.4</a>.</li>

<li>Между любым из строковых типов
<a href="types.htm#char"><code>CHAR</code></a>,
<a href="types.htm#char"><code>VARCHAR</code></a> и
<a href="types.htm#blob"><code>TEXT</code></a>,
включая преобразования между различными ширинами.</p>

<p>Конвертация <code>CHAR</code>, <code>VARCHAR</code> или
<code>TEXT</code> в <code>CHAR</code>, <code>VARCHAR</code> или
<code>TEXT</code> того же самого размера или больше никогда не делается с
потерями. Преобразование с потерями обработано, вставляя только первые
<em><code>N</code></em> символов строки на ведомом устройстве, где
<em><code>N</code></em> это ширина целевого столбца.</p>
<p>Репликация между столбцами, используя различные наборы
символов не поддержана.</p></li>

<li>Между любым из типов двоичных данных
<a href="types.htm#binary-varbinary"><code>BINARY</code></a>,
<a href="types.htm#binary-varbinary"><code>VARBINARY</code></a> и
<a href="types.htm#blob"><code>BLOB</code></a>,
включая преобразования между различными ширинами.</p>

<p>Конвертация <code>BINARY</code>, <code>VARBINARY</code> или
<code>BLOB</code> в <code>BINARY</code>,
<code>VARBINARY</code> или <code>BLOB</code> того же самого размера
или больше никогда не делается с потерями. Преобразование с потерями
обработано, вставляя только первые <em><code>N</code></em> байт строки
на ведомом устройстве, где <em><code>N</code></em> это
ширина целевого столбца.</li>

<li>Между любыми 2 столбцами
<a href="types.htm#bit-type"><code>BIT</code></a> любых 2 размеров.</p>
<p>Вставляя значение от <code>BIT(<em><code>M</code></em>)</code> в
<code>BIT(<em><code>M'</code></em>)</code>, где
<code><em><code>M'</code></em> &gt; <em><code>M</code></em></code>,
старшие значащие биты <code>BIT(<em><code>M'</code></em>)</code>
столбцы очищены (установлены к нолю) и <em><code>M</code></em> бит из
<code>BIT(<em><code>M</code></em>)</code> установлены как младшие значащие
биты столбца <code>BIT(<em><code>M'</code></em>)</code>.</p>

<p>Вставляя значение из <code>BIT(<em><code>M</code></em>)</code> в
<code>BIT(<em><code>M'</code></em>)</code>, где
<code><em><code>M'</code></em> &lt; <em><code>M</code></em></code>,
максимальное возможное значение для
<code>BIT(<em><code>M'</code></em>)</code> назначено, другими словами,
значение <span><span>all-set</span></span> назначено на целевой столбец.
</p></li></ul>
<p>Преобразования между типами не в предыдущем списке не разрешены.</p>

<h4><a name="replication-features-directory"></a>19.4.1.11.
Репликация опций DIRECTORY</h4>
<p>Если <code>DATA DIRECTORY</code> или <code>INDEX DIRECTORY</code>
применены в <a href="sql.htm#create-table"><code>CREATE TABLE</code></a> на
главном сервере, табличная опция также используется на ведомом устройстве.
Это может вызвать проблемы, если никакой соответствующий каталог не
существует в ведомой файловой системе узла, или если он существует, но
недоступен для ведомого сервера. Это может быть переопределено при
использовании режима SQL <a href="server.htm#sqlmode_no_dir_in_create"><code>
NO_DIR_IN_CREATE</code></a> на ведомом устройстве, который заставляет ведомое
устройство игнорировать опции <code>DATA DIRECTORY</code> и <code>INDEX
DIRECTORY</code>, копируя <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a>. Результат: файлы с данными и индексные файлы <code>MyISAM</code>
создаются в каталоге базы данных таблицы.</p>
<p>См. <a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<h4><a name="replication-features-invoked"></a>19.4.1.12.
Репликация особенностей</h4>
<p>Репликация особенностей, таких как определяемые пользователем функции
(UDF) и сохраненные программы (хранимые процедуры и функции, триггеры и
события) обеспечивает следующие характеристики:</p>

<ul><li><p>Эффекты особенности всегда копируются.</li>
<li>Следующие запросы копируются, используя основанную
на запросе репликацию:</p>

<ul><li><p><a href="sql.htm#create-event"><code>CREATE EVENT</code></a></li>
<li><a href="sql.htm#alter-event"><code>ALTER EVENT</code></a></li>
<li><a href="sql.htm#drop-event"><code>DROP EVENT</code></a></li>
<li><a href="sql.htm#create-procedure"><code>CREATE PROCEDURE</code></a></li>
<li><a href="sql.htm#drop-procedure"><code>DROP PROCEDURE</code></a></li>
<li><a href="sql.htm#create-function"><code>CREATE FUNCTION</code></a></li>
<li><a href="sql.htm#drop-function"><code>DROP FUNCTION</code></a></li>
<li><a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a></li>
<li><a href="sql.htm#drop-trigger"><code>DROP TRIGGER</code></a>
</p></li></ul>

<p>Однако, <span><em>эффекты</em></span> особенностей с
использованием этих запросов копируются, используя основанную
на строке репликацию.</p>

<p>Попытка копировать особенности, используя основанную
на запросе репликацию производит предупрждение
<span>Statement is not safe to log in statement format</span>.
Например, попытка копировать UDF с основанной на запросе репликацией
производит это предупреждение, потому что в настоящее время не может
определяться сервером MySQL, детерминирован ли UDF.
Если Вы абсолютно уверены, что эффекты особенности детерминированы,
Вы можете безопасно игнорировать такие предупреждения.</p></li>

<li>В случае <a href="sql.htm#create-event"><code>CREATE EVENT</code></a> и
<a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>:</p>
<ul><li><p>Состояние события установлено в
<code>SLAVESIDE_DISABLED</code> на ведомом устройстве независимо от
определенного состояния (это не относится к
<a href="sql.htm#drop-event"><code>DROP EVENT</code></a>).</li>

<li>Ведущее устройство, на котором создавалось событие,
идентифицировано на ведомом устройстве по его ID сервера. Столбец
<code>ORIGINATOR</code> в <a href="inform.htm#events-table"><code>
INFORMATION_SCHEMA.EVENTS</code></a> и столбец <code>originator</code> в
<code>mysql.event</code> хранят эту информацию. См. разделы
<a href="inform.htm#events-table">22.7</a> и
<a href="sql.htm#show-events">14.7.5.18</a>.</p></li></ul></li>

<li>Выполнение особенности находится на ведомом устройстве в возобновимом
состоянии, чтобы, если ведущее устройство терпит неудачу, ведомое устройство
могло использоваться в качестве ведущего без потери обработки событий.
</p></li></ul>

<p>Определить, есть ли какие-либо запланированные события на сервере MySQL,
которые создавались на различном сервере (который действовал как ведущее
устройство репликации), можно запросив таблицу
<a href="inform.htm#events-table"><code>INFORMATION_SCHEMA.EVENTS</code></a>:
<pre>
SELECT EVENT_SCHEMA, EVENT_NAME
       FROM INFORMATION_SCHEMA.EVENTS
       WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre>

<p>Альтернативно, Вы можете использовать <a href="sql.htm#show-events"><code>
SHOW EVENTS</code></a> так:
<pre>
SHOW EVENTS WHERE STATUS = 'SLAVESIDE_DISABLED';
</pre>

<p>Используя ведомое устройство репликации, имеющее такие события, как
ведущее устройство репликации, Вы должны включить каждое событие через
<a href="sql.htm#alter-event"><code>ALTER EVENT
<em><code>event_name</code></em> ENABLE</code></a>, где
<em><code>event_name</code></em> название события.</p>

<p>Если больше, чем одно ведущее устройство было вовлечено в создание событий
на этом ведомом устройстве, и Вы хотите идентифицировать события, которые
создавались только на данном ведущем устройстве, имеющем ID сервера
<em><code>master_id</code></em>, измените предыдущий запрос к таблице
<a href="inform.htm#events-table"><code>EVENTS</code></a>,
чтобы включить столбец <code>ORIGINATOR</code>, как показано здесь:
<pre>
SELECT EVENT_SCHEMA, EVENT_NAME, ORIGINATOR FROM INFORMATION_SCHEMA.EVENTS
       WHERE STATUS = 'SLAVESIDE_DISABLED' AND
       ORIGINATOR = '<em><code>master_id</code></em>'
</pre>

<p>Вы можете использовать <code>ORIGINATOR</code> с
<a href="sql.htm#show-events"><code>SHOW EVENTS</code></a>:
<pre>
SHOW EVENTS WHERE STATUS = 'SLAVESIDE_DISABLED' AND
     ORIGINATOR = '<em><code>master_id</code></em>'
</pre>

<p>Прежде, чем включить события, которые копировались от ведущего устройства,
Вы должны отключить MySQL Event Scheduler на ведомом устройстве (с
использованием запроса <code>SET GLOBAL event_scheduler = OFF;</code>),
выполнить любые необходимые <a href="sql.htm#alter-event"><code>ALTER
EVENT</code></a>, перезапустить сервер, затем повторно включить
Event Scheduler на ведомом устройстве позже (используя запрос
<code>SET GLOBAL event_scheduler = ON;</code>).</p>

<p>Если Вы позже понижаете в должности новое ведущее устройство назад к тому,
чтобы быть ведомым устройством репликации, Вы должны отключить вручную все
события, включенные <a href="sql.htm#alter-event"><code>ALTER EVENT</code>
</a>. Вы можете сделать это, храня в отдельной таблице имена событий из
показанного ранее <a href="sql.htm#select"><code>SELECT</code></a> или
применяя <a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>, чтобы
переименовать события с общей приставкой, например,
<code>replicated_</code>, чтобы идентифицировать их.</p>

<p>Если Вы переименовываете события, то, понижая в должности этот сервер
назад к тому, чтобы быть ведомым устройством репликации, Вы можете
идентифицировать события, запрашивая таблицу
<a href="inform.htm#events-table"><code>EVENTS</code></a>:
<pre>
SELECT CONCAT(EVENT_SCHEMA, '.', EVENT_NAME) AS 'Db.Event'
       FROM INFORMATION_SCHEMA.EVENTS
       WHERE INSTR(EVENT_NAME, 'replicated_') = 1;
</pre>

<h4><a name="replication-features-floatvalues"></a>19.4.1.13.
Репликация и значения с плавающей запятой</h4>
<p>С основанной на запросе репликацией значения преобразованы от десятичного
числа в двоичные. Поскольку преобразования между десятичными и двоичными
представлениями могут быть приблизительными, сравнения, вовлекающие значения
с плавающей запятой, неточны. Это истина для операций, которые используют
значения с плавающей запятой явно, или значения, которые преобразованы в тип
с плавающей запятой неявно. Сравнения значений с плавающей запятой могли бы
привести к различным результатам на основных и ведомых серверах
из-за различий в архитектуре, компилятора, которым собирали MySQL и т.д., см.
разделы <a href="funct.htm#type-conversion">13.2</a> и
<a href="error.htm#problems-with-float">B.5.4.8</a>.</p>

<h4><a name="replication-features-fractional-seconds"></a>19.4.1.14.
Репликация и дробные части секунд</h4>
<p>MySQL 8.0 позволяет дробные части секунд для типов
<a href="types.htm#time"><code>TIME</code></a>,
<a href="types.htm#datetime"><code>DATETIME</code></a> и
<a href="types.htm#datetime"><code>TIMESTAMP</code></a>
с точностью до микросекунд (6 цифр). См.
<a href="types.htm#fractional-seconds">раздел 12.3.6</a>.</p>

<p>Может быть мультиплицирование задач от главного сервера, который
понимает дробные секунды, к более старому ведомому устройству (MySQL 5.6.3
и ранее), которое этого не делает:</p>

<ul><li><p>Для <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>,
содержащих столбцы, которые имеют значение
<em><code>fsp</code></em> (fractional seconds precision) больше 0,
репликация потерпит неудачу из-за ошибок анализатора.</li>

<li>Запросы, которые используют временные типы данных с
<em><code>fsp</code></em> = 0, будут работать с основанным на запросе
журналированием, но не с основанным на строке журналированием. В последнем
случае типы данных имеют двоичные форматы и их коды ведущего устройства
отличаются от кодов в ведомом устройстве.</li>

<li>Некоторые результаты выражения разойдутся в ведущем
и ведомом устройствах. Примеры: на ведущем устройстве
системная переменная <code>timestamp</code> возвращает значение, которое
включает дробную часть микросекунд, на ведомом устройстве это
возвращает целое число. На ведущем устройстве функции, которые возвращают
результат, который включает текущее время
(например, <a href="funct.htm#function_curtime"><code>CURTIME()</code></a>,
<a href="funct.htm#function_sysdate"><code>SYSDATE()</code></a> или
<a href="funct.htm#function_utc-timestamp"><code>UTC_TIMESTAMP()</code></a>)
интерпретируют параметр как <em><code>fsp</code></em>
и возвращаемое значение включают дробную часть секунд. На ведомом устройстве
эти функции разрешают параметр, но игнорируют его.</p></li></ul>

<h4><a name="replication-features-flush"></a>19.4.1.15.
Репликация и FLUSH</h4>
<p>Некоторые формы <a href="sql.htm#flush"><code>FLUSH</code></a>
не зарегистрированы, потому что они могли вызвать проблемы, если копируются
к ведомому устройству: <a href="sql.htm#flush"><code>FLUSH LOGS</code></a>,
<a href="sql.htm#flush"><code>FLUSH MASTER</code></a>,
<a href="sql.htm#flush"><code>FLUSH SLAVE</code></a> и
<a href="sql.htm#flush"><code>FLUSH TABLES WITH READ LOCK</code></a>.
Для примера синтаксиса см. <a href="sql.htm#flush">раздел 14.7.6.3</a>.
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a>,
<a href="sql.htm#analyze-table"><code>ANALYZE TABLE</code></a>,
<a href="sql.htm#optimize-table"><code>OPTIMIZE TABLE</code></a> и
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a> написаны в
двоичный журналу и таким образом копируются к ведомым устройствам. Это обычно
не проблема, потому что эти запросы не изменяют табличные данные.</p>

<p>Однако, это поведение может вызвать трудности при определенных
обстоятельствах. Если Вы копируете таблицы привилегии в базе данных
<code>mysql</code> и обновляете те таблицы непосредственно без использования
<a href="sql.htm#grant"><code>GRANT</code></a>, Вы должны
скомандовать <a href="sql.htm#flush"><code>FLUSH PRIVILEGES</code></a>
на ведомых устройствах, чтобы осуществить новые привилегии. Кроме того, если
Вы используете <a href="sql.htm#flush"><code>FLUSH TABLES</code></a>,
переименовывая таблицу <code>MyISAM</code>, которая является частью
таблицы <code>MERGE</code>, Вы должны применить
<a href="sql.htm#flush"><code>FLUSH TABLES</code></a> вручную на ведомых
устройствах. Эти запросы написаны в двоичный журнал, если Вы не определяете
<code>NO_WRITE_TO_BINLOG</code> или его псевдоним <code>LOCAL</code>.</p>

<h4><a name="replication-features-functions"></a>19.4.1.16.
Репликация и системные функции</h4>
<p>Определенные функции не копируются хорошо при некоторых условиях:</p>

<ul><li><p><a href="funct.htm#function_user"><code>USER()</code></a>,
<a href="funct.htm#function_current-user"><code>CURRENT_USER()</code></a>
(или <a href="funct.htm#function_current-user"><code>CURRENT_USER</code>
</a>), <a href="funct.htm#function_uuid"><code>UUID()</code></a>,
<a href="funct.htm#function_version"><code>VERSION()</code></a> и
<a href="funct.htm#function_load-file"><code>LOAD_FILE()</code></a>
копируются без изменения и таким образом не работают достоверно с ведомым
устройством, если основанная на строке репликация не включена. См.
<a href="#replication-formats">раздел 19.2.1</a>.</p>

<p><a href="funct.htm#function_user"><code>USER()</code></a> и
<a href="funct.htm#function_current-user"><code>CURRENT_USER()</code></a>
автоматически копируются, используя основанную на строке репликацию,
используя режим <code>MIXED</code> и производят предупреждение в
режиме <code>STATEMENT</code> (см.
<a href="#replication-features-current-user">раздел 19.4.1.8</a>).
Это также истина для <a href="funct.htm#function_version"><code>VERSION()
</code></a> и <a href="funct.htm#function_rand"><code>RAND()</code></a>.</li>

<li>Для <a href="funct.htm#function_now"><code>NOW()</code></a>
двоичный журнал включает timestamp. Это означает, что значение,
<span><em>возвращенное вызовом этой функции на ведущем устройстве</em>
</span>, копируется к ведомому устройству. Чтобы избежать неожиданных
результатов, копируя между серверами MySQL в различных часовых поясах,
установите часовой пояс на ведущем устройстве и на ведомом устройстве. См.
также <a href="#replication-features-timezone">раздел 19.4.1.32
</a>.</p>

<p>Чтобы объяснить потенциальные проблемы, копируя между серверами, которые
находятся в различных часовых поясах, предположите, что ведущее устройство
расположено в Нью-Йорке, ведомое устройство расположено в Стокгольме, и оба
сервера используют местное время. Предположите далее, что на ведущем
устройстве Вы составляете таблицу <code>mytable</code>, выполняете
<a href="sql.htm#insert"><code>INSERT</code></a> на ней, а
затем выбираете из таблицы, как показано здесь:
<pre>
mysql&gt; CREATE TABLE mytable (mycol TEXT);
Query OK, 0 rows affected (0.06 sec)

mysql&gt; INSERT INTO mytable VALUES (NOW());
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT * FROM mytable;
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre>

<p>Местное время в Стокгольме на 6 часов позже чем в Нью-Йорке, если Вы
выполните <code>SELECT NOW()</code> на ведомом устройстве в этот же самый
момент, значение будет <code>2009-09-01 18:00:00</code>.
Поэтому, если Вы выбираете из копии ведомого устройства <code>mytable</code>
после копирования <a href="sql.htm#create-table"><code>CREATE TABLE</code>
</a> и <a href="sql.htm#insert"><code>INSERT</code></a>, Вы могли бы ожидать,
что <code>mycol</code> содержит значение <code>2009-09-01 18:00:00</code>.
Однако, дело обстоит не так: когда Вы выбираете из копии ведомого устройства
<code>mytable</code>, Вы получаете точно тот же самый результат как
на ведущем устройстве:
<pre>
mysql&gt; SELECT * FROM mytable;
+---------------------+
| mycol               |
+---------------------+
| 2009-09-01 12:00:00 |
+---------------------+
1 row in set (0.00 sec)
</pre>

<p>В отличие от <a href="funct.htm#function_now"><code>NOW()</code></a>,
функция <a href="funct.htm#function_sysdate"><code>SYSDATE()</code></a>
не безопасна для репликации, потому что она не затронута <code>SET
TIMESTAMP</code> в двоичном журнале и недетерминирована, если основанное на
запросе журналирование используется. Это не проблема, если основанное на
строке журналирование используется.</p>

<p>Альтернатива должна использовать опцию
<a href="server.htm#option_mysqld_sysdate-is-now"><code>--sysdate-is-now
</code></a>, чтобы вызвать <a href="funct.htm#function_sysdate"><code>
SYSDATE()</code></a> как псевдоним для
<a href="funct.htm#function_now"><code>NOW()</code></a>.
Это должно быть сделано на ведущем и ведомом устройствах, чтобы работать
правильно. В таких случаях предупреждение все еще выпущено этой функцией, но
может быть безопасно проигнорировано, пока
<a href="server.htm#option_mysqld_sysdate-is-now"><code>--sysdate-is-now
</code></a> используется на ведущем и на ведомом устройствах.</p>

<p><a href="funct.htm#function_sysdate"><code>SYSDATE()</code></a>
автоматически копируется, используя основанную на строке репликацию,
используя режим <code>MIXED</code> и производит
предупреждение в режиме <code>STATEMENT</code>.</p>
<p>См. <a href="#replication-features-timezone">раздел 19.4.1.32
</a>.</li>

<li><span><em>Следующее ограничение относится только к основанной
на запросе репликации, но не к основанной на строке.</em></span> Функции
<a href="funct.htm#function_get-lock"><code>GET_LOCK()</code></a>,
<a href="funct.htm#function_release-lock"><code>RELEASE_LOCK()</code></a>,
<a href="funct.htm#function_is-free-lock"><code>IS_FREE_LOCK()</code></a> и
<a href="funct.htm#function_is-used-lock"><code>IS_USED_LOCK()</code></a>,
которые обрабатывают блокировки на уровне пользователя, копируются без
ведомого устройства, зная контекст параллелизма на ведущем устройстве.
Поэтому, эти функции не должны использоваться, чтобы вставить в основную
таблицу, потому что контент на ведомом устройстве будет отличаться.
Например, не делайте запрос <code>INSERT INTO mytable VALUES(GET_LOCK(...))
</code>.</p>

<p>Эти функции автоматически копируются, используя основанную
на строке репликацию, используя режим <code>MIXED</code> и
производят предупреждение в режиме <code>STATEMENT</code>.</p></li></ul>

<p>Как обходное решение для предыдущих ограничений, когда основанная на
запросе репликация работает, Вы можете использовать стратегию сохранения
проблематичного функционального результата в пользовательской переменной и
обращении к переменной в более позднем запросе. Например, следующий
<a href="sql.htm#insert"><code>INSERT</code></a> проблематичен из-за ссылки
на функцию <a href="funct.htm#function_uuid"><code>UUID()</code></a>:
<pre>
INSERT INTO t VALUES(UUID());
</pre>

<p>Чтобы работать вокруг проблемы, сделайте это:
<pre>
SET @my_uuid = UUID();
INSERT INTO t VALUES(@my_uuid);
</pre>

<p>Та последовательность запросов копируется, потому что значение
<code>@my_uuid</code> сохранено в двоичном журнале как событие вставки
переменной через <a href="sql.htm#insert"><code>INSERT</code></a>.</p>

<p>Та же самая идея относится к многострочной вставке, но более сложна.
Для вставки с двумя строками Вы можете сделать это:
<pre>
SET @my_uuid1 = UUID(); @my_uuid2 = UUID();
INSERT INTO t VALUES(@my_uuid1),(@my_uuid2);
</pre>

<p>Однако, если число строк является большим или неизвестным,
обходное решение является трудным или невыполнимым. Например, Вы не можете
преобразовать следующий запрос к тому, в котором данная отдельная
пользовательская переменная связана с каждой строкой:
<pre>
INSERT INTO t2 SELECT UUID(), * FROM t1;
</pre>

<p>В пределах сохраненной функции <a href="funct.htm#function_rand"><code>
RAND()</code></a> копируется правильно, пока это вызвано только однажды во
время выполнения функции. Вы можете рассмотреть функциональное выполнение
timestamp и получение случайного числа как неявные вводы, которые идентичны
на ведущем и ведомом устройствах.</p>

<p><a href="funct.htm#function_found-rows"><code>FOUND_ROWS()</code></a> и
<a href="funct.htm#function_row-count"><code>ROW_COUNT()</code></a>
не копируются достоверно, используя основанную на запросе репликацию.
Обходное решение должно сохранить результат вызова функции в
пользовательской переменной, а затем использовать это в
<a href="sql.htm#insert"><code>INSERT</code></a>.
Например, если Вы хотите сохранить результат в таблице <code>mytable</code>,
Вы могли бы обычно делать так:
<pre>
SELECT SQL_CALC_FOUND_ROWS FROM mytable LIMIT 1;
INSERT INTO mytable VALUES(FOUND_ROWS());
</pre>

<p>Однако, если Вы копируете <code>mytable</code>, Вы должны использовать
<a href="sql.htm#select-into"><code>SELECT ... INTO</code></a>
и затем сохраните переменную в таблице:
<pre>
SELECT SQL_CALC_FOUND_ROWS INTO @found_rows FROM mytable LIMIT 1;
INSERT INTO mytable VALUES(@found_rows);
</pre>

<p>Таким образом, пользовательская переменная копируется как часть контекста
и применена на ведомом устройстве правильно.</p>
<p>Эти функции автоматически копируются, используя основанную
на строке репликацию, используя режим <code>MIXED</code> и производят
предупреждение в режиме <code>STATEMENT</code> (Bug #12092, Bug #30244).</p>

<h4><a name="replication-features-limit"></a>19.4.1.17.
Репликация и LIMIT</h4>
<p>Основанная на запросе репликация считает <code>LIMIT</code> в
in <a href="sql.htm#delete"><code>DELETE</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#insert-select"><code>INSERT ... SELECT</code></a>
опасным, так как порядок затронутых строк не определен. Такие запросы могут
копироваться правильно с основанной на запросе репликацией, только если они
также содержат <code>ORDER BY</code>. Когда с таким запросом сталкиваются:
</p>

<ul><li><p>Используя режим <code>STATEMENT</code>, предупреждение, что запрос
не безопасен для основанной на запросе репликации, создано.</p>
<p>Используя режим <code>STATEMENT</code>, предупреждения выпущены для
запросов DML, содержащих <code>LIMIT</code> даже когда они также имеют
<code>ORDER BY</code> (и таким образом сделаны детерминированными). Это
известная проблема (Bug #42851).</li>
<li>Используя режим <code>MIXED</code>, запрос теперь автоматически
копируется, используя основанный на строке режим.</p></li></ul>

<h4><a name="replication-features-load-data"></a>19.4.1.18.
Репликация и LOAD DATA INFILE</h4>
<p>В MySQL 8.0 <a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>
считается опасным (см. <a href="#replication-rbr-safe-unsafe">
раздел 19.2.1.3</a>). Это вызывает предупреждение, используя основанный на
запросе формат журналирования, и зарегистрировано, используя основанный на
строке формат, используя журналирование смешанного формата.</p>

<h4><a name="replication-features-partitioning"></a>19.4.1.19.
Репликация и разделение</h4>
<p>Репликация поддержана между разделенными таблицами, пока они используют ту
же самую схему разделения и имеют ту же самую структуру кроме того, где
исключение определенно позволено (см.
<a href="#replication-features-differing-tables">раздел 19.4.1.10
</a>).</p>

<p>Репликация между таблицами, имеющими различное разделение, вообще не
поддержана. Это потому, что запросы вроде
<a href="sql.htm#alter-table-partition-operations"><code>ALTER
TABLE ... DROP PARTITION</code></a>)
действуют непосредственно на разделение в таких случаях, что может привести к
различным результатам на ведущем и ведомом устройствах. В случае, где таблица
разделена на ведущем устройстве, но не на ведомом, любые запросы,
воздействующие на разделение на копии на ведущем устройстве, терпят неудачу
на ведомом устройстве. Когда копия ведомого устройства таблицы разделена, но
копия ведущего устройства нет, запросы, действующие на разделение, не могут
быть выполнены на ведущем устройстве, не вызывая ошибки.</p>

<p>Из-за этих опасностей заставить репликацию терпеть неудачу полностью
(из-за неудавшихся запросов) и несогласованностей (когда результат запросов
SQL на уровне разделения приводит к различным результатам на ведущем и
ведомом устройствах), мы рекомендуем, чтобы Вы обеспечили, чтобы разделение
любых таблиц, которые будут копироваться от ведущего устройства, было
соответствующим версиям ведомого устройства этих таблиц.</p>

<h4><a name="replication-features-repair-table"></a>19.4.1.20.
Репликацуя и REPAIR TABLE</h4>
<p>Когда используется на поврежденной таблице, возможно для
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>
удалить строки, которые не могут быть восстановлены. Однако, любые такие
модификации табличных данных, выполненные этим запросом, не копируются,
что может заставить ведущее и ведомое устройства потерять синхронизацию.
Поэтому, когда таблица на ведущем устройстве становится поврежденной, и Вы
используете <a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>,
чтобы восстановить это, Вы должны сначала остановить репликацию (если это все
еще работает) перед использованием <a href="sql.htm#repair-table"><code>
REPAIR TABLE</code></a>, позже сравнить копии таблицы ведущего и ведомого
устройств и быть подготовленными исправить любые несоответствия вручную
прежде, чем перезапустить репликацию.</p>

<h4><a name="replication-features-shutdowns"></a>19.4.1.21.
Репликация и завершение работы</h4>
<p>Безопасно закрыть главный сервер и перезапустить его позже.
Когда ведомое устройство теряет свое соединение с ведущим устройством,
ведомое устройство пытается повторно соединиться немедленно и повторяет
попытки периодически, если это терпит неудачу. По умолчанию надо повторять
каждые 60 секунд. Это может быть изменено с
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>.
Ведомое устройство также в состоянии иметь дело с сетевыми отключениями.
Однако, ведомое устройство замечает сетевое отключение
только после прекращения получения данных от ведущего устройства в течение
<a href="#sysvar_slave_net_timeout"><code>slave_net_timeout
</code></a> секунд. Если Ваши отключения коротки, Вы можете хотеть уменьшить
<a href="#sysvar_slave_net_timeout"><code>slave_net_timeout</code>
</a>. См. <a href="server.htm#server-system-variables">раздел 6.1.5</a>.</p>

<p>Грязное завершение работы (например, катастрофический отказ) на основной
стороне может привести к основному двоичному журналу, имеющему заключительную
позицию меньше, чем новая позиция, считанная ведомым устройством, из-за
не сброшенного файла основного двоичного системного журнала. Это может
заставить ведомое устройство быть не в состоянии копировать, когда ведущее
устройство возвращается. Установка <a href="#sysvar_sync_binlog">
<code>sync_binlog=1</code></a> в файле <code>my.cnf</code> на ведущем
устройстве помогает минимизировать эту проблему, потому что это заставляет
ведущее устройство сбрасывать двоичный журнал более часто.</p>

<p>Закрытие ведомого устройства чисто безопасно, потому что оно отслеживает
то, где оно закончило. Однако, проследите чтобы у ведомого устройства не было
открытых временных таблиц, см.
<a href="#replication-features-temptables">раздел 19.4.1.24</a>.
Грязные завершения работы могли бы произвести проблемы, особенно если
дисковый кэш не сброшен к диску прежде, чем проблема произошла:</p>

<ul><li><p>Для транзакций, которые ведомое устройство передает и затем
обновляет <code>relay-log.info</code>. Если катастрофический отказ происходит
между этими двумя операциями, обработка журнала реле продолжится далее, чем
информационный файл указывает, и ведомое устройство повторно запустит события
от последней транзакции в журнале реле после того, как это было перезапущено.
</li>

<li>Подобная проблема может произойти, если ведомое устройство обновляет
<code>relay-log.info</code>, но катастрофический отказ узла сервера был перед
сбросом записи на диск. Чтобы минимизировать шанс этого, надо установить
<a href="#sysvar_sync_relay_log_info"><code>sync_relay_log_info=1
</code></a> в файле <code>my.cnf</code> ведомого. Значение по умолчанию
<a href="#sysvar_sync_relay_log_info"><code>sync_relay_log_info
</code></a> = 0 не сбрасывает записи на диск строго, сервер полагается на
операционную систему, чтобы время от времени сбрасывать файл.</p></li></ul>
<p>Отказоустойчивость Вашей системы для этих типов проблем очень увеличена,
если у Вас есть хорошее непрерывное электропитание.</p>

<h4><a name="replication-features-max-allowed-packet"></a>19.4.1.22.
Репликация и max_allowed_packet</h4>
<p><a href="server.htm#sysvar_max_allowed_packet"><code>max_allowed_packet
</code></a> задает верхний предел для размера любого единственного сообщения
между сервером MySQL и клиентами, включая ведомые устройства репликации. Если
Вы копируете большие значения столбцов (те, которые могли бы быть найдены в
столбцах <a href="types.htm#blob"><code>TEXT</code></a> или
<a href="types.htm#blob"><code>BLOB</code></a>) и
<a href="server.htm#sysvar_max_allowed_packet"><code>max_allowed_packet
</code></a> слишком маленькое на ведущем устройстве, ведущее устройство
терпит неудачу с ошибкой, и ведомое устройство закрывает поток ввода/вывода.
Если <a href="server.htm#sysvar_max_allowed_packet"><code>max_allowed_packet
</code></a> является слишком маленьким на ведомом устройстве, это также
заставляет ведомое устройство останавливать поток ввода/вывода.</p>

<p>Основанная на строке репликация в настоящее время посылает все столбцы и
значения столбцов для обновленных строк от ведущего устройства к ведомому,
включая значения столбцов, которые не были фактически изменены обновлением.
Это означает, что, когда Вы копируете большие значения столбцов, используя
основанную на строке репликацию, Вы должны озаботиться достаточно большим
значением <a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a>, чтобы обработать самую большую строку в любой
таблице, которая будет копироваться, даже если Вы копируете только обновления
или вставляете только относительно маленькие значения.</p>

<h4><a name="replication-features-memory"></a>19.4.1.23.
Репликация и таблицы MEMORY</h4>
<p>Когда главный сервер закрывается и перезапускается, таблицы
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
становятся пустыми. Чтобы скопировать этот эффект к ведомым устройствам в
первый раз, когда ведущее устройство использует таблицу
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
после запуска, это регистрирует событие, которое извещает ведомые
устройства, что таблица должна быть освобождена записью
<a href="sql.htm#delete"><code>DELETE</code></a>
для той таблицы в двоичный журнал.</p>

<p>Когда ведомый сервер закрывается и перезапускается, таблицы
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
становятся пустыми. Это заставляет ведомое устройство быть вне синхронизации
с ведущим устройством и может привести к другим отказам или заставить
ведомое устройство останавливаться:</p>

<ul><li><p>Формат строки, полученный от ведущего устройства, может потерпеть
неудачу с ошибкой <code>Can't find record in '<em><code>memory_table</code>
</em>'</code>.</li>

<li>Запросы <a href="sql.htm#insert-select"><code>INSERT INTO
... SELECT FROM <em><code>memory_table</code></em></code></a> могут
вставить различный набор строк на ведущем и ведомом устройствах.
</p></li></ul>

<p>Безопасный способ перезапустить ведомое устройство, которое копирует
таблицы <a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
сначала удалить все строки из <a href="storage.htm#memory-storage-engine">
<code>MEMORY</code></a> на ведущем устройстве и подождать,
пока те изменения не скопируются к ведомому устройству. Тогда безопасно
перезапустить ведомое устройство.</p>

<p>Альтернативный метод перезапуска может примениться в некоторых случаях.
Когда <a href="#sysvar_binlog_format"><code>binlog_format=ROW
</code></a>, Вы можете препятствовать тому, чтобы ведомое устройство
остановилось, если Вы устанавливаете
<a href="#sysvar_slave_exec_mode"><code>slave_exec_mode=IDEMPOTENT
</code></a> прежде, чем Вы запустите ведомое устройство снова. Это позволяет
ведомому устройству продолжать копировать, но таблицы
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
будут все еще отличаться от тех, которые есть на ведущем устройстве. Это
может быть хорошо, если логика приложения такова что содержание
таблиц <a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
может быть безопасно потеряно (например, если
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
используются для того, чтобы кэшироваться).
<a href="#sysvar_slave_exec_mode"><code>slave_exec_mode=IDEMPOTENT
</code></a>применяется глобально ко всем таблицам, таким образом, это может
скрыть другие ошибки репликации в таблицах
не-<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>.</p>

<p>Размер <a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
ограничен значением <a href="server.htm#sysvar_max_heap_table_size"><code>
max_heap_table_size</code></a>, которая не копируется (см.
<a href="#replication-features-variables">раздел 19.4.1.38</a>).
Изменение в <code>max_heap_table_size</code> вступает в силу для
<code>MEMORY</code>, которые составлены или обновлены с использованием
<a href="sql.htm#alter-table"><code>ALTER TABLE ... ENGINE = MEMORY</code>
</a> или <a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
после изменения или для всех <a href="storage.htm#memory-storage-engine">
<code>MEMORY</code></a> после перезапуска сервера. Если Вы увеличиваете
значение этой переменной на ведущем устройстве, не делая так на ведомом
устройстве, для таблицы на ведущем устройстве становится возможно вырасти
больше, чем ее коллега на ведомом устройстве, что может привести к ошибке
<span>Table is full</span>. Это известная проблема (Bug #48666).
В таких случаях Вы должны установить глобальное значение
<a href="server.htm#sysvar_max_heap_table_size"><code>max_heap_table_size
</code></a> на ведомом устройстве так же, как на ведущем устройстве, затем
перезапустите репликацию. Также рекомендуется, чтобы Вы перезапустили
основные и ведомые серверы MySQL, чтобы обеспечить, чтобы новое значение
имело эффект на каждом из них.</p>
<p>См. <a href="storage.htm#memory-storage-engine">раздел 17.3</a>.</p>

<h4><a name="replication-features-temptables"></a>19.4.1.24.
Репликация и временные таблицы</h4>
<p>Обсуждение в следующих параграфах не применяется, когда
<a href="#sysvar_binlog_format"><code>binlog_format=ROW</code></a>
потому что, в этом случае временные таблицы не копируются, это означает, что
никогда нет никаких временных таблиц на ведомом устройстве, которые будут
потеряны в случае незапланированного завершения работы ведомым устройством.
Остаток от этого раздела применяется только, используя основанную на запросе
или репликацию смешанного формата. Потеря копируемых временных таблиц на
ведомом устройстве может быть проблемой, всякий раз, когда
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>
<code>STATEMENT</code> или <code>MIXED</code> для запросов, вовлекающих
временные таблицы, которые могут быть зарегистрированы безопасно, используя
основанный на запросе формат.</p>

<p><b>Безопасное ведомое завершение работы, используя временные таблицы. </b>
Временные таблицы копируются кроме случая, когда Вы останавливаете ведомый
сервер (не только ведомые потоки), и Вы копировали временные таблицы, которые
открыты для использования в обновлениях, которые еще не были выполнены на
ведомом устройстве. Если Вы останавливаете ведомый сервер, временные таблицы,
необходимые тем обновлениям, больше недоступны, когда ведомое устройство
перезапущено. Чтобы избежать этой проблемы, не закрывайте ведомое устройство,
в то время как у этого есть временные открытые таблицы. Вместо этого
используйте следующую процедуру:</p>

<ol type="1"><li><p>Выполните <code>STOP SLAVE SQL_THREAD</code>.</li>
<li>Используйте <a href="sql.htm#show-status"><code>SHOW STATUS</code></a>,
чтобы проверять значение переменной
<a href="server.htm#statvar_Slave_open_temp_tables">
<code>Slave_open_temp_tables</code></a>.</li>

<li>Если значение не 0, перезапустите ведомый поток SQL с помощью
<code>START SLAVE SQL_THREAD</code> и повторите процедуру позже.</li>
<li>Когда значение 0, выполните <a href="programs.htm#mysqladmin"><span>
<strong>mysqladmin shutdown</strong></span></a>, чтобы
остановить ведомое устройство.</p></li></ol>

<p><b>Временные таблицы и опции репликации. </b>
По умолчанию, все временные таблицы копируются, это происходит
безотносительно того, есть ли какое-либо соответствие
<a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a>,
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table</code></a> или
<a href="#option_mysqld_replicate-wild-do-table"><code>
--replicate-wild-do-table</code></a>. Однако, опции
<a href="#option_mysqld_replicate-ignore-table"><code>
--replicate-ignore-table</code></a> и
<a href="#option_mysqld_replicate-wild-ignore-table"><code>
--replicate-wild-ignore-table</code></a> соблюдают для временных таблиц.</p>

<p>Рекомендуемая практика, используя основанную на запросе или смешанную
репликацию должна определять приставку для исключительного использования в
обозначении временных таблиц, которые Вы не хотите копировать, затем
использовать <a href="#option_mysqld_replicate-wild-ignore-table">
<code>--replicate-wild-ignore-table</code></a>, чтобы соответствовать.
Например, Вы могли бы дать все такие табличные имена с <code>norep</code>,
затем применить <a href="#option_mysqld_replicate-wild-ignore-table">
<code>--replicate-wild-ignore-table=norep%</code></a>, чтобы
препятствовать тому, чтобы они копировались.</p>

<h4><a name="replication-features-mysqldb"></a>19.4.1.25.
Репликация системной базы данных mysql</h4>
<p>Запросы модификации данных, сделанные к таблицам в базе данных
<code>mysql</code>, копируются согласно значению
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>,
если это значение <code>MIXED</code>, эти запросы копируются, используя
основанный на строке формат. Однако, запросы, которые обычно обновляли бы эту
информацию косвенно, например, <a href="sql.htm#grant"><code>GRANT</code>
</a>, <a href="sql.htm#revoke"><code>REVOKE</code></a> и запросы, управляющие
сохраненными подпрограммами, триггерами и представлениями, копируются к
ведомым устройствам, используя основанную на запросе репликацию.</p>

<h4><a name="replication-features-optimizer"></a>19.4.1.26.
Репликация и оптимизатор запросов</h4>
<p>Для данных по ведущему и ведомому устройствам возможно стать отличающимся,
если запрос написано таким способом, которым модификация данных
недетерминирована благодаря оптимизации запроса. Вообще это не хорошая
практика, даже за пределами репликации. Примеры недетерминированных запросов
включают <a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>, которые применяют
<code>LIMIT</code> без <code>ORDER BY</code>, см.
<a href="#replication-features-limit">раздел 19.4.1.17</a>.</p>

<h4><a name="replication-features-reserved-words"></a>19.4.1.27.
Репликация и зарезервированные слова</h4>
<p>Вы можете столкнуться с проблемами, когда Вы пытаетесь копировать от
ведущего устройства старшего возраста к более новому ведомому устройству, и
Вы используете идентификаторы на ведущем устройстве, которые являются
зарезервированными словами в более новой версии MySQL, работающей на ведомом
устройстве. Пример этого использует столбец таблицы названный
<code>virtual</code> на 5.6 ведущих устройствах, которые копируются к 5.7 или
более новому ведомому устройству, потому что <code>VIRTUAL</code>
зарезервированное слово, начиная с MySQL 5.7. Репликация может потерпеть
неудачу в таких случаях с Error 1064
<span>You have an error in your SQL syntax...</span>,
<span><em>даже если база данных или таблица, названная с использованием
зарезервированного слова, исключена из репликации</em></span>.
Это следствие того, что каждое событие SQL должно быть разобрано ведомым
устройством до выполнения, чтобы ведомое устройство знало, какой объект базы
данных или объекты были бы затронуты, только после того, как событие
разобрано, ведомое устройство может применять любые правила фильтрации,
определенные <a href="#option_mysqld_replicate-do-db"><code>
--replicate-do-db</code></a>,
<a href="#option_mysqld_replicate-do-table"><code>
--replicate-do-table</code></a>,
<a href="#option_mysqld_replicate-ignore-db"><code>
--replicate-ignore-db</code></a> и
<a href="#option_mysqld_replicate-ignore-table"><code>
--replicate-ignore-table</code></a>.</p>

<p>Чтобы работать вокруг проблемы базы данных, таблицы или имен столбцов на
ведущем устройстве, которые были бы расценены как зарезервированные слова
ведомым устройством, делается одно из следующего:</p>

<ul><li><p>Используйте один или больше <a href="sql.htm#alter-table"><code>
ALTER TABLE</code></a> на ведущем устройстве, чтобы изменить названия любой
базы данных, где эти имена считались бы зарезервированными словами на ведомом
устройстве, и измените любые запросы SQL, которые используют старые названия,
чтобы использовать новые имена вместо этого.</li>

<li>В любых запросах SQL, используя эти названия объекта базы данных,
напишите имена как заключенные в кавычки идентификаторы, используя
символы обратной кавычки (<code>`</code>).</p></li></ul>

<p>Для списков зарезервированных слов в версии MySQL см.
<a href="../../../dev.mysql.com/doc/mysqld-version-reference/en/mysqld-version-reference-optvar.html"
target="_top">Reserved Words</a>, в <em>MySQL Server Version Reference</em>.
Для правил заключения в кавычки идентификатора см.
<a href="lang.htm#identifiers">раздел 10.2</a>.</p>

<h4><a name="replication-features-slaveerrors"></a>19.4.1.28.
Ведомые ошибки во время репликации</h4>
<p>Если запрос производит ту же самую ошибку (идентичный код ошибки)
на ведущем устройстве и на ведомом устройстве, ошибка зарегистрирована,
но репликация продолжается.</p>

<p>Если запрос производит различные ошибки на ведущем и ведомом устройствах,
ведомый поток SQL заканчивается, ведомое устройство пишет сообщение своему
журналу ошибок и ждет администратора базы данных, чтобы решить, что сделать.
Это включает случай, что запрос производит ошибку на ведущем или ведомом
устройстве, но не на обоих. Чтобы обратиться к проблеме, соединитесь с
ведомым устройством вручную и определите причину проблемы.
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
полезно для этого. После ремонта выполните <a href="sql.htm#start-slave">
<code>START SLAVE</code></a>. Например, Вы, возможно, должны были бы
составить несуществующую таблицу прежде, чем Вы сможете запустить
ведомое устройство снова.</p>

<p>Если это поведение проверки допустимости кода ошибки нежелательно,
некоторые или все ошибки могут быть проигнорированы с помощью опции
<a href="#option_mysqld_slave-skip-errors"><code>
--slave-skip-errors</code></a>.</p>

<p>Для нетранзакционных механизмов хранения, например, <code>MyISAM</code>,
возможно иметь запрос, который только частично обновляет таблицу и возвращает
код ошибки. Это может произойти, например, на многострочной вставке,
у которой есть одна строка, нарушающая ключевое ограничение, или если длинный
запрос обновления уничтожен после обновления некоторых из строк.
Если это произойдет на ведущем устройстве, то ведомое устройство ожидает, что
выполнение запроса приведет к тому же самому коду ошибки.
Если это не так, ведомые потоки SQL остановятся как описано ранее.</p>

<p>Если Вы копируете между таблицами, которые используют различные механизмы
хранения на ведущем и ведомом устройствах, имейте в виду, что тот же самый
запрос мог бы произвести различную ошибку, когда выполнен против одной версии
таблицы, но не другой, или мог бы вызвать ошибку для одной версии таблицы, но
не другой. Например, с тех пор как <code>MyISAM</code>
игнорирует ограничения внешнего ключа,
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>, получающие доступ к
<code>InnoDB</code> на ведущем устройстве могли бы вызвать нарушение внешнего
ключа, но тот же самый запрос, выполненный на версии <code>MyISAM</code>
той же самой таблицы на ведомом устройстве не произвел бы такой ошибки,
заставляя репликацию остановиться.</p>

<h4><a name="replication-features-server-side-help"></a>19.4.1.29.
Репликация серверных таблиц справки</h4>
<p>Сервер поддерживает таблицы в базе данных <code>mysql</code>, которые
хранят информацию для <a href="sql.htm#help"><code>HELP</code></a> (см.
<a href="sql.htm#help">раздел 14.8.3</a>.
Эти таблицы могут быть загружены вручную как описано в
<a href="server.htm#server-side-help-support">разделе 6.1.10</a>.</p>

<p>Табличный контент справки получен из MySQL Reference Manual.
Есть версии руководства, определенные для каждого ряда выпуска MySQL, таким
образом, контент справки является определенным для каждого ряда также.
Обычно Вы загружаете версию контента справки, которая соответствует
версии сервера. У этого есть значения для репликации.
Например, Вы загрузили бы контент справки MySQL 5.6 в главный сервер
MySQL 5.6, но не обязательно копировали бы тот контент к ведомому серверу
MySQL 5.7, для которого контент справки 5.7 является более подходящим.</p>

<p>Этот раздел описывает, как управлять табличными обновлениями контента
справки, когда Ваши серверы участвуют в репликации. Версии сервера это один
фактор в этой задаче. Другой то, что структура таблицы справки может
отличаться между ведущим и ведомым устройствами.</p>

<p>Предположите, что контент справки сохранен в файле названном
<code>fill_help_tables.sql</code>. В MySQL этот файл расположен в каталоге
<code>share</code> или <code>share/mysql</code>, новая версия всегда доступна
для скачивания с <a href="../../../dev.mysql.com/doc/index-other.html"
target="_top">http://dev.mysql.com/doc/index-other.html</a>.</p>

<p>Обновить таблицы справки можно, используя следующую процедуру.
Параметры соединения не показываются для
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>,
во всех случаях, соединитесь с сервером, используя учетную запись
<code>root</code> с привилегиями для того, чтобы изменить таблицы в
базе данных <code>mysql</code>.</p>

<ol type="1"><li><p>Обновите свои серверы через
<a href="programs.htm#mysql-upgrade"><span><strong>mysql_upgrade</strong>
</span></a>, сначала на ведомых устройствах и затем на ведущем устройстве.
Это обычный принцип обновления ведомых устройств сначала.</li>

<li>Решите, хотите ли Вы копировать табличный контент справки от
ведущего устройства к его ведомым устройствам. В противном случае загрузите
контент на ведущем устройстве и на каждом ведомом устройстве индивидуально.
Иначе, проверьте и решите любые несовместимости между структурой таблицы
справки на ведущем устройстве и ведомых, затем загрузите контент в ведущее
устройство и позвольте этому копировать к ведомым устройствам.</p></li></ol>

<h5><a name="idm139965299788864"></a>Загрузка табличного контента справки без
репликации к ведомым устройствам</h5>
<p>Чтобы загрузить табличный контент справки без репликации,
выполните эту команду на ведущем устройстве и на каждом ведомом устройстве
индивидуально, используя файл <code>fill_help_tables.sql</code>, содержащий
контент для нужной версии:
<pre>
mysql mysql &lt; fill_help_tables.sql
</pre>

<h5><a name="idm139965299785984"></a>Загрузка табличного контента справки с
репликацией к ведомым устройствам</h5>
<p>Если Вы действительно хотите копировать табличный контент справки,
проверьте на табличные несовместимости справки между Вашим ведущим
устройством и ведомыми устройствами. Столбец <code>url</code> в
таблицах <code>help_category</code> и <code>help_topic</code>
изначально <code>CHAR(128)</code>, но <code>TEXT</code> в
более новых версиях MySQL, чтобы приспособить более длинные URL. Чтобы
проверить структуру таблицы справки, используйте этот запрос:
<pre>
SELECT TABLE_NAME, COLUMN_NAME, COLUMN_TYPE
       FROM INFORMATION_SCHEMA.COLUMNS
       WHERE TABLE_SCHEMA = 'mysql' AND COLUMN_NAME = 'url';
</pre>

<p>Для таблиц со старой структурой запрос приводит к этому результату:
<pre>
+---------------+-------------+-------------+
| TABLE_NAME    | COLUMN_NAME | COLUMN_TYPE |
+---------------+-------------+-------------+
| help_category | url         | char(128)   |
| help_topic| url             | char(128)   |
+---------------+-------------+-------------+
</pre>

<p>Для таблиц с новой структурой запрос приводит к этому результату:
<pre>
+---------------+-------------+-------------+
| TABLE_NAME    | COLUMN_NAME | COLUMN_TYPE |
+---------------+-------------+-------------+
| help_category | url         | text        |
| help_topic    | url         | text        |
+---------------+-------------+-------------+
</pre>

<p>Если у ведущего и ведомого устройств есть старая структура или у обоих
есть новая структура, они совместимы, и Вы можете копировать табличный
контент справки, выполняя эту команду на ведущем устройстве:
<pre>
mysql mysql &lt; fill_help_tables.sql
</pre>

<p>Табличный контент будет загружаться в ведущее устройство, затем
копироваться к ведомым устройствам.</p>
<p>Если у ведущего и ведомого устройств есть несовместимые таблицы справки (у
одного сервера есть старая структура, другой имеет новую), у Вас есть выбор
между не мультиплицированием табличного контента справки или созданием
совместимых структур таблиц, чтобы Вы могли копировать контент.</p>

<ul><li><p>Если Вы решаете не копировать контент,
обновите ведущее устройство и ведомые устройства, индивидуально, используя
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a> с опцией
<a href="programs.htm#option_mysql_init-command"><code>--init-command</code>
</a>.</li>

<li>Если вместо этого Вы решаете сделать структуры таблиц совместимыми,
обновите таблицы на сервере, у которого есть старая структура. Предположите,
что у Вашего главного сервера есть старая структура таблицы. Обновите его
таблицы до новой структуры вручную, выполняя эти запросы (двоичное
журналирование отключено здесь, чтобы предотвратить репликацию изменений
ведомых устройств, у которых уже есть новая структура):
<pre>
SET sql_log_bin=0;
ALTER TABLE mysql.help_category ALTER COLUMN url TEXT;
ALTER TABLE mysql.help_topic ALTER COLUMN url TEXT;
</pre>

<p>Выполните эту команду на ведущем устройстве:
<pre>
mysql mysql &lt; fill_help_tables.sql
</pre>
<p>Табличный контент будет загружаться в ведущее устройство, затем
копироваться к ведомым устройствам.</p></li></ul>

<h4><a name="replication-features-sql-mode"></a>19.4.1.30.
Репликация и режим SQL сервера</h4>
<p>Используя различные настройки режима SQL на ведущем и
ведомом устройстве можно обработать тот же самый
<a href="sql.htm#insert"><code>INSERT</code></a> по-другому.
Для лучших результатов Вы должны всегда использовать тот же самый режим SQL
на ведущем и ведомом устройствах. Этот совет применяется, используете ли Вы
основанную на запросе или строке репликацию.</p>

<p>Если Вы копируете разделенные таблицы, используя различные режимы SQL на
ведущем и ведомое устройствах, это, вероятно, вызовет проблемы. Как минимум,
это, вероятно, заставит распределение данных среди разделения отличаться в
копиях ведущего и ведомого устройств данной таблицы. Это может также вызвать
вставки в разделенные таблицы, которые преуспевают на ведущем устройстве,
чтобы потерпеть неудачу на ведомом устройстве.</p>

<h4><a name="replication-features-timeout"></a>19.4.1.31.
Повторения репликации и тайм-ауты</h4>
<p>Глобальная системная переменная
<a href="#sysvar_slave_transaction_retries"><code>
slave_transaction_retries</code></a> влияет на репликацию так:
если ведомый поток SQL не в состоянии выполнить транзакцию из-за тупика
<code>InnoDB</code> или потому что это превысило значение <code>InnoDB</code>
<a href="innodb.htm#sysvar_innodb_lock_wait_timeout"><code>
innodb_lock_wait_timeout</code></a> (или значения
or the <a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a>
<code>TransactionDeadlockDetectionTimeout</code> или
<code>TransactionInactiveTimeout</code>), то ведомое устройство автоматически
повторяет транзакцию <a href="#sysvar_slave_transaction_retries">
<code>slave_transaction_retries</code></a> раз прежде, чем остановиться с
ошибкой. Значение по умолчанию 10. Полное количество повторных попыток может
быть найдено в выводе <a href="sql.htm#show-status"><code>SHOW STATUS</code>
</a>, см. <a href="server.htm#server-status-variables">раздел 6.1.7</a>.</p>

<h4><a name="replication-features-timezone"></a>19.4.1.32.
Репликация и часовые пояса</h4>
<p>По умолчанию основные и ведомые серверы предполагают, что находятся в
том же самом часовом поясе. Если Вы копируете между серверами в
различных часовых поясах, часовой пояс должен быть установлен на
ведущем и на ведомом устройствах. Иначе запросы в зависимости от местного
времени на ведущем устройстве не копируются должным образом, такие как
запросы, которые используют <a href="funct.htm#function_now"><code>NOW()
</code></a> или <a href="funct.htm#function_from-unixtime"><code>
FROM_UNIXTIME()</code></a>. Установите часовой пояс, в котором сервер MySQL
работает, при использовании опции
<a href="programs.htm#option_mysqld_safe_timezone"><code>--timezone=<em>
<code>timezone_name</code></em></code></a> скрипта
<code>mysqld_safe</code> или через переменную окружения <code>TZ</code>. См.
также <a href="#replication-features-functions">раздел 19.4.1.16
</a>.</p>

<h4><a name="replication-features-transactions"></a>19.4.1.33.
Репликация и транзакции</h4>
<p><b>Смешивание транзакционных и нетранзакционных запросов в пределах той же
самой транзакции. </b>Вообще Вы должны избежать транзакций, которые обновляют
транзакционные и нетранзакционные таблицы в окружающей среде репликации.
Вы должны также избегать использования любого запроса, который обращается к
транзакционным (или временным) и нетранзакционным таблицам и пишет
любую из них.</p>

<p>Сервер использует эти правила для двоичного журналирования:</p>
<ul><li><p>Если начальные запросы в транзакции являются нетранзакционными,
они немедленно написаны в двоичный журнал. Остающиеся запросы в транзакции
кэшируются и не написаны в двоичный журнал, пока транзакция не передана.
Если транзакция отменена, кэшируемые запросы написаны двоичному журналу,
только если они производят нетранзакционные изменения, которые не могут быть
отменены. Иначе от них отказываются.</li>

<li>Для основанного на запросе журналирования журналирование нетранзакционных
запросов затронуто <a href="#sysvar_binlog_direct_non_transactional_updates">
<code>binlog_direct_non_transactional_updates</code></a>. Когда эта
переменная <code>OFF</code> (по умолчанию), журналирование работает, как
только что описано. Когда эта переменная <code>ON</code>, журналирование
немедленно происходит для нетранзакционных запросов, происходящих где угодно
в транзакции (не только начальных нетранзакционных запросов). Другие запросы
сохранены в операционном кэше и зарегистрированы, когда транзакция
передается. <a href="#sysvar_binlog_direct_non_transactional_updates">
<code>binlog_direct_non_transactional_updates</code></a>
не имеет никакого эффекта для журналирования формата строки или смешанного.
</p></li></ul>

<p><a name="replication-features-transactions-trx-nontrx-mixed"></a><b>
Транзакционные, нетранзакционные и смешанные запросы. </b>
Чтобы применить эти правила, сервер считает запрос нетранзакционным, если он
изменяет только нетранзакционные таблицы, и транзакционным, если он изменяет
только транзакционные таблицы. В MySQL 8.0 запрос, который использует
нетранзакционные и транзакционные таблицы и обновляет <span><em>любые</em>
</span> из вовлеченных таблиц, считается
<span><span>смешанным</span></span>. В предыдущем ряду выпуска MySQL запрос,
который менял нетранзакционные и транзакционные таблицы, считали смешанным.
Смешанные запросы, как транзакционные запросы, кэшируются и зарегистрированы,
когда транзакция передается.</p>

<p>Смешанный запрос, который обновляет транзакционную таблицу, считают
опасным, если запрос также выполняет любое из следующих действий:</p>
<ul><li><p>Обновления или чтения транзакционной таблицы.</li>
<li>Читает нетранзакционную таблицу, и операционный уровень изоляции
меньше REPEATABLE_READ.</p></li></ul>

<p>Смешанный запрос после обновления транзакционной таблицы в пределах
транзакции считают опасным, если это выполняет любое из следующих действий:
</p>
<ul><li><p>Обновления любой таблицы и чтения от любой временной таблицы.
</li>
<li>Обновляет нетранзакционную таблицу, и
binlog_direct_non_trans_update = OFF.</p></li></ul>
<p>См. <a href="#replication-rbr-safe-unsafe">раздел 19.2.1.3</a>.
</p>

<p>Смешанный запрос не связан со смешанным двоичным форматом журналирования.
</p>
<p>В ситуациях, где операционные обновления соединяют транзакционные
и нетранзакционные таблицы, порядок запросов в двоичном журнале правилен, и
все необходимые запросы, написаны двоичному журналу даже в случае
<a href="sql.htm#commit"><code>ROLLBACK</code></a>.
Однако, когда второе соединение обновляет нетранзакционную таблицу прежде,
чем первая транзакция соединения будет полна, запросы могут быть
зарегистрированы не в том порядке, потому что второе обновление соединения
немедленно написано после того, как это выполнено, независимо от
статуса транзакции, выполняемой первым соединением.</p>

<p><b>Используя различные механизмы хранения на
ведущем и ведомом устройствах. </b>Возможно копировать транзакционные таблицы
на ведущем устройстве, используя нетранзакционные таблицы на ведомом
устройстве. Например, Вы можете копировать <code>InnoDB</code> в
<code>MyISAM</code>. Однако, если Вы делаете это, есть проблемы, если ведомое
устройство остановлено в середине блока <a href="sql.htm#commit"><code>BEGIN
</code></a> ... <a href="sql.htm#commit"><code>COMMIT</code></a>,
потому что ведомое устройство перезапускается в начале блока
<a href="sql.htm#commit"><code>BEGIN</code></a>.</p>

<p>В MySQL 8.0 также безопасно копировать транзакции от
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>
на ведущем устройстве к транзакционной таблицк, например,
<a href="innodb.htm"><code>InnoDB</code></a> на ведомом. В таких случаях
<a href="server.htm#sysvar_autocommit"><code>AUTOCOMMIT=1</code></a>
на ведущем устройстве, копируется, таким образом проводя в жизнь
<code>AUTOCOMMIT</code> на ведомом устройстве.</p>

<p>Когда тип механизма хранения ведомого устройства является
нетранзакционным, транзакций на ведущем устройстве, которые смешивают
обновления транзакционных и нетранзакционных таблиц, нужно избежать, потому
что они могут вызвать несогласованность данных между основной транзакционной
таблицей и ведомой нетранзакционной таблицей. Таким образом, такие транзакции
могут привести к нарушению синхронизации. MySQL не выпускает предупреждение
об этом в настоящее время, таким образом, дополнительная забота должна быть
проявлена, копируя транзакционные таблицы от ведущего устройства к
нетранзакционным таблицам на ведомых устройствах.</p>

<p><b>Изменение формата двоичного журналирования в пределах транзакций. </b>
<a href="#sysvar_binlog_format"><code>binlog_format</code></a>
только для чтения, пока транзакция происходит.</p>

<p>Каждая транзакция (включая <a href="server.htm#sysvar_autocommit"><code>
autocommit</code></a>) зарегистрирована в двоичном журнале, как если она
запускается с <a href="sql.htm#commit"><code>BEGIN</code></a> и заканчивается
<a href="sql.htm#commit"><code>COMMIT</code></a> или
<a href="sql.htm#commit"><code>ROLLBACK</code></a>. В MySQL 8.0 это истина
даже для запросов, затрагивающих таблицы, которые используют нетранзакционный
механизм хранения (такой как <a href="storage.htm#myisam-storage-engine">
<code>MyISAM</code></a>).</p>

<h4><a name="replication-features-transaction-inconsistencies"></a>19.4.1.34.
Репликация и операционные несогласованности</h4>
<p>Несогласованности в последовательности транзакций, которые были выполнены
из журнала реле, могут произойти в зависимости от Вашей конфигурации
репликации. Этот раздел объясняет, как избежать несогласованностей и решить
любые проблемы, которые они вызывают.</p>

<p>Следующие типы несогласованностей могут существовать:</p>
<ul><li><p><span><em>Полуприкладные транзакции</em></span>.
Транзакция, которая обновляет нетранзакционные таблицы, применила некоторые,
но не все ее изменения.</li>

<li><span><em>Промежутки</em></span>. Промежуток это транзакция, которая не
была (полностью) применена, даже при том, что некоторая более поздняя
транзакция была применена. Промежутки могут появиться, только используя
мультипоточное ведомое устройство. Чтобы избежать появления промежутков, надо
установить <a href="#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order=1</code></a>, что требует
<a href="#sysvar_slave_parallel_type"><code>
slave_parallel_type=LOGICAL_CLOCK</code></a>, а также включения
<a href="#sysvar_log_bin"><code>log-bin</code></a> и
<a href="#sysvar_log_slave_updates"><code>log-slave-updates</code>
</a>.</li>

<li><span><em>Позиция низкой отметки без промежутков</em></span>.
Даже в отсутствие промежутков возможно, что транзакции после
<code>Exec_master_log_pos</code> не были применены. Таким образом, все
транзакции до точки <code>N</code> были применены, и никакие транзакции после
<code>N</code> не были применены, но <code>Exec_master_log_pos</code>
имеет значение меньше <code>N</code>. Это может произойти только на
мультипоточных ведомых устройствах. Включение
<a href="#sysvar_slave_preserve_commit_order"><code>
slave_preserve_commit_order</code></a> <span><em>не</em></span> предотвращает
такие позиции без промежутков.</p></li></ul>

<p>Следующие сценарии относятся к существованию полуприкладных транзакций,
промежутков и несогласованностей позиции низкой отметки без промежутков:</p>
<ol type="1"><li><p>В то время как ведомые потоки работают, могут быть
промежутки и полупримененные транзакции.</li>

<li><a href="programs.htm#mysqld"><span><strong>mysqld</strong></span></a>
закрывается. Чистое и грязное завершение работы прерывает продолжающиеся
транзакции и может оставить промежутки и полупримененные транзакции.</li>

<li><a href="sql.htm#kill"><code>KILL</code></a> для потоков
репликации (поток SQL, используя однопоточное ведомое устройство, поток
координатора, используя мультипоточное ведомое устройство). Это прерывает
продолжающиеся транзакции и может оставить
промежутки и полупримененные транзакции.</li>

<li>Ошибка в потоках. Это может оставить промежутки. Если ошибка находится в
смешанной транзакции, та транзакция полуприменена. Используя мультипоточное
ведомое устройство, рабочие потоки, которые не получили ошибку, завершают
свои очереди, таким образом, это может занять время, чтобы
остановить все потоки.</li>

<li><a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>, используя
мультипоточное ведомое устройство. После
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>
ведомое устройство ждет заполнения любых промежутков и затем обновляет
<code>Exec_master_log_pos</code>. Это гарантирует, что никогда не оставляет
промежутки или позиции низкой отметки без промежутков, если любой из случаев
выше не применяется (другими словами, прежде завершения
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>, ошибки,
получением от другого потока <a href="sql.htm#kill"><code>KILL</code></a>
или перезапуска сервера. В этих случаях
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> успешно отработает.
</li>

<li>Если последняя транзакция в журнале реле только полуполучена, и
мультипоточный ведомый координатор начал намечать транзакцию рабочему, то
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> ждет 60 секунд для
транзакции, которая будет получена. После этого тайм-аута координатор сдается
и прерывает транзакцию. Если транзакция смешана, это
может остаться полузавершенным.</li>

<li><a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>, используя
однопоточное ведомое устройство. Если продолжающаяся транзакция только
обновляет транзакционные таблицы, она отменена и
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> остановлен сразу.
Если продолжающаяся транзакция смешана,
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a> ждет 60 секунд для
транзакции, чтобы завершиться. После этого тайм-аута это прерывает
транзакцию, таким образом, это может оставить ее полузавершенной.
</p></li></ol>

<p>Глобальная переменная <a href="#sysvar_rpl_stop_slave_timeout">
<code>rpl_stop_slave_timeout</code></a> не связана с процессом остановки
потоков репликации. Это только делает клиенту, который вызвал
<a href="sql.htm#stop-slave"><code>STOP SLAVE</code></a>, возврат управления
к клиенту, но потоки репликации продолжают пытаться остановиться.</p>

<p>Если у канала репликации есть промежутки, у него
есть следующие последствия:</p>
<ol type="1"><li><p>Ведомая база данных находится в статусе, которое никогда,
возможно, не существовало на ведущем устройстве.</li>

<li>Поле <code>Exec_master_log_pos</code> в
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>
только "low-watermark". Другими словами, транзакции, появляющиеся перед
позицией, как гарантируют, переданы, но транзакции после позиции, возможно,
переданы или нет.</li>

<li><a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a>
для того канала терпят неудачу с ошибкой, если потоки применения
не работают и <a href="sql.htm#change-master-to"><code>CHANGE MASTER TO
</code></a> только устанавливает опции получателя.</li>

<li>Если <a href="programs.htm#mysqld"><span><strong>mysqld</strong></span>
</a> запущен с <a href="#option_mysqld_relay-log-recovery"><code>
--relay-log-recovery</code></a>, никакое восстановление не сделано для того
канала, и предупреждение напечатано.</li>

<li>Если <a href="programs.htm#mysqldump"><span><strong>mysqldump</strong>
</span></a> используется с <a href="programs.htm#option_mysqldump_dump-slave">
<code>--dump-slave</code></a>, это не делает запись существования
промежутков, таким образом это печатает
<a href="sql.htm#change-master-to"><code>CHANGE MASTER TO</code></a> с
<code>RELAY_LOG_POS</code>, установленным к позиции низкой отметки в
<code>Exec_master_log_pos</code>.</p>

<p>После применения дампа на другом сервере и запуска потоков репликации,
транзакции, появляющиеся после позиции, копируются снова. Отметьте, что это
безопасно, если GTID включены (однако, в этом случае не рекомендуется
использовать <a href="programs.htm#option_mysqldump_dump-slave"><code>
--dump-slave</code></a>).</p></li></ol>

<p>Если у канала репликации есть позиция низкой отметки
без промежутков, случаи 2-5 выше применяются, но случай 1 нет.</p>
<p>Информация о положении низкой отметки
без промежутков сохранена в двоичном формате во внутренней таблице
<code>mysql.slave_worker_info</code>.
<a href="sql.htm#start-slave"><code>START SLAVE [SQL_THREAD]</code></a>
всегда консультируется с этой информацией так, чтобы она применила только
правильные транзакции. Это остается истиной, даже если
<a href="#sysvar_slave_parallel_workers"><code>
slave_parallel_workers</code></a> был изменен на 0 до
<a href="sql.htm#start-slave"><code>START SLAVE</code></a> и даже если
<a href="sql.htm#start-slave"><code>START SLAVE</code></a> применен с
<code>UNTIL</code>. <a href="sql.htm#start-slave"><code>START SLAVE UNTIL
SQL_AFTER_MTS_GAPS</code></a> применяет так много транзакций как необходимо,
чтобы заполнить промежутки. Если
<a href="sql.htm#start-slave"><code>START SLAVE</code></a> применен с
<code>UNTIL</code>, который говорит этому останавливаться прежде, чем это
потребит все промежутки, тогда это оставляет промежутки.</p>

<p><a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a>
удаляет журналы реле и сбрасывает позицию репликации. Таким образом
на ведомом устройстве с промежутками ведомое устройство после
<a href="sql.htm#reset-slave"><code>RESET SLAVE</code></a> теряет любую
информацию о промежутках, не исправляя промежутки.</p>

<p><a href="#sysvar_slave_preserve_commit_order"><code>
slave-preserve-commit-order</code></a> гарантирует, что нет никаких
промежутков. Однако, все еще возможно, что <code>Exec_master_log_pos</code>
только позиция низкой отметки без промежутков в сценариях 1-4 выше. Таким
образом, после <code>Exec_master_log_pos</code> могут быть транзакции,
которые были применены. Поэтому случаи 2-5 (но не 1) применяются, даже когда
включена <a href="#sysvar_slave_preserve_commit_order"><code>
slave-preserve-commit-order</code></a>.</p>

<h4><a name="replication-features-triggers"></a>19.4.1.35.
Репликация и триггеры</h4>
<p>С основанной на запросе репликацией триггеры, выполненные на ведущем
устройстве, также выполняются на ведомом устройстве. С основанной на строке
репликацией триггеры, выполненные на ведущем устройстве, не выполняются на
ведомом устройстве. Вместо этого строка изменяется на ведущем устройстве,
следуя из выполнения, копируется и применяется на ведомое устройство.</p>

<p>Это поведение проект. Если бы под основанной на строке репликацией ведомое
устройство применяло триггеры так же, как изменения строки, вызванные ими, то
изменения были бы в действительности применены дважды на ведомом устройстве,
приводя к различным данным по ведущему и ведомому устройствам.</p>

<p>Если Вы хотите, чтобы триггеры выполнились на ведущем устройстве и на
ведомом, возможно, потому что у Вас есть различные триггеры на ведущем и на
ведомом, Вы должны использовать основанную на запросе репликацию. Однако,
чтобы включить триггеры ведомой стороны, не надо использовать основанную на
запросе репликацию исключительно. Достаточно переключиться на основанную на
запросе репликацию только для тех запросов, где Вы хотите этот эффект, и
использовать основанную на строке репликацию остальную часть времени.</p>

<p>Запрос, вызывающий триггер (или функцию), который вызывает обновление
<code>AUTO_INCREMENT</code> не копируется правильно, используя основанную на
запросе репликацию. MySQL 8.0 отмечает такие запросы
как опасные (Bug #45677).</p>

<p>У триггера могут быть триггеры для различных комбинаций событий
(<a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a>) и время действия
(<code>BEFORE</code>, <code>AFTER</code>), многократные триггеры разрешены.
</p>

<p>Для краткости <span><span>многократные триггеры</span></span>
это сокращение для <span><span>многократные триггеры, у которых есть то же
самое событие и время действия</span></span>.</p>

<p><span><strong>Обновления.</strong></span> Предположите, что Вы обновляете
старый сервер, который не поддерживает многократные триггеры (до 5.7.2)
к версии, которая это уже делает (MySQL 5.7.2 или выше).
Если новый сервер это ведущее устройство репликации и имеет старые ведомые
устройства, которые не поддерживают многократные триггеры, ошибка происходит
на тех ведомых устройствах, если триггер создается на ведущем устройстве для
таблицы, у которой уже есть триггер с тем же самым событием и временем
действия. Чтобы избежать этой проблемы, обновите ведомые устройства сначала,
затем обновите ведущее.</p>

<p><span><strong>Откат.</strong></span> Если Вы понижаете сервер, который
поддерживает многократные триггеры к более старой версии, которая этого не
делает, откат имеет эти эффекты:</p>

<ul><li><p>Для каждой таблицы, у которой есть триггеры, все определения
триггеров находятся в файле <code>.TRG</code> для таблицы. Однако, если есть
многократные триггеры с тем же самым событием и временем действия, сервер
выполняет только одного из них, когда событие имеет место. Для информации о
файлах <code>.TRG</code> см.
<a href="../../../dev.mysql.com/doc/internals/en/sp-storage.html#sp-storage-trigger"
target="_top">Table Trigger Storage</a>.</li>

<li>Если триггеры для таблицы добавлены или удалены после отката, сервер
переписывает файл <code>.TRG</code>. Переписанный файл сохраняет только один
триггер на комбинацию события и времени, другие потеряны.</p></li></ul>

<p>Чтобы избежать этих проблем, измените свои триггеры перед откатом.
Для каждой таблицы, у которой есть многократные триггеры на комбинацию
события и времени, преобразуйте каждый такой набор триггеров к единственному
триггеру следующим образом:</p>

<ol type="1"><li><p>Для каждого триггера, создайте сохраненную подпрограмму,
которая содержит весь код триггера. Значения с доступом к использованию
<code>NEW</code> и <code>OLD</code> могут быть переданы к обычным параметрам
использования. Если триггер нуждается в единственном значении результата от
кода, Вы можете поместить код в сохраненную функцию и иметь возвращенное
функцией значение. Если триггер нуждается в многократных значениях результата
от кода, Вы можете поместить код в хранимую процедуру и возвратить с
использованием значений параметров <code>OUT</code>.</li>

<li>Удалите все триггеры для таблицы.</li>
<li>Создайте один новый триггер для таблицы, который
вызывает сохраненные подпрограммы. Эффект для этого триггера то же самое,
как многократные триггеры, которые это заменяет.</p></li></ol>

<h4><a name="replication-features-truncate"></a>19.4.1.36.
Репликация и TRUNCATE TABLE</h4>
<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
обычно расценивается как запрос DML и будет зарегистрирован и скопирован,
используя основанный на строке формат, когда двоичной режим журналирования
<code>ROW</code> или <code>MIXED</code>. Однако это вызвало проблемы
регистрируя или копируя, в режимах <code>STATEMENT</code> или
<code>MIXED</code> таблицы, которые использовали транзакционные механизмы
хранения, когда операционный уровень изоляции был <code>READ COMMITTED</code>
или <code>READ UNCOMMITTED</code>, который устраняет основанное
на запросе журналирование.</p>

<p><a href="sql.htm#truncate-table"><code>TRUNCATE TABLE</code></a>
в целях регистрации и репликации работает как DDL, а не DML так, чтобы это
могло быть зарегистрировано и копироваться как запрос. Однако, эффекты
запроса применимо к <a href="innodb.htm"><code>InnoDB</code></a>
и другим транзакционным таблицам на ведомых устройствах репликации все еще
следуют правилам, описанным в <a href="sql.htm#truncate-table">
разделе 14.1.30</a> (Bug #36763).</p>

<h4><a name="replication-features-user-names"></a>19.4.1.37.
Репликация и длина имени пользователя</h4>
<p>Максимальная длина имен пользователя MySQL 32
символа в MySQL 5.7.8 или выше. Репликация имен пользователя длинней 16
символов к ведомому устройству, которое поддерживает только более короткие
имена пользователя, потерпит неудачу. Однако, это должно произойти только,
копируя от более нового ведущего устройства к более старому ведомому
устройству, которое не является рекомендуемой конфигурацией.</p>

<h4><a name="replication-features-variables"></a>19.4.1.38.
Репликация и переменные</h4>
<p>Системные переменные не копируются правильно, используя режим
<code>STATEMENT</code>, за исключением следующих переменных, когда они
используются с контекстом сеанса:</p>

<ul><li><p><a href="#sysvar_auto_increment_increment"><code>
auto_increment_increment</code></a></li>
<li><a href="#sysvar_auto_increment_offset"><code>
auto_increment_offset</code></a></li>
<li><a href="server.htm#sysvar_character_set_client"><code>
character_set_client</code></a></li>
<li><a href="server.htm#sysvar_character_set_connection"><code>
character_set_connection</code></a></li>
<li><a href="server.htm#sysvar_character_set_database"><code>
character_set_database</code></a></li>
<li><a href="server.htm#sysvar_character_set_server"><code>
character_set_server</code></a></li>
<li><a href="server.htm#sysvar_collation_connection"><code>
collation_connection</code></a></li>
<li><a href="server.htm#sysvar_collation_database"><code>
collation_database</code></a></li>
<li><a href="server.htm#sysvar_collation_server"><code>
collation_server</code></a></li>
<li><a href="server.htm#sysvar_foreign_key_checks"><code>
foreign_key_checks</code></a></li>
<li><a href="server.htm#sysvar_identity"><code>identity</code></a></li>
<li><a href="server.htm#sysvar_last_insert_id"><code>last_insert_id</code>
</a></li>
<li><a href="server.htm#sysvar_lc_time_names"><code>lc_time_names</code></a>
</li>
<li><a href="server.htm#sysvar_pseudo_thread_id"><code>pseudo_thread_id
</code></a></li>
<li><a href="server.htm#sysvar_sql_auto_is_null"><code>sql_auto_is_null
</code></a></li>
<li><a href="server.htm#sysvar_time_zone"><code>time_zone</code></a></li>
<li><a href="server.htm#sysvar_timestamp"><code>timestamp</code></a></li>
<li><a href="server.htm#sysvar_unique_checks"><code>unique_checks</code></a>
</p></li></ul>

<p>Когда используется режим <code>MIXED</code>, переменные в предыдущем
списке, когда используются с контекстом сеанса, вызывают переключение
от основанного на запросе до основанного на строке журналирования. См.
<a href="server.htm#binary-log-mixed">раздел 6.4.4.3</a>.</p>

<p><a href="server.htm#sysvar_sql_mode"><code>sql_mode</code></a>
также копируется за исключением
<a href="server.htm#sqlmode_no_dir_in_create"><code>NO_DIR_IN_CREATE</code>
</a>, ведомое устройство всегда сохраняет свое собственное значение для
<a href="server.htm#sqlmode_no_dir_in_create"><code>NO_DIR_IN_CREATE</code>
</a>, независимо от изменений этого на ведущем устройстве. Это истина для
всех форматов репликации.</p>

<p>Однако, когда <a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a> разбирает запрос
<code>SET @@sql_mode = <em><code>mode</code></em></code>, полное значение
<em><code>mode</code></em> value, включая
<a href="server.htm#sqlmode_no_dir_in_create"><code>NO_DIR_IN_CREATE</code>
</a>, передано к серверу получения. Поэтому репликация такого запроса,
возможно, не безопасна, когда применен режим <code>STATEMENT</code>.</p>

<p><a href="server.htm#sysvar_default_storage_engine"><code>
default_storage_engine</code></a> не копируется, независимо от режима
журналирования, это предназначено, чтобы облегчить репликацию между
различными механизмами хранения.</p>

<p><a href="server.htm#sysvar_read_only"><code>read_only</code></a>
не копируется. Кроме того, включение этой переменной имеет различные эффекты
относительно временных таблиц, табличной блокировки и
<a href="sql.htm#set-password"><code>SET PASSWORD</code></a>
в различных версиях MySQL.</p>

<p><a href="server.htm#sysvar_max_heap_table_size"><code>max_heap_table_size
</code></a> не копируется. Увеличение значения этой переменной на ведущем
устройстве, не делая так на ведомом устройстве может привести в конечном
счете к ошибке <span>Table is full</span>
на ведомом устройстве, пытаясь выполнить
<a href="sql.htm#insert"><code>INSERT</code></a> на таблице
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a>
на ведущем устройстве, которой таким образом разрешают вырасти больше, чем ее
коллеге на ведомом устройстве. Для получения дополнительной информации см.
<a href="#replication-features-memory">раздел 19.4.1.23</a>.</p>

<p>В основанной на запросе репликации переменные сеанса не копируются должным
образом, когда используются в запросах обновления таблицы. Например,
следующая последовательность запросов не будет вставлять те же самые данные
по ведущему и ведомому устройствам:
<pre>
SET max_join_size=1000;
INSERT INTO mytable VALUES(@@max_join_size);
</pre>

<p>Это не относится к общей последовательности:
<pre>
SET time_zone=...;
INSERT INTO mytable VALUES(CONVERT_TZ(..., ..., @@time_zone));
</pre>

<p>Репликация переменных сеанса не проблема, когда основанная
на строке репликация используется, тогда переменные сеанса всегда копируются
безопасно. См. <a href="#replication-formats">раздел 19.2.1</a>.
</p>

<p>В MySQL 8.0 следующие переменные сеанса написаны в
двоичный журнал и соблюдаются ведомым устройством репликации, разбирая
двоичной журнал, независимо от формата журналирования:</p>

<ul><li><p><a href="server.htm#sysvar_sql_mode"><code>sql_mode</code></a></li>
<li><a href="server.htm#sysvar_foreign_key_checks"><code>foreign_key_checks
</code></a></li>
<li><a href="server.htm#sysvar_unique_checks"><code>unique_checks</code></a>
</li>
<li><a href="server.htm#sysvar_character_set_client"><code>
character_set_client</code></a></li>
<li><a href="server.htm#sysvar_collation_connection"><code>
collation_connection</code></a></li>
<li><a href="server.htm#sysvar_collation_database"><code>collation_database
</code></a></li>
<li><a href="server.htm#sysvar_collation_server"><code>collation_server
</code></a></li>
<li><a href="server.htm#sysvar_sql_auto_is_null"><code>sql_auto_is_null
</code></a></p></li></ul>

<p>Даже при том, что переменные сеанса, касающиеся наборов символов
и сопоставлений, написаны в двоичный журнал, репликация между различными
наборами символов не поддержана.</p>

<p>Чтобы помочь уменьшить возможный беспорядок, мы рекомендуем, чтобы Вы
всегда использовали ту же самую установку для
<a href="server.htm#sysvar_lower_case_table_names"><code>
lower_case_table_names</code></a> на ведущем и на ведомом устройствах,
особенно когда Вы выполняете MySQL на платформах с чувствительными к
регистру файловыми системами.</p>

<h4><a name="replication-features-views"></a>19.4.1.39.
Репликация и представления</h4>
<p>Представления всегда копируются к ведомым устройствам. Представления
фильтруются по их собственному имени, не по таблицам, к которым они
обращаются. Это означает, что представление может копироваться к ведомому
устройству, даже если содержит таблицу, которая обычно отфильтровывалась бы
правилами <code>replication-ignore-table</code>. Забота должна поэтому быть
проявлена, чтобы гарантировать, что представления не копируют табличные
данные, которые обычно фильтровались бы из соображений безопасности.</p>

<p>Репликация от таблицы в одноименное представление поддержана, используя
основанное на запросе журналирование, но не используя основанное на строке
журналирование. Попытка сделать так, когда работает основанное на строке
журналирование приводит к ошибке.</p>

<h3><a name="replication-compatibility"></a>19.4.2.
Совместимость репликации между версиями MySQL</h3>
<p>MySQL поддерживает Репликация от одного ряда выпуска до следующей более
высокой серии выпуска. Например, Вы можете копировать от ведущего с MySQL 5.6
к ведомому с MySQL 5.7, с ведущего с MySQL 5.7 к ведомому с MySQL 8.0 и т.д.
</p>

<p>Однако, Вы можете столкнуться с трудностями, копируя от ведущего
устройства старшего возраста к более новому ведомому устройству, если ведущее
устройство использует запросы или полагается на поведение, больше не
поддержанное в версии MySQL на ведомом устройстве. Например, в MySQL 5.5
<a href="sql.htm#create-table-select"><code>CREATE TABLE ... SELECT</code>
</a> разрешают изменить таблицы кроме создаваемой, но больше это не позволено
в MySQL 5.6 (см. <a href="#replication-features-create-select">
раздел 19.4.1.6</a>).</p>

<p>Использование больше чем двух версий MySQL Server не поддержано
в установках репликации, вовлекающих многократные ведущие устройства,
независимо от числа основных или ведомых серверов MySQL. Это ограничение
применяется не только к рядам выпуска, но и к номерам версии в пределах того
же самого ряда выпуска также. Например, если Вы используете цепочечную или
круговую установку репликации, Вы не можете использовать MySQL
8.0.1, MySQL 8.0.2 и MySQL сразу, хотя Вы могли использовать любые два из
этих выпусков вместе.</p>

<p>Сильно рекомендуется использовать новый выпуск, доступный в пределах
данного ряда выпуска MySQL, потому что репликация непрерывно улучшается.
Также рекомендуется обновить ведущие и ведомые устройства, которые используют
ранние выпуски серии выпуска MySQL к GA (производственным) выпускам, когда
последние становятся доступными для этого ряда выпуска.</p>

<p>Репликация от более новых ведущих устройств к более старым ведомым может
быть возможна, но вообще не поддержан. Это происходит из-за многих факторов:
</p>

<ul><li><p><b>Изменения формата журнала. </b>Формат журнала может измениться
между главными выпусками. В то время как мы пытаемся поддержать обратную
совместимость, это не всегда возможно.</p>

<p>У этого также есть существенные значения для того, чтобы обновить серверы
репликации, см. <a href="#replication-upgrade">раздел 19.4.3</a>.
</li>
<li>См. <a href="#replication-formats">раздел 19.2.1</a>.</li>

<li><b>Несовместимости SQL. </b>Вы не можете копировать от более нового
ведущего устройства к более старому ведомому, используя основанную на запросе
репликацию, если запросы, которые будут копироваться, используют особенности
SQL, доступные на ведущем устройстве, но не на ведомом.</p>

<p>Однако, если оба устройства применяют основанную на строке репликацию, и
нет никаких запросов определения данных, которые будут копироваться, которые
зависят от особенностей SQL, на ведущем, но не на ведомом устройстве, Вы
можете использовать основанную на строке репликацию, чтобы копировать эффекты
запросов модификации данных, даже если DDL, выполненный на ведущем
устройстве, не поддержан на ведомом устройстве.</p></li></ul>
<p>См. <a href="#replication-features">раздел 19.4.1</a>.</p>

<h3><a name="replication-upgrade"></a>19.4.3. Обновление установки репликации
</h3>
<p>Когда Вы обновляете серверы, которые участвуют в установке репликации,
процедура для того, чтобы обновить, зависит от текущих версий сервера и
версии, до которой Вы обновляете. Этот раздел предоставляет информацию о том,
как обновление репликации может повлиять на работу.
Для общей информации об обновлении MySQL см.
<a href="install.htm#upgrading">раздел 2.10.1</a>.</p>

<p>Когда Вы обновляете ведущее устройство до 8.0 от более раннего ряда
выпуска MySQL, Вы должны сначала гарантировать, что все ведомые устройства
этого ведущего устройства используют тот же самый выпуск 8.0.x.
Если дело обстоит не так, Вы должны сначала обновить ведомые устройства.
Чтобы обновить каждое ведомое устройство, закройте это, обновите до
соответствующей версии 8.0.x, перезапустите сервер и репликацию.
Журналы реле, создаваемые ведомым устройством после
обновления, находятся в форматах 8.0.</p>

<p>Изменения, затрагивающие операции в строгом режиме SQL,
могут привести к отказу репликации на обновленном ведомом
устройстве. Например, сервер ограничивает вставку <code>DEFAULT</code>
значения 0 для временных типов данных в строгом режиме
(<a href="server.htm#sqlmode_strict_trans_tables"><code>STRICT_TRANS_TABLES
</code></a> или <a href="server.htm#sqlmode_strict_all_tables"><code>
STRICT_ALL_TABLES</code></a>). Получающаяся несовместимость для репликации,
если Вы используете основанное на запросе журналирование
(<a href="#sysvar_binlog_format"><code>binlog_format=STATEMENT
</code></a>) это, если ведомое устройство будет обновлено, то необновленное
ведущее устройство выполнит запросы без ошибки, которая может потерпеть
неудачу на ведомом устройстве, и репликация остановится. Чтобы иметь дело с
этим, остановите все новые запросы на ведущем устройстве и ждите, пока
ведомые устройства его не нагонят. Тогда обновите ведомые устройства.
Альтернативно, если Вы не можете остановить новые запросы,
временно измените на основанный на строке формат журналирования
ведущего устройства (<a href="#sysvar_binlog_format"><code>
binlog_format=ROW</code></a>) и ждите, пока все ведомые устройства не
обработают все двоичные журналы, произведенные на грани этого изменения.
Тогда обновите ведомые устройства.</p>

<p>После того, как ведомые устройства были обновлены, закройте
ведущее устройство, обновите до того же самого выпуска 8.0.x, как ведомые
устройства, и перезапустите. Если Вы временно изменили ведущее устройство на
основанное на строке журналирование, измените его назад на основанное на
запросе журналирование. Ведущие устройства 8.0 в состоянии читать старые
двоичные журналы, написанные до обновления и послать их в эти ведомые
устройства 8.0. Ведомые устройства признают старый формат и обрабатывают его
должным образом. Двоичные журналы, создаваемые ведущим устройством после
обновления, находятся в форматах 8.0.
Они также признаны ведомыми устройствами 8.0.</p>

<p>Другими словами, обновляя до MySQL 8.0, ведомые устройства должны быть
MySQL 8.0 прежде, чем Вы сможете обновить ведущее устройство до 8.0.
Отметьте, что откат от 8.0 до более старых версий не работает так просто: Вы
должны гарантировать, что любые двоичные журналы 8.0 или журналы реле 8.0
были полностью обработаны, так, чтобы Вы могли удалить их
перед продолжением отката.</p>

<p>Откат установки репликации к предыдущей версии не может быть сделан, как
только Вы переключились от основанной на запросе на основанную на строке
репликации, и после того, как первый основанный на строке запрос был написан
в двоичный журнал. См. <a href="#replication-formats">раздел
19.2.1</a>.</p>

<p>Некоторые обновления могут потребовать, чтобы Вы удалили и обновили
объекты базы данных, когда Вы перемещаетесь от одного ряда MySQL до
следующего. Например, изменения сопоставления могли бы потребовать
пересоздания индексов таблицы. Такие операции, в случае необходимости,
детализированы в <a href="install.htm#upgrading-from-previous-series">
разделе 2.10.1.1</a>. Является самым безопасным выполнить эти операции
отдельно на ведомых устройствах и ведущем устройстве и отключить репликацию
этих операций от ведущего устройства к ведомому. Чтобы достигнуть этого,
используйте следующую процедуру:</p>

<ol type="1"><li><p>Остановите все ведомые устройства и обновите их.
Перезапустите их с <a href="#option_mysqld_skip-slave-start">
<code>--skip-slave-start</code></a>, чтобы они не соединились с ведущим
устройством. Выполните любые операции ремонта или восстановления таблицы,
которые должны были обновить объекты базы данных, такие как использование
<code>REPAIR TABLE</code>, <code>ALTER TABLE</code>
или дамп и перезагрузка таблиц или триггеров.</li>

<li>Отключите двоичный журнал ведущего устройства. Чтобы сделать это, не
перезапуская ведущее устройство, выполните <code>SET sql_log_bin = 0</code>.
Альтернативно, остановите ведущее устройство и перезапустите это без опции
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>.
Если Вы перезапускаете ведущее устройство, Вы могли бы также хотеть
отвергнуть соединения клиента. Например, если все клиенты соединяются с
использованием TCP/IP, используйте
<a href="server.htm#option_mysqld_skip-networking"><code>--skip-networking
</code></a>, когда Вы перезапускаете ведущее устройство.</li>

<li>С отключенным двоичным журналом выполните любые операции ремонта
или восстановления таблицы, которые должны были обновить объекты базы данных.
Двоичный журнал должен быть отключен во время этого шага, чтобы
препятствовать тому, чтобы эти операции были зарегистрированы и посланы
в ведомые устройства позже.</li>

<li>Повторно включите двоичный журнал нга ведущем устройстве.
Если Вы устанавливаете <a href="server.htm#sysvar_sql_log_bin"><code>
sql_log_bin</code></a> = 0, выполните <code>SET sql_log_bin = 1</code>.
Если Вы перезапускали ведущее устройство, чтобы отключить двоичной журнал,
перезапустите его с <a href="#option_mysqld_log-bin"><code>
--log-bin</code></a> и без <a href="server.htm#option_mysqld_skip-networking">
<code>--skip-networking</code></a>, чтобы клиенты и ведомые
устройства могли соединиться.</li>

<li>Перезапустите ведомые устройства, на сей раз без опции
<a href="#option_mysqld_skip-slave-start"><code>
--skip-slave-start</code></a>.</p></li></ol>

<p>Если Вы обновляете существующую установку репликации от версии MySQL,
которая не поддерживает глобальные операционные идентификаторы к версии,
которая это делает, Вы не должны включить GTID на ведущем или на ведомом
устройстве прежде, чем удостоверитесь, что установка отвечает всем
требованиям для GTID-репликации. Например,
<a href="#sysvar_server_uuid"><code>server_uuid</code></a>,
который был добавлен в MySQL 5.6, должен существовать для GTID, чтобы
функционировать правильно. См. <a href="#replication-gtids-howto">
раздел 19.1.3.2</a>, который содержит информацию о преобразовании
существующих установок репликации, чтобы использовать GTID-репликацию.</p>

<h3><a name="replication-problems"></a>19.4.4.
Поиск неисправностей репликации</h3>
<p>Если Вы следовали инструкциям, но Ваша установка репликации не работает,
первое, что нужно сделать <span><em>проверить журнал ошибок</em></span>.
Много пользователей потеряли время, не делая это достаточно быстро
после столкновения с проблемами.</p>

<p>Если Вы не можете сказать из журнала ошибок, какова проблема,
попробуйте следующие методы:</p>
<ul><li><p>Проверьте, что ведущему устройству включили двоичное
журналирование. Проверка делается с помощью
<a href="sql.htm#show-master-status"><code>SHOW MASTER STATUS</code></a>.
Если журналирование включено, <code>Position</code> не 0. Если двоичное
журналирование не включено, проверьте, что Вы выполняете ведущее устройство с
опцией <a href="#option_mysqld_log-bin"><code>--log-bin</code>
</a>.</li>

<li>Проверьте, что ведущее и ведомое устройства оба были запущены с опцией
<a href="#option_mysqld_server-id"><code>--server-id</code></a>
и что значение ID уникально на каждом сервере.</li>

<li>Проверьте, что ведомое устройство работает. Надо использовать
<a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>,
чтобы проверить, что <code>Slave_IO_Running</code> и
<code>Slave_SQL_Running</code> имеют значение <code>Yes</code>.
В противном случае проверьте опции, которые использовались, запуская ведомый
сервер. Например, <a href="#option_mysqld_skip-slave-start">
<code>--skip-slave-start</code></a> препятствует тому, чтобы ведомые потоки
запустились до <a href="sql.htm#start-slave"><code>START SLAVE</code></a>.
</li>

<li>Если ведомое устройство работает, проверьте, основало ли оно соединение с
ведущим. Надо использовать <a href="sql.htm#show-processlist"><code>SHOW
PROCESSLIST</code></a>, найдите ввод/вывод и потоки SQL и проверьте их
столбец <code>State</code>, чтобы видеть, что они выводят на экран. См.
<a href="#replication-implementation-details">раздел 19.2.2</a>.
Если состояние потока ввода/вывода <code>Connecting to master</code>,
то проверьте следующее:</p>

<ul><li><p>Проверьте привилегии для пользователя, используемого для
репликации на ведущем устройстве.</li>
<li>Проверьте, что имя хоста ведущего устройства правильно и что Вы
используете правильный порт, чтобы соединиться с ведущим устройством.
Порт, используемый для репликации, является тем же самым, как использующийся
для сетевых коммуникаций клиента (значение по умолчанию <code>3306</code>).
Для имени хоста гарантируйте, что имя ведет к правильному IP-адресу.</li>

<li>Проверьте, что сети не были отключены на ведущем
или ведомом устройствах. Ищите опцию
<a href="server.htm#option_mysqld_skip-networking"><code>skip-networking
</code></a> в конфигурационном файле. Если существует,
закомментируйте или удалите.</li>

<li>Если у ведущего устройства есть брандмауэр или конфигурация фильтрации
IP, гарантируйте, что сетевой порт, используемый для MySQL, не фильтруется.
</li>
<li>Проверьте, что Вы можете достигнуть ведущего устройства при использовании
<code>ping</code> или <code>traceroute</code>/<code>tracert</code>.
</p></li></ul></li>

<li>Если ведомое устройство работало ранее, но остановилось,
причина обычно состоит в том, что некоторый запрос, который преуспел на
ведущем устройстве, провалился на ведомом. Это никогда не должно происходить,
если Вы взяли надлежащий снимок ведущего устройства и никогда не изменяли
данные по ведомому устройству за пределами ведомого потока.
Если ведомое устройство неожиданно останавливается, это ошибка, или Вы
столкнулись с одним из известных ограничений репликации, описанных в
<a href="#replication-features">разделе 19.4.1</a>.
Если это ошибка, см. <a href="#replication-bugs">раздел 19.4.5
</a> для инструкций, как сообщить об этом.</li>

<li>Если запрос, который преуспел на ведущем устройстве, отказывается
работать на ведомом, попробуйте следующую процедуру, если невыполнимо сделать
полную пересинхронизацию базы данных, удаляя базы данных ведомого устройства
и копируя новый снимок от ведущего устройства:</p>

<ol type="1"><li><p>Определите, отличается ли затронутая таблица на ведомом
устройстве от основной таблицы. Попытайтесь понять, как это произошло. Тогда
сделайте таблицу ведомого устройства идентичной ведущему устройству и
выполните <a href="sql.htm#start-slave"><code>START SLAVE</code></a>.</li>

<li>Если предыдущий шаг не работает или не применяется, попытайтесь понять,
было ли бы безопасно сделать обновление вручную (если нужно) и затем
проигнорировать следующий запрос от ведущего устройства.</li>

<li>Если Вы решаете, что ведомое устройство может пропустить следующий
запрос от ведущего устройства, сделайте следующие запросы:
<pre>
mysql&gt; SET GLOBAL sql_slave_skip_counter = <em><code>N</code></em>;
mysql&gt; START SLAVE;
</pre>

<p>Значение <em><code>N</code></em> должно быть 1, если следующий
запрос от ведущего устройства не использует <code>AUTO_INCREMENT</code> или
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()</code>
</a>. Иначе значение должно быть 2. Причина использования значения 2 для
запросов <code>AUTO_INCREMENT</code> или
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()</code></a>
то, что они берут два события в двоичном журнале ведущего устройства.</p>

<p>См. <a href="sql.htm#set-global-sql-slave-skip-counter">раздел 14.4.2.5
</a>.</li>
<li>Если Вы уверены, что ведомое устройство начиналось отлично
синхронизированным с ведущим устройством, и что никто не обновил таблицы за
пределами ведомого потока, то по-видимому несоответствие результат ошибки.
Если Вы выполняете новую версию MySQL, пожалуйста, сообщите о проблеме. Если
Вы выполняете более старую версию, попытайтесь обновиться до последнего
производственного выпуска, чтобы определить, сохраняется ли проблема.
</p></li></ol></li></ul>

<h3><a name="replication-bugs"></a>19.4.5.
Как сообщить об ошибках или проблемах репликации</h3>
<p>Когда Вы решили, что нет никакой пользовательской ошибки
и репликация все еще не работает вообще или непостоянна, пора послать нам
отчет об ошибках. Мы должны получить настолько большую информацию, насколько
возможно от Вас, чтобы быть в состоянии разыскать ошибку. Пожалуйста,
проведите некоторое время и усилие в подготовке хорошего отчета об ошибках.
</p>

<p>Если у Вас есть повторимый прецедент, который демонстрирует ошибку,
пожалуйста, введите ее в нашу базу данных ошибок, используя инструкции,
данные в <a href="intro.htm#bug-reports">разделе 1.7</a>. Если у Вас есть
<span><span>призрак</span></span> проблемы (который Вы не можете дублировать
по желанию), используйте следующую процедуру:</p>

<ol type="1"><li><p>Проверьте, что никакая пользовательская ошибка не
вовлечена. Например, если Вы обновляете ведомое устройство за пределами
ведомого потока, данные выходят из синхронизации, и у Вас могут быть
уникальные ключевые нарушения на обновлениях. В этом случае ведомый поток
останавливается и ждет, чтобы очистить таблицы вручную, чтобы привести их в
синхронизацию. <span><em>Это не проблема репликации.
Это проблема внешнего вмешательства</em></span>.</li>

<li>Выполните ведомое устройство с опциями
<a href="#option_mysqld_log-slave-updates"><code>
--log-slave-updates</code></a> и
<a href="#option_mysqld_log-bin"><code>--log-bin</code></a>.
Эти опции заставляют ведомое устройство регистрировать обновления, которые
оно получает от ведущего устройства в его собственные двоичные журналы.</li>

<li>Сохраните все доказательства прежде, чем сбросить статус репликации.
Если у нас нет никакой информации или она только отрывочна, становится
трудным или невозможным для нас разыскать проблему. Доказательства, которые
Вы должны собрать:</p>

<ul><li><p>Все двоичные файлы системного журнала от ведущего устройства.</li>
<li>Все двоичные файлы системного журнала от ведомого устройства.</li>
<li>Вывод <a href="sql.htm#show-master-status"><code>SHOW MASTER STATUS
</code></a> от ведущего устройства в то время, когда Вы обнаружили проблему.
</li>

<li>Вывод <a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code>
</a> от ведомого устройства в то время, когда Вы обнаружили проблему.</li>
<li>Журналы ошибок от ведущего и ведомого устройств.</p></li></ul></li>

<li>Примените <a href="programs.htm#mysqlbinlog"><span><strong>mysqlbinlog
</strong></span></a>, чтобы исследовать двоичные журналы. Следующее должно
быть полезным, чтобы найти проблемный запрос.
<em><code>log_file</code></em> и <em><code>log_pos</code></em> это
значения <code>Master_Log_File</code> и <code>Read_Master_Log_Pos</code>
из <a href="sql.htm#show-slave-status"><code>SHOW SLAVE STATUS</code></a>.
<pre>
shell&gt; mysqlbinlog --start-position=<em><code>log_pos</code></em> <em><code>log_file</code></em> | head
</pre></li></ol>

<p>После того, как Вы собрали доказательства для проблемы, попытайтесь
изолировать это как отдельный прецедент сначала. Тогда введите проблему с
такой большой информацией насколько возможно в нашу базу данных ошибок,
используя инструкции в <a href="intro.htm#bug-reports">разделе 1.7</a>.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
