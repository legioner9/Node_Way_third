<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 21. Сохраненные программы и представления</title>
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="stored-programs-views"></a>
Глава 21. Сохраненные программы и представления</h1>
<p>Эта глава обсуждает сохраненные программы и представления, которые
являются объектами базы данных, определенными с точки зрения кода SQL,
который сохранен на сервере для более позднего выполнения.</p>

<p>Сохраненные программы включают эти объекты:</p>
<ul><li><p>Сохраненные подпрограммы, то есть, хранимые процедуры и функции.
Хранимая процедура вызвана, используя
<a href="sql.htm#call"><code>CALL</code></a>.
Процедура не имеет возвращаемого значения, но может изменить параметры для
более позднего просмотра. Это может также произвести наборы результатов,
которые будут возвращены программе клиента. Сохраненная функция используется
как встроенная функция. Вы вызываете это в выражении, и она возвращает
значение во время оценки выражения.</li>

<li>Триггеры. Триггер названный объект базы данных, который связан с
таблицей и активирован, когда особое событие имеет место для таблицы такое,
как вставка или обновление.</li>
<li>События. Событие задача, которую сервер выполняет согласно графику.
</p></li></ul>

<p>Представления сохраняют запросы, которые когда на них ссылаются,
производят набор результатов. Представление действует
как виртуальная таблица.</p>

<p>Эта глава описывает, как использовать сохраненные программы и
представления. Следующие разделы обеспечивают дополнительную информацию о
синтаксисе SQL для запросов, связанных с этими объектами:</p>

<ul><li><p>Для каждого типа объекта есть команды
<code>CREATE</code>, <code>ALTER</code> и <code>DROP</code>, которые
управляют тем, какие объекты существуют и как они определены. См.
<a href="sql.htm#sql-syntax-data-definition">раздел 14.1</a>.</li>

<li><a href="sql.htm#call"><code>CALL</code></a> используется, чтобы вызвать
хранимые процедуры. См. <a href="sql.htm#call">раздел 14.2.1</a>.</li>

<li>Сохраненные определения программы включают тело, которое может
использовать составные запросы, циклы, условные предложения и объявленные
переменные. См. <a href="sql.htm#sql-syntax-compound-statements">раздел 14.6
</a>.</li></ul>

<p>В MySQL метаданные изменяющиеся у объектов, упомянутых сохраненными
программами, обнаружены и вызывают автоматический перепарсинг затронутых
запросов, когда программа затем выполнена. Для получения дополнительной
информации см. <a href="optimiz.htm#statement-caching">раздел 9.10.4</a>.</p>

<h2><a name="stored-programs-defining"></a>
21.1. Определение сохраненных программ</h2>
<p>Каждая сохраненная программа содержит тело, которое состоит из запроса
SQL.Это запрос может быть составным запросом, составленным из нескольких,
отделенных точкой с запятой (<code>;</code>). Например, тело следующей
хранимой процедуры составляет блок <a href="sql.htm#begin-end"><code>BEGIN
... END</code></a>, который содержит запрос
<a href="sql.htm#set-variable"><code>SET</code></a> и цикл
<a href="sql.htm#repeat"><code>REPEAT</code></a>, который непосредственно
содержит другой <a href="sql.htm#set-variable"><code>SET</code></a>:
<pre>
CREATE PROCEDURE dorepeat(p1 INT)
BEGIN
  SET @x = 0;
  REPEAT SET @x = @x + 1; UNTIL @x &gt; p1 END REPEAT;
END;
</pre>

Если Вы используете
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>, чтобы
определить сохраненную программу, содержащую символы точки с запятой,
возникает проблема. По умолчанию <a href="programs.htm#mysql"><span><strong>
mysql</strong></span></a> признает точку с запятой разделителем запроса,
таким образом, Вы должны пересмотреть разделитель временно, чтобы заставить
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>
передавать все сохраненное определение программы серверу.</p>

<p>Чтобы пересмотреть разделитель, используйте команду
<code>delimiter</code>. Следующий пример показывает, как сделать это для
процедуры <code>dorepeat()</code>. Разделитель изменен на <code>//</code>,
чтобы позволить всему определению быть переданным к серверу как единственный
запрос, а затем <code>;</code> восстанавливается прежде, чем вызвать
процедуру. Это включает разделитель <code>;</code>, используемый в теле
процедуры, который передается к серверу вместо того, чтобы интерпретироваться
непосредственно <a href="programs.htm#mysql">
<span><strong>mysql</strong></span></a>.
<pre>
mysql&gt; delimiter //
mysql&gt; CREATE PROCEDURE dorepeat(p1 INT)
    -&gt; BEGIN
    -&gt;   SET @x = 0;
    -&gt;   REPEAT SET @x = @x + 1; UNTIL @x &gt; p1 END REPEAT;
    -&gt; END
    -&gt; //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; delimiter ;
mysql&gt; CALL dorepeat(1000);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT @x;
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)
</pre>

Вы можете переделать разделитель на строку вовсе не обязательно именно
<code>//</code>, разделитель может состоять из одного или нескольких
символов. Вы должны избегать использования наклонной черты влево
(<code>\</code>), потому что это символ ESC для MySQL.</p>

<p>Следующее пример функции, которая берет параметр, выполняет работу,
используя функцию SQL, и возвращает результат. В этом случае не нужно
использовать <code>delimiter</code>, потому что функциональное определение не
содержит внутренний разделитель запроса:
<pre>
mysql&gt; CREATE FUNCTION hello (s CHAR(20))
mysql&gt; RETURNS CHAR(50) DETERMINISTIC
    -&gt; RETURN CONCAT('Hello, ',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT hello('world');
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)
</pre>

<h2><a name="stored-routines"></a>21.2.
Использование сохраненных подпрограмм (процедуры и функции)</h2>
<p>MySQL поддерживает сохраненные подпрограммы (процедуры и функции).
Сохраненная подпрограмма ряд запросов SQL, которые могут быть сохранены на
сервере. Как только это было сделано, клиенты могут обратиться к
сохраненной подпрограмме напрямую.</p>

<p>Сохраненные подпрограммы могут быть особенно
полезными в определенных ситуациях:</p>
<ul><li><p>Когда приложения-клиенты написаны на различных языках или
работают под различными платформами, но должны выполнить те же самые
операции базы данных.</li>

<li>Когда безопасность является главной. Банки, например, используют хранимые
процедуры и функции для всех общих операций. Это обеспечивает
последовательную и безопасную окружающую среду, и подпрограммы могут
гарантировать, что каждая работа должным образом зарегистрирована.
В такой установке приложения и пользователи не имели бы никакого доступа к
таблицам базы данных непосредственно, а могут только выполнить
определенные сохраненные подпрограммы.</p></li></ul>

<p>Сохраненные подпрограммы могут обеспечить улучшенную работу, потому что
меньше информации нужно послать между сервером и клиентом. Обмен состоит в
том, что это действительно увеличивает загрузку на сервере базы данных,
потому что больше работы сделано на стороне сервера, и меньше сделано на
стороне клиента (приложения). Рассмотрите это, если много машин клиента
(таких, как веб-серверы) обслуживаются только одним или несколькими
серверами базы данных.</p>

<p>Сохраненные подпрограммы также позволяют Вам иметь библиотеки функций на
сервере базы данных. Это особенность, совместно использованная
современными языками приложений, которые включают такое внутренне (например,
при использовании классов). Использование этих языковых функций
приложения-клиента выгодно для программиста даже вне контекста
использования базы данных.</p>

<p>MySQL следует за синтаксисом SQL:2003 для сохраненных подпрограмм, который
также используется DB2 IBM. Весь синтаксис, описанный здесь, поддерживается,
любые ограничения и расширения зарегистрированы.</p>

<h3><a name="idm139965297029792"></a>Дополнительные ресурсы</h3>
<ul><li><p>Вы можете найти <a href="../../../forums.mysql.com/list.php@98"
target="_top">Stored Procedures User Forum</a> полезным, работая с
хранимыми процедурами и функциями.</li>

<li>Для ответов на некоторые обычно задаваемые вопросы относительно
сохраненных подпрограмм в MySQL см. <a href="faqs.htm#faqs-stored-procs">
раздел A.4</a>.</li>

<li>Есть некоторые ограничения на использование сохраненных подпрограмм. См.
<a href="restr.htm#stored-program-restrictions">раздел C.1</a>.</li>
<li>Двоичное журналирование для сохраненных подпрограмм имеет место как
описано в <a href="#stored-programs-logging">разделе 21.7</a>.
</p></li></ul>

<h3><a name="stored-routines-syntax"></a>21.2.1. Синтаксис подпрограмм</h3>
<p>Сохраненная подпрограмма процедура или функция. Сохраненные подпрограммы
создаются с помощью <a href="sql.htm#create-procedure"><code>CREATE
PROCEDURE</code></a> и <a href="sql.htm#create-function"><code>CREATE
FUNCTION</code></a> (см. <a href="sql.htm#create-procedure">раздел 14.1.13
</a>). Процедура вызвана, используя <a href="sql.htm#call"><code>CALL</code>
</a> (см. <a href="sql.htm#call">раздел 14.2.1</a>),
и может вернуть значения, используя только выходные переменные.
Функция может быть вызвана из запроса точно так же, как любая другая функция
(то есть, обращаясь к имени функции) и может возвратить скалярное значение.
Тело сохраненной подпрограммы может использовать составные запросы (см.
<a href="sql.htm#sql-syntax-compound-statements">раздел 14.6</a>).</p>

<p>Сохраненные подпрограммы могут быть удалены через
<a href="sql.htm#drop-procedure"><code>DROP PROCEDURE</code></a> и
<a href="sql.htm#drop-function"><code>DROP FUNCTION</code></a> (см.
<a href="sql.htm#drop-procedure">раздел 14.1.23</a>) и изменены с помощью
<a href="sql.htm#alter-procedure"><code>ALTER PROCEDURE</code></a> и
<a href="sql.htm#alter-function"><code>ALTER FUNCTION</code></a> (см.
<a href="sql.htm#alter-procedure">раздел 14.1.5</a>).</p>

<p>Хранимая процедура или функция связана с особой базой данных.
У этого есть несколько значений:</p>
<ul><li><p>Когда подпрограмма вызвана, выполнено неявное <code>USE
<em><code>db_name</code></em></code> (и отменено, когда подпрограмма
заканчивается). Запросы <a href="sql.htm#use"><code>USE</code></a>
в пределах сохраненных подпрограмм не разрешены.</li>

<li>Вы можете квалифицировать обычные имена с именем базы данных. Это может
использоваться, чтобы обратиться к подпрограмме, которая не находится в
текущей базе данных. Например, чтобы вызвать хранимую процедуру
<code>p</code> или функцию <code>f</code>, которые связаны с базой данных
<code>test</code>, Вы можете сказать <code>CALL test.p()</code> или
<code>test.f()</code>.</li>

<li>Когда база данных удалена, все сохраненные подпрограммы, связанные с
нею, также удалены.</p></li></ul>
<p>Сохраненные функции не могут быть рекурсивными.</p>

<p>Рекурсия в хранимых процедурах разрешена, но отключена по умолчанию.
Чтобы включить рекурсии, установите переменную
<a href="server.htm#sysvar_max_sp_recursion_depth"><code>
max_sp_recursion_depth</code></a> к значению больше ноля. Рекурсия хранимой
процедуры увеличивает требование к пространству стека потока. Если Вы
увеличиваете значение
<a href="server.htm#sysvar_max_sp_recursion_depth"><code>
max_sp_recursion_depth</code></a>, может быть необходимо увеличить размер
стека потока, увеличивая значение
<a href="server.htm#sysvar_thread_stack"><code>thread_stack</code></a> при
запуске сервера. См. <a href="server.htm#server-system-variables">раздел
6.1.5</a>.</p>

<p>MySQL поддерживает очень полезное расширение, которое включает
использование регулярных запросов <a href="sql.htm#select"><code>SELECT
</code></a> (то есть, не используя курсоры или местные переменные) в хранимой
процедуре. Набор результатов такого запроса просто посылают непосредственно
клиенту. Многократный <a href="sql.htm#select"><code>SELECT</code></a>
производит много наборов результатов, таким образом, клиент должен
пользоваться библиотекой клиента MySQL, которая поддерживает многократные
наборы результатов. Это означает, что клиент должен пользоваться библиотекой
клиента от версии MySQL, по крайней мере, 4.1. Клиент должен также определить
опцию <code>CLIENT_MULTI_RESULTS</code>, когда соединяется. Для программ C
это может быть сделано с помощью функции
<a href="connect.htm#mysql-real-connect"><code>mysql_real_connect()</code>
</a> C API. См. разделы <a href="connect.htm#mysql-real-connect">25.8.7.54
</a> и <a href="connect.htm#c-api-multiple-queries">25.8.17</a>.</p>

<h3><a name="stored-routines-privileges"></a>21.2.2.
Сохраненные подпрограммы и привилегии MySQL</h3>
<p>Система привилегий MySQL принимает сохраненные подпрограммы во
внимание следующим образом:</p>

<ul><li><p>Привилегия <a href="security.html#priv_create-routine"><code>
CREATE ROUTINE</code></a> необходима, чтобы создать сохраненные подпрограммы.
</li>

<li>Привилегия <a href="security.html#priv_alter-routine"><code>ALTER ROUTINE
</code></a> необходима, чтобы изменить или удалить сохраненные подпрограммы.
Эту привилегию предоставляют автоматически создателю подпрограммы в случае
необходимости и удаляют, когда подпрограмма удалена.</li>

<li>Привилегия <a href="security.html#priv_execute"><code>EXECUTE</code></a>
требуется, чтобы выполнять сохраненные подпрограммы. Однако, эту привилегию
предоставляют автоматически создателю подпрограммы в случае необходимости
(и удаляют, когда подпрограмма удалена). Кроме того, значение по умолчанию
<code>SQL SECURITY</code> для подпрограммы <code>DEFINER</code>, что
позволяет пользователям, у которых есть доступ к базе данных, с которой
подпрограмма связана, выполнить подпрограмму.</li>

<li>Если переменная <a href="server.htm#sysvar_automatic_sp_privileges">
<code>automatic_sp_privileges</code></a> равна 0, привилегии
<a href="security.html#priv_execute"><code>EXECUTE</code></a> и
<a href="security.html#priv_alter-routine"><code>ALTER ROUTINE</code></a>
автоматически не предоставляются и не удаляются.</li>
<li>Создатель подпрограммы это учетная запись, используемая, чтобы выполнить
<code>CREATE</code>.</p></li></ul>

<p>Сервер управляет таблицей <code>mysql.proc</code> в ответ на запросы,
которые создают, изменяют или удаляют сохраненные подпрограммы.
Не поддержано, чтобы сервер замечал ручные манипуляции с этой таблицей.</p>

<h3><a name="stored-routines-metadata"></a>21.2.3. Сохраненные метаданные</h3>
<p>Метаданные о сохраненных подпрограммах могут быть
получены следующим образом:</p>

<ul><li><p>Запросите таблицу<a href="inform.htm#routines-table"><code>
ROUTINES</code></a> базы данных <code>INFORMATION_SCHEMA</code>. См.
<a href="inform.htm#routines-table">раздел 22.19</a>.</li>

<li>Используйте <a href="sql.htm#show-create-procedure"><code>SHOW CREATE
PROCEDURE</code></a> и <a href="sql.htm#show-create-function"><code>SHOW
CREATE FUNCTION</code></a>, чтобы видеть определения. См.
<a href="sql.htm#show-create-procedure">раздел 14.7.5.9</a>.</li>

<li>Используйте <a href="sql.htm#show-procedure-status"><code>SHOW PROCEDURE
STATUS</code></a> и <a href="sql.htm#show-function-status"><code>SHOW
FUNCTION STATUS</code></a>, чтобы видеть характеристики. См.
<a href="sql.htm#show-procedure-status">раздел 14.7.5.28</a>.</p></li></ul>

<h3><a name="stored-routines-last-insert-id"></a>21.2.4.
Хранимые процедуры, функции, триггеры и LAST_INSERT_ID()</h3>
<p>В пределах тела сохраненной подпрограммы (процедуры или функции) или
триггера, значение <a href="funct.htm#function_last-insert-id"><code>
LAST_INSERT_ID()</code></a> изменяется тем же самым путем, что касается
запрсов, выполненных вне тела этих видов объектов (см.
<a href="funct.htm#information-functions">раздел 13.14</a>).
Эффект сохраненной подпрограммы или триггера на значение
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()</code></a>
зависит от вида подпрограммы:</p>

<ul><li><p>Если хранимая процедура выполняет запросы, которые изменяют
значение <a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()
</code></a>, измененное значение замечено запросами, которые следуют
за вызовом процедуры.</li>

<li>Для сохраненных функций и триггеров, которые изменяют значение,
восстановлено значение, когда функция или триггер завершаются, так что
измененное значение запросами, которые следуют за этим, не видно.
</p></li></ul>

<h2><a name="triggers"></a>21.3. Использование триггеров</h2>
<p>Триггер названный объект базы данных, который связан с таблицей
активируется, когда особое событие имеет место для таблицы. Некоторое
использование для триггеров должно выполнить проверки значений, которые будут
вставлены в таблицу или выполнят вычисления на
значениях, вовлеченных в обновление.</p>

<p>Триггер определен, чтобы активироваться, когда запрос вставляет,
обновляет или удаляет строки в связанной таблице. Эти операции события
триггера. Например, строки могут быть вставлены
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#load-data"><code>LOAD DATA</code></a>,
и триггер вставки активируется для каждой вставленной строки. Триггер может
быть установлен на активацию прежде или после события. Например, у Вас может
быть триггер, который активируется перед каждой строкой, которая вставлена в
таблицу или после каждой строки, которая обновлена.</p>

<p>Триггеры MySQL активируются только для изменений, произведенных в таблицах
запросами SQL. Они не активируются для изменений в представлениях или
изменений таблиц, сделанных API, которые не передают запроса SQL серверу
MySQL. Это означает, что триггеры не активированы изменениями в таблицах
<code>INFORMATION_SCHEMA</code> или <code>performance_schema</code>,
потому что эти таблицы фактически представления.</p>

<p>Следующие разделы описывают синтаксис для создания и удаления триггеров,
показывают некоторые примеры того, как использовать их, и указывают, как
получить метаданные триггеров.</p>

<h3><a name="trigger-syntax"></a>21.3.1. Синтаксис и примеры триггеров</h3>
<p>Чтобы создать или удалить триггер, используйте
<a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a> или
<a href="sql.htm#drop-trigger"><code>DROP TRIGGER</code></a>, описанные в
разделах <a href="sql.htm#create-trigger">14.1.17</a> и
<a href="sql.htm#drop-trigger">14.1.27</a>.</p>

<p>Вот простой пример, который связывает триггер с таблицей, чтобы
активироваться для вызова <a href="sql.htm#insert"><code>INSERT</code></a>.
Этот триггер действует как сумматор, суммируя значения, вставленные в один
из столбцов таблицы.
<pre>
mysql&gt; CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));
Query OK, 0 rows affected (0.03 sec)

mysql&gt; CREATE TRIGGER ins_sum BEFORE INSERT ON account
    -&gt;        FOR EACH ROW SET @sum = @sum + NEW.amount;
Query OK, 0 rows affected (0.06 sec)
</pre>

Запрос <a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a>
создает триггер <code>ins_sum</code>, связанный с таблицей
<code>account</code>. Это также включает пункты, которые определяют время
действия, инициирующее событие, и что сделать, когда триггер активируется:</p>

<ul><li><p>Ключевое слово <code>BEFORE</code> указывает время действия. В
этом случае триггер активируется прежде, чем каждая строка будет вставлена в
таблицу. Другое разрешенное ключевое слово здесь <code>AFTER</code>.</li>

<li>Ключевое слово <code>INSERT</code> указывает на событие, то есть, тип
работы, которая активирует триггер. В примере <a href="sql.htm#insert"><code>
INSERT</code></a> вызывает активацию. Вы можете также создать триггеры для
<a href="sql.htm#delete"><code>DELETE</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>.</li>

<li>Указание <code>FOR EACH ROW</code> определяет тело триггера, то есть,
запрос, чтобы выполнить каждый раз, когда триггер активируется, что
происходит однажды для каждой строки, затронутой инициирующим событием.
В примере тело простой <a href="sql.htm#set-variable"><code>SET</code></a>,
который накапливает в пользовательскую переменную значения, вставленные в
столбец <code>amount</code>. Запрос обращается к столбцу
как к <code>NEW.amount</code>.</p></li></ul>

<p>Чтобы использовать триггер, установите переменную сумматора в ноль,
выполните <a href="sql.htm#insert"><code>INSERT</code></a> и посмотрите
новое значение переменной:
<pre>
mysql&gt; SET @sum = 0;
mysql&gt; INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);
mysql&gt; SELECT @sum AS 'Total amount inserted';
+-----------------------+
| Total amount inserted |
+-----------------------+
| 1852.48               |
+-----------------------+
</pre>

В этом случае значение <code>@sum</code> после
<a href="sql.htm#insert"><code>INSERT</code></a>
<code>14.98 + 1937.50 - 100</code> или <code>1852.48</code>.</p>

<p>Чтобы разрушить триггер, используйте <a href="sql.htm#drop-trigger"><code>
DROP TRIGGER</code></a>. Вы должны определить имя схемы, если триггер не
находится в схеме по умолчанию:
<pre>
mysql&gt; DROP TRIGGER test.ins_sum;
</pre>
Если Вы удаляете таблицу, любые триггеры для таблицы также удалятся.</p>

<p>Имена триггеров существуют в пространстве имен схемы, означая, что у всех
триггеров должны быть уникальные имена в пределах схемы.
У триггеров в различных схемах может быть то же самое имя.</p>

<p>Возможно определить много триггеров для данной таблицы, у которых есть то
же самое событие и время действия. Например, Вы можете иметь два триггера
<code>BEFORE UPDATE</code> для таблицы. По умолчанию триггеры, у которых есть
то же самое событие и время действия, активируются в порядке, в котором они
создавались. Чтобы затронуть порядок, определите пункт после
<code>FOR EACH ROW</code>, который указывает <code>FOLLOWS</code> или
<code>PRECEDES</code> и название существующего триггера, у которого также
есть то же самое событие и время действия. С <code>PRECEDES</code>
новый триггер активируется после существующего.</p>

<p>Например, следующее определение задает другой триггер
<code>BEFORE INSERT</code> для таблицы <code>account</code>:
<pre>
mysql&gt; CREATE TRIGGER ins_transaction BEFORE INSERT ON account
    -&gt; FOR EACH ROW PRECEDES ins_sum
    -&gt; SET
    -&gt; @deposits = @deposits + IF(NEW.amount&gt;0,NEW.amount,0),
    -&gt; @withdrawals = @withdrawals + IF(NEW.amount&lt;0,-NEW.amount,0);
Query OK, 0 rows affected (0.02 sec)
</pre>

Этот триггер, <code>ins_transaction</code>, подобен <code>ins_sum</code>,
но накапливает deposits и withdrawals порознь. У этого есть предложение
<code>PRECEDES</code>, которое заставляет его активироваться прежде
<code>ins_sum</code>: без того пункта триггер активировался бы после
<code>ins_sum</code>, так как создан позднее <code>ins_sum</code>.</p>

<p>В пределах тела ключевые слова <code>OLD</code> и <code>NEW</code>
позволяют Вам доступ к столбцам в строках, затронутых триггером.
<code>OLD</code> и <code>NEW</code> расширения MySQL для триггеров,
они не являются чувствительными к регистру.</p>

<p>В триггере <code>INSERT</code> может использоваться только
<code>NEW.<em><code>col_name</code></em></code>: нет никакой старой строки. В
триггере <code>DELETE</code> нет никакой новой строки, поэтому может
использоваться только <code>OLD.<em><code>col_name</code></em></code>. В
триггере <code>UPDATE</code> можно применить
<code>OLD.<em><code>col_name</code></em></code>, чтобы обратиться к столбцам
строки прежде, чем они будут обновлены, и
<code>NEW.<em><code>col_name</code></em></code>, чтобы обратиться
после того, как это обновлено.</p>

<p>Столбец, названный <code>OLD</code>, только для чтения. Вы можете
обратиться к нему (если Вы имеете привилегию
<a href="sql.htm#select"><code>SELECT</code></a>), но не изменить.
Вы можете обратиться к столбцу, названному <code>NEW</code>, если Вы имеете
привилегию <a href="security.html#priv_select"><code>SELECT</code></a> для
него. В триггере <code>BEFORE</code> Вы можете также изменить его значение с
<code>SET NEW.<em><code>col_name</code></em> = <em><code>value</code></em>
</code>, если Вы имеете привилегию <a href="security.html#priv_update"><code>
UPDATE</code></a> для него. Это означает, что Вы можете использовать триггер,
чтобы изменить значения, которые будут вставляться в новую строку или
использоваться, чтобы обновить строку. Такой запрос <code>SET</code> не имеет
никакого эффекта в триггере <code>AFTER</code>, потому что изменение
строки уже произойдет.</p>

<p>В триггере <code>BEFORE</code> значение <code>NEW</code> для столбца
<code>AUTO_INCREMENT</code> 0, а не порядковый номер, который произведен
автоматически, когда новая строка фактически вставлена.</p>

<p>При использовании <a href="sql.htm#begin-end"><code>BEGIN ... END</code>
</a> Вы можете определить триггер, который выполняет много запросов. В
пределах блока <code>BEGIN</code> Вы также можете использовать другой
синтаксис, который разрешен в пределах сохраненных подпрограмм, например,
условные предложения и циклы. Однако, так же, как для сохраненных
подпрограмм, если Вы используете <a href="programs.htm#mysql"><span><strong>
mysql</strong></span></a>, чтобы определить триггер, который выполняет много
запросов, необходимо пересмотреть разделитель запроса так, чтобы Вы могли
использовать <code>;</code> в пределах определения триггера. Следующий пример
иллюстрирует эти тезисы. Это определяет триггер <code>UPDATE</code>, который
проверяет новое значение, которое будет использоваться для того, чтобы
обновить каждую строку, и изменяет значение, чтобы оно было в пределах
диапазона от 0 до 100. Это должен быть триггер <code>BEFORE</code>, потому
что значение должно быть проверено прежде, чем оно будет использоваться,
чтобы обновить строку:
<pre>
mysql&gt; delimiter //
mysql&gt; CREATE TRIGGER upd_check BEFORE UPDATE ON account FOR EACH ROW
    -&gt; BEGIN
    -&gt;   IF NEW.amount &lt; 0 THEN
    -&gt;      SET NEW.amount = 0;
    -&gt;   ELSEIF NEW.amount &gt; 100 THEN
    -&gt;      SET NEW.amount = 100;
    -&gt;   END IF;
    -&gt; END;//
mysql&gt; delimiter ;
</pre>

Может быть легче определить хранимую процедуру отдельно и затем вызвать
ее из триггера, используя простой <a href="sql.htm#call"><code>CALL</code>
</a>. Это также выгодно, если Вы хотите выполнить тот же самый код
из нескольких триггеров.</p>

<p>Есть ограничения на то, что может появиться в запросах, которые
триггер выполняет когда активирован:</p>
<ul><li><p>Триггер не может использовать
<a href="sql.htm#call"><code>CALL</code></a>, чтобы вызвать хранимые
процедуры, которые возвращают данные клиенту или используют динамический SQL.
Хранимым процедурам разрешают возвратить данные триггеру через параметры
<code>OUT</code> или <code>INOUT</code>.</li>

<li>Триггер не может использовать запросы, которые явно или неявно начинают
или заканчивают транзакцию, например, <a href="sql.htm#commit"><code>START
TRANSACTION</code></a>, <a href="sql.htm#commit"><code>COMMIT</code></a>,
or <a href="sql.htm#commit"><code>ROLLBACK</code></a>.
<a href="sql.htm#commit"><code>ROLLBACK to SAVEPOINT</code></a>
разрешен, потому что это не заканчивает транзакцию.</p></li></ul>

<p>MySQL обрабатывает ошибки в триггере следующим образом:</p>
<ul><li><p>Если триггер <code>BEFORE</code>
терпит неудачу, работа на соответствующей строке не выполнена.</li>

<li>Триггер <code>BEFORE</code> активирован
<span><em>попыткой</em></span> вставить или изменить строку, независимо от
того, преуспевает ли попытка впоследствии.</li>

<li>Триггер <code>AFTER</code> выполнен только если любой триггер
<code>BEFORE</code> и обработка строки прошли нормально.</li>
<li>Ошибка во время любого триггера <code>BEFORE</code> или
<code>AFTER</code> приведет к отказу всего запроса.</li>

<li>Для транзакционных таблиц отказ запроса должен вызвать отмену
всех изменений, выполненных запросом. Отказ триггера заставляет запрос
терпеть неудачу, таким образом, отказ также вызывает отмену. Для
нетранзакционных таблиц такая отмена не может быть сделана, так что, хотя
запрос терпит неудачу, любые изменения, выполненные до
ошибки, остаются в силе.</p></li></ul>

<p>Триггеры могут содержать прямые ссылки на таблицы по имени, такие как
триггер <code>testref</code>, показанный в этом примере:
<pre>
CREATE TABLE test1(a1 INT);
CREATE TABLE test2(a2 INT);
CREATE TABLE test3(a3 INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
CREATE TABLE test4(a4 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                   b4 INT DEFAULT 0);
delimiter |
CREATE TRIGGER testref BEFORE INSERT ON test1 FOR EACH ROW
BEGIN
   INSERT INTO test2 SET a2 = NEW.a1;
   DELETE FROM test3 WHERE a3 = NEW.a1;
   UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1;
END;
|
delimiter ;
INSERT INTO test3 (a3) VALUES
   (NULL), (NULL), (NULL), (NULL), (NULL),
   (NULL), (NULL), (NULL), (NULL), (NULL);
INSERT INTO test4 (a4) VALUES
   (0), (0), (0), (0), (0), (0), (0), (0), (0), (0);
</pre>

Предположите, что Вы вставляете следующие значения в таблицу
<code>test1</code> как показано здесь:
<pre>
mysql&gt; INSERT INTO test1 VALUES
    -&gt;        (1), (3), (1), (7), (1), (8), (4), (4);
Query OK, 8 rows affected (0.01 sec)
Records: 8  Duplicates: 0  Warnings: 0
</pre>

В результате эти четыре таблицы содержат следующие данные:
<pre>
mysql&gt; SELECT * FROM test1;
+----+
| a1 |
+----+
| 1  |
| 3  |
| 1  |
| 7  |
| 1  |
| 8  |
| 4  |
| 4  |
+----+
8 rows in set (0.00 sec)

mysql&gt; SELECT * FROM test2;
+----+
| a2 |
+----+
| 1  |
| 3  |
| 1  |
| 7  |
| 1  |
| 8  |
| 4  |
| 4  |
+----+
8 rows in set (0.00 sec)

mysql&gt; SELECT * FROM test3;
+----+
| a3 |
+----+
|  2 |
|  5 |
|  6 |
|  9 |
| 10 |
+----+
5 rows in set (0.00 sec)

mysql&gt; SELECT * FROM test4;
+----+----+
| a4 | b4 |
+----+----+
|  1 | 3  |
|  2 | 0  |
|  3 | 1  |
|  4 | 2  |
|  5 | 0  |
|  6 | 0  |
|  7 | 1  |
|  8 | 1  |
|  9 | 0  |
| 10 | 0  |
+----+----+
10 rows in set (0.00 sec)
</pre>

<h3><a name="trigger-metadata"></a>21.3.2. Метаданные триггеров</h3>
<p>Метаданные триггеров могут быть получены следующим образом:</p>
<ul><li><p>Запросите таблицу <a href="inform.htm#triggers-table"><code>
TRIGGERS</code></a> базы данных <code>INFORMATION_SCHEMA</code>. См.
<a href="inform.htm#triggers-table">раздел 22.27</a>.</li>

<li>Используйте <a href="sql.htm#show-create-trigger"><code>SHOW CREATE
TRIGGER</code></a>. См. <a href="sql.htm#show-create-trigger">раздел
14.7.5.11</a>.</li>
<li>Используйте <a href="sql.htm#show-triggers"><code>SHOW TRIGGERS</code>
</a>. См. <a href="sql.htm#show-triggers">раздел 14.7.5.38</a>.</p></li></ul>

<h2><a name="event-scheduler"></a>21.4. Использование планировщика событий
</h2>
<p><span>MySQL Event Scheduler</span> управляет планированием и выполнением
событий, то есть, задач, которые работают согласно графику. Следующее
обсуждение покрывает планировщик событий.</p>

<p>Сохраненные подпрограммы требуют таблицы <code>event</code> в базе данных
<code>mysql</code>. Эта таблица составлена во время процессов установки MySQL
8.0. Если Вы обновляетесь до MySQL 8.0 от более ранней версии, убедитесь, что
обновили свои таблицы, чтобы удостовериться, что таблица <code>event</code>
существует. См. <a href="programs.htm#mysql-upgrade">раздел 5.4.5</a>.</p>

<h3><a name="events-overview"></a>21.4.1. Краткий обзор планировщика событий
</h3>
<p>События MySQL это задачи, которые работают согласно графику.
Поэтому мы иногда именуем их <span><em>намеченные</em></span> события.
Когда Вы создаете событие, Вы создаете названный объект базы данных,
содержащий один или более запросов SQL, которые будут выполнены в одном или
более равных интервалах, начинаясь и заканчиваясь в определенную дату и
время. Концептуально это подобно идее Unix <code>crontab</code>
(также известный как <span>cron job</span>) или
Windows Task Scheduler.</p>

<p>Запланированные задачи этого типа также иногда известны как
<span>временные триггеры</span>, подразумевая, что они объекты,
которые вызваны течением времени. В то время как это чрезвычайно правильно,
мы предпочитаем использовать термин <span><em>события</em></span>, чтобы
избежать беспорядка с триггерами.  События не должны быть перепутаны с
ними. Принимая во внимание, что триггер это объект базы данных, запрос
которого выполнен в ответ на определенный тип ситуации, которая происходит в
данной таблице, запланированное событие это объект, запрос которого выполнен
в ответ на приход требуемого интервала времени.</p>

<p>В то время как нет никакого предоставления в стандарте SQL для
планирования событий, в других системах базы данных есть прецеденты, и Вы
можете заметить некоторые общие черты между этим выполнением и
найденным в сервере MySQL.</p>

<p>У событий MySQL есть следующие основные функции и свойства:</p>
<ul><li><p>В MySQL событие уникально идентифицировано его именем и схемой,
на которую назначено.</li>

<li>Событие выполняет определенное действие согласно графику. Это действие
состоит из запроса SQL, который может быть составным запросом в блоке
<a href="sql.htm#begin-end"><code>BEGIN ... END</code></a> при желании
(см. <a href="sql.htm#sql-syntax-compound-statements">раздел 14.6</a>).
Синхронизация события может быть <span>одноразовой</span> или
<span>текущей</span>. Одноразовое событие выполняется только один раз.
Повторяющееся событие повторяет свое действие в равном интервале, можно
назначить определенный день запуска и время, день конца и время, оба варианта
сразу или ни одного. По умолчанию график события начинается, как только оно
создается, и продолжается неопределенно долго, пока оно не отключено
или не удалено.</p>

<p>Если повторяющийся событие не заканчивается в пределах его интервала
планирования, результат может быть несколькими копиями события,
выполняющимися одновременно. Если это нежелательно, Вы должны установить
механизм, чтобы предотвратить одновременные выполнения. Например, Вы могли бы
использовать функцию <a href="funct.htm#function_get-lock"><code>GET_LOCK()
</code></a>, строковую или табличную блокировку.</li>

<li>Пользователи могут создать, изменить и удалить намеченные события,
используя запросы SQL, предназначенные в этих целях. Синтаксически
недопустимые запросы создания и модификации событий терпят неудачу с
соответствующим сообщением об ошибке. <span><em>Пользователь может включать
запросы в действие события, которые требуют привилегий, которые фактически не
имеет пользователь</em></span>. Запрос создания или модификации событий
преуспевает, но действие терпит неудачу. См.
<a href="#events-privileges">раздел 21.4.6</a>.</li>

<li>Многие из свойств события могут быть установлены или изменены через
использование запроса SQL. Эти свойства включают имя, синхронизацию,
постоянство (то есть, сохранено ли это после истечения его графика),
состояние (включен или отключен), действие, которое будет выполнено, и схема,
на которую это назначено. См. <a href="sql.htm#alter-event">раздел 14.1.2
</a>.</p>

<p>По умолчанию создатель события пользователь, который создал событие, если
событие не был изменено, тогда создатель пользователь, который выполнил
последний запрос <a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>,
затрагивающий это событие. Событие может быть изменено любым пользователем,
имеющим привилегию <a href="security.html#priv_event"><code>EVENT</code></a>
на базе данных, для которой определено событие. См.
<a href="#events-privileges">раздел 21.4.6</a>.</li>

<li>Запрос действия может включать большинство запросов SQL, разрешенных в
пределах сохраненных подпрограмм. Для ограничений см.
<a href="restr.htm#stored-program-restrictions">раздел C.1</a>.</p></li></ul>

<h3><a name="events-configuration"></a>21.4.2.
Конфигурация планировщика событий</h3>
<p>События запущены <span>потоком планировщика</span>, когда мы обращаемся к
планировщику событий, мы фактически обращаемся к этому потоку. Работая, поток
планировщика событий и его текущее состояние могут быть замечены
пользователями, имеющими привилегию <a href="security.html#priv_process">
<code>PROCESS</code></a> в выводе <a href="sql.htm#show-processlist"><code>
SHOW PROCESSLIST</code></a>, как показано далее.</p>

<p><a name="events-event-scheduler-option"></a>Глобальная переменная
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
определяет, включен ли планировщик событий. У этого есть одно из 3 значений,
которые затрагивают событие, как описано здесь:</p>

<ul><li><p><code>OFF</code>: Планировщик событий остановлен. Поток
планировщика событий не работает, не показан в выводе
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a> и
никакие запланированные события не запущены. <code>OFF</code> значение по
умолчанию для <a href="server.htm#sysvar_event_scheduler"><code>
event_scheduler</code></a>.</p>

<p>Когда планировщик событий остановлен
(<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
<code>OFF</code>), это может быть запущено, устанавливая значение
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
в <code>ON</code>.</li>

<li><code>ON</code>: Планировщик событий запущен, поток планировщика событий
выполняется и запускает все запланированные события. Когда планировщик
событий <code>ON</code>, поток планировщика событий перечислен в выводе
<a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST</code></a>
как процесс демона, и его статус представлен как показано здесь:
<pre>
mysql&gt; SHOW PROCESSLIST\G
*************************** 1. row ***************************
 Id: 1
   User: root
   Host: localhost
 db: NULL
Command: Query
   Time: 0
  State: NULL
   Info: show processlist
*************************** 2. row ***************************
 Id: 2
   User: event_scheduler
   Host: localhost
 db: NULL
Command: Daemon
   Time: 3
  State: Waiting for next activation
   Info: NULL
2 rows in set (0.00 sec)
</pre>

Планирование событий может быть остановлено, устанавливая значение
<a href="server.htm#sysvar_event_scheduler">
<code>event_scheduler</code></a> в <code>OFF</code>.</li>

<li><code>DISABLED</code>: Это значение представляет не влияющий на
эксплуатацию планировщик событий. Когда планировщик событий
<code>DISABLED</code>, поток планировщика событий не работает (и не
появляется в выводе <a href="sql.htm#show-processlist"><code>SHOW PROCESSLIST
</code></a>). Кроме того, его статус не может быть изменен
во время выполнения.</p></li></ul>

<p>Если состояние планировщика событий не было установлено в
<code>DISABLED</code>, <a href="server.htm#sysvar_event_scheduler"><code>
event_scheduler</code></a> может быть переключена между
<code>ON</code> и <code>OFF</code> (с использованием
<a href="sql.htm#set-variable"><code>SET</code></a>). Также возможно
использовать <code>0</code> для <code>OFF</code> и <code>1</code> для
<code>ON</code>, устанавливая эту переменную. Таким образом, любой из
следующих 4 запросов может использоваться в клиенте
<a href="programs.htm#mysql"><span><strong>mysql</strong></span></a>,
чтобы включить планировщик событий:
<pre>
SET GLOBAL event_scheduler = ON;
SET @@global.event_scheduler = ON;
SET GLOBAL event_scheduler = 1;
SET @@global.event_scheduler = 1;
</pre>

Точно так же любой из этих 4 запросов может использоваться, чтобы
выключить планировщик событий:
<pre>
SET GLOBAL event_scheduler = OFF;
SET @@global.event_scheduler = OFF;
SET GLOBAL event_scheduler = 0;
SET @@global.event_scheduler = 0;
</pre>

Хотя <code>ON</code> и <code>OFF</code> имеют числовые эквиваленты, значение,
выведенное на экран для
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
через <a href="sql.htm#select"><code>SELECT</code></a> или
<a href="sql.htm#show-variables"><code>SHOW VARIABLES</code></a> всегда
<code>OFF</code>, <code>ON</code> или <code>DISABLED</code>.
<span><em><code>DISABLED</code> не имеет никакого числового эквивалента</em>
</span>. Поэтому <code>ON</code> и <code>OFF</code> обычно предпочитаются
<code>1</code> и <code>0</code>, устанавливая эту переменную.</p>

<p>Заметьте, что попытка установить
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
не определяя это как глобальную переменную вызывает ошибку:
<pre>
mysql&lt; SET @@event_scheduler = OFF;
<span>ERROR 1229 (HY000): Variable 'event_scheduler' is a GLOBAL
variable and should be set with SET GLOBAL</span>
</pre>

<p>Возможно установить планировщик событий в <code>DISABLED</code> только при
запуске сервера. Если <a href="server.htm#sysvar_event_scheduler"><code>
event_scheduler</code></a> <code>ON</code> или <code>OFF</code>,
Вы не можете установить это в <code>DISABLED</code> во время выполнения.
Кроме того, если планировщик событий установлен в <code>DISABLED</code>
при запуске Вы не можете изменить значение
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
во время выполнения.</p>

<p>Чтобы отключить планировщик событий, используйте один из
следующих двух методов:</p>
<ul><li><p>Как параметр командной строки, запуская сервер:
<pre>
--event-scheduler=DISABLED
</pre></li>

<li>В конфигурационном файле сервера (<code>my.cnf</code>,
или <code>my.ini</code> в Windows) включите строку, где она будет
считана сервером (например, в раздел <code>[mysqld]</code>):
<pre>
event_scheduler=DISABLED
</pre></li></ul>

<p>Чтобы включить планировщик событий, перезапустите сервер без параметра
командной строки <a href="server.htm#option_mysqld_event-scheduler"><code>
--event-scheduler=DISABLED</code></a> или после удаления (или комментирования)
строки в конфигурационном файле сервера, содержащей
<a href="server.htm#option_mysqld_event-scheduler"><code>
event-scheduler=DISABLED</code></a>. Альтернативно, Вы можете использовать
<code>ON</code> (или <code>1</code>) или <code>OFF</code> (или <code>0
</code>) вместо <code>DISABLED</code>, запуская сервер.</p>

<p>Вы можете сделать запрос манипуляции событий, когда
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
<code>DISABLED</code>. Никакие предупреждения или ошибки не произведены в
таких случаях (при условии, что запрос самостоятельно допустим). Однако,
запланированные события не могут выполниться, пока эта переменная не
установлена в <code>ON</code> (или <code>1</code>). Как только это было
сделано, поток планировщика событий запускает все события, условия
планирования которых удовлетворены.</p>

<p>Запуск сервера MySQL с опцией
<a href="server.htm#option_mysqld_skip-grant-tables"><code>
--skip-grant-tables</code></a> установит
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>
в <code>DISABLED</code>, переопределяя любое другое значение в командной
строке или в файле <code>my.cnf</code> (или <code>my.ini</code>).</p>
<p>Для запросов SQL, используемых, чтобы создать, изменить и удалить
события см. <a href="#events-syntax">раздел 21.4.3</a>.</p>

<p>MySQL обеспечивает таблицу <a href="inform.htm#events-table"><code>EVENTS
</code></a> в базе данных <code>INFORMATION_SCHEMA</code>. Эта таблица
может быть запрошена, чтобы получить информацию о запланированных событиях,
которые были определены на сервере. См. разделы
<a href="#events-metadata">21.4.4</a> и
<a href="inform.htm#events-table">22.7</a>.</p>

<h3><a name="events-syntax"></a>21.4.3. Синтаксис событий</h3>
<p>MySQL обеспечивает несколько запросов SQL для того, чтобы они
работали с запланированными событиями:</p>

<ul><li><p>Новые события определены, используя
<a href="sql.htm#create-event"><code>CREATE EVENT</code></a>. См.
<a href="sql.htm#create-event">раздел 14.1.10</a>.</li>

<li>Определение существующего события может быть изменено посредством
<a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>. См.
<a href="sql.htm#alter-event">раздел 14.1.2</a>.</li>

<li>Когда запланированное событие больше не требуется, оно может быть удалено
с сервера создателем события с помощью
<a href="sql.htm#drop-event"><code>DROP EVENT</code></a>. См.
<a href="sql.htm#drop-event">раздел 14.1.20</a>.
Сохраняется ли событие после конца его графика, также зависит от его
предложения <code>ON COMPLETION</code>, если оно есть. См.
<a href="sql.htm#create-event">раздел 14.1.10</a>.</p>

<p>Событие может быть удалено любым пользователем, имеющим привилегию
<a href="security.html#priv_event"><code>EVENT</code></a> для базы данных, на
которой определен событие. См.
<a href="#events-privileges">раздел 21.4.6</a>.</p></li></ul>

<h3><a name="events-metadata"></a>21.4.4. Метаданные событий</h3>
<p>Метаданные о событиях могут быть получены следующим образом:</p>

<ul><li><p>Запросите таблицу <code>event</code>
базы данных <code>mysql</code>.</li>

<li>Запросите таблицу <a href="inform.htm#events-table"><code>EVENTS</code>
</a> базы данных <code>INFORMATION_SCHEMA</code>. См.
<a href="inform.htm#events-table">раздел 22.7</a>.</li>

<li>Используйте <a href="sql.htm#show-create-event"><code>SHOW CREATE EVENT
</code></a>. См. <a href="sql.htm#show-create-event">раздел 14.7.5.7</a>.
</li>
<li>Используйте <a href="sql.htm#show-events"><code>SHOW EVENTS</code></a>.
См. <a href="sql.htm#show-events">раздел 14.7.5.18</a>.</p></li></ul>

<p><span><strong>Представление времени планировщика событий</strong></span>
<p>У каждого сеанса в MySQL есть часовой пояс сеанса (STZ). Это сеансовая
переменная <a href="server.htm#sysvar_time_zone"><code>time_zone</code></a>,
которая инициализирована от глобального значения сервера
<a href="server.htm#sysvar_time_zone"><code>time_zone</code></a>, когда сеанс
начинается, но может быть изменена во время сеанса.</p>

<p>Часовой пояс сеанса, который актуален, когда выполняется
<a href="sql.htm#create-event"><code>CREATE EVENT</code></a> или
<a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>, используется,
чтобы интерпретировать времена, определенные при создании события. Это
становится часовым поясом событий (ETZ), то есть, часовой пояс, который
используется для планирования событий и является в действительности
часовым поясом, в котором выполняется событие.</p>

<p>Для представления информации о событии в таблице <code>mysql.event</code>
времена <code>execute_at</code>, <code>starts</code> и <code>ends</code>
преобразованы в UTC и сохранены наряду с часовым поясом события. Это
позволяет выполнению событий продолжиться как определено независимо от любых
последующих изменений часового пояса сервера или эффектов летнего времени.
Время <code>last_executed</code> также сохранено в UTC.</p>

<p>Если Вы выбираете информацию из <code>mysql.event</code>, времена
получены как значения UTC. Эти времена могут также быть получены, выбирая из
<a href="inform.htm#events-table"><code>INFORMATION_SCHEMA.EVENTS</code></a>
или через <a href="sql.htm#show-events"><code>SHOW EVENTS</code></a>, но о
них сообщают как о значениях ETZ. Другие времена, доступные из этих
источников, указывают, когда событие создавалоси или последний раз
изменилось, они выведены на экран как значения STZ. Следующая таблица
суммирует представление времен событий.</p>

<table border="1">
<thead><tr><th scope="col">Значение</th><th scope="col">
<code>mysql.event</code></th>
<th scope="col"><a href="inform.htm#events-table"><code>
INFORMATION_SCHEMA.EVENTS</code></a></th>
<th scope="col"><a href="sql.htm#show-events"><code>SHOW EVENTS
</code></a></th></tr></thead>
<tbody><tr><td scope="row">Execute at</td><td>UTC</td><td>ETZ</td><td>ETZ
</td></tr>
<tr><td scope="row">Starts</td><td>UTC</td><td>ETZ</td><td>ETZ</td></tr>
<tr><td scope="row">Ends</td><td>UTC</td><td>ETZ</td><td>ETZ</td></tr>
<tr><td scope="row">Last executed</td><td>UTC</td><td>ETZ</td><td>n/a</td>
</tr>
<tr><td scope="row">Created</td><td>STZ</td><td>STZ</td><td>n/a</td></tr>
<tr><td scope="row">Last altered</td><td>STZ</td><td>STZ</td><td>n/a
</td></tr></tbody></table>

<h3><a name="events-status-info"></a>21.4.5. Состояние планировщика событий
</h3>
<p>Планировщик событий пишет информацию о выполнении события, которое
заканчивается с ошибкой или предупреждением в журнал ошибок сервера MySQL.
См. <a href="#events-privileges">раздел 21.4.6</a>.</p>

<p>Чтобы получить информацию о статусе планировщика событий для отладки и
поиска неисправностей, выполните <a href="programs.htm#mysqladmin"><span>
<strong>mysqladmin debug</strong></span></a> (см.
<a href="programs.htm#mysqladmin">раздел 5.5.2</a>). После выполнения этой
команды журнал ошибок сервера содержит вывод, касающийся планировщика
событий, подобный тому, что показывают здесь:
<pre>
Events status:
LLA = Last Locked At  LUA = Last Unlocked At
WOC = Waiting On Condition  DL = Data Locked

Event scheduler status:
State: INITIALIZED
Thread id  : 0
LLA: init_scheduler:313
LUA: init_scheduler:318
WOC: NO
Workers: 0
Executed   : 0
Data locked: NO

Event queue status:
Element count   : 1
Data locked : NO
Attempting lock : NO
LLA   : init_queue:148
LUA   : init_queue:168
WOC   : NO
Next activation : 0000-00-00 00:00:00
</pre>

В запросах, которые происходят как часть событий, запущенных планировщиком
событий, сообщения диагностики (не только ошибки, а также и предупреждения)
написаны в журнал ошибок и в Windows в журнал событий приложения. Для часто
запускаемых событий это может привести ко многим зарегистрированным
сообщениям. Например, для запроса <code>SELECT ... INTO
<em><code>var_list</code></em></code>, если запрос не возвращает строк,
предупреждения с кодом ошибки 1329, происходят (<code>No data</code>),
и переменные значения остаются неизменными. Если запрос возвращает много
строк, происходит ошибка 1172 (<code>Result consisted of more than one row
</code>). Для любого условия Вы можете избежать регистрации предупреждений,
объявляя обработчик условия, см.
<a href="sql.htm#declare-handler">раздел 14.6.7.2</a>. Для запросов, которые
могут получить много строк, другая стратегия состоит в том, чтобы
использовать <code>LIMIT 1</code>, чтобы ограничить набор
результатов единственной строкой.</p>

<h3><a name="events-privileges"></a>21.4.6.
Привилегии планировщика и событий MySQL</h3>
<p>Чтобы включить или отключить выполнение запланированных событий,
необходимо установить значение глобальной переменной
<a href="server.htm#sysvar_event_scheduler"><code>event_scheduler</code></a>.
Это требует привилегии <a href="security.html#priv_super"><code>SUPER</code>
</a>.</p>

<p>Привилегия <a href="security.html#priv_event"><code>EVENT</code></a>
управляет созданием, модификацией и удалением событий. Эта привилегия может
дароваться, используя <a href="sql.htm#grant"><code>GRANT</code></a>.
Например, этот запрос <a href="sql.htm#grant"><code>GRANT</code></a>
предоставляет привилегию <a href="security.html#priv_event"><code>EVENT
</code></a> для схемы <code>myschema</code> пользователю
<code>jon@ghidora</code>:
<pre>
GRANT EVENT ON myschema.* TO jon@ghidora;
</pre>
Мы предполагаем, что эта учетная запись пользователя уже существует.
</p>

<p>Чтобы предоставить тому же самому пользователю привилегию
<a href="security.html#priv_event"><code>EVENT</code></a>
на всех схемах, используйте следующее запрос:
<pre>
GRANT EVENT ON *.* TO jon@ghidora;
</pre>

Привилегия <a href="security.html#priv_event"><code>EVENT</code></a>
имеет глобальный контекст или на уровне схемы. Поэтому попытка предоставить
это на единственной таблице приводит к ошибке как показано:
<pre>
mysql&gt; GRANT EVENT ON myschema.mytable TO jon@ghidora;
<span>ERROR 1144 (42000): Illegal GRANT/REVOKE command; please
consult the manual to see which privileges can be used</span>
</pre>

Важно понять, что событие запущено с привилегиями его создателя, и что оно не
может выполнить действия, для которых у его автора нет необходимых
привилегий. Например, предположите, что <code>jon@ghidora</code> имеет
привилегию <a href="security.html#priv_event"><code>EVENT</code></a> для
<code>myschema</code>. Предположите также, что этот пользователь имеет
привилегию <a href="security.html#priv_select"><code>SELECT</code></a> для
<code>myschema</code>, но никаких других привилегий для этой схемы. Для
<code>jon@ghidora</code> возможно создать новое событие:
<pre>
CREATE EVENT e_store_ts ON SCHEDULE EVERY 10 SECOND DO
       INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP());
</pre>

Пользователь ждет в течение приблизительно одной минуты, и затем выполняет
запрос <code>SELECT * FROM mytable;</code>, ожидая увидеть несколько новых
строк в таблице. Вместо этого таблица пуста. Так как пользователь не имеет
привилегии <a href="security.html#priv_insert"><code>INSERT</code></a>
для рассматриваемой таблицы, событие не имеет никакого эффекта.</p>

<p>Если Вы просматриваете журнал ошибок MySQL
(<code><em><code>hostname</code></em>.err</code>),
Вы можете видеть, что событие выполняется, но действие, которое оно
пытается выполнить, терпит неудачу:
<pre>
2013-09-24T12:41:31.261992Z 25 [ERROR] Event Scheduler:
[jon@ghidora][cookbook.e_store_ts] INSERT command denied to user
'jon'@'ghidora' for table 'mytable'
2013-09-24T12:41:31.262022Z 25 [Note] Event Scheduler:
[jon@ghidora].[myschema.e_store_ts] event execution failed.
2013-09-24T12:41:41.271796Z 26 [ERROR] Event Scheduler:
[jon@ghidora][cookbook.e_store_ts] INSERT command denied to user
'jon'@'ghidora' for table 'mytable'
2013-09-24T12:41:41.272761Z 26 [Note] Event Scheduler:
[jon@ghidora].[myschema.e_store_ts] event execution failed.
</pre>

Так как у этого пользователя очень вероятно нет доступа к журналу ошибок,
возможно проверить, допустим ли запрос, выполняя это непосредственно:
<pre>
mysql&gt; INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP());
<span>ERROR 1142 (42000): INSERT command denied to user
'jon'@'ghidora' for table 'mytable'</span>
</pre>

<p>Просмотр таблицы <a href="inform.htm#events-table"><code>
INFORMATION_SCHEMA.EVENTS</code></a> показывает, что <code>e_store_ts</code>
существует и включен, но столбец <code>LAST_EXECUTED</code> <code>NULL</code>:
<pre>
mysql&gt; SELECT * FROM INFORMATION_SCHEMA.EVENTS
     &gt;          WHERE EVENT_NAME='e_store_ts' AND
     &gt;          EVENT_SCHEMA='myschema'\G
*************************** 1. row ***************************
   EVENT_CATALOG: NULL
EVENT_SCHEMA: myschema
EVENT_NAME: e_store_ts
 DEFINER: jon@ghidora
EVENT_BODY: SQL
EVENT_DEFINITION: INSERT INTO myschema.mytable VALUES (UNIX_TIMESTAMP())
EVENT_TYPE: RECURRING
EXECUTE_AT: NULL
  INTERVAL_VALUE: 5
  INTERVAL_FIELD: SECOND
SQL_MODE: NULL
STARTS: 0000-00-00 00:00:00
  ENDS: 0000-00-00 00:00:00
STATUS: ENABLED
   ON_COMPLETION: NOT PRESERVE
 CREATED: 2006-02-09 22:36:06
LAST_ALTERED: 2006-02-09 22:36:06
   LAST_EXECUTED: NULL
   EVENT_COMMENT:
1 row in set (0.00 sec)
</pre>

Отменить привилегию <a href="security.html#priv_event"><code>EVENT</code></a>
можно через <a href="sql.htm#revoke"><code>REVOKE</code></a>. В этом примере
привилегия <a href="security.html#priv_event"><code>EVENT</code></a> на схеме
<code>myschema</code> удалена из учетной записи пользователя
<code>jon@ghidora</code>:
<pre>
REVOKE EVENT ON myschema.* FROM jon@ghidora;
</pre>

<p>Отмена привилегии <a href="security.html#priv_event"><code>EVENT</code>
</a> не удаляет или отключает события, которые, возможно, были
созданы этим пользователем.</p>

<p>Событие не мигрирует или удаляется в результате переименования или
удаления пользователя, который его создал.</p>
<p>Предположите что пользователю <code>jon@ghidora</code> были даны
привилегии <a href="security.html#priv_event"><code>EVENT</code></a> и
<a href="security.html#priv_insert"><code>INSERT</code></a> на схеме
<code>myschema</code>.  Этот пользователь тогда создает следующий событие:
<pre>
CREATE EVENT e_insert ON SCHEDULE EVERY 7 SECOND DO
       INSERT INTO myschema.mytable;
</pre>

После того, как это событие было создано, <code>root</code> отменяет
привилегию <a href="security.html#priv_event"><code>EVENT</code></a> для
<code>jon@ghidora</code>. Однако, <code>e_insert</code>
продолжает выполняться, вставляя новую строку в <code>mytable</code>
каждые семь секунд. То же самое было бы истиной, если
<code>root</code> сделал любой из этих запросов:</p>
<ul><li><p><code>DROP USER jon@ghidora;</code></li>
<li><code>RENAME USER jon@ghidora TO someotherguy@ghidora;</code></li></ul>

<p>Вы можете проверить, что это истина, исследуя таблицу
<code>mysql.event</code> или <a href="inform.htm#events-table"><code>
INFORMATION_SCHEMA.EVENTS</code></a> (см.
<a href="inform.htm#events-table">раздел 22.7</a>) до и после выполнения
<a href="sql.htm#drop-user"><code>DROP USER</code></a> или
<a href="sql.htm#rename-user"><code>RENAME USER</code></a>.

<p>Определения событий сохранены в таблице <code>mysql.event</code>.
Чтобы удалить событие, созданное другой учетной записью пользователя, MySQL
<code>root</code> (или другой пользователь с необходимыми привилегиями) может
удалить строки из этой таблицы. Например, чтобы удалить событие
<code>e_insert</code> <code>root</code> может использовать следующий запрос:
<pre>
DELETE FROM mysql.event WHERE db = 'myschema' AND
       definer = 'jon@ghidora' AND name = 'e_insert';
</pre>

Очень важно соответствовать имени события, имени схемы базы данных и учетной
записи пользователя, удаляя строки из <code>mysql.event</code>. Тот же самый
пользователь может создать различные события с тем же самым
именем в различных схемах.</p>

<p>Пользовательские привилегии <a href="security.html#priv_event"><code>EVENT
</code></a> сохранены в столбцах <code>Event_priv</code> таблиц
<code>mysql.user</code> и <code>mysql.db</code>. В обоих случаях этот столбец
содержит одно из значений '<code>Y</code>' или '<code>N</code>' (по умолчанию
'<code>N</code>'). <code>mysql.user.Event_priv</code> установлен в
'<code>Y</code>' для данного пользователя, только если у этого пользователя
есть глобальная привилегия <a href="security.html#priv_event"><code>EVENT
</code></a> (то есть, если привилегия даровалась, используя
<code>GRANT EVENT ON *.*</code>). Для привилегии
<a href="security.html#priv_event"><code>EVENT</code></a> на уровне схемы
<a href="sql.htm#grant"><code>GRANT</code></a> создает строку в
<code>mysql.db</code> и устанавливает столбец <code>Db</code> в имя схемы,
столбец <code>User</code> к имени пользователя, а столбец
<code>Event_priv</code> в '<code>Y</code>'. Никогда не должно быть никакой
потребности управлять этими таблицами непосредственно, запросы
<a href="sql.htm#grant"><code>GRANT EVENT</code></a> и <code>REVOKE EVENT
</code> выполняют необходимые операции на них.</p>

<p>Пять переменных состояния предоставляют счетчики в связанных с событиями
операциях (но <span><em>НЕ</em></span> запросов, выполненных событиями, см.
<a href="restr.htm#stored-program-restrictions">раздел C.1</a>). Это:</p>

<ul><li><p><code>Com_create_event</code>: Число
<a href="sql.htm#create-event"><code>CREATE EVENT</code></a>, выполненных
начиная с последнего перезапуска сервера.</li>

<li><code>Com_alter_event</code>: Число
<a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>, выполненных
начиная с последнего перезапуска сервера.</li></li>

<li><code>Com_drop_event</code>: Число
<a href="sql.htm#drop-event"><code>DROP EVENT</code></a>, выполненных
начиная с последнего перезапуска сервера.</li>

<li><code>Com_show_create_event</code>: Число
<a href="sql.htm#show-create-event"><code>SHOW CREATE EVENT</code></a>,
выполненных начиная с последнего перезапуска сервера.</li></li>

<li><code>Com_show_events</code>: Число
<a href="sql.htm#show-events"><code>SHOW EVENTS</code></a>, выполненных
начиная с последнего перезапуска сервера.</li></ul>

<p>Вы можете рассмотреть текущие значения для всех них, выполняя запрос
<code>SHOW STATUS LIKE '%event%';</code>.</p>

<h2><a name="views"></a>21.5. Использование представлений</h2>
<p>MySQL поддерживает представления, включая обновляемые. Представления
сохраняют запросы, которые когда вызваны производят набор результатов.
Представление действует как виртуальная таблица.</p>
<p>Следующее обсуждение описывает синтаксис для создания и удаления
представлений и показывает некоторые примеры того, как использовать их.</p>

<h3><a name="view-syntax"></a>21.5.1. Синтаксис представления</h3>
<p>Запрос <a href="sql.htm#create-view"><code>CREATE VIEW</code></a>
создает новое представление (см. <a href="sql.htm#create-view">раздел
14.1.18</a>). Чтобы изменить определение представления или удалить
представление, надо использовать
<a href="sql.htm#alter-view"><code>ALTER VIEW</code></a> (см.
<a href="sql.htm#alter-view">раздел 14.1.8</a>) или
<a href="sql.htm#drop-view"><code>DROP VIEW</code></a>
(см. <a href="sql.htm#drop-view">раздел 14.1.28</a>).</p>

<p>Представление может быть создано из многих видов запросов
<a href="sql.htm#select"><code>SELECT</code></a>. Это может сослаться на
базовые таблицы или другие представления. Это может использовать объединения,
<a href="sql.htm#union"><code>UNION</code></a> и подзапросы.
<a href="sql.htm#select"><code>SELECT</code></a>
не должен даже обратиться ни к каким таблицам. Следующий пример определяет
представление, которое выбирает два столбца из другой таблицы, так же как
выражение, вычисленное от тех столбцов:
<pre>
mysql&gt; CREATE TABLE t (qty INT, price INT);
mysql&gt; INSERT INTO t VALUES(3, 50), (5, 60);
mysql&gt; CREATE VIEW v AS SELECT qty, price, qty*price AS value FROM t;
mysql&gt; SELECT * FROM v;
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
| 3    | 50    |   150 |
| 5    | 60    |   300 |
+------+-------+-------+

mysql&gt; SELECT * FROM v WHERE qty = 5;
+------+-------+-------+
| qty  | price | value |
+------+-------+-------+
| 5    | 60    |   300 |
+------+-------+-------+
</pre>

<h3><a name="view-algorithms"></a>21.5.2. Алгоритмы обработки представления
</h3>
<p>Дополнительное предложение <code>ALGORITHM</code> для
<a href="sql.htm#create-view"><code>CREATE VIEW</code></a> или
<a href="sql.htm#alter-view"><code>ALTER VIEW</code></a> это расширение MySQL
для SQL. Это затрагивает, как MySQL обрабатывает представление.
<code>ALGORITHM</code> берет три значения:
<code>MERGE</code>, <code>TEMPTABLE</code> или <code>UNDEFINED</code>.</p>

<ul><li><p><code>MERGE</code>: текст запроса, который относится к
представлению и определению представления, слит таким образом, что части
определения представления заменяют соответствующие части запроса.</li>

<li><code>TEMPTABLE</code>: результаты представления получены во временную
таблицу, которая используется, чтобы выполнить запрос.</li>
<li><code>UNDEFINED</code>: MySQL выбирает, который алгоритм использовать.
Это предпочитает <code>MERGE</code> если возможно, потому что
<code>MERGE</code> обычно более эффективен, и представление не может быть
обновляемым, если временная таблица используется.</li>

<li>Если нет предложения <code>ALGORITHM</code>, алгоритм значения по
умолчанию определен значением флага <code>derived_merge</code> переменной
<a href="server.htm#sysvar_optimizer_switch"><code>optimizer_switch</code>
</a>. См. <a href="optimiz.htm#derived-table-optimization">
раздел 9.2.1.18.3</a>.</p></li></ul>

<p>Причина определить <code>TEMPTABLE</code> явно: блокировки могут быть
сняты на основных таблицах после того, как временная таблица была составлена
и прежде, чем она будет использоваться, чтобы закончить обрабатывать запрос.
Это могло бы привести к более быстрому снятию блокировки, чем алгоритм
<code>MERGE</code> так, чтобы другие клиенты, которые используют
представление, не были заблокированы надолго.</p>

<p>Алгоритм представления может быть <code>UNDEFINED</code> по трем причинам:
</p>
<ul><li><p>Предложение <code>ALGORITHM</code> не присутствует в запросе
<a href="sql.htm#create-view"><code>CREATE VIEW</code></a>.</li>

<li><a href="sql.htm#create-view"><code>CREATE VIEW</code></a> имеет явное
предложение <code>ALGORITHM = UNDEFINED</code>.</li>
<li><code>ALGORITHM = MERGE</code> определен для представления, которое может
быть обработано только с временной таблицей. В этом случае MySQL производит
предупреждение и устанавливает алгоритм в <code>UNDEFINED</code>.
</p></li></ul>

<p>Как упомянуто ранее, <code>MERGE</code> обработан, сливая соответствующие
части определения представления в запрос, которое относится к представлению.
Следующие примеры кратко иллюстрируют как работает алгоритм
<code>MERGE</code>. Примеры предполагают, что есть представление
<code>v_merge</code>, у которого есть это определение:
<pre>
CREATE ALGORITHM = MERGE VIEW v_merge (vc1, vc2) AS
       SELECT c1, c2 FROM t WHERE c3 &gt; 100;
</pre>
Пример 1: Предположите, что мы делаем этот запрос:
<pre>
SELECT * FROM v_merge;
</pre>

MySQL обрабатывает запрос следующим образом:</p>
<ul><li><p><code>v_merge</code> становится <code>t</code>.</li>
<li><code>*</code> становится <code>vc1, vc2</code>,
которые соответствуют <code>c1, c2</code>.</li>
<li>Предложение <code>WHERE</code> представления добавлен.</p></li></ul>

<p>Получается запрос, который будет выполнен:
<pre>
SELECT c1, c2 FROM t WHERE c3 &gt; 100;
</pre>

Пример 2: Предположите, что мы делаем этот запрос:
<pre>
SELECT * FROM v_merge WHERE vc1 &lt; 100;
</pre>

Это запрос обработан так же, как предыдущий, за исключением того, что
<code>vc1 &lt; 100</code> становится <code>c1 &lt; 100</code> и предложение
<code>WHERE</code> добавлено к <code>WHERE</code> запроса, используя
<a href="funct.htm#operator_and"><code>AND</code></a> (и круглые скобки
добавлены, чтобы удостовериться, что части предложения выполнены с правильным
приоритетом). Получается запрос, который будет выполнен:
<pre>
SELECT c1, c2 FROM t WHERE (c3 &gt; 100) AND (c1 &lt; 100);
</pre>

Эффективно, у запроса, который будет выполнен, есть
<code>WHERE</code> этой формы:
<pre>
WHERE (select WHERE) AND (view WHERE)
</pre>

Если алгоритм <code>MERGE</code> не может использоваться, временная таблица
должна использоваться вместо этого. <code>MERGE</code> не может
использоваться, если представление содержит какие-либо конструкции в
следующем списке. Эти конструкции также предотвращают слияние полученных
таблиц (см. <a href="optimiz.htm#derived-table-optimization">раздел
9.2.1.18.3</a>).</p>

<ul><li><p>Совокупные функции
(<a href="funct.htm#function_sum"><code>SUM()</code></a>,
<a href="funct.htm#function_min"><code>MIN()</code></a>,
<a href="funct.htm#function_max"><code>MAX()</code></a>,
<a href="funct.htm#function_count"><code>COUNT()</code></a> и подобные).</li>

<li><code>DISTINCT</code>.</li>
<li><code>GROUP BY</code>.</li>
<li><code>HAVING</code>.</li>
<li><code>LIMIT</code>.</li>
<li><a href="sql.htm#union"><code>UNION</code></a> или
<a href="sql.htm#union"><code>UNION ALL</code></a>.</li>
<li>Подзапрос в списке select.</li>
<li>Назначение на пользовательские переменные.</li>
<li>Обращается только к буквальным значениям (в этом случае нет
никакой основной таблицы).</p></li></ul>

<h3><a name="view-updatability"></a>21.5.3.
Обновляемые и вставляемые представления</h3>
<p>Некоторые представления обновляемые и ссылки на них могут использоваться,
чтобы определить таблицы, которые будут обновлены в запросах изменения
данных. Таким образом, Вы можете использовать их в таких запросах, как
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> или
<a href="sql.htm#insert"><code>INSERT</code></a>, чтобы обновить содержание
основной таблицы. Полученные таблицы могут также быть определены в таблице
запроса <a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>, но могут использоваться
только для того, чтобы считать данные, чтобы определить строки, которые будут
обновлены или удалены. Вообще, ссылки представления должны быть обновляемыми,
означая, что они могут быть слиты и не осуществлены. У сложных представлений
есть более сложные правила.</p>

<p>Для представления, чтобы быть обновлемым, должны быть непосредственные
отношения между строками в представлении и строками в основной таблице.
Есть также определенные другие конструкции, которые делают представление
необновлемым. Чтобы быть более определенным, представление не обновляемое,
если это содержит какое-либо следующие элементы:</p>

<ul><li><p>Совокупные функции
(<a href="funct.htm#function_sum"><code>SUM()</code></a>,
<a href="funct.htm#function_min"><code>MIN()</code></a>,
<a href="funct.htm#function_max"><code>MAX()</code></a>,
<a href="funct.htm#function_count"><code>COUNT()</code></a> и подобные).</li>

<li><code>DISTINCT</code>.</li>
<li><code>GROUP BY</code>.</li>
<li><code>HAVING</code>.</li>
<li><code>LIMIT</code>.</li>
<li><a href="sql.htm#union"><code>UNION</code></a> или
<a href="sql.htm#union"><code>UNION ALL</code></a>.</li>
<li>Подзапрос в списке select. Независимые подзапросы в списке терпят неудачу
для <a href="sql.htm#insert"><code>INSERT</code></a>, но работают для
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>. Для зависимых подзапросов
не разрешены никакие запросы изменения данных.</li>

<li>Определенные соединения (см. дополнительное обсуждение соединения
позже в этом разделе).</li>
<li>Ссылка на необновляемое представление в предложении <code>FROM</code>.
</li>

<li>Подзапрос в <code>WHERE</code>, который
относится к таблице в <code>FROM</code>.</li>
<li>Обращается только к буквальным значениям (в этом случае нет никакой
основной таблицы, чтобы обновить).</li>

<li><code>ALGORITHM = TEMPTABLE</code> (использование временной таблицы
всегда делает представление необновляемым).</li>
<li>Многократные ссылки на любой столбец базовой таблицы (терпит неудачу для
<a href="sql.htm#insert"><code>INSERT</code></a>, работает для
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>).</p></li></ul>

<p>Произведенный столбец в представлении считают обновляемым, потому что
возможно назначить на него. Однако, если такой столбец обновлен явно,
единственное разрешенное значение <code>DEFAULT</code>.</p>

<p>Для многотабличного представления иногда возможно быть обновляемым,
предполагая, что это может быть обработано с алгоритмом <code>MERGE</code>.
Для того, чтобы это работало, представление должно использовать внутреннее
соединение (не внешнее соединение или <a href="sql.htm#union"><code>UNION
</code></a>). Кроме того, только единственная таблица в определении
представления может быть обновлена, таким образом, предложение
<code>SET</code> должно назвать только столбцы одной из таблиц в
представлении. Представления, которые используют
<a href="sql.htm#union"><code>UNION ALL</code></a> не разрешены даже при том,
что они могли бы быть теоретически обновляемыми.</p>

<p>Относительно вставляемых (то есть обновляемых запросом
<a href="sql.htm#insert"><code>INSERT</code></a>) представлений.
Представление вставляемое, если оно обновляемое, а также удовлетворяет эти
дополнительные требования для столбцов представления:</p>

<ul><li><p>Не должно быть никаких двойных имен столбцов представления.</li>
<li>Представление должно содержать все столбцы в базовой таблице, у которых
нет значения по умолчанию.</li>

<li>Столбцы представления должны быть простыми ссылками столбца.
Они не должны быть выражениями, такими как:
<pre>
3.14159
col1 + 3
UPPER(col2)
col3 / col4
(<em><code>подзапрос</code></em>)
</pre></li></ul>

<p>MySQL устанавливает флаг, названный обновляемым представлением, во время
<a href="sql.htm#create-view"><code>CREATE VIEW</code></a>.
Флаг установлен в to <code>YES</code> (true), если
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>
(и подобные операции), являются законными для представления. Иначе, флаг
установлен в <code>NO</code> (false). Столбец <code>IS_UPDATABLE</code> в
<a href="inform.htm#views-table"><code>INFORMATION_SCHEMA.VIEWS</code></a>
выводит на экран состояние этого флага. Это означает, что сервер всегда
знает, является ли представление обновляемым.</p>

<p>Если представление не обновляемое, такие запросы, как
<a href="sql.htm#update"><code>UPDATE</code></a>,
<a href="sql.htm#delete"><code>DELETE</code></a> и
<a href="sql.htm#insert"><code>INSERT</code></a>
незаконны и отклонены. Отметьте, что, даже если представление обновляемое,
невозможно вставить в него, как описано в другом месте в этом разделе.</p>

<p>Обновляемость представлений может быть затронут значением переменной
<a href="server.htm#sysvar_updatable_views_with_limit"><code>
updatable_views_with_limit</code></a>. См.
<a href="server.htm#server-system-variables">раздел 6.1.5</a>.</p>

<p>Для следующего обсуждения, предположите, что эти
таблицы и представления существуют:
<pre>
CREATE TABLE t1 (x INTEGER);
CREATE TABLE t2 (c INTEGER);
CREATE VIEW vmat AS SELECT SUM(x) AS s FROM t1;
CREATE VIEW vup AS SELECT * FROM t2;
CREATE VIEW vjoin AS SELECT * FROM vmat JOIN vup ON vmat.s=vup.c;
</pre>

Запросы <a href="sql.htm#insert"><code>INSERT</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
<a href="sql.htm#delete"><code>DELETE</code></a>
разрешены следующим образом:</p>

<ul><li><p><a href="sql.htm#insert"><code>INSERT</code></a>: Таблица вставки
может быть ссылкой представления, которая слита. Если представление
является представлением соединения, все компоненты представления должны быть
обновляемы (не осуществленные). Для многотабличного обновляемого
представления <a href="sql.htm#insert"><code>INSERT</code></a>
может работать, если это вставляет в единственную таблицу.</p>

<p>Это запрос недопустим, потому что один компонент
представления соединения необновляемый:
<pre>
INSERT INTO vjoin (c) VALUES (1);
</pre>

Это запрос допустим: представление не содержит осуществленных компонентов:
<pre>
INSERT INTO vup (c) VALUES (1);
</pre></li>

<li><a href="sql.htm#update"><code>UPDATE</code></a>:
Таблица или таблицы, которые будут обновлены в
<a href="sql.htm#update"><code>UPDATE</code></a>
могут быть ссылками представления, которые слиты.
Если представление это представление соединения, по крайней мере один
компонент представления должен быть обновляемым (это отличается от
<a href="sql.htm#insert"><code>INSERT</code></a>).</p>

<p>В многотабличном <a href="sql.htm#update"><code>UPDATE</code></a>
обновленные табличные ссылки запроса должны быть базовыми таблицами
или ссылками обновляемого представления. Необновленные табличные ссылки могут
быть осуществленными представлениями или полученными таблицами.</p>

<p>Это запрос допустим: столбец <code>c</code> из обновляемой
части представления соединения:
<pre>
UPDATE vjoin SET c=c+1;
</pre>

Это запрос недопустим: столбец <code>x</code> из необновляемой части:
<pre>
UPDATE vjoin SET x=x+1;
</pre>

Это запрос допустим: обновленная табличная ссылка многотабличного
<a href="sql.htm#update"><code>UPDATE</code></a> является
обновляемым представление (<code>vup</code>):
<pre>
UPDATE vup JOIN (SELECT SUM(x) AS s FROM t1) AS dt ON ...
SET c=c+1;
</pre>

Это запрос недопустимо: пытается обновить осуществленную полученную таблицу:
<pre>
UPDATE vup JOIN (SELECT SUM(x) AS s FROM t1) AS dt ON ...
SET s=s+1;
</pre></li>

<li><a href="sql.htm#delete"><code>DELETE</code></a>:
Таблица или таблицы, из которых данные будут удалены в
<a href="sql.htm#delete"><code>DELETE</code></a>
должны быть слиты представлением. Представления соединения не позволены (это
отличается от <a href="sql.htm#insert"><code>INSERT</code></a> и
<a href="sql.htm#update"><code>UPDATE</code></a>).</p>

<p>Это запрос недопустим, потому что представление с соединением:
<pre>
DELETE vjoin WHERE ...;
</pre>

Это запрос допустим, потому что представление слитое (обновляемое):
<pre>
DELETE vup WHERE ...;
</pre>

Это запрос допустим, потому что он удаляет из
слитого (обновляемого) представления:
<pre>
DELETE vup FROM vup JOIN (SELECT SUM(x) AS s FROM t1) AS dt ON ...;
</pre></li></ul>

<p>Более раннее обсуждение в этом разделе указало, что представление не
вставляемое, если не все столбцы простые ссылки столбца (например, если это
содержит столбцы, которые являются выражениями или сложными выражениями).
Хотя такое представление не вставляемое, это может быть обновляемым, если Вы
обновляете только столбцы, которые не являются выражениями.
Рассмотрите это представление:
<pre>
CREATE VIEW v AS SELECT col1, 1 AS col2 FROM t;
</pre>

Это представление не вставляемое, потому что <code>col2</code> выражение. Но
оно обновляемое, если обновление не пытается обновить <code>col2</code>.
Это обновление допустимо:
<pre>
UPDATE v SET col1 = 0;
</pre>

Это обновление не допустимо, потому что оно пытается
обновить столбец выражения:
<pre>
UPDATE v SET col2 = 0;
</pre>

Если таблица содержит столбец <code>AUTO_INCREMENT</code>, вставка во
вставляемое представление на таблице, которая не включает столбец
<code>AUTO_INCREMENT</code>, не изменяет значение
<a href="funct.htm#function_last-insert-id"><code>LAST_INSERT_ID()</code>
</a>, потому что побочные эффекты вставки значений по умолчанию в столбцы,
не являющиеся частью представления, не должны быть видимыми.</p>

<h3><a name="view-check-option"></a>21.5.4. Предложение WITH CHECK OPTION
</h3>
<p>Предложение <code>WITH CHECK OPTION</code> может быть дано для
обновляемого представления, чтобы предотвратить вставку строк, для которых
<code>WHERE</code> в <em><code>select_statement</code></em> не true.
Это предотвращает обновления строк, для которых <code>WHERE</code> true, но
обновление заставило бы это быть не истиной (другими словами, это
препятствует тому, чтобы видимые строки были обновлены к невидимым строкам).
</p>

<p>В предложении <code>WITH CHECK OPTION</code> для обновляемого
представления ключевые слова <code>LOCAL</code> и <code>CASCADED</code>
определяют контекст тестирования проверки, когда представление определено с
точки зрения другого представления. Когда никакое ключевое слово не задано,
значение по умолчанию <code>CASCADED</code>.</p>

<p>Тестирование <code>WITH CHECK OPTION</code> следует правилам:</p>
<ul><li><p>С <code>LOCAL</code> предложение <code>WHERE</code> представления
проверено, затем проверка рекурсивно проверяет основные представления и
применяет те же самые правила.</li>

<li>С <code>CASCADED</code> предложение <code>WHERE</code> представления
проверено, затем проверка рекурсивно проверяет основные представления,
добавляет к ним опцию <code>WITH CASCADED CHECK OPTION</code> (в целях
проверки, их определения остаются неизменными) и применяет те
же самые правила.</li>

<li>Без опции проверки предложение <code>WHERE</code> представления не
проверено, затем проверка рекурсивно проверяет основные представления
и применяет те же самые правила.</p></li></ul>

<p>Рассмотрите определения для следующей таблицы и набора представлений:
<pre>
CREATE TABLE t1 (a INT);
CREATE VIEW v1 AS SELECT * FROM t1 WHERE a &lt; 2 WITH CHECK OPTION;
CREATE VIEW v2 AS SELECT * FROM v1 WHERE a &gt; 0 WITH LOCAL CHECK OPTION;
CREATE VIEW v3 AS SELECT * FROM v1 WHERE a &gt; 0 WITH CASCADED CHECK OPTION;
</pre>
Здесь представления <code>v2</code> и <code>v3</code>
определены с точки зрения другого представления <code>v1</code>.</p>

<p>Вставки для <code>v2</code> проверены по опции <code>LOCAL</code>, затем
проверка переходит к <code>v1</code> и правила применены снова. Правила для
<code>v1</code> вызовут отказ проверки. Проверка на <code>v3</code>
также терпит неудачу:
<pre>
mysql&gt; INSERT INTO v2 VALUES (2);
ERROR 1369 (HY000): CHECK OPTION failed 'test.v2'
mysql&gt; INSERT INTO v3 VALUES (2);
ERROR 1369 (HY000): CHECK OPTION failed 'test.v3'
</pre>

<h3><a name="view-metadata"></a>21.5.5. Метаданные о представлении</h3>
<p>Метаданные о представлениях могут быть получены следующим образом:</p>

<ul><li><p>Запросите таблицу
<a href="inform.htm#views-table"><code>VIEWS</code></a> базы данных
<code>INFORMATION_SCHEMA</code>. См. <a href="inform.htm#views-table">раздел
22.29</a>.</li>

<li>Используйте <a href="sql.htm#show-create-view"><code>SHOW CREATE VIEW
</code></a>. См. <a href="sql.htm#show-create-view">раздел 14.7.5.13</a>.
</p></li></ul>

<h2><a name="stored-programs-security"></a>21.6.
Управление доступом для сохраненных программ и представлений</h2>
<p>Сохраненные программы и представления определены до использования и
выполняются в пределах контекста безопасности, который определяет их
привилегии. Этими привилегиями управляет их атрибут <code>DEFINER</code>
и, если есть, характеристика <code>SQL SECURITY</code>.</p>

<p>У всех сохраненных программ (процедуры, функции, триггеры и события) и
представлений может быть атрибут <code>DEFINER</code>, который называет
учетную запись MySQL. Если признак <code>DEFINER</code> опущен в
сохраненной программе или определении представления, учетная запись по
умолчанию это пользователь, который создает объект.</p>

<p>Кроме того, у сохраненных подпрограмм (процедуры и функции) и
представлений может быть характеристика <code>SQL SECURITY</code> со
значением <code>DEFINER</code> или <code>INVOKER</code>, чтобы
определить, выполняется ли объект в контексте создателя или вызывающего. Если
<code>SQL SECURITY</code> нет, значение по умолчанию контекст создателя.</p>

<p>Триггеры и события не имеют <code>SQL SECURITY</code> и всегда выполняются
в контексте создателя. Сервер вызывает эти объекты автоматически по мере
необходимости, таким образом нет никакого пользователя вызова.</p>

<p>Контексты безопасности отличаются следующим образом:</p>
<ul><li><p>Сохраненная программа или представление, которое выполняется в
контексте безопасности создателя, выполняют с привилегиями учетной записи,
названной <code>DEFINER</code>. Эти привилегии могут полностью отличаться от
таковых пользователя вызова. У вызывающего должны быть соответствующие
привилегии, чтобы сослаться на объект (например,
<a href="security.html#priv_execute"><code>EXECUTE</code></a>, чтобы
вызвать хранимую процедуру или
<a href="security.html#priv_select"><code>SELECT</code></a>, чтобы выбрать
данные из представления), но когда объект выполняется, эти привилегии
проигнорированы и учитываются только привилегии учетной записи
<code>DEFINER</code>. Если у этой учетной записи есть немного привилегий,
объект соответственно ограничен в операциях, которые это может выполнить.
Если <code>DEFINER</code> имеет большие права (например, это
<code>root</code>), объект может выполнить сильные операции
<span><em>независимо от того, кто его вызывает</em></span>.</li>

<li>Сохраненная подпрограмма или представление, которое выполняется в
контексте безопасности вызывающего, могут выполнить только операции, для
которых у вызывающего есть привилегии. <code>DEFINER</code> признак может
быть определен, но не имеет никакого эффекта для объектов, которые
выполняются в контексте безопасности вызывающего.</p></li></ul>

<p>Рассмотрите следующую хранимую процедуру:
<pre>
CREATE DEFINER = 'admin'@'localhost' PROCEDURE p1()
SQL SECURITY DEFINER
BEGIN
  UPDATE t1 SET counter = counter + 1;
END;
</pre>

Любой пользователь, который имеет привилегию
<a href="security.html#priv_execute"><code>EXECUTE</code></a> для
<code>p1</code> может вызвать это с <a href="sql.htm#call"><code>CALL</code>
</a>. Однако, когда <code>p1</code> выполняется, это работает в контексте
безопасности <code>DEFINER</code> и таким образом выполняется с привилегиями
<code>'admin'@'localhost'</code>, учетной записм, названной в атрибуте
<code>DEFINER</code>. Эта учетная запись должна иметь привилегию
<a href="security.html#priv_execute"><code>EXECUTE</code></a> для
<code>p1</code> так же как <a href="security.html#priv_update"><code>UPDATE
</code></a> для <code>t1</code>. Иначе процедура терпит неудачу.</p>

<p>Теперь рассмотрите эту хранимую процедуру, которая идентична
<code>p1</code> за исключением того, что характеристика <code>SQL SECURITY
</code> <code>INVOKER</code>:
<pre>
CREATE DEFINER = 'admin'@'localhost' PROCEDURE p2()
SQL SECURITY INVOKER
BEGIN
  UPDATE t1 SET counter = counter + 1;
END;
</pre>

<code>p2</code>, в отличие от <code>p1</code>, выполняется в контексте
безопасности <code>INVOKER</code>. Атрибут <code>DEFINER</code> не важен и
<code>p2</code> выполняется с привилегиями пользователя вызова.
<code>p2</code> терпит неудачу, если вызывающему недостает привилегии
<a href="security.html#priv_execute"><code>EXECUTE</code></a> для
<code>p2</code> или <a href="security.html#priv_update"><code>UPDATE</code>
</a> для таблицы с именем <code>t1</code>.</p>

<p>MySQL использует следующие правила, чтобы управлять тем, какие учетные
записи пользователь может определить в атрибуте <code>DEFINER</code> объекта:
</p>

<ul><li><p>Вы можете определить значение <code>DEFINER</code>
не к своей собственной учетной записи, только если Вы имеете привилегию
<a href="security.html#priv_super"><code>SUPER</code></a>.</li>

<li>Если Вы не имеете привилегии
<a href="security.html#priv_super"><code>SUPER</code></a>, единственное
легальное пользовательское значение: Ваша собственная учетная запись,
определенная буквально или при использовании
<a href="funct.htm#function_current-user"><code>CURRENT_USER</code></a>.
Вы не можете установить definer в некоторую другую учетную запись.
</p></li></ul>

<p>Чтобы минимизировать потенциал риска для сохраненной программы и создания
представления, следуйте этим советам:</p>
<ul><li><p>Для сохраненной подпрограммы или представления, надо использовать
<code>SQL SECURITY INVOKER</code> в определении объекта, когда возможно,
чтобы это могло использоваться только пользователями с разрешениями,
подходящими для операций, выполненных объектом.</li>

<li>Если Вы создаете сохраненные программы контекста создателя, используя
учетную запись, которая имеет привилегию
<a href="security.html#priv_super"><code>SUPER</code></a>,
определите явно признак <code>DEFINER</code>, который называет учетную
запись, обладающую только привилегиями требуемыми для операций выполненных
объектом. Определите чрезвычайно привилегированный <code>DEFINER</code>
только когда абсолютно необходимо.</li>

<li>Администраторы могут препятствовать тому, чтобы пользователи определили
чрезвычайно привилегированные учетные записи в <code>DEFINER</code>, не
предоставляя им привилегию <a href="security.html#priv_super"><code>SUPER
</code></a>.</li>

<li>Объекты контекста создателя должны быть написаны, имея в виду, что они
могут быть в состоянии получить доступ к данным, для которых у пользователя
вызова нет никаких привилегий. В некоторых случаях Вы можете предотвратить
ссылку на эти объекты, не предоставляя неправомочным
пользователям особые привилегии:</p>

<ul><li><p>На хранимую процедуру или функцию не может сослаться пользователь,
который не имеет привилегии <a href="security.html#priv_execute"><code>
EXECUTE</code></a> для этого.</li>

<li>На представление не может сослаться пользователь, у которого нет
соответствующей привилегии для него
(<a href="security.html#priv_select"><code>SELECT</code></a> для выбора
из, <a href="security.html#priv_insert"><code>INSERT</code></a> для вставки
и т.д.).</p></li></ul>

<p>Однако, никакого такого управления не существует для триггеров, потому что
пользователи не ссылаются на них непосредственно. Триггер всегда выполняется
в контексте <code>DEFINER</code> и активирован доступом к таблице, с которой
связан, даже обычные табличные доступы пользователями без специальных
привилегий. Если учетной записи <code>DEFINER</code> дают привилегию,
триггер может выполнить чувствительные или опасные операции. Это остается
истиной, если привилегии <a href="security.html#priv_super"><code>SUPER
</code></a> и <a href="security.html#priv_trigger"><code>TRIGGER</code></a>
должны были создать триггер, отменяются из учетной записи пользователя,
который создал это. Администраторы должны быть особенно осторожными
относительно предоставления пользователям этой комбинации привилегий.
</p></li></ul>

<h2><a name="stored-programs-logging"></a>21.7.
Двоичное журналирование сохраненных программ</h2>
<p>Двоичный журнал содержит информацию о запросах SQL, которые изменяют
содержание базы данных. Эта информация хранится в форме
<span>событий</span>, которые описывают модификации. У двоичного
журнала есть две важных цели:</p>

<ul><li><p>Двоичный журнал используется на основных серверах репликации
в качестве отчета о запросах, которые будут посланы в ведомые серверы.
Главный сервер посылает события, содержавшиеся в его двоичном журнале к его
ведомым устройствам, которые запускают те события, чтобы произвести те же
самые изменения данных, которые были сделаны на ведущем устройстве. См.
<a href="replica.htm#replication-implementation">раздел 19.2</a>.</li>

<li>Определенные операции восстановления данных требуют использования
двоичного журнала. После того как резервный файл был восстановлен, события в
двоичном журнале, которые были зарегистрированы после того, как резервное
копирование было сделано, повторно выполнены. Эти события осовременивают базы
данных от пункта резервного копирования. См.
<a href="backup.htm#recovery-from-backups">раздел 8.3.2</a>.</p></li></ul>

<p>Однако, есть определенные двоичные проблемы журналирования, которые
применяются относительно сохраненных программ (хранимые процедуры и функции,
триггеры и события), если журналирование происходит на уровне запроса:</p>

<ul><li><p>В некоторых случаях возможно, что запрос затронет различные наборы
строк на ведущем и ведомом устройствах.</li>
<li>Копируемые запросы, выполненные на ведомом устройстве, обработаны ведомым
потоком SQL, у которого есть полные привилегии. Для процедуры возможно
следовать различными путями выполнения на основных и ведомых серверах, таким
образом, пользователь может написать подпрограмму, содержащую опасный запрос,
который выполнится только на ведомом устройстве, где это обработано потоком,
у которого есть полные привилегии.</li>

<li>Если сохраненная программа, которая изменяет данные, недетерминирована,
это неповторимо. Это может привести к различным данным по ведущему и ведомому
устройству или заставить восстановленные данные отличаться
от оригинальных данных.</p></li></ul>

<p>Этот раздел описывает, как MySQL обрабатывает двоичное журналирование для
сохраненных программ. Это заявляет текущие положения, которые выполнение
помещает в использование сохраненных программ, и что Вы можете сделать, чтобы
избежать проблем. Это также обеспечивает дополнительную информацию о
причинах этих условий.</p>

<p>Вообще, проблемы описанные здесь, бывают, когда двоичное журналирование
происходит на уровне запроса SQL. Если Вы используете основанное на строке
двоичное журналирование, журнал содержит изменения, произведенные в
отдельных строках в результате выполнения запросов SQL. Когда подпрограммы
или триггеры выполняются, зарегистрированы изменения строки, а не запросы,
которые производят изменения. Для хранимых процедур это означает, что
запрос <a href="sql.htm#call"><code>CALL</code></a> не зарегистрирован. Для
сохраненных функций изменения строки, произведенные в пределах функции,
зарегистрированы, а не вызов функции. Для триггеров зарегистрированы
изменения строки, произведенные триггером. На ведомой стороне замечены
только изменения строки, а не сохраненный вызов программы. Для общей
информации об основанном на строке журналировании см.
<a href="replica.htm#replication-formats">раздел 19.2.1</a>.</p>

<p>Если не отмечено иное, замечания здесь предполагают, что Вы включили
двоичное журналирование, запуская сервер с опцией
<a href="replica.htm#option_mysqld_log-bin"><code>--log-bin</code></a>
(см. <a href="server.htm#binary-log">раздел 6.4.4</a>). Если двоичный журнал
не включен, репликация невозможна, и при этом двоичный журнал недоступен
для восстановления данных.</p>

<p>Условия использования сохраненных функций в MySQL могут быть получены в
итоге следующим образом. Эти условия не относятся к хранимым процедурам или
событиям планировщика событий и не применяются, если двоичное
журналирование не включено.</p>

<ul><li><p>Чтобы создать или изменить сохраненную функцию, Вы должны иметь
привилегию <a href="security.html#priv_super"><code>SUPER</code></a>
в дополнение к <a href="security.html#priv_create-routine"><code>CREATE
ROUTINE</code></a> или <a href="security.html#priv_alter-routine"><code>
ALTER ROUTINE</code></a>, которая обычно требуется. В зависимости от значения
<code>DEFINER</code> в функциональном определении,
<a href="security.html#priv_super"><code>SUPER</code></a> может
требоваться независимо от того, включено ли двоичное журналирование. См.
<a href="sql.htm#create-procedure">раздел 14.1.13</a>.</li>

<li>Когда Вы создаете сохраненную функцию, Вы должны объявить что это
детерминировано или что не изменяет данные. Иначе, это может быть опасно для
восстановления данных или репликации.</p>

<p>По умолчанию для запроса <a href="sql.htm#create-function"><code>CREATE
FUNCTION</code></a>, который будет принят, по крайней мере один из
<code>DETERMINISTIC</code>, <code>NO SQL</code> или
<code>READS SQL DATA</code> должен быть определен явно.
Иначе происходит ошибка:
<pre>
ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled
(you *might* want to use the less safe
log_bin_trust_function_creators variable)
</pre>

Эта функция детерминирована (и не изменяет данные), таким
образом, это безопасно:
<pre>
CREATE FUNCTION f1(i INT) RETURNS INT DETERMINISTIC READS SQL DATA
BEGIN
  RETURN i;
END;
</pre>

Эта функция использует <a href="funct.htm#function_uuid"><code>UUID()</code>
</a>, которая не детерминирована, таким образом, функция также не
детерминирована и не безопасна:
<pre>
CREATE FUNCTION f2() RETURNS CHAR(36) CHARACTER SET utf8
BEGIN
  RETURN UUID();
END;
</pre>

Эта функция изменяет данные, таким образом, это, возможно, не безопасно:
<pre>
CREATE FUNCTION f3(p_id INT)
RETURNS INT
BEGIN
  UPDATE t SET modtime = NOW() WHERE id = p_id;
  RETURN ROW_COUNT();
END;
</pre>

Оценка природы функции основана на <span>определении</span> создателя: MySQL
не проверяет, что функция, объявленная <code>DETERMINISTIC</code>, свободна
от запросов, которые приводят к недетерминированным результатам.</li>

<li>Хотя возможно создать детерминированную сохраненную функцию без
определения <code>DETERMINISTIC</code>, Вы не можете выполнить эту функцию,
используя основанное на запросе двоичное журналирование. Чтобы выполнить
такую функцию, Вы должны использовать основанное на строке или смешанное
двоичное журналирование. Альтернативно, если Вы явно определяете
<code>DETERMINISTIC</code> в функциональном определении Вы можете
использовать любой вид журналирования, включая основанное
на запросе журналирование.</li>

<li>Чтобы ослабить предыдущие условия функционального создания (что Вы должны
иметь привилегию <a href="security.html#priv_super"><code>SUPER</code></a>,
и что функция должна быть объявлена детерминированной или не изменять
данные), установите глобальную переменную
<a href="server.htm#sysvar_log_bin_trust_function_creators"><code>
log_bin_trust_function_creators</code></a> в 1. По умолчанию у этой
переменной есть значение 0, но Вы можете изменить ее
<pre>
mysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;
</pre>

Вы можете также установить эту переменную при использовании опции
<a href="replica.htm#option_mysqld_log-bin-trust-function-creators"><code>
--log-bin-trust-function-creators=1</code></a>, запуская сервер.</p>

<p>Если двоичное журналирование не включено,
<a href="server.htm#sysvar_log_bin_trust_function_creators"><code>
log_bin_trust_function_creators</code></a> не применяется.
<a href="security.html#priv_super"><code>SUPER</code></a> не требуется для
функционального создания если, как описано ранее, <code>DEFINER</code>
в функциональном определении требует этого.</li>

<li>Для информации о встроенных функциях, которые могут быть опасными для
репликации (и таким образом сделать сохраненные функции, которые используют
их, также опасными) см.
<a href="replica.htm#replication-features">раздел 19.4.1</a>.</p></li></ul>

<p>Триггеры подобны сохраненным функциям, таким образом, предыдущие замечания
относительно функций также относятся к триггерам со следующим исключением:
<a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a>
не имеет дополнительной характеристики <code>DETERMINISTIC</code>, таким
образом, триггеры, как предполагается, всегда детерминированы. Однако, это
предположение могло бы в некоторых случаях быть недопустимым. Например,
функция <a href="funct.htm#function_uuid"><code>UUID()</code></a>
недетерминирована (и не копируется). Вы должны быть осторожными относительно
использования таких функций в триггерах.</p>

<p>Триггеры могут обновить таблицы, таким образом, сообщения об ошибках,
подобные тем для сохраненных функций, происходят с
<a href="sql.htm#create-trigger"><code>CREATE TRIGGER</code></a>,
если у Вас нет необходимых привилегий. На ведомой стороне сервер использует
атрибут <code>DEFINER</code> триггера, чтобы определить, какой пользователь
является создателем триггера.</p>

<p>Остальная часть этого раздела обеспечивает дополнительные детали о
выполнении журналирования и его значениях. Это обсуждение применяется только
для основанного на запросе журналирования, а не для основанного на строке
журналирования, за исключением первого элемента:
<code>CREATE</code> и <code>DROP</code> зарегистрированы как запросы
независимо от режима журналирования.</p>

<ul><li><p>Сервер пишет
<a href="sql.htm#create-event"><code>CREATE EVENT</code></a>,
<a href="sql.htm#create-procedure"><code>CREATE PROCEDURE</code></a>,
<a href="sql.htm#create-function"><code>CREATE FUNCTION</code></a>,
<a href="sql.htm#alter-event"><code>ALTER EVENT</code></a>,
<a href="sql.htm#alter-procedure"><code>ALTER PROCEDURE</code></a>,
<a href="sql.htm#alter-function"><code>ALTER FUNCTION</code></a>,
<a href="sql.htm#drop-event"><code>DROP EVENT</code></a>,
<a href="sql.htm#drop-procedure"><code>DROP PROCEDURE</code></a> и
<a href="sql.htm#drop-function"><code>DROP FUNCTION</code></a>
в двоичный журнал.</li>

<li>Сохраненная функция зарегистрирована как
<a href="sql.htm#select"><code>SELECT</code></a>, если функция изменяет
данные и происходит в пределах запроса, который не был бы иначе
зарегистрирован. Это предотвращает игнорирование изменений данных, которые
следуют из использования сохраненных функций в незарегистрированных запросах.
Например, <a href="sql.htm#select"><code>SELECT</code></a> не записаны в
двоичный журнал, но <a href="sql.htm#select"><code>SELECT</code></a> мог бы
вызвать сохраненную функцию, которая производит изменения. Чтобы обработать
это, <code>SELECT <em><code>func_name</code></em>()</code> записан в двоичный
журнал, когда данная функция производит изменение. Предположите, что
следующие запросы выполнены на ведущем устройстве:
<pre>
CREATE FUNCTION f1(a INT) RETURNS INT
BEGIN
  IF (a &lt; 3) THEN INSERT INTO t2 VALUES (a);
  END IF;
  RETURN 0;
END;

CREATE TABLE t1 (a INT);
INSERT INTO t1 VALUES (1),(2),(3);
SELECT f1(a) FROM t1;
</pre>

Когда <a href="sql.htm#select"><code>SELECT</code></a> выполняется, функция
<code>f1()</code> вызвана три раза. Два из тех вызовов вставляют строку, и
MySQL регистрирует <a href="sql.htm#select"><code>SELECT</code></a> для
каждого из них. Таким образом, MySQL пишет следующие
запросы в двоичный журнал:
<pre>
SELECT f1(1);
SELECT f1(2);
</pre>

Сервер также регистрирует запрос
<a href="sql.htm#select"><code>SELECT</code></a> для сохраненной функции
, когда функция вызывает хранимую процедуру, которая вызывает ошибку. В этом
случае сервер пишет <a href="sql.htm#select"><code>SELECT</code></a>
в журнал наряду с ожидаемым кодом ошибки. На ведомом устройстве, если та же
самая ошибка происходит, что является ожидаемым результатом, репликация
продолжается. Иначе репликация встанет.</li>

<li>У журналирования сохраненных функциональных вызовов, а не запросов,
выполненных функцией, есть значение безопасности для репликации, которое
является результатом двух факторов:</p>

<ul><li><p>Для функции возможно следовать
различными путями выполнения на основных и ведомых серверах.</li>
<li>Запросы, выполненные на ведомом устройстве, обработаны ведомым потоком
SQL, у которого есть полные привилегии.</p></li></ul>

<p>Хотя пользователь должен иметь привилегию
<a href="security.html#priv_create-routine"><code>CREATE ROUTINE</code></a>,
чтобы создать функцию, пользователь может написать функцию, содержащую
опасный запрос, который выполнится только на ведомом устройстве, где это
обработано потоком, у которого есть полные привилегии. Например, если у
основного и ведомого серверов есть значения идентификаторов сервера 1 и 2,
соответственно, пользователь на главном сервере мог создать и вызвать опасную
функцию <code>unsafe_func()</code>:
<pre>
mysql&gt; delimiter //
mysql&gt; CREATE FUNCTION unsafe_func () RETURNS INT
    -&gt; BEGIN
    -&gt;   IF @@server_id=2 THEN <em><code>dangerous_statement</code></em>;
    -&gt;   END IF;
    -&gt;   RETURN 1;
    -&gt; END;
    -&gt; //
mysql&gt; delimiter ;
mysql&gt; INSERT INTO t VALUES(unsafe_func());
</pre>

Запросы <a href="sql.htm#create-function"><code>CREATE FUNCTION</code></a> и
<a href="sql.htm#insert"><code>INSERT</code></a> записаны в двоичный журнал,
таким образом, ведомое устройство выполнит их. Поскольку у ведомого потока
SQL есть полные привилегии, он выполнит опасный запрос. Таким образом,
функциональный вызов имеет различные эффекты на ведущее и ведомое устройство
и не безопасен для репликации.</p>

<p>Чтобы принять меры против этой опасности для серверов, которым включили
двоичное журналирование, создатели сохраненных функций должны иметь
привилегию <a href="security.html#priv_super"><code>SUPER</code></a>,
в дополнение к обычной <a href="security.html#priv_create-routine"><code>
CREATE ROUTINE</code></a>, которая требуется. Точно так же, чтобы
использовать <a href="sql.htm#alter-function"><code>ALTER FUNCTION</code></a>
Вы должны иметь <a href="security.html#priv_super"><code>SUPER</code></a> в
дополнение к <a href="security.html#priv_alter-routine"><code>ALTER ROUTINE
</code></a>. Без <a href="security.html#priv_super"><code>SUPER</code></a>
произойдет такая ошибка:
<pre>
ERROR 1419 (HY000): You do not have the SUPER privilege and
binary logging is enabled (you *might* want to use the less safe
log_bin_trust_function_creators variable)
</pre>

Если Вы не хотите требовать, чтобы функциональные создатели имели привилегию
<a href="security.html#priv_super"><code>SUPER</code></a> (например, если все
пользователи с привилегией <a href="security.html#priv_create-routine"><code>
CREATE ROUTINE</code></a> на Вашей системе опытные разработчики приложений),
установите глобальную системную переменную
<a href="server.htm#sysvar_log_bin_trust_function_creators">
<code>log_bin_trust_function_creators</code></a> в 1.
Вы можете также установить эту переменную при использовании опции
<a href="replica.htm#option_mysqld_log-bin-trust-function-creators">
<code>--log-bin-trust-function-creators=1</code></a>, запуская сервер. Если
двоичное журналирование не включено,
<a href="server.htm#sysvar_log_bin_trust_function_creators">
<code>log_bin_trust_function_creators</code></a> не применяется.
<a href="security.html#priv_super"><code>SUPER</code></a> не требуется для
функционального создания если, как описано ранее, значение
<code>DEFINER</code> в функциональном определении требует этого.</li>

<li>Если функция, которая выполняет обновления, недетерминирована, это
неповторимо. Это может иметь два нежелательных эффекта:</p>
<ul><li><p>Это сделает ведомое устройство отличающимся от ведущего.</li>
<li>Восстановленные данные будут отличаться от оригинальных данных.</li></ul>

<p>Чтобы иметь дело с этими проблемами, MySQL проводит в жизнь следующее
требование: на главном сервере создание и изменение функции не работает, если
Вы не объявляете, что функция детерминирована или не изменяет данные.
Два набора функциональных характеристик применяются здесь:</p>

<ul><li><p><code>DETERMINISTIC</code> и <code>NOT DETERMINISTIC</code>
указывают, приводит ли функция всегда к тому же самому результату для данных
вводов. Значение по умолчанию <code>NOT DETERMINISTIC</code>, если никакая
характеристика не дана. Чтобы объявить, что функция детерминирована, Вы
должны определить <code>DETERMINISTIC</code> явно.</li>

<li><code>CONTAINS SQL</code>, <code>NO SQL</code>, <code>READS SQL DATA
</code> и <code>MODIFIES SQL DATA</code> предоставляют информацию о том,
читает ли функция или пишет данные. Также <code>NO SQL</code> или
<code>READS SQL DATA</code> указывает, что функция не изменяет данные, но Вы
должны определить один из них явно, потому что значение по умолчанию
<code>CONTAINS SQL</code>, если никакая характеристика не задана.</li></ul>

<p>По умолчанию для <a href="sql.htm#create-function"><code>CREATE FUNCTION
</code></a>, который будет принят, по крайней мере один из
<code>DETERMINISTIC</code>, <code>NO SQL</code> или
<code>READS SQL DATA</code> должен быть определен явно.
Иначе ошибка происходит:
<pre>
ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled
(you *might* want to use the less safe
log_bin_trust_function_creators variable)
</pre>

Если Вы устанавливаете
<a href="server.htm#sysvar_log_bin_trust_function_creators">
<code>log_bin_trust_function_creators</code></a> в 1, требование, чтобы
функции быть детерминированными или не изменяли данные, пропущено.</li>

<li>Требования хранимой процедуры зарегистрированы на уровне запроса, а не на
уровне вызова <a href="sql.htm#call"><code>CALL</code></a>. Таким образом,
сервер не регистрирует сам <a href="sql.htm#call"><code>CALL</code></a>,
это регистрирует те запросы в пределах процедуры, которые фактически
выполняют. В результате те же самые изменения, которые происходят на ведущем
устройстве, будут наблюдаться относительно ведомых серверов. Это
предотвращает проблемы, которые могли следовать из процедуры, имеющей
различные пути выполнения на разных машинах.</p>

<p>Вообще, запросы, выполненные в пределах хранимой процедуры, записаны в
двоичный журнал, используя те же самые правила, которые применились бы для
запросов, которые будут выполнены автономным способом. Некоторая специальная
забота проявлена, регистрируя регистрируя запрос процедуры, потому что
выполнение запроса в пределах процедур не совсем то же самое, как
не в контексте процедуры:</p>

<ul><li><p>Запрос, который будет зарегистрирован, мог бы содержать ссылки на
местные переменные процедуры. Эти переменные не существуют за пределами
контекста хранимой процедуры, таким образом, запрос, который относится к
такой переменной, не может быть зарегистрирован буквально. Вместо этого
каждая ссылка на местную переменную заменена этой конструкцией для того,
чтобы зарегистрировать цели:
<pre>
NAME_CONST(<em><code>var_name</code></em>, <em><code>var_value</code></em>)
</pre>

<em><code>var_name</code></em> местное имя переменной, а
<em><code>var_value</code></em> постоянное указание на значение, которое
имеет переменная в то время, когда запрос зарегистрирован.
<a href="funct.htm#function_name-const"><code>NAME_CONST()</code></a>
имеет значение <em><code>var_value</code></em> и <span>name</span>
<em><code>var_name</code></em>. Таким образом, если Вы вызываете эту функцию
непосредственно, Вы получаете результат:
<pre>
mysql&gt; SELECT NAME_CONST('myname', 14);
+--------+
| myname |
+--------+
| 14     |
+--------+
</pre>

<a href="funct.htm#function_name-const"><code>NAME_CONST()</code></a>
позволяет зарегистрированному автономному запросу быть выполненным на ведомом
устройстве с тем же самым эффектом как оригинальный запрос, который был
выполнен на ведущем устройстве в пределах хранимой процедуры.</p>

<p>Использование <a href="funct.htm#function_name-const"><code>NAME_CONST()
</code></a> может привести к проблеме для
<a href="sql.htm#create-table"><code>CREATE TABLE ... SELECT</code></a>,
когда исходные выражения столбца обращаются к местным переменным.
Преобразование этих ссылок в выражения
<a href="funct.htm#function_name-const"><code>NAME_CONST()</code></a>
может привести к именам столбцов, которые отличаются на основных и ведомых
серверах, или именам, которые являются слишком длинными, чтобы быть
допустимыми идентификаторами столбца. Обходное решение должно поставлять
псевдонимы для столбцов, которые обращаются к местным переменным.
Рассмотрите этот запрос, когда <code>myvar</code> имеет значение 1:
<pre>
CREATE TABLE t1 SELECT myvar;
</pre>

Это будет переписано следующим образом:
<pre>
CREATE TABLE t1 SELECT NAME_CONST(myvar,1);
</pre>

Чтобы гарантировать, что у основных и ведомых таблиц есть те же самые имена
столбцов, напишите запрос так:
<pre>
CREATE TABLE t1 SELECT myvar AS myvar;
</pre>

Переписанный запрос становится:
<pre>
CREATE TABLE t1 SELECT NAME_CONST(myvar, 1) AS myvar;
</pre></li>

<li>Запрос, который будет зарегистрирован, мог бы содержать ссылки на
определяемые пользователем переменные. Чтобы обработать это, MySQL пишет
<a href="sql.htm#set-variable"><code>SET</code></a> в двоичный журнал, чтобы
удостовериться, что переменная существует на ведомом устройстве с тем же
самым значением, как на ведущем устройстве. Например, если запрос относится к
переменной <code>@my_var</code>, этому запросу будет предшествовать в
двоичном журнале следующий запрос, где <em><code>value</code></em>
значение <code>@my_var</code> на ведущем сервере:
<pre>
SET @my_var = <em><code>value</code></em>;
</pre></li>

<li>Вызовы процедуры могут произойти в пределах законченной или отмененной
транзакции. Контекст транзакции составляется так, чтобы аспекты выполнения
процедуры копировались правильно. Таким образом, сервер регистрирует те
запросы в пределах процедуры, которые фактически выполняются и изменяют
данные, а также регистрирует
<a href="sql.htm#commit"><code>BEGIN</code></a>,
<a href="sql.htm#commit"><code>COMMIT</code></a> и
<a href="sql.htm#commit"><code>ROLLBACK</code></a>
по мере необходимости. Например, если процедура обновляет только
транзакционные таблицы и выполнена в пределах транзакции, которая понижена до
прежнего уровня, те обновления не зарегистрированы. Если процедура происходит
в пределах завершенной транзакции, <a href="sql.htm#commit"><code>BEGIN
</code></a> и <a href="sql.htm#commit"><code>COMMIT</code></a>
зарегистрированы с обновлениями. Для процедуры, которая выполняется в
пределах отмененной транзакции, ее запросы зарегистрированы, используя те же
самые правила, которые применились бы, если бы запросы были
выполнены автономным способом:</p>

<ul><li><p>Обновления транзакционных таблиц не зарегистрированы.</li>
<li>Обновления нетранзакционных таблиц зарегистрированы, потому что обратная
перемотка не отменяет их.</li>

<li>Обновления соединения транзакционных и нетранзакционных таблиц
зарегистрированы, окруженные
<a href="sql.htm#commit"><code>BEGIN</code></a> и
<a href="sql.htm#commit"><code>ROLLBACK</code></a>
так, чтобы ведомые устройства произвели те же самые изменения и отмены,
как на ведущем устройстве.</li></ul></li></ul></li>

<li>Требование хранимой процедуры <span><em>НЕ</em></span> записано в
двоичный журнал на уровне запроса, если процедура вызвана изнутри сохраненной
функции. В этом случае единственной зарегистрированной вещью является запрос,
который вызывает функцию (если это происходит в пределах запроса, который
зарегистрирован) или запрос <a href="sql.htm#do"><code>DO</code></a>
(если это происходит в пределах запроса, который не зарегистрирован). Поэтому
забота должна быть осуществлена в использовании сохраненных функций, которые
вызывают процедуру, даже если процедура иначе безопасна сама по себе.
</li></ul>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
