<html>
<head>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <title>Глава 12. Типы данных</title>
<meta name="generator" content="DocBook XSL Stylesheets + chunker.py v1.9.2" />
</head>

<body>
<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<h1><a name="data-types"></a>Глава 12. Типы данных</h1>
<p>MySQL поддерживает много типов данных <a href="glossary.htm#glos_sql">SQL
</a> в нескольких категориях: числовые типы, типы даты и времени, строка
(символ и байт), пространственные типы и
<a href="#json"><code>JSON</code></a>.
Эта глава обеспечивает краткий обзор этих типов данных, более подробное
описание свойств типов в каждой категории и резюме требований хранения типа
данных. Начальный краткий обзор преднамеренно краток. С более подробными
описаниями позже в главе нужно консультироваться для дополнительной
информации об особых типах данных, таких как допустимые форматы, в которых Вы
можете определить значения.</p>

<p>Описания типа данных используют эти соглашения:</p>
<ul><li><p><em><code>M</code></em> указывает на максимальную ширину
отображения для типов целого числа. Для чисел с плавающей запятой и
фиксированной точкой <em><code>M</code></em> общее количество цифр, которые
могут быть сохранены (точность). Для строковых типов
<em><code>M</code></em> максимальная длина. Максимальное допустимое значение
<em><code>M</code></em> зависит от типа данных.</li>

<li><em><code>D</code></em> относится к числам с плавающей запятой и
фиксированной точкой и указывает на число цифр после десятичной запятой
(масштаб). Максимальное возможное значение 30, но должно быть не больше
<em><code>M</code></em>-2.</li>

<li><em><code>fsp</code></em> относится к типам
<a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a>
и представляет дробную точность секунд, то есть, число цифр после десятичной
запятой для дробных частей секунд. Значение <em><code>fsp</code></em>, если
есть, должно быть в диапазоне от 0 до 6. Значение 0 показывает, что нет
никакой дробной части. Если опущено, точность по умолчанию 0. Это отличается
от стандартного значения по умолчанию SQL 6 для совместимости с
предыдущими версиями MySQL.</li>
<li>Квадратные скобки (<code>[</code> и <code>]</code>)
указывают на дополнительные части определений типа.</p></li></ul>

<h2><a name="data-type-overview"></a>12.1. Краткий обзор типов данных</h2>
<h3><a name="numeric-type-overview"></a>12.1.1. Краткий обзор числовых типов
</h3>
<p>Для дополнительной информации о свойствах и требованиях хранения числовых
типов см. разделы <a href="#numeric-types">12.2</a> и
<a href="#storage-requirements">12.8</a>.</p>

<p><em><code>M</code></em> указывает на максимальную ширину отображения
для типов целого числа. Максимальная ширина 255. Ширина не связана с
диапазоном значений, которые тип может содержать, как описано в
<a href="#numeric-types">разделе 12.2</a>. Для чисел с плавающей
запятой и типов фиксированной точки <em><code>M</code></em>
общее количество цифр, которые могут быть сохранены.</p>

<p>Если Вы определяете <code>ZEROFILL</code> для числового столбца, MySQL
автоматически добавляет <code>UNSIGNED</code> столбцу.</p>
<p>Типы числовых данных, которые разрешают <code>UNSIGNED</code>, также
разрешают <code>SIGNED</code>. Однако, эти типы данных со знаком
по умолчанию, таким образом, <code>SIGNED</code>
не имеет никакого эффекта.</p>

<p><code>SERIAL</code> означает <code>BIGINT UNSIGNED NOT NULL
AUTO_INCREMENT UNIQUE</code>.</p>
<p><code>SERIAL DEFAULT VALUE</code> в определении целого числа столбец
псевдоним для <code>NOT NULL AUTO_INCREMENT UNIQUE</code>.</p>

<p>Когда Вы используете вычитание между целочисленными значениями, где каждое
число имеет тип <code>UNSIGNED</code>, результат со знаком, если включен
режим SQL <a href="server.htm#sqlmode_no_unsigned_subtraction"><code>
NO_UNSIGNED_SUBTRACTION</code></a>. См. <a href="funct.htm#cast-functions">
раздел 13.10</a>.</p>

<ul><li><p><a href="#bit-type"><code>BIT[(<em><code>M</code></em>)]
</code></a></p>
<p>Тип битового значения. <em><code>M</code></em> указывает на число битов на
значение, от 1 до 64. Значение по умолчанию 1, если
<em><code>M</code></em> пропущен.</li>

<li><a href="#integer-types"><code>TINYINT[(<em><code>M</code>
</em>)] [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Очень маленькое целое число. Диапазон со знаком от
<code>-128</code> до <code>127</code>. Диапазон без знака от
<code>0</code> до <code>255</code>.</li>

<li><a href="#integer-types"><code>BOOL</code></a>,
<a href="#integer-types"><code>BOOLEAN</code></a></p>
<p>Эти типы синонимы для
<a href="#integer-types"><code>TINYINT(1)</code></a>.
Значение ноля считают ложным. Ненулевые значения считают истиной:
<pre>
mysql&gt; SELECT IF(0, 'true', 'false');
+------------------------+
| IF(0, 'true', 'false') |
+------------------------+
| false                  |
+------------------------+

mysql&gt; SELECT IF(1, 'true', 'false');
+------------------------+
| IF(1, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+

mysql&gt; SELECT IF(2, 'true', 'false');
+------------------------+
| IF(2, 'true', 'false') |
+------------------------+
| true                   |
+------------------------+
</pre>

<p>Однако, значения <code>TRUE</code> и <code>FALSE</code> просто псевдонимы
для <code>1</code> и <code>0</code>, соответственно, как показано здесь:
<pre>
mysql&gt; SELECT IF(0 = FALSE, 'true', 'false');
+--------------------------------+
| IF(0 = FALSE, 'true', 'false') |
+--------------------------------+
| true                           |
+--------------------------------+

mysql&gt; SELECT IF(1 = TRUE, 'true', 'false');
+-------------------------------+
| IF(1 = TRUE, 'true', 'false') |
+-------------------------------+
| true                          |
+-------------------------------+

mysql&gt; SELECT IF(2 = TRUE, 'true', 'false');
+-------------------------------+
| IF(2 = TRUE, 'true', 'false') |
+-------------------------------+
| false                         |
+-------------------------------+

mysql&gt; SELECT IF(2 = FALSE, 'true', 'false');
+--------------------------------+
| IF(2 = FALSE, 'true', 'false') |
+--------------------------------+
| false                          |
+--------------------------------+
</pre>
<p>Последние два запроса выводят на экран такие результаты, потому что
<code>2</code> не равно ни <code>1</code>, ни <code>0</code>.</li>

<li><a href="#integer-types"><code>SMALLINT[(<em><code>M</code>
</em>)] [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Маленькое целое число. Диапазон со знаком от
<code>-32768</code> до <code>32767</code>. Диапазон без знака от
<code>0</code> до <code>65535</code>.</li>

<li><a href="#integer-types"><code>MEDIUMINT[(<em><code>M</code>
</em>)] [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Целое число среднего размера. Диапазон со знаком от
<code>-8388608</code> до <code>8388607</code>. Диапазон без знака от
<code>0</code> до <code>16777215</code>.</li>

<li><a href="#integer-types"><code>INT[(<em><code>M</code></em>)]
[UNSIGNED] [ZEROFILL]</code></a></p>
<p>Целое число нормального размера. Диапазон со знаком от
<code>-2147483648</code> до <code>2147483647</code>.
Диапазон без знака от <code>0</code> до <code>4294967295</code>.</li>

<li><a href="#integer-types"><code>INTEGER[(<em><code>M</code>
</em>)] [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Этот тип синоним для <a href="#integer-types"><code>INT</code>
</a>.</li>

<li><a href="#integer-types"><code>BIGINT[(<em><code>M</code></em>)]
[UNSIGNED] [ZEROFILL]</code></a></p>
<p>Большое целое число. Диапазон со знаком от
<code>-9223372036854775808</code> до <code>9223372036854775807</code>.
Диапазон без знака от is <code>0</code> до <code>18446744073709551615</code>.
</p>

<p><code>SERIAL</code> псевдоним для <code>BIGINT
UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE</code>.</p>
<p>Некоторые вещи Вы должны знать относительно столбцов
<a href="#integer-types"><code>BIGINT</code></a>:</p>

<ul><li><p>Вся арифметика сделана, используя знаковые значения
<a href="#integer-types"><code>BIGINT</code></a> или
<a href="#floating-point-types"><code>DOUBLE</code></a>,
таким образом, Вы не должны использовать большие целые числа без знака,
больше <code>9223372036854775807</code> (63 bits), кроме как с разрядными
функциями! Если Вы делаете это, некоторые из последних цифр в результате
могут быть неправильными из-за округления ошибок, преобразовывая
<a href="#integer-types"><code>BIGINT</code></a> в
<a href="#floating-point-types"><code>DOUBLE</code></a>.</p>

<p>MySQL может обработать
<a href="#integer-types"><code>BIGINT</code></a>
в следующих случаях:</p>

<ul><li><p>Используя целые числа, чтобы сохранить большие значения без знака
в столбце <a href="#integer-types"><code>BIGINT</code></a>.</li>
<li>В <a href="funct.htm#function_min"><code>MIN(<em><code>col_name</code>
</em>)</code></a> или <a href="funct.htm#function_max"><code>MAX(<em><code>
col_name</code></em>)</code></a>, где <em><code>col_name</code></em>
обращается к столбцу <a href="#integer-types"><code>BIGINT
</code></a>.</li>

<li>Используя операторы
(<a href="funct.htm#operator_plus"><code>+</code></a>,
<a href="funct.htm#operator_minus"><code>-</code></a>,
<a href="funct.htm#operator_times"><code>*</code></a> и подобные
где оба операнда целые числа.</p></li></ul></li>

<li><p>Вы можете всегда хранить точное целочисленное значение в столбце
<a href="#integer-types"><code>BIGINT</code></a>, используя строку.
В этом случае, MySQL выполняет преобразование строки к числу, которое не
вовлекает промежуточного представления двойной точности.</li>

<li>Операторы <a href="funct.htm#operator_minus"><code>-</code></a>,
<a href="funct.htm#operator_plus"><code>+</code></a> и
<a href="funct.htm#operator_times"><code>*</code></a> применяют арифметику
<a href="#integer-types"><code>BIGINT</code></a>, когда оба операнда
целочисленные значения. Это означает, что, если Вы умножаете два больших
целых числа (или получаете результат из функций, которые возвращают целые
числа), Вы можете получить неожиданные результаты, когда результат больше
<code>9223372036854775807</code>.</p></li></ul></li>

<li><p><a href="#fixed-point-types"><code>DECIMAL[(<em><code>M
</code></em>[,<em><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Упакованное <span>точное</span> число фиксированной точки.
<em><code>M</code></em> общее количество цифр (точность), а
<em><code>D</code></em> число цифр после десятичной запятой (масштаб).
Десятичная запятая и (для отрицательных чисел) знак <code>-</code>
не включены в <em><code>M</code></em>. Если <em><code>D</code></em> 0,
у значений нет никакой десятичной запятой или дробной части. Максимальное
количество цифр (<em><code>M</code></em>) для
<a href="#fixed-point-types"><code>DECIMAL</code></a> 65.
Максимальное количество поддержанных десятичных чисел
(<em><code>D</code></em>) 30. Если <em><code>D</code></em> пропущено,
по умолчанию 0. Если <em><code>M</code></em> пропущено, по умолчанию 10.</p>

<p><code>UNSIGNED</code>, если определено, отвергает отрицательные величины.
</p>
<p>Все основные вычисления (<code>+, -, *, /</code>) со столбцами
<a href="#fixed-point-types"><code>DECIMAL</code></a>
сделаны с точностью в 65 цифр.</li>

<li><a href="#fixed-point-types"><code>DEC[(<em><code>M</code>
</em>[,<em><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code></a>,
<a href="#fixed-point-types"><code>NUMERIC[(<em><code>M</code>
</em>[,<em><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code></a>,
<a href="#fixed-point-types"><code>FIXED[(<em><code>M</code>
</em>[,<em><code>D</code></em>])] [UNSIGNED] [ZEROFILL]</code></a></p>

<p>Эти типы синонимы для
<a href="#fixed-point-types"><code>DECIMAL</code></a>.
<a href="#fixed-point-types"><code>FIXED</code></a> синоним
доступен для совместимости с другими системами базы данных.</li>

<li><a href="#floating-point-types"><code>FLOAT[(<em><code>M</code>
</em>,<em><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Маленькое (одинарная точность) число с плавающей запятой. Допустимые
значения от <code>-3.402823466E+38</code> до <code>-1.175494351E-38</code>,
<code>0</code> и от <code>1.175494351E-38</code> до
<code>3.402823466E+38</code>. Это теоретические пределы, основанные на
стандарте IEEE. Фактический диапазон может быть немного меньшим в зависимости
от Ваших аппаратных средств или операционной системы.</p>

<p><em><code>M</code></em> общее количество цифр и <em><code>D</code></em>
число цифр после десятичной запятой. Если <em><code>M</code></em>
и <em><code>D</code></em> опущены, значения сохранены к пределам, разрешенным
аппаратными средствами. Число одинарной точности с плавающей запятой имеет
приблизительно 7 десятичных разрядов.</p>

<p><code>UNSIGNED</code>, если определено, отвергает отрицательные величины.
</p>
<p>Использование <a href="#floating-point-types"><code>FLOAT</code>
</a> может дать Вам некоторые неожиданные проблемы, потому что все вычисления
в MySQL сделаны с двойной точностью. См.
<a href="error.htm#no-matching-rows">раздел B.5.4.7</a>.</li>

<li><a href="#floating-point-types"><code>DOUBLE[(<em><code>M</code>
</em>,<em><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Нормальный размер (двойная точность) число с плавающей запятой. Допустимые
значения от <code>-1.7976931348623157E+308</code> до
<code>-2.2250738585072014E-308</code>, <code>0</code> и от
<code>2.2250738585072014E-308</code> до <code>1.7976931348623157E+308</code>.
Это теоретические пределы, основанные на стандарте IEEE. Фактический диапазон
может быть немного меньшим в зависимости от Ваших аппаратных средств
или операционной системы.</p>

<p><em><code>M</code></em> общее количество цифр и <em><code>D</code></em>
число цифр после десятичной запятой. Если <em><code>M</code></em>
и <em><code>D</code></em> опущены, значения сохранены к пределам, разрешенным
аппаратными средствами. Число двойной точности с плавающей запятой имеет
приблизительно 15 десятичных разрядов.</p></p>
<p><code>UNSIGNED</code>, если определено, отвергает отрицательные величины.
</p>

<li><a href="#floating-point-types"><code>DOUBLE
PRECISION[(<em><code>M</code></em>,<em><code>D</code></em>)]
[UNSIGNED] [ZEROFILL]</code></a>,
<a href="#floating-point-types"><code>REAL[(<em><code>M</code></em>,
<em><code>D</code></em>)] [UNSIGNED] [ZEROFILL]</code></a></p>

<p>Эти типы синонимы для
<a href="#floating-point-types"><code>DOUBLE</code></a>. Исключение:
если включен режим SQL <a href="server.htm#sqlmode_real_as_float"><code>
REAL_AS_FLOAT</code></a>, <a href="#floating-point-types"><code>
REAL</code></a> синоним для <a href="#floating-point-types"><code>
FLOAT</code></a>, а не для <a href="#floating-point-types"><code>
DOUBLE</code></a>.</li>

<li><a href="#floating-point-types"><code>FLOAT(<em><code>p</code>
</em>) [UNSIGNED] [ZEROFILL]</code></a></p>
<p>Число с плавающей запятой. <em><code>p</em> представляет точность в битах,
но MySQL использует это значение только, чтобы определить, использовать ли
<a href="#floating-point-types"><code>FLOAT</code></a> или
<a href="#floating-point-types"><code>DOUBLE</code></a> для
получающегося типа данных. Если <em><code>p</code></em> от 0 до 24, тип
данных становится <a href="#floating-point-types"><code>FLOAT</code>
</a> без значения <em><code>M</code></em> или <em><code>D</code></em>.
Если <em><code>p</code></em> от 25 до 53, тип данных становится
<a href="#floating-point-types"><code>DOUBLE</code></a>
без значения <em><code>M</code></em> или <em><code>D</code></em>.
Диапазон получающегося столбца то же самое, что касается одинарной точности
<a href="#floating-point-types"><code>FLOAT</code></a> или
двойной точности <a href="#floating-point-types"><code>DOUBLE
</code></a>, описанные ранее в этом разделе.</p>

<p>Синтаксис <a href="#floating-point-types"><code>FLOAT(<em>
<code>p</code></em>)</code></a> предусмотрен для совместимости с ODBC.
</p></li></ul>

<h3><a name="date-and-time-type-overview"></a>12.1.2.
Краткий обзор типов даты и времени</h3>
<p>Для дополнительной информации о свойствах и требованиях хранения временных
типов см. разделы <a href="#date-and-time-types">12.3</a> и
<a href="#storage-requirements">12.8</a>. Для описаний функций,
которые воздействуют на временные значения см.
<a href="funct.htm#date-and-time-functions">раздел 13.7</a>.</p>

<p>Для описания диапазона <a href="#datetime"><code>DATE</code></a>
и <a href="#datetime"><code>DATETIME</code></a>
<span>"поддерживается"</span> означает, что, хотя более ранние
значения могли бы работать, нет никакой гарантии.</p>

<p>MySQL разрешает дробные секунды для значений
<a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a> с точностью до
микросекунд (6 цифр). Чтобы определить столбец, который включает дробную
часть секунд, используйте синтаксис <code><em><code>type_name</code></em>
(<em><code>fsp</code></em>)</code>, где <em><code>type_name</code></em>
<a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a> или
<a href="#datetime"><code>TIMESTAMP</code></a>, а
<em><code>fsp</code></em> дробная точность секунд. Например:
<pre>
CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
</pre>

<p>Значение <em><code>fsp</code></em>, если есть, должно быть в диапазоне от
0 до 6. Значение 0 показывает, что нет никакой дробной части. Если опущено,
точность значения по умолчанию 0. Это отличается от стандартного значения по
умолчанию SQL 6, для совместимости с предыдущими версиями MySQL.</p>

<p>Любой столбец <a href="#datetime"><code>TIMESTAMP</code></a> или
<a href="#datetime"><code>DATETIME</code></a>
в таблице может иметь автоматическую инициализацию и свойства обновления.</p>

<ul><li><p><a href="#datetime"><code>DATE</code></a></p>
<p>Дата. Поддержанный диапазон от <code>'1000-01-01'</code> до
<code>'9999-12-31'</code>. MySQL отображает значения
<a href="#datetime"><code>DATE</code></a> в формате
<code>'YYYY-MM-DD'</code>, но разрешает назначение значений столбцам
<a href="#datetime"><code>DATE</code></a>,
используя строки или числа.</li>

<li>
<a href="#datetime"><code>DATETIME[(<em><code>fsp</code></em>)]</code></a>
</p>

<p>Комбинация даты и времени. Поддержанный диапазон от
<code>'1000-01-01 00:00:00.000000'</code> до
<code>'9999-12-31 23:59:59.999999'</code>. MySQL отображает значения
displays <a href="#datetime"><code>DATETIME</code></a> в формате
<code>'YYYY-MM-DD HH:MM:SS[.fraction]'</code>,
но разрешает назначение значений столбцам
<a href="#datetime"><code>DATETIME</code></a>,
используя строки или числа.</p>

<p>Дополнительное значение <em><code>fsp</code></em> в диапазоне от 0 до 6
может быть дано, чтобы определить дробную точность секунд. Значение 0
показывает, что нет никакой дробной части.
Если опущено, точность значения по умолчанию 0.</p>

<p>Автоматическая инициализация и обновение для столбцов
<a href="#datetime"><code>DATETIME</code></a>
могут быть определены, используя предложения <code>DEFAULT</code> и
<code>ON UPDATE</code>, как описано в
<a href="#timestamp-initialization">разделе 12.3.5</a>.</li>

<li><a href="#datetime"><code>TIMESTAMP[(<em><code>fsp</code></em>)]
</code></a></p>
<p>Метка времени (timestamp). Диапазон от <code>'1970-01-01
00:00:01.000000'</code> UTC до <code>'2038-01-19 03:14:07.999999'</code> UTC.
Значения <a href="#datetime"><code>TIMESTAMP</code></a>
сохранены как число секунд начиная с
<code>'1970-01-01 00:00:00'</code> UTC.
<a href="#datetime"><code>TIMESTAMP</code></a>
не может представить значение <code>'1970-01-01 00:00:00'</code>, потому что
это эквивалентно 0 секундам от начала эпохи, а значение 0 сохранено для того,
чтобы представить <code>'0000-00-00 00:00:00'</code>, <span>нулевое</span>
значение <a href="#datetime"><code>TIMESTAMP</code></a>.</p>

<p>Дополнительное значение <em><code>fsp</code></em> в диапазоне от 0 до 6
может быть дано, чтобы определить дробную точность секунд. Значение 0
показывает, что нет никакой дробной части. Если опущено, точность
значения по умолчанию 0.</p>

<p>Как сервер обрабатывает определения <code>TIMESTAMP</code> зависит
от значения переменной
<a href="server.htm#sysvar_explicit_defaults_for_timestamp"><code>
explicit_defaults_for_timestamp</code></a> (см.
<a href="server.htm#server-system-variables">раздел 6.1.5</a>). По умолчанию
<a href="server.htm#sysvar_explicit_defaults_for_timestamp"><code>
explicit_defaults_for_timestamp</code></a> отключена, и сервер обрабатывает
<code>TIMESTAMP</code> следующим образом:</p>

<p>Если не определено иначе, первый столбец
<a href="#datetime"><code>TIMESTAMP</code></a> в таблице
определен, чтобы быть автоматически установленным в дату и время новой
модификации если значение не назначено явно. Это делает
<a href="#datetime"><code>TIMESTAMP</code></a> полезным для записи
моментов операций <a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#update"><code>UPDATE</code></a>. Вы можете также установить
любой столбец <a href="#datetime"><code>TIMESTAMP</code></a>
к текущей дате и времени, назначая ему значение <code>NULL</code>, если это
не было определено с атрибутом <code>NULL</code>,
чтобы разрешить <code>NULL</code>.</p>

<p>Автоматическая инициализация и обновление к текущей дате и времени может
быть определено, используя предложения <code>DEFAULT CURRENT_TIMESTAMP</code>
и <code>ON UPDATE CURRENT_TIMESTAMP</code>. По умолчанию первый столбец
<a href="#datetime"><code>TIMESTAMP</code></a> имеет
эти свойства, как ранее отмечено. Однако, любой столбец
<a href="#datetime"><code>TIMESTAMP</code></a>
в таблице может быть определен, чтобы иметь эти свойства.</p>

<p>Если <a href="server.htm#sysvar_explicit_defaults_for_timestamp"><code>
explicit_defaults_for_timestamp</code></a> включен, нет никакого
автоматического назначения атрибутов <code>DEFAULT CURRENT_TIMESTAMP</code>
или <code>ON UPDATE CURRENT_TIMESTAMP</code> любому столбцу
<a href="#datetime"><code>TIMESTAMP</code></a>.
Они должны быть включены явно в определении столбца. Кроме того, любой
<a href="#datetime"><code>TIMESTAMP</code></a>, не объявленный явно
как <code>NOT NULL</code>, допускает значения <code>NULL</code>.</li>

<li><a href="#time"><code>TIME[(<em><code>fsp</code></em>)]</code>
</a></p>
<p>Время. Диапазон от <code>'-838:59:59.000000'</code> до
<code>'838:59:59.000000'</code>. MySQL отображает значения
<a href="#time"><code>TIME</code></a> в формате
<code>'HH:MM:SS[.fraction]'</code>, но позволяет задавать значения столбцов
<a href="#time"><code>TIME</code></a>, используя строки или числа.
</p>

<p>Дополнительное значение <em><code>fsp</code></em> в диапазоне от 0 до 6
может быть дано, чтобы определить дробную точность секунд. Значение 0
показывает, что нет никакой дробной части. Если опущено, точность
значения по умолчанию 0.</li>

<li><a href="#year"><code>YEAR[(4)]</code></a></p>
<p>Год в формате с четырьмя цифрами. MySQL отображает значения
<a href="#year"><code>YEAR</code></a> в формате <code>YYYY</code>,
но позволяет задавать значения столбцов
<a href="#year"><code>YEAR</code></a>, используя строки или числа.
Значения показываются от <code>1901</code> до <code>2155</code> и
<code>0000</code>.</p>

<p>Для дополнительной информации о формате и интерпретации входных значений
<a href="#year"><code>YEAR</code></a> см.
<a href="#year">раздел 12.3.3</a>.</p>

<p>MySQL 8.0 не поддерживает тип данных
<a href="#year"><code>YEAR(2)</code></a>, разрешенный в более старых
версиях MySQL. Для инструкций по преобразованию в
to <a href="#year"><code>YEAR(4)</code></a> см.
<a href="#migrating-to-year4">раздел 12.3.4</a>.</p></li></ul>

<p>Совокупные функции <a href="funct.htm#function_sum"><code>SUM()</code></a>
и <a href="funct.htm#function_avg"><code>AVG()</code></a> не работают с
временными значениями. Они преобразовывают значения в числа, теряя все после
первого нечислового символа. Чтобы обойти эту проблему, преобразуйте в
числовые модули, выполните совокупную работу и преобразуйте назад во
временное значение. Примеры:
<pre>
SELECT SEC_TO_TIME(SUM(TIME_TO_SEC(<em><code>time_col</code></em>))) FROM <em><code>tbl_name</code></em>;
SELECT FROM_DAYS(SUM(TO_DAYS(<em><code>date_col</code></em>))) FROM <em><code>tbl_name</code></em>;
</pre>

<p>Сервер MySQL может быть выполнен в режиме SQL
<a href="server.htm#sqlmode_maxdb"><code>MAXDB</code></a>.
В этом случае <a href="#datetime"><code>TIMESTAMP</code></a>
идентично <a href="#datetime"><code>DATETIME</code></a>.
Если этот режим включен в то время, когда таблица составлена, столбец
<a href="#datetime"><code>TIMESTAMP</code></a> создан как
<a href="#datetime"><code>DATETIME</code></a>. В результате такое
использование столбцов <a href="#datetime"><code>DATETIME</code></a>
имеет тот же самый диапазон значений, и нет никакой автоматической
инициализации или обновления к текущей дате и времени. См.
<a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<h3><a name="string-type-overview"></a>12.1.3. Краткий обзор строк</h3>
<p>В некоторых случаях MySQL может изменить строковый столбец на тип,
отличающийся от данного в <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> или <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>. См. <a href="sql.htm#silent-column-changes">раздел 14.1.15.4</a>.</p>

<p>MySQL интерпретирует технические требования длины в символьных
определениях столбца в символьных модулях. Это относится к типам
<a href="#char"><code>CHAR</code></a>,
<a href="#char"><code>VARCHAR</code></a> и
<a href="#blob"><code>TEXT</code></a>.</p>

<p>Определения столбца для многих строковых типов данных могут включать
признаки, которые определяют набор символов или сопоставление столбца. Эти
признаки относятся к типам <a href="#char"><code>CHAR</code></a>,
<a href="#char"><code>VARCHAR</code></a>,
<a href="#blob"><code>TEXT</code></a>,
<a href="#enum"><code>ENUM</code></a> и
<a href="#set"><code>SET</code></a>.</p>

<ul><li><p>Признак <code>CHARACTER SET</code> определяет набор символов, а
<code>COLLATE</code> определяет сопоставление для набора символов. Например:
<pre>
CREATE TABLE t (c1 VARCHAR(20) CHARACTER SET utf8,
                c2 TEXT CHARACTER SET latin1 COLLATE latin1_general_cs);
</pre>

<p>Это табличное определение создает столбец, названный <code>c1</code>,
который имеет набор символов <code>utf8</code> с сопоставлением по умолчанию
для того набора символов, и столбец <code>c2</code>, у которого есть набор
символов <code>latin1</code> и чувствительное к регистру сопоставление.</p>

<p>Правила для того, чтобы назначить набор символов и сопоставление, когда
один или оба атрибута <code>CHARACTER SET</code> и <code>COLLATE</code>
отсутствуют, описаны в <a href="global.htm#charset-column">разделе 11.1.3.5
</a>.</p>
<p><code>CHARSET</code> синоним для <code>CHARACTER SET</code>.</li>

<li>Определение атрибута <code>CHARACTER SET binary</code>
для типа данных строки символов заставляет столбец создаваться как
соответствующий двоичный строковый тип данных:
<a href="#char"><code>CHAR</code></a> станет
<a href="#binary-varbinary"><code>BINARY</code></a>,
<a href="#char"><code>VARCHAR</code></a> станет
<a href="#binary-varbinary"><code>VARBINARY</code></a>, а
<a href="#blob"><code>TEXT</code></a> станет
<a href="#blob"><code>BLOB</code></a>.Для типов
<a href="#enum"><code>ENUM</code></a> и
<a href="#set"><code>SET</code></a> этого не происходит: они
создаются как объявлено. Предположите, что Вы определяете таблицу,
используя это определение:
<pre>
CREATE TABLE t (c1 VARCHAR(10) CHARACTER SET binary,
                c2 TEXT CHARACTER SET binary,
                c3 ENUM('a','b','c') CHARACTER SET binary);
</pre>

<p>У получающейся таблицы есть это определение:
<pre>
CREATE TABLE t (c1 VARBINARY(10), c2 BLOB,
                c3 ENUM('a','b','c') CHARACTER SET binary);
</pre></li>

<li>Признак <code>BINARY</code> стенография для того, чтобы определить
табличный набор символов по умолчанию и сопоставление <code>_bin</code>
того набора символов. В этом случае, сравнение и сортировка основаны на
значениях кодов символов.</li>

<li>Атрибут <code>ASCII</code> сокращение для
<code>CHARACTER SET latin1</code>.</li>
<li>Атрибут <code>UNICODE</code> сокращение для
<code>CHARACTER SET ucs2</code>.</p></li></ul>

<p>Символьное сравнение столбца и сортировка основаны на сопоставлении,
назначенном столбцу. Для типов <a href="#char"><code>CHAR</code></a>,
<a href="#char"><code>VARCHAR</code></a>,
<a href="#blob"><code>TEXT</code></a>,
<a href="#enum"><code>ENUM</code></a> и
<a href="#set"><code>SET</code></a> Вы можете объявить столбец с
двоичным сопоставлением (<code>_bin</code>) или признаком
<code>BINARY</code>, чтобы использовать основные символьные кодовые
обозначения, а не лексическое упорядочивание.</p>

<ul><li><p><code>[NATIONAL] CHAR[(<em><code>M</code></em>)]
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></p>

<p>Строка фиксированной длины, которая всегда дополнена справа пробелами
до указанной длины, когда сохранена. <em><code>M</code></em>
представляет длину столбца в символах. Диапазон <em><code>M</code></em> от 0
до 255. Если <em><code>M</code></em> опущен, длина 1.</p>

<p>Конечные пробелы удалены, когда значения
<a href="#char"><code>CHAR</code></a> получены, если режим SQL
<a href="server.htm#sqlmode_pad_char_to_full_length">
<code>PAD_CHAR_TO_FULL_LENGTH</code></a> выключен.</p>

<p><a href="#char"><code>CHAR</code></a> сокращение для
<a href="#char"><code>CHARACTER</code></a>.
<a href="#char"><code>NATIONAL CHAR</code></a> (или
<a href="#char"><code>NCHAR</code></a>) стандартный способ SQL
определить, что столбец <a href="#char"><code>CHAR</code></a> должен
использовать некоторый предопределенный набор символов. MySQL использует
<code>utf8</code> как этот предопределенный набор символов.</p>

<p>Тип <a href="#binary-varbinary"><code>CHAR BYTE</code></a>
псевдоним для <a href="#binary-varbinary"><code>BINARY</code></a>.
Это особенность совместимости.</p>

<p>MySQL разрешает Вам создавать столбец типа <code>CHAR(0)</code>.
Это полезно прежде всего, когда Вы должны быть совместимы со старыми
приложениями, которые зависят от существования столбца, но которые фактически
не используют его значение. <code>CHAR(0)</code> также довольно хорош, когда
Вы нуждаетесь в столбце, который может взять только два значения: столбец,
который определен как <code>CHAR(0) NULL</code> занимает только один бит и
может взять только значения <code>NULL</code> и <code>''</code>
(пустая строка).</li>

<li><code>[NATIONAL] VARCHAR(<em><code>M</code></em>)
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></p>

<p>Строка переменной длины. <em><code>M</code></em>
представляет максимальную длину столбца в символах. Диапазон
<em><code>M</code></em> от 0 до 65535. Эффективная максимальная длина
<a href="#char"><code>VARCHAR</code></a> зависит от максимального
размера строки (65 535 байтов, который совместно использован всеми
столбцами), и используемого набора символов. Например, символы
<code>utf8</code> могут потребовать до трех байтов на символ, таким образом,
столбец <a href="#char"><code>VARCHAR</code></a>, который использует
набор символов <code>utf8</code> имеет максимумом 21844 символа. См.
<a href="restr.htm#column-count-limit">раздел C.10.4</a>.</p>

<p>MySQL хранит значения <a href="#char"><code>VARCHAR</code></a>
как префикс в 1 или 2 байта плюс данные. Префикс длины указывает на число
байтов в значении. Столбец <a href="#char"><code>VARCHAR</code></a>
использует один байт длины, если значения требуют не больше 255 байтов, два
байта длины, если значения могут потребовать больше, чем 255 байтов.</p>

<p>MySQL следует за стандартной спецификацией SQL и
<span><em>НЕ</em></span> удаляет конечные пробелы из значений
<a href="#char"><code>VARCHAR</code></a>.</p>

<p><a href="#char"><code>VARCHAR</code></a> сокращение для
<a href="#char"><code>CHARACTER VARYING</code></a>.
<a href="#char"><code>NATIONAL VARCHAR</code></a> стандартный способ
SQL определить, что столбец <a href="#char"><code>VARCHAR</code></a>
должен использовать некоторый предопределенный набор символов. MySQL
использует <code>utf8</code> как этот предопределенный набор символов.
<a href="#char"><code>NVARCHAR</code></a> сокращение для
<a href="#char"><code>NATIONAL VARCHAR</code></a>.</li>

<li><a href="#binary-varbinary"><code>BINARY(<em><code>M</code>
</em>)</code></a></p>
<p>Тип <a href="#binary-varbinary"><code>BINARY</code></a> подобен
<a href="#char"><code>CHAR</code></a>, но хранит двоичные строки
байтов, а не недвоичные строки символов.</li>

<li><a href="#binary-varbinary"><code>VARBINARY(<em><code>M</code>
</em>)</code></a></p>
<p>Тип <a href="#binary-varbinary"><code>VARBINARY</code></a>
подобен <a href="#char"><code>VARCHAR</code></a>, но хранит двоичные
строки байтов, а не недвоичные строки символов. <em><code>M</code></em>
представляет максимальную длину столбца в байтах.</li>

<li><a href="#blob"><code>TINYBLOB</code></a></p>
<p>Столбец <a href="#blob"><code>BLOB</code></a>
с максимальной длиной 255 (2<sup>8</sup>-1) байт. Каждое значение
<a href="#blob"><code>TINYBLOB</code></a> сохранено, используя
1-байтовую приставку длины, которая указывает на число байтов в значении.
</li>

<li><a href="#blob"><code>TINYTEXT
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></a></p>
<p>Столбец <a href="#blob"><code>TEXT</code></a> с максимальной
длиной (2<sup>8</sup>-1). Эффективная максимальная длина меньше, если
значение содержит мультибайтные символы. Каждое значение
<a href="#blob"><code>TINYTEXT</code></a> сохранено, используя
1-байтовую приставку длины, которая указывает на число байтов в значении.
</li>

<li><a href="#blob"><code>BLOB[(<em><code>M</code></em>)]</code></a>
</p>
<p>Столбец <a href="#blob"><code>BLOB</code></a> с максимальной
длиной 65535 (2<sup>16</sup>-1) байт. Каждое значение
<a href="#blob"><code>BLOB</code></a> сохранено, используя
2-байтовую приставку длины, которая указывает на число байтов в значении.
</p>

<p>Дополнительная длина <em><code>M</code></em> может быть дана для этого
типа. Если это сделано, MySQL создает столбец как самый маленький тип
<a href="#blob"><code>BLOB</code></a> достаточно большой, чтобы
содержать значения длиной в <em><code>M</code></em> байт.</li>

<li><a href="#blob"><code>TEXT[(<em><code>M</code></em>)]
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></a></p>

<p>Столбец <a href="#blob"><code>TEXT</code></a> с максимальной
длиной 65535 (2<sup>16</sup>-1) символов. Эффективная максимальная длина
меньше, если значение содержит мультибайтные символы. Каждое значение
<a href="#blob"><code>TEXT</code></a> сохранено, используя
2-байтовую приставку длины, которая указывает на число байтов в значении.</p>

<p>Дополнительная длина <em><code>M</code></em> может быть дана для этого
типа. Если это сделано, MySQL создает столбец как самый маленький тип
<a href="#blob"><code>TEXT</code></a> достаточно большой, чтобы
содержать значения длиной в <em><code>M</code></em> байт.</li>

<li><a href="#blob"><code>MEDIUMBLOB</code></a></p>
<p>Столбец <a href="#blob"><code>BLOB</code></a> с максимальной
длиной в 16,777,215 (2<sup>24</sup>-1) байт. Каждое значение
<a href="#blob"><code>MEDIUMBLOB</code></a> сохранено, используя
3-байтовую приставку длины, которая указывает на число байтов в значении.
</li>

<li><a href="#blob"><code>MEDIUMTEXT
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></a></p>

<p>Столбец <a href="#blob"><code>TEXT</code></a> с максимальной
длиной в 16,777,215 (2<sup>24</sup>-1) символов. Эффективная максимальная
длина меньше, если значение содержит мультибайтные символы. Каждое значение
<a href="#blob"><code>MEDIUMTEXT</code></a> сохранено, используя
3-байтовую приставку длины, которая указывает на число байтов в значении.
</li>

<li><a href="#blob"><code>LONGBLOB</code></a></p>
<p>Столбец <a href="#blob"><code>BLOB</code></a> с максимальной
длиной в 4,294,967,295 байт или 4GB (2<sup>32</sup>-1). Эффективная
максимальная длина <a href="#blob"><code>LONGBLOB</code></a>
зависит от сконфигурированного максимального пакетного размера в протоколе
клиент-сервер и доступной памяти. Каждое значение
<a href="#blob"><code>LONGBLOB</code></a> сохранено, используя
4-байтовую приставку длины, которая указывает на число байтов в значении.
</li>

<li><a href="#blob"><code>LONGTEXT
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></a></p>

<p>Столбец <a href="#blob"><code>TEXT</code></a> с максимальной
длиной в 4,294,967,295 или 4GB (2<sup>32</sup>-1) символов. Эффективная
максимальная длина меньше, если значение содержит мультибайтные символы.
Эффективная максимальная длина столбцов
<a href="#blob"><code>LONGTEXT</code></a> также зависит от
сконфигурированного максимального пакетного размера в протоколе клиент-сервер
и доступной памяти. Каждое значение
<a href="#blob"><code>LONGTEXT</code></a> сохранено, используя
4-байтовую приставку длины, которая указывает на число байтов в значении.
</li>

<li><a href="#enum"><code>ENUM('<em><code>value1</code></em>',
'<em><code>value2</code></em>',...)
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></a></p>

<p>Перечисление. Строковый объект, у которого может быть только одно
значение, выбранное из списка значений
<code>'<em><code>value1</code></em>'</code>,
<code>'<em><code>value2</code></em>'</code>,
<code>...</code>, <code>NULL</code> или специальное ошибочное значение
<code>''</code>. Значения <a href="#enum"><code>ENUM</code></a>
представлены внутренне как целые числа.</p>
<p>У столбца <a href="#enum"><code>ENUM</code></a> может быть
максимум 65535 отличных элементов.</li>

<li><a href="#set"><code>SET('<em><code>value1</code></em>',
'<em><code>value2</code></em>',...)
[CHARACTER SET <em><code>charset_name</code></em>]
[COLLATE <em><code>collation_name</code></em>]</code></a></p>

<p>Набор. Строковый объект, у которого может быть ноль или больше значений,
каждое из которых должно быть выбрано из списка значений
<code>'<em><code>value1</code></em>'</code>,
<code>'<em><code>value2</code></em>'</code>,
<code>...</code>. Значения <a href="#set"><code>SET</code></a>
представлены внутренне как целые числа.</p>
<p>У столбца <a href="#set"><code>SET</code></a> может быть
максимум 64 отличных участника.</p></li></ul>

<h2><a name="numeric-types"></a>12.2. Числовые типы</h2>
<p>MySQL поддерживает все стандартные типы числовых данных SQL. Эти типы
включают точные типы числовых данных
(<a href="#integer-types"><code>INTEGER</code></a>,
<a href="#integer-types"><code>SMALLINT</code></a>,
<a href="#fixed-point-types"><code>DECIMAL</code></a> и
<a href="#fixed-point-types"><code>NUMERIC</code></a>),
так же как приблизительные типы числовых данных
(<a href="#floating-point-types"><code>FLOAT</code></a>,
<a href="#floating-point-types"><code>REAL</code></a> и
<a href="#floating-point-types"><code>DOUBLE PRECISION</code></a>).
Ключевое слово <a href="#integer-types"><code>INT</code></a>
синоним для <a href="#integer-types"><code>INTEGER</code></a>, а
<a href="#fixed-point-types"><code>DEC</code></a> и
<a href="#fixed-point-types"><code>FIXED</code></a> синонимы для
<a href="#fixed-point-types"><code>DECIMAL</code></a>. MySQL
обрабатывает <a href="#floating-point-types"><code>DOUBLE</code></a>
как синоним для <a href="#floating-point-types"><code>DOUBLE
PRECISION</code></a> (нестандартное расширение). MySQL также обрабатывает
<a href="#floating-point-types"><code>REAL</code></a> как синоним
<a href="#floating-point-types"><code>DOUBLE PRECISION</code></a>
(нестандартное расширение), если включен режим SQL
<a href="server.htm#sqlmode_real_as_float"><code>REAL_AS_FLOAT</code></a>.
</p>

<p>Тип данных <a href="#bit-type"><code>BIT</code></a>
хранит битовые значения и поддержан для
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>,
<a href="storage.htm#memory-storage-engine"><code>MEMORY</code></a> и
<a href="innodb.htm"><code>InnoDB</code></a>.</p>

<p>Для информации о том, как MySQL обрабатывает назначение значений из
диапазона столбцам и переполнение во время оценки выражения см.
<a href="#out-of-range-and-overflow">раздел 12.2.6</a>.</p>

<p>Для информации о числовых требованиях хранения типа см.
<a href="#storage-requirements">раздел 12.8</a>.</p>
<p>Тип данных, используемый для результата вычисления на числовых операндах,
зависит от типов операндов и операций, выполненных на них. Для получения
дополнительной информации см.
<a href="funct.htm#arithmetic-functions">раздел 13.6.1</a>.</p>

<h3><a name="integer-types"></a>12.2.1. Типы целого числа (точное значение)
INTEGER, INT, SMALLINT, TINYINT, MEDIUMINT, BIGINT</h3>
<p>MySQL поддерживает стандартные типы целого числа SQL
<code>INTEGER</code> (или <code>INT</code>) и <code>SMALLINT</code>.
Как расширение к стандарту, MySQL также поддерживает типы целого числа
<code>TINYINT</code>, <code>MEDIUMINT</code> и <code>BIGINT</code>.
Следующая таблица показывает необходимое место для хранения и диапазон для
каждого типа целого числа.</p>

<table border="1">
<thead><tr><th scope="col">Тип</th><th scope="col">Место</th>
<th scope="col">Минимум</th><th scope="col">Максимум</th></tr>
<tr><th scope="col"> </th><th scope="col">(байтов)</th>
<th scope="col">(Signed/Unsigned)</th>
<th scope="col">(Signed/Unsigned)</th></tr></thead>
<tbody><tr><td scope="row"><code>TINYINT</code></td><td>1</td>
<td><code>-128</code></td><td><code>127</code></td></tr>
<tr><td scope="row"> </td><td> </td><td><code>0</code></td>
<td><code>255</code></td></tr>
<tr><td scope="row"><code>SMALLINT</code></td><td>2</td>
<td><code>-32768</code></td><td><code>32767</code></td></tr>
<tr><td scope="row"> </td><td> </td><td><code>0</code></td>
<td><code>65535</code></td></tr>
<tr><td scope="row"><code>MEDIUMINT</code></td><td>3</td>
<td><code>-8388608</code></td><td><code>8388607</code></td></tr>
<tr><td scope="row"> </td><td> </td><td><code>0</code></td>
<td><code>16777215</code></td></tr>
<tr><td scope="row"><code>INT</code></td><td>4</td>
<td><code>-2147483648</code></td><td><code>2147483647</code></td></tr>
<tr><td scope="row"> </td><td> </td><td><code>0</code></td>
<td><code>4294967295</code></td></tr>
<tr><td scope="row"><code>BIGINT</code></td><td>8</td>
<td><code>-9223372036854775808</code></td><td><code>9223372036854775807
</code></td></tr>
<tr><td scope="row"> </td><td> </td><td><code>0</code></td>
<td><code>18446744073709551615</code></td></tr></tbody></table>

<h3><a name="fixed-point-types"></a>12.2.2. Типы с фиксированной точкой
(точное значение) DECIMAL, NUMERIC</h3>
<p>Типы <code>DECIMAL</code> и <code>NUMERIC</code> хранят точные значения
числовых данных. Эти типы используются, когда важно сохранить абсолютную
точность, например с денежно-кредитными данными. В MySQL <code>NUMERIC</code>
осуществлен как <code>DECIMAL</code>, так что следующие замечания о
<code>DECIMAL</code> одинаково относятся к <code>NUMERIC</code>.</p>

<p>MySQL хранит значения <code>DECIMAL</code> в двоичном формате. См.
<a href="funct.htm#precision-math">раздел 13.20</a>.</p>

<p>В определении столбца <code>DECIMAL</code> могут быть определены точность
и масштаб (обычно так и бывает), например:
<pre>
salary DECIMAL(5,2)
</pre>

<p>В этом примере <code>5</code> точность и <code>2</code> масштаб. Точность
представляет число существенных цифр, которые сохранены для значений, а
масштаб представляет число цифр, которые могут быть сохранены
после десятичной запятой.</p>

<p>Стандартный SQL требует, чтобы <code>DECIMAL(5,2)</code> мог
сохранить любое значение с пятью цифрами и двумя десятичными числами, так
значения, которые могут быть сохранены в столбце <code>salary</code> в
диапазоне от <code>-999.99</code> до <code>999.99</code>.</p>

<p>В стандартном SQL синтаксис
<code>DECIMAL(<em><code>M</code></em>)</code> эквивалентен
<code>DECIMAL(<em><code>M</code></em>,0)</code>. Точно так же синтаксис
<code>DECIMAL</code> эквивалентен
<code>DECIMAL(<em><code>M</code></em>,0)</code>, где
выполнению разрешают решить значение <em><code>M</code></em>.
поддерживает обе эти формы синтаксиса <code>DECIMAL</code>.
Значение по умолчанию <em><code>M</code></em> 10.</p>

<p>Если масштаб 0, значения <code>DECIMAL</code> не содержат десятичной
запятой или дробной части.</p>
<p>Максимальное количество цифр для <code>DECIMAL</code> 65, но фактический
диапазон для данного столбца <code>DECIMAL</code> может быть ограничен
точностью или масштабом для данного столбца. Когда такому столбцу назначают
значение с большим количеством цифр после десятичной запятой, чем разрешено
указанным масштабом, значение преобразовано в тот масштаб. Точное поведение
работает в зависимости от системы, но вообще эффектом будет усечение к
допустимому числу цифр.</p>

<h3><a name="floating-point-types"></a>12.2.3.
Типы с плавающей запятой (приблизительная точность) FLOAT, DOUBLE</h3>
<p>Типы <code>FLOAT</code> и <code>DOUBLE</code> представляют приблизительные
значения числовых данных. MySQL использует четыре байта для значений
одинарной точности и восемь байтов для значений двойной точности.</p>

<p>Для <code>FLOAT</code> стандарт SQL разрешает дополнительную спецификацию
точности (но не диапазон экспоненты) в битах после ключевого слова
<code>FLOAT</code> в круглых скобках. MySQL также поддерживает эту
дополнительную спецификацию точности, но значение точности используется
только, чтобы определить размер хранения. Результаты точностью от 0 до 23
хранятся в 4-байтовом столбце <code>FLOAT</code> одинарной точности.
Результаты точностью от 24 до 53 хранятся в 8-байтовом столбце
<code>DOUBLE</code> двойной точности.</p>

<p>MySQL разрешает нестандартный синтаксис:
<code>FLOAT(<em><code>M</code></em>,<em><code>D</code></em>)</code> или
<code>REAL(<em><code>M</code></em>,<em><code>D</code></em>)</code> или
<code>DOUBLE PRECISION(<em><code>M</code></em>,<em><code>D</code></em>)
</code>. Здесь <code>(<em><code>M</code></em>,<em><code>D</code></em>)</code>
означает, что значения могут быть сохранены размером до
<em><code>M</code></em> цифр всего из них <em><code>D</code></em> цифр могут
быть после десятичной запятой. Например, столбец, определенный как
<code>FLOAT(7,4)</code> будет выглядеть как <code>-999.9999</code> при
отображении. MySQL выполняет округление, сохраняя значения, так, если Вы
вставляете <code>999.00009</code> в столбец <code>FLOAT(7,4)</code>,
приблизительный результат будет <code>999.0001</code>.</p>

<p>Поскольку значения с плавающей запятой приблизительны и не сохранены как
точные значения, попытки обработать их как точные в сравнениях могут привести
к проблемам. Они также подвергаются зависимостям от выполнения или платформы.
Для получения дополнительной информации см.
<a href="error.htm#problems-with-float">раздел B.5.4.8</a>.</p>

<p>Для максимальной мобильности хранения код, требующий приблизительных
значений числовых данных, должен использовать <code>FLOAT</code> или
<code>DOUBLE PRECISION</code> без спецификации точности или числа цифр.</p>

<h3><a name="bit-type"></a>12.2.4. Тип битового значения BIT</h3>
<p>Тип <code>BIT</code> используется, чтобы сохранить битовые значения. Тип
<code>BIT(<em><code>M</code></em>)</code> включает хранение
<em><code>M</code></em>-битовых значений. <em><code>M</code></em>
может колебаться от 1 до 64.</p>

<p>Определить битовые значения можно в нотации
<code>b'<em><code>value</code></em>'</code>. <em><code>value</code></em>
двоичное значение из нулей и единиц. Например, <code>b'111'</code> и
<code>b'10000000'</code> означают соответственно 7 и 128. См.
<a href="lang.htm#bit-value-literals">раздел 10.1.5</a>.</p>

<p>Если Вы назначаете значение столбцу
<code>BIT(<em><code>M</code></em>)</code>, которое меньше
<em><code>M</code></em> бит, значение дополнено слева нолями.
Например, назначая значение <code>b'101'</code> столбцу <code>BIT(6)</code>,
в действительности Вы делаете то же самое, как назначая
<code>b'000101'</code>.</p>

<h3><a name="numeric-type-attributes"></a>12.2.5. Числовые признаки типа</h3>
<p>MySQL поддерживает расширение для того, чтобы произвольно определить
ширину типов данных целого числа в круглых скобках после основного ключевого
слова для типа. Например,
<a href="#integer-types"><code>INT(4)</code></a> определяет
<a href="#integer-types"><code>INT</code></a> с шириной отображения
четыре цифры. Эта дополнительная ширина может использоваться приложениями,
чтобы вывести на экран целочисленные значения, имеющие ширину меньше ширины,
определенной для столбца, дополняя их слева пробелами. Таким образом, эта
ширина присутствует в метаданных, возвращенных с наборами результатов.
Используется ли это или нет, зависит от приложения.</p>

<p>Ширина отображения <span><em>НЕ</em></span> ограничивает диапазон
значений, которые могут быть сохранены в столбце. И при этом это не мешает
вывести на экран правильно значения шире, чем ширина отображения столбца.
Например, столбец, определенный как
<a href="#integer-types"><code>SMALLINT(3)</code></a> имеет обычный
<a href="#integer-types"><code>SMALLINT</code></a> диапазон от
<code>-32768</code> до <code>32767</code>, и значения вне диапазона,
разрешенного тремя цифрами, выведены на экран в полном использовании больше,
чем трех цифр.</p>

<p>Когда используется в соединении с дополнительным (нестандартным) признаком
<code>ZEROFILL</code>, дополнение значения по умолчанию пробелами заменено
нолями. Например, для столбца, объявленного как
<a href="#integer-types"><code>INT(4) ZEROFILL</code></a>, значение
<code>5</code> будет <code>0005</code>.</p>

<p>Признак <code>ZEROFILL</code> проигнорирован, когда столбец вовлечен в
выражения или запрос <a href="sql.htm#union"><code>UNION</code></a>.</p>
<p>Если Вы храните значения больше, чем ширина отображения в столбце целого
числа, который имеет признак <code>ZEROFILL</code>, Вы можете испытать
проблемы, когда MySQL производит временные таблицы для некоторых сложных
соединений. В этих случаях MySQL предполагает, что значения данных
соответствуют пределам ширины отображения столбца.</p>

<p>У всех типов целого числа может быть дополнительный (нестандартный)
признак <code>UNSIGNED</code>. Тип без знака может использоваться,
чтобы разрешить только неотрицательные числа в столбце или когда Вы
нуждаетесь в большем верхнем числовом диапазоне для столбца. Например, если
столбец <a href="#integer-types"><code>INT</code></a>
<code>UNSIGNED</code>, размер диапазона столбца тот же самый, но его конечные
точки сдвигаются от <code>-2147483648</code> и <code>2147483647</code>
к <code>0</code> и <code>4294967295</code>.</p>

<p>Типы с плавающей запятой и фиксированной точки также могут быть
<code>UNSIGNED</code>. Как с типами целого числа, этот признак препятствует
тому, чтобы отрицательные величины были сохранены в столбце. В отличие от
типов целого числа, верхний диапазон значений столбцов остается тем же самым.
</p>

<p>Если Вы определяете <code>ZEROFILL</code> для числового столбца, MySQL
автоматически добавляет <code>UNSIGNED</code>.</p>
<p>У целого числа или типов данных с плавающей запятой может быть
дополнительный признак <code>AUTO_INCREMENT</code>. Когда Вы вставляете
значение <code>NULL</code> в индексированный столбец
<code>AUTO_INCREMENT</code>, реально он будет установлен в следующее
значение последовательности. Как правило, это
<code><em><code>value</code></em>+1</code>, где <em><code>value</code></em>
самое большое значение для столбца в настоящее время в таблице.
Последовательности <code>AUTO_INCREMENT</code> начинаются с <code>1</code>.
</p>

<p>Сохранение <code>0</code> в столбец <code>AUTO_INCREMENT</code> имеет тот
же самый эффект, как запись <code>NULL</code>, если включен режим SQL
<a href="server.htm#sqlmode_no_auto_value_on_zero">
<code>NO_AUTO_VALUE_ON_ZERO</code></a>.</p>

<p>Вставка <code>NULL</code> для генерации значений
<code>AUTO_INCREMENT</code> требует, чтобы столбец был объявлен
<code>NOT NULL</code>. Если столбец объявлен <code>NULL</code>, вставка
<code>NULL</code> сохранит именно <code>NULL</code>. Когда Вы вставляете
любое другое значение в столбец <code>AUTO_INCREMENT</code>, он
установлен в это значение, а последовательность сброшена так, чтобы следующее
автоматически произведенное значение следовало последовательно
из вставленного значения.</p>
<p>В MySQL 8.0 отрицательные величины для столбцов
<code>AUTO_INCREMENT</code> не поддержаны.</p>

<h3><a name="out-of-range-and-overflow"></a>12.2.6.
Обработка переполнения и выхода из диапазона</h3>
<p>Когда MySQL сохраняет значение в числовом столбце, которое вне допустимого
диапазона типа данных столбца, результат зависит от режима SQL в это время:
</p>

<ul><li><p>Если строгий режим SQL включен, MySQL отклоняет значение
с ошибкой, и вставка терпит неудачу, в соответствии со стандартом SQL.</li>
<li>Если никакие строгие режимы не включены, MySQL отсекает значение к
соответствующей конечной точке диапазона и хранит получающееся значение.</p>

<p>Когда значение вне диапазона назначено столбцу целого числа, MySQL
сохранит значение, представляющее соответствующую конечную точку диапазона
типа данных столбца. Если Вы сохраните 256 в
<a href="#integer-types"><code>TINYINT</code></a> или
<code>TINYINT UNSIGNED</code>, MySQL запишет соответственно 127 или 255.</p>

<p>Когда столбцу с плавающей запятой или столбцу фиксированной точки
назначают значение, которое превышает диапазон, подразумеваемый указанными
(или значением по умолчанию) точностью и масштабом, MySQL сохранит значение,
представляющее соответствующую конечную точку того диапазона.
</p></li></ul>

<p>О преобразованиях назначения столбца, которые происходят из-за отсечения,
когда MySQL не работает в строгом режиме, сообщают предупреждения для
for <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
<a href="sql.htm#load-data"><code>LOAD DATA INFILE</code></a>,
<a href="sql.htm#update"><code>UPDATE</code></a> и
multiple-row <a href="sql.htm#insert"><code>INSERT</code></a>.
В строгом режиме терпят неудачу эти запросы, и некоторые или все значения не
будут введены или изменены, в зависимости от того, является ли таблица
транзакционной таблицей и другими факторами. Для деталей см.
<a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<p>Переполнение во время числовой оценки выражения приводит к ошибке.
Например, самое большое значение
<a href="#integer-types"><code>BIGINT</code></a> со знаком
9223372036854775807, таким образом, следующее выражение производит ошибку:
<pre>
mysql&gt; SELECT 9223372036854775807 + 1;
ERROR 1690 (22003): BIGINT value is out of range in '(9223372036854775807+1)'
</pre>

<p>Чтобы позволить работе преуспеть в этом случае,
преобразуйте значение в беззнаковое;
<pre>
mysql&gt; SELECT CAST(9223372036854775807 AS UNSIGNED) + 1;
+-------------------------------------------+
| CAST(9223372036854775807 AS UNSIGNED) + 1 |
+-------------------------------------------+
| 9223372036854775808                       |
+-------------------------------------------+
</pre>

<p>Происходит ли переполнение, зависит от диапазона операндов, таким образом,
другой способ обработать предыдущее выражение состоит в том, чтобы
использовать арифметику точного значения, потому что значения
<a href="#fixed-point-types"><code>DECIMAL</code></a>
имеют больший диапазон, чем целые числа:
<pre>
mysql&gt; SELECT 9223372036854775807.0 + 1;
+---------------------------+
| 9223372036854775807.0 + 1 |
+---------------------------+
| 9223372036854775808.0     |
+---------------------------+
</pre>

<p>Вычитание между целочисленными значениями, где каждое имеет тип
<code>UNSIGNED</code>, приводит к беззнаковому результату по умолчанию. Если
результат иначе был бы отрицателен, будет ошибка:
<pre>
mysql&gt; SET sql_mode = '';
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT CAST(0 AS UNSIGNED) - 1;
<span>ERROR 1690 (22003): BIGINT UNSIGNED value is out of range in
'(cast(0 as unsigned) - 1)'</span>
</pre>

<p>Если режим SQL <a href="server.htm#sqlmode_no_unsigned_subtraction"><code>
NO_UNSIGNED_SUBTRACTION</code></a> включен, результат отрицателен:
<pre>
mysql&gt; SET sql_mode = 'NO_UNSIGNED_SUBTRACTION';
mysql&gt; SELECT CAST(0 AS UNSIGNED) - 1;
+-------------------------+
| CAST(0 AS UNSIGNED) - 1 |
+-------------------------+
| -1                      |
+-------------------------+
</pre>

<p>Если результат такой работы используется, чтобы обновить
столбец <code>UNSIGNED</code> целого числа, результат отсечен к максимальному
значению для типа столбца, или отсечен к 0, если включен
<a href="server.htm#sqlmode_no_unsigned_subtraction"><code>
NO_UNSIGNED_SUBTRACTION</code></a>. Если строгий режим SQL включен, ошибка
происходит, и столбец остается неизменным.</p>

<h2><a name="date-and-time-types"></a>12.3. Типы даты и времени</h2>
<p>Типы даты и времени для того, чтобы представить временные значения
<a href="#datetime"><code>DATE</code></a>,
<a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a>,
<a href="#datetime"><code>TIMESTAMP</code></a> и
<a href="#year"><code>YEAR</code></a>.
У каждого временного типа есть диапазон допустимых значений, так же как
<span>нулевое</span> значение, которое может использоваться,
когда Вы определяете недопустимое значение, которое не может представить
MySQL. Тип <a href="#datetime"><code>TIMESTAMP</code></a> имеет
специальное автоматическое поведение обновления, описанное позже. Для
требований хранения временных типов см.
<a href="#storage-requirements">раздел 12.8</a>.</p>

<p>Имейте в виду эти общие соображения, работая с типами времени и датой:</p>
<ul><li><p>MySQL получает значения для данной даты или типа времени в
стандартном выходном формате, но пытается интерпретировать множество форматов
для входных значений, которые Вы поставляете (например, когда Вы определяете
значение, которое будет назначено или по сравнению с датой или типом
времени). Для описания разрешенных форматов для типов даты и времени см.
<a href="lang.htm#date-and-time-literals">раздел 10.1.3</a>.
Ожидается, что Вы поставляете допустимые значения. Непредсказуемые результаты
могут произойти, если Вы используете значения в других форматах.</li>

<li>Хотя MySQL пытается интерпретировать значения в нескольких форматах,
части даты должны всегда даваться в порядке &quot;день месяца года&quot;
(например, <code>'98-09-04'</code>), вместо в &quot;дневном году месяца&quot;
(<code>'09-04-98'</code>).</li>

<li>Даты, содержащие значения года с двумя цифрами, неоднозначны, потому что
столетие неизвестно. MySQL интерпретирует значения года с двумя цифрами,
используя эти правила:</p>

<ul><li><p>Год в диапазоне <code>70-99</code> преобразован в
<code>1970-1999</code>.</li>
<li>Год в диапазоне <code>00-69</code> преобразован в
<code>2000-2069</code>.</p></li></ul></li>

<li>Преобразование значений из одного временного типа в другой происходит
согласно правилам в <a href="#date-and-time-type-conversion">разделе
12.3.7</a>.</li>

<li>MySQL автоматически преобразовывает дату или время
к числу, если значение используется в числовом контексте и наоборот.</li>
<li>По умолчанию, когда MySQL сталкивается со значением для типа даты или
времени, которое вне диапазона или иначе недопустимо для типа, это
преобразовывает значение в <span>нулевое</span> для того типа.
Исключение: значения <a href="#time"><code>TIME</code></a> вне
диапазона отсечены к соответствующей конечной точке
<a href="#time"><code>TIME</code></a>.</li>

<li>Устанавливая режим SQL в соответствующее значение, Вы можете определить
более точно, какие даты Вы хотите, чтобы MySQL поддерживал. См.
<a href="server.htm#sql-mode">раздел 6.1.8</a>.
Вы можете заставить MySQL принимать определенные даты, такие, как
<code>'2009-11-31'</code>, включая режим SQL
<a href="server.htm#sqlmode_allow_invalid_dates"><code>ALLOW_INVALID_DATES
</code></a>. Это полезно, когда Вы хотите сохранить
<span>возможно, неправильное</span> значение, которое
пользователь определил (например, в веб-форме) в базе данных для будущей
обработки. Под этим режимом MySQL проверяет только, что месяц находится в
диапазоне от 1 до 12 и что день находится в диапазоне от 1 до 31.</li>

<li>MySQL разрешает Вам хранить даты, где день или месяц и день ноль в
столбце <a href="#datetime"><code>DATE</code></a> или
<a href="#datetime"><code>DATETIME</code></a>.
Это полезно для приложений, которые должны сохранить даты рождения, для
которых Вы не можете знать точную дату. В этом случае Вы просто храните дату
как <code>'2009-00-00'</code> или <code>'2009-01-00'</code>.
Если Вы сохраните такие даты, Вы не должны ожидать правильные результаты для
таких функций, как <a href="funct.htm#function_date-sub"><code>DATE_SUB()
</code></a> или <a href="funct.htm#function_date-add"><code>DATE_ADD()</code>
</a>, которые требует полных дат. Чтобы отвергнуть нулевые части месяца или
дня в датах, включите режим <a href="server.htm#sqlmode_no_zero_in_date">
<code>NO_ZERO_IN_DATE</code></a>.</li>

<li>MySQL разрешает Вам хранить <span>нулевое</span> значение
<code>'0000-00-00'</code> как <span>пустую дату</span>.
Это в некоторых случаях более удобно, чем использование значений
<code>NULL</code>: занимает меньше места в данных и индексе. Отвергнуть
<code>'0000-00-00'</code> можно, включив режим
<a href="server.htm#sqlmode_no_zero_date"><code>NO_ZERO_DATE</code></a>.</li>

<li><span>Нулевые</span> дата или время,
используемые через Connector/ODBC, преобразованы автоматически в
<code>NULL</code>, так как ODBC не может обработать такие значения.
</p></li></ul>

<p>Следующая таблица показывает формат <span>нулевых</span>
значений для каждого типа. <span>Нулевые</span> значения
являются особенными, но Вы можете сохранить или отослать к ним явно
используя значения, показанные в таблице. Вы можете также сделать это
с использованием значений <code>'0'</code> или <code>0</code>,
которые легче написать. Для временных типов, которые включают часть даты
(<a href="#datetime"><code>DATE</code></a>,
<a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a>),
использование этих значений производит предупреждения, если включен режим SQL
<a href="server.htm#sqlmode_no_zero_date"><code>NO_ZERO_DATE</code></a>.</p>

<table border="1">
<thead><tr><th scope="col">Тип данных</th><th scope="col"><span>
Нулевое</span> значение</th></tr></thead>
<tbody><tr><td scope="row"><a href="#datetime"><code>DATE</code></a>
</td><td><code>'0000-00-00'</code></td></tr>
<tr><td scope="row"><a href="#time"><code>TIME</code></a></td>
<td><code>'00:00:00'</code></td></tr>
<tr><td scope="row"><a href="#datetime"><code>DATETIME</code></a>
</td><td><code>'0000-00-00 00:00:00'</code></td></tr>
<tr><td scope="row"><a href="#datetime"><code>TIMESTAMP</code></a>
</td><td><code>'0000-00-00 00:00:00'</code></td></tr>
<tr><td scope="row"><a href="#year"><code>YEAR</code></a></td>
<td><code>0000</code></td></tr></tbody></table>

<h3><a name="datetime"></a>12.3.1. Типы DATE, DATETIME и TIMESTAMP</h3>
<p>Типы <code>DATE</code>, <code>DATETIME</code> и <code>TIMESTAMP</code>
связаны. Этот раздел описывает их характеристики, как они подобны, и как они
отличаются. MySQL признает значения <code>DATE</code>, <code>DATETIME</code>
и <code>TIMESTAMP</code> в нескольких форматах, описанных в
<a href="lang.htm#date-and-time-literals">разделе 10.1.3</a>. Для
описания диапазона <code>DATE</code> и <code>DATETIME</code>
<span>поддерживается</span> означает, что, хотя более ранние
значения могли бы работать, нет никакой гарантии.</p>

<p>Тип <code>DATE</code> используется для значений с частью даты, но без
части времени. MySQL получает и выводит на экран значения
<code>DATE</code> в формате <code>'YYYY-MM-DD'</code>. Поддержанный
диапазон от <code>'1000-01-01'</code> до <code>'9999-12-31'</code>.</p>

<p>Тип <code>DATETIME</code> используется для значений с частями даты и
времени. MySQL получает и выводит на экран значения
<code>DATETIME</code> в формате <code>'YYYY-MM-DD HH:MM:SS'</code>.
Поддержанный диапазон от
<code>'1000-01-01 00:00:00'</code> до <code>'9999-12-31 23:59:59'</code>.</p>

<p>Тип <code>TIMESTAMP</code> используется для значений, которые содержат
части даты и времени. <code>TIMESTAMP</code> имеет диапазон от
<code>'1970-01-01 00:00:01'</code> UTC до
<code>'2038-01-19 03:14:07'</code> UTC.</p>

<p>Значение <code>DATETIME</code> или <code>TIMESTAMP</code>
может включать дробную часть секунд до микросекунд (6 цифр).
В частности, любая дробная часть в значении, вставленном в столбец
<code>DATETIME</code> или <code>TIMESTAMP</code>, сохранена.
С включенной дробной частью формат для этих значений
<code>'YYYY-MM-DD HH:MM:SS[.fraction]'</code>, где диапазон
<code>DATETIME</code> от <code>'1000-01-01 00:00:00.000000'</code> до
<code>'9999-12-31 23:59:59.999999'</code>, а диапазон <code>TIMESTAMP</code>
от <code>'1970-01-01 00:00:01.000000'</code> до <code>'2038-01-19
03:14:07.999999'</code>. Дробная часть должна всегда отделяться от остальной
части времени десятичной запятой, никакой другой дробный разделитель секунд
не признан. Для информации о дробной поддержке секунд в MySQL см.
<a href="#fractional-seconds">раздел 12.3.6</a>.</p>

<p>Типы данных <code>TIMESTAMP</code> и <code>DATETIME</code> предлагают
автоматическую инициализацию и обновление к текущей дате и времени. Для
получения дополнительной информации см.
<a href="#timestamp-initialization">раздел 12.3.5</a>.</p>

<p>MySQL конвертирует значения <code>TIMESTAMP</code>
от зоны текущего времени в UTC для хранения и назад из UTC в зону текущего
времени для извлечения. Это не происходит для других типов, например,
<code>DATETIME</code>. По умолчанию зона текущего времени для каждого
соединения это время сервера. Часовой пояс может быть установлен на основе
соединения. Пока установка часового пояса остается постоянной, Вы возвращаете
то же самое значение, которое Вы храните. Если Вы сохраняете
<code>TIMESTAMP</code>, а потом изменяете часовой пояс, полученное значение
отличается от значения, которое Вы сохранили. Это происходит, потому что тот
же самый часовой пояс не использовался для преобразования в обоих
направлениях. Зона текущего времени доступна как значение переменной
<a href="server.htm#sysvar_time_zone"><code>time_zone</code></a>. Подробности
в <a href="global.htm#time-zone-support">разделе 11.6</a>.</p>

<p>Недопустимые значения <code>DATE</code>, <code>DATETIME</code> или
<code>TIMESTAMP</code> преобразованы в <span>нулевое</span>
значение соответствующего типа (<code>'0000-00-00'</code> или
<code>'0000-00-00 00:00:00'</code>).</p>

<p>Знайте об определенных свойствах интерпретации значения даты в MySQL:</p>
<ul><li><p>MySQL разрешает <span>облегченный</span> формат для значений,
определенных как строки, в которых любой символ пунктуации может
использоваться в качестве разделителя между частями даты или частями времени.
В некоторых случаях, этот синтаксис может обманывать. Например, такое
значение, как <code>'10:11:12'</code> может быть похожим на временное
из-за <code>:</code>, но интерпретируется как год
<code>'2010-11-12'</code>, если используется в контексте даты. Значение
<code>'10:45:15'</code> преобразовано в <code>'0000-00-00'</code>, потому что
<code>'45'</code> недопустимый месяц.</p>

<p>Единственный разделитель, признанный между частями даты и времени и
дробной частью секунд, является десятичной запятой.</li>
<li>Сервер требует, чтобы значения месяца и дня были допустимы и не просто в
диапазоне 1-12 и 1-31, соответственно. При отключенном строгом режиме
недопустимые даты, вроде <code>'2004-04-31'</code>, конвертируются в
<code>'0000-00-00'</code> и предупреждение произведено. С включенным строгим
режимом недопустимые даты производят ошибку. Чтобы разрешить такие даты,
включите <a href="server.htm#sqlmode_allow_invalid_dates"><code>
ALLOW_INVALID_DATES</code></a>. См. <a href="server.htm#sql-mode">раздел
6.1.8</a>.</li>

<li>MySQL не принимает значения <code>TIMESTAMP</code>, которые включают ноль
в столбец дня или месяца или значения, которые не являются допустимой датой.
Единственное исключение к этому правилу: специальное <span>нулевое</span>
значение <code>'0000-00-00 00:00:00'</code>.</li></li></ul>

<p>Сервер MySQL может быть выполнен в режиме SQL
<a href="server.htm#sqlmode_maxdb"><code>MAXDB</code></a>.
В этом случае <code>TIMESTAMP</code> идентичен <code>DATETIME</code>.
Если этот режим включен в то время, когда таблица составлена, столбцы
<code>TIMESTAMP</code> создаются как <code>DATETIME</code>.
В результате такого использования столбцы <code>DATETIME</code>
имейют тот же самый диапазон значений, и нет никакой автоматической
инициализации или обновления к текущей дате и времени. См.
<a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<h3><a name="time"></a>12.3.2. Тип TIME</h3>
<p>MySQL получает и отображает значения <code>TIME</code> в формате
<code>'HH:MM:SS'</code> (или <code>'HHH:MM:SS'</code> для больших значений
часов). Значения <code>TIME</code> могут быть в диапазоне от
<code>'-838:59:59'</code> до <code>'838:59:59'</code>.
Часть часов может быть настолько большой потому, что <code>TIME</code>
может использоваться не только, чтобы представить время суток (которое должно
составить меньше 24 часов), но также прошедшее время или временной интервал
между двумя событиями (который может быть намного больше, чем 24 часа
или даже отрицательным).</p>

<p>MySQL признает значения <code>TIME</code> в нескольких форматах, некоторые
из которых могут включать дробную часть секунд до микросекунд (6 цифр). См.
<a href="lang.htm#date-and-time-literals">раздел 10.1.3</a>.
Для информации о дробной поддержке секунд в MySQL см.
<a href="#fractional-seconds">раздел 12.3.6</a>.
С дробной частью диапазон для значения <code>TIME</code> от
<code>'-838:59:59.000000'</code> до <code>'838:59:59.000000'</code>.</p>

<p>Будьте осторожны относительно назначения сокращенных значений столбцам
<code>TIME</code>. MySQL интерпретирует сокращенные значения
<code>TIME</code> с двоеточиями как время дня. Таким образом,
<code>'11:12'</code> значит <code>'11:12:00'</code>, а не
<code>'00:11:12'</code>. MySQL интерпретирует сокращенные значения без
двоеточий, используя предположение, что две самых правых цифры представляют
секунды (то есть, как прошедшее время, а не как время суток). Например, Вы
могли бы думать, что <code>'1112'</code> и <code>1112</code> значат
<code>'11:12:00'</code> (12 минут после 11 часов), но MySQL интерпретирует их
как <code>'00:11:12'</code> (11 минут 12 секунд). Точно так же
<code>'12'</code> и <code>12</code> интерпретируются как
<code>'00:00:12'</code>.</p>

<p>Единственный разделитель, признанный между частью времени и дробной частью
секунд, является десятичной запятой.</p>
<p>По умолчанию значения, которые лежат вне диапазона <code>TIME</code>,
но иначе допустимы, отсечены к самой близкой конечной точке диапазона.
Например, <code>'-850:00:00'</code> и <code>'850:00:00'</code> преобразованы
в <code>'-838:59:59'</code> и <code>'838:59:59'</code>.
Недопустимые значения <code>TIME</code> преобразованы в
<code>'00:00:00'</code>. Отметьте это потому, что <code>'00:00:00'</code>
самостоятельно допустимое значение <code>TIME</code>,
нет никакого способа сказать по значению <code>'00:00:00'</code>,
сохраненному в таблице, было ли оригинальное значение определено как
<code>'00:00:00'</code> или это было недопустимо.</p>

<p>Для более строгой обработки недопустимых значений <code>TIME</code>,
позвольте строгому режиму SQL вызвать ошибки. См.
<a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<h3><a name="year"></a>12.3.3. Тип YEAR</h3>
<p>Тип <code>YEAR</code> 1-байтовый тип, используемый, чтобы представить
значения года. Это может быть объявлено как
<code>YEAR</code> или <code>YEAR(4)</code> и имеет ширину четыре символа.</p>

<p>MySQL 8.0 не поддерживает тип
<a href="#year"><code>YEAR(2)</code></a>, разрешенный в более старых
версиях MySQL. Для инструкций по преобразованию в
<a href="#year"><code>YEAR(4)</code></a> см.
<a href="#migrating-to-year4">раздел 12.3.4</a>.</p>

<p>MySQL отображает <code>YEAR</code> в формате
<code>YYYY</code> с диапазоном от
<code>1901</code> до <code>2155</code> или <code>0000</code>.</p>

<p>Вы можете определить значения <code>YEAR</code> во множестве форматов:</p>
<ul><li><p>Как число с 4 цифрами в диапазоне от <code>1901</code> до
<code>2155</code>.</li>

<li>Как строка с 4 цифрами в диапазоне от <code>'1901'</code> до
<code>'2155'</code>.</li>
<li>Как число с 1 или 2 цифрами в диапазоне от <code>1</code> до
<code>99</code>. MySQL преобразовывает значения в диапазонах от
<code>1</code> до <code>69</code> и от <code>70</code> до <code>99</code>
в значения <code>YEAR</code> в диапазонах от <code>2001</code> до
<code>2069</code> и от <code>1970</code> до <code>1999</code>.</li>

<li>Как строка с 1 или 2 цифрами в диапазоне от
<code>'0'</code> до <code>'99'</code>. MySQL
преобразовывает значения в диапазонах от <code>'0'</code> до
<code>'69'</code> и от <code>'70'</code> до <code>'99'</code> в значения
<code>YEAR</code> в диапазонах от <code>2000</code> до <code>2069</code> и от
<code>1970</code> до <code>1999</code>.</li>

<li>Результат вставки числового <code>0</code> имеет значение
<code>0000</code> и внутреннее значение <code>0000</code>. Чтобы вставить
ноль и интерпретировать его как <code>2000</code>, определите это как строку
<code>'0'</code> или <code>'00'</code>.</li>

<li>Как результат функции, которая возвращает значение, которое является
приемлемым в контексте <code>YEAR</code>, например,
<a href="funct.htm#function_now"><code>NOW()</code></a>.</p></li></ul>
<p>MySQL конвертирует недопустимые значения <code>YEAR</code> в
<code>0000</code>.</p>

<h3><a name="migrating-to-year4"></a>12.3.4. Миграция столбцов из YEAR(2) в
YEAR(4)</h3>
<p>MySQL 8.0 не поддерживает тип
<a href="#year"><code>YEAR(2)</code></a>, разрешенный в более старых
версиях MySQL. Существующие столбцы
<a href="#year"><code>YEAR(2)</code></a> должны быть преобразованы в
to <a href="#year"><code>YEAR(4)</code></a>, чтобы стать применимыми
снова. Этот раздел предоставляет информацию о выполнении преобразования.</p>

<h4><a name="limited-y2-support"></a>Удаление поддержки YEAR(2) в MySQL 8.0
</h4>
<p>MySQL 8.0 обрабатывает столбцы
<a href="#year"><code>YEAR(2)</code></a> следующим образом:</p>

<ul><li><p>Определения столбца
<a href="#year"><code>YEAR(2)</code></a> для новых таблиц производят
ошибку <a href="error.htm#error_er_invalid_year_column_length"><code>
ER_INVALID_YEAR_COLUMN_LENGTH</code></a>:
<pre>
mysql&gt; CREATE TABLE t1 (y YEAR(2));
ERROR 1818 (HY000): Supports only YEAR or YEAR(4) column.
</pre></li>

<li>Столбец <a href="#year"><code>YEAR(2)</code></a>
в существующих таблицах остается как
<a href="#year"><code>YEAR(2)</code></a>, но эти столбцы
в запросах производят предупреждения или ошибки.</li>

<li>Несколько программ и запросов конвертируют
<a href="#year"><code>YEAR(2)</code></a> в
<a href="#year"><code>YEAR(4)</code></a> автоматически:</p>

<ul><li><p><a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> при
пересоздании таблицы.</li>
<li><a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a> (который
<a href="sql.htm#check-table"><code>CHECK TABLE</code></a> рекомендует, чтобы
Вы использовали, если находит, что таблица содержит столбцы
<a href="#year"><code>YEAR(2)</code></a>).</li>

<li><a href="programs.htm#mysql-upgrade"><span><strong>mysql_upgrade</strong>
</span></a> (использует <a href="sql.htm#repair-table"><code>REPAIR TABLE
</code></a>).</li>

<li>Дамп с помощью <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a> и перезагрузки файла дампа. В отличие от преобразований,
выполненных предыдущими вариантами, дамп и перезагрузка
имеет потенциал, чтобы изменить значения.</p></li></ul>

<p>Обновление MySQL обычно вовлекает по крайней мере один из последних двух
вариантов. Однако, относительно <a href="#year"><code>YEAR(2)</code>
</a> <a href="programs.htm#mysql-upgrade"><span><strong>mysql_upgrade
</strong></span></a> предпочтителен. Вы должны избегать использования
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
, потому что, как отмечено, это может изменить значения.</p></li></ul>

<h4><a name="migrating-from-y2-to-y4"></a>Миграция с YEAR(2) на YEAR(4)</h4>
<p>Преобразовать столбцы <a href="#year"><code>YEAR(2)</code></a> в
<a href="#year"><code>YEAR(4)</code></a> Вы можете сделать вручную в
любое время без обновления. Альтернативно Вы можете обновиться до версии
MySQL с уменьшенной или удаленной поддержкой
<a href="#year"><code>YEAR(2)</code></a> (MySQL 5.6.6 или позже),
затем сделать, чтобы MySQL преобразовал столбцы
<a href="#year"><code>YEAR(2)</code></a> автоматически. В последнем
случае избегайте обновления, выводя и перезагружая Ваши данные, потому что
это может изменить значения данных. Кроме того, если Вы используете
репликацию, есть соображения обновления, которые Вы должны
принять во внимание.</p>

<p>Преобразовать столбцы <a href="#year"><code>YEAR(2)</code></a> в
<a href="#year"><code>YEAR(4)</code></a> вручную можно через
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> или
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a>.
Предположите, что таблица <code>t1</code> имеет это определение:
<pre>
CREATE TABLE t1 (ycol YEAR(2) NOT NULL DEFAULT '70');
</pre>

<p>Измените использование столбца <code>ALTER TABLE</code> следующим образом:
<pre>
ALTER TABLE t1 FORCE;
</pre>

<p><a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> преобразовывает
таблицу без изменения значений <a href="#year"><code>YEAR(2)</code>
</a>. Если сервер ведущее устройство, <a href="sql.htm#alter-table"><code>
ALTER TABLE</code></a> копируется к ведомым устройствам и производит
соответствующее табличное изменение на каждом.</p>

<p>Другой метод миграции должен выполнить двойное обновление: установите
MySQL, не выводя и не перезагружая Ваши данные. Тогда выполнение
run <a href="programs.htm#mysql-upgrade"><span><strong>mysql_upgrade</strong>
</span></a>, который использует
<a href="sql.htm#repair-table"><code>REPAIR TABLE</code></a> для конвертации
<a href="#year"><code>YEAR(2)</code></a> в
<a href="#year"><code>YEAR(4)</code></a> не изменяя значения данных.
Если сервер ведущее устройство, <a href="sql.htm#repair-table"><code>REPAIR
TABLE</code></a> копируется к ведомым устройствам и производит
соответствующие табличные изменения на каждом, если Вы не вызываете
<a href="programs.htm#mysql-upgrade"><span><strong>mysql_upgrade</strong>
</span></a> с опцией <a href="programs.htm#option_mysql_upgrade_write-binlog">
<code>--skip-write-binlog</code></a>.</p>

<p>Обновления серверов репликации обычно обновляют к более новой версии
MySQL ведомые устройства, затем обновляя ведущее устройство. Например, если
ведущее и ведомое устройства оба выполняют MySQL 5.5, типичная
последовательность обновления вовлекает обновление ведомого устройства до
5.6, а уже затем ведущее устройство обновляется до 5.6. Относительно другого
отношения <a href="#year"><code>YEAR(2)</code></a> в MySQL 5.6.6,
последовательность обновления приводит к проблеме: предположите, что ведомое
устройство было обновлено, но ведущее пока нет. Тогда составление таблицы,
содержащей столбец <a href="#year"><code>YEAR(2)</code></a>
на ведущем устройстве приводит к таблице, содержащей столбец
<a href="#year"><code>YEAR(4)</code></a> на ведомом.
Следовательно, у этих операций будет различный результат на ведущем и ведомом
устройствах, если Вы будете использовать основанную на запросе репликацию:
</p>

<ul><li><p>Числовая вставка <code>0</code>. У получающегося значения есть
внутреннее значение <code>2000</code> на ведущем устройстве,
но <code>0000</code> на ведомом.</li>

<li>Преобразование <a href="#year"><code>YEAR(2)</code></a> в
строку. Эта работа использует значение отображения
<a href="#year"><code>YEAR(2)</code></a> на ведущем устройстве, но
<a href="#year"><code>YEAR(4)</code></a> на ведомом.</p></li></ul>

<p>Чтобы избежать таких проблем, измените все столбцы
<a href="#year"><code>YEAR(2)</code></a> на ведущем устройстве к
to <a href="#year"><code>YEAR(4)</code></a> перед обновлением.
Используйте <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
как описано ранее. Тогда Вы можете обычно обновлять (ведомое устройство
сначала, ведущее позже), не представляя никаких различий между ведущим
устройством и ведомым в <a href="#year"><code>YEAR(2)</code></a>.
</p>

<p>Одного метода перемещения нужно избежать: не выводите свои данные с
<a href="programs.htm#mysqldump"><span><strong>mysqldump</strong></span></a>
с перезагрузкой файла дампа после обновления. У этого есть потенциал, чтобы
изменить значения <a href="#year"><code>YEAR(2)</code></a>.</p>

<p>Перемещение от <a href="#year"><code>YEAR(2)</code></a> к
<a href="#year"><code>YEAR(4)</code></a> должно также вовлечь код
программы для возможности измененного исследования поведения при условиях:
</p>

<ul><li><p>Код, который ожидает столбец
<a href="#year"><code>YEAR</code></a>, чтобы произвести
точно две цифры.</li>

<li>Код, который не составляет различную обработку для вставок числовых
<code>0</code>: вставка <code>0</code> в
<a href="#year"><code>YEAR(2)</code></a> или
<a href="#year"><code>YEAR(4)</code></a> во внутреннем значении
обрабатывается как <code>2000</code> или <code>0000</code>, соответственно.
</p></li></ul>

<h3><a name="timestamp-initialization"></a>12.3.5.
Автоматическая инициализация и обновление для TIMESTAMP и DATETIME</h3>
<p>Столбцы <a href="#datetime"><code>TIMESTAMP</code></a> и
<a href="#datetime"><code>DATETIME</code></a> могут быть
автоматически инициализированы и обновлены к текущей дате и времени
(то есть, timestamp).</p>

<p>Для любого столбца <a href="#datetime"><code>TIMESTAMP</code></a>
или <a href="#datetime"><code>DATETIME</code></a> в таблице Вы
можете назначить текущий timestamp в качестве значения по умолчанию, значения
автообновления или обоих:</p>

<ul><li><p>Автоинициализированный столбец установлен в текущий timestamp
для вставленных строк, которые не определяют значения для столбца.</li>
<li>Автообновленный столбец автоматически обновлен к текущему timestamp,
когда значение любого другого столбца в строке изменено от текущего.
Автообновленный столбец остается неизменным, если все другие столбцы
установлены в их текущее значение. Чтобы препятствовать автообновленному
столбцу обновиться, когда другие столбцы изменяются, явно установите это в
его текущее значение. Чтобы обновить автообновленный столбец, даже когда
другие столбцы не изменяются, явно установите его в значение, которое он
должен иметь (например, установите
<a href="funct.htm#function_current-timestamp"><code>CURRENT_TIMESTAMP</code>
</a>).</p></li></ul>

<p>Кроме того, Вы можете инициализировать или обновить любой столбец
<a href="#datetime"><code>TIMESTAMP</code></a> к текущей дате и
времени, назначая <code>NULL</code>, если это не было определено с
атрибутом <code>NULL</code>, чтобы позволить значение <code>NULL</code>.</p>

<p>Чтобы определить автоматические свойства, используйте предложения
<code>DEFAULT CURRENT_TIMESTAMP</code> и <code>ON UPDATE CURRENT_TIMESTAMP
</code> в определениях столбца. Порядок не имеет значения. Если оба
присутствуют в определении столбца, любой может быть первым. Любой из
синонимов для <a href="funct.htm#function_current-timestamp"><code>
CURRENT_TIMESTAMP</code></a> имеет то же самое значение как
<a href="funct.htm#function_current-timestamp"><code>CURRENT_TIMESTAMP</code>
</a>: <a href="funct.htm#function_now"><code>NOW()</code></a>,
<a href="funct.htm#function_localtime"><code>LOCALTIME</code></a>,
<a href="funct.htm#function_localtime"><code>LOCALTIME()</code></a>,
<a href="funct.htm#function_localtimestamp"><code>LOCALTIMESTAMP</code></a> и
<a href="funct.htm#function_localtimestamp"><code>LOCALTIMESTAMP()</code>
</a>.</p>

<p>Использование <code>DEFAULT CURRENT_TIMESTAMP</code> и
<code>ON UPDATE CURRENT_TIMESTAMP</code> является определенным для
<a href="#datetime"><code>TIMESTAMP</code></a> и
<a href="#datetime"><code>DATETIME</code></a>. Предложение
<code>DEFAULT</code> также может использоваться, чтобы определить постоянное
(не автоматическое) значение по умолчанию, например,
<code>DEFAULT 0</code> или <code>DEFAULT '2000-01-01 00:00:00'</code>.</p>

<p>Следующее использует в качестве примера <code>DEFAULT 0</code>,
значение по умолчанию, которое может произвести предупреждения или ошибки в
зависимости от того, включен ли строгий режим SQL или
<a href="server.htm#sqlmode_no_zero_date"><code>NO_ZERO_DATE</code></a>.
Знайте, что режим SQL <a href="server.htm#sqlmode_traditional"><code>
TRADITIONAL</code></a> включает строгий режим и
<a href="server.htm#sqlmode_no_zero_date"><code>NO_ZERO_DATE</code></a>. См.
<a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<p>Определения столбцов <a href="#datetime"><code>TIMESTAMP</code>
</a> или <a href="#datetime"><code>DATETIME</code></a> могут
определить текущий timestamp для обоих значений (по умолчанию и
автообновления), для одного, но не другого, или ни для одного.
У различных столбцов могут быть различные комбинации автоматических свойств.
Следующие правила описывают возможности:</p>

<ul><li><p>С обоими <code>DEFAULT CURRENT_TIMESTAMP</code> и
<code>ON UPDATE CURRENT_TIMESTAMP</code> столбец имеет текущий timestamp
для его значения по умолчанию и автоматически обновлен к текущемк timestamp.
<pre>
CREATE TABLE t1 (ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE
                 CURRENT_TIMESTAMP,
                 dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE
                 CURRENT_TIMESTAMP);
</pre></li>

<li>С <code>DEFAULT</code> без <code>ON UPDATE CURRENT_TIMESTAMP</code>
столбец имеет данное значение по умолчанию и автоматически не обновлен.</p>
<p>Значение по умолчанию зависит от того, определяет ли <code>DEFAULT</code>
<code>CURRENT_TIMESTAMP</code> или постоянную величину. С
<code>CURRENT_TIMESTAMP</code> значение по умолчанию будет текущим timestamp.
<pre>
CREATE TABLE t1 (ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                 dt DATETIME DEFAULT CURRENT_TIMESTAMP);
</pre>

<p>С константой значение по умолчанию данное значение. В этом случае у
столбца нет никаких автоматических свойств вообще.
<pre>
CREATE TABLE t1 (ts TIMESTAMP DEFAULT 0, dt DATETIME DEFAULT 0);
</pre></li>

<li>С <code>ON UPDATE CURRENT_TIMESTAMP</code> и константой в
<code>DEFAULT</code> столбец автоматически обновлен к текущему timestamp и
имеет данное постоянное значение по умолчанию.
<pre>
CREATE TABLE t1 (ts TIMESTAMP DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP,
                 dt DATETIME DEFAULT 0 ON UPDATE CURRENT_TIMESTAMP);
</pre></li>

<li>С <code>ON UPDATE CURRENT_TIMESTAMP</code> и без <code>DEFAULT</code>
столбец автоматически обновлен к текущему timestamp, но не имеет текущего
timestamp для его значения по умолчанию.</p>

<p>Значение по умолчанию в этом случае зависит от типа.
<a href="#datetime"><code>TIMESTAMP</code></a>
имеет значение по умолчанию 0, если не определено с <code>NULL</code>,
тогда значение по умолчанию <code>NULL</code>.
<pre>
CREATE TABLE t1 (ts1 TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -- default 0
                 ts2 TIMESTAMP NULL ON UPDATE
                 CURRENT_TIMESTAMP -- default NULL);
</pre>

<p><a href="#datetime"><code>DATETIME</code></a>
имеет значение по умолчанию <code>NULL</code>, если не определено с
<code>NOT NULL</code>, тогда значение по умолчанию 0.
<pre>
CREATE TABLE t1 (dt1 DATETIME ON UPDATE CURRENT_TIMESTAMP, -- default NULL
                 dt2 DATETIME NOT NULL ON UPDATE
                 CURRENT_TIMESTAMP -- default 0);
</pre></li></ul>

<p>Столбцы <a href="#datetime"><code>TIMESTAMP</code></a> и
<a href="#datetime"><code>DATETIME</code></a> не имеют никаких
автоматических свойств, если они не определены явно, с этим исключением:
по умолчанию <span><em>первый</em></span> столбец
<a href="#datetime"><code>TIMESTAMP</code></a> имеет оба
<code>DEFAULT CURRENT_TIMESTAMP</code> и <code>ON UPDATE CURRENT_TIMESTAMP
</code>, если ни один не определен явно. Подавить автоматические свойства для
первого столбца <a href="#datetime"><code>TIMESTAMP</code></a> можно,
используя одну из этих стратегий:</p>

<ul><li><p>Включите переменну.
<a href="server.htm#sysvar_explicit_defaults_for_timestamp"><code>
explicit_defaults_for_timestamp</code></a>. Если эта переменная включена,
<code>DEFAULT CURRENT_TIMESTAMP</code> и
<code>ON UPDATE CURRENT_TIMESTAMP</code>, которые определяют автоматическую
инициализацию и обновление, доступны, но не назначены ни на какой столбец
<a href="#datetime"><code>TIMESTAMP</code></a>, если явно не
включены в определение столбца.</li>

<li>Альтернативно, если
<a href="server.htm#sysvar_explicit_defaults_for_timestamp"><code>
explicit_defaults_for_timestamp</code></a> выключена
(по умолчанию), сделайте любое из следующего:

<ul><li><p>Определите столбец с <code>DEFAULT</code>, который определяет
постоянное значение по умолчанию.</li>
<li>Определите признак <code>NULL</code>. Это также заставляет столбец
разрешать значения <code>NULL</code>, что означает, что Вы не можете
назначить текущий timestamp, устанавливая столбец в <code>NULL</code>.
Назначение <code>NULL</code> устанавливает столбец именно в <code>NULL
</code>.</p></li></ul></li></ul>

<p>Рассмотрите эти табличные определения:
<pre>
CREATE TABLE t1 (ts1 TIMESTAMP DEFAULT 0,
                 ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                 ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t2 (ts1 TIMESTAMP NULL,
                 ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                 ON UPDATE CURRENT_TIMESTAMP);
CREATE TABLE t3 (ts1 TIMESTAMP NULL DEFAULT 0,
                 ts2 TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                 ON UPDATE CURRENT_TIMESTAMP);
</pre>

<p>У таблиц есть эти свойства:</p>
<ul><li><p>В каждом табличном определении первый столбец
<a href="#datetime"><code>TIMESTAMP</code></a> не имеет
никакой автоматической инициализации или обновления.</li>

<li>Таблицы отличаются в том, как столбец <code>ts1</code> обрабатывает
<code>NULL</code>. Для <code>t1</code> <code>ts1</code> <code>NOT NULL</code>
и назначение ему <code>NULL</code> установит его в текущий timestamp. Для
<code>t2</code> и <code>t3</code> <code>ts1</code> допускает
<code>NULL</code> и назначение им <code>NULL</code> установит их в
<code>NULL</code>.</li>

<li><code>t2</code> и <code>t3</code> отличаются по значению по умолчанию для
<code>ts1</code>. Для <code>t2</code> <code>ts1</code> определен, чтобы
разрешить <code>NULL</code>, таким образом, значение по умолчанию также
<code>NULL</code> в отсутствии явного <code>DEFAULT</code>. Для
<code>t3</code> <code>ts1</code> допускает <code>NULL</code>,
но имеет явное значение по умолчанию 0.</p></li></ul>

<p>Если определение столбца <a href="#datetime"><code>TIMESTAMP
</code></a> или <a href="#datetime"><code>DATETIME</code></a>
включает явное дробное значение точности секунд где угодно, то же самое
значение должно использоваться всюду по определению столбца. Это разрешено:
<pre>
CREATE TABLE t1 (ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP(6)
                 ON UPDATE CURRENT_TIMESTAMP(6));
</pre>

<p>А вот это нет:
<pre>
CREATE TABLE t1 (ts TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP
                 ON UPDATE CURRENT_TIMESTAMP(3));
</pre>

<h4><a name="idm139965360698640"></a>Инициализация TIMESTAMP и атрибут NULL
</h4>
<p>По умолчанию столбцы <a href="#datetime"><code>TIMESTAMP</code>
</a> <code>NOT NULL</code>, не могут содержать <code>NULL</code>,
и назначение <code>NULL</code> реально назначает текущий timestamp. Чтобы
разрешить столбцу <a href="#datetime"><code>TIMESTAMP</code></a>
содержать <code>NULL</code>, явно объявите его с атрибутом <code>NULL</code>.
В этом случае значение по умолчанию также становится <code>NULL</code>, если
не переопределено в <code>DEFAULT</code>, который определяет иное значение по
умолчанию. <code>DEFAULT NULL</code> может использоваться, чтобы явно
определить <code>NULL</code> как значение по умолчанию. Для
столбцов <a href="#datetime"><code>TIMESTAMP</code></a>,
не объявленных с атрибутом <code>NULL</code>, <code>DEFAULT NULL</code>
недопустим. Если столбец <a href="#datetime"><code>TIMESTAMP</code>
</a> разрешает <code>NULL</code>, назначение ему <code>NULL</code> установит
именно <code>NULL</code>, а не текущий timestamp.</p>

<p>Следующая таблица содержит несколько столбцов
<a href="#datetime"><code>TIMESTAMP</code></a>, которые
разрешают значения <code>NULL</code>:
<pre>
CREATE TABLE t (ts1 TIMESTAMP NULL DEFAULT NULL,
                ts2 TIMESTAMP NULL DEFAULT 0,
                ts3 TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP);
</pre>

<p>Столбец <a href="#datetime"><code>TIMESTAMP</code></a>, который
разрешает <code>NULL</code> <span><em>НЕ</em></span> берет текущий
timestamp во время вставки, кроме как при одном из следующих условий:</p>

<ul><li><p>Его значение по умолчанию определено как
<a href="funct.htm#function_current-timestamp"><code>CURRENT_TIMESTAMP</code>
</a>, и никакое значение не определено для столбца.</li>

<li><a href="funct.htm#function_current-timestamp"><code>CURRENT_TIMESTAMP
</code></a> или любой ее синоним, вроде
<a href="funct.htm#function_now"><code>NOW()</code></a>,
явно вставлена в столбец.</p></li></ul>

<p>Другими словами, столбец <a href="#datetime"><code>TIMESTAMP
</code></a>, определенный, чтобы разрешить значения <code>NULL</code>,
автоинициализируется, только если его определение включает
<code>DEFAULT CURRENT_TIMESTAMP</code>:
<pre>
CREATE TABLE t (ts TIMESTAMP NULL DEFAULT CURRENT_TIMESTAMP);
</pre>

<p>Если столбец <a href="#datetime"><code>TIMESTAMP</code></a>
разрешает значения <code>NULL</code>, но его определение не включает
<code>DEFAULT CURRENT_TIMESTAMP</code>, Вы должны явно вставить значение,
соответствующее текущей дате и времени. Предположите, что таблицы
<code>t1</code> и <code>t2</code> имеют эти определения:
<pre>
CREATE TABLE t1 (ts TIMESTAMP NULL DEFAULT '0000-00-00 00:00:00');
CREATE TABLE t2 (ts TIMESTAMP NULL DEFAULT NULL);
</pre>

<p>Установить столбец <a href="#datetime"><code>TIMESTAMP</code></a>
в любой таблице к текущему timestamp во время вставки можно, явно назначив
такое значение. Например:
<pre>
INSERT INTO t1 VALUES (NOW());
INSERT INTO t2 VALUES (CURRENT_TIMESTAMP);
</pre>

<h3><a name="fractional-seconds"></a>12.3.6.
Дробные доли секунд во временных значениях</h3>
<p>У MySQL 8.0 есть поддержка дробных секунд для значений
<a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a> с точностью
до микросекунд (6 цифр):</p>

<ul><li><p>Чтобы определить столбец, который включает дробную часть секунд,
используйте синтаксис
<code><em><code>type_name</code></em>(<em><code>fsp</code></em>)</code>,
где <em><code>type_name</code></em>
<a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a> или
<a href="#datetime"><code>TIMESTAMP</code></a>, а
<em><code>fsp</code></em> дробная точность секунд. Например:
<pre>
CREATE TABLE t1 (t TIME(3), dt DATETIME(6));
</pre>

<p>Значение <em><code>fsp</code></em>, если есть, должно быть в диапазоне от
0 до 6. Значение 0 показывает, что нет никакой дробной части. Если опущено,
точность значения по умолчанию 0. Это отличается от стандартного значения по
умолчанию SQL 6, для совместимости с предыдущими версиями MySQL.</li>

<li>Вставка значения <a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATE</code></a> или
<a href="#datetime"><code>TIMESTAMP</code></a>
с дробной частью секунд в столбец того же самого типа, но имеющий меньше
дробных цифр приводит к округлению, как показано в этом примере:
<pre>
mysql&gt; CREATE TABLE fractest(c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2));
Query OK, 0 rows affected (0.33 sec)

mysql&gt; INSERT INTO fractest VALUES
     &gt; ('17:51:04.777', '2014-09-08 17:51:04.777',
     &gt;  '2014-09-08 17:51:04.777');
Query OK, 1 row affected (0.03 sec)

mysql&gt; SELECT * FROM fractest;
+-------------+------------------------+------------------------+
| c1          | c2                     | c3                     |
+-------------+------------------------+------------------------+
| 17:51:04.78 | 2014-09-08 17:51:04.78 | 2014-09-08 17:51:04.78 |
+-------------+------------------------+------------------------+
1 row in set (0.00 sec)
</pre>

<p>Никакое предупреждение или ошибка не даны, когда такое округление
происходит. Это поведение следует стандарту SQL и не затронуто параметром
<a href="server.htm#sysvar_sql_mode"><code>sql_mode</code></a>.</li>

<li>Функции, которые берут временные параметры, принимают значения с дробными
секундами. Возвращаемые значения от временных функций включают дробные
секунды. Например, <a href="funct.htm#function_now"><code>NOW()</code></a>
без параметра возвращает текущую дату и время без дробной части, но берет
дополнительный параметр от 0 до 6, чтобы определить, что возвращаемое
значение включает дробную часть секунд.</li>

<li>Синтаксис для временных литералов производит временные значения:
<code>DATE '<em><code>str</code></em>'</code>,
<code>TIME '<em><code>str</code></em>'</code> и
<code>TIMESTAMP '<em><code>str</code></em>'</code>, а также
эквиваленты ODBC-синтаксиса. Получающееся значение включает
дробную часть секунд, если определено. Ранее временное ключевое слово типа
было проигнорировано, и эти конструкции произвели строковое значение.
</p></li></ul>

<h3><a name="date-and-time-type-conversion"></a>12.3.7.
Преобразование между типами даты и времени</h3>
<p>До некоторой степени Вы можете преобразовать значение одного временного
типа в другой. Однако, может быть некоторое изменение значения или потеря
информации. Во всех случаях преобразование между временными типами
подвергается диапазону допустимых значений для получающегося типа.
Например, хотя все значения <a href="#datetime"><code>DATE</code>
</a>, <a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a> могут быть
определены, используя тот же самый набор форматов, нет того же самого
диапазона. Значения <a href="#datetime"><code>TIMESTAMP</code></a>
не могут быть ранее <code>1970</code> UTC или позже
<code>'2038-01-19 03:14:07'</code> UTC. Это означает что такая дата, как
<code>'1968-01-01'</code>, допустимая как
<a href="#datetime"><code>DATE</code></a> или
<a href="#datetime"><code>DATETIME</code></a>, недопустима в
<a href="#datetime"><code>TIMESTAMP</code></a> и преобразована в
<code>0</code>.</p>

<p>Преобразование значения <a href="#datetime"><code>DATE</code></a>:
</p>
<ul><li><p>Преобразование в <a href="#datetime"><code>DATETIME
</code></a> или <a href="#datetime"><code>TIMESTAMP</code></a>
добавляет часть времени <code>'00:00:00'</code>, так как значение
<a href="#datetime"><code>DATE</code></a>
не содержит информации времени.</li>
<li>Преобразование в <a href="#time"><code>TIME</code></a>
не полезно: результат <code>'00:00:00'</code>.</p></li></ul>

<p>Преобразование <a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a>:</p>
<ul><li><p>Преобразование в <a href="#datetime"><code>DATE</code>
</a> принимает дробные секунды во внимание и округляет часть времени.
Например, <code>'1999-12-31 23:59:59.499'</code> станет
<code>'1999-12-31'</code>, тогда как <code>'1999-12-31 23:59:59.500'</code>
станет <code>'2000-01-01'</code>.</li>

<li>Преобразование в <a href="#time"><code>TIME</code></a>
отказывается от части даты, потому что тип
<a href="#time"><code>TIME</code></a>
не содержит информации о дате.</p></li></ul>

<p>Для преобразования <a href="#time"><code>TIME</code></a>
к другим временным типам значение
<a href="funct.htm#function_current-date"><code>CURRENT_DATE()</code></a>
используется для части даты. <a href="#time"><code>TIME</code></a>
интерпретируется как прошедшее время (не время суток) и добавлено к дате. Это
означает, что часть даты результата отличается от текущей даты, если
временное значение вне диапазона от
<code>'00:00:00'</code> до <code>'23:59:59'</code>.</p>

<p>Предположите, что текущая дата <code>'2012-01-01'</code>. Значения
<a href="#time"><code>TIME</code></a>
<code>'12:00:00'</code>, <code>'24:00:00'</code>,
и <code>'-12:00:00'</code>, когда преобразованы в
<a href="#datetime"><code>DATETIME</code></a> или
<a href="#datetime"><code>TIMESTAMP</code></a>,
приведут к <code>'2012-01-01 12:00:00'</code>, <code>'2012-01-02
00:00:00'</code> и <code>'2011-12-31 12:00:00'</code>, соответственно.</p>

<p>Преобразование <a href="#time"><code>TIME</code></a> в
<a href="#datetime"><code>DATE</code></a> подобно, но отказывается
от части времени результата: <code>'2012-01-01'</code>,
<code>'2012-01-02'</code> и <code>'2011-12-31'</code>, соответственно.</p>

<p>Явное преобразование может использоваться, чтобы переопределить неявное
преобразование. Например, по сравнению с
<a href="#datetime"><code>DATE</code></a> и
<a href="#datetime"><code>DATETIME</code></a>, значение
<a href="#datetime"><code>DATE</code></a> принуждено к типу
<a href="#datetime"><code>DATETIME</code></a>, добавляя часть
времени <code>'00:00:00'</code>. Чтобы выполнить сравнение, игнорируя часть
времени <a href="#datetime"><code>DATETIME</code></a> вместо этого,
используйте функцию <a href="funct.htm#function_cast"><code>CAST()</code>
</a> следующим образом:
<pre>
<em><code>date_col</code></em> = CAST(<em><code>datetime_col</code></em> AS DATE)
</pre>

<p>Преобразование <a href="#time"><code>TIME</code></a> и
<a href="#datetime"><code>DATETIME</code></a> к числовой форме
(например, добавляя <code>+0</code>) зависит от того, содержит ли значение
дробную часть секунд.
<a href="#time"><code>TIME(<em><code>N</code></em>)</code></a> или
<a href="#datetime"><code>DATETIME(<em><code>N</code></em>)</code>
</a> преобразован в целое число, когда <em><code>N</code></em> = 0
(или опущено) и в <code>DECIMAL</code> с <em><code>N</code></em>
десятичных цифр, когда <em><code>N</code></em> больше 0:
<pre>
mysql&gt; SELECT CURTIME(), CURTIME()+0, CURTIME(3)+0;
+-----------+-------------+--------------+
| CURTIME() | CURTIME()+0 | CURTIME(3)+0 |
+-----------+-------------+--------------+
| 09:28:00  | 92800       | 92800.887    |
+-----------+-------------+--------------+

mysql&gt; SELECT NOW(), NOW()+0, NOW(3)+0;
+---------------------+----------------+--------------------+
| NOW()               | NOW()+0        | NOW(3)+0           |
+---------------------+----------------+--------------------+
| 2012-08-15 09:28:00 | 20120815092800 | 20120815092800.889 |
+---------------------+----------------+--------------------+
</pre>

<h3><a name="two-digit-years"></a>12.3.8. Годы с двумя цифрами в датах</h3>
<p>Значения даты с годами с двумя цифрами неоднозначны, потому что столетие
неизвестно. Такие значения должны интерпретироваться в форму с четырьмя
цифрами, потому что MySQL хранит годы, внутренне используя четыре цифры.</p>

<p>Для <a href="#datetime"><code>DATETIME</code></a>,
<a href="#datetime"><code>DATE</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a> MySQL
интерпретирует даты, определенные с неоднозначными значениями года,
используя эти правила:</p>

<ul><li><p>Год в диапазоне <code>00-69</code> преобразован в
<code>2000-2069</code>.</li>
<li>Год в диапазоне <code>70-99</code> преобразован в
<code>1970-1999</code>.</p></li></ul>

<p>Для <code>YEAR</code> правила те же самые, с этим исключением: число
<code>00</code>, вставленное в <code>YEAR(4)</code> станет <code>0000</code>,
вместо <code>2000</code>. Определить ноль для <code>YEAR(4)</code> и
интерпретировать его как <code>2000</code> можно, указав строку
<code>'0'</code> или <code>'00'</code>.</p>

<p>Помните, что эти правила только эвристика, которая обеспечивает разумные
предположения относительно того, что означают Ваши значения данных. Если
правила, используемые MySQL, не производят значения, которые Вы требуете, Вы
должны обеспечить однозначный ввод, содержащий значения года
из четырех знаков.</p>

<p><code>ORDER BY</code> должным образом сортирует значения
<a href="#year"><code>YEAR</code></a>, у которых есть
год с двумя цифрами.</p>

<p>Функции вроде <a href="funct.htm#function_min"><code>MIN()</code></a> и
<a href="funct.htm#function_max"><code>MAX()</code></a> конвертирует
<a href="#year"><code>YEAR</code></a> к числу. Это означает, что
значение с годом с двумя цифрами не работает должным образом с этими
функциями. Затруднительное положение в этом случае должно преобразовать
<a href="#year"><code>YEAR</code></a> к формату года
из четырех знаков.</p>

<h2><a name="string-types"></a>12.4. Строковые типы</h2>
<p>Строковые типы <a href="#char"><code>CHAR</code></a>,
<a href="#char"><code>VARCHAR</code></a>,
<a href="#binary-varbinary"><code>BINARY</code></a>,
<a href="#binary-varbinary"><code>VARBINARY</code></a>,
<a href="#blob"><code>BLOB</code></a>,
<a href="#blob"><code>TEXT</code></a>,
<a href="#enum"><code>ENUM</code></a> и
<a href="#set"><code>SET</code></a>.
Этот раздел описывает, как эти типы работают и как использовать их в Ваших
запросах. Для требований хранения строковых типов см.
<a href="#storage-requirements">раздел 12.8</a>.</p>

<h3><a name="char"></a>12.4.1. Типы CHAR и VARCHAR</h3>
<p>Типы <code>CHAR</code> и <code>VARCHAR</code> подобны, но отличаются по
способу, которым они сохранены и получены. Они также отличаются по
максимальной длине и по тому, сохранены ли конечные пробелы.</p>

<p>Типы <code>CHAR</code> и <code>VARCHAR</code> объявлены с длиной, которая
указывает на максимальное количество символов, которые Вы хотите сохранить.
Например, <code>CHAR(30)</code> может содержать до 30 символов.</p>

<p>Длина столбца <code>CHAR</code> установлена к длине, которую Вы
объявляете, когда составляете таблицу. Длина может быть любым значением от 0
до 255. Когда значения <code>CHAR</code> сохранены, они дополнены справа
пробелами к указанной длине. Когда значения <code>CHAR</code> получены,
конечные пробелы не удалены, если включен режим SQL
<a href="server.htm#sqlmode_pad_char_to_full_length"><code>
PAD_CHAR_TO_FULL_LENGTH</code></a>.</p>

<p>Значения в столбцах <code>VARCHAR</code> строки переменной длины. Длина
может быть определена как значение от 0 до 65535. Эффективная максимальная
длина <code>VARCHAR</code> зависит от максимального размера строки (65535
байтов, которые совместно использованы всеми столбцами), и используемого
набора символов. См. <a href="restr.htm#column-count-limit">раздел C.10.4
</a>.</p>

<p>В отличие от <code>CHAR</code>, значения <code>VARCHAR</code>
сохранены как 1 или 2-байтовая приставка длины плюс данные. Приставка длины
указывает на число байтов в значении. Столбец использует длину в один байт,
если значения требуют не больше, чем 255 байтов, и два байта, если значения
могут потребовать больше 255 байтов.</p>

<p>Если строгий режим SQL не включен, и Вы назначаете значение
<code>CHAR</code> или <code>VARCHAR</code>, которое превышает максимальную
длину столбца, значение является усеченным, чтобы соответствовать размеру, и
предупреждение произведено. Для усечения непробелов Вы можете вызвать ошибку
(а не предупреждение) и подавить вставку значения при использовании строгого
режима SQL. См. <a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<p>Для <code>VARCHAR</code> конечные пробелы сверх длины столбца усечены до
вставки, и предупреждение произведено, независимо от режима SQL. Для
<code>CHAR</code> усечение лишних конечных пробелов вставленных значений
выполнено тихо, независимо от режима SQL.</p>

<p><code>VARCHAR</code> не дополнены, когда они сохранены. Конечные пробелы
сохранены, когда значения сохранены и получены, в соответствии
со стандартным SQL.</p>

<p>Следующая таблица иллюстрирует различия между <code>CHAR</code> и
<code>VARCHAR</code>, показывая результат хранения различных строк в
<code>CHAR(4)</code> и <code>VARCHAR(4)</code> (предполагается, что столбец
использует однобайтовый набор символов такой, как <code>latin1</code>).</p>

<table border="1">
<thead><tr><th scope="col">Значение</th><th scope="col"><code>CHAR(4)</code>
</th><th scope="col">Необходимое место</th>
<th scope="col"><code>VARCHAR(4)</code>
</th><th scope="col">Необходимое место</th></tr></thead>
<tbody><tr><td scope="row"><code>''</code></td><td><code>''</code></td>
<td>4 байта</td><td><code>''</code></td><td>1 байт</td></tr>
<tr><td scope="row"><code>'ab'</code></td><td><code>'ab'</code></td>
<td>4 байта</td><td><code>'ab'</code></td><td>3 байта</td></tr>
<tr><td scope="row"><code>'abcd'</code></td><td><code>'abcd'</code></td>
<td>4 байта</td><td><code>'abcd'</code></td><td>5 байт</td></tr>
<tr><td scope="row"><code>'abcdefgh'</code></td><td><code>'abcd'</code></td>
<td>4 байта</td><td><code>'abcd'</code></td><td>5 байт</td>
</tr></tbody></table>

<p>Значения, показанные как сохраненные в последней строке таблицы,
применяются <span><em>только если не используется строгий режим</em></span>.
Если MySQL работает в строгом режиме, значения, которые превышают длину
столбца, <span><em>не сохранены</em></span> и произведут ошибку.</p>

<p>Для <a href="glossary.htm#glos_row_format">форматов строк</a>
<code>COMPACT</code>, <code>DYNAMIC</code> и <code>COMPRESSED</code> в
<code>InnoDB</code> <code>CHAR</code> обработан как тип переменной длины,
если длина значения столбца больше или равна 768 байтам, что может произойти,
если максимальная длина байта набора символов больше 3, как с
<code>utf8mb4</code>. Когда обработано как тип переменной длины, значение
столбца <code>CHAR</code> может быть выбрано для хранения вне страницы. Для
получения дополнительной информации см.
<a href="innodb.htm#innodb-row-format">раздел 16.10</a>.</p>

<p>Если данное значение сохранено в столбцах <code>CHAR(4)</code>
и <code>VARCHAR(4)</code>, значения, полученные из столбцов, являются не
всегда тем же самым, потому что конечные пробелы удалены из <code>CHAR</code>
после извлечения. Следующий пример иллюстрирует это различие:
<pre>
mysql&gt; CREATE TABLE vc (v VARCHAR(4), c CHAR(4));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; INSERT INTO vc VALUES ('ab', 'ab');
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT CONCAT('(', v, ')'), CONCAT('(', c, ')') FROM vc;
+---------------------+---------------------+
| CONCAT('(', v, ')') | CONCAT('(', c, ')') |
+---------------------+---------------------+
| (ab)                | (ab)                |
+---------------------+---------------------+
1 row in set (0.06 sec)
</pre>

<p>Значения в <code>CHAR</code> и <code>VARCHAR</code> отсортированы и
сравнены согласно сопоставлению набора символов, назначенному на столбец.</p>
<p>Все сопоставления MySQL имеют тип <code>PADSPACE</code>. Это означает, что
все значения <code>CHAR</code>, <code>VARCHAR</code> и <code>TEXT</code> в
MySQL сравнены без отношения с любыми конечными пробелами. В этом контексте
сравнение не включает оператор <a href="funct.htm#operator_like"><code>LIKE
</code></a>, для которого конечные пробелы являются существенными. Например:
<pre>
mysql&gt; CREATE TABLE names (myname CHAR(10));
Query OK, 0 rows affected (0.03 sec)

mysql&gt; INSERT INTO names VALUES ('Monty');
Query OK, 1 row affected (0.00 sec)

mysql&gt; SELECT myname = 'Monty', myname = 'Monty' FROM names;
+------------------+------------------+
| myname = 'Monty' | myname = 'Monty' |
+------------------+------------------+
| 1                | 1                |
+------------------+------------------+
1 row in set (0.00 sec)

mysql&gt; SELECT myname LIKE 'Monty', myname LIKE 'Monty' FROM names;
+---------------------+---------------------+
| myname LIKE 'Monty' | myname LIKE 'Monty' |
+---------------------+---------------------+
| 1                   | 0                   |
+---------------------+---------------------+
1 row in set (0.00 sec)
</pre>

<p>Это истина для всех версий MySQL, и не затронуто режимом SQL.</p>
<p>Для тех случаев, где символы-заполнители обрезаны или сравнения игнорируют
их, если у столбца будет индексирование, которое требует уникальных значений,
вставляя в значения столбцов, которые отличаются только по числу
символов-заполнителей, то приведет к ошибке дублирования ключа.</p>

<h3><a name="binary-varbinary"></a>12.4.2. Типы BINARY и VARBINARY</h3>
<p>Типы <code>BINARY</code> и <code>VARBINARY</code> похожи на
<a href="#char"><code>CHAR</code></a> и
<a href="#char"><code>VARCHAR</code></a> за исключением того, что
они содержат двоичные строки. Таким образом, они содержат строки байт, а не
символов. Это означает, что они имеют набор символов и сопоставление
<code>binary</code>, а сравнение и сортировка основаны на
числовых значениях байтов.</p>

<p>Допустимая максимальная длина та же самая для
<code>BINARY</code> и <code>VARBINARY</code>, как для
<a href="#char"><code>CHAR</code></a> и
<a href="#char"><code>VARCHAR</code></a>, за исключением того, что
длина для for <code>BINARY</code> и <code>VARBINARY</code> в
байтах, а не в символах.</p>

<p>Типы <code>BINARY</code> и <code>VARBINARY</code> отличны от
<code>CHAR BINARY</code> и <code>VARCHAR BINARY</code>. Для последних типов
атрибут <code>BINARY</code> не заставляет столбец быть обработанным как
двоичный строковый столбец. Вместо этого это вызывает двоичное
(<code>_bin</code>) сопоставление для набора символов столбца, который будет
использоваться, а сам столбец содержит недвоичные строки символов, а не
двоичные строки байтов. Например, <code>CHAR(5) BINARY</code> обработан как
<code>CHAR(5) CHARACTER SET latin1 COLLATE latin1_bin</code>, считая, что
набор символов по умолчанию <code>latin1</code>. Это отличается от
<code>BINARY(5)</code>, который хранит 5-байтовые двоичные строки, которые
имеют набор символов и сопоставление <code>binary</code>. Для информации о
различиях между двоичными строками и двоичными сопоставлениями для недвоичных
строк см. <a href="global.htm#charset-binary-collations">раздел 11.1.8.5</a>.
</p>

<p>Если строгий режим SQL не включен, и Вы назначаете значение столбцу
<code>BINARY</code> или <code>VARBINARY</code>, которое превышает
максимальную длину столбца, значение усечено, чтобы соответствовать, и
предупреждение произведено. Для случаев усечения Вы можете вызвать ошибку
(а не предупреждение) и подавить вставку значения при использовании строгого
режима SQL. См. <a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<p>Когда значения <code>BINARY</code> сохранены, они дополнены справа
значением заполнителя до указанной длины. Значение заполнителя
<code>0x00</code> (нулевой байт). Значения дополнены при вставке, и никакие
байтах не удалены при получении. Все байты являются существенными в
сравнениях, включая <code>ORDER BY</code> и
<code>DISTINCT</code>. Байты <code>0x00</code> и пробелы отличаются в
сравнениях, причем <code>0x00</code> &lt; пробела.</p>

<p>Пример: Для столбца <code>BINARY(3)</code> <code>'a '</code> становится
<code>'a \0'</code>, когда вставлено. <code>'a\0'</code> становится
<code>'a\0\0'</code>, когда вставлено. Оба вставленных значения остаются
неизменными, когда выбраны.</p>

<p>Для столбца <code>VARBINARY</code> нет никакого дополнения на вставке, и
никакие байты не отсекаются при выборке. Все байты являются существенными в
сравнениях, включая <code>ORDER BY</code> и <code>DISTINCT</code>. Байты
<code>0x00</code> и пробелы отличаются в сравнениях,
<code>0x00</code> &lt; пробела.</p>

<p>Для тех случаев, где байты дополнения отрезаны или сравнения игнорируют
их, если у столбца будет индексирование, которое требует уникальных значений,
вставляя в значения столбцов, которые отличаются только по числу байтов
дополнения, это приведет к ошибке дубликата ключа. Например, если таблица
содержит <code>'a'</code>, попытка сохранить <code>'a\0'</code> вызывает
ошибку дубликата ключа.</p>

<p>Вы должны рассмотреть предыдущее дополнение и обрезку значений
тщательно, если Вы планируете использовать тип <code>BINARY</code>
для того, чтобы сохранить двоичные данные и требуете, чтобы полученное
значение было точно тем же самым, как сохраненное. Следующий пример
иллюстрирует, как <code>0x00</code>-дополнение значений <code>BINARY</code>
затрагивает сравнения значений столбца:
<pre>
mysql&gt; CREATE TABLE t (c BINARY(3));
Query OK, 0 rows affected (0.01 sec)

mysql&gt; INSERT INTO t SET c = 'a';
Query OK, 1 row affected (0.01 sec)

mysql&gt; SELECT HEX(c), c = 'a', c = 'a\0\0' from t;
+--------+---------+-------------+
| HEX(c) | c = 'a' | c = 'a\0\0' |
+--------+---------+-------------+
| 610000 | 0       | 1           |
+--------+---------+-------------+
1 row in set (0.09 sec)
</pre>

<p>Если полученное значение должно быть тем же самым, как значение,
определенное для хранения без дополнения, может быть предпочтительно
использовать <code>VARBINARY</code> или один из типов данных
<a href="#blob"><code>BLOB</code></a> вместо этого.</p>

<h3><a name="blob"></a>12.4.3. Типы BLOB и TEXT</h3>
<p><code>BLOB</code> это binary large object, большой двоичный объект,
который может содержать переменный объем данных. Есть четыре типа
<code>BLOB</code>: <code>TINYBLOB</code>, <code>BLOB</code>,
<code>MEDIUMBLOB</code> и <code>LONGBLOB</code>. Они отличаются только по
максимальной длине значений, которые они могут содержать. Им соответствуют
четыре типа <code>TEXT</code>: <code>TINYTEXT</code>, <code>TEXT</code>,
<code>MEDIUMTEXT</code> и <code>LONGTEXT</code>. У них есть те же самые
максимальные длины и требования хранения. См.
<a href="#storage-requirements">раздел 12.8</a>.</p>

<p>Значения <code>BLOB</code> обработаны как двоичные строки байтов.
Они имеют набор символов и сопоставление <code>binary</code>,
сравнение и сортировка основаны на числовых значениях байтов в значениях
столбцов. Значения <code>TEXT</code> обработаны как недвоичные строки (строки
символов). У них есть набор символов не <code>binary</code>, значения
отсортированы и сравнены основывясь на сопоставлении набора символов.</p>

<p>Если строгий режим SQL не включен, и Вы назначаете значение на столбец
<code>BLOB</code> или <code>TEXT</code>, которое превышает максимальную длину
столбца, значение усечено, чтобы соответствовать размеру, и предупреждение
произведено. Для усечения непробелов Вы можете вызвать ошибку (а не
предупреждение) и подавить вставку значения при использовании строгого режима
SQL. См. <a href="server.htm#sql-mode">раздел 6.1.8</a>.</p>

<p>Усечение лишних конечных пробелов от значений, которые будут вставлены в
столбцы <a href="#blob"><code>TEXT</code></a> всегда производит
предупреждение, независимо от режима SQL.</p>

<p>Для столбцов <code>TEXT</code> и <code>BLOB</code> нет никакого дополнения
при вставке, и никакие байты не отрезаны при выборке.</p>
<p>Если <code>TEXT</code> индексирован, индексная запись сравнивается
с пробелами в конце. Это означает, что, если индексирование требует
уникальных значений, ошибка дубликата ключа произойдет для значений, которые
отличаются только по числу конечных пробелов. Например, если таблица содержит
<code>'a'</code>, попытка сохранить <code>'a '</code> вызывает ошибку
дубликата ключа. Это не истина для столбцов <code>BLOB</code>.</p>

<p>В большинстве отношений Вы можете расценить <code>BLOB</code> как
<a href="#binary-varbinary"><code>VARBINARY</code></a>, который
может быть столь большим, как Вам нравится. Точно так же Вы можете расценить
<code>TEXT</code> как <a href="#char"><code>VARCHAR</code></a>.
<code>BLOB</code> и <code>TEXT</code> отличаются от
<a href="#binary-varbinary"><code>VARBINARY</code></a> и
<a href="#char"><code>VARCHAR</code></a> следующим:</p>

<ul><li><p>Для индексов на <code>BLOB</code> и <code>TEXT</code>
Вы должны определить длину префикса. Для <a href="#char"><code>CHAR
</code></a> и <a href="#char"><code>VARCHAR</code></a>
длина префикса является дополнительной. См.
<a href="optimiz.htm#column-indexes">раздел 9.3.4</a>.</li>
<li><code>BLOB</code> и <code>TEXT</code> не могут иметь значения
<code>DEFAULT</code>.</p></li></ul>

<p>Если Вы используете признак <code>BINARY</code> с <code>TEXT</code>,
столбцу назначают сопоставление <code>_bin</code> набора символов столбца.
</p>
<p><code>LONG</code> и <code>LONG VARCHAR</code> отобразятся на
<code>MEDIUMTEXT</code>. Это особенность совместимости.</p>

<p>MySQL Connector/ODBC определяет значения <code>BLOB</code> как
<code>LONGVARBINARY</code>, а <code>TEXT</code> как
<code>LONGVARCHAR</code>.</p>

<p>Так как <code>BLOB</code> и <code>TEXT</code> могут быть чрезвычайно
длинными, Вы можете столкнуться с некоторыми
ограничениями в их использовании:</p>

<ul><li><p>Только первые
<a href="server.htm#sysvar_max_sort_length"><code>max_sort_length</code></a>
байт столбца используются, сортируя. Значение по умолчанию
<a href="server.htm#sysvar_max_sort_length"><code>max_sort_length</code></a>
1024. Вы можете сделать больше байтов существенными в сортировке или
группировке, увеличивая значение <a href="server.htm#sysvar_max_sort_length">
<code>max_sort_length</code></a>. Любой клиент может изменить значение
сеансовой переменной <a href="server.htm#sysvar_max_sort_length"><code>
max_sort_length</code></a>:
<pre>
mysql&gt; SET max_sort_length = 2000;
mysql&gt; SELECT id, comment FROM t
    -&gt;        ORDER BY comment;
</pre></li>

<li>Экземпляры столбцов <code>BLOB</code> или <code>TEXT</code>
в результате запроса, который обработан, используя временную таблицу,
заставляют сервер использовать таблицу на диске, а не в памяти потому, что
механизм хранения <code>MEMORY</code> не поддерживает эти типы данных (см.
<a href="optimiz.htm#internal-temporary-tables">раздел 9.4.4</a>).
Использование диска вносит накладные расходы по производительности, так что
включение <code>BLOB</code> или <code>TEXT</code> в запрос, только если они
действительно необходимы. Например, избегайте использования
<a href="sql.htm#select"><code>SELECT *</code></a>,
который выбирает все столбцы.</li>

<li>Максимальный размер <code>BLOB</code> или <code>TEXT</code>
определен его типом, но самое большое значение, которое Вы фактически можете
передать между клиентом и сервером, определено количеством доступной памяти и
размером коммуникационных буферов. Вы можете изменить размер буфера
сообщения, изменяя значение переменной
<a href="server.htm#sysvar_max_allowed_packet"><code>max_allowed_packet
</code></a>, но Вы должны сделать так для сервера и для Вашей программы
клиента. Например, <a href="programs.htm#mysql"><span><strong>mysql</strong>
</span></a> и <a href="programs.htm#mysqldump"><span><strong>mysqldump
</strong></span></a> позволяют Вам изменить клиентское значение
<a href="server.htm#sysvar_max_allowed_packet"><code>max_allowed_packet
</code></a>. См. разделы <a href="server.htm#server-configuration">6.1.1</a>,
<a href="programs.htm#mysql">5.5.1</a> и
<a href="programs.htm#mysqldump">5.5.4</a>. Вы можете также хотеть сравнить
пакетные размеры и размер объектов данных, которые Вы храните, см.
<a href="#storage-requirements">раздел 12.8</a>.</p></li></ul>

<p>Каждое значение <code>BLOB</code> или <code>TEXT</code> представлено
внутренне отдельно выделенным объектом. Это отличие от всех других типов
данных, для которых хранение выделено однажды на столбец,
когда таблица открыта.</p>

<p>В некоторых случаях может быть желательно сохранить двоичные данные, такие
как медиа-файлы в <code>BLOB</code> или <code>TEXT</code>.
Вы можете счесть строковые функции обработки MySQL полезными для работы с
такими данными. См. <a href="funct.htm#string-functions">раздел 13.5</a>.
Для безопасности и других причин, обычно предпочтительно использовать код
программы вместо того, чтобы дать пользователям приложения привилегию
<a href="security.html#priv_file"><code>FILE</code></a>.
Вы можете обсудить специфические особенности для различных языков и платформ
на форумах MySQL (<a href="../../../forums.mysql.com/default.htm" target="_top">
http://forums.mysql.com/</a>).</p>

<h3><a name="enum"></a>12.4.4. Тип ENUM</h3>
<p><code>ENUM</code> строковый объект со значением, выбранным из списка
разрешенных значений, которые перечислены явно в спецификации столбца при
создании таблицы. У этого есть преимущества:</p>

<ul><li><p>Компактное хранение данных в ситуациях, где у столбца есть
ограниченный набор возможных значений. Строки, которые Вы определяете как
входные значения, автоматически закодированы как числа. См.
<a href="#storage-requirements">раздел 12.8</a>
для требований хранения для <code>ENUM</code>.</li>
<li>Читаемые запросы и вывод. Числа преобразованы назад в соответствующие
строки в результатах запроса.</p></li></ul>

<p>Обратите внимание на следующее:</p>
<ul><li><p>Если Вы делаете значения перечисления, которые похожи на числа,
легко перепутать буквальные значения с их внутренними индексами.</li>
<li>Использование столбцов <code>ENUM</code> в <code>ORDER BY</code>
требуют дополнительной заботы.</p></li></ul>

<h4><a name="enum-using"></a>Создание и применение ENUM</h4>
<p>Значение перечисления должно быть заключенной в кавычки буквальной
строкой. Например, Вы можете составить таблицу с <code>ENUM</code> так:
<pre>
CREATE TABLE shirts (name VARCHAR(40),
       size ENUM('x-small', 'small', 'medium', 'large', 'x-large'));
INSERT INTO shirts (name, size)
       VALUES ('dress shirt','large'), ('t-shirt','medium'),
              ('polo shirt','small');
SELECT name, size FROM shirts WHERE size = 'medium';
+---------+--------+
| name    | size   |
+---------+--------+
| t-shirt | medium |
+---------+--------+
UPDATE shirts SET size = 'small' WHERE size = 'large';
COMMIT;
</pre>

<p>Вставка 1 миллиона строк в эту таблицу со значением <code>'medium'</code>
потребовала бы 1 миллиона байтов хранения, в противоположность 6 миллионам
байтов, если бы Вы сохранили фактическую строку
<code>'medium'</code> в столбец <code>VARCHAR</code>.</p>

<h4><a name="enum-indexes"></a>Значения индекса для литералов перечисления
</h4>
<p>У каждого значения перечисления есть индекс:</p>
<ul><li><p>Элементы, перечисленные в спецификации столбца, являются
назначенными индексами, начиная с 1.</li>

<li>Индексное значение пустой строки с ошибкой 0. Это означает, что Вы можете
использовать следующий запрос, чтобы найти строки, в которых были назначены
недопустимые значения <code>ENUM</code>:
<pre>
mysql&gt; SELECT * FROM <em><code>tbl_name</code></em>
                   WHERE <em><code>enum_col</code></em>=0;
</pre></li>

<li>Индекс значения <code>NULL</code> <code>NULL</code>.</li>
<li>Термин <span>index</span> здесь относится к позиции в пределах списка
значений перечисления. Это не имеет никакого отношения к индексу таблицы.
</p></li></ul>

<p>Например, столбец, определенный как <code>ENUM('Mercury',
'Venus', 'Earth')</code> может иметь любое из значений, показанных здесь.
Индекс каждого значения также показывают.</p>

<table border="1">
<thead><tr><th scope="col">ЗначениеValue</th><th scope="col">Индекс</th></tr>
</thead>
<tbody><tr><td scope="row"><code>NULL</code></td>
<td><code>NULL</code></td></tr>
<tr><td scope="row"><code>''</code></td><td>0</td></tr>
<tr><td scope="row"><code>'Mercury'</code></td><td>1</td></tr>
<tr><td scope="row"><code>'Venus'</code></td><td>2</td></tr>
<tr><td scope="row"><code>'Earth'</code></td><td>3</td></tr></tbody></table>

<p>У столбца <a href="#enum"><code>ENUM</code></a> может быть
максимум 65535 различных элементов.</p>

<p>Если Вы получаете значение <code>ENUM</code> в числовом контексте,
возвращается индекс значения столбца. Например, Вы можете получить числовые
значения из <code>ENUM</code> так:
<pre>
mysql&gt; SELECT <em><code>enum_col</code></em>+0 FROM <em><code>tbl_name</code></em>;
</pre>

<p>Такие функции, как <a href="funct.htm#function_sum"><code>SUM()</code></a>
или <a href="funct.htm#function_avg"><code>AVG()</code></a>, которые
ожидает числовой параметр, пеерводят параметр в число в случае необходимости.
Для значений <code>ENUM</code> индекс используется в вычислении.</p>

<h4><a name="enum-literals"></a>Обработка литералов перечисления</h4>
<p>Конечные пробелы автоматически удалены из членов значения
<code>ENUM</code> в табличном определении, когда таблица составлена.</p>

<p>Когда получены, значения, сохраненные в столбце <code>ENUM</code>,
выведены на экран, используя нижний регистр, который использовался в
определении столбца. Отметьте, что столбцам <code>ENUM</code>
можно назначить набор символов и сопоставление. Для двоичных или
чувствительных к регистру сопоставлений регистр принят во внимание,
назначая значения столбцу.</p>

<p>Если Вы храните число в <code>ENUM</code>, оно обработано как индекс в
возможных значениях, и сохраненное значение является участником перечисления
с этим индексом. Однако, это <span><em>НЕ</em></span> работает с
<a href="sql.htm#load-data"><code>LOAD DATA</code></a>,
который обрабатывает весь ввод как строки. Если числовое значение заключено в
кавычки, оно все еще интерпретируется как индекс, если нет никакой строки
соответствия в списке значений перечисления. По этим причинам нежелательно
определить столбец <code>ENUM</code> со значениями перечисления, которые
похожи на числа, потому что это может легко стать запутывающим. Например, у
следующего столбца есть участники перечисления со строковыми значениями
<code>'0'</code>, <code>'1'</code> и <code>'2'</code>, но числовые индексы
значений <code>1</code>, <code>2</code> и <code>3</code>:
<pre>
numbers ENUM('0','1','2')
</pre>

<p>Если Вы сохраните <code>2</code>, это интерпретируется как индекс
и получится <code>'1'</code> (значение с индексом 2). Если Вы сохраните
<code>'2'</code>, это соответствует значению перечисления, таким образом,
это сохранено как <code>'2'</code>. Если Вы сохраните <code>'3'</code>,
это не соответствует значению перечисления, таким образом, это обработано как
индекс и становится <code>'2'</code> (значение с индексом 3).
<pre>
mysql&gt; INSERT INTO t (numbers) VALUES(2),('2'),('3');
mysql&gt; SELECT * FROM t;
+---------+
| numbers |
+---------+
| 1       |
| 2       |
| 2       |
+---------+
</pre>

<p>Определить все возможные значения для столбца <code>ENUM</code> можно
с помощью <a href="sql.htm#show-columns"><code>SHOW
COLUMNS FROM <em><code>tbl_name</code></em> LIKE
'<em><code>enum_col</code></em>'</code></a> и просмотра определения
<code>ENUM</code> в столбце <code>Type</code> вывода.</p>

<p>В C API значения <code>ENUM</code> возвращены как строки. Для информации
об использовании метаданных о наборе результатов, чтобы отличить их от других
строк, см. <a href="connect.htm#c-api-data-structures">раздел 25.8.5</a>.</p>

<h4><a name="enum-nulls"></a>Пустые или NULL значения перечисления</h4>
<p>Значение перечисления может также быть пустой строкой (<code>''</code>)
или <code>NULL</code> при определенных обстоятельствах:</p>

<ul><li><p>Если Вы вставляете недопустимое значение в <code>ENUM</code>
(то есть, строку, не существующую в списке разрешенных значений), пустая
строка вставлена вместо этого как специальное ошибочное значение.
Эту строку можно отличить от <span>нормальной</span> пустой строки факт, что
у этой строки есть числовое значение 0.</p>

<p>Если строгий режим SQL включен, попытки вставить недопустимое значение
<code>ENUM</code> приводят к ошибке.</li>
<li>Если столбец <code>ENUM</code> разрешает <code>NULL</code>, значение
<code>NULL</code> допустимое значение для столбца, и значение по умолчанию
<code>NULL</code>. Если столбец <code>ENUM</code> объявлен как <code>NOT NULL
</code>, его значение по умолчанию первый элемент списка разрешенных значений.
</p></li></ul>

<h4><a name="enum-sorting"></a>Сортировка перечисления</h4>
<p>Значения <code>ENUM</code> отсортированы, основываясь на их индексах,
которые зависят от порядка, в котором участники перечисления были перечислены
в спецификации столбца. Например, <code>'b'</code> будет перед
<code>'a'</code> для <code>ENUM('b', 'a')</code>. Пустые строки будут
перед непустыми строками, а <code>NULL</code> перед
всеми другими значениями перечисления.</p>

<p>Предотвратить неожиданные результаты, используя
<code>ORDER BY</code> на столбце <code>ENUM</code> можно так:</p>
<ul><li><p>Определите список <code>ENUM</code> в алфавитном порядке.</li>
<li>Удостоверьтесь, что столбец сортирован лексически, а не индексом, кодируя
<code>ORDER BY CAST(<em><code>col</code></em> AS CHAR)</code> или
<code>ORDER BY CONCAT(<em><code>col</code></em>)</code>.</p></li></ul>

<h4><a name="enum-limits"></a>Ограничения перечисления</h4>
<p>Значение перечисления не может быть выражением, даже то, которое
оценивается как строковое значение.</p>

<p>Например, <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>
<span><em>НЕ</em></span> работает, потому что <code>CONCAT</code>
не может использоваться, чтобы создать значение перечисления:
<pre>
CREATE TABLE sizes (size ENUM('small', CONCAT('med','ium'), 'large'));
</pre>

<p>Вы также не можете использовать пользовательскую переменную как значение
перечисления. Эта пара запросов <span><em>НЕ</em></span> работает:
<pre>
SET @mysize = 'medium';
CREATE TABLE sizes (size ENUM('small', @mysize, 'large'));
</pre>

<p>Мы сильно рекомендуем, чтобы Вы <span><em>НЕ</em></span>
использовали числа как значения перечисления, потому что это не экономит на
хранении по сравнении с соответствующим типом
<a href="#integer-types"><code>TINYINT</code></a> или
<a href="#integer-types"><code>SMALLINT</code></a>, зато
легко перепутать строки и основные значения числа (которые могут не быть тем
же самым), если Вы заключаете в кавычки значения <code>ENUM</code>
неправильно. Если Вы действительно используете число в качестве значения
перечисления, всегда задавайте это в кавычках. Если кавычки опущены, число
расценено как индекс.</p>
<p>Двойные значения в определении вызывают предупреждение или ошибку, если
строгий режим SQL включен.</p>

<h3><a name="set"></a>12.4.5. Тип SET</h3>
<p><code>SET</code> строковый объект, у которого может быть ноль или больше
значений, каждое из которых должно быть выбрано из списка разрешенных
значений, определенных, когда таблица составлена. Значения столбцов
<code>SET</code>, которые состоят из многих участников набора, определены
перечнем участников, отделенных запятыми (<code>,</code>). Последствие этого:
членские значения <code>SET</code> не должны сами содержать запятые.</p>

<p>Например, столбец, определенный как <code>SET('one', 'two')
NOT NULL</code> может иметь любое из этих значений:
<pre>
''
'one'
'two'
'one,two'
</pre>

<p>У столбца <a href="#set"><code>SET</code></a> может быть
максимум 64 различных участника.</p>
<p>Двойные значения в определении вызывают предупреждение или ошибку, если
строгий режим SQL включен.</p>
<p>Конечные пробелы автоматически удалены из членов <code>SET</code>
в табличном определении, когда таблица составлена.</p>

<p>Когда получены, значения сохраненные в столбце <code>SET</code>,
выведены на экран, используя регистр символов, который использовался в
определении столбца. Отметьте, что столбцам <code>SET</code> можно назначить
набор символов и сопоставление. Для двоичных или чувствительных к регистру
сопоставлений регистр принят во внимание, назначая значения.</p>

<p>MySQL хранит значения <code>SET</code> в цифровой форме, с битом младшего
разряда хранимого значения, соответствующего первому участнику набора. Если
Вы получаете значение <code>SET</code> в числовом контексте, полученное
значение есть набор битов, соответствующий участникам набора, которые
составляют значение столбца. Например, Вы можете получить числовые значения
из <code>SET</code> так:
<pre>
mysql&gt; SELECT <em><code>set_col</code></em>+0 FROM <em><code>tbl_name</code></em>;
</pre>

<p>Если число сохранено в столбец <code>SET</code>, биты, которые установлены
в двоичном представлении числа, определяют участников набора в значении
столбца. Для столбца, определенного как <code>SET('a','b','c','d')</code>,
у участников есть следующие десятичные и двоичные значения:</p>

<table border="1">
<thead><tr><th scope="col">Член <code>SET</code></th>
<th scope="col">Десятичное значение</th><th scope="col">Двоичное значение
</th></tr></thead>
<tbody><tr><td scope="row"><code>'a'</code></td><td><code>1</code></td>
<td><code>0001</code></td></tr>
<tr><td scope="row"><code>'b'</code></td><td><code>2</code></td>
<td><code>0010</code></td></tr>
<tr><td scope="row"><code>'c'</code></td><td><code>4</code></td>
<td><code>0100</code></td></tr>
<tr><td scope="row"><code>'d'</code></td><td><code>8</code></td>
<td><code>1000</code></td></tr></tbody></table>

<p>Если Вы назначаете значение <code>9</code> этому столбцу, оно является
<code>1001</code> в двоичном виде, таким образом, первый и четвертый члены
<code>SET</code> <code>'a'</code> и <code>'d'</code>
выбраны и получающееся значение <code>'a,d'</code>.</p>

<p>Для значения, содержащего больше чем один элемент <code>SET</code>, не
имеет значения порядок их перечисления. Также не имеет значения, сколько
раз данный элемент перечислен в значении. Когда значение получено позже,
каждый элемент в значении появляется однажды, с элементами, перечисленными
согласно порядку, в котором они были определены в табличном определении.
Например, предположите, что столбец определен как
<code>SET('a','b','c','d')</code>:
<pre>
mysql&gt; CREATE TABLE myset (col SET('a', 'b', 'c', 'd'));
</pre>

<p>Если Вы вставляете значения <code>'a,d'</code>,
<code>'d,a'</code>, <code>'a,d,d'</code>,
<code>'a,d,a'</code> и <code>'d,a,d'</code>:
<pre>
mysql&gt; INSERT INTO myset (col) VALUES
    -&gt;        ('a,d'), ('d,a'), ('a,d,a'), ('a,d,d'), ('d,a,d');
Query OK, 5 rows affected (0.01 sec)
Records: 5 Duplicates: 0 Warnings: 0
</pre>

<p>Тогда все эти значения появляются как <code>'a,d'</code>:
<pre>
mysql&gt; SELECT col FROM myset;
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
5 rows in set (0.04 sec)
</pre>

<p>Если Вы устанавливаете столбец <code>SET</code> к неподдержанному
значению, значение проигнорировано, и предупреждение создано:
<pre>
mysql&gt; INSERT INTO myset (col) VALUES ('a,d,d,s');
Query OK, 1 row affected, 1 warning (0.03 sec)

mysql&gt; SHOW WARNINGS;
+---------+------+------------------------------------------+
| Level   | Code | Message                                  |
+---------+------+------------------------------------------+
| Warning | 1265 | Data truncated for column 'col' at row 1 |
+---------+------+------------------------------------------+
1 row in set (0.04 sec)

mysql&gt; SELECT col FROM myset;
+------+
| col  |
+------+
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
| a,d  |
+------+
6 rows in set (0.01 sec)
</pre>

<p>Если строгий режим SQL включен, попытки вставить недопустимое
значение <code>SET</code> приводят к ошибке.</p>
<p>Значения <code>SET</code> отсортированы в цифровой форме. <code>NULL
</code> будет перед не-<code>NULL</code> членами <code>SET</code>.</p>

<p>Функции вроде <a href="funct.htm#function_sum"><code>SUM()</code></a> или
<a href="funct.htm#function_avg"><code>AVG()</code></a>, которые ожидают
числовой параметр, приводят параметр к числу в случае необходимости. Для
значения <code>SET</code> это заставляет числовое значение использоваться.
</p>

<p>Обычно Вы ищете значения <code>SET</code>, используя функцию
<a href="funct.htm#function_find-in-set"><code>FIND_IN_SET()</code></a>
или оператор <a href="funct.htm#operator_like"><code>LIKE</code></a>:
<pre>
mysql&gt; SELECT * FROM <em><code>tbl_name</code></em> WHERE
                   FIND_IN_SET('<em><code>value</code></em>', <em><code>set_col</code></em>) &gt;0;
mysql&gt; SELECT * FROM <em><code>tbl_name</code></em> WHERE
                   <em><code>set_col</code></em> LIKE '%<em><code>value</code></em>%';
</pre>

<p>Первый запрос находит строки, где
<em><code>set_col</code></em> содержит участника набора
<em><code>value</code></em>. Второй подобен, но не то же самое: находит
строки, где <em><code>set_col</code></em> содержит
<em><code>value</code></em> где угодно, как подстроку
другого участника набора.</p>

<p>Следующие запросы также разрешены:
<pre>
mysql&gt; SELECT * FROM <em><code>tbl_name</code></em> WHERE
                   <em><code>set_col</code></em> &amp; 1;
mysql&gt; SELECT * FROM <em><code>tbl_name</code></em> WHERE
                   <em><code>set_col</code></em> = '<em><code>val1</code></em>, <em><code>val2</code></em>';
</pre>

<p>Первый из этих запросов ищет значения, содержащие первого участника
набора. Второй ищет точное совпадение. Будьте осторожны со сравнениями
второго типа. Сравнение набора оценивая
<code>'<em><code>val1</code></em>,<em><code>val2</code></em>'</code>
возвращает различные результаты, чем сравнение значений
<code>'<em><code>val2</code></em>,<em><code>val1</code></em>'</code>.
Вы должны определить значения в том же самом порядке, в каком они
перечислены в определении столбца.</p>

<p>Определить все возможные значения для <code>SET</code> можно, применив
<code>SHOW COLUMNS FROM <em><code>tbl_name</code></em> LIKE
<em><code>set_col</code></em></code> и изучив определение <code>SET</code> в
столбце <code>Type</code> вывода.</p>

<p>В C API значения <code>SET</code> возвращены как строки. Для информации об
использовании метаданных о наборе результатов, чтобы отличить их от других
строк, см. <a href="connect.htm#c-api-data-structures">раздел 25.8.5</a>.</p>

<h2><a name="spatial-extensions"></a>12.5.
Расширения для пространственных данных</h2>
<p>Open Geospatial Consortium (OGC) является международным консорциумом более
250 компаний, агентств и университетов, участвующих в развитии публично
доступных концептуальных решений, которые могут быть полезными со всеми
видами приложений, которые управляют пространственными данными.</p>

<p>Open Geospatial Consortium издает
<em>OpenGIS Implementation Standard for Geographic
information - Simple feature access - Part 2: SQL option</em>,
документ, который предлагает несколько концептуальных путей к распространению
SQL RDBMS, чтобы поддержать пространственные данные. Эта спецификация
доступна с OGC Web site
<a href="../../../www.opengeospatial.org/standards/sfs" target="_top">
http://www.opengeospatial.org/standards/sfs</a>.</p>

<p>После спецификации OGC MySQL осуществляет пространственные расширения как
подмножество <span><strong>SQL с типами геометрии</strong></span>.
Этот термин относится к окружающей среде SQL, которая была расширена рядом
типов геометрии. Столбец со значением геометрии SQL осуществлен как столбец,
у которого есть тип геометрии. Спецификация описывает ряд типов геометрии
SQL, так же как функции на этих типах, чтобы создать и
проанализировать значения геометрии.</p>

<p>Пространственные расширения MySQL включают производство, хранение и
анализ географических особенностей:</p>
<ul><li><p>Типы данных для того, чтобы представить пространственные значения.
</li>
<li>Функции для того, чтобы управлять пространственными значениями.</li>
<li>Пространственная индексация для улучшения времени
доступа к пространственным столбцам.</p></li></ul>

<p>Типы данных и функции доступны для таблиц
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>,
<a href="innodb.htm"><code>InnoDB</code></a> и
<a href="storage.htm#archive-storage-engine"><code>ARCHIVE</code></a>.
Для того, чтобы индексировать пространственные столбцы,
<code>MyISAM</code> и <code>InnoDB</code> поддерживают индексы
<code>SPATIAL</code> и не-<code>SPATIAL</code>. Другие механизмы хранения
поддерживают не-<code>SPATIAL</code> индексы, как описано в
<a href="sql.htm#create-index">раздел 14.1.12</a>.</p>

<p><span><strong>Географическая особенность</strong></span> это что-либо в
мире, у чего есть местоположение. Особенность может быть:</p>

<ul><li><p>Объект. Например, гора, водоем, город.</li>
<li>Пространство. Например, городской район, тропики.</li>
<li>Определимое местоположение. Например, перекресток, как особое место,
где две улицы пересекаются.</p></li></ul>

<p>Некоторые документы используют термин <span><strong>geospatial
feature</strong></span>, чтобы обратиться к географическим особенностям.</p>
<p><span><strong>Геометрия</strong></span> другое слово, которое обозначает
географическую особенность. Первоначально слово "геометрия" означало
измерение земли. Другое значение прибывает из картографии, обращаясь к
геометрическим функциям, которые картографы используют, чтобы отобразить мир.
</p>

<p>Обсуждение здесь считает эти термины синонимичными:
<span><strong>географическая особенность</strong></span>,
<span><strong>geospatial feature</strong></span>,
<span><strong>особенность</strong></span> или
<span><strong>геометрия</strong></span>. Термином, обычно используемым,
является <span><strong>геометрия</strong></span>, определенная как
<span><em>пункт или совокупность пунктов, представляющих что-либо в мире, у
чего есть местоположение</em></span>.</p>

<p>Следующий материал затрагивает эти темы:</p>
<ul><li><p>Пространственные типы данных осуществлены в модели MySQL.</li>
<li>Основание пространственных расширений в модели геометрии OpenGIS.</li>
<li>Форматы данных для того, чтобы представить пространственные данные.</li>
<li>Как использовать пространственные данные в MySQL.</li>
<li>Использование индексации для пространственных данных.</li>
<li>Отличия MySQL от спецификации OpenGIS.</p></li></ul>

<h3><a name="idm139965359989104"></a>Соответствие и совместимость MySQL GIS
</h3>
<p>MySQL не реализует следующие опции GIS:</p>
<ul><li><p>Дополнительные представления метаданных.</p>
<p>Технические требования OpenGIS предлагают несколько дополнительных
представлений метаданных. Например, системное представление, называемое
<code>GEOMETRY_COLUMNS</code>, содержит описание столбцов геометрии, по одной
строке для каждого столбца геометрии в базе данных.</li>

<li>Функция OpenGIS <a href="funct.htm#function_length"><code>Length()</code>
</a> на <code>LineString</code> и <code>MultiLineString</code>
должна быть вызвана в MySQL как
<a href="funct.htm#function_st-length"><code>ST_Length()</code></a>.</p>

<p>Проблема состоит в том, что есть существующая функция SQL
<a href="funct.htm#function_length"><code>Length()</code></a>,
это вычисляет длину строковых значений, и иногда невозможно различить,
вызвана ли функция в текстовом или пространственном контексте.</p></li></ul>

<h3><a name="idm139965359978608"></a>Дополнительные ресурсы</h3>
<ul><li><p>The Open Geospatial Consortium издает
<em class="citetitle">OpenGIS Implementation Standard for Geographic
information - Simple feature access - Part 2: SQL option</em>,
документ, который предлагает несколько концептуальных путей к распространению
SQL RDBMS, чтобы поддержать пространственные данные. The Open Geospatial
Consortium (OGC) поддерживает Web-сайт
<a href="../../../www.opengeospatial.org/default.htm" target="_top">
http://www.opengeospatial.org/</a>. Спецификация доступна там на
<a href="../../../www.opengeospatial.org/standards/sfs" target="_top">
http://www.opengeospatial.org/standards/sfs</a>. Это содержит дополнительную
информацию, относящуюся к материалам здесь.</li>

<li>Если у Вас есть вопросы или проблемы по поводу использования
пространственных расширений MySQL, Вы можете обсудить их на форуме GIS:
<a href="../../../forums.mysql.com/list.php@23" target="_top">
http://forums.mysql.com/list.php?23</a>.</p></li></ul>

<h3><a name="spatial-datatypes"></a>12.5.1. Пространственные типы данных</h3>
<p>У MySQL есть типы данных, которые соответствуют классам OpenGIS. Некоторые
из этих типов содержат единственные значения геометрии:</p>

<ul><li><p><code>GEOMETRY</code></li>
<li><code>POINT</code></li>
<li><code>LINESTRING</code></li>
<li><code>POLYGON</code></p></li></ul>

<p><code>GEOMETRY</code> может сохранить значения геометрии любого типа.
Другие типы единственного значения (<code>POINT</code>,
<code>LINESTRING</code> и <code>POLYGON</code>)
ограничивают их значения особым типом геометрии.</p>

<p>Другие типы данных содержат наборы значений:</p>
<ul><li><p><code>MULTIPOINT</code></li>
<li><code>MULTILINESTRING</code></li>
<li><code>MULTIPOLYGON</code></li>
<li><code>GEOMETRYCOLLECTION</code></p></li></ul>

<p><code>GEOMETRYCOLLECTION</code> может сохранить набор объектов любого
типа. Другие типы (<code>MULTIPOINT</code>, <code>MULTILINESTRING</code>,
<code>MULTIPOLYGON</code> и <code>GEOMETRYCOLLECTION</code>)
ограничивают участников набора теми, которые имеют особый тип геометрии.</p>

<p>У пространственных типов данных MySQL есть своя основа в модели геометрии
OpenGIS, описанной в <a href="#opengis-geometry-model">
разделе 12.5.2</a>. Для примеров, показывающих, как использовать
пространственные типы данных в MySQL, см.
<a href="#using-spatial-data">раздел 12.5.3</a>.</p>

<h3><a name="opengis-geometry-model"></a>12.5.2. Модель геометрии OpenGIS</h3>
<p>Набор типов геометрии, предложенных OGC's
<span><strong>SQL with Geometry Types</strong></span>, основан на
<span><strong>OpenGIS Geometry Model</strong></span>. В этой модели у
каждого геометрического объекта есть следующие общие свойства:</p>

<ul><li><p>Это связано с пространственной ссылочной системой, которая
описывает координатное пространство, в котором определен объект.</li>
<li>Это принадлежит некоторому классу геометрии.</p></li></ul>

<h4><a name="gis-geometry-class-hierarchy"></a>12.5.2.1.
Иерархия классов геометрии</h4>
<p>Классы геометрии определяют иерархию следующим образом:</p>

<ul><li><p><code>Geometry</code> (noninstantiable)</p>
<ul><li><p><code>Point</code> (instantiable)</li>
<li><code>Curve</code> (noninstantiable)</p>
<ul><li><p><code>LineString</code> (instantiable)</p>
<ul><li><p><code>Line</code></li>
<li><code>LinearRing</code></p></li></ul></li></ul></li>
<li><p><code>Surface</code> (noninstantiable)</p>
<ul><li><p><code>Polygon</code> (instantiable)</p></li></ul></li>
<li><p><code>GeometryCollection</code> (instantiable)</p>
<ul><li><p><code>MultiPoint</code> (instantiable)</li>
<li><code>MultiCurve</code> (noninstantiable)</p>
<ul><li><p><code>MultiLineString</code> (instantiable)</p></li></ul></li>
<li><p><code>MultiSurface</code> (noninstantiable)</p>
<ul><li><p><code>MultiPolygon</code> (instantiable)
</li></ul></li></ul></li></ul></li></ul>

<p>Невозможно создать объекты в noninstantiable классах. Возможно создать
объекты в instantiable классах. У всех классов есть свойства, у
instantiable классов могут также быть утверждения (правила, которые
определяют допустимые экземпляры класса).</p>

<p><code>Geometry</code> базовый класс. Это абстрактный класс. instantiable
подклассы <code>Geometry</code> ограничены 0, 1 и 2-мерными геометрическими
объектами, которые существуют в двумерном координатном пространстве.
Все instantiable классы геометрии определены так, чтобы допустимые экземпляры
класса геометрии были топологически закрыты (то есть, все определенные
конфигурации включают свою границу).</p>

<p>У базового класса <code>Geometry</code> есть подклассы для
<code>Point</code>, <code>Curve</code>, <code>Surface</code> и
<code>GeometryCollection</code>:</p>

<ul><li><p><code>Point</code> представляет нуль-мерные объекты.</li>
<li><code>Curve</code> представляет одномерные объекты и имеет подкласс
<code>LineString</code> с подподклассами
<code>Line</code> и <code>LinearRing</code>.</li>

<li><code>Surface</code> разработан для двумерных объектов и имеет подкласс
<code>Polygon</code>.</li>
<li><code>GeometryCollection</code> имеет специальные
ноль-, одно- и двумерные классы набора, названные
<code>MultiPoint</code>, <code>MultiLineString</code> и
<code>MultiPolygon</code> для того, чтобы смоделировать конфигурации,
соответствующие наборам <code>Points</code>,
<code>LineStrings</code> и <code>Polygons</code>, соответственно.
<code>MultiCurve</code> и <code>MultiSurface</code> введены как абстрактные
суперклассы, которые обобщают интерфейсы набора, чтобы
обработать <code>Curves</code> и <code>Surfaces</code>.</p></li></ul>

<p><code>Geometry</code>, <code>Curve</code>,
<code>Surface</code>, <code>MultiCurve</code> и <code>MultiSurface</code>
определены как noninstantiable классы. Они определяют единый набор методов
для их подклассов и включены для расширяемости.</p>

<p><code>Point</code>, <code>LineString</code>, <code>Polygon</code>,
<code>GeometryCollection</code>, <code>MultiPoint</code>,
<code>MultiLineString</code> и <code>MultiPolygon</code> instantiable классы.
</p>

<h4><a name="gis-class-geometry"></a>12.5.2.2. Класс геометрии</h4>
<p><code>Geometry</code> класс корня иерархии. Это noninstantiable класс, но
имеет много свойств, описанных в следующем списке, которые характерны для
любой геометрии, созданной от любого из подклассов <code>Geometry</code>.
У особых подклассов есть свои собственные определенные
свойства, описанные позже.</p>

<p><span><strong>Свойства геометрии</strong></span></p>
<p>У значения геометрии есть следующие свойства:</p>
<ul><li><p>Его <span><strong>тип</strong></span>. Каждая геометрия
принадлежит одному из instantiable классов в иерархии.</li>

<li>Его <span><strong>SRID</strong></span> или пространственный ссылочный
идентификатор. Это значение идентифицирует связанную пространственную
ссылочную систему геометрии, которая описывает координатное пространство, в
котором определен объект геометрии.</p>

<p>В MySQL SRID целое число, связанное со значением геометрии. Все вычисления
сделаны, принимая Евклидову (плоскую) геометрию. Максимальное применимое
значение SRID 2<sup>32</sup>-1. Если большее значение дано, используются
только нижние 32 бита.</li>

<li>Его <span><strong>координаты</strong></span> в его пространственной
ссылочной системе, представленной как числа двойной точности (8 байтов).
Все непустые конфигурации включают по крайней мере одну пару (X,Y) координат.
Пустые конфигурации не содержат координат.</p>

<p>Координаты связаны с SRID. Например, в различных системах координат,
расстояние между двумя объектами может отличаться, даже когда у объектов есть
те же самые координаты, потому что расстояние на <span><strong>плоской
</strong></span> системе координат и расстояние на <span><strong>
геодезической</strong></span> системе (координаты на поверхности Земли)
являются разными вещами.</li>

<li>Ее <span><strong>интерьер</strong></span>, <span><strong>граница</strong>
</span> и <span><strong>внешность</strong></span>.</p>
<p>Каждая геометрия занимает некоторую позицию в пространстве. Внешность
геометрии все место, не занятое геометрией. Интерьер место, занятое
геометрией. Граница интерфейс между интерьером геометрии и внешностью.</li>

<li>Его <span><strong>MBR</strong></span> (минимальный ограничительный
прямоугольник) или конверт. Это геометрия ограничения, сформированная
минимумом и максимумом (X, Y) координат:
<pre>
((MINX MINY, MAXX MINY, MAXX MAXY, MINX MAXY, MINX MINY))
</pre></li>

<li> Значение <span><strong>простое</strong></span> или
<span><strong>непростое</strong></span>. Значения геометрии типов
(<code>LineString</code>, <code>MultiPoint</code>,
<code>MultiLineString</code>) просты или непросты. Каждый тип определяет свои
собственные утверждения для того, чтобы быть простым или непростым.</li>

<li><span><strong>Закрыто</strong></span> ли значение или
<span><strong>не закрыто</strong></span>. Значения геометрии типов
(<code>LineString</code>, <code>MultiString</code>) закрыты или не закрыты.
Каждый тип определяет свои собственные утверждения для того, чтобы быть
закрытым или не закрытым.</li>

<li><span><strong>Пусто</strong></span> значение или
<span><strong>непусто</strong></span>, геометрия пуста, если у нее нет
никаких пунктов. Внешность, интерьер и граница пустой геометрии не
определены (то есть, они представлены значением <code>NULL</code>). Пустая
геометрия определена, чтобы быть всегда простой и имеет область 0.</li>

<li>Его <span><strong>измерение</strong></span>. У геометрии может быть
измерение -1, 0, 1 или 2:</p>
<ul><li><p>-1 для пустой геометрии.</li>
<li>0 для геометрии без длины и области.</li>
<li>1 для геометрии с длиной отличной от нуля и нулевой областью.</li>
<li>2 для геометрии с областью отличной от нуля.</p></li></ul>

<p>Объекты <code>Point</code> имеют измерение 0. У объектов
<code>LineString</code> есть измерение 1. У объектов <code>Polygon</code>
есть измерение 2. Измерения объектов <code>MultiPoint</code>,
<code>MultiLineString</code> и <code>MultiPolygon</code> такие же, как
измерения элементов, из которых они состоят.</p></li></ul>

<h4><a name="gis-class-point"></a>12.5.2.3. Класс Point</h4>
<p><code>Point</code> геометрия, которая представляет единственное
местоположение в координатном пространстве.</p>

<p>Примеры <span>Point</code></strong></span>:</p>
<ul><li><p>Вообразите крупномасштабную карту мира со многими городами.
Объект <code>Point</code> может представить каждый город.</li>
<li>На городской карте объект <code>Point</code> может
представить автобусную остановку.</p></li></ul>

<p>Свойства <span>Point</code>:</strong></span></p>
<ul><li><p>Значение X-координаты.</li>
<li>Значение Y-координаты.</li>
<li><code>Point</code> определен как 0-мерная геометрия.</li>
<li>Граница a <code>Point</code> пустой набор.</p></li></ul>

<h4><a name="gis-class-curve"></a>12.5.2.4. Класс Curve</h4>
<p><code>Curve</code> одномерная геометрия, обычно представляемая
последовательностью пунктов. Особые подклассы <code>Curve</code> определяют
тип интерполяции между пунктами. <code>Curve</code> noninstantiable класс.
</p>

<p>Свойства <span>Curve</code>:</strong></span></p>
<ul><li><p><code>Curve</code> имеет координаты его пунктов.</li>
<li><code>Curve</code> определен как одномерная геометрия.</li>

<li><code>Curve</code> просто, если это не проходит через тот же самый пункт
дважды, за исключением того, что кривая может все еще быть простой, если
конечные точки те же самые.</li>

<li><code>Curve</code> закрыт, если его стартовая точка равна
его конечной точке.</li>
<li>Граница закрытого <code>Curve</code> пуста.</li>

<li>Граница незакрытого <code>Curve</code> состоит из его
двух конечных точек.</li>
<li><code>Curve</code>, который прост и закрыт, это
<code>LinearRing</code>.</p></li></ul>

<h4><a name="gis-class-linestring"></a>12.5.2.5. Класс LineString</h4>
<p><code>LineString</code> это <code>Curve</code>
с линейной интерполяцией между пунктами.</p>

<p>Примеры <span>LineString</code>:</strong></span></p>
<ul><li><p>На мировой карте объекты <code>LineString</code>
могут представить реки.</li>
<li>В городской карте объекты <code>LineString</code>
могут представить улицы.</p></li></ul>

<p>Свойства <span>LineString</code></strong></span>:</p>

<ul><li><p><code>LineString</code> имеет координаты сегментов, определенных
каждой последовательной парой пунктов.</li>
<li><code>LineString</code> это <code>Line</code>,
если это состоит точно из двух пунктов.</li>
<li><code>LineString</code> это <code>LinearRing</code>,
если это закрыто и просто.</p></li></ul>

<h4><a name="gis-class-surface"></a>12.5.2.6. Класс Surface</h4>
<p><code>Surface</code> двумерная геометрия. Это noninstantiable класс. Его
единственный instantiable подкласс <code>Polygon</code>.</p>

<p>Свойства <span>Surface</code></strong></span>:</p>
<ul><li><p><code>Surface</code> определен как двумерная геометрия.</li>
<li>Спецификация OpenGIS определяет простой <code>Surface</code>
как геометрию, которая состоит из единственного <span>patch</span>, который
связан с единственной внешней границей и нолем или большим
количеством внутренних границ.</li>
<li>Граница простого <code>Surface</code> это набор закрытых кривых,
соответствующих его внешним и внутренним границам.</p></li></ul>

<h4><a name="gis-class-polygon"></a>12.5.2.7. Класс Polygon</h4>
<p><code>Polygon</code> это плоское представление <code>Surface</code>
мультипримкнутой геометрии. Это определено единственной внешней границей и
нолем или большим количеством внутренних границ, где каждая внутренняя
граница определяет отверстие в <code>Polygon</code>.</p>

<p>Примеры <span>Polygon</code></strong></span>:</p>
<ul><li><p>На карте области объекты <code>Polygon</code> могут
представить леса, районы и так далее.</p></li></ul>

<p>Утверждения <span>Polygon</code>:</p>
<ul><li><p>Граница <code>Polygon</code> состоит из ряда объектов
<code>LinearRing</code> (то есть, объектов <code>LineString</code>, которые
просты и закрыты), которые составляют его внешние и внутренние границы.</li>

<li><code>Polygon</code> не имеет никаких колец, которые пересекаются.
Кольца в границе <code>Polygon</code> могут пересечься в <code>Point</code>,
но только как тангенс.</li>

<li><code>Polygon</code> не имеет никаких линий, шипов или проколов.</li>
<li><code>Polygon</code> имеет интерьер, который является
соединенным набором пунктов.</li>

<li><code>Polygon</code> может иметь отверстия. Внешность
<code>Polygon</code> с отверстиями не соединена. Каждое отверстие определяет
соединенный компонент внешности.</p></li></ul>
<p>Предыдущие утверждения делают <code>Polygon</code> простой геометрией.</p>

<h4><a name="gis-class-geometrycollection"></a>12.5.2.8. Класс
GeometryCollection</h4>
<p><code>GeometryCollection</code> геометрия, которая является набором из
одной или более конфигураций любого класса.</p>

<p>Все элементы в <code>GeometryCollection</code> должны быть в той же самой
пространственной ссылочной системе (то есть, в той же самой системе
координат). Нет никаких других ограничений на элементы
<code>GeometryCollection</code>, хотя подклассы
<code>GeometryCollection</code> в следующих разделах могут ограничить
членство. Ограничения могут быть основаны на:</p>

<ul><li><p>Тип элемента (например, <code>MultiPoint</code>
может содержать только <code>Point</code>).</li>
<li>Измерение.</li>
<li>Ограничения на степень пространственного перекрытия между элементами.
</p></li></ul>

<h4><a name="gis-class-multipoint"></a>12.5.2.9. Класс MultiPoint</h4>
<p><code>MultiPoint</code> набор геометрии, составленный из
<code>Point</code>. Пункты не соединены или упорядочены в любом случае.</p>

<p>Примеры <span>MultiPoint</code>:</p>
<ul><li><p>На мировой карте <code>MultiPoint</code> может
представить цепочку небольших островов.</li>
<li>На городской карте <code>MultiPoint</code> может
представить билетные кассы.</p></li></ul>

<p>Свойства <span>MultiPoint</code>:</p>
<ul><li><p><code>MultiPoint</code> геометрия 0-мерная.</li>
<li><code>MultiPoint</code> просто, если никакие два <code>Point</code> не
равны (имеют идентичные координатные значения).</li>
<li>Граница <code>MultiPoint</code> пустой набор.</p></li></ul>

<h4><a name="gis-class-multicurve"></a>12.5.2.10. Класс MultiCurve</h4>
<p><code>MultiCurve</code> набор геометрии, составленный из
<code>Curve</code>. <code>MultiCurve</code> noninstantiable класс.</p>

<p>Свойства <span>MultiCurve</code>:</p>
<ul><li><p><code>MultiCurve</code> одномерная геометрия.</li>
<li><code>MultiCurve</code> просто, если и только если все его элементы
просты: единственные пересечения между любыми двумя элементами происходят в
пунктах, которые находятся на границах обоих элементов.</li>

<li>Граница <code>MultiCurve</code> получена, применяя
<span>mod 2 union rule</span> (также известно как <span>odd-even rule
</span>): пункт находится в границе <code>MultiCurve</code>, если это
находится в границах нечетного числа элементов <code>Curve</code>.</li>
<li><code>MultiCurve</code> закрыт, если все его элементы закрыты.</li>
<li>Граница закрытого <code>MultiCurve</code> всегда пуста.</p></li></ul>

<h4><a name="gis-class-multilinestring"></a>12.5.2.11. Класс MultiLineString
</h4>
<p><code>MultiLineString</code> это набор геометрии <code>MultiCurve</code>
из элементов <code>LineString</code>.</p>
<p>Примеры <span>MultiLineString</code>:</p>
<ul><li><p>На карте области <code>MultiLineString</code> может
представить речную или магистральную систему.</p></li></ul>

<h4><a name="gis-class-multisurface"></a>12.5.2.12. Класс MultiSurface</h4>
<p><code>MultiSurface</code> набор геометрии, составленный из поверхностных
элементов. <code>MultiSurface</code> noninstantiable класс. Его единственный
instantiable подкласс <code>MultiPolygon</code>.</p>

<p>Утверждения <code>MultiSurface</code>:</p>
<ul><li><p>Поверхности в пределах <code>MultiSurface</code>
не имеют никаких интерьеров, которые пересекаются.</li>
<li>Поверхности в пределах <code>MultiSurface</code> имеют границы, которые
пересекаются самое большее в конечном числе точек.</p></li></ul>

<h4><a name="gis-class-multipolygon"></a>12.5.2.13. Класс MultiPolygon</h4>
<p><code>MultiPolygon</code> это объект <code>MultiSurface</code>
из элементов <code>Polygon</code>.</p>

<p>Примеры <code>MultiPolygon</code>:</p>
<ul><li><p>На карте области <code>MultiPolygon</code> может
представить систему озер.</p></li></ul>

<p>Утверждения <code>MultiPolygon</code></span>:</p>
<ul><li><p><code>MultiPolygon</code> не имеет никаких двух элементов
<code>Polygon</code> с интерьерами, которые пересекаются.</li>

<li><code>MultiPolygon</code> не имеет никаких двух элементов
<code>Polygon</code>, которые пересекаются (пересечение также запрещено
предыдущим утверждением), или которые заходят в бесконечное число пунктов.
</li>

<li><code>MultiPolygon</code> возможно, не сократил строки, шипы или
проколы. <code>MultiPolygon</code> закрытый набор пунктов.</li>
<li><code>MultiPolygon</code> имеет больше одного <code>Polygon</code>,
имеющий интерьер, который не соединен. Число соединенных компонентов
интерьера <code>MultiPolygon</code> равно числу значений <code>Polygon</code> values in the
в <code>MultiPolygon</code>.</p></li></ul>

<p>Свойства <span>MultiPolygon</code></span>:</p>
<ul><li><p>У <code>MultiPolygon</code> двумерная геометрия.</li>
<li>Граница <code>MultiPolygon</code> ряд закрытых кривых (значения
<code>LineString</code>), соответствующих границам элементов <code>Polygon
</code>.</li>

<li>Каждый <code>Curve</code> в границе <code>MultiPolygon</code> находится в
границе точно одного <code>Polygon</code>.</li>
<li>Каждый <code>Curve</code> в границе <code>Polygon</code> находится в
границе <code>MultiPolygon</code>.</p></li></ul>

<h3><a name="using-spatial-data"></a>12.5.3.
Использование пространственных данных</h3>
<p>Этот раздел описывает, как составить таблицы, которые включают столбцы с
типами пространственных данных, и как управлять пространственной информацией.
</p>

<h4><a name="gis-data-formats"></a>12.5.3.1.
Поддержанные пространственные форматы данных/h4>
<p>Два стандартных пространственных формата данных используются, чтобы
представить объекты геометрии в запросах:</p>

<ul><li><p>Well-Known Text (WKT).</li>
<li>Well-Known Binary (WKB).</p></li></ul>
<p>Внутренне MySQL хранит значения геометрии в формате, который не идентичен
ни одному из них.</p>

<p>Есть функции, доступные, чтобы преобразовать между различными форматами
данных, см. <a href="funct.htm#gis-format-conversion-functions">раздел
13.15.6</a>.</p>

<h5><a name="gis-wkt-format"></a>12.5.3.1.1. Формат Well-Known Text (WKT)</h5>
<p>Well-Known Text (WKT) разработан для того, чтобы обменяться информациями
геометрии в форме ASCII. Спецификация OpenGIS обеспечивает грамматику
Backus-Naur, которая определяет формальные производственные правила для того,
чтобы написать значения WKT (см. <a href="#spatial-extensions">
раздел 12.5</a>).</p>

<p>Примеры представлений WKT объектов геометрии:</p>
<ul><li><p><code>Point</code>:
<pre>
POINT(15 20)
</pre>

<p>Координаты пункта определены без отделения запятой. Это отличается от
синтаксиса для функции SQL <a href="funct.htm#function_point"><code>Point()
</code></a>, которая требует запятой между координатами. Заботьтесь, чтобы
использовать синтаксис, соответствующий контексту данной пространственной
работы. Например, следующие запросы оба извлекают X-координату из
<code>Point</code>. Первый вернет объект, непосредственно используя функцию
<a href="funct.htm#function_point"><code>Point()</code></a>. Второй применит
представление WKT, преобразованное в <code>Point</code> через
<code>GeomFromText()</code>.
<pre>
mysql&gt; SELECT ST_X(Point(15, 20));
+---------------------+
| ST_X(POINT(15, 20)) |
+---------------------+
| 15                  |
+---------------------+

mysql&gt; SELECT ST_X(ST_GeomFromText('POINT(15 20)'));
+---------------------------------------+
| ST_X(ST_GeomFromText('POINT(15 20)')) |
+---------------------------------------+
| 15                                    |
+---------------------------------------+
</pre></li>

<li><p><code>LineString</code> с четырьмя пунктами:
<pre>
LINESTRING(0 0, 10 10, 20 25, 50 60)
</pre>
<p>Пары координат пунктов отделены запятыми.</li>

<li><code>Polygon</code> с одним внешним и одним внутренним кольцом:
<pre>
POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))
</pre></li>

<li><code>MultiPoint</code> с тремя <code>Point</code>:
<pre>
MULTIPOINT(0 0, 20 20, 60 60)
</pre>

 <p>В MySQL 8.0 такие пространственные функции, как
<a href="funct.htm#function_st-mpointfromtext"><code>ST_MPointFromText()
</code></a> и <a href="funct.htm#function_st-geomfromtext"><code>
ST_GeomFromText()</code></a>, принимая представленные в WKT-формате значения
<code>MultiPoint</code>, разрешают отдельным пунктам в пределах значений быть
окруженными круглыми скобками. Например, оба из следующих
вызовов функции допустимы:
<pre>
ST_MPointFromText('MULTIPOINT (1 1, 2 2, 3 3)')
ST_MPointFromText('MULTIPOINT ((1 1), (2 2), (3 3))')
</pre></li>

<li><code>MultiLineString</code> с двумя <code>LineString</code>:
<pre>
MULTILINESTRING((10 10, 20 20), (15 15, 30 15))
</pre></li>

<li><code>MultiPolygon</code> с двумя <code>Polygon</code>:
<pre>
MULTIPOLYGON(((0 0,10 0,10 10,0 10,0 0)),((5 5,7 5,7 7,5 7, 5 5)))
</pre></li>

<li><code>GeometryCollection</code> состоящая из двух
<code>Point</code> и одного <code>LineString</code>:
<pre>
GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))
</pre></li></ul>

<h5><a name="gis-wkb-format"></a>12.5.3.1.2. Формат Well-Known Binary (WKB)
</h5>
<p>Well-Known Binary (WKB) используется для того, чтобы обменяться
информациями геометрии как двоичными потоками, представленными значениями
<a href="#blob"><code>BLOB</code></a>, содержащими геометрическую
информацию WKB. Этот формат определен спецификацией OpenGIS (см.
<a href="#spatial-extensions">раздел 12.5</a>). Это также определено
в ISO <em class="citetitle">SQL/MM Part 3: Spatial</em>.</p>

<p>WKB использует 1-байтовые unsigned integer, 4-байтовые unsigned integer и
8-байтовые числа двойной точности (формат IEEE 754).
Байт составляет восемь битов.</p>

<p>Например, значение WKB, которое соответствует <code>POINT(1 1)</code>
состоит из этой последовательности 21 байта, каждый представлен
двумя шестнадцатеричными цифрами:
<pre>
0101000000000000000000F03F000000000000F03F
</pre>

<p>Последовательность состоит из этих компонентов:
<pre>
Byte order: 01
WKB type: 01000000
X coordinate: 000000000000F03F
Y coordinate: 000000000000F03F
</pre>

<p>Составляющее представление следующие:</p>
<ul><li><p>Порядок байтов 1 или 0, чтобы указать тип хранения little-endian
или big-endian. Типы хранения также известны как Network Data Representation
(NDR) и External Data Representation (XDR), соответственно.</li>

<li>Тип WKB код, который указывает на тип геометрии. Значения от 1 до 7
указывают <code>Point</code>, <code>LineString</code>, <code>Polygon</code>,
<code>MultiPoint</code>, <code>MultiLineString</code>,
<code>MultiPolygon</code> и <code>GeometryCollection</code>.</li>

<li>Значение <code>Point</code> имеет координаты X и Y, каждая представлена
как значение двойной точности.</p></li></ul>
<p>У значений WKB для более сложных значений геометрии есть более сложные
структуры данных, как детализировано в спецификации OpenGIS.</p>

<h4><a name="creating-spatial-columns"></a>12.5.3.2.
Создание пространственных столбцов</h4>
<p>MySQL обеспечивает стандартный способ создать пространственные столбцы для
типов геометрии, например, с <a href="sql.htm#create-table"><code>CREATE
TABLE</code></a> или <a href="sql.htm#alter-table"><code>ALTER TABLE</code>
</a>. Пространственные столбцы поддержаны для таблиц
<a href="storage.htm#myisam-storage-engine"><code>MyISAM</code></a>,
<a href="innodb.htm"><code>InnoDB</code></a>,
<a href="../../../dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html"
target="_top"><code>NDB</code></a> и
<a href="storage.htm#archive-storage-engine"><code>ARCHIVE</code></a>.</p>

<ul><li><p>Используйте <a href="sql.htm#create-table"><code>CREATE TABLE
</code></a>, чтобы составить таблицу с пространственным столбцом:
<pre>
CREATE TABLE geom (g GEOMETRY);
</pre></li>

<li>Используйте <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>,
чтобы добавить или удалить пространственный столбец существующей таблицы:
<pre>
ALTER TABLE geom ADD pt POINT;
ALTER TABLE geom DROP pt;
</pre></li></ul>

<h4><a name="populating-spatial-columns"></a>12.5.3.3.
Заполнение пространственных столбцов</h4>
<p>После того, как Вы создали пространственные столбцы, Вы можете заполнить
их пространственными данными.</p>

<p>Значения должны быть сохранены во внутреннем формате геометрии, но Вы
можете преобразовать их в этот формат из Well-Known Text (WKT) или Well-Known
Binary (WKB). Следующие примеры демонстрируют, как вставить значения
геометрии в таблицу, преобразовывая значения WKT во
внутренний формат геометрии:</p>

<ul><li><p>Выполните преобразование непосредственно в
<a href="sql.htm#insert"><code>INSERT</code></a>:
<pre>
INSERT INTO geom VALUES (ST_GeomFromText('POINT(1 1)'));
SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (ST_GeomFromText(@g));
</pre></li>

<li>Выполните преобразование до
<a href="sql.htm#insert"><code>INSERT</code></a>:
<pre>
SET @g = ST_GeomFromText('POINT(1 1)');
INSERT INTO geom VALUES (@g);
</pre></li></ul>

<p>Следующие примеры вставляют более сложные конфигурации в таблицу:
<pre>
SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (ST_GeomFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (ST_GeomFromText(@g));

SET @g = 'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (ST_GeomFromText(@g));
</pre>

<p>Предыдущее использование в качестве примера
<a href="funct.htm#function_st-geomfromtext"><code>ST_GeomFromText()</code>
</a>. Вы можете также использовать определенные для типа функции:
<pre>
SET @g = 'POINT(1 1)';
INSERT INTO geom VALUES (ST_PointFromText(@g));

SET @g = 'LINESTRING(0 0,1 1,2 2)';
INSERT INTO geom VALUES (ST_LineStringFromText(@g));

SET @g = 'POLYGON((0 0,10 0,10 10,0 10,0 0),(5 5,7 5,7 7,5 7, 5 5))';
INSERT INTO geom VALUES (ST_PolygonFromText(@g));

SET @g = 'GEOMETRYCOLLECTION(POINT(1 1),LINESTRING(0 0,1 1,2 2,3 3,4 4))';
INSERT INTO geom VALUES (ST_GeomCollFromText(@g));
</pre>

<p>Программа приложения-клиента, которая хочет использовать представления
значений геометрии WKB, ответственна за посылку правильно сформированных WKB
в запросах к серверу. Есть несколько способов удовлетворить
это требование. Например:</p>

<ul><li><p>Вставить значение <code>POINT(1 1)</code> с
шестнадцатеричным литералом:
<pre>
mysql&gt; INSERT INTO geom VALUES
    -&gt; (ST_GeomFromWKB(0x0101000000000000000000F03F000000000000F03F));
</pre></li>

<li>Приложение ODBC может послать представление WKB, связывая это с
заполнителем, используя параметр типа <a href="#blob"><code>BLOB
</code></a>:
<pre>
INSERT INTO geom VALUES (ST_GeomFromWKB(?))
</pre>
<p>Другие программные интерфейсы могут поддержать
подобный механизм заполнителя.</li>

<li>В программе на C Вы можете экранировать двоичное значение, применив
<a href="connect.htm#mysql-real-escape-string-quote"><code>
mysql_real_escape_string_quote()</code></a> и включив результат в строку
запроса, которую посылают в сервер. См.
<a href="connect.htm#mysql-real-escape-string-quote">раздел 25.8.7.56</a>.
</p></li></ul>

<h4><a name="fetching-spatial-data"></a>12.5.3.4.
Установка пространственных данных</h4>
<p>Значения геометрии, сохраненные в таблице, могут быть получены во
внутреннем формате. Вы можете также преобразовать их в формат WKB или WKT.
</p>

<ul><li><p>Установка пространственных данных во внутреннем формате:</p>
<p>Значения геометрии, использующие внутренний формат могут быть полезными в
передачах от таблицы к таблице:
<pre>
CREATE TABLE geom2 (g GEOMETRY) SELECT g FROM geom;
</pre></li>

<li>Установка пространственных данных в формате WKT:</p>
<p>Функция <a href="funct.htm#function_st-astext"><code>ST_AsText()</code>
</a> преобразовывает геометрию из внутреннего формата в строку WKT.
<pre>
SELECT ST_AsText(g) FROM geom;
</pre></li>

<li>Установка пространственных данных в формате WKB:</p>
<p>Функция <a href="funct.htm#function_st-asbinary"><code>ST_AsBinary()
</code></a>преобразовывает геометрию из внутреннего формата в WKB
<a href="#blob"><code>BLOB</code></a>.
<pre>
SELECT ST_AsBinary(g) FROM geom;
</pre></li></ul>

<h4><a name="optimizing-spatial-analysis"></a>12.5.3.5.
Оптимизация пространственного анализа</h4>
<p>Для таблиц <a href="storage.htm#myisam-storage-engine"><code>MyISAM</code>
</a> и <code>InnoDB</code> операции поиска в столбцах, содержащих
пространственные данные, могут быть оптимизированы, используя индексы
<code>SPATIAL</code>. Самые типичные операции:</p>

<ul><li><p>Запросы пункта, которые ищут все объекты, которые
содержат данный пункт.</li>
<li>Запросы области, которые ищут все объекты, которые
перекрывают данную область.</p></li></ul>

<p>MySQL использует <span><strong>R-Trees с квадратным разделением</strong>
</span> для индексов <code>SPATIAL</code> на пространственных столбцах.
Индекс <code>SPATIAL</code> создан, используя минимальный ограничительный
прямоугольник (MBR) геометрии. Для большинства конфигураций MBR минимальный
прямоугольник, который окружает конфигурации. Для горизонтального или
вертикального linestring MBR прямоугольник, деградировавший в linestring. Для
point MBR прямоугольник, деградировавший в point.</p>

<p>Также возможно создать нормальный индекс на пространственных столбцах. В
не-<code>SPATIAL</code> индексе Вы должны объявить префикс для любого
пространственного столбца за исключением <code>POINT</code>.</p>

<p><code>MyISAM</code> и <code>InnoDB</code> поддерживают индексы
<code>SPATIAL</code> и не-<code>SPATIAL</code>.
Другие механизмы хранения поддерживают индексы не-<code>SPATIAL</code>,
как описано в <a href="sql.htm#create-index">раздел 14.1.12</a>.</p>

<h4><a name="creating-spatial-indexes"></a>12.5.3.6.
Пространственное создание индексов</h4>
<p>Для таблиц <a href="storage.htm#myisam-storage-engine"><code>MyISAM</code>
</a> и <code>InnoDB</code> MySQL может создать пространственный индекс,
используя синтаксис, подобный этому для того, чтобы создать регулярный
индекс, но применяя ключевое слово <code>SPATIAL</code>. Столбцы в
пространственном индексе должны быть объявлены <code>NOT NULL</code>.
Следующие примеры демонстрируют, как создать пространственный индекс:</p>

<ul><li><p>С <a href="sql.htm#create-table"><code>CREATE TABLE</code></a>:
<pre>
CREATE TABLE geom (g GEOMETRY NOT NULL, SPATIAL INDEX(g)) ENGINE=MyISAM;
</pre></li>

<li>С <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>:
<pre>
ALTER TABLE geom ADD SPATIAL INDEX(g);
</pre></li>

<li>С <a href="sql.htm#create-index"><code>CREATE INDEX</code></a>:
<pre>
CREATE SPATIAL INDEX sp_index ON geom (g);
</pre></li></ul>

<p><code>SPATIAL INDEX</code> создает R-дерево. Для механизмов хранения,
которые поддерживают непространственную индексацию пространственных столбцов,
механизм создает B-дерево. B-дерево индекса на пространственных значениях
полезно для поисков точного значения, но не для просмотров диапазона.</p>

<p>Чтобы удалить пространственный индекс, надо использовать
<a href="sql.htm#alter-table"><code>ALTER TABLE</code></a> или
<a href="sql.htm#drop-index"><code>DROP INDEX</code></a>:</p>

<ul><li><p>С <a href="sql.htm#alter-table"><code>ALTER TABLE</code></a>:
<pre>
ALTER TABLE geom DROP INDEX g;
</pre></li>

<li>С <a href="sql.htm#drop-index"><code>DROP INDEX</code></a>:
<pre>
DROP INDEX sp_index ON geom;
</pre></li></ul>

<p>Пример: Предположите что таблица <code>geom</code> содержит больше 32000
конфигураций, которые сохранены в столбце
<code>g</code> типа <code>GEOMETRY</code>. Таблица также имеет
<code>AUTO_INCREMENT</code> столбец <code>fid</code> для того, чтобы
сохранить значения идентификаторов объекта.
<pre>
mysql&gt; DESCRIBE geom;
+-------+----------+------+-----+---------+----------------+
| Field | Type     | Null | Key | Default | Extra          |
+-------+----------+------+-----+---------+----------------+
| fid   | int(11)  |      | PRI | NULL    | auto_increment |
| g     | geometry |      |     |         |                |
+-------+----------+------+-----+---------+----------------+
2 rows in set (0.00 sec)

mysql&gt; SELECT COUNT(*) FROM geom;
+----------+
| count(*) |
+----------+
| 32376    |
+----------+
1 row in set (0.00 sec)
</pre>

<p>Чтобы добавить пространственный индекс на столбце <code>g</code>,
используйте этот запрос:
<pre>
mysql&gt; ALTER TABLE geom ADD SPATIAL INDEX(g) ENGINE=MyISAM;
Query OK, 32376 rows affected (4.05 sec)
Records: 32376 Duplicates: 0 Warnings: 0
</pre>

<h4><a name="using-spatial-indexes"></a>12.5.3.7.
Использование пространственного индекса</h4>
<p>Оптимизатор занимается расследованиями, может ли доступный
пространственный индекс быть вовлечен в поиск запросов, которые используют
такую функцию, как <a href="funct.htm#function_mbrcontains"><code>
MBRContains()</code></a> или <a href="funct.htm#function_mbrwithin"><code>
MBRWithin()</code></a> в предложении <code>WHERE</code>. Следующий запрос
находит все объекты, которые находятся в данном прямоугольнике:
<pre>
mysql&gt; SET @poly =
    -&gt; 'Polygon((30000 15000, 31000 15000, 31000 16000, 30000 16000,
                    30000 15000))';
mysql&gt; SELECT fid,ST_AsText(g) FROM geom WHERE
    -&gt;        MBRContains(ST_GeomFromText(@poly),g);
+-----+---------------------------------------------------------------+
| fid | ST_AsText(g)                                                  |
+-----+---------------------------------------------------------------+
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.00 sec)
</pre>

<p>Используйте <a href="sql.htm#explain"><code>EXPLAIN</code></a>, чтобы
проверить путь, которым этот запрос выполнен:
<pre>
mysql&gt; SET @poly =
    -&gt; 'Polygon((30000 15000, 31000 15000, 31000 16000,
                    30000 16000, 30000 15000))';
mysql&gt; EXPLAIN SELECT fid,ST_AsText(g) FROM geom WHERE
    -&gt;         MBRContains(ST_GeomFromText(@poly),g)\G
*************************** 1. row ***************************
 id: 1
select_type: SIMPLE
table: geom
 type: range
possible_keys: g
key: g
key_len: 32
ref: NULL
 rows: 50
Extra: Using where
1 row in set (0.00 sec)
</pre>

<p>Проверьте то, что произошло бы без пространственного индекса:
<pre>
mysql&gt; SET @poly =
    -&gt; 'Polygon((30000 15000, 31000 15000, 31000 16000,
                    30000 16000, 30000 15000))';
mysql&gt; EXPLAIN SELECT fid,ST_AsText(g) FROM g IGNORE INDEX (g) WHERE
    -&gt;         MBRContains(ST_GeomFromText(@poly),g)\G
*************************** 1. row ***************************
 id: 1
select_type: SIMPLE
table: geom
 type: ALL
possible_keys: NULL
key: NULL
key_len: NULL
ref: NULL
 rows: 32376
Extra: Using where
1 row in set (0.00 sec)
</pre>

<p>Выполнение <a href="sql.htm#select"><code>SELECT</code></a> без
пространственного индекса выдаст тот же самый результат, но время выполнения
повышается с 0.00 до 0.46 секунды:
<pre>
mysql&gt; SET @poly =
    -&gt; 'Polygon((30000 15000, 31000 15000, 31000 16000,
                    30000 16000, 30000 15000))';
mysql&gt; SELECT fid,ST_AsText(g) FROM geom IGNORE INDEX (g) WHERE
    -&gt;        MBRContains(ST_GeomFromText(@poly),g);
+-----+---------------------------------------------------------------+
| fid | ST_AsText(g)                                                  |
+-----+---------------------------------------------------------------+
|   1 | LINESTRING(30250.4 15129.2,30248.8 15138.4,30238.2 15136. ... |
|   2 | LINESTRING(30220.2 15122.8,30217.2 15137.8,30207.6 15136, ... |
|   3 | LINESTRING(30179 15114.4,30176.6 15129.4,30167 15128,3016 ... |
|   4 | LINESTRING(30155.2 15121.4,30140.4 15118.6,30142 15109,30 ... |
|   5 | LINESTRING(30192.4 15085,30177.6 15082.2,30179.2 15072.4, ... |
|   6 | LINESTRING(30244 15087,30229 15086.2,30229.4 15076.4,3024 ... |
|   7 | LINESTRING(30200.6 15059.4,30185.6 15058.6,30186 15048.8, ... |
|  10 | LINESTRING(30179.6 15017.8,30181 15002.8,30190.8 15003.6, ... |
|  11 | LINESTRING(30154.2 15000.4,30168.6 15004.8,30166 15014.2, ... |
|  13 | LINESTRING(30105 15065.8,30108.4 15050.8,30118 15053,3011 ... |
|  21 | LINESTRING(30350.4 15828.8,30350.6 15845,30333.8 15845,30 ... |
|  22 | LINESTRING(30350.6 15871.4,30350.6 15887.8,30334 15887.8, ... |
|  23 | LINESTRING(30350.6 15914.2,30350.6 15930.4,30334 15930.4, ... |
|  24 | LINESTRING(30290.2 15823,30290.2 15839.4,30273.4 15839.4, ... |
|  25 | LINESTRING(30291.4 15866.2,30291.6 15882.4,30274.8 15882. ... |
|  26 | LINESTRING(30291.6 15918.2,30291.6 15934.4,30275 15934.4, ... |
| 154 | LINESTRING(30276.2 15143.8,30261.4 15141,30263 15131.4,30 ... |
| 155 | LINESTRING(30269.8 15084,30269.4 15093.4,30258.6 15093,30 ... |
| 157 | LINESTRING(30128.2 15011,30113.2 15010.2,30113.6 15000.4, ... |
| 249 | LINESTRING(30337.8 15938.6,30337.8 15946.8,30320.4 15946. ... |
+-----+---------------------------------------------------------------+
20 rows in set (0.46 sec)
</pre>

<h2><a name="json"></a>12.6. Тип данных JSON</h2>
<p>MySQL поддерживает тип данных <code>JSON</code>, который включает
эффективный доступ к данным в документах JSON (JavaScript Object Notation).
Тип данных <code>JSON</code> обеспечивает эти преимущества перед хранением
строк JSON-формата в строковом столбце:</p>

<ul><li><p>Автоматическая проверка допустимости документов JSON в столбцах
<code>JSON</code>. Недопустимые документы производят ошибку.</li>
<li>Оптимизированный формат хранения. Документы JSON в столбцах
<code>JSON</code> преобразованы во внутренний формат, который разрешает
быстрый доступ для чтения к элементам документа. Когда сервер позже должен
считать значение JSON сохраненное в этом двоичном формате, значение не должно
быть разобрано из текстового представления. Двоичный формат структурирован,
чтобы позволить серверу искать подобъекты или вложенные значения
непосредственно ключом или индексом массива, не читая все значения прежде или
после них в документе.</p></li></ul>

<p>Размер документов JSON в столбцах <code>JSON</code> ограничен значением
переменной <a href="server.htm#sysvar_max_allowed_packet"><code>
max_allowed_packet</code></a>. В то время, как сервер управляет значением
JSON внутренне в памяти, это может быть больше: предел применяется, когда
сервер хранит его.</p>

<p>Столбцы <code>JSON</code> не могут иметь значения по умолчанию.</p>
<p>Столбцы <code>JSON</code>, как столбцы других двоичных типов, не
индексированы непосредственно: вместо этого, Вы можете создать индекс на
произведенном столбце, который извлекает скалярное значение
из <code>JSON</code>. См.
<a href="sql.htm#create-table-secondary-indexes-virtual-columns">раздел
14.1.15.6</a>.</p>

<p>Оптимизатор MySQL также ищет совместимый индекс на виртуальных
столбцах с выражением JSON.</p>
<p>Следующее обсуждение затрагивает эти темы:</p>
<ul><li><p><a href="#json-values">Создание значений JSON</a>.</li>
<li><a href="#json-normalization">Нормализация, слияние и
автообертывание значений JSON</a>.</li>

<li><a href="#json-paths">Поиск и модификация значений JSON</a>.
</li>
<li><a href="#json-comparison">Сравнение и упорядочивание JSON</a>.
</li>
<li><a href="#json-aggregation">Агрегирование значений JSON</a>.
</p></li></ul>

<p>Наряду с типом данных, ряд функций SQL доступен, чтобы включить операции
на значениях JSON таких, как создание, манипуляция и поиск. Последующее
обсуждение показывает примеры этих операций. Для деталей об отдельных
функциях см. <a href="funct.htm#json-functions">раздел 13.16</a>.</p>


<p>Ряд пространственных функций для того, чтобы воздействовать на значения
<code>GeoJSON</code> также доступен. См.
<a href="funct.htm#spatial-geojson-functions">раздел 13.15.11</a>.</p>

<h3><a name="json-values"></a>Создание значений JSON</h3>
<p>Массив JSON содержит список значений, отделенных запятыми и приложенный в
пределах символов <code>[</code> и <code>]</code>:
<pre>
["abc", 10, null, true, false]
</pre>

<p>Объект JSON содержит ряд пар ключа/значения, отделенных запятыми и
приложенный в пределах символов <code>{</code> и <code>}</code>:
<pre>
{"k1": "value", "k2": 10}
</pre>

<p>Массивы и объекты JSON могут содержать скалярные значения, которые
являются строками или числами, литералом JSON null или литералами JSON
boolean true или false. Ключи в объектах JSON должны быть строками. Временные
(date, time или datetime) скалярные значения также разрешены:
<pre>
["12:18:29.000000", "2015-07-29", "2015-07-29 12:18:29.000000"]
</pre>

<p>Вложение разрешено в пределах элементов массива и значений
ключа объекта JSON:
<pre>
[99, {"id": "HK500", "cost": 75.99}, ["hot", "cold"]]
{"k1": "value", "k2": [10, 20]}
</pre>

<p>Вы можете также получить значения JSON из многих функций, поставляемых
MySQL с этой целью (см. <a href="funct.htm#json-creation-functions">раздел
13.16.2</a>) так же, как конвертируя значения других типов в
<code>JSON</code>, используя <a href="funct.htm#function_cast"><code>
CAST(<em><code>value</code></em> AS JSON)</code></a>.</p>

<p>В MySQL значения JSON написаны как строки. MySQL разбирает любую строку,
используемую в контексте, который требует значения JSON, и производит ошибку,
если это не допустимо как JSON. Эти контексты включают вставку значения в
столбец, который имеет тип <code>JSON</code> и прохождение параметра в
функцию, которая ожидает значение JSON, как следующие примеры демонстрируют:
</p>

<ul><li><p>Попытка вставить значение в столбец <code>JSON</code>
преуспевает, если значение допустимое значение JSON, но терпит неудачу, если
это не так:
<pre>
mysql&gt; CREATE TABLE t1 (jdoc JSON);
Query OK, 0 rows affected (0.20 sec)

mysql&gt; INSERT INTO t1 VALUES('{"key1": "value1", "key2": "value2"}');
Query OK, 1 row affected (0.01 sec)

mysql&gt; INSERT INTO t1 VALUES('[1, 2,');
ERROR 3140 (22032) at line 2: Invalid JSON text: "Invalid value."
at position 6 in value (or column) '[1, 2,'.
</pre>

<p>Позиции для <span>at position <em><code>N</code></em></span>
в таких сообщениях об ошибках считаются с 0, но должны считаться грубыми
признаками того, где проблема в значении фактически происходит.</li>

<li>Функция <a href="funct.htm#function_json-type"><code>JSON_TYPE()</code>
</a> ожидает параметр JSON и попытается разобрать это в значение JSON.
Это возвращает значение типа JSON, если это допустимо и
производит ошибку иначе:
<pre>
mysql&gt; SELECT JSON_TYPE('["a", "b", 1]');
+----------------------------+
| JSON_TYPE('["a", "b", 1]') |
+----------------------------+
| ARRAY                      |
+----------------------------+

mysql&gt; SELECT JSON_TYPE('"hello"');
+----------------------+
| JSON_TYPE('"hello"') |
+----------------------+
| STRING               |
+----------------------+

mysql&gt; SELECT JSON_TYPE('hello');
ERROR 3146 (22032): Invalid data type for JSON data in argument 1
to function json_type; a JSON string or JSON type is required.
</pre></li></ul>

<p>MySQL обрабатывает строки, используемые в контексте JSON, используя
набор символов <code>utf8mb4</code> и сопоставление <code>utf8mb4_bin</code>.
Строки в других наборах символов преобразованы в <code>utf8mb4</code>
по мере необходимости. Для строк в наборах символов <code>ascii</code> или
<code>utf8</code> никакое преобразование не необходимо потому, что
<code>ascii</code> и <code>utf8</code> подмножества <code>utf8mb4</code>.</p>

<p>Как альтернатива написанию значений JSON, используя буквальные строки,
существуют функции для того, чтобы составить значения JSON из составляющих
элементов. <a href="funct.htm#function_json-array"><code>JSON_ARRAY()</code>
</a> берет (возможно пустой) список значений и возвращает массив JSON,
содержащий те значения:
<pre>
mysql&gt; SELECT JSON_ARRAY('a', 1, NOW());
+----------------------------------------+
| JSON_ARRAY('a', 1, NOW())|
+----------------------------------------+
| ["a", 1, "2015-07-27 09:43:47.000000"] |
+----------------------------------------+
</pre>

<p><a href="funct.htm#function_json-object"><code>JSON_OBJECT()</code></a>
берет (возможно пустой) список пар ключа/значения и возвращает объект JSON,
содержащий те пары:
<pre>
mysql&gt; SELECT JSON_OBJECT('key1', 1, 'key2', 'abc');
+---------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc') |
+---------------------------------------+
| {"key1": 1, "key2": "abc"}|
+---------------------------------------+
</pre>

<p><a href="funct.htm#function_json-merge"><code>JSON_MERGE()</code></a>
берет два или больше документа JSON и возвращает объединенный результат:
<pre>
mysql&gt; SELECT JSON_MERGE('["a", 1]', '{"key": "value"}');
+--------------------------------------------+
| JSON_MERGE('["a", 1]', '{"key": "value"}') |
+--------------------------------------------+
| ["a", 1, {"key": "value"}]                 |
+--------------------------------------------+
</pre>

<p>Значения JSON могут быть назначены на
определяемые пользователем переменные:
<pre>
mysql&gt; SET @j = JSON_OBJECT('key', 'value');
mysql&gt; SELECT @j;
+------------------+
| @j               |
+------------------+
| {"key": "value"} |
+------------------+
</pre>

<p>Однако, определяемые пользователем переменные не могут иметь тип
<code>JSON</code>, так хотя <code>@j</code> в предыдущем примере похоже на
значение JSON и имеет тот же самый набор символов и сопоставление как
значение JSON, это <span><em>НЕ</em></span> имеет тип данных
<code>JSON</code>. Вместо этого результат
<a href="funct.htm#function_json-object"><code>JSON_OBJECT()</code></a>
преобразован в строку, когда назначен переменной.</p>

<p>У строк, произведенных, преобразовывая значения JSON, есть набор символов
<code>utf8mb4</code> и сопоставление <code>utf8mb4_bin</code>:
<pre>
mysql&gt; SELECT CHARSET(@j), COLLATION(@j);
+-------------+---------------+
| CHARSET(@j) | COLLATION(@j) |
+-------------+---------------+
| utf8mb4     | utf8mb4_bin   |
+-------------+---------------+
</pre>

<p>Поскольку <code>utf8mb4_bin</code> двоичное сопоставление, сравнение
значений JSON является чувствительным к регистру.
<pre>
mysql&gt; SELECT JSON_ARRAY('x') = JSON_ARRAY('X');
+-----------------------------------+
| JSON_ARRAY('x') = JSON_ARRAY('X') |
+-----------------------------------+
| 0                                 |
+-----------------------------------+
</pre>

<p>Чувствительность к регистру также относится к литералам JSON
<code>null</code>, <code>true</code> и <code>false</code>,
которые всегда должны писаться в нижнем регистре:
<pre>
mysql&gt; SELECT JSON_VALID('null'), JSON_VALID('Null'), JSON_VALID('NULL');
+--------------------+--------------------+--------------------+
| JSON_VALID('null') | JSON_VALID('Null') | JSON_VALID('NULL') |
+--------------------+--------------------+--------------------+
| 1                  | 0                  | 0                  |
+--------------------+--------------------+--------------------+

mysql&gt; SELECT CAST('null' AS JSON);
+----------------------+
| CAST('null' AS JSON) |
+----------------------+
| null                 |
+----------------------+
1 row in set (0.00 sec)

mysql&gt; SELECT CAST('NULL' AS JSON);
ERROR 3141 (22032): Invalid JSON text in argument 1 to function
cast_as_json: "Invalid value." at position 0 in 'NULL'.
</pre>

<p>Чувствительность к регистру литералов JSON отличается от тех же самых
литералов из SQL <code>NULL</code>, <code>TRUE</code> и <code>FALSE</code>,
которые могут быть написаны в любом регистре:
<pre>
mysql&gt; SELECT ISNULL(null), ISNULL(Null), ISNULL(NULL);
+--------------+--------------+--------------+
| ISNULL(null) | ISNULL(Null) | ISNULL(NULL) |
+--------------+--------------+--------------+
| 1            | 1            | 1            |
+--------------+--------------+--------------+
</pre>

<h3><a name="json-normalization"></a>Нормализация, слияние и автообертывание
значений JSON</h3>
<p>Когда строка разобрана и является допустимым документом JSON,
она также нормализована: от участников с ключами, которые делают дубликат
ключа, найденный ранее в документе, отказываются (даже если значения
отличаются). Значение объекта произведено следующим вызовом
<a href="funct.htm#function_json-object"><code>JSON_OBJECT()</code></a> не
включает второй элемент <code>key1</code>, потому что это ключевое имя
есть ранее в значении:
<pre>
mysql&gt; SELECT JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def');
+------------------------------------------------------+
| JSON_OBJECT('key1', 1, 'key2', 'abc', 'key1', 'def') |
+------------------------------------------------------+
| {"key1": 1, "key2": "abc"}                           |
+------------------------------------------------------+
</pre>

<p>Нормализация, выполненная MySQL, также сортирует ключи объекта JSON
(с целью создания более эффективных поисков). Результат этого упорядочивания
подвержен изменениям и не гарантируется, что будет последовательным. Кроме
того, от дополнительных пробелов между ключами, значениями или элементами в
оригинале документа отказываются.</p>

<p>Функции MySQL, которые производят значения JSON (см.
<a href="funct.htm#json-creation-functions">раздел 13.16.2</a>)
всегда возвращают нормализованные значения.</p>

<p>В контекстах, которые комбинируют многократные массивы, массивы слиты в
единственный массив, добавляя массивы, названные позже, в конец первого
массива. В следующем примере
<a href="funct.htm#function_json-merge"><code>JSON_MERGE()</code></a>
сливает параметры в единственный массив:
<pre>
mysql&gt; SELECT JSON_MERGE('[1, 2]', '["a", "b"]', '[true, false]');
+-----------------------------------------------------+
| JSON_MERGE('[1, 2]', '["a", "b"]', '[true, false]') |
+-----------------------------------------------------+
| [1, 2, "a", "b", true, false]                       |
+-----------------------------------------------------+
</pre>

<p>Много объекты когда слиты производят единственный объект. Если у многих
объектов есть тот же самый ключ, значение для того ключа в получающемся
слитом объекте является массивом, содержащим значения ключа:
<pre>
mysql&gt; SELECT JSON_MERGE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}');
+----------------------------------------------------+
| JSON_MERGE('{"a": 1, "b": 2}', '{"c": 3, "a": 4}') |
+----------------------------------------------------+
| {"a": [1, 4], "b": 2, "c": 3}                      |
+----------------------------------------------------+
</pre>

<p>Значения не массива использовали в контексте, который требует, чтобы
значение массива было автообернуто: значение окружено символами
<code>[</code> и <code>]</code>, чтобы преобразовать его в массив. В
следующем заявлении каждый параметр автообернут как массив
(<code>[1]</code>, <code>[2]</code>). Они слиты, чтобы произвести
единственный массив результата:
<pre>
mysql&gt; SELECT JSON_MERGE('1', '2');
+----------------------+
| JSON_MERGE('1', '2') |
+----------------------+
| [1, 2]               |
+----------------------+
</pre>

<p>Значения массива и объекта слиты, автообертывая объект как массив и
сливая два массива:
<pre>
mysql&gt; SELECT JSON_MERGE('[10, 20]', '{"a": "x", "b": "y"}');
+------------------------------------------------+
| JSON_MERGE('[10, 20]', '{"a": "x", "b": "y"}') |
+------------------------------------------------+
| [10, 20, {"a": "x", "b": "y"}]                 |
+------------------------------------------------+
</pre>

<h3><a name="json-paths"></a>Поиск и модификация значений JSON</h3>
<p>Выражение пути JSON выбирает значение в пределах документа JSON.</p>
<p>Выражения пути полезны с функциями, которые извлекают части или
изменяют документ JSON, чтобы определить, где работать в пределах этого
документа. Например, следующий запрос извлекает из документа JSON
значение участника с ключом <code>name</code>:
<pre>
mysql&gt; SELECT JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name');
+---------------------------------------------------------+
| JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.name') |
+---------------------------------------------------------+
| "Aztalan"                                               |
+---------------------------------------------------------+
</pre>

<p>Синтаксис пути использует символ <code>$</code>, чтобы представить
документ JSON на рассмотрении, произвольно сопровождаемый селекторами,
которые указывают на последовательно более определенные части документа:</p>

<ul><li><p>Период, сопровождаемый ключевым именем, называет участника в
объекте с данным ключом. Ключевое имя должно быть определено в пределах
двойных кавычек, если имя без кавычек не является законным в пределах
выражений пути (например, если это содержит пробел).</li>

<li><code>[<em><code>N</code></em>]</code> добавленный к пути, который
выбирает массив, называет значение в позиции <em><code>N</code></em> в
пределах массива. Позиции массива целые числа, начинающиеся с ноля.</li>

<li>Пути могут содержать подстановочные знаки <code>*</code> или
<code>**</code>:</p>

<ul><li><p><code>.[*]</code> оценивается к значениям всех
участников в объекте JSON.</li>
<li><code>[*]</code> оценивается к значениям всех элементов в массиве JSON.
</li>

<li><code><em><code>prefix</code></em>**<em><code>suffix</code></em></code>
оценивается ко всем путям, которые начинаются с названной приставки и
заканчиваются названным суффиксом.</p></li></ul></li>
<li><p>Путь, который не существует в документе (ведет к несуществующим
данным) оценивает к <code>NULL</code>.</p></li></ul>

<p><code>$</code> ссылается на этот массив JSON с тремя элементами:
<pre>
[3, {"a": [5, 6], "b": 10}, [99, 100]]
</pre>

<p>Тогда:</p>
<ul><li><p><code>$[0]</code> <code>3</code>.</li>
<li><code>$[1]</code> <code>{"a": [5, 6], "b": 10}</code>.</li>
<li><code>$[2]</code> <code>[99,100]</code>.</li>
<li><code>$[3]</code> <code>NULL</code> (это обращается к четвертому элементу
массива, который не существует).</p></li></ul>

<p>Поскольку <code>$[1]</code> и <code>$[2]</code> оцениваются
к нескалярным значениям, они могут использоваться в качестве основания для
более определенных выражений пути, которые выбирают
вложенные значения. Примеры:</p>

<ul><li><p><code>$[1].a</code> <code>[5,6]</code>.</li>
<li><code>$[1].a[1]</code> <code>6</code>.</li>
<li><code>$[1].b</code> <code>10</code>.</li>
<li><code>$[2][0]</code> <code>99</code>.</p></li></ul>

<p>Как упомянуто ранее, компоненты пути, которые называют ключи, должны быть
заключены в кавычки, если ключевое имя не законное в выражениях пути.
Пусть <code>$</code> обращается к этому значению:
<pre>
{"a fish": "shark", "a bird": "sparrow"}
</pre>

<p>Ключи содержат пробел и должны быть заключены в кавычки:</p>
<ul><li><p><code>$."a fish"</code> <code>shark</code>.</li>
<li><code>$."a bird"</code> <code>sparrow</code>.</p></li></ul>

<p>Пути, которые используют подстановочные знаки, оцениваются к массиву,
который может содержать много значений:
<pre>
mysql&gt; SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.*') |
+---------------------------------------------------------+
| [1, 2, [3, 4, 5]]                                       |
+---------------------------------------------------------+

mysql&gt; SELECT JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]');
+------------------------------------------------------------+
| JSON_EXTRACT('{"a": 1, "b": 2, "c": [3, 4, 5]}', '$.c[*]') |
+------------------------------------------------------------+
| [3, 4, 5]                                                  |
+------------------------------------------------------------+
</pre>

<p>В следующем примере путь <code>$**.b</code>
оценивается к разнообразным путям (<code>$.a.b</code> и
<code>$.c.b</code>) и производит массив соответствующих значений пути:
<pre>
mysql&gt; SELECT JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b');
+---------------------------------------------------------+
| JSON_EXTRACT('{"a": {"b": 1}, "c": {"b": 2}}', '$**.b') |
+---------------------------------------------------------+
| [1, 2]                                                  |
+---------------------------------------------------------+
</pre>

<p>Вы можете использовать
<a href="funct.htm#operator_json-column-path"><code><em><code>column</code>
</em>-&gt;<em><code>path</code></em></code></a> с идентификатором столбца
и выражением пути JSON как синоним для
<a href="funct.htm#function_json-extract"><code>JSON_EXTRACT(<em><code>column
</code></em>, <em><code>path</code></em>)</code></a>. См. разделы
<a href="funct.htm#json-search-functions">13.16.3</a> и
<a href="sql.htm#create-table-secondary-indexes-virtual-columns">14.1.15.6
</a>.</p>

<p>Некоторые функции берут существующий документ JSON, изменяют это в
некотором роде и возвращают получающийся измененный документ. Выражения пути
указывают, где в документе произвести изменения. Например, функции
<a href="funct.htm#function_json-set"><code>JSON_SET()</code></a>,
<a href="funct.htm#function_json-insert"><code>JSON_INSERT()</code></a> и
<a href="funct.htm#function_json-replace"><code>JSON_REPLACE()</code></a>
берут документ JSON плюс одна или более пар пути/значения, которые описывают,
где изменить документ и какие значения использовать. Функции отличаются по
тому, как они обрабатывают существующие и несуществующие
значения в пределах документа.</p>

<p>Рассмотрите этот документ:
<pre>
mysql&gt; SET @j = '["a", {"b": [true, false]}, [10, 20]]';
</pre>

<p><a href="funct.htm#function_json-set"><code>JSON_SET()</code></a>
заменяет значения для путей, которые существуют и добавляет значения для
путей, которые не существуют:
<pre>
mysql&gt; SELECT JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+--------------------------------------------+
| JSON_SET(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+--------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20, 2]]      |
+--------------------------------------------+
</pre>

<p>В этом случае путь <code>$[1].b[0]</code> выбирает существующее значение
(<code>true</code>), которое заменено значением после параметра пути
(<code>1</code>). Путь <code>$[2][2]</code> не существует, таким образом,
соответствующее значение (<code>2</code>) добавлено к значению, выбранному
<code>$[2]</code>.</p>

<p><a href="funct.htm#function_json-insert"><code>JSON_INSERT()</code></a>
добавляет новые значения, но не заменяет существующие:
<pre>
mysql&gt; SELECT JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+-----------------------------------------------+
| JSON_INSERT(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+-----------------------------------------------+
| ["a", {"b": [true, false]}, [10, 20, 2]]      |
+-----------------------------------------------+
</pre>

<p><a href="funct.htm#function_json-replace"><code>JSON_REPLACE()</code></a>
заменяет существующие значения и игнорирует новые:
<pre>
mysql&gt; SELECT JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2);
+------------------------------------------------+
| JSON_REPLACE(@j, '$[1].b[0]', 1, '$[2][2]', 2) |
+------------------------------------------------+
| ["a", {"b": [1, false]}, [10, 20]]             |
+------------------------------------------------+
</pre>

<p>Пары пути/значения оценены слева направо. Документ, представленный,
оценивая одну пару, становится новым значением, против которого
оценена следующая пара.</p>

<p><code>JSON_REMOVE()</code> берет документ JSON и один или более путей,
которые определяют значения, которые будут удалены из документа. Возвращаемое
значение: оригинал документа минус значения, выбранные путями, которые
существуют в пределах документа:
<pre>
mysql&gt; SELECT JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]');
+---------------------------------------------------+
| JSON_REMOVE(@j, '$[2]', '$[1].b[1]', '$[1].b[1]') |
+---------------------------------------------------+
| ["a", {"b": [true]}]                              |
+---------------------------------------------------+
</pre>

<p>Пути имеют эти эффекты:</p>
<ul><li><p><code>$[2]</code> соответствует <code>[10, 20]</code>
и удаляет это.</li>

<li>Первый экземпляр <code>$[1].b[1]</code> соответствует
<code>false</code> в элементе <code>b</code> и удаляет это.</li>
<li>Второй экземпляр <code>$[1].b[1]</code> ничему не соответствует: этот
элемент был уже удален, путь больше не существует и не
имеет никакого эффекта.</p></li></ul>

<h3><a name="json-comparison"></a>Сравнение и упорядочивание значений JSON
</h3>
<p>Значения JSON могут быть сравнены, используя операторы
<a href="funct.htm#operator_equal"><code>=</code></a>,
<a href="funct.htm#operator_less-than"><code>&lt;</code></a>,
<a href="funct.htm#operator_less-than-or-equal"><code>&lt;=</code></a>,
<a href="funct.htm#operator_greater-than"><code>&gt;</code></a>,
<a href="funct.htm#operator_greater-than-or-equal"><code>&gt;=</code></a>,
<a href="funct.htm#operator_not-equal"><code>&lt;&gt;</code></a>,
<a href="funct.htm#operator_not-equal"><code>!=</code></a> и
<a href="funct.htm#operator_equal-to"><code>&lt;=&gt;</code></a>.</p>

<p>Следующие операторы сравнения и функции еще не поддержаны
со значениями JSON:</p>
<ul><li><p><a href="funct.htm#operator_between"><code>BETWEEN</code></a></li>
<li><a href="funct.htm#function_in"><code>IN()</code></a></li>
<li><a href="funct.htm#function_greatest"><code>GREATEST()</code></a></li>
<li><a href="funct.htm#function_least"><code>LEAST()</code></a></p></li></ul>

<p>Обход для операторов сравнения и функций: конвертировать значения JSON в
числа MySQL или представить тип данных в виде строки, таким образом, у них
есть последовательный не-JSON скалярный тип.</p>

<p>Сравнение значений JSON имеет место на двух уровнях. Первый уровень
сравнения основан на типах JSON сравненных значений. Если типы отличаются,
результат сравнения определен исключительно тем, у какого типа есть более
высокий приоритет. Если два значения имеют тот же самый тип JSON, второй
уровень сравнения происходит, используя определенные для типа правила.</p>

<p>Следующий список показывает приоритеты типов JSON от самого высокого
до самого низкого. Имена типов возвращены функцией
<a href="funct.htm#function_json-type"><code>JSON_TYPE()</code></a>.
У типов, показанных вместе на строке, есть тот же самый приоритет. Любое
значение, имеющее тип JSON ранее в списке, считается больше, чем значение
JSON позже в списке.
<pre>
BLOB
BIT
OPAQUE
DATETIME
TIME
DATE
BOOLEAN
ARRAY
OBJECT
STRING
INTEGER, DOUBLE
NULL
</pre>

<p>Для значений JSON того же самого приоритета правила сравнения
определены для типа:</p>
<ul><li><p><code>BLOB</code></p>
<p>Первые <em><code>N</code></em> байты двух значений сравнены, где
<em><code>N</code></em> число байтов в более коротком значении. Если первые
<em><code>N</code></em> байты двух значений идентичны, более короткое
значение упорядочено перед более длинным значением.</li>

<li><code>BIT</code></p>
<p>Аналогично <code>BLOB</code>.</li>
<li><code>OPAQUE</code></p>
<p>Аналогично <code>BLOB</code>. Значения <code>OPAQUE</code>
не классифицированы как один из других типов.</li>

<li><code>DATETIME</code></p>
<p>Значение, которое представляет более ранний момент времени, упорядочено
перед значением, которое представляет более поздний момент времени. Если два
значения первоначально прибывают из типов MySQL <code>DATETIME</code> и
<code>TIMESTAMP</code>, соответственно, они равны, если они представляют тот
же самый момент времени.</li>

<li><code>TIME</code></p>
<p>Меньшее из двух временных значений упорядочено перед большим.</li>
<li><code>DATE</code></p>
<p>Более ранняя дата упорядочена перед более свежей датой.</li>

<li><code>ARRAY</code></p>
<p>Два массива JSON равны, если у них есть та же самая длина, и значения в
соответствующих позициях в массивах равны.</p>

<p>Если массивы не равны, их порядок определен элементами в первой позиции,
где есть различие. Массив с меньшим значением в этой позиции сортируется
первым. Если все значения в более коротком массиве равны соответствующим
значениям в более длинном массиве, более короткий массив сортируется первым.
</p>

<p>Пример:
<pre>
[] &lt; ["a"] &lt; ["ab"] &lt; ["ab", "cd", "ef"] &lt; ["ab", "ef"]
</pre></li>

<li><p><code>BOOLEAN</code></p>
<p>JSON-литерал false меньше true.</li>
<li><code>OBJECT</code></p>
<p>Два объекта JSON равны, если у них есть тот же самый набор ключей, и у
каждого ключа есть то же самое значение в обоих объектах.</p>

<p>Пример:
<pre>
{"a": 1, "b": 2} = {"b": 2, "a": 1}
</pre>
<p>Порядок двух объектов, которые не равны, является
неуказанным, но детерминированным.</li>

<li><code>STRING</code></p>
<p>Строки упорядочены лексически на первых <em><code>N</code></em> байтах
представления <code>utf8mb4</code> двух сравниваемых строк, где
<em><code>N</code></em> длина более короткой строки. Если первые
<em><code>N</code></em> байт двух строк идентичны, более короткую строку
считают меньшей чем более длинная строка.</p>

<p>Пример:
<pre>
"a" &lt; "ab" &lt; "b" &lt; "bc"
</pre>

<p>Это упорядочивание эквивалентно упорядочиванию строк SQL с сопоставлением
<code>utf8mb4_bin</code>. Поскольку <code>utf8mb4_bin</code> двоичное
сопоставление, сравнение значений JSON является чувствительным к регистру:
<pre>
"A" &lt; "a"
</pre></li>

<li><p><code>INTEGER</code>, <code>DOUBLE</code></p>
<p>Значения JSON могут содержать числа точного значения и числа
приблизительной точности. Для общего обсуждения этих типов чисел см.
<a href="lang.htm#number-literals">раздел 10.1.2</a>.</p>

<p>Правила для того, чтобы сравнить числовые типы MySQL обсуждены в
<a href="funct.htm#type-conversion">разделе 13.2</a>, но правила для того,
чтобы сравнить числа в пределах значений JSON несколько отличаются:</p>

<ul><li><p>В сравнении между двумя столбцами, которые используют
MySQL <a href="#integer-types"><code>INT</code></a> и
<a href="#floating-point-types"><code>DOUBLE</code></a>,
соответственно, известно, что все сравнения вовлекают целое число и двойное,
таким образом, целое число преобразовано в двойное для всех строк. Таким
образом, числа точного значения преобразованы в
числа приблизительной точности.</li>

<li>С другой стороны, если запрос сравнивает два столбца JSON, содержащие
числа, неизвестно заранее, будут ли числа integer или double. Чтобы
обеспечить самое последовательное поведение через все строки, MySQL
преобразовывает числа приблизительной точности в числа точного значения.
Получающееся упорядочивание последовательно и не теряет точность для чисел
точного значения. Например, учитывая скаляры 9223372036854775805,
9223372036854775806, 9223372036854775807 и 9.223372036854776e18,
порядок таков как этот:
<pre>
9223372036854775805 &lt; 9223372036854775806 &lt; 9223372036854775807
&lt; 9.223372036854776e18 = 9223372036854776000 &lt; 9223372036854776001
</pre></li></ul>

<p>Если сравнения JSON используют числовые правила сравнения не-JSON,
непоследовательное упорядочивание могло произойти. Обычные правила сравнения
MySQL для чисел приводят к этим упорядочиваниям:</p>

<ul><li><p>Сравнения Integer:
<pre>
9223372036854775805 &lt; 9223372036854775806 &lt; 9223372036854775807
</pre>
<p>(не определено для 9.223372036854776e18).</li>

<li>Сравнения Double:
<pre>
9223372036854775805 = 9223372036854775806 = 9223372036854775807 = 9.223372036854776e18
</pre></li></ul></li></ul>

<p>Для сравнения любого JSON с SQL
<code>NULL</code> результат <code>UNKNOWN</code>.</p>
<p>Для сравнения любых JSON и не-JSON значений, не-JSON преобразовано в JSON
согласно правилам в следующей таблице, тогда значения сравнены
как описано ранее.</p>

<p><a name="json-converting-between-types"></a><b>Преобразование между
значениями JSON и не-JSON. </b>Следующая таблица обеспечивает резюме правил,
которым MySQL следует, сравнивая значения JSON и других типов:</p>

<a name="json-conversion-rules"></a>
<p><b>Таблица 12.1. Правила конвертации JSON</b></p>
<table><thead><tr><td align="center">другой тип</td>
<td align="center">CAST(другой тип AS JSON)</td>
<td align="center">CAST(JSON AS другой тип)</td></tr></thead>
<tbody><tr><td>JSON</td><td>Без изменений</td><td>Без изменений</td></tr>
<tr><td>Тип символа utf8 (<code>utf8mb4</code>,
<code>utf8</code>, <code>ascii</code>).</td>
<td>Строка разобрана в значение JSON.</td>
<td>Значение JSON преобразовано в последовательную форму в строку
<code>utf8mb4</code>.</td></tr>
<tr><td>Другие символьные типы</td>
<td>Другие кодировки символов неявно преобразованы в <code>utf8mb4</code> и
и обработаны как описано для utf8.</td>
<td>Значение JSON преобразовано в последовательную форму в строку
<code>utf8mb4</code>, затем приводится к другой кодировке символов.
Результат, возможно, не является значащим.</td></tr>
<tr><td><code>NULL</code></td>
<td>Результаты в значении <code>NULL</code> типа JSON.</td>
<td>Неприменим.</td></tr>
<tr><td>Типы геометрии.</td>
<td>Значение геометрии преобразовано в документ JSON вызовом
<a href="funct.htm#function_st-asgeojson"><code>ST_AsGeoJSON()</code></a>.
</td>
<td>Недопустимо. Обходное решение: передайте результат
<a href="funct.htm#function_cast"><code>CAST(<em><code>json_val</code></em>
AS CHAR)</code></a> в
<a href="funct.htm#function_st-geomfromgeojson"><code>ST_GeomFromGeoJSON()
</code></a>.</td></tr>
<tr><td>Все другие типы</td>
<td>Результаты в документе JSON, состоящем из
единственного скалярного значения.</td>
<td>Преуспевает, если документ JSON состоит из единственного скалярного
значения целевого типа и скалярное значение может быть конвертировано к
целевому типу. Иначе возвращает <code>NULL</code> и производит предупреждение.
</td></tr></tbody></table>

<p><code>ORDER BY</code> и <code>GROUP BY</code> для JSON
работают согласно этим принципам:</p>
<ul><li><p>Упорядочивание скаляра значения JSON использует те же самые
правила, как в предыдущем обсуждении.</li>

<li>Для сортировок по возрастанию SQL <code>NULL</code> будет перед всеми
значениями JSON, включая буквальный нуль JSON.
Для сортировок по убыванию наоборот.</li>

<li>Ключи сортировки для значений JSON ограничены значением переменной
<a href="server.htm#sysvar_max_sort_length"><code>max_sort_length</code></a>,
таким образом, ключи, которые отличаются только после первых
<a href="server.htm#sysvar_max_sort_length"><code>max_sort_length</code></a>
байт сравниваются как равные.</li>
<li>Сортировка нескалярных значений в настоящее время не
поддерживается, и предупреждение происходит.</p></li></ul>

<p>Для того, чтобы сортировать, может быть выгодно, преобразовать скаляр JSON
к некоторому другому типу MySQL. Например, если столбец <code>jdoc</code>
содержит объекты JSON, имеющие участника, состоящего из ключа <code>id</code>
и неотрицательного значения, используйте это выражение для сортировки
по значениям <code>id</code>:
<pre>
ORDER BY CAST(JSON_EXTRACT(jdoc, '$.id') AS UNSIGNED)
</pre>

<p>Если есть произведенный столбец, определенный, чтобы использовать то же
самое выражение в <code>ORDER BY</code>, оптимизатор MySQL признает это и
рассматривает использование индексирования для плана выполнения запроса. См.
<a href="optimiz.htm#generated-column-index-optimizations">раздел 9.3.9</a>.
</p>

<h3><a name="json-aggregation"></a>Агрегирование значений JSON</h3>
<p>Для агрегирования значений JSON SQL <code>NULL</code>
проигнорированы, как для других типов данных. Не-<code>NULL</code>
преобразованы в числовой тип и соединены, за исключением
<a href="funct.htm#function_min"><code>MIN()</code></a>,
<a href="funct.htm#function_max"><code>MAX()</code></a> и
<a href="funct.htm#function_group-concat"><code>GROUP_CONCAT()</code></a>.
Преобразование в число должно привести к значащему результату для значений
JSON, которые являются числовыми скалярами, хотя (в зависимости от значений)
усечение и потеря точности могут произойти. Преобразование в число других
значений JSON, возможно, не приводит к значащему результату.</p>

<h2><a name="data-type-defaults"></a>12.7. Значения по умолчанию</h2>
<p>Предложение <code>DEFAULT <em><code>value</code></em></code>
в спецификации типа данных указывает на значение по умолчанию для столбца. С
одним исключением: значение по умолчанию должно быть константой, это не может
быть функция или выражение. Это означает, например, что Вы не можете
установить значение по умолчанию для столбца даты в значение такой функции,
как <a href="funct.htm#function_now"><code>NOW()</code></a> или
<a href="funct.htm#function_current-date"><code>CURRENT_DATE</code></a>.
Исключение: Вы можете определить
<a href="funct.htm#function_current-timestamp"><code>CURRENT_TIMESTAMP</code>
</a> как значение по умолчанию для столбцов
<a href="#datetime"><code>TIMESTAMP</code></a> и
<a href="#datetime"><code>DATETIME</code></a>. См.
<a href="#timestamp-initialization">раздел 12.3.5</a>.</p>

<p>Столбцам <a href="#blob"><code>BLOB</code></a>,
<a href="#blob"><code>TEXT</code></a>, <code>GEOMETRY</code> и
<a href="#json"><code>JSON</code></a>
нельзя назначить значение по умолчанию.</p>

<p>Если определение столбца включает неявное значение
<code>DEFAULT</code>, MySQL определяет значение по
умолчанию следующим образом:</p>

<p>Если столбец может взять <code>NULL</code> как значение, столбец
определен с явным <code>DEFAULT NULL</code>.</p>
<p>Если столбец не может взять <code>NULL</code> как значение, MySQL
определяет столбец без явного <code>DEFAULT</code>.
Исключение: Если столбец определен как часть <code>PRIMARY KEY</code>,
но не явно как <code>NOT NULL</code>, MySQL создает это как
<code>NOT NULL</code> (потому что <code>PRIMARY KEY</code> должны
быть <code>NOT NULL</code>).</p>

<p>Для ввода данных в столбец <code>NOT NULL</code>, который имеет неявное
предложение <code>DEFAULT</code>, если запрос
<a href="sql.htm#insert"><code>INSERT</code></a> или
<a href="sql.htm#replace"><code>REPLACE</code></a> не включает значения для
столбца, или <a href="sql.htm#update"><code>UPDATE</code></a> устанавливает
столбец в <code>NULL</code>, MySQL обрабатывает столбец согласно режиму
SQL в это время:</p>

<ul><li><p>Если строгий режим SQL включен, ошибка происходит для
транзакционных таблиц, и запрос откатывается до прежнего уровня. Для
нетранзакционных таблиц ошибка происходит, но если это происходит для второй
или последующей строки запроса с многими строками, предыдущие
строки будут вставлены.</li>

<li>Если строгий режим не включен, MySQL устанавливает столбец в неявное
значение по умолчанию для типа данных столбца.</p></li></ul>
<p>Предположите что таблица <code>t</code> определена следующим образом:
<pre>
CREATE TABLE t (i INT NOT NULL);
</pre>

<p>В этом случае <code>i</code> не имеет никакого явного значения по
умолчанию, таким образом, в строгом режиме каждый из следующих запросов
производит ошибку, и никакая строка не вставлена. Если не используется
строгий режим, только третий запрос производит ошибку: неявное значение по
умолчанию вставлено для первых двух запросов, но третий терпит неудачу,
потому что <a href="funct.htm#function_default"><code>DEFAULT(i)</code></a>
не может произвести значение:
<pre>
INSERT INTO t VALUES();
INSERT INTO t VALUES(DEFAULT);
INSERT INTO t VALUES(DEFAULT(i));
</pre>

<p>Для данной таблицы Вы можете использовать
<a href="sql.htm#show-create-table"><code>SHOW CREATE TABLE</code></a>, чтобы
видеть, у каких столбцов есть явное предложение <code>DEFAULT</code>.</p>

<p>Неявные значения по умолчанию определены следующим образом:</p>
<ul><li><p>Для числовых типов значение по умолчанию <code>0</code>, за
исключением того, что для целого числа или типов с плавающей запятой,
объявленных с атрибутом <code>AUTO_INCREMENT</code>, значение по умолчанию
это следующее значение в последовательности.</li>

<li>Для типов даты и времени, но не для
<a href="#datetime"><code>TIMESTAMP</code></a>,
значение по умолчанию соответствующее <span>нулевое</span> значение для типа.
Это также истина для <a href="#datetime"><code>TIMESTAMP</code></a>,
если системная переменная
<a href="server.htm#sysvar_explicit_defaults_for_timestamp"><code>
explicit_defaults_for_timestamp</code></a> включена (см.
<a href="server.htm#server-system-variables">раздел 6.1.5</a>).
Иначе для первого столбца <a href="#datetime"><code>TIMESTAMP</code>
</a> значение по умолчанию это текущая дата и время. См.
<a href="#date-and-time-types">раздел 12.3</a>.</li>

<li>Для строковых типов, кроме
<a href="#enum"><code>ENUM</code></a>,
значение по умолчанию пустая строка. Для
<a href="#enum"><code>ENUM</code></a>
значение по умолчанию первое значение перечисления.</p></li></ul>
<p><code>SERIAL DEFAULT VALUE</code> в определении столбца целого числа
это псевдоним для <code>NOT NULL AUTO_INCREMENT UNIQUE</code>.</p>

<h2><a name="storage-requirements"></a>12.8. Требования хранения типов данных
</h2>
<p>Требования хранения для табличных данных зависят от нескольких факторов.
Различные механизмы хранения представляют типы данных и хранят необработанные
данные по-другому. Табличные данные могли бы быть сжаты для столбца или для
всей строки, усложняя вычисление требований хранения для таблицы или столбца.
</p>

<p>Несмотря на различия в расположении хранения на диске, внутренние MySQL
API, которые сообщают и обмениваются информацией о строках таблицы,
используют последовательную структуру данных, которая применяется
всеми механизмами хранения.</p>

<p>Этот раздел включает информацию для требований хранения для каждого типа
данных, поддержанного MySQL, включая внутренний формат и размер для
механизмов хранения, которые используют представление фиксированного размера
для типов данных. Информация перечислена по категориям
или механизмам хранения.</p>

<p>У внутреннего представления таблицы есть максимальный размер строки в
65535 байтов, даже если механизм хранения способен к поддержке более крупных
строк. Это число исключает столбцы
<a href="#blob"><code>BLOB</code></a> или
<a href="#blob"><code>TEXT</code></a>, которые вносят только 9-12
байт к этому размеру. Для <a href="#blob"><code>BLOB</code></a> и
<a href="#blob"><code>TEXT</code></a>
информация хранится внутренне в иной области памяти, чем буфер строки.
Различные механизмы хранения обрабатывают распределение и хранение этих
данных по-разному, согласно методу, который они используют для того, чтобы
обработать соответствующие типы. Для получения дополнительной информации см.
<a href="storage.htm">главу 17</a> и
<a href="restr.htm#column-count-limit">раздел C.10.4</a>.</p>

<h3><a name="idm139965358951872"></a>Требования хранения для таблиц InnoDB
</h3>
<p>См. <a href="innodb.htm#innodb-physical-record">раздел 16.8.2</a>
для информации о требованиях хранения для таблиц <code>InnoDB</code>.</p>

<h3><a name="idm139965358947824"></a>Требования хранения для числовых типов
</h3>
<table border="1">
<thead><tr><th scope="col">Тип</th>
<th scope="col">Сколько надо места</th></tr></thead>
<tbody><tr><td scope="row"><a href="#integer-types"><code>TINYINT
</code></a></td><td>1 байт</td></tr>
<tr><td scope="row"><a href="#integer-types"><code>SMALLINT</code>
</a></td><td>2 байта</td></tr>
<tr><td scope="row"><a href="#integer-types"><code>MEDIUMINT</code>
</a></td><td>3 байта</td></tr>
<tr><td scope="row"><a href="#integer-types"><code>INT</code></a>,
<a href="#integer-types"><code>INTEGER</code></a></td><td>4 байта
</td></tr>
<tr><td scope="row"><a href="#integer-types"><code>BIGINT</code>
</a></td><td>8 байт</td></tr>
<tr><td scope="row"><code>FLOAT(<em><code>p</code></em>)</code></td>
<td>4 байта, если 0 &lt;= <em><code>p</code></em> &lt;= 24, 8 байт, если 25
&lt;= <em><code>p</code></em> &lt;= 53</td></tr>
<tr><td scope="row"><a href="#floating-point-types"><code>FLOAT
</code></a></td><td>4 байт</td></tr>
<tr><td scope="row"><code>DOUBLE [PRECISION]</code>,
<a href="#floating-point-types"><code>REAL</code></a></td>
<td>8 байт</td></tr>
<tr><td scope="row"><code>DECIMAL(<em><code>M</code></em>,<em><code>D</code>
</em>)</code>, <code>NUMERIC(<em><code>M</code></em>,<em><code>D</code></em>)
</code></td><td>Переменно (см. ниже)</td></tr>
<tr><td scope="row"><code>BIT(<em><code>M</code></em>)</code></td>
<td>примерно (<em><code>M</code></em>+7)/8 байт</td>
</tr></tbody></table>

<p>Значения для столбцов <a href="#fixed-point-types"><code>DECIMAL
</code></a> (и <a href="#fixed-point-types"><code>NUMERIC</code>
</a>) представлены, используя двоичный формат, который упаковывает 9
десятичных цифр в четыре байта. Хранение для целого числа и дробных частей
каждого значения определено отдельно. Каждые 9 цифр требуют четырех байтов, и
<span>крайние слева</span> цифры требуют какой-то части четырех байтов.
Хранение, требуемое для этих лишних цифр, дано следующей таблицей.</p>

<table border="1">
<thead><tr><th scope="col">Крайние слева цифры</th>
<th scope="col">Число байт</th></tr></thead>
<tbody><tr><td scope="row">0</td><td>0</td></tr>
<tr><td scope="row">1</td><td>1</td></tr>
<tr><td scope="row">2</td><td>1</td></tr>
<tr><td scope="row">3</td><td>2</td></tr>
<tr><td scope="row">4</td><td>2</td></tr>
<tr><td scope="row">5</td><td>3</td></tr>
<tr><td scope="row">6</td><td>3</td></tr>
<tr><td scope="row">7</td><td>4</td></tr>
<tr><td scope="row">8</td><td>4</td></tr></tbody></table>

<h3><a name="data-types-storage-reqs-date-time"></a>
Требования хранения для типов даты и времени</h3>
<p>Для столбцов <a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a> место, требуемое для
таблиц, составленных до MySQL 5.6.4, отличается от таблиц, составленных в
5.6.4 и выше. Это происходит из-за изменения в 5.6.4, который разрешает этим
типам иметь дробную часть, которая требует от 0 до 3 байтов.</p>

<table border="1">
<thead><tr><th scope="col">Тип данных</th>
<th scope="col">Сколько надо места до MySQL 5.6.4</th>
<th scope="col">Сколько надо места в MySQL 5.6.4 и выше</th></tr></thead>
<tbody><tr><td scope="row"><a href="#year"><code>YEAR</code></a>
</td><td>1 byte</td><td>1 байт</td></tr>
<tr><td scope="row"><a href="#datetime"><code>DATE</code></a></td>
<td>3 bytes</td><td>3 байта</td></tr>
<tr><td scope="row"><a href="#time"><code>TIME</code></a></td>
<td>3 bytes</td><td>3 байта + дробное хранение секунд</td></tr>
<tr><td scope="row"><a href="#datetime"><code>DATETIME</code></a>
</td><td>8 bytes</td><td>5 байт + дробное хранение секунд</td></tr>
<tr><td scope="row"><a href="#datetime"><code>TIMESTAMP</code></a>
</td><td>4 bytes</td><td>4 байта + дробное хранение секунд</td>
</tr></tbody></table>

<p>С MySQL 5.6.4 место для <a href="#year"><code>YEAR</code></a>
и <a href="#datetime"><code>DATE</code></a> остается неизменным.
Однако, <a href="#time"><code>TIME</code></a>,
<a href="#datetime"><code>DATETIME</code></a> и
<a href="#datetime"><code>TIMESTAMP</code></a> представлены
по-другому. <a href="#datetime"><code>DATETIME</code></a>
упакован более эффективно, требуя 5 а не 8 байтов для целой части, и у всех
трех частей есть дробная часть, которая требует от 0 до 3 байтов, в
зависимости от точности дробной части секунд сохраненных значений.</p>

<table border="1">
<thead><tr><th scope="col">Точности дробной части секунд</th>
<th scope="col">Сколько надо места</th></tr></thead>
<tbody><tr><td scope="row">0</td><td>Не надо</td></tr>
<tr><td scope="row">1, 2</td><td>1 байт</td></tr>
<tr><td scope="row">3, 4</td><td>2 байта</td></tr>
<tr><td scope="row">5, 6</td><td>3 байта</td></tr></tbody></table>

<p>Например, <a href="#time"><code>TIME(0)</code></a>,
<a href="#time"><code>TIME(2)</code></a>,
<a href="#time"><code>TIME(4)</code></a> и
<a href="#time"><code>TIME(6)</code></a>
используют 3, 4, 5 и 6 байтов, соответственно.
<a href="#time"><code>TIME</code></a> и
<a href="#time"><code>TIME(0)</code></a>
эквивалентны и требуют того же самого места.</p>

<p>Для деталей о внутреннем представлении временных значений см.
<a href="../../../dev.mysql.com/doc/internals/en/algorithms.html"
target="_top">MySQL Internals: Important Algorithms and Structures</a>.</p>

<h3><a name="idm139965358838544"></a>Требования хранения для строковых типов
</h3>
<p>В следующей таблице <em><code>M</code></em> представляет заявленную длину
столбца в символах для недвоичных строковых типов и в байтах для двоичных
строковых типов. <em><code>L</code></em> представляет фактическую длину в
байтах данного строкового значения.</p>

<table border="1">
<thead><tr><th scope="col">Тип данных</th><th scope="col">Сколько надо места
</th></tr></thead>
<tbody><tr><td scope="row"><code>CHAR(<em><code>M</code></em>)</code></td>
<td><em><code>M</code></em>/<em><code>w</code></em> байт,
0 <code>&lt;= <em><code>M</code></em> &lt;=</code> 255, где
<em><code>w</code></em> число байтов, требуемых для символа максимальной
длины в наборе символов. См.
<a href="innodb.htm#innodb-physical-record">раздел 16.8.2</a> для информации
о требованиях хранения типа данных <code>CHAR</code> в таблицах <code>InnoDB
</code>.</td></tr>
<tr><td scope="row"><code>BINARY(<em><code>M</code></em>)</code></td>
<td><em><code>M</code></em> байт, 0 <code>&lt;=<em><code>M</code></em>
&lt;=</code> 255</td></tr>

<tr><td scope="row"><code>VARCHAR(<em><code>M</code></em>)</code>,
<code>VARBINARY(<em><code>M</code></em>)</code></td>
<td><em><code>L</code></em> + 1 байт, если значения столбцов требуют
0-255 байт, <em><code>L</code></em> + 2 байта, если значения могут
потребовать больше 255 байтов</td></tr>

<tr><td scope="row"><a href="#blob"><code>TINYBLOB</code></a>,
<a href="#blob"><code>TINYTEXT</code></a></td><td><em><code>L</code>
</em> + 1 байт, где <em><code>L</code></em> &lt; 2<sup>8</sup></td></tr>

<tr><td scope="row"><a href="#blob"><code>BLOB</code></a>,
<a href="#blob"><code>TEXT</code></a></td><td><em><code>L</code>
</em> + 2 байта, где <em><code>L</code></em> &lt; 2<sup>16</sup></td></tr>

<tr><td scope="row"><a href="#blob"><code>MEDIUMBLOB</code></a>,
<a href="#blob"><code>MEDIUMTEXT</code></a></td>
<td><em><code>L</code></em> + 3 байта, где
<em><code>L</code></em> &lt; 2<sup>24</sup></td></tr>

<tr><td scope="row"><a href="#blob"><code>LONGBLOB</code></a>,
<a href="#blob"><code>LONGTEXT</code></a></td>
<td><em><code>L</code></em> + 4 байта, где
<em><code>L</code></em> &lt; 2<sup>32</sup></td></tr>

<tr><td scope="row"><code>ENUM('<em><code>value1</code></em>',
'<em><code>value2</code></em>',...)</code></td>
<td>1 или 2 байта, в зависимости от числа значений перечисления
(максимум значений 65535 штук)</td></tr>

<tr><td scope="row"><code>SET('<em><code>value1</code></em>',
'<em><code>value2</code></em>',...)</code></td>
<td>1, 2, 3, 4 или 8 байт, в зависимости от числа
участников набора (максимум 64)</td></tr></tbody></table>

<p>Строковые типы переменной длины сохранены, используя приставку длины плюс
данные. Приставка длины требует от одного до четырех байтов в зависимости от
типа данных, и значение приставки <em><code>L</code></em>
(байт длины строки). Например, хранение для
<a href="#blob"><code>MEDIUMTEXT</code></a> требует
<em><code>L</code></em> байт, чтобы сохранить значение плюс три байта, чтобы
сохранить длину значения.</p>

<p>Вычисляя число байтов для хранения значения столбца
<a href="#char"><code>CHAR</code></a>,
<a href="#char"><code>VARCHAR</code></a> или
<a href="#blob"><code>TEXT</code></a>, Вы должны принять во внимание
набор символов, используемый для этого столбца и содержит ли значение
мультибайтные символы. В частности, используя набор символов Unicode
<code>utf8</code>, Вы должны иметь в виду, что не все символы используют то
же самое число байтов. Наборы символов <code>utf8mb3</code> и <code>utf8mb4
</code> могут потребовать до трех и четырех байтов на символ, соответственно.
См. подробности в <a href="global.htm#charset-unicode">разделе 11.1.9</a>.</p>

<p>Типы <a href="#char"><code>VARCHAR</code></a>,
<a href="#binary-varbinary"><code>VARBINARY</code></a>,
<a href="#blob"><code>BLOB</code></a> и
<a href="#blob"><code>TEXT</code></a> это типы переменной длины. Для
каждого из них требования хранения зависят от этих факторов:</p>

<ul><li><p>Фактическая длина значения столбца.</li>
<li>Максимальная возможная длина столбца.</li>
<li>Набор символов столбца, потому что некоторые наборы символов
содержат мультибайтные символы.</p></li></ul>

<p>Например, столбец <code>VARCHAR(255)</code> может содержать строку
максимальной длиной 255 символов. Предположим, что столбец использует
набор символов <code>latin1</code> (один байт на символ), тогда фактически
требуемое место является длиной строки (<em><code>L</code></em>)
плюс один байт, чтобы сделать запись длины строки. Для строки <code>'abcd'
</code> <em><code>L</code></em> 4 и требуемое место составляет пять байтов.
Если тот же самый столбец вместо этого использует двухбайтный набор символов
<code>ucs2</code>, требование хранения составляет 10 байтов: длина
<code>'abcd'</code> восемь байтов, и столбец требует, чтобы два байта
сохранили длину, потому что максимальная длина больше 255 (до 510 байтов).
</p>

<p><code>InnoDB</code> рассматривает <a href="#char"><code>CHAR
</code></a> как тип переменной длины, если таблица составлена, используя
формат строки <code>COMPACT</code>, <code>DYNAMIC</code> или
<code>COMPRESSED</code>, значение столбца
<a href="#char"><code>CHAR</code></a> больше
или равна 768 байтам, что может произойти, если максимальная длина символа
набора больше 3 байт, как с <code>utf8mb4</code>, например.</p>

<p>Эффективное максимальное количество <span><em>байтов</em></span>,
которые могут быть сохранены в столбце
<a href="#char"><code>VARCHAR</code></a> или
<a href="#binary-varbinary"><code>VARBINARY</code></a>
ограничено максимальным размером строки в 65535 байтов, которые совместно
использованы всеми столбцами. Для <a href="#char"><code>VARCHAR
</code></a>, который хранит мультибайтные символы, эффективное максимальное
количество <span><em>символов</em></span> меньше. Например, символы
<code>utf8mb4</code> могут потребовать до четырех байтов на символ, таким
образом, столбец <a href="#char"><code>VARCHAR</code></a>, который
использует набор символов <code>utf8mb4</code> может хранить максимум 16383
символа. См. <a href="restr.htm#column-count-limit">раздел C.10.4</a>.</p>

<p>Размер объекта <a href="#enum"><code>ENUM</code></a>
определен числом различных значений перечисления. Один байт используется
для перечислений с 255 возможными значениями. Два байта используются для
наличия перечислений между 256 и 65535 возможными значениями. См.
<a href="#enum">раздел 12.4.4</a>.</p>

<p>Размер объекта <a href="#set"><code>SET</code></a>
определен числом различных участников набора. Если размер набора
<em><code>N</code></em>, объект занимает
<code>(<em><code>N</code></em>+7)/8</code> байт, округленныфе вверх до
1, 2, 3, 4 или 8 байт. <a href="#set"><code>SET</code></a> может
иметь максимум 64 участника. См. <a href="#set">раздел 12.4.5</a>.
</p>

<h2><a name="choosing-types"></a>12.9. Выбор правильного типа для столбца
</h2>
<p>Для оптимального хранения Вы должны попытаться использовать самый точный
тип во всех случаях. Например, если столбец целого числа используется для
значений в диапазоне от <code>1</code> до
<code>99999</code>, <code>MEDIUMINT UNSIGNED</code> лучший тип.
Из типов, которые представляют все необходимые значения, этот тип использует
наименьшее количество памяти.</p>

<p>Все основные вычисления (<code>+</code>, <code>-</code>, <code>*</code> и
<code>/</code>) со столбцами <a href="#fixed-point-types"><code>
DECIMAL</code></a> сделаны с точностью 65 десятичных цифр. См.
<a href="#numeric-type-overview">раздел 12.1.1</a>.</p>

<p>Если точность не слишком важна или если скорость самый высокий приоритет,
тип <a href="#floating-point-types"><code>DOUBLE</code></a>
тип может быть достаточно хорошим. Для высокой точности Вы можете всегда
преобразовывать в тип фиксированной точки, сохраненный в
<a href="#integer-types"><code>BIGINT</code></a>.
Это позволяет Вам сделать все вычисления с 64-битовыми целыми числами и затем
преобразовать результаты назад в значения с плавающей запятой
по мере необходимости.</p>

<p><code>PROCEDURE ANALYSE</code> может использоваться, чтобы получить
предложения для оптимальных типов данных столбца. Для получения
дополнительной информации см.
<a href="optimiz.htm#procedure-analyse">раздел 9.4.2.4</a>.</p>

<h2><a name="other-vendor-data-types"></a>12.10.
Применение типов данных из других баз данных</h2>
<p>Чтобы облегчить использование кода, написанного для выполнения SQL
других производителей, MySQL отображает типы данных как показано в следующей
таблице. Эти отображения облегчают импорт табличных определений из других
систем баз данных в MySQL.</p>

<table border="1">
<thead><tr><th scope="col">Тип из другой СУБД</th><th scope="col">Тип в MySQL
</th></tr></thead>
<tbody><tr><td scope="row"><a href="#integer-types"><code>BOOL
</code></a></td><td><a href="#integer-types"><code>TINYINT</code>
</a></td></tr>
<tr><td scope="row"><a href="#integer-types"><code>BOOLEAN</code>
</a></td><td><a href="#integer-types"><code>TINYINT</code></a></td>
</tr>
<tr><td scope="row"><code>CHARACTER VARYING(<em><code>M</code></em>)</code>
</td><td><code>VARCHAR(<em><code>M</code></em>)</code></td></tr>
<tr><td scope="row"><a href="#fixed-point-types"><code>FIXED</code>
</a></td><td><a href="#fixed-point-types"><code>DECIMAL</code></a>
</td></tr>
<tr><td scope="row"><a href="#floating-point-types"><code>FLOAT4
</code></a></td><td><a href="#floating-point-types"><code>FLOAT
</code></a></td></tr>
<tr><td scope="row"><a href="#floating-point-types"><code>FLOAT8
</code></a></td><td><a href="#floating-point-types"><code>DOUBLE
</code></a></td></tr>
<tr><td scope="row"><a href="#integer-types"><code>INT1</code></a>
</td><td><a href="#integer-types"><code>TINYINT</code></a></td></tr>
<tr><td scope="row"><a href="#integer-types"><code>INT2</code></a>
</td><td><a href="#integer-types"><code>SMALLINT</code></a></td></tr>
<tr><td scope="row"><a href="#integer-types"><code>INT3</code></a>
</td><td><a href="#integer-types"><code>MEDIUMINT</code></a></td></tr>
<tr><td scope="row"><a href="#integer-types"><code>INT4</code></a>
</td><td><a href="#integer-types"><code>INT</code></a></td></tr>
<tr><td scope="row"><code>INT8</code></td>
<td><a href="#integer-types"><code>BIGINT</code></a></td></tr>
<tr><td scope="row"><code>LONG VARBINARY</code></td>
<td><a href="#blob"><code>MEDIUMBLOB</code></a></td></tr>
<tr><td scope="row"><code>LONG VARCHAR</code></td>
<td><a href="#blob"><code>MEDIUMTEXT</code></a></td></tr>
<tr><td scope="row"><code>LONG</code></td>
<td><a href="#blob"><code>MEDIUMTEXT</code></a></td></tr>
<tr><td scope="row"><a href="#integer-types"><code>MIDDLEINT</code>
</a></td><td><a href="#integer-types"><code>MEDIUMINT</code></a>
</td></tr>
<tr><td scope="row"><a href="#fixed-point-types"><code>NUMERIC
</code></a></td><td><a href="#fixed-point-types"><code>DECIMAL
</code></a></td></tr></tbody></table>

<p>Отображение типа данных происходит во время создания таблицы, после
которого отказываются от оригинальных технических требований типа.
Если Вы составляете таблицу с типами, используемыми другими разработчиками
и затем выполняете <code>DESCRIBE <em><code>tbl_name</code></em></code>,
MySQL сообщает о структуре таблицы, используя эквивалентные
типы MySQL. Например:
<pre>
mysql&gt; CREATE TABLE t (a BOOL, b FLOAT8, c LONG VARCHAR, d NUMERIC);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; DESCRIBE t;
+-------+---------------+------+-----+---------+-------+
| Field | Type          | Null | Key | Default | Extra |
+-------+---------------+------+-----+---------+-------+
| a     | tinyint(1)    | YES  |     | NULL    |       |
| b     | double        | YES  |     | NULL    |       |
| c     | mediumtext    | YES  |     | NULL    |       |
| d     | decimal(10,0) | YES  |     | NULL    |       |
+-------+---------------+------+-----+---------+-------+
4 rows in set (0.01 sec)
</pre>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value); return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>
<tr><td><input type="submit" value="Найти" style="font-size: 9pt"/></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<P><FONT SIZE=-1>Вы можете <A HREF="mailto:alexey.v.pautov@mail.ru">
направить письмо</A> администратору этой странички, Алексею Паутову.</FONT>
<A HREF="mailto:alexey.v.pautov@mail.ru"><IMG SRC="img/email.gif"
ALT="mailto:alexey.v.pautov@mail.ru" BORDER=0 valign="center" HEIGHT=35
WIDTH=105 ALIGN=ABSCENTER></A></P>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>

</body>
</html>
