<HTML>
<HEAD>
  <TITLE>MySQL: Руководство администратора</TITLE>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
</HEAD>

<BODY>

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>


<H1><A NAME="Introduction">1 Основная информация про MySQL</A></H1>
<P>MySQL очень быстрый, многопоточный, многопользовательский и поддерживающий
SQL (Structured Query Language) сервер баз данных.</P>

<P>MySQL является free software. Он лицензируется по <STRONG>GNU GENERAL
PUBLIC LICENSE</STRONG> <a HREF="../../../www.gnu.org/default.htm">http://www.gnu.org</a>.
</P>

<P><a HREF="../../../www.mysql.com/default.htm">Сайт MySQL</a> предоставляет последнюю
информацию касательно MySQL.</P>

<P>Следующий перечень описывает наиболее интересные места руководства:</P>
<UL><LI>Все о разработчиках MySQL можно узнать в разделе
"<A HREF="#What_is_MySQL_AB">1.1.2 Что такое MySQL AB</A>".

<LI>Обсуждение основных возможностей MySQL приведено в разделе
"<A HREF="#Features">1.1.4 Основные возможности MySQL</A>".

<LI>Примеры на SQL и информация по тестированию производительности есть в
каталоге <TT>sql-bench</TT> дистрибутива.

<LI>Перечень известных на сегодняшний день проблем и дефектов приведен в
разделе "<A HREF="#Bugs">1.2.7 Известные ошибки в MySQL</A>".</UL>

<P><STRONG>ВАЖНО:</STRONG></P>
<P>Сообщения об ошибках также как вопросы и комментарии, должны быть посланы
списку рассылки <a HREF="mailto:mysql@lists.mysql.com">
mysql@lists.mysql.com</a>. Подробности в разделе
"<A HREF="#Bug_reports">1.4.1 Как сообщать о проблемах и сбоях</A>".
Скрипт <CODE>mysqlbug</CODE> должен использоваться, чтобы генерировать отчеты
об ошибках. Для дистрибутивов исходных текстов скрипт <CODE>mysqlbug</CODE>
может быть найден в каталоге <TT>scripts</TT>. Для двоичных дистрибутивов
<CODE>mysqlbug</CODE> находится в каталоге <TT>bin</TT>. Если Вы нашли ошибку
защиты в MySQL, Вы должны послать e-mail на
<a HREF="mailto:security@mysql.com">security@mysql.com</a>.</P>

<P>Если Вы имеете любые предложения относительно добавлений или исправлений
этого руководства, пожалуйста, пошлите их на <a HREF="mailto:docs@mysql.com">
docs@mysql.com</a>.</P>

<H2><A NAME="MySQL_and_MySQL_AB">1.1 MySQL, MySQL AB и Open Source</A></H2>

<H3><A NAME="What-is">1.1.1 Что такое MySQL</A></H3>
<P>MySQL представляет собой очень популярную систему управления базами данных
с открытыми исходными текстами, разрабатываемую MySQL AB. MySQL AB является
коммерческой компанией, строящей свой бизнес на сервисах, сосредоточенных на
базе данных MySQL. Подробности в разделе
"<A HREF="#What_is_MySQL_AB">1.1.2 Что такое MySQL AB</A>".</P>

<DL COMPACT>
<DT>MySQL представляет собой систему управления базами данных.
<DD>Базой данных называют структурированный набор данных. Это может быть чем
угодно: от простого перечня покупок до галереи изображений. Чтобы добавлять,
обращаться и обрабатывать данные, сохраненные в компьютерной базе данных, Вы
нуждаетесь в системе управления базы данных, типа MySQL. Так как компьютеры
очень хороши при обработке больших количеств данных, базы данных играют
центральную роль в вычислениях, как автономные утилиты, или как части других
пакетов прикладных программ.

<DT>MySQL является реляционной СУБД.
<DD>Реляционная база данных сохраняет данные в отдельных таблицах. Это
добавляет быстродействие и гибкость. Таблицы связаны определенными
отношениями, делающими возможным объединить данные из нескольких таблиц в
одном запросе. SQL-часть MySQL ориентирована на Structured Query Language,
наиболее общий стандартизированный язык, используемый, чтобы обратиться к
компьютерным базам данных.

<DT>MySQL является Open Source Software.
<DD>Open Source означает, что тексты открыты для чтения и правки всем
желающим. Любой может скачать MySQL из Internet и использовать его совершенно
бесплатно. Любой желающий может изучать исходный текст и изменять его по
своему усмотрению. MySQL использует лицензию GPL (GNU General Public License)
<a HREF="../../../www.gnu.org/default.htm">http://www.gnu.org</a>, чтобы определить то, что
Вы можете делать с программным обеспечением в различных ситуациях. Если Вы
считаете GPL неудобной или должны внедрить MySQL в коммерческую прикладную
программу, Вы можете купить коммерчески запатентованную версию у авторов.

<DT>Почему используют MySQL?
<DD>MySQL очень быстр, надежен и легок в использовании. Если это то, что Вы
ищете, Вы должны попробовать его. MySQL также имеет очень практичный набор
свойств, разработанных в очень близком сотрудничестве с пользователями. Вы
можете найти сравнение эффективности MySQL с некоторыми другими
администраторами баз данных на странице эталонных тестов. Подробности в
разделе "<A HREF="glava05.htm#MySQL_Benchmarks">5.1.4 Пакет тестов MySQL
Benchmark Suite</A>". MySQL был первоначально разработан, чтобы обработать
очень большие базы данных намного быстрее, чем существующие решения, и
успешно использовался в высокотребовательных промышленных средах в течение
нескольких лет. При постоянной разработке MySQL сегодня предлагает богатый и
очень полезный набор функций. Связность, быстродействие и защита делают MySQL
очень подходящим для обращения к базам данных из Internet.

<DT>Технические возможности MySQL.
<DD>MySQL является системой "клиент-сервер", состоящей из многопоточного
SQL-сервера, который поддерживает различные функции, нескольких различных
клиентских программ и библиотек, административных инструментальных средств и
нескольких интерфейсов программирования.

<DT>MySQL имеет много дополнительных программ.
<DD>Вероятно, Вы обнаружите, что Ваша любимая прикладная программа или язык
программирования уже поддерживает MySQL.</DL>

<P>Официально MySQL произносится как "Май-Эс-Ку-Эль", а не как MY-SEQUEL.</P>

<H3><A NAME="What_is_MySQL_AB">1.1.2 Что такое MySQL AB?</A></H3>
<P>MySQL AB является шведской компанией, которая владеет правами на исходные
тексты сервера и марку MySQL. Она занимается разработкой, распространением и
поддержкой пакета MySQL.</P>

<P>Авторы ищут партнеров, которые хотели бы поддерживать разработку MySQL
так, чтобы они могли бы ускорить темп разработки. Если Вы заинтересованы в
этом, напишите на e-mail <a HREF="mailto:partner@mysql.com">
partner@mysql.com</a>!</P>

<P>MySQL AB имеет в настоящее время свыше 20 разработчиков
(<a HREF="../../../www.mysql.com/development/team.html">
http://www.mysql.com/development/team.html</a>) в платежной ведомости, и это
число возрастает быстро.</P>

<P>Основные источники дохода:</P>
<UL><LI>Коммерческая поддержка высокого качества для MySQL, обеспеченная
разработчиками MySQL непосредственно. Если Вы заинтересованы в закупке
контракта поддержки, пожалуйста, посетите <a HREF="../../../https@order.mysql.com/default.htm">
https://order.mysql.com</a>, чтобы рассмотреть параметры поддержки или
собственно заказать поддержку.

<LI>Консультантские услуги. Фирма MySQL AB имеет разработчиков и
консультантов в 12 странах и партнеров во многих других странах, которые
могут помочь Вам почти с любой проблемой с MySQL. Если Вы нуждаетесь в
консультантских услугах, пожалуйста, напишите по e-mail хорошее описание
Ваших потребностей на <a HREF="mailto:info@mysql.com">info@mysql.com</a>!
Если авторы не смогут обработать это непосредственно, то они обычно могут
найти партнера или разработчика, который может помочь Вам с Вашими проблемами.

<LI>Авторы продают лицензии на использование MySQL как встроенной базы данных.
Если Вы имеете коммерческую программу, для которой Вам требуется база данных
высоких качеств, но Вы не можете позволить себе открыть ее исходники, Вы
можете купить право использовать сервер MySQL под нормальным коммерческим
авторским правом. Если Вы заинтересованы этим, Вы можете купить лицензию
прямо на сайте <a HREF="../../../https@order.mysql.com/default.htm">https://order.mysql.com</a>
или написать на <a HREF="mailto:licensing@mysql.com">licensing@mysql.com</a>.

<LI>Реклама. Сайт <a HREF="../../../www.mysql.com/default.htm">http://www.mysql.com</a>
представаляет собой очень популярное место более, чем с 10000000 показами
страницы в месяц (на январь 2001). Сами понимаете, что баннер на таком сайте
гарантирует известность в среде Open source, Linux и баз данных. Если это Вам
интересно и нужно, напишите на <a HREF="mailto:advertising@mysql.com">
advertising@mysql.com</a>.

<LI>Авторы пакета формируют программу партнеров, чтобы иметь возможность
обеспечивать услуги MySQL в каждой стране. Если Вы заинтересованы в том,
чтобы стать таким партнером, пишите на <a HREF="mailto:partner@mysql.com">
partner@mysql.com</a> или посетите сайт программы партнерства
<a HREF="../../../www.mysql.com/information/partners.html">
http://www.mysql.com/information/partners.html</a>.

<LI>Разработчики обеспечивают обучение MySQL через свои программы партнеров.
Для получения большего количества информации, пожалуйста, пишите на
<a HREF="mailto:info@mysql.com">info@mysql.com</a>.

<LI>Если Вы заинтересованы использованием марки изготовителя MySQL в Вашем
маркетинге, Вы можете написать об этом на e-mail
<a HREF="mailto:info@mysql.com">info@mysql.com</a>.</UL>

<P>Авторы пакета хотят, чтобы MySQL всегда был:</P>
<UL><LI>Самой лучшей и наиболее используемой базой данных в мире.
<LI>Доступным для всех.
<LI>Легким в использовании, насколько это возможно для такого пакета.
<LI>Непрерывно улучшаемым при дальнейшем пребывании быстрым и безопасным.
<LI>Свободным от ошибок.</UL>

<P>MySQL AB и команда MySQL AB:</P>
<UL><LI>Продвигает в массы философию Open Source (открытых исходных текстов)
и поддерживает все сообщество разработчиков Open Source Community.
<LI>Предпочитает партнеров, которые совместно используют знания.
<LI>Отвечают на почту и оказывает поддержку.
<LI>Является виртуальной компанией, работающей в основном по сети.
<LI>Выступает против программных патентов.</UL>

<H3><A NAME="History">1.1.3 История MySQL</A></H3>
<P>Началось все с попыток добавить к <CODE>mSQL</CODE> драйвер низкого уровня
для связи с только что разработанным форматом таблиц (ISAM). Однако, после
вдумчивого тестирования, было установлено, что <CODE>mSQL</CODE> недостаточно
быстр и гибок для этого дела. Это закончилось созданием нового интерфейса SQL
к нашей базе данных, но почти с тем же самым интерфейсом API, что и у
<CODE>mSQL</CODE>. Этот API был выбран, чтобы облегчить перенос кодов для
других разработчиков программ.</P>

<P>Название возникло из сокращения (а вернее, слияния) слов My SQL, что на
английском языке значит "мой SQL". Названию около десяти лет, оно прижилось
еще в те времена, когда пакет не был коммерческой разработкой.</P>

<H3><A NAME="Features">1.1.4 Основные возможности MySQL</A></H3>
<P>Следующий перечень описывает наиболее важные возможности MySQL:</P>

<UL><LI>Полностью многопоточное использование ядерных нитей. Это означает,
что пакет может легко использовать много CPUs, если они есть.

<LI>Интерфейсы для языков C, C++, Eiffel, Java, Perl, PHP, Python и Tcl.
<LI>Работает на многих различных платформах.
<LI>Много типов столбцов: целые со знаком или без него длиной 1, 2, 3, 4 и 8
байт, <CODE>FLOAT</CODE>, <CODE>DOUBLE</CODE>, <CODE>CHAR</CODE>,
<CODE>VARCHAR</CODE>, <CODE>TEXT</CODE>, <CODE>BLOB</CODE>,
<CODE>DATE</CODE>, <CODE>TIME</CODE>, <CODE>DATETIME</CODE>,
<CODE>TIMESTAMP</CODE>, <CODE>YEAR</CODE>,
<CODE>SET</CODE> и <CODE>ENUM</CODE>.

<LI>Очень быстрые объединения, использующие оптимизированное однопроходное
объединение многих таблиц.

<LI>Полная поддержка операторов и функций в частях запроса
<CODE>SELECT</CODE> и <CODE>WHERE</CODE>. Например:
<PRE>
mysql&#62; SELECT CONCAT(first_name, " ", last_name) FROM tbl_name
                  WHERE income/dependents &#62; 10000 AND age &#62; 30;
</PRE>

<LI>SQL-функции выполнены через хорошо оптимизированную библиотеку классов и
должны выполняться с такой скоростью, с какой только возможно! Обычно не
имеется никакого распределения памяти вообще после инициализации запроса.

<LI>Полная поддержка предложений SQL <CODE>GROUP BY</CODE> и <CODE>ORDER
BY</CODE>. Поддержка групповых функций (<CODE>COUNT()</CODE>,
<CODE>COUNT(DISTINCT ...)</CODE>, <CODE>AVG()</CODE>, <CODE>STD()</CODE>,
<CODE>SUM()</CODE>, <CODE>MAX()</CODE> и <CODE>MIN()</CODE>).

<LI>Поддержка <CODE>LEFT OUTER JOIN</CODE> и <CODE>RIGHT OUTER JOIN</CODE> с
синтаксисами ANSI SQL и ODBC.

<LI>Вы можете смешивать таблицы из разных баз данных в одном запросе.
<LI>Привилегии и система паролей, которая является очень гибкой и безопасной,
и позволяет проверку, основанную на имени хоста. Пароли безопасны потому, что
вся передача пароля шифрована, когда Вы соединяетесь с сервером.

<LI>ODBC (Open-DataBase-Connectivity) поддерживается для Win32 (с
исходниками). Все функции ODBC 2.5 и многие другие реализованы. Например, Вы
можете использовать MS Access для связи с сервером MySQL.

<LI>Очень быстрые дисковые таблицы B-tree с индексным сжатием.
<LI>Можно иметь до 32 индексов на таблицу. Каждый индекс может состоять от 1
до 16 столбцов или частей столбцов. Максимальная индексная длина 500 байт
(это может быть изменено при компиляции MySQL). Индекс может использовать
префикс поля <CODE>CHAR</CODE> или <CODE>VARCHAR</CODE>.

<LI>Записи фиксированной и переменной длины.
<LI>Таблицы в памяти, которые используются как временные таблицы.
<LI>Поддержка поистине огромных объемов данных. Известен случай использования
MySQL на 60000 таблиц, хранящих около 5000000000 строк.

<LI>Все столбцы имеют значения по умолчанию. Вы можете использовать вызов
<CODE>INSERT</CODE>, чтобы вставить подмножество столбцов таблицы. Те
столбцы, которым явно не заданы значения, будут автоматически установлены к
их значениям по умолчанию.
<LI>Для переносимости использованы GNU Automake, Autoconf и Libtool.
<LI>Пакет написан на C и C++. Оттестирован на всех распространенных
компиляторах этих языков.
<LI>Очень быстрая поточно-безопасная система управления памятью.
<LI>Никаких утечек памяти. MySQL тестировался с помощью Purify, коммерческого
детектора утечек памяти.
<LI>Есть <CODE>myisamchk</CODE>, очень быстрая утилита для проверки таблицы,
оптимизации и ремонта. Все функциональные возможности <CODE>myisamchk</CODE>
также доступны через интерфейс SQL.
<LI>Полная поддержка для нескольких различных наборов символов, включая
ISO-8859-1 (Latin1), german, big5, ujis и много других. Например,
скандинавские символы `@ringaccent{a}', `@"a' и `@"o' позволяются в
именах столбцов и таблиц.
<LI>Все данные сохранены в выбранном наборе символов. Все сравнения для
нормальных столбцов нечувствительны к регистру.
<LI>Сортировка выполнена согласно выбранному набору символов (шведский по
умолчанию). Возможно изменить это, когда сервер MySQL работает. Чтобы увидеть
пример очень продвинутой сортировки, рассмотрите сортировочный код для Czech.
MySQL поддерживает много различных наборов символов, которые могут быть
определены при компиляции или во время выполнения.
<LI>Псевдонимы на таблицах и именах столбцов доступны как в стандарте SQL92.
<LI><CODE>DELETE</CODE>, <CODE>INSERT</CODE>, <CODE>REPLACE</CODE> и
<CODE>UPDATE</CODE> возвращают число строк, которые были изменены
(обработаны). Можно взамен вернуть число согласованных строк, устанавливая
флажок при соединении с сервером.
<LI>Имена функции не сталкиваются с именами столбцов или таблиц. Например,
<CODE>ABS</CODE> представляет собой имеющее силу имя столбца. Единственное
ограничение: для обращения к функции никакие пробелы не позволяются между
именем функции и символом скобки (<SAMP>`('</SAMP>), который следует за ним.
<LI>Все программы пакета MySQL понимают параметры командной строки
<CODE>--help</CODE> или <CODE>-?</CODE> для выдачи справки о параметрах
запуска конкретной программы.
<LI>Сервер умеет выдавать сообщения об ошибках и диагностику на разных языках.
<LI>Клиенты могут соединяться с сервером MySQL, используя все мыслимые
способы, допустимые в сегодняшних сетях: сокеты TCP/IP, сокеты Unix (под
Unix) или даже именованные каналы (под NT).
<LI>MySQL-специфичная команда <CODE>SHOW</CODE> может использоваться, чтобы
получить информацию относительно баз данных, таблиц и индексов. Команда
<CODE>EXPLAIN</CODE> может использоваться, чтобы определить, как именно
оптимизатор решает запрос.</UL>

<H3><A NAME="Stability">1.1.5 Насколько стабилен MySQL?</A></H3>
<P>Этот раздел сводится к вопросам о том, насколько можно доверять пакету, и
сколько шансов, что он разнесет на кусочки важный проект, зависящий от него.
Строго говоря, MySQL очень надежен.</P>

<P>Попробую разъяснить некоторые проблемы и ответить на некоторые из наиболее
важных вопросов, которые, кажется, касаются многих. Этот раздел был собран из
информации, собранной из списка рассылки (который является очень активным по
части сообщений об ошибках и сбоях).</P>

<P>В TcX MySQL работал без любых проблем в проектах, начиная с середины 1996.
Когда MySQL был выпущен на публику, авторы отметили, что имелись некоторые
части непроверенного кода, которые были быстро найдены новыми пользователями,
делавшими запросы иными способами, чем авторы. Каждый новый выпуск имел
меньшее количество проблем мобильности, чем предыдущий (даже при том, что
каждый имел много новых свойств).</P>

<P>Каждый выпуск MySQL был пригоден для использования, и имелись проблемы
только, когда пользователи начинали использовать код из серых зон.
Естественно, пользователи снаружи не видят то, чем являются серые зоны, этот
раздел пытается указать, которые зоны в настоящее время известны. Описания
имеют дело с MySQL Version 3.23. Все известные и сообщенные ошибки
выправлены в последней версии, за исключением ошибок, перечисленных в
отдельном разделе, которые являются проблемами, связанными с проектом.
Подробности в разделе "<A HREF="#Bugs">1.2.7
Известные ошибки и проблемы</A>".</P>

<P>MySQL написан на нескольких уровнях и различных независимых модулях. Эти
модули перечислены ниже с индикацией относительно того, как хорошо проверен
каждый из них (сравните с MS SQL Server!):</P>

<P><A NAME="IDX34"></A></P>
<DL COMPACT>
<DT><STRONG>Драйвер ISAM-таблиц: стабилен.</STRONG>
<DD>Это управляет хранением и поиском всех данных в MySQL Version 3.22 и
ранее. Во всех выпусках MySQL не имелось сообщений об ошибках в этом коде.
Единственный известный способ получить разрушенную таблицу состоит в том,
чтобы уничтожить сервер в середине модификации. Даже это вряд ли уничтожит
любые данные потому, что все данные сбрасываются на диск между запросами. Не
было отчетов об ошибках относительно потерянных данных из-за ошибок в MySQL.

<A NAME="IDX35"></A><A NAME="IDX36"></A><A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<DT><STRONG>Драйвер MyISAM-таблиц: стабилен.</STRONG>
<DD>Это ноовведение MySQL Version 3.23. Это в значительной степени основано
на коде ISAM-таблиц, но имеет много новых и очень полезных свойств.

<DT><STRONG>Лексический анализатор и обработчик команд: стабильны.</STRONG>
<DD>Не было сообщений об ошибках в этой системе в течение длительного времени.

<DT><STRONG>Клиентский код на C: стабилен.</STRONG>
<DD>Никаких известных проблем. До Version 3.20 имелись некоторые ограничения
в размере буферов передачи/приема. Начиная с Version 3.21, буферный размер
теперь динамически меняется до значения по умолчанию в 16M.

<DT><STRONG>Стандартные клиентские программы: стабильны.</STRONG>
<DD>Это касается утилит <CODE>mysql</CODE>, <CODE>mysqladmin</CODE>,
<CODE>mysqlshow</CODE>, <CODE>mysqldump</CODE> и <CODE>mysqlimport</CODE>.

<DT><STRONG>Поддержка SQL: стабильна.</STRONG>
<DD>Базисная система функций SQL, классы строк и динамическая обработка
памяти. Ни одной сообщенной ошибки в этой системе.

<DT><STRONG>Оптимизатор запросов: стабилен.</STRONG>
<DD>
<DT><STRONG>Оптимизатор диапазонов: стабилен.</STRONG>
<DD>
<DT><STRONG>Оптимизатор объединений: стабилен.</STRONG>
<DD>
<DT><STRONG>Блокировки: пока Gamma.</STRONG>
<DD>Это очень зависит от системы. На некоторых системах имеются большие
проблемы при использовании стандарта блокировки OS (<CODE>fcntl()</CODE>). В
этих случаях Вы должны выполнить MySQL с опцией <CODE>--skip-locking</CODE>.
Проблемы, как известно, происходят на некоторых Linux-системах и на SunOS при
использовании файловых систем по NFS.

<DT><STRONG>Linux threads: стабильно.</STRONG>
<DD> Главная найденная проблема была с обращением <CODE>fcntl()</CODE>,
которое исправлено, используя опцию <CODE>--skip-locking</CODE> для
<CODE>mysqld</CODE>. Некоторые пользователи сообщали о проблемах тупика в
Version 0.5. LinuxThreads должен быть перетранслирован, если Вы планируете
использовать свыше 1000 параллельных подключений. Хотя можно выполнить много
подключений с LinuxThreads по умолчанию (однако, Вы никогда не будете иметь
более, чем 1021 подключение), заданный по умолчанию лимит стека в 2 МБ делает
прикладную программу ненадежной, и она способна свалиться в дамп ядра после
создания 1021 неактивных подключений.

<DT><STRONG>Solaris 2.5+ pthreads: стабильно.</STRONG>
<DD>Мы используем это для всей нашей промышленной работы.

<DT><STRONG>MIT-pthreads (прочие системы): стабильно.</STRONG>
<DD>Не имелось никаких сообщенных ошибок, начиная с Version 3.20.15, и
никаких известных авторам (почувствуйте разницу!) ошибок, начиная с Version
3.20.16. На некоторых системах имеется сильное замедление операций (до 1/20
секунды бездействия между каждыми двумя запросами). Конечно, MIT-pthreads
может все немного замедлять, но индексные инструкции <CODE>SELECT</CODE>
обычно выполняются в одном пакете.

<DT><STRONG>Другие реализации потоков: Beta-Gamma.</STRONG>
<DD>Версии для других систем все еще очень новые и могут иметь ошибки,
возможно, в MySQL, но наиболее часто непосредственно в реализации потоков.

<DT><STRONG><CODE>LOAD DATA...</CODE>, <CODE>INSERT...SELECT</CODE>:
стабильно.</STRONG>
<DD>Некоторые люди думали, что они нашли ошибки здесь, но они обычно просто
не поняли ситуацию. Пожалуйста, внимательно проверьте руководство перед тем,
как сообщать о возникших проблемах!

<DT><STRONG><CODE>ALTER TABLE</CODE>: стабильно.</STRONG>
<DD>Маленькие изменения в Version 3.22.12.

<DT><STRONG>DBD: стабильно.</STRONG>
<DD>Сейчас поддерживает Jochen Wiedmann
(<a HREF="mailto:wiedmann@neckar-alb.de">wiedmann@neckar-alb.de</a>). Спасибо!

<DT><STRONG><CODE>mysqlaccess</CODE>: стабильно.</STRONG>
<DD>Написан и поддерживается Yves Carlier
(<a HREF="mailto:Yves.Carlier@rug.ac.be">Yves.Carlier@rug.ac.be</a>). Спасибо!

<DT><STRONG><CODE>GRANT</CODE>: стабильно.</STRONG>
<DD>Большие изменения внесены в MySQL Version 3.22.12.

<DT><STRONG><STRONG>MyODBC</STRONG> (используется ODBC SDK 2.5): Gamma.
</STRONG>
<DD>Это, кажется, уже работает хорошо с некоторыми программами.

<DT><STRONG>Репликация: Beta/Gamma.</STRONG>
<DD>Авторы все еще работают над репликацией, так что не ожидайте, что это
будет твердой скалой. С другой стороны, некоторые пользователи MySQL уже
вовсю применяют это свойство с очень хорошими результатами.

<DT><STRONG>Таблицы BDB: Beta.</STRONG>
<DD>Код Berkeley DB сам по себе очень устойчив, но разработчики пакета все
еще улучшают интерфейс между MySQL и таблицами BDB, так что будет требоваться
некоторое время прежде, чем все будет надежно.

<DT><STRONG>Таблицы InnoDB: Beta.</STRONG>
<DD>Это недавнее добавление к <CODE>MySQL</CODE>. Они работают хорошо и
могут использоваться после начального тестирования.

<DT><STRONG>Автоматический ремонт таблиц MyISAM: Beta.</STRONG>
<DD>Это воздействует только на новый код, который проверяет, была ли таблица
закрыта правильно, и выполняет автоматическую проверку/ремонт таблицы, если
это не так.

<DT><STRONG>Таблицы MERGE: Beta/Gamma.</STRONG>
<DD>Использование ключей на таблицах <CODE>MERGE</CODE> все еще не
оттестировано как следует. Другая часть кода <CODE>MERGE</CODE> проверена.

<DT><STRONG>FULLTEXT: Beta.</STRONG>
<DD>Текстовый поиск работает, но все еще не используется широко.</DL>

<P>MySQL AB обеспечивает поддержку по электронной почте для покупателей
соответствующей услуги, но список рассылки MySQL обычно обеспечивает ответы
на общие вопросы. Ошибки обычно исправляются сразу же с помощью патча, для
серьезных ошибок почти всегда имеется новый выпуск.</P>

<H3><A NAME="Table_size">1.1.6 Насколько большими могут быть таблицы MySQL?
</A></H3>
<P>MySQL Version 3.22 имеет лимит в 4G на размер таблицы. С новым кодом
<CODE>MyISAM</CODE> в MySQL Version 3.23 максимальный размер таблицы увеличен
до 8 миллионов терабайт (2^63 байт).</P>

<P>Обратите внимание, однако, что операционные системы имеют их собственные
ограничения размера файла. Имеются некоторые примеры:</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Операционная система</STRONG></TD><TD><STRONG>Ограничение
размера файла</STRONG></TD></TR>
<TR><TD>Linux-Intel 32 bit</TD><TD>2G, 4G или больше, зависит от версии Linux
</TD></TR>
<TR><TD>Linux-Alpha</TD><TD>8T (?)</TD></TR>
<TR><TD>Solaris 2.5.1</TD><TD>2G (возможно, до 4G с патчем)</TD></TR>
<TR><TD>Solaris 2.6</TD><TD>4G</TD></TR>
<TR><TD>Solaris 2.7 Intel</TD><TD>4G</TD></TR>
<TR><TD>Solaris 2.7 ULTRA-SPARC</TD><TD>8T (?)</TD></TR></TABLE>

<P>В Linux 2.2 Вы можете получать таблицы больше, чем 2G, используя заплату
LFS для файловой системы ext2. В Linux 2.4 существует также заплата для
ReiserFS, чтобы получить поддержку для больших файлов.</P>

<P>Это означает, что размер таблицы для MySQL обычно ограничивается
операционной системой, а не самим пакетом.</P>

<P>По умолчанию таблицы MySQL имеют максимальный размер около 4G. Вы можете
проверять максимальный размер таблицы для каждой конкретной таблицы с помощью
команды <CODE>SHOW TABLE STATUS</CODE> или утилитой <CODE>myisamchk -dv
table_name</CODE>. Подробности приведены в
разделе "<A HREF="admin.htm#SHOW">4.5.5 Синтаксис <CODE>SHOW</CODE></A>".</P>

<P>Если Вы нуждаетесь в таблицах, больших, чем 4G (и Ваша операционная
система поддерживает это), Вы должны установить параметры
<CODE>AVG_ROW_LENGTH</CODE> и <CODE>MAX_ROWS</CODE>, когда Вы создаете Вашу
таблицу. Вы можете установить их и позже с помощью <CODE>ALTER TABLE</CODE>.

<P>Если Ваша большая таблица нужна только для чтения, Вы могли бы
использовать <CODE>myisampack</CODE>, чтобы объединить и сжать много таблиц в
одну. Утилита <CODE>myisampack</CODE> обычно сжимает таблицу по крайней мере
на 50%, так что Вы можете иметь намного большие таблицы.</P>

<P>Вы можете обойти ограничения размера файла операционной системы для
файлов данных <CODE>MyISAM</CODE>, используя опцию <CODE>RAID</CODE>.

<P>Другое решение может быть реализовано с помощью библиотеки MERGE, которая
позволяет Вам обрабатывать совокупность идентичных
таблиц как одну.

<H3><A NAME="Year_2000_compliance">1.1.7 Совместимость с проблемой 2000</A>
</H3>
<P>MySQL непосредственно не имеет никаких трудностей с проблемой 2000 (Y2K):
</P>

<UL><LI>MySQL использует Unix-функции времени и не имеет никаких проблем с
датами до <CODE>2069</CODE>. Все годы с 2 цифрами расценены в интервале от
<CODE>1970</CODE> до <CODE>2069</CODE>, это означает, что, если Вы сохраняете
<CODE>01</CODE> в столбце типа <CODE>year</CODE>, MySQL обрабатывает это как
<CODE>2001</CODE>.
<LI>Все функции даты в MySQL сохранены в одном файле <TT>sql/time.cc</TT> и
кодированы очень тщательно, чтобы быть абсолютно 2000-безопасными.
<LI>В MySQL Version 3.22 и позже новый тип столбца <CODE>YEAR</CODE> может
сохранять годы <CODE>0</CODE> и в интервале от <CODE>1901</CODE> до
<CODE>2155</CODE> в 1 байте, а также отображать их, используя 2 или 4 цифры.
</UL>

<P>Вы можете сталкиваться с проблемами в прикладных программах, которые
используют MySQL, но сами несовместимы с проблемой Y2K. Например, много
старых прикладных программ сохраняют или управляют значениями лет,
используя числа с 2 цифрами (которые являются неоднозначными). Эта проблема
также может быть составлена прикладными программами, которые используют
<CODE>00</CODE> или <CODE>99</CODE> как значения для индикатора "пропустить".
В свое время пришлось столкнуться с программой, которая помечала удаленные
записи, выставляя им год <CODE>00</CODE>...</P>

<P>К сожалению, эти проблемы могут быть трудными в исправлении потому, что
различные прикладные программы могут быть написаны различными программистами,
каждый из которых может использовать различный набор соглашений и
обрабатывающих даты функций.</P>

<P>Имеется простой пример, иллюстрирующий, что MySQL не имеет любых проблем с
датами до года 2030:</P>
<PRE>
mysql&#62; DROP TABLE IF EXISTS y2k;
Query OK, 0 rows affected (0.01 sec)

mysql&#62; CREATE TABLE y2k (date date, date_time datetime,
                             time_stamp timestamp);
Query OK, 0 rows affected (0.00 sec)

mysql&#62; INSERT INTO y2k VALUES
    -&#62; ("1998-12-31","1998-12-31 23:59:59",19981231235959),
    -&#62; ("1999-01-01","1999-01-01 00:00:00",19990101000000),
    -&#62; ("1999-09-09","1999-09-09 23:59:59",19990909235959),
    -&#62; ("2000-01-01","2000-01-01 00:00:00",20000101000000),
    -&#62; ("2000-02-28","2000-02-28 00:00:00",20000228000000),
    -&#62; ("2000-02-29","2000-02-29 00:00:00",20000229000000),
    -&#62; ("2000-03-01","2000-03-01 00:00:00",20000301000000),
    -&#62; ("2000-12-31","2000-12-31 23:59:59",20001231235959),
    -&#62; ("2001-01-01","2001-01-01 00:00:00",20010101000000),
    -&#62; ("2004-12-31","2004-12-31 23:59:59",20041231235959),
    -&#62; ("2005-01-01","2005-01-01 00:00:00",20050101000000),
    -&#62; ("2030-01-01","2030-01-01 00:00:00",20300101000000),
    -&#62; ("2050-01-01","2050-01-01 00:00:00",20500101000000);
Query OK, 13 rows affected (0.01 sec)
Records: 13  Duplicates: 0  Warnings: 0

mysql&#62; SELECT * FROM y2k;
+------------+---------------------+----------------+
| date       | date_time           | time_stamp     |
+------------+---------------------+----------------+
| 1998-12-31 | 1998-12-31 23:59:59 | 19981231235959 |
| 1999-01-01 | 1999-01-01 00:00:00 | 19990101000000 |
| 1999-09-09 | 1999-09-09 23:59:59 | 19990909235959 |
| 2000-01-01 | 2000-01-01 00:00:00 | 20000101000000 |
| 2000-02-28 | 2000-02-28 00:00:00 | 20000228000000 |
| 2000-02-29 | 2000-02-29 00:00:00 | 20000229000000 |
| 2000-03-01 | 2000-03-01 00:00:00 | 20000301000000 |
| 2000-12-31 | 2000-12-31 23:59:59 | 20001231235959 |
| 2001-01-01 | 2001-01-01 00:00:00 | 20010101000000 |
| 2004-12-31 | 2004-12-31 23:59:59 | 20041231235959 |
| 2005-01-01 | 2005-01-01 00:00:00 | 20050101000000 |
| 2030-01-01 | 2030-01-01 00:00:00 | 20300101000000 |
| 2050-01-01 | 2050-01-01 00:00:00 | 00000000000000 |
+------------+---------------------+----------------+
13 rows in set (0.00 sec)
</PRE>

<P>Это показывает, что типы <CODE>DATE</CODE> и <CODE>DATETIME</CODE> не
будут давать никаких проблем с будущими датами (они легко обрабатывают даты
вообще до 9999 года).</P>

<P>Тип <CODE>TIMESTAMP</CODE>, который используется, чтобы сохранить текущее
(актуальное) время, имеет диапазон только до <CODE>2030-01-01</CODE>.
<CODE>TIMESTAMP</CODE> имеет диапазон от <CODE>1970</CODE> до
<CODE>2030</CODE> на 32-разрядных машинах (значение со знаком). На
64-разрядных машинах это обрабатывает времена до <CODE>2106</CODE> года
(значение без знака).</P>

<P>Даже при том, что MySQL Y2K-совместим, Вы отвечаете за то, чтобы
обеспечить однозначный ввод.</P>

<H2><A NAME="Compatibility">1.2 MySQL и стандарты</A></H2>
<P>Этот раздел описывает, как MySQL соответствует стандартам ANSI SQL. MySQL
имеет много расширений для них, здесь Вы выясните, что они из себя
представляют, и как использовать их. Вы также найдете информацию относительно
функциональных возможностей, отсутствующих в MySQL, и как обойти проблемы.
</P>

<H3><A NAME="Extensions_to_ANSI">1.2.1 MySQL-расширения для
стандарта ANSI SQL92</A></H3>
<P>MySQL включает некоторые расширения, которые Вы, вероятно, не будете
находить в других базах данных SQL. Предупреждаю, что, если Вы используете
их, Ваш код не будет переносимым на другие SQL-серверы. В некоторых случаях
Вы можете писать код, который включает MySQL-расширения, но все же является
переносимым за счет комментариев формы <CODE>/*! ... */</CODE>. В этом случае
MySQL анализирует и выполнит код внутри комментария, но другие SQL-серверы
игнорируют расширения. Например:</P>
<PRE>
SELECT /*! STRAIGHT_JOIN */ col_name FROM table1,table2 WHERE ...
</PRE>

<P>Если Вы добавляете номер версии после <CODE>'!'</CODE>, синтаксис будет
выполнен только, если версия MySQL равна или больше, чем этот номер версии:
</P>
<PRE>
CREATE /*!32302 TEMPORARY */ TABLE (a int);
</PRE>

<P>Это означает, что, если Вы имеете Version 3.23.02 или более новую, MySQL
использует ключевое слово <CODE>TEMPORARY</CODE>.</P>

<P>MySQL-расширения перечислены ниже:</P>
<UL><LI>Поля типов <CODE>MEDIUMINT</CODE>, <CODE>SET</CODE>,
<CODE>ENUM</CODE> и разные типы <CODE>BLOB</CODE> и <CODE>TEXT</CODE>.

<LI>Атрибуты полей <CODE>AUTO_INCREMENT</CODE>, <CODE>BINARY</CODE>,
<CODE>NULL</CODE>, <CODE>UNSIGNED</CODE> и <CODE>ZEROFILL</CODE>.

<LI>Все сравнения строк нечувствительны к регистру по умолчанию, сортировка
зависит от текущего набора символов (по умолчанию ISO-8859-1 Latin1). Если Вы
не находите это удобным, Вы должны объявить Ваши столбцы с атрибутом
<CODE>BINARY</CODE> или использовать ключевое слово <CODE>BINARY</CODE>,
которое заставляет сравнения быть выполненными согласно порядку ASCII,
используемому на сервере MySQL.

<LI>MySQL отображает каждую базу данных к каталогу под каталогом данных
MySQL, а таблицы внутри базы данных к именам файлов в каталоге баз данных.
Это имеет несколько значений:

<A NAME="IDX129"></A><A NAME="IDX130"></A><A NAME="IDX131"></A>
<A NAME="IDX132"></A><UL><LI>Имена баз данных и таблиц в MySQL чувствительны
к регистру на операционных системах, которые имеют чувствительные к регистру
имена файлов (подобно большинству Unix-систем).

<LI>Имена баз данных, таблиц, индексов, столбцов или псевдонимы могут
начинаться с цифр (но не могут состоять исключительно из цифр).

<LI>Вы можете использовать стандартные команды системы, чтобы резервировать,
переименовывать, перемещать, удалять или копировать таблицы. Например, чтобы
переименовать таблицу, переименуйте файлы <TT>.MYD</TT>, <TT>.MYI</TT> и
<TT>.frm</TT>, которым таблица соответствует.</UL>

<LI>В инструкциях SQL Вы можете обращаться к таблицам из различных баз
данных с помощью синтаксиса <CODE>db_name.tbl_name</CODE>. Некоторые
SQL-серверы обеспечивают те же самые функциональные возможности, но называют
это <CODE>User space</CODE>. MySQL не поддерживает пространство таблиц как
in: <CODE>create table ralph.my_table...IN my_tablespace</CODE>.
<LI><CODE>LIKE</CODE> позволяется на числовых столбцах.
<LI>Использование <CODE>INTO OUTFILE</CODE> и <CODE>STRAIGHT_JOIN</CODE>
допустимо в инструкции <CODE>SELECT</CODE>.
<LI>Опция <CODE>SQL_SMALL_RESULT</CODE> в инструкции <CODE>SELECT</CODE>.
<LI>Есть инструкция <CODE>EXPLAIN SELECT</CODE>, чтобы получить описание
того, как таблицы соединены.
<LI>Использование индексных имен на префиксе поля и параметров
<CODE>INDEX</CODE> или <CODE>KEY</CODE> в инструкции
<CODE>CREATE TABLE</CODE>.
<LI>Применение <CODE>TEMPORARY</CODE> или <CODE>IF NOT EXISTS</CODE> с
<CODE>CREATE TABLE</CODE>.
<LI>Применение <CODE>COUNT(DISTINCT list)</CODE>, где 'list' включает больше,
чем один элемент.
<LI>Применение <CODE>CHANGE col_name</CODE>, <CODE>DROP col_name</CODE> или
<CODE>DROP INDEX</CODE>, <CODE>IGNORE</CODE> или <CODE>RENAME</CODE> в вызове
команды <CODE>ALTER TABLE</CODE>.
<LI>Применение <CODE>RENAME TABLE</CODE>.
<LI>Использование нескольких инструкций <CODE>ADD</CODE>, <CODE>ALTER</CODE>,
<CODE>DROP</CODE> или <CODE>CHANGE</CODE> в одном
вызове <CODE>ALTER TABLE</CODE>.
<LI>Использование <CODE>DROP TABLE</CODE> с ключевым словом <CODE>IF EXISTS
</CODE>.
<LI>Вы можете удалять много таблиц одиночной инструкцией <CODE>DROP
TABLE</CODE>.
<LI>Предложение <CODE>LIMIT</CODE> в инструкции <CODE>DELETE</CODE>.
<LI>Предложение <CODE>DELAYED</CODE> в инструкциях <CODE>INSERT</CODE> и
<CODE>REPLACE</CODE>.
<LI>Предложение <CODE>LOW_PRIORITY</CODE> в инструкциях <CODE>INSERT</CODE>,
<CODE>REPLACE</CODE>, <CODE>DELETE</CODE> и <CODE>UPDATE</CODE>.
<A NAME="IDX133"></A><A NAME="IDX134"></A><LI>Использование <CODE>LOAD DATA
INFILE</CODE>. Во многих случаях этот синтаксис совместим с Oracle
<CODE>LOAD DATA INFILE</CODE>.
<LI>Инструкции <CODE>ANALYZE TABLE</CODE>, <CODE>CHECK TABLE</CODE>,
<CODE>OPTIMIZE TABLE</CODE> и <CODE>REPAIR TABLE</CODE>.
<LI>Инструкция <CODE>SHOW</CODE>.
<LI>Строки могут быть обозначены с помощью <SAMP>`"'</SAMP> или
<SAMP>`''</SAMP>, а не только <SAMP>`''</SAMP>.
<LI>Использование Escape-символа <SAMP>`\'</SAMP>.
<LI>Инструкция <CODE>SET OPTION</CODE>.
<LI>Вы не должны назвать все выбранные столбцы в <CODE>GROUP BY</CODE>.
Это дает лучшую эффективность для некоторых очень специфических, но
совершенно нормальных запросов.
<LI>Можно определять параметры <CODE>ASC</CODE> и <CODE>DESC</CODE> с вызовом
<CODE>GROUP BY</CODE>. Очень полезно.
<LI>Чтобы сделать проще для пользователей миграцию из других SQL-сред, MySQL
поддерживает псевдонимы для многих функций. Например, все функции строк
поддерживают синтаксисы ANSI SQL и ODBC.
<LI>MySQL понимает операторы <CODE>||</CODE> и <CODE>&#38;&</CODE> в качестве
OR и AND, как в языке программирования C. В MySQL <CODE>||</CODE> и
<CODE>OR</CODE> синонимы, так же как <CODE>&#38;&</CODE> и <CODE>AND</CODE>.
Из-за этого хорошего синтаксиса MySQL не поддерживает оператор ANSI SQL
<CODE>||</CODE> для конкатенации строк, используйте вместо него
<CODE>CONCAT()</CODE>. Поскольку <CODE>CONCAT()</CODE> берет любое число
параметров, просто преобразовать использование <CODE>||</CODE> в MySQL.
<LI><CODE>CREATE DATABASE</CODE> или <CODE>DROP DATABASE</CODE>.
<A NAME="IDX135"></A><A NAME="IDX136"></A><LI>Оператор <CODE>%</CODE>
является синонимом для <CODE>MOD()</CODE>. То есть <CODE>N%M</CODE>
равносильно <CODE>MOD(N,M)</CODE>. <CODE>%</CODE> поддержан для
C-программистов и для совместимости с PostgreSQL.
<LI>Операторы <CODE>=</CODE>, <CODE>&#60;&#62;</CODE>, <CODE>&#60;=</CODE>,
<CODE>&#60;</CODE>, <CODE>&#62;=</CODE>,<CODE>&#62;</CODE>,
<CODE>&#60;&#60;</CODE>, <CODE>&#62;&#62;</CODE>, <CODE>&#60;=&#62;</CODE>,
<CODE>AND</CODE>, <CODE>OR</CODE> или <CODE>LIKE</CODE> могут использоваться
в сравнениях столбца слева от <CODE>FROM</CODE> в инструкции
<CODE>SELECT</CODE>. Например, так:
<PRE>
mysql&#62; SELECT col1=1 AND col2=2 FROM tbl_name;
</PRE>

<LI>Функция <CODE>LAST_INSERT_ID()</CODE>.
<LI>Регулярные выражения с расширениями <CODE>REGEXP</CODE> и
<CODE>NOT REGEXP</CODE> в операторах.
<LI>Вызов функций <CODE>CONCAT()</CODE> или <CODE>CHAR()</CODE> с одним
параметром или больше, чем с двумя параметрами. В MySQL эти функции могут
брать любое число параметров.
<LI>Функции <CODE>BIT_COUNT()</CODE>, <CODE>CASE</CODE>, <CODE>ELT()</CODE>,
<CODE>FROM_DAYS()</CODE>, <CODE>FORMAT()</CODE>, <CODE>IF()</CODE>,
<CODE>PASSWORD()</CODE>, <CODE>ENCRYPT()</CODE>, <CODE>md5()</CODE>,
<CODE>ENCODE()</CODE>, <CODE>DECODE()</CODE>, <CODE>PERIOD_ADD()</CODE>,
<CODE>PERIOD_DIFF()</CODE>, <CODE>TO_DAYS()</CODE> и <CODE>WEEKDAY()</CODE>.
<LI>Использование <CODE>TRIM()</CODE> для подрезания подстрок. ANSI SQL
поддерживает удаление только одиночных символов.
<LI>В <CODE>GROUP BY</CODE> можно использовать <CODE>STD()</CODE>,
<CODE>BIT_OR()</CODE> и <CODE>BIT_AND()</CODE>.
<LI>Применение <CODE>REPLACE</CODE> вместо связки
<CODE>DELETE</CODE>+<CODE>INSERT</CODE>.
<LI>Инструкция <CODE>FLUSH flush_option</CODE>.
<LI>Возможность устанавливать переменные в инструкции через <CODE>:=</CODE>:
<PRE>
SELECT @a:=SUM(total),@b=COUNT(*),@a/@b AS avg FROM test_table;
SELECT @t1:=(@t2:=1)+@t3:=4,@t1,@t2,@t3;
</PRE></UL>

<H3><A NAME="Differences_from_ANSI">1.2.2 Отличия MySQL от ANSI SQL92</A>
</H3>
<P>Авторы пробуют заставить MySQL следовать стандартам ANSI SQL и ODBC SQL,
но в некоторых случаях MySQL обрабатывает некоторые дела по-другому:</P>

<UL><LI><CODE>--</CODE> является комментарием, только если сопровождается
незаполненным пространством. Подробности чуть ниже.

<LI>Для столбцов <CODE>VARCHAR</CODE> конечные пробелы будут удалены, когда
значение сохранено. Подробности в разделе "<A HREF="#Bugs">1.2.7
Известные ошибки и проблемы</A>".

<LI>В ряде случаев столбцы типа <CODE>CHAR</CODE> тихо меняются на столбцы
типа <CODE>VARCHAR</CODE>.

<LI>Привилегии для таблицы автоматически не отменяются, когда Вы удаляете
таблицу. Вы должны явно выдать <CODE>REVOKE</CODE>, чтобы отменить все
привилегии для таблицы.

<LI><CODE>NULL AND FALSE</CODE> вернет <CODE>NULL</CODE> вместо
<CODE>FALSE</CODE>, чтобы не возиться долго с оценкой выражений.</UL>

<H3><A NAME="ANSI_mode">1.2.3 Запуск MySQL в режиме ANSI</A></H3>
<P>Если Вы запустили <CODE>mysqld</CODE> с опцией <CODE>--ansi</CODE>,
поведение MySQL изменится следующим образом:</P>

<UL><LI><CODE>||</CODE> является конкатенацией строк, а не <CODE>OR</CODE>.
<LI>Вы можете иметь любое число пробелов между именем функции и
<SAMP>`('</SAMP>. Это вынуждает все имена функций обрабатываться
как зарезервированные слова.
<LI><SAMP>`"'</SAMP> будет цитировать идентификаторы (аналогично MySQL
<SAMP>``'</SAMP>), но не строки.
<LI><CODE>REAL</CODE> превратится в синоним для <CODE>FLOAT</CODE> вместо
синонима для <CODE>DOUBLE</CODE>.
<LI>Заданный по умолчанию уровень изоляции транзакции <CODE>SERIALIZABLE
</CODE>.</UL>

<P>Этого также можно достичь опцией <CODE>--sql-mode=REAL_AS_FLOAT,
PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,SERIALIZE,ONLY_FULL_GROUP_BY</CODE>.
</P>

<H3><A NAME="Missing_functions">1.2.4
Функциональные возможности, отсутствующие в MySQL</A></H3>
<P>Следующие функциональные возможности отсутствуют в текущей версии MySQL.
Есть список, указывающий, когда новые расширения могут быть добавлены к
MySQL (с их приоритетами), его можно посмотреть в Интернете по адресу
<a HREF="../../../www.mysql.com/documentation/manual.php@section=TODO">
http://www.mysql.com/documentation/manual.php?section=TODO</a>.</P>

<H4><A NAME="Missing_Sub-selects">1.2.4.1
Вложенные операторы select (sub-selects)</A></H4>
<P>MySQL в настоящее время поддерживает sub-selects только в виде
<CODE>INSERT ... SELECT ...</CODE> и <CODE>REPLACE ... SELECT ...</CODE>.
Вы можете, однако, использовать функцию <CODE>IN()</CODE> в других контекстах.
</P>

<P>Во многих случаях Вы можете переписать запрос без sub-select:</P>
<PRE>
SELECT * FROM table1 WHERE id IN (SELECT id FROM table2);
</PRE>

<P>Это может быть переделано так:</P>
<PRE>
SELECT table1.* FROM table1,table2 WHERE table1.id=table2.id;
</PRE>

<P>Запросы:
<PRE>
SELECT * FROM table1 WHERE id NOT IN (SELECT id FROM table2);
SELECT * FROM table1 WHERE NOT EXISTS (SELECT id FROM table2
                     where table1.id=table2.id);
</PRE>

<P>Могут быть переделаны так:</P>
<PRE>
SELECT table1.* FROM table1 LEFT JOIN table2 ON table1.id=table2.id
                where table2.id IS NULL
</PRE>

<P>Для более сложных подзапросов Вы можете часто создавать временные таблицы,
чтобы сохранить подзапрос. В некоторых случаях эта опция не будет работать.
Наиболее часто это происходит с инструкциями <CODE>DELETE</CODE>, для которых
стандарт SQL не поддерживает объединения (за исключением sub-selects). Для
этой ситуации имеются два решения, доступные пока подзапросы не поддержаны.
</P>

<P>Первое должно использовать процедурный язык программирования (типа Perl
или PHP) чтобы представить на рассмотрение такой запрос <CODE>SELECT</CODE>,
чтобы получить первичные ключи для записей, которые будут удалены, и затем
использовать эти значения, чтобы создать инструкцию <CODE>DELETE</CODE>
(<CODE>DELETE FROM ... WHERE ... IN (key1, key2, ...)</CODE>).</P>

<P>Второе решение должно использовать интерактивный SQL для автопостроения
набора инструкций <CODE>DELETE</CODE> при использовании MySQL-расширения
<CODE>CONCAT()</CODE> (вместо стандартного оператора <CODE>||</CODE>):</P>
<PRE>
SELECT CONCAT('DELETE FROM tab1 WHERE pkid = ', tab1.pkid, ';')
       FROM tab1, tab2
       WHERE tab1.col1 = tab2.col2;
</PRE>

<P>Вы можете помещать этот запрос в файл скрипта и переназначать ввод на
интерпретатор командных строк <CODE>mysql</CODE>, отправив вывод на его
вторую копию клиента:</P>
<PRE>
prompt&#62; mysql --skip-column-names mydb &#60; myscript.sql|mysql mydb
</PRE>

<P>MySQL 4.0 поддерживает многотабличное удаление, которое может
использоваться, чтобы эффективно удалить строки, основанные на информации из
одной таблицы (или даже из многих таблиц) в то же самое время.</P>

<H4><A NAME="Missing_SELECT_INTO_TABLE">1.2.4.2 <CODE>SELECT INTO TABLE
</CODE></A></H4>
<P>MySQL не поддерживает Oracle SQL-расширение <CODE>SELECT ... INTO
TABLE ...</CODE>. MySQL вместо него поддерживает синтаксис ANSI SQL
<CODE>INSERT INTO ... SELECT ...</CODE>, который является в основном той
же самой функциональностью.</P>
<PRE>
INSERT INTO tblTemp2 (fldID) SELECT tblTemp1.fldOrder_ID
       FROM tblTemp1
       WHERE tblTemp1.fldOrder_ID &#62; 100;
</PRE>

<P>Альтернативно, Вы можете использовать <CODE>SELECT INTO OUTFILE...</CODE>
или <CODE>CREATE TABLE ... SELECT</CODE>, чтобы решить Вашу проблему.</P>

<H4><A NAME="Missing_Transactions">1.2.4.3 Транзации</A></H4>
<P>Поскольку MySQL в настоящее время поддерживает транзакции, следующее
обсуждение имеет силу, только если Вы используете не
транзакционно-безопасные типы таблицы.</P>

<P>Часто спрашивают, почему MySQL не транзационная база данных?</P>

<P>MySQL сделал сознательное решение поддерживать другую парадигму для
целостности данных: атомные операции. Дело в том, что атомные операции
предлагают равную или даже лучшую целостность с намного лучшей
эффективностью. Однако, авторы пакета тем не менее оценивают и понимают
транзакционную парадигму базы данных и планируют в следующих версиях
представить транзакционно-безопасные таблицы. Пользователям будет
предоставлена возможность решить, нуждаются ли они в быстродействии атомных
операций, или они должны использовать свойства транзакций в своих программах.
</P>

<P>Давайте разберемся в том, как MySQL поддержает строгую целостность, и
сравним эти свойства с транзакциями.</P>

<P>Перво-наперво в транзакционной системе, если Ваши программы в критических
ситуациях вызывают rollback вместо commit, транзакционная схема удобней.
Кроме того, транзакции гарантируют, что незаконченные модификации или
разрушительные действия не будут применены к базе данных немедленно, сервер
дает возможность сделать автоматическую обратную перемотку, и Ваша база
данных будет сохранена.</P>

<P>MySQL почти во всех случаях позволяет Вам обойти проблемы включением
простых проверок перед модификациями и запуском простых скриптов, которые
проверяют целостность базы данных, а также автоматически проводят ремонт.
Обратите внимание, что только используя файл регистрации MySQL или даже
добавляя один дополнительный файл регистрации, обычно можно востанавливать
таблицы без потери целостности данных.</P>

<P>Кроме того, фатальные модификации в транзакционной схеме могут быть
переделаны так, чтобы стать атомными. Фактически все проблемы целостности,
которые решают транзакции, могут быть выполнены с помощью <CODE>LOCK
TABLES</CODE> или атомными модификациями, гарантируя, что Вы никогда не
получите автоматическое аварийное прекращение работы базы данных, что
является общей проблемой для транзакционных баз данных.</P>

<P>Далеко не все транзакции могут предотвращать потерю данных, если сервер
рушится. В таких случаях даже транзакционная система может терять данные.
Никакая система не 100%-но безопасна, речь идет лишь о минимизации потерь.
Даже Oracle, как сообщают, иногда теряет данные в таких ситуациях, хоть и
считается самой безопасной из транзакционных баз данных.</P>

<P>Чтобы обеспечить безопасность в MySQL, Вы должны только иметь копии и
регистрацию модификаций. С этим Вы можете восстановить фактически любое
повреждение базы данных.</P>

<P>Транзакционная парадигма имеет выгоды и недостатки. Много пользователей и
разработчиков прикладных программ зависят от легкости, с которой они могут
обойти проблемы, где аварийное прекращение работы появляется или необходимо,
и им, вероятно, придется делать немного больше работы с MySQL, чтобы думать
по-другому или писать больше. Если Вы плохо знакомы с атомной парадигмой
операций или более знакомы с транзакциями, не считайте, что MySQL не знаком с
этими проблемами. Надежность и целостность у авторов этого пакета стоят на
первом месте! Недавние оценки указывают, что имеется больше, чем 1000000
серверов <CODE>mysqld</CODE>, многие из которых находятся в промышленных
средах. Очень редко можно услышать от пользователей, что они потеряли данные,
и почти во всех случаях виноваты были сами пользователи. Это самое лучшее
доказательство стабильности и надежности MySQL.</P>

<P>Наконец, в ситуациях, где целостность имеет самую высокую важность,
текущие свойства MySQL учитывают уровень транзакции или лучшую надежность и
целостность. Если Вы блокируете таблицы с помощью <CODE>LOCK TABLES</CODE>,
все модификации остановятся, пока любые проверки целостности не будут
сделаны. Если Вы только получаете блокировку чтения (в противоположность
блокировке записи), то чтение и вставки продолжают работать. Новые
вставленные записи не будут замечены клиентами, имеющими блокировку
<CODE>READ</CODE>, пока они не освободят их блокировки чтения. С помощью
<CODE>INSERT DELAYED</CODE> Вы можете поместить вставки в локальную очередь,
где они останутся до тех пор, пока блокировки не будут освобождены. Таким
образом, сервер не будет иметь пользователя, который ждет завершения вставки.
</P>

<P>"Атомная" означает, что Вы можете убедиться в том, что в то время как
каждая специфическая модификация выполняется, никакой другой пользователь не
может сталкиваться с ней, и никакой автоматической обратной перемотки не
будет никогда (хотя это может случаться на транзакционных системах, если Вы
не очень осторожны). MySQL также гарантирует, что не будет иметься лишних
чтений. Вы можете найти пример того, как писать атомные модификации в разделе
"<A HREF="#Commit-rollback">1.2.6 Как справиться без
<CODE>COMMIT</CODE>/<CODE>ROLLBACK</CODE></A>".</P>

<P>Использование атомной парадигмы позволяет применять много оптимизаций
быстродействия, которые иначе не будут возможны. К тому же, при грамотном
подходе такая схема ускорит работу в 3-5 раз по сравнению с лучшими
транзакционными базами данных при той же надежности.</P>

<P>Для тех случаев, где безопасность более важна, чем быстродействие, я
советую применять транзакционные таблицы типов <CODE>BDB</CODE> или
<CODE>InnoDB</CODE> для всех критических данных.

<P>Одно заключительное примечание: в настоящее время авторы пакета работают
над безопасной схемой репликации, которая должна быть лучше, чем любая
известная на сегодняшний день поддержка репликации. Эта система будет
работать наиболее надежно при атомных операциях, а не транзакциях.</P>

<H4><A NAME="Missing_Triggers">1.2.4.4 Хранимые процедуры и триггеры</A></H4>
<P>Хранимая процедура представляет собой набор команд SQL, который может
компилироваться и храниться на сервере. Как только это было выполнено, клиент
не должен хранить весь запрос, а может обратиться к сохраненной процедуре.
Это обеспечивает лучшую эффективность потому, что запрос должен
анализироваться только однажды, и меньшее количество информации должно быть
послано между клиентом и сервером. Вы можете также поднимать концептуальный
уровень при наличии библиотек функций.</P>

<P>Триггер представляет собой сохраненную процедуру, которая вызывается,
когда специфическое событие происходит. Например, Вы можете устанавливать
сохраненную процедуру, которая будет вызвана каждый раз, когда запись удалена
из таблицы transaction. Эта процедура автоматически удаляет соответствующего
заказчика из таблицы customer, когда все его транзакции удалены.</P>

<P>Запланированный язык модификаций будет способен обработать сохраненные
процедуры, но без триггеров. Триггеры обычно замедляют все, даже запросы, к
которым не имеют отношения.</P>

<H4><A NAME="Missing_Foreign_Keys">1.2.4.5 Внешние ключи</A></H4>
<P>Обратите внимание, что внешние ключи в SQL не используются, чтобы
соединить таблицы, но используются обычно для проверки справочной
целостности. Если Вы хотите получить результат из нескольких таблиц командой
<CODE>SELECT</CODE>, Вы делаете это, соединяя таблицы так:</P>
<PRE>
SELECT * from table1,table2 where table1.id = table2.id;
</PRE>

<P>Синтаксис <CODE>FOREIGN KEY</CODE> в MySQL существует только для
совместимости с другими версиями SQL-команды <CODE>CREATE TABLE</CODE>, это
не делает ничего. Синтаксис <CODE>FOREIGN KEY</CODE> без <CODE>ON DELETE ...
</CODE> обычно используется для документационных целей. Некоторые прикладные
программы стандарта ODBC могут использовать это, чтобы произвести
автоматические предложения <CODE>WHERE</CODE>, но это обычно просто, чтобы
перекрыть. <CODE>FOREIGN KEY</CODE> иногда используется как проверка
ограничения, но эта проверка практически не нужна, если строки вставлены в
таблицы в правильном порядке. MySQL поддерживает эти предложения только
потому, что некоторые прикладные программы требуют, чтобы они существовали
(независимо от того, работают они или нет).</P>

<P>В MySQL Вы можете обойти проблему неработающей конструкции
<CODE>ON DELETE ...</CODE> добавляя соответствующую инструкцию
<CODE>DELETE</CODE> к прикладной программе, когда Вы удаляете записи из
таблицы, которая имеет внешний ключ. Практически это иногда быстрее и намного
более переносимо, чем использование внешних ключей в таблице.</P>

<P>В ближайшем будущем мы расширим реализацию <CODE>FOREIGN KEY</CODE> так,
чтобы по крайней мере информация была сохранена в файле спецификации таблицы
и могла быть получена <CODE>mysqldump</CODE> и ODBC. На более поздней стадии
мы выполним ограничения внешних ключей для прикладной программы, которая не
может легко быть перекодирована, чтобы избежать их.</P>

<H4><A NAME="Broken_Foreign_KEY">1.2.4.6 Почему не реализована поддержка
для Foreign Keys</A></H4>
<P>Много ученых по теории базы данных и программистов чувствуют, что
справочная целостность должна быть предписана внутри сервера базы данных.
Действительно, во многих случаях этот подход очень полезен. Однако, в
разговоре со многими пользователями баз данных авторы наблюдали, что внешние
ключи часто неправильно используются, что может вызывать серьезные проблемы.
Даже когда все используется правильно, это не волшебное решение для проблемы
справочной целостности, хотя это делает все проще в некоторых случаях.</P>

<P>Из-за вышеупомянутых наблюдений авторы не назначали реализации внешних
ключей высокий приоритет. Однако, в последние годы ядро пользователей
расширилось, и теперь авторы пакета имеют много пользователей, кто хотел бы
иметь предписанную поддержку справочной целостности внутри MySQL. Так что в
ближайшем будущем внешние ключи все-таки будут реализованы.</P>

<P>Некоторые преимущества применения внешних ключей:</P>
<UL><LI>При принятии соответствующего проекта отношений, ограничения внешних
ключей сделают более трудным для программиста и пользователя создание
несогласованности в базе данных.
<LI>Использование каскадируемых модификаций и удалений может упростить код
программ пользовательского уровня.
<LI>Правильно разработанный внешний ключ управляет помощью в документации
отношений между таблицами.</UL>

<P>Противопоказания:</P>
<UL><LI>MySQL еще не поддерживает предписанную справочную целостность, так
что если Ваша прикладная программа зависит от этого, Вы не сможете применить
MySQL до реализации этого свойства.
<LI>Ошибки, которые являются простыми в проектировании отношений ключей,
могут вызывать серьезные проблемы, например, круговые правила или
неправильная комбинация каскадирования удалений.
<LI>Правильно написанная прикладная программа сама удостоверится, что не
нарушает ограничения целостности прежде, чем начнет обработку запроса. Таким
образом, добавочные проверки на уровне базы данных только замедлят
эффективность для такой прикладной программы.</UL>

<H4><A NAME="Missing_Views">1.2.4.7 Views</A></H4>
<P>MySQL не поддерживает views, но это планируется исправить примерно к 4.1.
</P>

<P>Views обычно полезны для разрешения пользователям обращаться к набору
отношений как к одной таблице (в режиме только для чтения). Многие базы
данных SQL не позволяют модифицировать любые строки в таком представлении:
Вы должны делать все модификации в отдельных таблицах.</P>

<P>MySQL обычно используется в прикладных программах и на web-системах, где
автор прикладной программы имеет полное управление над применением базы
данных. По этой причине views не сочтены очень важными.</P>

<P>Чтобы ограничить доступ к столбцам в MySQL views тоже не требуются: MySQL
имеет очень сложную систему предоставления привилегий. Подробности в разделе
"<A HREF="privileg.htm#Privilege_system">4.2 Общие проблемы защиты и система
привилегий доступа MySQL</A>".</P>

<H4><A NAME="Missing_comments">1.2.4.8
<SAMP>`--'</SAMP> как начало комментария</A></H4>
<P>Некоторые базы данных SQL применяют <SAMP>--</SAMP> как начало
комментария. MySQL имеет <SAMP>#</SAMP> как символ начала комментария, даже
если инструмент командной строки <CODE>mysql</CODE> удаляет все строки,
начинающиеся с <SAMP>--</SAMP>. Вы можете также использовать стиль
комментариев языка C (<CODE>/* это комментарий */</CODE>) в MySQL.</P>

<P>MySQL Version 3.23.3 и выше поддерживает стиль комментариев
<SAMP>--</SAMP>, только если комментарий сопровождается пробелом. Это потому,
что стиль комментария вызвал много проблем с автоматически сгенерированными
запросами SQL, которые использовали нечто вроде следующего кода, где мы
автоматически вставляем значение payment вместо <CODE>!payment!</CODE>:</P>
<PRE>
UPDATE tbl_name SET credit=credit-!payment!
</PRE>

<P>Как Вы думаете, что случится, когда значение <CODE>payment</CODE>
отрицательное? А вот что. Поскольку <CODE>1--1</CODE> допустимо в SQL, пакет
думает, что начался комментарий типа <SAMP>--</SAMP>. Вряд ли это
входит в Ваши планы...</P>

<P>В MySQL Version 3.23 Вы можете использовать:
<CODE>1-- Это был комментарий</CODE></P>

<P>Следующее обсуждение касается Вас, только если Вы управляете MySQL
Version 3.23 или ранее:</P>

<P>Если Вы имеете программу SQL в текстовом файле, который содержит
комментарии <SAMP>--</SAMP>, Вы должны использовать:</P>
<PRE>
shell&#62; replace " --" " #" &#60; text-file-with-funny-comments.sql \
                   | mysql database
</PRE>

<P>Вместо обычного решения:</P>
<PRE>
shell&#62; mysql database &#60; text-file-with-funny-comments.sql
</PRE>

<P>Вы можете также редактировать командный файл, чтобы сменить комментарии
<SAMP>--</SAMP> на <SAMP>#</SAMP>:</P>
<PRE>
shell&#62; replace " --" " #" -- text-file-with-funny-comments.sql
</PRE>

<P>Замените их обратно этой командой:</P>
<PRE>
shell&#62; replace " #" " --" -- text-file-with-funny-comments.sql
</PRE>

<H3><A NAME="Standards">1.2.5 Каким стандартам соответствует MySQL?</A></H3>
<P>Entry level SQL92. ODBC levels 0-2.</P>

<H3><A NAME="Commit-rollback">1.2.6
Как обойтись без <CODE>COMMIT</CODE>/<CODE>ROLLBACK</CODE></A></H3>
<P>Следующее обычно применяется только для таблиц <CODE>ISAM</CODE>,
<CODE>MyISAM</CODE> и <CODE>HEAP</CODE>. Если Вы используете только
транзакционно-безопасные таблицы (<CODE>BDB</CODE> или <CODE>InnoDB</CODE>) в
модификации, Вы можете также делать
<CODE>COMMIT</CODE> и <CODE>ROLLBACK</CODE> в MySQL.</P>

<P>Проблема с эффективной обработкой
<CODE>COMMIT</CODE>-<CODE>ROLLBACK</CODE> с вышеупомянутыми типами таблиц
требует полностью иного размещения таблицы, чем используемое MySQL сегодня.
Тип таблицы также нуждался бы в дополнительных потоках, которые вели бы
автоматические очистки на таблицах, да и использование дисков было бы намного
выше. Это сделало бы эти типы таблицы приблизительно в 2-4 медленнее, чем
они есть сейчас.</P>

<P>Текущей проблемой является <CODE>ROLLBACK</CODE>. Без
<CODE>ROLLBACK</CODE> Вы можете делать любой вид <CODE>COMMIT</CODE> с
помощью <CODE>LOCK TABLES</CODE>. Для поддержки <CODE>ROLLBACK</CODE> с
вышеупомянутыми типами таблицы MySQL должен быть изменен так, чтобы сохранять
все старые записи, которые модифицировались, и иметь возможность быстро
вернуться к отправной точке, если была выдана команда <CODE>ROLLBACK</CODE>.
Для простых случаев это довольно просто (можно приспособить сюда
<CODE>isamlog</CODE>), но будет намного трудней выполнить
<CODE>ROLLBACK</CODE> для <CODE>ALTER/DROP/CREATE TABLE</CODE>.</P>

<P>Чтобы избежать использования <CODE>ROLLBACK</CODE>, Вы можете использовать
следующую стратегию действий:</P>
<OL><LI>Примените <CODE>LOCK TABLES ...</CODE>, чтобы блокировать все
таблицы, к которым Вы хотите обращаться.
<LI>Проверьте все условия.
<LI>Модифицируйте, если все в порядке.
<LI>Вызовите команду <CODE>UNLOCK TABLES</CODE>, чтобы снять блокировки.</OL>

<P>Это обычно намного более быстрый метод, чем использование транзакций с
возможностью <CODE>ROLLBACK</CODE>, хотя и не всегда. Единственная ситуация,
которую это решение не обрабатывает, состоит в том, что кто-то уничтожает
поток в середине модификации. В этом случае все блокировки будут сняты, но
некоторые из модификаций, возможно, не будут выполнены.</P>

<P>Вы можете также использовать функции, чтобы модифицировать записи в
одиночной операции. Вы можете получать очень эффективную прикладную
программу, применяя следующие методы:</P>
<UL><LI>Измените поля относительно их текущего значения.
<LI>Модифицируйте только те поля, которые фактически изменились.</UL>

<P>Например, когда мы делаем модификации некоторой информации заказчика, мы
модифицируем только данные заказчика, которые изменились, и проверяем, что ни
один из измененных данных или других данных, которые зависят от измененных
данных, не изменился по сравнению с первоначальной строкой. Тест для
измененных данных выполнен с предложением <CODE>WHERE</CODE> в инструкции
<CODE>UPDATE</CODE>. Если запись не модифицировалась, мы даем пользователю
сообщение о том, что некоторые из данных, которые Вы изменили, были изменены
другим пользователем. Затем мы показываем старую строку против новой строки в
окне, так что пользователь может решать, которую версию записи заказчика он
должен будет использовать.</P>

<P>Это дает нам нечто, что является подобным блокировке столбца, но
фактически это даже лучше потому, что мы модифицируем только некоторые из
столбцов, используя значения, которые вычислены относительно их текущих
значений. Это означает, что типичные инструкции <CODE>UPDATE</CODE> выглядят
примерно таким образом:</P>
<PRE>
UPDATE tablename SET pay_back=pay_back+'relative change';
UPDATE customer SET customer_date='current_date',
                    address='new address', phone='new phone',
                    money_he_owes_us=money_he_owes_us+'new_money'
       WHERE customer_id=id AND address='old address' AND phone='old phone';
</PRE>

<P>Как Вы можете видеть, это очень эффективно и работает, даже если другой
пользователь изменил значения столбцов <CODE>pay_back</CODE> или
<CODE>money_he_owes_us</CODE>.</P>

<P><A NAME="IDX160"></A><A NAME="IDX161"></A>Во многих случаях пользователи
хотели использовать <CODE>ROLLBACK</CODE> и/или <CODE>LOCK TABLES</CODE> с
целью управления уникальными идентификаторами для некоторых таблиц. Это может
быть обработано намного более эффективно, используя столбец
<CODE>AUTO_INCREMENT</CODE> и функцию SQL <CODE>LAST_INSERT_ID()</CODE> или
функцию C API <CODE>mysql_insert_id()</CODE>.</P>

<P><A NAME="IDX162"></A>В MySQL AB авторы пакета никогда не имели никакой
потребности в блокировке уровня строки потому, что всегда могли ее обойти.
Некоторые случаи и в самом деле нуждаются в блокировке строки, но они очень
немногочисленны. Если Вы хотите иметь блокировку уровня строки, Вы можете
использовать столбец флажка в таблице и делать нечто вроде:</P>
<PRE>
UPDATE tbl_name SET row_flag=1 WHERE id=ID;
</PRE>

<P>MySQL вернет для числа обработанных строк, если строка была найдена, и
<CODE>row_flag</CODE> не был 1 в первоначальной строке.</P>

<H3><A NAME="Bugs">1.2.7 Известные ошибки и проблемы</A></H3>
<P>Перечисленные ниже проблемы известны авторам пакета, и их устранение имеет
очень высокий приоритет.</P>

<UL><LI><CODE>ANALYZE TABLE</CODE> на таблицах BDB может в некоторых случаях
делать таблицу непригодной, пока Вы не перезапустите <CODE>mysqld</CODE>.
Когда это выполнено, Вы будете видеть ошибки подобные следующим в файле
регистрации ошибок MySQL:
<PRE>
001207 22:07:56 bdb: log_flush: LSN past current end-of-log
</PRE>

<LI>Не выполняйте <CODE>ALTER TABLE</CODE> на таблице <CODE>BDB</CODE>, на
которой Вы управляете незавершенными многооператорными транзакциями.
Транзакция будет, вероятно, игнорироваться.
<LI><CODE>ANALYZE TABLE</CODE>, <CODE>OPTIMIZE TABLE</CODE> и <CODE>REPAIR
TABLE</CODE> могут вызывать проблемы на таблицах, для которых Вы используете
вызов <CODE>INSERT DELAYED</CODE>.
<LI>Выполнение <CODE>LOCK TABLE ...</CODE> и <CODE>FLUSH TABLES ...</CODE>
еще не гарантирует, что не имеется наполовину выполненной транзакции.
<LI>Таблицы BDB не спешат открываться. Если Вы имеете много BDB-таблиц в
базе данных, потребуется длительное время, чтобы использовать клиент
<CODE>mysql</CODE> на этой базе данных, если Вы не используете опцию
<CODE>-A</CODE> или применяете <CODE>rehash</CODE>. Это особенно важно, когда
Вы имеете большой кэш таблицы.
<LI>Текущий протокол репликации не может иметь дело с <CODE>LOAD DATA
INFILE</CODE> и выравнивать символы признака конца строки, которые сами
занимают больше, чем 1 символ.</UL>

<P>Следующие проблемы известны и будут устранены в назначенное время:</P>
<UL><LI><CODE>MATCH</CODE> работает только с инструкциями
<CODE>SELECT</CODE>.
<LI>При использовании <CODE>SET CHARACTER SET</CODE> не могут быть применены
транслируемые символы в базе данных, таблице и столбцах.
<LI><CODE>DELETE FROM merge_table</CODE>, используемый без
<CODE>WHERE</CODE>, только очистит отображение для таблицы, не удаляя ничего
в самих отображенных таблицах.
<LI>Вы не можете формировать пакет в другом каталоге при использовании
MIT-pthreads, поскольку это требует правки кода MIT-pthreads, мы вряд ли это
свойство будем исправлять.
<LI>Значения <CODE>BLOB</CODE> не могут надежно использоваться в <CODE>GROUP
BY</CODE>, <CODE>ORDER BY</CODE> или <CODE>DISTINCT</CODE>. Только первые
<CODE>max_sort_length</CODE> байт (по умолчанию 1024) используются при
сравнении <CODE>BLOB</CODE> в этих случаях. Это может быть изменено с помощью
опции <CODE>-O max_sort_length</CODE> при запуске <CODE>mysqld</CODE>. Обход
для большинства случаев должен использовать подстроку: <CODE>SELECT DISTINCT
LEFT(blob,2048) FROM tbl_name</CODE>.
<LI>Вычисление выполнено с <CODE>BIGINT</CODE> или <CODE>DOUBLE</CODE>
(оба обычно длиной в 64 бита). Это зависит от функции, которую обрабатывает
пакет. Общее правило: битовые функции выполнены с точностью
<CODE>BIGINT</CODE>, <CODE>IF</CODE> и <CODE>ELT()</CODE> с
<CODE>BIGINT</CODE> или <CODE>DOUBLE</CODE>, а все прочие с
<CODE>DOUBLE</CODE>. Нужно пробовать избегать использовать большие длинные
значения без знака (9223372036854775807)!
<LI>Все строковые столбцы, кроме <CODE>BLOB</CODE> и <CODE>TEXT</CODE>,
автоматически удаляют все конечные пробелы, когда сохраняются. Для типа
<CODE>CHAR</CODE> это разрешено и может быть расценено как свойство согласно
ANSI SQL92. Ошибка в том, что в MySQL столбцы <CODE>VARCHAR</CODE>
обрабатываются тем же самым путем.
<LI>Вы можете иметь только до 255 столбцов типа <CODE>ENUM</CODE> и
<CODE>SET</CODE> для каждой таблицы.
<LI><CODE>safe_mysqld</CODE> переназначает все сообщения <CODE>mysqld</CODE>
в файл регистрации <CODE>mysqld</CODE>. Одна проблема с этим состоит в том,
что, если Вы выполняете <CODE>mysqladmin refresh</CODE>, чтобы закрыть и
вновь открыть файл регистрации, <CODE>stdout</CODE> и <CODE>stderr</CODE>
все еще переназначаются к старому файлу регистрации. Если Вы используете
опцию <CODE>--log</CODE>, Вы должны редактировать <CODE>safe_mysqld</CODE>,
чтобы регистрировать данные в файле <TT>'hostname'.err</TT> вместо
<TT>'hostname'.log</TT>, чтобы у Вас не было крупных проблем с запуском и
работой с <CODE>mysqladmin refresh</CODE>.
<LI>В инструкции <CODE>UPDATE</CODE> столбцы модифицируются слева направо.
Если Вы обращаетесь к модифицируемому столбцу, Вы получите модифицируемое
значение вместо первоначального значения. Например:
<PRE>
mysql&#62; UPDATE tbl_name SET KEY=KEY+1,KEY=KEY+1;
</PRE>
Это модифицирует <CODE>KEY</CODE> с <CODE>2</CODE> вместо <CODE>1</CODE>.

<LI>Вы не можете использовать временные таблицы больше, чем однажды в том же
самом запросе. Например, следующее не будет работать:
<PRE>
select * from temporary_table, temporary_table as t2;
</PRE>

<LI><CODE>RENAME</CODE> не работает с таблицами <CODE>TEMPORARY</CODE>.
<LI>Оптимизатор может обрабатывать <CODE>DISTINCT</CODE> по-разному, если Вы
используете скрытые столбцы в объединении или нет. В объединении скрытые
столбцы рассчитаны как часть результата (даже если они не показаны) в то
время, как в нормальном запросе они не участвуют в сравнении
<CODE>DISTINCT</CODE>. Мы, вероятно, изменим это в будущем, чтобы никогда не
сравнить скрытые столбцы при выполнении <CODE>DISTINCT</CODE>. Например:
<PRE>
SELECT DISTINCT mp3id FROM band_downloads WHERE userid=9 ORDER BY id DESC;
</PRE>
и
<PRE>
SELECT DISTINCT band_downloads.mp3id, FROM band_downloads,band_mp3
       WHERE band_downloads.userid=9 AND band_mp3.id=band_downloads.mp3id
       ORDER BY band_downloads.id DESC;
</PRE>

Во втором случае Вы можете в MySQL 3.23.x получить две идентичных строки в
наборе результатов (потому, что скрытый столбец 'id' может
отличаться). Обратите внимание, что это случается только для запросов, где Вы
не имеете ORDER BY в результате, что вообще-то неправильно с точки зрения
стандарта ANSI SQL.

<LI>Поскольку MySQL позволяет Вам работать с типами таблиц, которые не
поддерживают транзакции (и таким образом не могут выполнить
<CODE>rollback</CODE>), некоторые вещи ведут себя немного иначе, чем в других
серверах SQL. Это только должно гарантировать, что MySQL никогда не должен
делать обратную перемотку для команд SQL. Это может быть иногда немного
неуклюже, поскольку значения столбца должны проверяться прикладной
программой, но это фактически даст Вам хорошее увеличение быстродействия,
поскольку это позволяет MySQL делать некоторые оптимизации, которые иначе
были бы невозможны или очень трудны. Если Вы устанавливаете столбец к
неправильному значению, MySQL будет, вместо того, чтобы делать обратную
перемотку, сохранять <CODE>самое лучшее возможное</CODE> значение в столбце.

<UL><LI>Если Вы пробуете сохранять значение вне диапазона в числовом столбце,
MySQL взамен сохранит самое маленькое или самое большое возможное значение.
<LI>Если Вы пробуете сохранять строку, которая не начинается с числа, в
числовой столбец, MySQL сохранит 0 в нем.
<LI>Если Вы пробуете сохранять <CODE>NULL</CODE>, который не берет
значения <CODE>NULL</CODE>, MySQL сохранит 0 или <CODE>''</CODE> (пустую
строку). Это поведение может, однако, быть изменено с опцией компиляции
-DDONT_USE_DEFAULT_FIELDS.
<LI>MySQL позволяет Вам сохранять некоторые неправильные значения даты в
столбцы <CODE>DATE</CODE> и <CODE>DATETIME</CODE>. Например, 2000-02-31 или
2000-02-00. Если дата полностью неправильна, MySQL сохранит в столбце
специальное значение даты 0000-00-00.
<LI>Если Вы устанавливаете <CODE>enum</CODE> к неподдерживаемому значению,
это будет установлено к значению ошибки 'empty string' с числовым значением 0.
</UL>

<LI>Если Вы выполняете <CODE>PROCEDURE</CODE> на запросе, который возвращает
пустой набор, в некоторых случаях <CODE>PROCEDURE</CODE> не будет
трансформировать столбцы.
<LI>Создание таблицы типа <CODE>MERGE</CODE> не проверяет, имеют ли основные
таблицы совместимые типы.
<LI>MySQL не может все же обрабатывать значения <CODE>NaN</CODE>,
<CODE>-Inf</CODE> и <CODE>Inf</CODE> в double. Использование их вызовет
проблемы при попытке экспортировать и импортировать данные. Вы должны как
промежуточное решение изменить <CODE>NaN</CODE> на <CODE>NULL</CODE> (если
возможно), а <CODE>-Inf</CODE> и <CODE>Inf</CODE> соответственно к
минимальному и максимальному возможным значениям <CODE>double</CODE>.
<LI><CODE>LIMIT</CODE> на отрицательных числах превращается в очень большие
положительные числа, что ошибочно.
<LI>Если Вы используете <CODE>ALTER TABLE</CODE>, чтобы сначала добавить
индекс <CODE>UNIQUE</CODE> к таблице, используемой в таблице типа
<CODE>MERGE</CODE>, и затем использовать <CODE>ALTER TABLE</CODE>, чтобы
добавить нормальный индекс уже на таблице <CODE>MERGE</CODE>, порядок ключей
будет иным для таблиц, если имелся старый не уникальный ключ в таблице. Это
потому, что <CODE>ALTER TABLE</CODE> помещает ключи <CODE>UNIQUE</CODE> перед
нормальными ключами, чтобы обнаружить двойные ключи как можно раньше.</UL>

<P>Следующее представляет известные ошибки в более ранних версиях MySQL:</P>
<UL><LI>Вы можете получать зависающий поток, если Вы делаете <CODE>DROP
TABLE</CODE> на таблице, которая является одной среди многих таблиц, которые
блокированы с помощью <CODE>LOCK TABLES</CODE>.
<LI>В следующих случаях Вы можете получать дамп ядра:
<UL><LI>Отсроченный драйвер вставки имеет ждущие обработки вставки к таблице.
<LI><CODE>LOCK table</CODE> с <CODE>WRITE</CODE>
<LI><CODE>FLUSH TABLES</CODE></UL>
<LI>До MySQL Version 3.23.2 <CODE>UPDATE</CODE>, который модифицировал ключ
с помощью <CODE>WHERE</CODE> на том же самом ключе, возможно, потерпел
неудачу потому, что та же самая строка использовалась для поиска:
<PRE>
UPDATE tbl_name SET KEY=KEY+1 WHERE KEY &#62; 100;
</PRE>

Обойти это можно так:
<PRE>
mysql&#62; UPDATE tbl_name SET KEY=KEY+1 WHERE KEY+0 &#62; 100;
</PRE>

Это будет работать потому, что MySQL не будет использовать индекс на
выражениях в предложении <CODE>WHERE</CODE>.
<LI>До MySQL Version 3.23 все числовые типы обрабатываются как поля с
фиксированной точкой. Это означает, что Вы должны были определить, сколько
десятичных чисел должно быть после запятой. Все результаты были возвращены с
правильным количеством десятичных чисел.</UL>

<P>Для изучения ошибок, специфических для конкретной платформы, изучите
разделы по компиляции и портированию.</P>

<H2><A NAME="Licensing_and_Support">1.3 Лицензирование и поддержка MySQL</A>
</H2>
<P>Этот раздел описывает поддержку MySQL и меры патентования:</P>

<UL><LI>Авторские права, под которыми распространяется MySQL, описаны в
разделе "<A HREF="#Copyright">1.3.2 Авторские права на MySQL</A>".

<LI>Типовое иллюстрирование ситуаций, когда лицензия требуется, есть в
разделе "<A HREF="#Licensing_examples">1.3.3
Примеры лицензирования</A>".

<LI>Цены на поддержку есть в разделе "<A HREF="#Cost">1.3.4
Лицензирование и платная поддержка MySQL</A>", а раздел
"<A HREF="#Support">1.3.5 Типы коммерческой поддержки</A>"
описывает разные варианты платной поддержки.</UL>

<H3><A NAME="Licensing_policy">1.3.1 Политика лицензирования MySQL</A></H3>
<P>Формальные условия лицензии GPL могут быть найдены в сети или в разделе
"<A HREF="appl4.htm#GPL_license">Приложение 4. GNU GENERAL PUBLIC LICENSE
</A>". В основном, стратегия патентования и интерпретация
GPL авторами следующие:</P>

<P>Обратите внимание, что старшие версии MySQL все еще используют более
строгую лицензию. Так что изучите соответствующую документацию по адресу
<a HREF="../../../www.mysql.com/support/arrangements/mypl.html">
http://www.mysql.com/support/arrangements/mypl.html</a>. Если Вы нуждаетесь в
коммерческой лицензии потому, что лицензия GPL не удовлетворяет Вашу
прикладную программу, Вы можете купить ее на сайте
<a HREF="../../../https@order.mysql.com/default.htm">https://order.mysql.com</a>.</P>

<P>Для нормального внутреннего использования MySQL не стоит ничего. Вы не
должны никому ничего платить за некоммерческое использование пакета.</P>

<P>Лицензия требуется если:</P>
<UL><LI>Вы компонуете программу, которая не является free software, с кодом
клиента или сервера MySQL, который имеет лицензию GPL. Это случается,
например, когда Вы используете MySQL как вложенный сервер баз данных в Ваших
прикладных программах, или когда Вы добавляете не свободные расширения в
MySQL. В этом случае Ваша прикладная программа/код также стала бы GPL через
лицензию GPL, которая действует как вирус. Покупая сервер MySQL у MySQL AB
под коммерческой лицензией Вы избежите возникновения этой проблемы.
Подробности по адресу <a HREF="../../../www.gnu.org/copyleft/gpl-faq.html">
http://www.gnu.org/copyleft/gpl-faq.html</a>.

<LI>Вы имеете коммерческую прикладную программу, которая работает ТОЛЬКО с
MySQL и продаете ее в комплекте с сервером MySQL.

<LI>Вы имеете дистрибутив MySQL, и Вы не обеспечиваете исходный текст для
Вашей копии сервера MySQL, как определено в лицензии GPL.</UL>

<P>Лицензия <STRONG>НЕ</STRONG> требуется если:</P>

<UL><LI>Вы не нуждаетесь в лицензии, чтобы включить код пользователя в
коммерческие программы. Клиентская часть MySQL лицензируется под LGPL
<CODE>GNU Library General Public License</CODE>. Клиент командной строки
<CODE>mysql</CODE> включает код из библиотеки <CODE>readline</CODE>, которая
находится под <CODE>GPL</CODE>.

<LI>Если Ваше использование MySQL не требует лицензии, но Вы находите
приятным MySQL и хотите поощрить дальнейшую разработку, купите лицензию или
хотя бы поддержку.

<LI>Если Вы используете MySQL в коммерческом контексте, который приносит
доход, то должны купить поддержку. Если Вы зарабатываете деньги на MySQL, то
будет только справедливо поделиться ими с авторами пакета.</UL>

<P>Для обстоятельств, при которых лицензия MySQL требуется, Вы нуждаетесь в
лицензии на машину, которая выполняет сервер <CODE>mysqld</CODE>. Однако,
машина с несколькими CPU считается одной машиной, и нет никаких ограничение
на число серверов MySQL, выполняемых на ней, или на число клиентов,
одновременно связанных с ней!</P>

<P>Если Вы имеете любые вопросы относительно того, требуется или нет лицензия
для Вашего специфического использования MySQL, пожалуйста, прочитайте это
снова, а затем войдите в контакт с авторами.</P>

<P>Если Вам требуется лицензия MySQL, самый простой способ купить ее состоит
в том, чтобы использовать форму лицензии на безопасном сервере MySQL по адресу
<a HREF="../../../https@order.mysql.com/default.htm">https://order.mysql.com</a>. Другие формы
оплаты обсуждены в разделе "<A HREF="#Payment_information">1.3.4.1
Информация об оплате</A>".</P>

<H3><A NAME="Copyright">1.3.2 Авторские права на MySQL</A></H3>
<P>Имеется несколько различных авторских прав на дистрибутив MySQL:</P>

<OL><LI>MySQL-специфический источник, необходимый, чтобы формировать
библиотеку <CODE>mysqlclient</CODE>, запатентован под <CODE>LGPL</CODE>, и
программы в каталоге <TT>client</TT> под GPL. Каждый файл имеет заголовок,
который показывает, которое авторское право используется для этого файла.

<LI>Библиотека пользователей и библиотека GNU <CODE>getopt</CODE> охвачены
GNU LIBRARY GENERAL PUBLIC LICENSE. Подробности в разделе
"<A HREF="appl5.htm#LGPL_license">Приложение 5. GNU LESSER
GENERAL PUBLIC LICENSE</A>".

<LI>Некоторые части исходного кода (например, библиотека <CODE>regexp</CODE>)
охвачены авторским правом Berkeley-стиля.

<LI>Все исходники сервера и библиотека GNU <CODE>readline</CODE>
лицензируются по GNU GENERAL PUBLIC LICENSE. Подробности в разделе
"<A HREF="appl4.htm#GPL_license">Приложение 4. GNU GENERAL PUBLIC LICENSE
</A>". Она также доступна как файл <TT>COPYING</TT> в дистрибутивах.</OL>

<P>Одна цель состоит в том, что библиотека пользователей SQL должна быть
достаточно свободной, чтобы возможно было добавить поддержку MySQL в
коммерческие программы без лицензии. По этой причине авторы выбрали лицензию
LGPL для кода пользователя.</P>

<P>Это означает, что Вы можете использовать пакет свободно с любо
й программой, которая применяет любую из свободных программных лицензий.
MySQL также абсолютно свободен для любого конечного пользователя для
его личного пользования.</P>

<H4><A NAME="Copyright_changes">1.3.2.1 Изменения авторского права</A></H4>
<P>MySQL Version 3.22 все еще использует более строгую лицензию. Подробности
есть в документации по ней.</P>

<H3><A NAME="Licensing_examples">1.3.3 Примеры лицензирования</A></H3>
<P>Этот раздел описывает некоторые примеры ситуаций, показывая, должны или
нет Вы лицензировать сервер MySQL.</P>

<P>Обратите внимание, что одиночная лицензия MySQL покрывает любое число CPU
и серверов <CODE>mysqld</CODE> на одной машине! Не имеется никакого
искусственного ограничения числа клиентов, которые могут работать с сервером.
</P>

<H4><A NAME="Products_that_use_MySQL">1.3.3.1
Продажа программ, использующих MySQL</A></H4>
<P>Чтобы определить, нуждаетесь или нет Вы в лицензии MySQL при продаже Вашей
прикладной программы, Вы должны спросить себя, зависит ли соответствующее
функционирование Вашей прикладной программы от использования MySQL, и
включаете ли Вы сервер MySQL в поставку программы. Имеется несколько случаев:
</P>

<UL><LI>Ваша прикладная программа требует MySQL, чтобы функционировать?
<LI>Если Ваше изделие требует MySQL, Вы нуждаетесь в лицензии для любой
машины, которая выполняет сервер <CODE>mysqld</CODE>.
<LI>Если Ваша прикладная программа не требует MySQL, Вы не должны получить
лицензию. Например, если использование MySQL только добавляет некоторые новые
факультативные свойства к программе (типа добавления регистрации в базе
данных, если MySQL используется вместо регистрации в текстовом файле), это
должно считаться нормальным использованием, и лицензия не требуется.

<LI>Другими словами, Вы нуждаетесь в лицензии, если Вы продаете программу,
разработанную именно для использования с MySQL, или она требует, чтобы сервер
MySQL работал в любом случае. Причем неважно, входит ли MySQL для Ваших
клиентов в дистрибутив программы.

<LI>Это также зависит от того, что Вы делаете для пользователя. Вы планируете
обеспечивать Вашего пользователя детализированными командами при установке
MySQL с Вашим программным обеспечением? Если да, скорее всего сервер ему
понадобится обязательно, а раз так, покупайте лицензию. Если Вы просто
связываетесь с базой данных, которую Вы ожидаете найти на системе в готовом
виде на момент покупки Вашей программы, то Вы не нуждаетесь в лицензии.</UL>

<H4><A NAME="ISP">1.3.3.2 Сервисы ISP MySQL</A></H4>
<P>Internet Service Providers (ISP) часто ставят серверы MySQL для своих
заказчиков. По лицензии GPL это не требует покупки лицензии.</P>

<P>С другой стороны, авторы поощряют использование тех ISP, которые имеют
поддержку MySQL, поскольку это даст им возможность консультироваться по
проблемам с СУБД у своего провайдера.</P>

<P>Всем таким ISP стоит подписаться на рассылку <CODE>announce</CODE>, чтобы
они могли знать фатальные проблемы, которые могут быть релевантны для их
инсталляций пакета MySQL.</P>

<P>Обратите внимание, что, если ISP не имеет лицензию для MySQL, он должен
дать заказчикам по крайней мере доступ для чтения к источнику установки MySQL
так, чтобы заказчик мог проверить, что все исправлено правильно.</P>

<H4><A NAME="Web_server">1.3.3.3 Запуск Web-сервера, использующего MySQL</A>
</H4>
<P>Если Вы используете MySQL вместе с Web-сервером под Unix, Вы не должны
покупать для этого лицензию.</P>

<P>Это верно, даже если Вы выполняете коммерческий Web-сервер, который
использует MySQL потому, что Вы не продаете вложенную версию MySQL
самостоятельно. Однако, в этом случае авторы хотели бы, чтобы Вы приобрели
поддержку MySQL потому, что пакет MySQL помогает Вашему предприятию.</P>

<H3><A NAME="Cost">1.3.4 Лицензирование и платная поддержка MySQL</A></H3>
<P>Текущие (актуальные) цены на лицензии показываются ниже. Чтобы сделать
покупку, посетите сайт <a HREF="../../../https@order.mysql.com/default.htm">
https://order.mysql.com</a>.</P>

<P>Если Вы оплачиваете кредитной карточкой, денежная единица: EURO (European
Union Euro), так что цены немного отличаются.</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Количество лицензий</STRONG></TD>
<TD><STRONG>Цена одной копии</STRONG></TD></TR>
<TR><TD>1-9</TD><TD>230 EURO</TD></TR>
<TR><TD>10-24</TD><TD>138 EURO</TD></TR>
<TR><TD>25-49</TD><TD>117 EURO</TD></TR>
<TR><TD>50-99</TD><TD>102 EURO</TD></TR>
<TR><TD>100-249</TD><TD>91 EURO</TD></TR>
<TR><TD>250-499</TD><TD>76 EURO</TD></TR>
<TR><TD>500-999</TD><TD>66 EURO</TD></TR></TABLE>

<P>Для большого объема (OEM) покупок, пожалуйста, войдите в контакт с
<a HREF="mailto:sales@mysql.com">sales@mysql.com</a>.</P>

<P>Для приобретений OEM, Вы должны действовать как посредник для возможных
проблем или запросов расширения от ваших пользователей. Авторы также требуют,
чтобы OEM-заказчики имели по крайней мере расширенный контракт поддержки
электронной почты. Обратите внимание, что лицензии OEM применимы только к
пакетам, где пользователь не имеет прямой доступ на сервер MySQL (встроенные
системы). Другими словами, сервер MySQL должен использоваться только с Вашей
прикладной программой, но не с другими.</P>

<P>Если Ваша программа должна быть дешевой, свяжитесь с разработчиками пакета
и изложите ситуацию (цены, оценки предполагаемого рынка и прочее, что имеет
отношение к вопросу). Торг уместен.</P>

<P>Полноценная лицензия не представляет собой соглашение поддержки и включает
очень маленькую поддержку. Это означает, что авторы пробуют отвечать на любые
релевантные вопросы. Если ответ находится в документации, они направят Вас к
соответствующему разделу. Если Вы не приобрели лицензию или поддержку, они,
вероятно, не будут отвечать вообще.</P>

<P>Если Вы обнаруживаете то, что рассматривается реальная ошибка, ее скорей
всего исправят в любом случае. Но если Вы оплачиваете поддержку, это ускорит
процесс исправления ошибки.</P>

<P>Более всесторонняя поддержка продается отдельно. Описание того, что
включает каждый уровень поддержки, даны в разделе
"<A HREF="#Support">1.3.5 Типы коммерческой поддержки</A>". Цены
для различных типов коммерческой поддержки показываются ниже. Цены указаны в
EURO (European Union Euro).</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Тип поддержки</STRONG></TD><TD><STRONG>Цена годовой подписки
на поддержку этого типа</STRONG></TD></TR>
<TR><TD>Базовая поддержка электронной почты</TD><TD>EURO 200</TD></TR>
<TR><TD>Расширенная поддержка электронной почты</TD><TD>EURO 1000</TD></TR>
<TR><TD>Login-поддержка</TD><TD>EURO 2000</TD></TR>
<TR><TD>Расширенная Login-поддержка</TD><TD>EURO 5000</TD></TR>
<TR><TD>Телефонная поддержка</TD><TD>EURO 12000</TD></TR></TABLE>

<P>Вы можете перейти на более высокий уровень поддержки, оплатив разницу в
цене между уровнями.</P>

<P>Авторы обеспечивают также и телефонную поддержку (обычно аварийную, но и
24/7 тоже). Эта опция поддержки не имеет фиксированную цену, а бывает
заключена в зависимости от ситуации. Если Вы заинтересованы этой опцией, Вы
можете сообщать относительно Ваших потребностей по e-mail
<a HREF="mailto:sales@mysql.com">sales@mysql.com</a>.</P>

<P>Обратите внимание, что, поскольку коммерческий штат фирмы очень занят,
может потребоваться некоторое время, пока Ваш запрос обработают.</P>

<H4><A NAME="Payment_information">1.3.4.1 Информация об оплате</A></H4>
<P>В настоящее время поддерживаются кредитные карточки, чеки или SWIFT.</P>

<P>Оплата должна быть сделана на:</P>
<PRE>
Postgirot Bank AB
105 06 STOCKHOLM, SWEDEN

MySQL AB
BOX 6434
11382 STOCKHOLM, SWEDEN

SWIFT address: PGSI SESS
Account number: 96 77 06 - 3
</PRE>

<P>Определите: лицензия и/или поддержка, Ваше имя и адрес электронной почты.
</P>

<P>В Европе и Японии Вы можете использовать платеж EuroGiro (который должен
быть менее дорог) к тому же самому счету.</P>

<P>Если Вы хотите оплачивать чеком, заполните его на ``MySQL Finland AB'' и
отправьте по почте на адрес:</P>
<PRE>
MySQL AB
BOX 6434, Torsgatan 21
11382 STOCKHOLM, SWEDEN
</PRE>

<P>Если Вы хотите оплачивать кредитной карточкой через Internet, Вы можете
использовать безопасную форму лицензии MySQL AB на
<a HREF="../../../https@order.mysql.com/default.htm">https://order.mysql.com</a>.</P>

<P>Вы можете также отпечатать копию формы лицензии, заполнить ее и отправить
по факсу на:</P>
<P>+46-8-729 69 05</P>

<P>Если Вы хотите, чтобы Вам выставили счет, Вы можете использовать форму
лицензии и написать ``bill us'' в поле комментария. Вы можете также отправить
сообщение на адрес <a HREF="mailto:sales@mysql.com">sales@mysql.com</a>
(но <STRONG>НЕ</STRONG> на <CODE>mysql@lists.mysql.com</CODE>!) с Вашей
информацией о компании и попросить, чтобы авторы выставили счет Вам.</P>

<H4><A NAME="Contact_information">1.3.4.2 Контактная информация</A></H4>
<P>Для коммерческого лицензирования, пожалуйста, войдите в контакт с группой
лицензирования MySQL. Наилучший метод для этого: послать e-mail на адрес
<a HREF="mailto:licensing@mysql.com">licensing@mysql.com</a>. Факсы также
возможны, но их обработка может занять намного большее время (факс:
+46-8-729 69 05).</P>

<P>Если Вы представляете бизнес, который заинтересован в партнерстве с
MySQL, пожалуйста, пошлите электронную почту на адрес
<a HREF="mailto:partner@mysql.com">partner@mysql.com</a>.</P>

<P>Для своевременных и точных ответов на технические вопросы относительно
MySQL Вы должны заказать один из контрактов поддержки. Поддержка MySQL
обеспечивается разработчиками MySQL, так что стандарт чрезвычайно высок.</P>

<P>Если Вы заинтересованы размещением рекламы на Web-сайте MySQL, пожалуйста,
пошлите электронную почту на адрес <a HREF="mailto:advertising@mysql.com">
advertising@mysql.com</a>.</P>

<P>Если Вы заинтересованы любой из работ, перечисленных в разделе работ
(<a HREF="../../../www.mysql.com/development/jobs">
http://www.mysql.com/development/jobs</a>), пожалуйста, пошлите электронную
почту на адрес <a HREF="mailto:jobs@mysql.com">jobs@mysql.com</a>.</P>

<P>Для общего обсуждения среди пользователей пакета, пожалуйста, направьте
сообщение в соответствующий список рассылки. Их перечень есть на
<a HREF="../../../www.mysql.com/documentation/lists.html">
http://www.mysql.com/documentation/lists.html</a>.</P>

<P>Для вопросов или комментариев относительно работ или содержания Web-сайта,
пожалуйста, пошлите электронную почту на
<a HREF="mailto:webmaster@mysql.com">webmaster@mysql.com</a>.</P>

<H3><A NAME="Support">1.3.5 Типы коммерческой поддержки</A></H3>
<P>Следующее всегда верно для всех параметров поддержки:</P>

<UL><LI>Поддержка покупается сроком на год.
<LI>Авторы устраняют любую воспроизводимую ошибку (в крайнем случае обеспечат
путь ее обхода).
<LI>Более высокий уровень поддержки подразумевает большее количество усилий,
которое авторы прилагают для поиска решений Ваших проблем.
<LI>Следующее истинно для всех контрактов поддержки за исключением базовой
поддержки электронной почты: вопросы, не относящиеся к ошибкам (оптимизация
запросов, например), оплачиваются отдельно и стоят недешево (200 EURO/час).
</UL>

<H4><A NAME="Basic_email_support">1.3.5.1 Базовая поддержка электронной почты
</A></H4>
<P>Базовая поддержка электронной почты очень недорогая опция поддержки и
вообще-то скорее способ поддержать разработчиков, чем помочь клиентам... В
значительной мере это окупает работу списков рассылки.</P>

<P>На этом уровне поддержки списки рассылки по-прежнему являются основной
коммуникацией. То есть, пишите в них о своих проблемах, выбирая
соответствующий теме список (вдруг кто-то уже эту проблему решил?). Однако,
покупая базовую поддержку электронной почты, Вы также имеете доступ к
mysql-поддержке по адресу <a HREF="mailto:mysql-support@mysql.com">
mysql-support@mysql.com</a>, который не доступен как часть минимальной
поддержки, которую Вы получаете, просто покупая лицензию MySQL. Это означает,
что для особенно критических вопросов, Вы можете послать сообщение на
<a HREF="mailto:mysql-support@mysql.com">mysql-support@mysql.com</a>. Если
сообщение содержит чувствительные данные, Вы должны писать только на
<a HREF="mailto:mysql-support@mysql.com">mysql-support@mysql.com</a>.</P>

<P><STRONG>ПОМНИТЕ!</STRONG> ВСЕГДА включайте Ваш код регистрации и дату
окончания, когда Вы посылаете сообщение на
<a HREF="mailto:mysql-support@mysql.com">mysql-support@mysql.com</a>.</P>

<P>Обратите внимание, что, если Вы столкнулись с критической воспроизводимой
ошибкой, и, согласно правилам, отослали сообщение о ней на
<a HREF="mailto:bugs@lists.mysql.com">bugs@lists.mysql.com</a>, разработчики
будут пробовать исправить ее как можно скорее, независимо от Вашего уровня
поддержки! Подробности в разделе "<A HREF="#Bug_reports">1.4.1 Как
сообщать об ошибках и проблемах</A>".</P>

<P>Базовая поддержка электронной почты включает следующие типы обслуживания:
</P>

<UL><LI>Если на Ваш вопрос уже ответили в руководстве, Вам сообщат
правильный раздел, в котором Вы можете найти ответ. Если ответ не в
руководстве, Вам сообщат, где Вы можете ответ найти сами.

<LI>Авторы гарантируют своевременный ответ для Ваших сообщений электронной
почты. Они не могут гарантировать, что решат любую проблему, но по крайней
мере Вы получите ответ.

<LI>Авторы помогут с непредвиденными проблемами, когда Вы устанавливаете
MySQL из двоичного дистрибутива на поддержанных платформах. Этот уровень
поддержки не покрывает установку MySQL из исходников. Поддержанные платформы,
для которых MySQL, как известно, работает, перечислены в разделе
"<A HREF="install.htm#Which_OS">2.2.2 ОС, поддерживаемые MySQL</A>".

<LI>Авторы помогут с ошибками и отсутствующими свойствами. Любые ошибки,
которые найдены, будут исправлены для следующего выпуска MySQL. Если ошибка
критическая для Вас, по электронной почте Вы получите патч, как только он
будет сделан. Критические ошибки всегда имеют самый высокий приоритет, и
разработчики гарантируют, что они будут исправлены как можно скорее.

<LI>Ваши предложения для дальнейшей разработки MySQL будут учтены, но не как
самые важные. Купив e-mail-поддержку, Вы тем самым уже немного помогли
дальнейшей разработке MySQL. Если Вы хотите иметь больше сведений, перейдите
к более высокому уровню поддержки.</UL>

<H4><A NAME="Extended_email_support">1.3.5.2
Расширенная поддержка электронной почты</A></H4>
<P>Расширенная поддержка электронной почты включает все из базовой поддержки
электронной почты с этими добавлениями:</P>

<UL><LI>С Вашей электронной почтой будут иметь дело прежде, чем с почтой с
уровня базовой поддержки.

<LI>Ваши предложения для дальнейшей разработки MySQL получат сильное
рассмотрение. Простые расширения, которые удовлетворяют базисные цели MySQL,
будут выполнены в течение нескольких дней. Купив расширенную поддержку
электронной почты, Вы уже помогли дальнейшей разработке MySQL.

<LI>Типичные ситуации, покрытые расширенной поддержкой электронной почты:

<UL><LI>Авторы отвечают и (в рамках вопроса) решают вопросы, которые касаются
возможных ошибок в MySQL. Как только ошибка найдена и исправлена, Вам пришлют
заплатку для нее.

<LI>Авторы помогают с непредвиденными проблемами, когда Вы устанавливаете
MySQL из исходного или двоичного дистрибутива на поддержанных платформах.

<LI>Авторы отвечают на вопросы относительно отсутствия свойств, а также
предлагают решения, как обойти проблему.

<LI>Предлагаются советы при оптимизации работы <CODE>mysqld</CODE> (и
запросов) для Вашей конкретной ситуации.</UL>

<LI>Вам позволяют влиять на приоритет элементов списка MySQL TODO. Это
гарантирует, что свойства, в которых Вы в самом деле нуждаетесь, будут
выполнены скорее, чем они могли бы быть выполнены в иных случаях.</UL>

<H4><A NAME="Login_support">1.3.5.3 Login-поддержка</A></H4>
<P>Login-поддержка включает все, что входит в расширенную поддержку
электронной почты, но с добавлениями, которые перечислены ниже:</P>

<UL><LI>С вашей электронной почтой будут иметь дело даже прежде, чем с
обращениями пользователей расширенной поддержки электронной почты.

<LI>Ваши предложения для дальнейшей разработки MySQL будут приниматься с
очень пристальным вниманием. Расширения, которые могут быть выполнены за
несколько часов, и в общем соответствуют базисным целям MySQL, будут
выполнены как можно скорее.

<LI>Если Вы имеете очень специфическую проблему, возможна связь авторов
прямо с Вашей системой, чтобы решить проблему на месте.

<LI>Конечно, как и любой производитель СУБД, разработчики пакета не могут
гарантировать, что смогут спасти любые данные из разрушенных таблиц, но они
помогут Вам в максимально возможной степени. MySQL доказал себя очень
надежной системой, но что-нибудь всегда возможно из-за обстоятельств вне
контроля авторов пакета.

<LI>Обеспечиваются советы при оптимизации Вашей системы и запросов.

<LI>Вам позволяют связываться (через модератора) с разработчиками и обсуждать
Ваши проблемы с MySQL. Эта опция должна, однако, использоваться только как
последний шанс после того, как не удалось устранить проблему по e-mail. Чтобы
сделать эффективное использование времени, авторы должны сначала получить все
факты относительно проблемы перед разговором по телефону, чтобы работать
настолько эффективно, насколько это вообще возможно при решении проблемы.
</UL>

<H4><A NAME="Extended_login_support">1.3.5.4 Расширенная Login-поддержка</A>
</H4>
<P>Расширенная Login-поддержка включает все из предыдущего типа поддержки, но
уже с этими добавлениями:</P>

<UL><LI>Ваша электронная почта имеет самый высокий возможный приоритет.

<LI>Авторы активно исследуют Вашу систему и помогут Вам оптимизировать ее и
Ваши запросы. Они могут также оптимизировать и/или расширить MySQL, чтобы
лучше удовлетворить Ваши потребности.

<LI>Вы можете также запрашивать специальные расширения только для Вас.
Например:
<PRE>
mysql&#62; select MY_FUNC(col1,col2) from table;
</PRE>

<LI>Авторы будут обеспечивать двоичный дистрибутив всех важных выпусков MySQL
персонально для Вашей системы, пока им будет предоставлен shell-доступ к
подобной системе. В крайнем случае предоставьте доступ к Вашей системе.

<LI>Если Вы можете обеспечивать размещение и дорожные расходы, Вы можете даже
вызвать кого-то из разработчиков пакета к себе для решения проблем.
Расширенная поддержка позволяет один такой визит в год, но авторы пакета
всегда очень гибко относятся к заказчикам! Если посещение занимает 16 часов
или больше, первые 8 часов бесплатны. За остальное время Вы будете обязаны
заплатить в соответствии с тарифом, который является по крайней мере на 20%
меньше, чем наши стандартные тарифы.</UL>

<H4><A NAME="Telephone_support">1.3.5.5 Телефонная поддержка</A></H4>
<P>Телефонная поддержка как обычно включает весь предыдущий уровень
поддержки, но еще и с этими добавлениями:</P>

<UL><LI>Авторы будут обеспечивать Вас динамической web-страницей, показывая
текущий список разработчиков <CODE>MySQL</CODE>, которым Вы можете звонить,
когда Вы имеете критическую проблему.

<LI>Для некритических проблем Вы можете запрашивать разработчика
<CODE>MySQL</CODE>, чтобы перезвонить в течение 48 часов, чтобы обсудить
возникшую проблему с пакетом.</UL>

<H4><A NAME="Table_handler_support">1.3.5.6
Поддержка для других драйверов таблицы</A></H4>
<P>Чтобы получить поддержку для таблиц типов <CODE>BDB</CODE> и
<CODE>InnoDB</CODE> Вы должны оплатить дополнительно по 30% от стандартной
цены поддержки за каждый из драйверов таблицы, для которых Вы хотели
бы иметь поддержку.</P>

<P>В <CODE>MySQL AB</CODE> помогут Вам создать соответствующий отчет ошибки
для драйвера таблицы и представить его на рассмотрение разработчикам
специфического драйвера таблицы. Авторы пакета будут также стараться
гарантировать, что Вы получите своевременный ответ или решение от
разработчиков драйвера таблицы.</P>

<P>Имейте в виду, что разработчики самого пакета не несут ответственности за
разработчиков дополнительных драйверов. Несмотря на то, что они, само собой,
приложат все усилия к решению проблемы, не гарантируется, что оно будет
найдено очень быстро.</P>

<H4>1.4 Выяснение вопросов или сообщение об ошибках в пакете</H4>
<P>Перед отправкой отчета об ошибке или вопроса сделайте следующее:</P>

<UL><LI>Начните с поисков в руководстве по MySQL. Самая свежая версия (увы,
только на английском языке) есть по адресу:
<BR>http://www.mysql.com/documentation/manual.php.

<LI>Ищите также в архиве списков рассылки по MySQL:
http://www.mysql.com/documentation.

<LI>Вы можете также использовать http://www.mysql.com/search.html для поиска
по всем страницам на http://www.mysql.com.</UL>

<P>Если Вы не можете найти ответ в руководстве или архиве,
проконсультируйтесь с Вашим локальным экспертом MySQL. Если Вы все еще не
можете найти ответ на Ваш вопрос, читайте следующий раздел относительно того,
как послать запрос на mysql@lists.mysql.com.</P>

<H4><A NAME="Bug_reports">1.4.1 Как сообщать об ошибках и проблемах</A></H4>
<P>Написание хорошего отчета об ошибке требует немало терпения, но при
выполнении этого экономится много времени Вам и всем окружающим. Хороший
отчет об ошибке, содержащий полный случай теста для ошибки, делает весьма
вероятным скорейшее исправление проблемы. Этот раздел поможет Вам написать
Ваш отчет так, чтобы Вы не тратили впустую Ваше время, выполняя действия,
которые не могут ничем помочь.</P>

<P>Пользуйтесь скриптом <CODE>mysqlbug</CODE>, чтобы генерировать отчет об
ошибке (или отчет относительно любой проблемы), если возможно. Сам
<CODE>mysqlbug</CODE> может быть найден в каталоге <TT>scripts</TT> в
дистрибутиве исходного кода или (для двоичного дистрибутива) в каталоге
<TT>bin</TT> под Вашим каталогом установки MySQL. Если Вы не можете
использовать <CODE>mysqlbug</CODE>, Вы должны все же включать всю необходимую
информацию, перечисленную в этом разделе.</P>

<P>Скрипт <CODE>mysqlbug</CODE> помогает Вам сгенерировать отчет, определяя
многое из следующей информации автоматически, но если кое-что важное
отсутствует, пожалуйста, включите это в Ваше сообщение! Пожалуйста, читайте
этот раздел тщательно и удостоверьтесь, что вся информация, описанная здесь,
включена в Ваш отчет.</P>

<P>Нормальное место, чтобы сообщить ошибки и проблемы:
mysql@lists.mysql.com. Если Вы
можете создать случай теста, который ясно показывает ошибку, Вы должны его
послать на bugs@lists.mysql.com.
Обратите внимание, что в этом списке Вы должны только регистрировать полный
повторимый отчет ошибки, использующий скрипт <CODE>mysqlbug</CODE>. Если Вы
работаете под Windows, Вы должны включить описание операционной системы и
версии MySQL. Предпочтительно, Вы должны проверить проблему при использовании
последнего устойчивого дистрибутива или версии для разработчика. Любой должен
быть способен повторить ошибку, используя только <CODE>mysql test&#60;script
</CODE> на включенном случае теста или выполнить скрипт, который включен в
отчет ошибки. Все ошибки, зарегистрированные в списке <CODE>bugs</CODE>,
будут исправлены или зарегистрированы в следующем выпуске MySQL! Если имеются
только маленькие изменения кода, в этом списке может быть опубликован патч.
</P>

<P>Не забудьте, что можно ответить на сообщение, содержащее слишком много
информации, но не на то, в котором полезных данных очень мало. Часто люди
опускают факты потому, что они думают, что они знают причину проблемы и
считают, что некоторые важнейшие детали не имеют значения. Хороший принцип:
если Вы находитесь в сомнении относительно установления чего-либо,
устанавливайте это! Это намного ускорит и упростит работу всем остальным.</P>

<P>Наиболее общие ошибки состоят в том, что люди не указывают номер версии
MySQL или ОС (включая ее версию!), на которой работают. Это очень важная
информация, и в 99 случаях из 100 отчет об ошибке без нее бесполезен! Часто
спрашивают об ошибках, которые есть в старых версиях, но их уже нет в новых.
Обновляйте софт, меньше будет проблем! Иногда ошибка платформно-зависимая, в
таких ситуациях почти невозможно установить что-нибудь без того, чтобы знать
операционную систему и номер версии платформы.</P>

<P>Не забудьте также обеспечивать информацию относительно Вашего компилятора,
если это связано с проблемой. Часто люди находят ошибки в компиляторах и
считают, что это проблемы MySQL. Большинство компиляторов вечно находятся в
состоянии разработки и совершенствования. Чтобы определить, зависит или нет
Ваша проблема от компилятора, авторы должны знать, какой именно компилятор
используется. Обратите внимание, что каждая проблема компиляции должна быть
расценена как отчет об ошибке и сообщена соответственно.</P>

<P>Самые лучшие отчеты такие, которые включают полный пример, показывающий
как воспроизвести ошибку или проблему. Подробности в разделе
"6.1.6 Создание случая теста, когда Вы испытываете искажение таблицы".</P>

<P>Если программа производит сообщение об ошибках, очень важно включить
сообщение в Ваш отчет! Если мы пробуем искать данные из архива, используя
сведения по этой программе лучше, чтобы присланное сообщение об ошибках точно
соответствовало тому, которое программа производит. Вы никогда не должны
пробовать запомнить то, что было в сообщении об ошибке, вместо этого
скопируйте и вставьте сообщение в Ваш отчет!</P>

<P>Пожалуйста, не забудьте, что многие из тех, кто будет читать Ваш отчет,
применяют монитор в режиме с 80 символами в строке. Следовательно, при
изготовлении отчетов и примеров с использованием клиента <CODE>mysql</CODE>
Вы должны использовать опцию <CODE>--vertical</CODE> (или завершать команду
комбинацией символов <CODE>\G</CODE>) для вывода, который не превысит
доступную ширину для такого дисплея (например, инструкция <CODE>EXPLAIN
SELECT</CODE>, подробности ниже).</P>

<P>Пожалуйста, включите следующую информацию в Ваш отчет:</P>

<UL><LI>Версия дистрибутива MySQL (например, MySQL Version 3.22.22).
Вы можете выяснить, которой версией пользуетесь, командой <CODE>mysqladmin
version</CODE>. <CODE>mysqladmin</CODE> может быть найден в каталоге
<TT>bin</TT> под каталогом установок MySQL.

<LI>Изготовитель и модель машины, на которой Вы работаете.

<LI>Имя операционной системы и версия. Для большинства операционных систем,
Вы можете получить эту информацию, выполняя Unix-команду
<CODE>uname -a</CODE>.

<LI>Иногда объем памяти (реальной и виртуальной) релевантен. Если
сомневаетесь, включите эти значения.

<LI>Если Вы используете исходники MySQL, нужны имя и версия компилятора. Если
Вы имеете двоичный дистрибутив, необходимо его имя. Если проблема происходит
в течение трансляции, включите точное сообщение об ошибках, а также несколько
строк контекста кода из файла, где ошибка произошла.

<LI>Если <CODE>mysqld</CODE> рухнул, Вы должны также сообщить запрос, который
потерпел крах. Вы можете обычно найти его, запуская <CODE>mysqld</CODE> с
включеным протоколированием. Подробности в разделе
"6.1.5 Использование журналов, чтобы найти причину ошибок в mysqld".

<LI>Если любая таблица базы данных связана с проблемой, включите вывод из
<CODE>mysqldump --no-data db_name tbl_name1 tbl_name2 ...</CODE>. Это очень
простой и мощный способ получить информацию относительно любой таблицы в базе
данных, которая поможет создать ситуацию, соответствующую той, что у Вас.

<LI>Для связанных с быстродействием ошибок или проблем с инструкциями
<CODE>SELECT</CODE> Вы должны всегда включать вывод
<CODE>EXPLAIN SELECT ...</CODE> и по крайней мере число строк, которые
производит инструкция <CODE>SELECT</CODE>. Большее количество информации,
которую Вы даете относительно Вашей ситуации, делает более вероятным, что
кто-то сможет помочь Вам! Например, следующее представляет собой пример очень
хорошо составленного отчета об ошибке (это должно быть, конечно, создано с
помощью скрипта <CODE>mysqlbug</CODE>). Обратите внимание на использование
признака конца оператора <CODE>\G</CODE> для инструкций, чья ширина вывода
иначе превысила бы 80 символов:
<PRE>
mysql&#62; SHOW VARIABLES;
mysql&#62; SHOW COLUMNS FROM ...\G
     &#60; Вывод SHOW COLUMNS&#62;
mysql&#62; EXPLAIN SELECT ...\G
     &#60; Вывод EXPLAIN&#62;
mysql&#62; FLUSH STATUS;
mysql&#62; SELECT ...;
     &#60; Короткая версия вывода из SELECT, включая время, затраченное
           на обработку запроса&#62;
mysql&#62; SHOW STATUS;
     &#60; Вывод SHOW STATUS&#62;
</PRE>

<LI>Если ошибка или проблема происходит при работе <STRONG>mysqld</STRONG>,
попробуйте сделать скрипт, который воспроизведет аномалию. Этот скрипт
должен включить любые необходимые исходные файлы. Если у Вас получается
сделать такой пример, который точно воспроизводит ошибку при минимальных
усилиях со стороны изучающего, направьте его на
bugs@lists.mysql.com для
приоритетной обработки ситуации! Если Вы не можете обеспечить готовый скрипт,
Вы должны по крайней мере включить вывод <CODE>mysqladmin variables
extended-status processlist</CODE>, чтобы обеспечить некоторую информацию о
раболте Вашей системы.

<LI>Если Вы не можете изготовить случай теста в нескольких строках, или если
таблица теста слишком большая, чтобы быть отправленной по почте в список
рассылки (больше, чем 10 строк), Вы должны сделать дамп Вашей таблицы,
используя <CODE>mysqldump</CODE>, и создать файл <TT>README</TT>, который
описывает Вашу проблему. Создайте сжатый архив Ваших файлов, используя
<CODE>tar</CODE> и <CODE>gzip</CODE> (или <CODE>zip</CODE>), и передайте его
по <CODE>ftp</CODE> на
ftp://support.mysql.com/pub/mysql/secret</a>. Затем пошлите короткое описание
проблемы на bugs@lists.mysql.com</a>.

<LI>Если Вы думаете, что MySQL производит странный результат, включите не
только сам результат, но также и Ваше мнение, каким он должен быть, а также
основание для Вашего мнения.

<LI>При предоставлении примера проблемы, лучше использовать имена переменных,
таблицы и т.д., которые существуют в Вашей фактической ситуации, чем
придумывать новые. Проблема может быть связана с именем переменной или
таблицы. Эти случаи редки, возможно, но лучше подстраховаться. В конце
концов это должно быть проще для Вас, чтобы обеспечить пример, который
использует Вашу фактическую ситуацию. В случае если Вы имеете данные, которые
Вы не хотите показывать другим, Вы можете передать их по <CODE>ftp</CODE> на
ftp://support.mysql.com/pub/mysql/secret. Если данные совершенно
секретны, используйте другие имена, но это крайние меры.

<LI>Включите все параметры, данные релевантным программам, если возможно.
Например, укажите параметры, которые Вы используете, когда запускаете
<CODE>mysqld</CODE>, и что Вы используете, чтобы выполнить любые программы
клиента MySQL. Параметры к программам <CODE>mysqld</CODE> и
<CODE>mysql</CODE>, а также скрипту <CODE>configure</CODE>, часто являются
ключами к решениям и очень нужны. Во всяком случае включить их не помешает.
Если Вы используете любые модули, типа Perl или PHP, пожалуйста, включите
также номера их версий.

<LI>Если Ваш вопрос связан с системой привилегии, пожалуйста, включите вывод
<CODE>mysqlaccess</CODE>, <CODE>mysqladmin reload</CODE> и все сообщения об
ошибках, которые Вы получили при попытке подключить! Когда Вы проверяете Ваши
привилегии, Вы должны сначала выполнить <CODE>mysqlaccess</CODE>. После этого
выполните <CODE>mysqladmin reload version</CODE> и попробуйте соединиться с
программой, которая создает проблему. Команда <CODE>mysqlaccess</CODE> есть в
каталоге <TT>bin</TT> под каталогом установки MySQL.

<LI>Если Вы имеете заплату для ошибки, которая является хорошей, пришлите ее
авторам в комплекте со случаем теста, иллюстрирующим применение заплаты.
Помните, что без детального описания и тестового примера, разработчики могут
и не понять назначение заплатки, а следовательно, и не будут ее применять.
Покажите, что заплата обработает все ситуации, которые могут возникнуть.

<LI>Присылайте предположения касательно причин ошибки. Без таких
предположений сложно с первой попытки понять, какой именно кусок кода надо
отлаживать и изучать. К тому же, описание причин упрощает отладку.

<LI>Если Вы получаете ошибку синтаксического анализа (<CODE>parse
error</CODE>), пожалуйста, проверьте Ваш синтаксис очень тщательно! Если Вы
не можете найти что-то неправильное в нем, чрезвычайно вероятно, что Ваша
текущая версия MySQL просто не поддерживает запрос, который Вы используете.
Если Вы применяете самую свежую версию, и руководство на
http://www.mysql.com/documentation/manual.php не покрывает синтаксис,
который Вы применили, значит MySQL не поддерживает Ваш запрос. Если
руководство покрывает синтаксис, который Вы используете, но Вы имеете старую
версию MySQL, Вы должны проверить хронологию изменения MySQL, чтобы увидеть,
когда синтаксис был реализован. В этом случае следует обновить версию.

<LI>Если проблема разрушает данные в таблицах, или Вы получаете ошибки, когда
обращаетесь к некоторой специфической таблице, Вы должны сначала проверить и
пробовать восстановить Ваши таблицы с помощью <CODE>myisamchk</CODE> или
<CODE>CHECK TABLE</CODE> и <CODE>REPAIR TABLE</CODE>.

<LI>Если Вы часто получаете разрушенные таблицы, Вы должны пробовать
выяснить, когда и почему это случается! В этом случае файл
<TT>mysql-data-directory/'hostname'.err</TT> может содержать некоторую
информацию относительно того, что случалось. Пожалуйста, включите любую
релевантную информацию из этого файла в Ваш отчет об ошибке. Как правило,
<CODE>mysqld</CODE> <STRONG>никогда</STRONG> не должен разрушить таблицу,
если ничто не уничтожило его посреди модификации. Если Вы можете найти
причину слета <CODE>mysqld</CODE>, это сильно облегчит работу.

<LI>Если возможно, загрузите и поставьте самую современную версию MySQL и
проверьте, не решило ли это проблему. Все версии MySQL полностью проверены и
должны бы работать без проблем! В пакете поддерживается обратная
совместимость, так что переход на новую версию займет несколько минут.</UL>

<P>Направьте отчет на адрес соответствующей рассылки. Может
кто-то еще испытал (и возможно решил) такую проблему. Если Вы подписаны на
поддержку, пишите на mysql-support@mysql.com.</P>

<P>Когда ответы посланы Вам индивидуально, а не списку рассылки, считается
хорошим тоном суммировать ответы и послать резюме в список рассылки, чтобы
все могли с ним ознакомиться и решить свои проблемы.</P>

<H4>1.4.3 Руководящие принципы ответов на вопросы в списках рассылки</A></H4>
<P>Если Вы полагаете, что Ваш ответ представляет широкий интерес, Вы можете
отправить его в список рассылки вместо того, чтобы ответить лично
индивидууму, который Вас спросил. Пожалуйста, удостоверьтесь, что Ваш ответ
не дублирует другой.</P>

<P>Попробуйте суммировать существенную часть вопроса в Вашем ответе, не надо
цитировать все первоначальное сообщение. Пожалуйста, не отправляйте сообщения
почты из Вашего браузера с включенным режимом HTML! Много пользователей не
читают почту в браузере.</P>

<H2><A NAME="Comparisons">1.5 MySQL в сравнении с другим базами данных</A>
</H2>
<P>Этот раздел сравнивает MySQL с другими популярными базами данных.</P>

<P>Этот раздел первоначально был написан разработчиками MySQL. Не имеется
никаких фактических ошибок, содержащихся в этом разделе, о которых я бы знал.
Если Вы находите что-то неправильное, свяжитесь с авторами пакета по e-mail
<a HREF="mailto:docs@mysql.com">docs@mysql.com</a>.</P>

<P>Перечень всех поддержанных ограничений, функций и типов есть на
<CODE>crash-me</CODE> Web page по адресу
<a HREF="../../../www.mysql.com/information/crash-me.php">
http://www.mysql.com/information/crash-me.php</a>.</P>

<H3><A NAME="Compare_mSQL">1.5.1 MySQL в сравнении с <CODE>mSQL</CODE></A>
</H3>
<DL COMPACT>
<DT><STRONG>Производительность</STRONG>
<DD>Для истинного сравнения быстродействия, консультируйтесь с пакетом MySQL
benchmark suite. Подробности в разделе
"<A HREF="glava05.htm#MySQL_Benchmarks">5.1.4 Набор тестов MySQL Benchmark
Suite</A>". Поскольку нет создания потоков и маленького синтаксического
анализатора, зато есть упрощенная защита и немного возможностей, пакет
<CODE>mSQL</CODE> должен быть более быстрым в следующих случаях:

<UL><LI>Тесты, которые выполняют повторные подключения, работая с очень
простым запросом в течение каждого подключения.

<LI>Операции <CODE>INSERT</CODE> в очень простые таблицы с немногими
столбцами и ключами.

<LI><CODE>CREATE TABLE</CODE> и <CODE>DROP TABLE</CODE>.

<LI><CODE>SELECT</CODE> на чем-то, что не является индексом (просмотр таблицы
очень прост).</UL>

С другой стороны, MySQL намного быстрее, чем <CODE>mSQL</CODE> (и большинство
других реализаций SQL) на следующем:

<UL><LI>Сложные запросы <CODE>SELECT</CODE>.
<LI>Получение больших результатов (MySQL имеет более быстрый и безопасный
протокол обмена данными).
<LI>Таблицы со строками переменной длины потому, что MySQL имеет более
эффективную обработку и может иметь индексы на столбцах <CODE>VARCHAR</CODE>.
<LI>Обработка таблиц с многими столбцами.
<LI>Обработка таблиц с большими длинами записи.
<LI><CODE>SELECT</CODE> с многими выражениями.
<LI><CODE>SELECT</CODE> на больших таблицах.
<LI>Обработка многих подключений в то же самое время. MySQL полностью
многопоточный. Каждое подключение имеет собственный поток, что означает, что
никакой поток не должен ждать другой (если поток не изменяет таблицу, к
которой другой поток хочет обращаться). В <CODE>mSQL</CODE> как только одно
подключение установлено, другие должны ждать его завершения независимо от
того, управляет ли подключение запросом, который является коротким или
длинным. Когда первое подключение завершается, следующее может обслуживаться.

<LI>Объединения. Пакет <CODE>mSQL</CODE> может стать патологически медленным,
если Вы изменяете таблицу в <CODE>SELECT</CODE>. В эталонном наборе тестов
время выполнения порой отличалось в 15000 раз! Это из-за недостатка
оптимизатора объединения <CODE>mSQL</CODE>, который не может упорядочить
таблицы в оптимальном порядке. Однако, если Вы помещаете таблицы точно в
правильном порядке <CODE>mSQL</CODE>, а предложение <CODE>WHERE</CODE>
простое и использует индексные столбцы, объединение будет относительно
быстрым! Подробности в разделе "<A HREF="glava05.htm#MySQL_Benchmarks">5.1.4
Набор тестов MySQL Benchmark Suite</A>".

<LI><CODE>ORDER BY</CODE> и <CODE>GROUP BY</CODE>.
<LI><CODE>DISTINCT</CODE>.
<LI>Использование столбцов типов <CODE>TEXT</CODE> и <CODE>BLOB</CODE>.</UL>

<DT><STRONG>Возможности SQL</STRONG>
<DD><UL><LI><CODE>GROUP BY</CODE> и <CODE>HAVING</CODE>.
<CODE>mSQL</CODE> не поддерживает <CODE>GROUP BY</CODE> вообще. MySQL
поддерживает полную версию <CODE>GROUP BY</CODE> с <CODE>HAVING</CODE> и
следующими функциями: <CODE>COUNT()</CODE>, <CODE>AVG()</CODE>,
<CODE>MIN()</CODE>, <CODE>MAX()</CODE>, <CODE>SUM()</CODE> и
<CODE>STD()</CODE>. <CODE>COUNT(*)</CODE> оптимизирован, чтобы возвратить
данные очень быстро, если <CODE>SELECT</CODE> получает данные из одной
таблицы, никакие другие столбцы не получены, и не имеется никакого
предложения <CODE>WHERE</CODE>. <CODE>MIN()</CODE> and <CODE>MAX()</CODE>
могут брать параметры-строки.

<LI><CODE>INSERT</CODE> и <CODE>UPDATE</CODE> с вычислениями в фоновом
режиме. MySQL может делать вычисления в вызовах <CODE>INSERT</CODE> или
<CODE>UPDATE</CODE>. Например:
<PRE>
mysql&#62; UPDATE SET x=x*10+y WHERE x&#60;20;
</PRE>

<LI>Псевдонимы. MySQL имеет псевдонимы для имени столбца.
<LI>Автоматическое дополнение спецификаций имен столбца. В MySQL, если имя
столбца уникально среди таблиц, используемых в запросе, Вы не должны
использовать полный спецификатор.
<LI><CODE>SELECT</CODE> с функциями. MySQL имеет много функций (слишком
много, чтобы перечислить их здесь.</UL>

<DT><STRONG>Использование диска</STRONG>
<DD>Насколько маленькими Вы можете делать Ваши таблицы? MySQL имеет очень
точные типы, так что Вы можете создавать таблицы, которые требуют минимум
места. Пример полезного типа в MySQL: <CODE>MEDIUMINT</CODE>, который имеет
длину в 3 байта. Если Вы имеете 100000000 записей, экономия даже одного байта
на запись принципиальна. <CODE>mSQL2</CODE> имеет более ограниченный набор
типов столбца, так что труднее получить маленькие таблицы.

<DT><STRONG>Стабильность</STRONG>
<DD>Сложно судить объективно. Вот что пишут авторы MySQL: мы не имеем
никакого опыта со стабильностью <CODE>mSQL</CODE>, так что мы не можем
говорить что-нибудь относительно этого.

<DT><STRONG>Цена</STRONG>
<DD>Другая важная проблема: лицензия. MySQL имеет более гибкую лицензию, чем
<CODE>mSQL</CODE>, а также менее дорог, чем <CODE>mSQL</CODE>.

<DT><STRONG>Интерфейс с языком Perl</STRONG>
<DD>MySQL имеет в основном те же самые интерфейсы к Perl, что и
<CODE>mSQL</CODE>, но с некоторыми добавленными свойствами.

<DT><STRONG>JDBC (Java)</STRONG>
<DD>MySQL в настоящее время имеет много различных JDBC-драйверов:
<UL><LI>Драйвер mm: type 4 JDBC (автор Mark Matthews,
<a HREF="mailto:mmatthew@ecn.purdue.edu">mmatthew@ecn.purdue.edu</a>).
Распространяется по LGPL.

<LI>Драйвер Resin. Это коммерческий драйвер JDBC, распространяемый как
open source (<a HREF="../../../www.caucho.com/projects/jdbc-mysql/index.xtp">
http://www.caucho.com/projects/jdbc-mysql/index.xtp</a>).

<LI>Драйвер gwe: Java-интерфейс, разработанный GWE technologies (в настоящее
время не поддерживается).

<LI>Драйвер jms: улучшенный вариант gwe (автор Xiaokun Kelvin ZHU,
<a HREF="mailto:X.Zhu@brad.ac.uk">X.Zhu@brad.ac.uk</a>). В настоящее
время не поддерживается.

<LI>Драйвер twz: type 4 JDBC (автор Terrence W. Zellers,
<a HREF="mailto:zellert@voicenet.com">zellert@voicenet.com</a>).
Коммерческий, но свободен для частного и образовательного использования. В
настоящее время не поддерживается.
</UL>

Рекомендуемый драйвер: mm. Resin также хорош (по крайней мере просмотры
эталонных тестов хороши), но о нем маловато сведений. Я знаю, что
<CODE>mSQL</CODE> имеет JDBC-драйвер, но дел с ним имел мало, сравнивать их
трудно из-за отсутствия данных.

<DT><STRONG>Порядок разработки</STRONG>
<DD>MySQL имеет очень маленькую группу разработчиков, но они хорошо знают C и
C++. Поскольку потоки, функции, <CODE>GROUP BY</CODE> и прочее пока не
реализованы в <CODE>mSQL</CODE>, его разработчикам придется еще немало
поработать головой. Чтобы получить некоторую перспективу, Вы можете
просматривать файл <TT>HISTORY</TT> в <CODE>mSQL</CODE> за последний год и
сравнивать это с разделом News в MySQL Reference Manual. Должно быть довольно
очевидно, что развивается наиболее быстро.

<DT><STRONG>Утилиты</STRONG>
<DD><CODE>mSQL</CODE> и MySQL имеют много интересных инструментальных средств
от третьего лица. Поскольку портирование из <CODE>mSQL</CODE> в MySQL легко,
почти все интересные прикладные программы, которые являются доступными для
<CODE>mSQL</CODE>, также доступны для MySQL. MySQL приходит с простой
программой <CODE>msql2mysql</CODE>, которая устанавливает различия в проверке
правописания между <CODE>mSQL</CODE> и MySQL для используемых функций C API.
Например, это изменяет образцы <CODE>msqlConnect()</CODE> на
<CODE>mysql_connect()</CODE>. Преобразование программы пользователя с
<CODE>mSQL</CODE> в MySQL обычно занимает несколько минут.</DL>

<H4><A NAME="Using_mSQL_tools">1.5.1.1 Как конвертировать инструментальные
средства <CODE>mSQL</CODE> для MySQL</A></H4>
<P>Согласно опыту, требуется только несколько часов, чтобы преобразовать
инструментальные средства, типа <CODE>msql-tcl</CODE> и
<CODE>msqljava</CODE>, которые используют <CODE>mSQL</CODE> C API так, чтобы
они работали с MySQL C API.</P>

<P>Процедура преобразования:</P>
<OL><LI>Выполните скрипт оболочки <CODE>msql2mysql</CODE> на исходниках. Это
требует программы <CODE>replace</CODE>, которая поставляется с MySQL.
<LI>Откомпилируйте результат.
<LI>Исправьте ошибки компиляции.</OL>

<P>Различия между <CODE>mSQL</CODE> C API и MySQL C API:</P>
<UL><LI>MySQL применяет структуру <CODE>MYSQL</CODE> как тип подключения
(<CODE>mSQL</CODE> использует <CODE>int</CODE>).

<LI><CODE>mysql_connect()</CODE> берет указатель на структуру
<CODE>MYSQL</CODE> как параметр. Просто определите его глобально или
используйте <CODE>malloc()</CODE>. <CODE>mysql_connect()</CODE> также берет
два параметра для определения пользователя и пароля. Вы можете устанавливать
их к <CODE>NULL, NULL</CODE> для заданного по умолчанию использования.

<LI><CODE>mysql_error()</CODE> берет указатель на структуру
<CODE>MYSQL</CODE> как параметр. Только добавьте параметр для Вашего старого
кода <CODE>msql_error()</CODE>, если Вы переносите старый код.

<LI>MySQL возвращает код ошибки и текстовое сообщение об ошибках для всех
ошибок. <CODE>mSQL</CODE> возвращает только текстовое сообщение об ошибках.

<LI>Некоторые несовместимости существуют в результате многократных
подключений к серверу MySQL из того же самого процесса.</UL>

<H4><A NAME="Protocol_differences">1.5.1.2 Чем отличаются протоколы
<CODE>mSQL</CODE> и MySQL клиент/сервер</A></H4>
<P>Имеется достаточно различий, из-за которых невозможно (или по крайней мере
непросто) поддерживать оба.</P>

<P>Наиболее значительные вещи, которыми протокол MySQL отличается от
<CODE>mSQL</CODE>, перечислены ниже:</P>

<UL><LI>Буфер сообщений может содержать много строк результатов.
<LI>Буфера сообщений динамически будут расширены, если запрос или результат
больше, чем текущий (актуальный) буфер.
<LI>Все пакеты пронумерованы, чтобы отследить дублированные или отсутствующие
пакеты, а также хакеров.
<LI>Все значения столбца представлены в ASCII. Длины столбцов и строк
представлены в упакованном двоичном виде (1, 2 или 3 байта).
<LI>MySQL может работать с небуферизованными результатами (без того, чтобы
иметь необходимость сохранять полный набор данных на клиенте).
<LI>Если одиночное чтение или запись берет больше, чем 30 секунд, сервер
закрывает такое подключение.
<LI>Если подключение бездействует в течение 8 часов, сервер его закрывает.
</UL>

<H4><A NAME="Syntax_differences">1.5.1.3 Чем синтаксис <CODE>mSQL</CODE> 2.0
SQL отличается от MySQL</A></H4>
<P><STRONG>Типы столбцов:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Имеет следующие дополнительные типы:
<UL><LI><CODE>ENUM</CODE>: тип для одного значения из набора строк.
<LI><CODE>SET</CODE>: тип для многих значений из набора строк.
<LI><CODE>BIGINT</CODE>: тип для 64-разрядных целых чисел.</UL>

<DT><CODE></CODE>
<DD>MySQL также поддерживает следующие дополнительные атрибуты для типов:
<UL><LI>Опция <CODE>UNSIGNED</CODE> для целочисленных столбцов.
<LI>Опция <CODE>ZEROFILL</CODE> для целочисленных столбцов.
<LI>Опция <CODE>AUTO_INCREMENT</CODE> для целочисленных столбцов, которые
являются <CODE>PRIMARY KEY</CODE>.
<LI>Значение <CODE>DEFAULT</CODE> для всех столбцов.</UL>

<DT><CODE>mSQL2</CODE>
<DD>Типы столбцов <CODE>mSQL</CODE> соответствуют типам столбцов MySQL,
показанным в таблице ниже:

<TABLE BORDER WIDTH="100%">
<TR><TD>Тип в <CODE>mSQL</CODE><STRONG></STRONG></TD><TD><STRONG>Тип в MySQL
</STRONG></TD></TR>
<TR><TD><CODE>CHAR(len)</CODE></TD><TD><CODE>CHAR(len)</CODE></TD></TR>
<TR><TD><CODE>TEXT(len)</CODE></TD><TD><CODE>TEXT(len)</CODE>.
<CODE>len</CODE> максимальная длина. <CODE>LIKE</CODE> работает.</TD></TR>
<TR><TD><CODE>INT</CODE></TD><TD><CODE>INT</CODE>. С намного большим числом
параметров!</TD></TR>
<TR><TD><CODE>REAL</CODE></TD><TD><CODE>REAL</CODE>. Или <CODE>FLOAT</CODE>.
Доступны версии с 4 или 8 байтами.</TD></TR>
<TR><TD><CODE>UINT</CODE></TD><TD><CODE>INT UNSIGNED</CODE></TD></TR>
<TR><TD><CODE>DATE</CODE></TD><TD><CODE>DATE</CODE>. Использует формат ANSI
SQL, а не собственный формат <CODE>mSQL</CODE>.</TD></TR>
<TR><TD><CODE>TIME</CODE></TD><TD><CODE>TIME</CODE></TD></TR>
<TR><TD><CODE>MONEY</CODE></TD><TD><CODE>DECIMAL(12,2)</CODE>. Значение с
десятичной фиксированной точкой и двумя целыми числами.</TD></TR></TABLE>
</DL>

<P><STRONG>Создание индексов:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Индексы могут быть определены при создании таблицы инструкцией
<CODE>CREATE TABLE</CODE>.

<DT><CODE>mSQL</CODE>
<DD>Индексы должны быть созданы после того, как таблица была создана
отдельными инструкциями <CODE>CREATE INDEX</CODE>.</DL>

<P><STRONG>Чтобы вставить уникальный идентификатор в таблицу:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Используйте <CODE>AUTO_INCREMENT</CODE> как спецификатор типа столбца.

<DT><CODE>mSQL</CODE>
<DD>Создайте <CODE>SEQUENCE</CODE> на таблице и выберите столбец
<CODE>_seq</CODE>.</DL>

<P><STRONG>Чтобы получить уникальный идентификатор строки:</STRONG></P>

<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Добавьте ключ <CODE>PRIMARY KEY</CODE> или <CODE>UNIQUE</CODE> к таблице
и используйте его. Нововведение в Version 3.23.11: если <CODE>PRIMARY</CODE>
или <CODE>UNIQUE</CODE> состоит только из одного столбца, и это имеет тип
integer, можно также обратиться к нему как к <CODE>_rowid</CODE>.

<DT><CODE>mSQL</CODE>
<DD>Используйте столбец <CODE>_rowid</CODE>. Заметьте, что
<CODE>_rowid</CODE> может изменяться через какое-то время в зависимости
от многих факторов.</DL>

<P><STRONG>Чтобы получить время, когда столбец был в последний раз изменен:
</STRONG></P>

<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Добавьте столбец <CODE>TIMESTAMP</CODE> к таблице. Этот столбец будет
автоматически установлен к текущей (актуальной) дате и времени для инструкций
<CODE>INSERT</CODE> или <CODE>UPDATE</CODE>, если Вы не задаете столбцу
значение, или если Вы задаете ему значение <CODE>NULL</CODE>.

<DT><CODE>mSQL</CODE>
<DD>Используйте столбец <CODE>_timestamp</CODE>.</DL>

<P><STRONG>Сравнения значений <CODE>NULL</CODE>:</STRONG></P>

<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>MySQL следует стандарту ANSI SQL, и сравнение с <CODE>NULL</CODE> всегда
вернет <CODE>NULL</CODE>.

<DT><CODE>mSQL</CODE>
<DD>В <CODE>mSQL</CODE>, <CODE>NULL=NULL</CODE> вернет TRUE. Вы должны
изменить <CODE>=NULL</CODE> на <CODE>IS NULL</CODE> и
<CODE>&#60;&#62;NULL</CODE> на <CODE>IS NOT NULL</CODE> при переносе старого
кода с <CODE>mSQL</CODE> на MySQL.</DL>

<P><STRONG>Сравнение строк:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Обычно, сравнения выполняются без учета регистра символов с применением
порядка сортировки, определенным текущим (актуальным) набором символов
(по умолчанию ISO-8859-1 Latin1). Если Вас это не устраивает, объявите Ваши
столбцы с атрибутом <CODE>BINARY</CODE>, который заставляет сравнения быть
выполненными согласно порядку ASCII, используемому на сервере MySQL.

<DT><CODE>mSQL</CODE>
<DD>Все сравнения выполняются с учетом регистра. Сортировка строго по ASCII.
</DL>

<P><STRONG>Нечувствительный к регистру поиск:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD><CODE>LIKE</CODE> в зависимости от включаемых столбцов может быть как
чувствительным к регистру, так и нет. Если возможно, MySQL использует
индексы, если параметр <CODE>LIKE</CODE> не начинается с группового символа.

<DT><CODE>mSQL</CODE>
<DD>Используйте оператор <CODE>CLIKE</CODE>.</DL>

<P><STRONG>Обработка конечных пробелов:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Удаляет все пробелы в конце столбцов <CODE>CHAR</CODE> и
<CODE>VARCHAR</CODE>. Если это поведение нежелательно, используйте столбцы
типа <CODE>TEXT</CODE>, там пробелы остаются на месте.

<DT><CODE>mSQL</CODE>
<DD>Сохраняет конечные пробелы.</DL>

<P><STRONG>Предложение <CODE>WHERE</CODE>:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>MySQL правильно располагает по приоритетам все (<CODE>AND</CODE> будет
оценен перед <CODE>OR</CODE>). Чтобы получить поведение <CODE>mSQL</CODE> в
MySQL, используйте круглые скобки (как показано в примере ниже).

<DT><CODE>mSQL</CODE>
<DD>Оценивает все слева направо. Это означает, что некоторые логические
вычисления более, чем с тремя параметрами не могут быть выражены никогда. Это
также означает, что Вы должны изменить некоторые запросы, когда Вы мигрируете
на MySQL. Это можно сделать легко, добавляя круглые скобки. Предположим, что
Вы имеете следующий запрос <CODE>mSQL</CODE>:
<PRE>
mysql&#62; SELECT * FROM table WHERE a=1 AND b=2 OR a=3 AND b=4;
</PRE>

Чтобы MySQL рассматривал его по методике, принятой в <CODE>mSQL</CODE>,
Вы должны добавить скобок:
<PRE>
mysql&#62; SELECT * FROM table WHERE (a=1 AND (b=2 OR (a=3 AND (b=4))));
</PRE></DL>

<P><STRONG>Контроль доступа:</STRONG></P>
<DL COMPACT>
<DT><CODE>MySQL</CODE>
<DD>Имеет таблицы, чтобы сохранить предоставление параметры (разрешения) на
пользователя, компьютер и базу данных.

<DT><CODE>mSQL</CODE>
<DD>Имеет файл <TT>mSQL.acl</TT>, в котором Вы можете предоставлять
привилегии чтения-записи для пользователей.</DL>

<H3><A NAME="Compare_PostgreSQL">1.5.2 MySQL в сравнении с PostgreSQL</A>
</H3>
<P>При чтении следующего материала, пожалуйста, обратите внимание на то, что
обе программы непрерывно развиваются и совершенствуются.</P>

<P>Следующее сравнение сделано в MySQL AB. Авторы старались быть максимально
точными, но поскольку они знают MySQL вдоль и поперек, а вот PostgreSQL
известен несколько хуже, некоторые вещи могли быть оценены не совсем верно.
</P>

<P>MySQL и PostgreSQL представляют собой широко используемые программы, но с
различными целями проекта, даже при том, что они стараются поддерживать
совместимость с ANSI SQL. Это означает, что для некоторых прикладных программ
больше подходит MySQL, в то время как для других лучше все же PostgreSQL. При
выборе Вы должны сначала проверить, удовлетворяет ли набор свойств базы
данных вашу прикладную программу. Если Вы нуждаетесь в необработанном
быстродействии, MySQL, вероятно, Ваш самый лучший выбор. Если Вы нуждаетесь в
некоторых из дополнительных свойств, которые только PostgreSQL может
предложить, значит нужен <CODE>PostgreSQL</CODE>.</P>

<H4><A NAME="MySQL-PostgreSQL_goals">1.5.2.1
Стратегии разработки MySQL и PostgreSQL</A></H4>
<P>При добавлении свойств к MySQL авторы стремятся сделать оптимальное,
определенное решение. Код должен быть настолько хорош, чтобы не возникала
потребность менять его в обозримом будущем. Авторы также не считают, что
стоит жертвовать быстродействием ради свойств, но будут делать все возможное,
чтобы найти такое решение, которое даст максимальную производительность. Это
означает, что разработка идет медленнее, но конечный результат будет этого
стоить. Этот вид разработки возможен только потому, что весь код сервера
проверен одним или несколькими (в настоящее время двумя) авторами прежде, чем
будет включен в сервер MySQL.</P>

<P>В MySQL AB считается, что частые выпуски могут предоставить новые свойства
пользователям быстро. Из-за этого новый маленький выпуск появляется раз в три
недели. Все выпуски проверены инструментальными средствами тестирования на
большом количестве различных платформ.</P>

<P>PostgreSQL основан на ядре с большим количеством вкладчиков. Здесь имеет
смысл располагать по приоритетам добавление новых свойств, вместо того, чтобы
выполнить их оптимально потому, что можно всегда оптимизировать все, что надо
позже, если возникнет потребность в этом.</P>

<P>Другое большое различие между MySQL и PostgreSQL: почти весь код в MySQL
кодирован разработчиками, которые наняты MySQL AB. Исключительные ситуации:
транзакции и библиотека regexp. Это находится в остром контрасте с
PostgreSQL, где большинство кода написано большой группой людей.</P>

<P>Оба вышеупомянутых метода разработки имеют собственные преимущества и
недостатки. В MySQL AB считают, что их модель лучше потому, что она дает
лучшую непротиворечивость кода, более оптимальный и переносимый код, а также
меньшее количество ошибок.</P>

<H4><A NAME="MySQL-PostgreSQL_features">1.5.2.2
Сравнение возможностей MySQL и PostgreSQL</A></H4>
<P>На странице <a HREF="../../../www.mysql.com/information/crash-me.php">
crash-me</a> Вы можете найти список тех конструкций базы данных и
ограничений, которые можно обнаружить автоматически программой. Обратите
внимание, однако, что многие числовые ограничения могут быть изменены с
параметрами запуска для соответствующей базы данных. Вышеупомянутая
web-страница является чрезвычайно полезной, когда Вы хотите гарантировать,
что Ваши прикладные программы работают с различными базами данных, или когда
Вы хотите перенести Вашу прикладную программу из одной СУБД в другую.</P>

<P>MySQL предлагает следующие преимущества перед PostgreSQL:</P>
<UL><LI><CODE>MySQL</CODE> вообще намного быстрее, чем PostgreSQL.
<LI>MySQL больше ориентирован на пользователя. Исторически сложилось так, что
клиенты более стабильны, чем у PostgreSQL. MySQL намного больше использован в
промышленных средах, чем PostgreSQL, обычно благодаря тому, что MySQL AB (а
ранее TCX DataKonsult AB) обеспечил поддержку высшего качества для MySQL со
дня первого выпуска пакета, в то время как до недавнего времени PostgreSQL
был неподдерживаемым вообще.

<LI>MySQL работает лучше под Windows, чем PostgreSQL. MySQL выполняется как
местная прикладная программа (сервис системы под NT/Win2000/WinXP), а вот
PostgreSQL выполнен при помощи эмулятора cygwin. Бытует мнение, что
PostgreSQL под Windows не так устройчив, но утверждать что-либо определенное
тут пока рано.

<LI>MySQL имеет большее количество API к языкам и поддержан большим
количеством существующих программ, чем PostgreSQL.

<LI>MySQL работает на тяжелых системах 24/7. В большинстве обстоятельств Вы
никогда не должны выполнить никакие очистки на MySQL. PostgreSQL все же не
поддерживает системы 24/7 потому, что Вы должны выполнить
<CODE>VACUUM()</CODE> время от времени, чтобы восстановить место после команд
<CODE>UPDATE</CODE> и <CODE>DELETE</CODE> и выполнять анализ статистики,
который является критическим, чтобы получить хорошую эффективность
PostgreSQL. <CODE>VACUUM()</CODE> также необходим после добавления многих
новых строк к таблице. На занятой системе с большим количеством изменений,
<CODE>VACUUM()</CODE> должен быть выполнен очень часто, в самых плохих
случаях даже много раз в день. В течение работы <CODE>VACUUM()</CODE>,
который может занять часы, если база данных большая, никто ничего с базой
данных сделать не может. Группа разработки PostgreSQL имеет намерение
исправить это безобразие, но это будет не так-то просто!

<LI>Работающая и проверенная репликация. Проверена на сайтах:
<UL><LI>Yahoo Finance (<a HREF="../../../finance.yahoo.com/default.htm">
http://finance.yahoo.com</a>)
<LI>Mobile.de (<a HREF="../../../www.mobile.de/default.htm">http://www.mobile.de</a>)
<LI>Slashdot (<a HREF="../../../www.slashdot.org/default.htm">http://www.slashdot.org</a>)
</UL>

<LI>В дистрибутив MySQL входят два пакета тестирования:
<TT>mysql-test-run</TT> и
<a HREF="../../../www.mysql.com/information/crash-me.php">crash-me</a>. Система
теста активно модифицируется с кодом, чтобы проверить каждое новое свойство и
почти все повторимые ошибки. Авторы проверяют MySQL ими на большом количестве
платформ перед каждым выпуском. Эти тесты более сложны, чем все, что мне
доводилось видеть на PostgreSQL, и они гарантируют, что MySQL надежен.

<LI>MySQL поддерживает большее количество стандартных функций ODBC, чем
<CODE>PostgreSQL</CODE>.

<LI>MySQL имеет намного более сложную поддержку <CODE>ALTER TABLE</CODE>.

<LI>MySQL имеет поддержку для таблиц без транзакций для прикладных программ,
которые нуждаются во всем быстродействии, которое они могут получить. Таблицы
могут быть расположены в памяти, иметь типы <CODE>HEAP</CODE> или
<CODE>MyISAM</CODE>. Подробности в разделе
"<A HREF="glava07.htm#Table_types">7 Типы таблиц MySQL</A>".

<LI>MySQL имеет поддержку для двух различных драйверов таблицы, которые
поддерживают транзакции, <CODE>BerkeleyDB</CODE> и <CODE>InnoDB</CODE>.
Поскольку каждый драйвер транзакции выполняется по-разному при различных
условиях, это дает автору прикладной программы большее количество параметров,
чтобы найти оптимальное решение.

<LI>Таблицы <CODE>MERGE</CODE> дают Вам уникальный способ немедленно делать
просмотр набора идентичных таблиц и использовать их как одну. Это идеально
для систем, где Вы имеете журналы, которые Вы упорядочиваете, например, раз в
месяц. Подробности в разделе "<A HREF="merge.htm#MERGE">7.2 Таблицы MERGE
</A>".

<LI>Можно сжать таблицы только для чтения, но все еще иметь прямой доступ к
строкам таблиц. Это очень полезно, когда Вы архивируете данные.

<LI>MySQL имеет внутреннюю поддержку для полнотекстового поиска.

<LI>Вы можете обращаться ко многим базам данных из того же самого подключения
(зависит, конечно, от Ваших привилегий).

<LI>MySQL изначально написан как многопоточная программа, а вот PostgreSQL
применяет процессы. Переключение контекста и доступ к общим областям памяти
намного быстрее между потоками, чем между отдельными процессами, это дает
MySQL большое преимущество быстродействия в многопользовательских прикладных
программах, а также делает проще для MySQL работу в системах с поддержкой
схемы SMP (symmetric multiprocessor).

<LI>MySQL имеет намного более сложную систему привилегий, чем PostgreSQL. В
то время как PostgreSQL поддерживает только привилегии пользователя
<CODE>INSERT</CODE>, <CODE>SELECT</CODE> и <CODE>UPDATE/DELETE</CODE> на базе
данных или таблице, MySQL позволяет Вам определять набор различных привилегий
на уровнях базы данных, таблицы и столбца. MySQL также позволяет определять
привилегию на комбинациях пользователей и хостов.

<LI>MySQL поддерживает сжатый протокол клиент-сервер, который улучшает
эффективность на медленных каналах связи.

<LI>MySQL понимает понятие "драйвер таблицы". Более того, это единственная
реляционная база данных, сформированная на этом понятии. Это позволяет
различным типам таблицы низкого уровня меняться в сервере SQL, и при этом
каждый конкретный тип таблицы может быть отдельно оптимизирован для различных
характеристик эффективности.

<LI>Все типы таблиц MySQL (за исключением <STRONG>InnoDB</STRONG>) выполнены
как файлы (одна таблица на файл), что сильно облегчает проблемы копирования,
перемещения, резервирования и даже создания символических связей между
таблицами и базами данных (даже при выключенном сервере).

<LI>Инструментальные средства для ремонта и оптимизации наиболее общего типа
таблиц <STRONG>MyISAM</STRONG>. Инструмент для ремонта необходим только когда
происходит физическое искажение файла данных, обычно из-за аппаратного сбоя.
Это позволяет восстановить большинство данных.

<LI>Обновление MySQL безболезненно. Когда Вы наращиваете вычислительные
возможности MySQL, Вы не нуждаетесь в резервировании и восстановлении данных,
которое Вы должны делать с большинством обновлений PostgreSQL.</UL>

<P>Недостатки MySQL в сравнении с PostgreSQL:</P>
<UL><LI>Поддержка транзакций в MySQL еще не проверена так, как в PostgreSQL.

<LI>Так как MySQL применяет потоки, которые еще не отлажены толком на многих
операционных системах, надо либо пользоваться готовыми дистрибутивами с
<a HREF="../../../www.mysql.com/downloads">
http://www.mysql.com/downloads</a>, либо тщательно следовать инструкциям на
<a HREF="../../../www.mysql.com/doc/I/n/Installing_source.html">
http://www.mysql.com/doc/I/n/Installing_source.html</a>, чтобы получить
оптимальный двоичный код, который работает во всех случаях.

<LI>Блокировка таблицы в нетранзакционных таблицах <CODE>MyISAM</CODE>
во многих случаях быстрее, чем блокировки страницы, блокировки строки или
versioning. Недостаток состоит в том, что, если каждый клиент не принимает
во внимание, как работает блокировка таблицы, одиночный долго работающий
запрос может блокировать таблицу для модификаций в течение длительного
времени. Этого можно избежать при проектировании прикладной программы. Если
это невозможно, рекомендуется перейти на использование транзакционных таблиц.

<LI>С помощью UDF (user defined functions) можно расширять MySQL с помощью
обычных или агрегируемых функций SQL, но это еще не так просто и
гибко, как в PostgreSQL.

<LI>Модификации, которые работают с несколькими таблицами, в MySQL сложнее.
Это будет исправлено в MySQL 4.0 через многотабличную версию
<CODE>UPDATE</CODE>, а в MySQL 4.1 появятся вложенные выборы (subselects). В
MySQL 4.0 можно использовать многотабличное удаление, чтобы удалить данные из
многих таблиц сразу в то же самое время.</UL>

<P>PostgreSQL в настоящее время предлагает следующие преимущества над MySQL:
</P>

<P>Обратите внимание, что в следующей таблице приведены версии, начиная с
которых MySQL должен начать поддерживать то или иное свойство. К сожалению,
планы разработчиков PostgreSQL мне неизвестны, так что таких данных по их
пакету у меня нет.</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Возможность</STRONG></TD><TD><STRONG>Версия MySQL</STRONG>
</TD></TR>
<TR><TD>Вложенные выборки</TD><TD>4.1</TD></TR>
<TR><TD>Внешние ключи</TD><TD>4.0 и 4.1</TD></TR>
<TR><TD>Просмотр (Views)</TD><TD>4.2</TD></TR>
<TR><TD>Хранимые процедуры</TD><TD>4.1</TD></TR>
<TR><TD>Расширяемые системные типы</TD><TD>Не планируется</TD></TR>
<TR><TD>Unions</TD><TD>4.0</TD></TR>
<TR><TD>Полные объединения</TD><TD>4.0 или 4.1</TD></TR>
<TR><TD>Триггеры</TD><TD>4.1</TD></TR>
<TR><TD>Constrainst</TD><TD>4.1</TD></TR>
<TR><TD>Курсоры</TD><TD>4.1 или 4.2</TD></TR>
<TR><TD>Расширяемые типы индексов, например, R-деревья</TD><TD>R-деревья
планируются в версии не ниже 4.2</TD></TR>
<TR><TD>Таблицы с наследованием</TD><TD>Не планируются</TD></TR></TABLE>

<P>Другие резоны применения PostgreSQL:</P>

<UL><LI>Стандартное использование в PostgreSQL ближе к ANSI SQL в некоторых
случаях (но не всегда).
<LI>Можно ускорять PostgreSQL, программируя задачи как сохраненные процедуры.
<LI>PostgreSQL имеет большую группу разработчиков, которые способствуют
быстрой отладке сервера.</UL>

<P>Недостатки PostgreSQL в сравнении с MySQL:</P>
<UL><LI><CODE>VACUUM()</CODE> делает PostgreSQL непригодным, чтобы
использовать его в среде 24/7.
<LI>Только транзакционные таблицы.
<LI>Намного более медленные операции <CODE>INSERT</CODE>,
<CODE>DELETE</CODE> и <CODE>UPDATE</CODE>.</UL>

<P>Для получения полного списка недостатков, Вы должны также исследовать
первую таблицу в этом разделе.</P>

<H4><A NAME="MySQL-PostgreSQL_benchmarks">1.5.2.3
Сравнение производительности MySQL и PostgreSQL</A></H4>
<P>На сегодняшний день есть только один эталоныый тест, который можно
применить для оценки производительности MySQL, PostgreSQL и других баз
данных. Его можно скачать с
<a HREF="../../../www.mysql.com/information/benchmarks.html">
http://www.mysql.com/information/benchmarks.html</a>.</P>

<P>Несмотря на многократные обращения к авторам пакета PostgreSQL с просьбой
дополнить этот пакет тестов, ответа пока нет...</P>

<P>Эталонные тесты обычно выполняются опцией <CODE>--fast</CODE> и без нее
для сравнения величин. Когда тест выполнен с опцией <CODE>--fast</CODE>,
используются все расширенные возможности сервера для максимально возможного
ускорения процессов. Без этой опции сервер работает в нормальном режиме.</P>

<P>При работе PostgreSQL с <CODE>--fast</CODE> вызывается
<CODE>VACUUM()</CODE> после каждого сложного вызова <CODE>UPDATE</CODE> и
<CODE>DROP TABLE</CODE>, чтобы сделать базу данных компактней для следующих
вызовов <CODE>SELECT</CODE>. Время работы вызова <CODE>VACUUM()</CODE>
измеряется отдельно от времени теста.</P>

<P>При выполнении PostgreSQL 7.1.1 с опцией <CODE>--fast</CODE> на тесте
<CODE>INSERT</CODE> сервер PostgreSQL рухнул, похоронив под своими обломками
и всю базу данных, причем она была так разрушена, что было невозможно
перезапустить сервер. После повторения такого инцидента во второй раз, было
решено отложить тестирование с опцией <CODE>--fast</CODE> до выхода релиза.
</P>

<P>Некоторые замечания по ходу тестов:</P>

<P>Очень легко сделать такой тест, который покажет отличные результаты на
ЛЮБОЙ базе данных. Для этого всего-то надо использовать те возможности, в
которых испытуемая база данных сильна, а конкуренты слабы. Такие места есть
везде, в любой системе.</P>

<P>Этим способом можно показать, что MySQL быстрее PostgreSQL в 36 раз
(проверено лично). Но такой результат нельзя рассматривать как честный.
Более того, есть тесты, в которых PostgreSQL отстает от MySQL более, чем в
2000 раз. Это происходит на тех задачах, где PostgreSQL слабее MySQL. Если
замерить производительность на них и сравнить с производительностью на
задачах, дающих фору MySQL, примерно столько и выйдет.</P>

<P>Все это сказано для того, чтобы исключить сомнения в честности
тестирования. Да, есть способы доказать превосходство любой СУБД над любой
другой, но здесь сравнивали честно. MySQL делает много оптимизаций, которые
по каким-либо причинам не делает PostgreSQL. Это тоже верно, SQL-оптимизатор
очень сложный модуль, его можно оптимизировать годами.</P>

<P>При просмотре результатов эталонного теста, Вы должны искать те дела,
которые Вы делаете в Вашей прикладной программе, и использовать только эти
результаты, чтобы решить, которая база данных лучше всего подошла бы для
Вашей прикладной программы. Эталонные результаты также показывают дела, в
которых конкретная база данных не хороша, и должны дать Вам понятие
относительно того, что Вам, вероятно, придется делать другими способами.</P>

<P>Есть один тест, разработанный Great Bridge, прочитать данные о нем можно
на: <a HREF="../../../www.greatbridge.com/about/press.php@content_id=4">
http://www.greatbridge.com/about/press.php?content_id=4</a>.</P>

<P>Это самый ужасный тест, какой мне только попадался. Он не только делает
все, чтобы повысить результаты PostgreSQL. Он еще и сильно принижает все
прочие базы данных.</P>

<P><STRONG>ОБРАТИТЕ ВНИМАНИЕ</STRONG>: Разработчики PostgreSQL тут не при
чем! Группа авторов этого пакета решительно осудила разработку Great Bridge,
так что обвинять их просто не в чем.</P>

<P>Этот эталонный тест был осужден в большом количестве писем в списках
рассылки, так что я здесь только коротко повторю, что там сделано не так.
</P>

<UL><LI>Тесты были выполнены с дорогим коммерческим инструментом, который
делает невозможным для небольшой компании проверить эталонные тесты, или даже
проверить то, как эталонные тесты были действительно выполнены. Инструмент не
предназначен для тестирования баз данных вообще. Он ориентирован на
тестирование прикладной программы и установки.

<LI>Great Bridge признал, что они оптимизировали базу данных PostgreSQL перед
тестом с помощью вызова <CODE>VACUUM()</CODE> и настроили запуск тестов, чего
они не сделали ни для одной из других включаемых баз данных. При этом авторы
такого теста говорят о том, что этот процесс оптимизирует индексы и немного
освобождает дисковое пространство. Оптимизированные индексы немного
увеличивают эффективность. Но разработчиками MySQL было показано, что разница
в скорости работы множественных выборок на базе после применения
вакуумирования (<CODE>VACUUM()</CODE>) и до него
отличается примерно в 10 раз.

<LI>Результаты теста были также странными. Документация теста AS3AP
упоминает, что тест делает выборки, простые объединения, проектирования,
агрегаты, одиночные и оптовые модификации. PostgreSQL хорош при выполнении
<CODE>SELECT</CODE> и <CODE>JOIN</CODE> (особенно после вызова
<CODE>VACUUM()</CODE>), но никуда не годится на <CODE>INSERT</CODE> или
<CODE>UPDATE</CODE>. Эталонные тесты указывают, что только
<CODE>SELECT</CODE> были выполнены (или очень немного модификаций). Это могло
бы легко объяснять их хорошие результаты для PostgreSQL в этом тесте. Плохие
результаты для MySQL будут очевидны ниже в этом документе.

<LI>Тестеры выполняли так называемый эталонный тест под Windows против
Linux-машины с ODBC, которую никакой нормальный пользователь базы данных не
будет когда-либо делать при управлении тяжелой многопользовательской
прикладной программой. Это больше проверило драйвер ODBC и протокол Windows,
используемый для связи между клиентурой и сервером, чем саму базу данных.

<LI>При управлении базами данных Oracle и MS-SQL (Great Bridge косвенно
указал базы данных, которые они использовали в тесте) не использовался
местный протокол, вместо него поставили ODBC. Любой, кто когда-либо
использовал Oracle знает, что вся реальная прикладная программа использует
местный интерфейс вместо ODBC. Выполнение теста через ODBC вместе с
требованием, чтобы результаты отражали работу системы в реальной ситуации
не имеют с честностью ничего общего. Следовало бы сделать два теста: с
применением ODBC и без него, да еще и правильно все базы настроить.

<LI>Тестеры обращаются к тестам TPC-C, но они не упоминают где-нибудь, что
это не настоящий тест TPC-C. Все тесты TPC-C должны проводиться только в
соответствии с правилами, одобренными TPC Council
(<a HREF="../../../www.tpc.org/default.htm">http://www.tpc.org</a>). Great Bridge не делал
этого. Мало того, что была нарушена марка производителя, так еще и
дискредитировали эталонные тесты. Набор правил TPC Council очень строг, чтобы
гарантировать, что никто не может производить неправильные результаты или
делать невыполнимые инструкции. Очевидно, Great Bridge не был заинтересован
выполнением этих норм.

<LI>После первого теста авторы MySQL сообщили Great Bridge о некоторых из
наиболее очевидных ошибок, которые они сделали с MySQL:

<UL><LI>Работали с версией отладки ODBC-драйвера.
<LI>Работали на Linux-системе, которая не была оптимизирована для потоков.
<LI>Использовали старую версию MySQL.
<LI>Не запустили MySQL с правильными параметрами для тяжелого
многопользовательского режима (заданная по умолчанию установка применяется
для минимального использования ресурсов).</UL>

Great Bridge выполнил новый тест с оптимизированным ODBC-драйвером и с
лучшими параметрами запуска для MySQL, но отказался применить
модифицированную библиотеку glibc или стандартный двоичный дистрибутив,
скомпонованный статически с этой библиотекой (применяется на 80% систем).
Зато не предпринималось никаких попыток оптимизировать другие базы данных
для нормальной работы. Great Bridge не связывалась с Oracle или Microsoft,
это известно совершенно точно.

<LI>Эталонный тест был оплачен Great Bridge, и они решили издавать только
выбранные результаты (вместо того, чтобы издать все).</UL>

<P>Tim Perdue, длительное время любитель PostgreSQL и неохотный пользователь
MySQL издал сравнение на
<a HREF="../../../www.phpbuilder.com/columns/tim20001112.php3">
http://www.phpbuilder.com/columns/tim20001112.php3</a>.</P>

<P>Было выявлено много странных вещей в его результатах. Например, он
утверждал, что MySQL имел проблему с пятью пользователями в его тестах, когда
известно, что имеются пользователи с подобными машинами как его, которые
используют MySQL с 2000 одновременными подключениями, делающими по 400
запросов в секунду. В этом случае ограничение было в пропускной способности
сети, а не в базе данных.</P>

<P>Похоже, он использовал ядро Linux, которое имело некоторые проблемы с
многими потоками, например, ядра до 2.4, которые имели проблему с многими
потоками на многопроцессорных системах.</P>

<P>Другая возможная проблема: старая версия glibc. Tim сам собирал пакет, а
не использовал готовый дистрибутив с сайта разработчиков.</P>

<P>На все просьбы авторов пакета показать данные, на которых выполнялся тест,
и выяснить, что пошло не так, ответа так и не последовало.</P>

<P>Через какое-то время возможности пакета меняются, и вышеупомянутые
эталонные тесты больше не являются релевантными. MySQL теперь имеют пару
разных драйверов таблицы с различными соотношениями
быстродействия/параллелизма. Подробности в разделе
"<A HREF="glava07.htm#Table_types">7 Типы таблиц MySQL</A>". Было бы
интересно увидеть, как вышеупомянутые тесты выполнятся с различными
транзакционными типами таблиц в MySQL. PostgreSQL, конечно, также получил
новые свойства. Поскольку вышеупомянутый тест не доступен публично, нет
никакого способа узнать, как база данных повела бы себя в тех же
самых тестах сегодня.</P>

<P>Заключение:</P>

<P>Единственные эталонные тесты, которые существуют сегодня в таком виде, что
любой может скачать их и выполнить в MySQL и PostgreSQL, это эталонные тесты
MySQL. Авторы этого пакета считают, что базы данных с открытыми исходниками
должны быть проверены инструментальными средствами с открытым исходным кодом!
Это единственный способ гарантировать, что никто не делает тесты, которых
никто не сможет воспроизводить. Без знания всех фактов невозможно ответить
на требования испытателя.</P>

<P>Более подробно о наборе тестов рассказано в разделе
"<A HREF="glava05.htm#MySQL_Benchmarks">5.1.4 Набор тестов
MySQL Benchmark Suite</A>".</P>

<H2><A NAME="TODO">1.6 MySQL и будущее (TODO)</A></H2>
<P>Это приложение вносит в список свойства, которые планируется реализовать в
новых версиях MySQL.</P>

<P>Все в этом списке указано приблизительно в том порядке, в каком это будет
выполнено. Однако, коммерческие пользователи пакета до некоторой степени
могут на этот порядок влиять. Кто платит деньги, тот и заказывает музыку.</P>

<P>В будущем пакет будет поддерживать полный стандарт ANSI SQL99, но с
большим количеством полезных расширений.</P>

<H3><A NAME="TODO_MySQL_4.0">1.6.1 Что нового должно появиться в версии 4.0
</A></H3>
<P>Большинство базисных свойств, которые хотелось бы иметь в 4.0, уже
выполнено. Теперь будут реализованы всякие полезные мелочи, а глобальные
изменения подождут до версии MySQL 4.1.</P>

<UL><LI>Новый формат файла определения (файлы <CODE>.frm</CODE>). Это даст
возможность не исчерпать биты при добавлении большего количества параметров
таблицы. Старый формат пока поддерживается. Все недавно созданные таблицы,
однако, уже используют новый формат. Новый формат файла даст возможность
добавить новые типы столбца, большее количество параметров для ключей и
поддержку <CODE>FOREIGN KEY</CODE>.

<LI><CODE>mysqld</CODE> в виде библиотеки. Это будет иметь тот же самый
интерфейс как стандартный клиент MySQL (с дополнительной функцией, чтобы
только установить параметры запуска) но будет быстрее (никакой TCP/IP или
сокетной поддержки), меньше и намного проще в использовании для встроенных
приложений и систем. Каждый будет способен определить во время компоновки
форму использования (клиент-сервер или стационарное приложение), только
определяя, которую библиотеку компоновать с программой. Такой
<CODE>mysqld</CODE> будет поддерживать все стандартные свойства MySQL и можно
использовать это в поточном клиенте, чтобы выполнить различные запросы в
отдельных потоках системы.

<LI>Репликация должна работать с <CODE>RAND()</CODE> и переменными
пользователя <CODE>@var</CODE>.

<LI>Интерактивная копия с очень низким снижением эффективности. Интерактивная
копия облегчит добавление новой подчиненной системы. Планируется разрешить
<CODE>DELETE</CODE> на таблицах <CODE>MyISAM</CODE>, чтобы использовать кэш
записи. Чтобы сделать это, авторы должны модифицировать кэш записи потоков
при изменении файла <CODE>.MYD</CODE>.

<LI>Лучшая репликация.
<LI>Большее количество функций для полнотекстового поиска.
<LI>Трансляция наборов символов и поддержка для совместного применения
нескольких разных наборов символов.
<LI>Позволить пользователям менять параметры запуска без перезагрузки сервера.
<LI>Помощь для всех команд с клиента.
<LI>Защищенное соединение (по SSL).

<LI><CODE>SHOW COLUMNS FROM table_name</CODE> (используется клиентом
<CODE>mysql</CODE>, чтобы позволить расширения имен столбца) не должен
открывать таблицу, а только файл определения. Это требует меньшего количества
памяти и работает намного быстрее.

<LI>Новый кэш ключей.
<LI>При использовании <CODE>SET CHARACTER SET</CODE> надо транслировать весь
запрос целиком, а не только строки из него. Это даст возможность
пользователям свободно применять все транслируемые символы в именах базы
данных, таблицы и столбцов.

<LI>Нужен сменный интерфейс для <CODE>gethostbyaddr_r()</CODE> так, чтобы
можно было менять <CODE>ip_to_hostname()</CODE>, чтобы не блокировать другие
потоки при выполнении поиска в DNS.

<LI>Надо добавить метод <CODE>record_in_range()</CODE> в таблицы
<CODE>MERGE</CODE>, чтобы быть способным выбрать правильный индекс, когда
имеется много индексов. Авторы должны также расширить интерфейс информации,
чтобы получить распределение ключей для каждого индекса при выполнении
<CODE>analyze</CODE> на всех подтаблицах.
<LI><CODE>SET SQL_DEFAULT_TABLE_TYPE=[MyISAM|INNODB|BDB|HEAP]</CODE>.</UL>

<H3><A NAME="TODO_future">1.6.2 Возможности, планируемые в ближайшем будущем
</A></H3>
<UL><LI>Полностью безопасная репликация.

<LI>Подзапросы, например, такой: <CODE>select id from t where grp in
(select grp from g where u &#62; 100)</CODE>

<LI>Полученные таблицы.
<PRE>
select a.col1, b.col2 from (select max(col1) as col1 from root_table) a,
other_table b where a.col1=b.col1
</PRE>

Это могло бы быть выполнено, автоматически создавая временные таблицы для
полученных таблиц для продолжительности запроса.

<LI>Добавление инструкции <CODE>PREPARE</CODE> и посылки параметров для
<CODE>mysqld</CODE>.

<LI>Надо расширить протокол клиент-сервер для передачи предупреждений.
<LI>Добавить опции протокола клиент-сервер, чтобы получить индикатор
прогресса для длинных команд.

<LI>Добавить имя базы данных и реальное имя таблицы (в случае псевдонима) к
структуре MYSQL_FIELD.

<LI>Не позволять выполнять больше, чем определенное число потоков для
выполнения восстановления MyISAM.

<LI>Переделать <CODE>INSERT ... SELECT</CODE> для получения возможности
опционального применения конкурентных вставок.

<LI>Реализовать <CODE>RENAME DATABASE</CODE>. Чтобы сделать это безопасным
для всех драйверов таблицы, это должно работать следующим образом:

<UL><LI>Создать новую базу данных.
<LI>Для каждой таблицы переименовать таблицу в другой базе данных, как это
делается в команде <CODE>RENAME</CODE>.
<LI>Удалить старую базу данных.</UL>

<LI>Возвращать оригинальные типы полей при выполнении
<CODE>SELECT MIN(column) ... GROUP BY</CODE>.
<LI>Много наборов результатов.

<LI>Переделать протокол связи так, чтобы позволить двоичную передачу
значений. Чтобы делать это эффективно, нужно добавить API, чтобы позволить
связывание пользовательских переменных.

<LI>Сделать возможным задание <CODE>long_query_time</CODE> с точностью до
миллионных долей секунды.

<LI>Добавить настраиваемое приглашение командной строки клиента
<CODE>mysql</CODE> с указанием используемой базы данных, даты, времени и т.д.

<LI>Добавить проверку диапазона в таблицы <CODE>MERGE</CODE>.
<LI>Скомпоновать код <CODE>myisampack</CODE> с сервером.
<LI>Портировать MySQL на BeOS.
<LI>Портировать клиенты MySQL на LynxOS.

<LI>Добавить временный кэш буфера ключей на время работы
<CODE>INSERT/DELETE/UPDATE</CODE> так, чтобы можно было восстанавливаться,
если индексный файл становится полным.

<LI>Если Вы выполняете <CODE>ALTER TABLE</CODE> на таблице, которая является
ссылкой на другой диск, надо создавать временные таблицы на этом диске.

<LI>Реализовать тип <CODE>DATE/DATETIME</CODE>, который обрабатывает
информацию часового пояса правильно, так, чтобы иметь дело с датами в
различных часовых поясах было бы намного проще, чем сейчас.

<LI>FreeBSD и MIT-pthreads, бездействие потока тем не менее грузит CPU?
<LI>Проверить, не загружают ли блокированные потоки CPU.

<LI>Исправить configure так, чтобы можно компилировать все библиотеки
(подобно <CODE>MyISAM</CODE>) без потоков.

<LI>Добавить опцию для периодического сброса страниц ключей для таблицы с
отсроченными ключами, если они не использовались некоторое время.

<LI>Разрешить объединение на частях ключей (оптимизатор объединений).
<LI><CODE>INSERT SQL_CONCURRENT</CODE> и <CODE>mysqld
--concurrent-insert</CODE> должны выполнять вставки в конец файла, если файл
блокирован на чтение.

<LI>Сделать опредление <CODE>FOREIGN</CODE> для ключей в файле
<TT>.frm</TT>.

<LI>Вложенные вызовы <CODE>DELETE</CODE>.
<LI>Курсоры серверной стороны.
<LI>Проверить, работает ли <CODE>lockd</CODE> с современными ядрами Linux.
Если нет, надо исправить <CODE>lockd</CODE>! Чтобы проверить это, запустите
<CODE>mysqld</CODE> с параметром <CODE>--enable-locking</CODE> и выполните
различные тесты fork*. Они не должны выдавать какие-либо ошибки, если
сервер <CODE>lockd</CODE> работает.

<LI>Задействовать переменные SQL в <CODE>LIMIT</CODE>, например,
<CODE>LIMIT @a,@b</CODE>.
<LI>Разрешить обновление переменных через вызов <CODE>UPDATE</CODE>.
Например: <CODE>UPDATE TABLE foo SET @a=a+b,a=@a,b=@a+c</CODE>

<LI>Переделать изменение пользовательских переменных так, чтобы можно
использовать их с <CODE>GROUP BY</CODE>, как в следующем примере:
<CODE>SELECT id, @a:=count(*), sum(sum_col)/@a FROM table_name
GROUP BY id</CODE>.

<LI>Не добавлять автоматические значения <CODE>DEFAULT</CODE> к столбцам.
Выдавать ошибку при использовании инструкции <CODE>INSERT</CODE>, которая не
содержит столбец, который не имеет значения <CODE>DEFAULT</CODE>.

<LI>Кэширование запросов и результатов. Это должно быть выполнено как
отдельный модуль, который исследует каждый запрос, и если этот запрос
находится в кэше, кэшируемый результат должен быть возвращен. При модификации
таблицы из кэша должно быть удалено как можно меньше запросов. Это должно
дать большое быстродействие на машинах с большой RAM, где запросы часто
повторяются (подобно прикладным программам WWW). Возможно, стоит сделать так,
чтобы кэшировать только запросы типа <CODE>SELECT CACHED ...</CODE>.

<LI>Исправить <TT>libmysql.c</TT>, чтобы позволить две команды
<CODE>mysql_query()</CODE> в строке без того, чтобы читать результаты или
давать хорошее сообщение об ошибках.
<LI>Оптимизировать тип <CODE>BIT</CODE>, чтобы он занимал в самом деле 1 бит,
(сейчас <CODE>BIT</CODE> занимает 1 символ).
<LI>Разобраться, почему MIT-pthreads <CODE>ctime()</CODE> не работает на
целом ряде систем FreeBSD.
<LI>Добавить опцию <CODE>IMAGE</CODE> в вызов <CODE>LOAD DATA INFILE</CODE>
для отмены обновления полей <CODE>TIMESTAMP</CODE> и
<CODE>AUTO_INCREMENT</CODE>.
<LI>Добавить синтаксис <CODE>LOAD DATE INFILE UPDATE</CODE>.

<UL><LI>Для таблиц с первичными ключами, если данные содержат первичный ключ,
записи, соответствующие ему, модифицируется из остатка от столбцов. Однако,
столбцы, отсутствующие во входящей подаче данных, не меняются.

<LI>Для таблиц с первичными ключами, которые пропускают некоторую часть
ключа во входящем потоке данных, или не имеют никакого первичного ключа,
подача данных сейчас обрабатывается как инструкция <CODE>LOAD DATA
INFILE ... REPLACE INTO</CODE>.</UL>

<LI>Сделать синтаксис <CODE>LOAD DATA INFILE</CODE> поумнее, например, так:
<PRE>
LOAD DATA INFILE file_name.txt INTO TABLE tbl_name
     TEXT_FIELDS (text_field1, text_field2, text_field3)
     SET table_field1=concatenate(text_field1, text_field2), table_field3=23
     IGNORE text_field3
</PRE>

Это может использоваться, чтобы перескочить над столбцами дополнительного
пространства в текстовом файле, или обновить столбцы, основываясь на
выражениях из прочитанных данных.

<LI><CODE>LOAD DATA INFILE 'file_name' INTO TABLE 'table_name' ERRORS TO
err_table_name</CODE>. Это заставило бы любые ошибки и предупреждения
регистрироваться в таблице err_table_name. Эта таблица имела бы структуру:
<PRE>
line_number   - Номер строки в файле данных
error_message - Сообщение error/warning
Может быть, стоит добавить и
data_line     - Строка из файла данных
</PRE>

<LI>Добавить полную поддержку для <CODE>VARCHAR</CODE> (сейчас это уже
поддержано для таблиц MyISAM).

<LI>Автоматический вывод из <CODE>mysql</CODE> в netscape.
<LI><CODE>LOCK DATABASES</CODE> с разными опциями.
<LI>Изменить сортировку, чтобы распределить память в ``hunks'' для получения
лучшего использования памяти.
<LI>Типы <CODE>DECIMAL</CODE> и <CODE>NUMERIC</CODE> не могут читать
числа в экспоненциальной форме: <CODE>Field_decimal::store(const char
*from,uint len)</CODE> должен быть переделан, чтобы это исправить.

<LI>Выправить <CODE>mysql.cc</CODE>, чтобы делать меньшее количество вызовов
<CODE>malloc()</CODE>, когда имена полей хешированы.
<LI>Функции ADD_TO_SET(value,set) и REMOVE_FROM_SET(value,set)
<LI>Добавить использование <CODE>t1 JOIN t2 ON ...</CODE> и
<CODE>t1 JOIN t2 USING ...</CODE>. Сейчас Вы можете использовать его только с
вызовом <CODE>LEFT JOIN</CODE>.
<LI>Добавить полную поддержку для типа <CODE>unsigned long long</CODE>.

<LI>Намного больше переменных для <CODE>show status</CODE>. Считать
инструкции <CODE>INSERT</CODE>/<CODE>DELETE</CODE>/<CODE>UPDATE</CODE>.
Учитывать чтения и обновления, выборки из одной таблицы и выборки с
объединением, среднее число таблиц в выборе, количество запросов <CODE>ORDER
BY</CODE> и <CODE>GROUP BY</CODE>.

<LI>Если Вы прерываете <CODE>mysql</CODE> в середине запроса, Вы должны
открыть другое подключение и уничтожить старый запрос. Альтернативно попытка
должна быть сделана, чтобы обнаружить это на сервере.

<LI>Добавьте интерфейс драйвера для информации таблицы, так что Вы можете
использовать это как системную таблицу. Это было бы немного медленно, если Вы
запросили информацию относительно всех таблиц, но очень гибко. <CODE>SHOW
INFO FROM tbl_name</CODE> должно быть для базисной информации таблицы.

<LI>Добавить поддержку для UNICODE.
<LI><CODE>NATURAL JOIN</CODE> и <CODE>UNION JOIN</CODE>
<LI>Позволить <CODE>select a from crash_me left join crash_me2 using (a)
</CODE>. В этом случае a будет принято из таблицы crash_me.

<LI>Сделать так, чтобы <CODE>ON</CODE> и <CODE>USING</CODE> работали с типом
объединения <CODE>JOIN</CODE> в оптимизаторе.

<LI>Oracle-подобный вызов <CODE>CONNECT BY PRIOR ...</CODE> для поиска в
иерархических структурах и списках.
<LI><CODE>RENAME DATABASE</CODE>
<LI><CODE>mysqladmin copy database new-database</CODE>. Нужно добавить
команду COPY к <CODE>mysqld</CODE>

<LI>Processlist должен показывать число работающих запросов и потоков.
<LI><CODE>SHOW HOSTS</CODE> для печати информации относительно кэша hostname.
<LI>Опции <CODE>DELETE</CODE> и <CODE>REPLACE</CODE> в команде
<CODE>UPDATE</CODE> (это удалит строки, когда получена ошибка дублирования
ключа при модифицировании).

<LI>Переделать формат <CODE>DATETIME</CODE>, чтобы сохранить доли секунд.
<LI>Добавить все отсутствующие типы из ANSI92 и ODBC 3.0.
<LI>Изменить имена таблицы с пустых строк на <CODE>NULL</CODE> для расчетных
столбцов во избежание недоразумений.

<LI>Не использовать Item_copy_string на числовых значениях, чтобы избежать
конвертации число-&#62;строка-&#62;число в случае:
<CODE>SELECT COUNT(*)*(id+0) FROM table_name GROUP BY id</CODE>.

<LI>Сделать возможным использовать новую библиотеку GNU regexp вместо
текущей (GNU-библиотека должна быть намного быстрее, чем старая).

<LI>Изменения, которые вносит <CODE>ALTER TABLE</CODE>, не должны прерывать
клиентов, выполняющих запрос <CODE>INSERT DELAYED</CODE>.

<LI>Иногда столбцы, вызванные в предложении <CODE>UPDATE</CODE>, хранят
старые значения, которые у них были перед началом модификации.

<LI><CODE>myisamchk</CODE>, <CODE>REPAIR</CODE> и <CODE>OPTIMIZE TABLE</CODE>
должны обрабатывать случаи, где файлы данных и/или индекса являются не
файлами, а символическими ссылками.

<LI>Добавить моделирование <CODE>pread()</CODE>/<CODE>pwrite()</CODE> в
Windows, чтобы задействовать параллельные вставки.

<LI>Сделать анализатор протоколов, который мог бы анализировать, какие
таблицы вызываются чаще, как часто выполняются многотабличные объединения и
т.д. Это должно помочь пользователям идентифицировать области или сделать
проект таблицы, который мог бы быть оптимизирован, чтобы выполнить намного
более эффективные запросы.

<LI>Добавить <CODE>SUM(DISTINCT)</CODE>
<LI>Добавить групповые функции <CODE>ANY()</CODE>, <CODE>EVERY()</CODE> и
<CODE>SOME()</CODE>. В ANSI SQL они работают только на булевых столбцах, но
можно расширять их, чтобы работать на любых столбцах/выражениях, применяя:
<PRE>
value == 0 -&#62; FALSE
value &#60;&#62; 0 -&#62; TRUE.
</PRE>

<LI>Исправить то, что тип для <CODE>MAX(column)</CODE> совпадает с типом
самого столбца column.
<PRE>
create table t1 (a DATE);
insert into t1 values (now());
create table t2 select max(a) from t1;
show columns from t2;
</PRE>

<LI>Придумать хороший синтаксис для инструкции, которая <CODE>UPDATE</CODE>
строку, если она существует, и <CODE>INSERT</CODE> новую строку, если такой
строки пока нет. Вызов <CODE>REPLACE</CODE> примерно так работает с
<CODE>INSERT</CODE>/<CODE>DELETE</CODE>.</UL>

<H3><A NAME="TODO_sometime">1.6.3 Дела, которые должны быть выполнены позже
</A></H3>
<UL><LI>Реализовать функцию <CODE>get_changed_tables(timeout,table1,table2,
...)</CODE>.

<LI>Атомные многотабличные модификации, например: <CODE>update items,
month set items.price=month.price where items.id=month.id;</CODE>

<LI>Изменить чтение таблиц, чтобы использовать <CODE>memmap</CODE> когда
возможно. Сейчас только сжатые таблицы используют <CODE>memmap</CODE>.

<LI>Добавить новую привилегию <STRONG>Show_priv</STRONG>
для команд <CODE>SHOW</CODE>.

<LI>Сделать автоматический код timestamp лучше. Добавлять
<CODE>timestamp</CODE> в файл регистрации модификации с помощью
записи <CODE>SET TIMESTAMP=#;</CODE>.

<LI>Использовать в некоторых местах read/write mutex, чтобы получить большее
количество быстродействия, чем есть сейчас.

<LI>Полная поддержка внешних ключей. Возможно, сначала следует сделать
специальный процедурный язык.

<LI>Нужно реализовать простые просмотры (Simple views): сначала на одной
таблице, позже любое выражение.

<LI>Автоматически закрывать таблицы, если таблица, временная таблица или
временный файл получают ошибку 23 (недостаточно открытых файлов).

<LI>Когда найдено field=#, сменить все поля на #. Сейчас это выполнено только
для некоторых простых случаев.

<LI>Сменить все выражения констант с расчетными выражениями, если возможно.

<LI>Оптимизировать ключ=выражение. Сейчас оптимизируются только ключ=поле
или ключ=константа.

<LI>Объединить некоторые из функций копирования.

<LI>Переделать <TT>sql_yacc.yy</TT> к встроенному синтаксическому
анализатору, чтобы уменьшить размер, и получить лучшие сообщения об ошибках.

<LI>Изменить синтаксический анализатор так, чтобы использовать только одно
правило на разное число параметров для функции.

<LI>Использование полных имен вычисления в части
<CODE>order</CODE> (для ACCESS97).

<LI><CODE>UNION</CODE>, <CODE>MINUS</CODE>, <CODE>INTERSECT</CODE> и
<CODE>FULL OUTER JOIN</CODE>. Сейчас работает только
<CODE>LEFT OUTER JOIN</CODE>.

<LI>Разрешить применение <CODE>UNIQUE</CODE> на полях, которые могут быть
<CODE>NULL</CODE>.

<LI><CODE>SQL_OPTION MAX_SELECT_TIME=#</CODE>, чтобы поместить ограничение
времени выполнения в запрос.

<LI>Сделать файл регистрации модификаций в конкретной базе данных.

<LI>Отрицательное значение <CODE>LIMIT</CODE>, чтобы восстановить (отыскать)
данные с конца, также должно работать.

<LI>Предупреждения для клентских функций connect/read/write.

<LI>Пожалуйста, обратите внимание на изменения для <CODE>safe_mysqld</CODE>:
согласно FSSTND (которому Debian пробует следовать), PID-файлы должны быть в
каталоге <TT>/var/run/&#60;progname&#62;.pid</TT>, а файлы протоколов в
<TT>/var/log</TT>. Было бы хорошо, если бы Вы могли помещать "DATADIR" в
первое объявление "pidfile" и "log", так что размещение этих файлов может
быть изменено одиночной инструкцией.

<LI>Разрешить клиенту запрашивать регистрацию.
<LI>Добавить использование <CODE>zlib()</CODE> для <CODE>gzip</CODE>-файлов,
чтобы инструкция <CODE>LOAD DATA INFILE</CODE> работала с ними.

<LI>Исправить сортировку и группировку столбцов <CODE>BLOB</CODE>
(частично уже решено).

<LI>Сохраненные процедуры. Сейчас не так уж и важно, поскольку сохраненные
процедуры очень не стандартизированы. Другая проблема: сохраненные процедуры
делают работу намного труднее для оптимизатора, и во многих случаях результат
будет получен медленнее. С другой стороны, планируется добавить простой
(атомный) язык модификаций, который может использоваться, чтобы писать циклы.

<LI>Начать использовать семафоры при подсчете потоков. Нужно сначала
приделать библиотеку семафоров к MIT-pthreads.

<LI>Не назначать новое значение <CODE>AUTO_INCREMENT</CODE>, когда столбец
выставляется в 0. Надо использовать <CODE>NULL</CODE> в таких случаях.

<LI>Добавить полную поддержку для <CODE>JOIN</CODE> с круглыми скобками.

<LI>Как вариант для одного потока/соединения, надо управлять набором потоков,
чтобы обработать запросы.

<LI>Разрешить получать больше, чем одну блокировку с <CODE>GET_LOCK</CODE>.
При выполнении этого, нужно также обработать возможные тупики, которые это
изменение может представить.</UL>

<P>Время дано согласно количеству работы, это не реальное время.</P>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</HTML>
