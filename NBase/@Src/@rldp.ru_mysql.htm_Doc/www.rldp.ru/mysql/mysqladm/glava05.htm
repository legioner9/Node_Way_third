<HTML>
<HEAD>
  <TITLE>MySQL: Руководство администратора</TITLE>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
</HEAD>

<BODY>

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>


<H1><A NAME="MySQL_Optimization">5 Оптимизация в MySQL</A></H1>
<P>Оптимизация представляет собой сложную задачу потому, что в конечном счете
требуется понимание целой системы. В то время, как можно сделать некоторую
локальную оптимизацию с небольшими знаниями относительно Вашей системы или
прикладной программы, серьезная оптимизация требует значительных знаний.</P>

<P>Эта глава пробует объяснить и дать некоторые примеры различных способов
оптимизировать MySQL. Помните, однако, что всегда имеются некоторые
дополнительные способы сделать Вашу систему еще чуть быстрее.</P>

<H2><A NAME="Optimize_Overview">5.1 Обзор оптимизации</A></H2>
<P>Наиболее важная часть для получения быстрой системы: базисный проект.
Вы также должны знать то, какие дела Ваша система будет делать, каковы Ваши
узкие места на этом пути.</P>

<P>Наиболее общие узкие места:
<UL><LI>Дисковый поиск. Это требует времени для диска, чтобы найти часть
данных. С современными дисками среднее время для этого обычно ниже, чем 10ms,
так что мы можем в теории делать приблизительно 1000 позиционирований. Способ
оптимизировать это состоит в том, чтобы распространить данные на несколько
дисков, работающих параллельно.

<LI>Чтение и запись на диск. Когда диск в правильной позиции, мы должны
прочитать с него данные. С современными дисками один диск доставляет что-то
около 70-80 Mb в секунду. Это проще для оптимизации, чем поиск потому, что Вы
можете читать параллельно с нескольких дисков.

<LI>Циклы CPU. Когда мы имеем данные в основной памяти (или если они уже были
там), мы должны обработать их, чтобы добраться до нашего результата. Наличие
маленьких таблиц, сравнимых по размеру с памятью, наиболее общий фактор
ограничения быстродействия системы.

<LI>Скорость памяти. Когда CPU нужны данные, пропускная способность памяти
становится узким местом. Это бывает редко, но лучше всего про него помнить.
</UL>

<H3><A NAME="Design_Limitations">5.1.1 Ограничения в MySQL</A></H3>
<P>Поскольку MySQL использует чрезвычайно быструю блокировку таблицы
(много чтений и одна запись), самая большая остающаяся проблема: смесь
устойчивого потока вставок и медленного выбора данных в той же самой таблице.
</P>

<P>Считается, что для огромного числа систем чрезвычайно быстрая
эффективность в других случаях делает этот выбор правильным. Этот случай
обычно также решаем при наличии нескольких копий таблицы, но требуется
большее количество усилий и аппаратных средств.</P>

<P>Авторы также работают над некоторыми расширениями, чтобы решить эту
проблему для некоторых общих ниш прикладных программ.</P>

<H3><A NAME="Portability">5.1.2 Мобильность</A></H3>
<P>Потому, что все серверы SQL выполняют различные части SQL, требуется
немалая работа, чтобы писать переносные прикладные программы SQL. Для очень
простых выборов и вставок это очень просто, но чем дальше, тем труднее
становится нормальное программирование.</P>

<P>Чтобы делать сложную прикладную программу переносной, Вы должны выбрать
ряд серверов SQL, с которыми она должна работать.</P>

<P>Вы можете использовать MySQL программу crash-me/web-page
<a HREF="../../../www.mysql.com/information/crash-me.php">
http://www.mysql.com/information/crash-me.php</a>, чтобы найти функции, типы
и ограничения, которые Вы можете использовать с выбором сервера базы данных.
Crash-me проверяет далеко не все возможное, но тест выполнен для 450 задач.
</P>

<P>Например, Вы не должны иметь имена столбцов более длинными, чем 18
символов, если Вы хотите использовать Informix или DB2.</P>

<P>Тесты и программа MySQL crash-me являются очень независимыми от базы
данных. Изучение этих программ может помочь Вам в написании своих прикладных
программ, независимых от базы данных. Эталонные тесты могут быть найдены в
каталоге <TT>sql-bench</TT> дерева исходников MySQL. Они написаны на Perl с
интерфейсом базы данных DBI (который решает проблемы доступа).</P>

<P>Результаты тестов есть на
<a HREF="../../../www.mysql.com/information/benchmarks.html">
http://www.mysql.com/information/benchmarks.html</a>.</P>

<P>Как Вы можете видеть в этих результатах, все базы данных имеют некоторые
слабые пункты. То есть они имеют различные компромиссы проекта, которые
ведут к различному поведению.</P>

<P>Если Вы боретесь за независимость базы данных, Вы должны получить данные
по проблемным зонам каждого сервера SQL. MySQL ОЧЕНЬ быстр в поиске и
модифицировании, но будет иметь проблему при смешивании медленных чтений и
записей на той же самой таблице. Oracle, с другой стороны, имеет большую
проблему, когда Вы пробуете обращаться к строкам, которые Вы недавно
модифицировали (пока их не сбросят на диск). Базы данных с транзакциями
вообще не очень хороши при производстве итоговых таблиц из таблиц файла
регистрации, поскольку в этом случае блокировка строки почти бесполезна.</P>

<P>Чтобы сделать Вашу прикладную программу <EM>по-настоящему</EM> независимой
от базы данных, Вы должны определить простой интерфейс, через который Вы
управляете вашими данными. Поскольку C++ доступен на большинстве систем,
имеет смысл использовать интерфейс классов C++ к базам данных.</P>

<P>Если Вы используете некоторое специфическое свойство для некоторой базы
данных (подобно команде <CODE>REPLACE</CODE> в MySQL), Вы должны
предусмотреть метод для других серверов SQL, чтобы выполнить то же самое
свойство (но медленнее). С MySQL Вы можете использовать синтаксис
<CODE>/*!  */</CODE>, чтобы добавить MySQL-специфические ключевые слова к
запросу. Код внутри <CODE>/**/</CODE> будет обрабатываться как комментарий
большинством других серверов SQL.</P>

<P>Если высокая эффективность более важна, чем точность, как в некоторых
прикладных программах для интернета, можно создать уровень прикладной
программы, который кэширует все результаты, чтобы дать Вам даже более высокую
эффективность. Позволяя старым результатам выдыхаться через некоторое время,
Вы можете хранить кэш, приемлемо свежим. Это совершенно хорошо в случае
чрезвычайно высокой загрузки, когда Вы можете динамически увеличивать кэш и
повышать время ожидания, пока ситуация не вернется к норме.</P>

<P>В этом случае информация для создания новой таблицы должна содержать еще и
информацию относительно начального размера кэша и то, как часто таблица
обычно должна обновиться.</P>

<H3><A NAME="Internal_use">5.1.3 Для чего использовали MySQL?</A></H3>
<P>Вот что пишут авторы пакета о том, как создавалась эта СУБД:</P>

<P>В ходе начальной разработки, свойства MySQL были сделаны такими, чтобы
удовлетворить нашего самого большого заказчика. Он обрабатывает данные для
самых больших розничных продавцов в Швеции.</P>

<P>Из всех магазинов мы получаем еженедельно резюме всех транзакций по картам
скидок и призов. Требуется обеспечить полезную информацию для владельцев
магазинов, чтобы помочь им понять, как их рекламные кампании воздействуют на
их заказчиков.</P>

<P>Данные огромны (приблизительно 7 миллионов итоговых транзакций в месяц), и
мы имеем данные за последние 4-10 лет, которые должны представить
пользователям. Мы получили еженедельно запросы от заказчиков, что они хотят
иметь мгновенный доступ к новым отчетам из этих данных.</P>

<P>Мы решили это, сохраняя всю информацию за месяц в сжатых таблицах. Мы
имеем набор простых макрокоманд (скриптов), который генерирует итоговые
таблицы, сгруппированные в соответствии с различными критериями (product
group, customer id, store, ...) из таблиц транзакции. Отчеты представляют
собой Web-страницы, которые динамически генерируются маленьким скриптом на
Perl, который анализирует Web-страницу, выполняет инструкции SQL и вставляет
результаты. Мы использовали бы взамен PHP или mod_perl, но они не были
доступны в то время.</P>

<P>Для графических данных мы написали на <CODE>C</CODE> простой инструмент,
который может производить GIF-файлы, основываясь на результате запроса SQL (с
некоторой обработкой результата). Это также динамически выполняется из
скрипта на Perl, который анализирует HTML-файлы.</P>

<P>В большинстве случаев новый отчет может быть выполнен, просто копируя
существующий скрипт и изменяя запрос SQL в нем. В некоторых случаях мы будем
должны добавить большее количество полей к существующей таблице или
сгенерировать новую, но это также просто, поскольку мы храним все таблицы
транзакций на диске. В настоящее время мы имеем по крайней мере 50G таблиц
транзакций и порядка 200G других данных заказчика.</P>

<P>Мы также позволяем нашим заказчикам обращаться к итоговым таблицам
непосредственно через ODBC так, чтобы продвинутые пользователи могли
самостоятельно экспериментировать с данными.</P>

<P>Мы не имели проблем с обработкой данных на Sun Ultra SPARCstation (2x200
Mhz). Недавно был проведен апгрейд до 2 CPU 400 Mhz UltraSPARC, и мы теперь
планируем запускать транзакции обработки на уровне изделия товара, что
означает десятикратное увеличение данных.</P>

<P>Мы также экспериментируем с Intel-Linux, чтобы быть способными получить
большее количество более дешевой мощности CPU. Теперь, когда мы имеем
двоичный переносимый формат базы данных (введен в Version 3.23), мы начнем
использовать это для некоторых частей прикладной программы.</P>

<H3><A NAME="MySQL_Benchmarks">5.1.4 Пакет тестов MySQL Benchmark Suite</A>
</H3>
<P>Этот раздел должен содержать техническое описание эталонного набора тестов
MySQL и теста <CODE>crash-me</CODE>, но пока подробное руководство еще никем
не написано (в том числе и авторами пакета). Так что говорить о нем рано. В
настоящее время Вы можете получить хорошую помощь относительно эталонного
теста, рассматривая код и результаты в каталоге <TT>sql-bench</TT>
дистрибутива исходников MySQL.</P>

<P>Этот эталонный набор, как предполагается, является эталонным тестом,
который сообщит любому пользователю, что именно данная реализация SQL
выполняет хорошо или плохо.</P>

<P>Обратите внимание, что этот эталонный тест однопоточный, так что он
измеряет минимальное время для операций. В будущем планируется добавление
поддержки многопоточной обработки.</P>

<P>Например, (запуск на машине с NT 4.0):</P>
<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Чтение 2000000 строк по индексу</STRONG></TD>
<TD><STRONG>Секунд</STRONG></TD></TR>
<TR><TD>mysql</TD><TD>367</TD></TR>
<TR><TD>mysql_odbc</TD><TD>464</TD></TR>
<TR><TD>db2_odbc</TD><TD>1206</TD></TR>
<TR><TD>informix_odbc</TD><TD>121126</TD></TR>
<TR><TD>ms-sql_odbc</TD><TD>1634</TD></TR>
<TR><TD>oracle_odbc</TD><TD>20800</TD></TR>
<TR><TD>solid_odbc</TD><TD>877</TD></TR>
<TR><TD>sybase_odbc</TD><TD>17614</TD></TR></TABLE>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Вставка 350768 строк</STRONG></TD>
<TD><STRONG>Секунд</STRONG></TD></TR>
<TR><TD>mysql</TD><TD>381</TD></TR>
<TR><TD>mysql_odbc</TD><TD>619</TD></TR>
<TR><TD>db2_odbc</TD><TD>3460</TD></TR>
<TR><TD>informix_odbc</TD><TD>2692</TD></TR>
<TR><TD>ms-sql_odbc</TD><TD>4012</TD></TR>
<TR><TD>oracle_odbc</TD><TD>11291</TD></TR>
<TR><TD>solid_odbc</TD><TD>1801</TD></TR>
<TR><TD>sybase_odbc</TD><TD>4802</TD></TR></TABLE>

<P>В вышеупомянутом тесте MySQL был выполнен с 8M индексным кэшем.</P>

<P>Мы имеем несколько больше эталонных результатов на
<a HREF="../../../www.mysql.com/information/benchmarks.html">
http://www.mysql.com/information/benchmarks.html</a>.</P>

<P>Обратите внимание, что Oracle не включен потому, что компания-разработчик
потребовала удалить эти данные. Причины такого отношения к независимым
измерениям производительности могут быть вызваны лишь откровенным завышением
характеристик сервера компанией Oracle.</P>

<P>Чтобы выполнить эталонный набор, Вы должны загрузить исходники MySQL,
установить драйвер perl DBI для базы данных, которую Вы хотите проверить, и
затем отдать команды:</P>
<PRE>
cd sql-bench
perl run-all-tests --server=#
</PRE>

<P>Здесь # задает один из поддержанных серверов. Вы можете получить список
всех параметров и поддержанных серверов командой <CODE>run-all-tests --help
</CODE>.</P>

<P><A NAME="IDX824"></A>Тест <CODE>crash-me</CODE> может определить, какие
свойства база данных поддерживает, и перечень фактических возможностей и
ограничений. Например, это определяет:</P>

<UL><LI>Какие типы столбца поддержаны
<LI>Сколько индексов поддержано
<LI>Какие функции доступны
<LI>Насколько велик может быть запрос
<LI>Насколько велик может быть столбец типа <CODE>VARCHAR</CODE></UL>

<P>Результаты теста crash-me для большого набора разных баз данных можно
найти на <a HREF="../../../www.mysql.com/information/crash-me.php">
http://www.mysql.com/information/crash-me.php</a>.</P>

<H3><A NAME="Custom_Benchmarks">5.1.5 Использование ваших
собственных эталонных тестов</A></H3>
<P>Вы должны использовать эталонный тест, чтобы выяснять, где находятся узкие
места. Исправляя это (или заменяя узкое место фиктивным модулем), Вы можете
затем легко идентифицировать следующее узкое место и так далее. Даже если
полная эффективность для Вашей прикладной программы достаточна, Вы должны по
крайней мере сделать план каждого узкого места и решить, как его расширить,
если возникнет такая потребность.</P>

<P>Для примера переносных эталонных программ рассмотрите эталонный набор
MySQL. Подробности в разделе "<A HREF="#MySQL_Benchmarks">5.1.4
Пакет тестов MySQL Benchmark Suite</A>". Вы можете брать любую программу из
этого набора и изменять ее для Ваших потребностей. Делая это, Вы можете
опробовать различные решения Вашей проблемы и теста, который в самом деле
является самым быстрым решением для Вас.</P>

<P>Некоторые проблемы происходят только тогда, когда система очень тяжело
загружена. В каждом из этих случаев это обычно проблема с базисным проектом
(просмотр таблицы НЕ хорош при высокой загрузке) или есть трудности с
OS/Library. Большинство этих случаев было бы <STRONG>НАМНОГО</STRONG> проще
исправить, если система еще не запущена в работу.</P>

<P>Чтобы избежать подобных проблем, Вы должны тестировать прикладную
программу при самой плохой возможной загрузке! Вы можете использовать для
этого Super Smack, который доступен по адресу
<a HREF="../../../www.mysql.com/Downloads/super-smack/super-smack-1.0.tar.gz">
http://www.mysql.com/Downloads/super-smack/super-smack-1.0.tar.gz</a>.</P>

<H2><A NAME="Query_Speed">5.2
Оптимизация <CODE>SELECT</CODE> и разных запросов</A></H2>
<P>Сначала, одна вещь, которая воздействует на все запросы: более сложная
установка систем разрешений, которую Вы имеете, усложняет и замедляет работу.
В настройках не должно быть ничего лишнего. Все дополнительные довески и
добавки замедляют работу системы (порой неожиданно сильно!). Как говорил один
из моих преподавателей в университете, на парте должны быть только бумага,
ручка и Ваши мозги.</P>

<P>Если Вы не имеете никаких выполненных инструкций <CODE>GRANT</CODE>, MySQL
оптимизирует проверку разрешений.</P>

<P>Если Ваша проблема связана с некоторой явной функцией MySQL, Вы можете
всегда сделать это в пользователе MySQL:</P>
<PRE>
mysql&#62; select benchmark(1000000,1+1);
+------------------------+
| benchmark(1000000,1+1) |
+------------------------+
|                      0 |
+------------------------+
1 row in set (0.32 sec)
</PRE>

<P>Этот пример показывает, что MySQL может выполнять 1000000 операций
сложения (<CODE>+</CODE>) за 0.32 секунды на <CODE>PentiumII 400MHz</CODE>.
</P>

<P>Все функции MySQL должны быть очень хорошо оптимизированы, но могут
иметься некоторые исключительные ситуации, и вызов
<CODE>benchmark(loop_count,expression)</CODE> представляет собой хороший
инструмент, чтобы выяснить, связана ли эта проблема с Вашим запросом.</P>

<H3><A NAME="EXPLAIN">5.2.1 Синтаксис <CODE>EXPLAIN</CODE>
(получение информации о <CODE>SELECT</CODE>)</A></H3>
<PRE>
  EXPLAIN tbl_name or
  EXPLAIN SELECT select_options
</PRE>

<P><CODE>EXPLAIN tbl_name</CODE> представляет собой синоним для
<CODE>DESCRIBE tbl_name</CODE> или <CODE>SHOW COLUMNS FROM tbl_name</CODE>.
</P>

<P>Когда Вы перед <CODE>SELECT</CODE> задаете ключевое слово
<CODE>EXPLAIN</CODE>, MySQL объясняет, как он обработал бы
<CODE>SELECT</CODE>, обеспечивая информацию относительно того, как таблицы
будут соединены, и в каком порядке.</P>

<P>С помощью <CODE>EXPLAIN</CODE> Вы можете видеть, когда Вы должны добавить
индексы к таблицам, чтобы получить более быстрый <CODE>SELECT</CODE>, который
использует индексы, чтобы найти записи. Вы можете также видеть, соединяет ли
оптимизатор таблицы в оптимальном порядке. Чтобы вынуждать оптимизатор
использовать специфический порядок объединения для инструкции
<CODE>SELECT</CODE>, добавьте предложение <CODE>STRAIGHT_JOIN</CODE>.</P>

<P>Для непростых объединений <CODE>EXPLAIN</CODE> возвратит строку информации
для каждой таблицы, используемой в инструкции <CODE>SELECT</CODE>. Таблицы
перечислены в том порядке, в каком они читались бы. MySQL читает строку из
первой таблицы, затем находит строку соответствий во второй таблице, затем в
третьей таблице и так далее. Когда все таблицы обработаны, MySQL выводит
выбранные столбцы и возвращается через список таблицы, пока не будет найдена
таблица, для которой там больше соответствующих строк. Следующая строка
читается из этой таблицы, и процесс продолжается со следующей таблицей.</P>

<P>Вывод из <CODE>EXPLAIN</CODE> включает в себя следующие столбцы:</P>
<DL COMPACT>
<DT><CODE>table</CODE>
<DD>Таблица, к которой строка вывода обращается.

<DT><CODE>type</CODE>
<DD>Тип объединения. Информация относительно различных типов дана ниже.

<DT><CODE>possible_keys</CODE>
<DD>Столбец <CODE>possible_keys</CODE> указывает, какие индексы MySQL мог бы
использовать, чтобы найти строки в этой таблице. Обратите внимание, что этот
столбец полностью не зависит от порядка таблиц. Это означает, что некоторые
из ключей в possible_keys не могут быть пригодны для использования
практически со сгенерированным порядком таблицы. Если этот столбец пуст, не
имеется никаких релевантных индексов. В этом случае, Вы можете улучшить
эффективность Вашего запроса, исследуя предложение <CODE>WHERE</CODE>, чтобы
увидеть, обращается ли оно к некоторому столбцу или столбцам, которые были бы
подходящими для индексации. Если так, создайте соответствующий индекс, и
проверьте запрос с помощью <CODE>EXPLAIN</CODE> снова. Чтобы увидеть, какие
индексы таблица имеет, вызовите <CODE>SHOW INDEX FROM tbl_name</CODE>.

<DT><CODE>key</CODE>
<DD>Столбец <CODE>key</CODE> указывает ключ, который MySQL фактически решил
использовать. Если индекс не выбран, здесь будет <CODE>NULL</CODE>. Если
MySQL выбирает неправильный индекс, Вы можете вынуждать MySQL использовать
другой индекс, используя <CODE>myisamchk --analyze</CODE>. Подробности в
разделе "<A HREF="recovery.htm#myisamchk_syntax">4.4.6.1 Синтаксис обращения
к <CODE>myisamchk</CODE></A>". Можно применить и
<CODE>USE INDEX/IGNORE INDEX</CODE>.

<DT><CODE>key_len</CODE>
<DD>Столбец <CODE>key_len</CODE> указывает длину ключа, который MySQL решил
использовать. Длина равна <CODE>NULL</CODE>, если <CODE>key</CODE> равен
<CODE>NULL</CODE>. Обратите внимание, что это сообщает нам, сколько частей
составного ключа фактически использует MySQL.

<DT><CODE>ref</CODE>
<DD>Столбец <CODE>ref</CODE> показывает, которые столбцы или константы
используются с <CODE>key</CODE>, чтобы выбрать строки из таблицы.

<DT><CODE>rows</CODE>
<DD>Столбец <CODE>rows</CODE> указывает число строк, которые MySQL должен
исследовать, чтобы выполнить запрос.

<DT><CODE>Extra</CODE>
<DD>Этот столбец содержит дополнительную информацию относительно того, как
MySQL решит запрос. Имеется объяснение различных текстовых строк, которые
могут быть найдены в этом столбце:

<DL COMPACT>
<DT><CODE>Distinct</CODE>
<DD>MySQL не будет продолжать искать большее количество строк для текущей
комбинации строк после того, как найдет первую строку соответствий.

<DT><CODE>Not exists</CODE>
<DD>MySQL был способен делать оптимизацию <CODE>LEFT JOIN</CODE> на запросе и
не будет исследовать большее количество строк в этой таблице для предыдущей
комбинации строк после того, как найдет одну строку, которая соответствует
критериям <CODE>LEFT JOIN</CODE>. Имеется пример этого:
<PRE>
SELECT * FROM t1 LEFT JOIN t2 ON t1.id=t2.id WHERE t2.id IS NULL;
</PRE>

Считается, что <CODE>t2.id</CODE> определен как <CODE>NOT NULL</CODE>.
В этом случае MySQL просмотрит <CODE>t1</CODE> и будет искать строки в
<CODE>t2</CODE> через <CODE>t1.id</CODE>. Если MySQL находит строку
соответствий в <CODE>t2</CODE>, он знает, что <CODE>t2.id</CODE> никогда не
может быть <CODE>NULL</CODE>, и не будет просматривать остальную часть строк
в <CODE>t2</CODE>, которые имеют тот же самый идентификатор <CODE>id</CODE>.
Другими словами, для каждой строки в <CODE>t1</CODE> MySQL должен делать
только одиночную поисковую таблицу в <CODE>t2</CODE> независимо от того,
сколько соответствий строк находится в <CODE>t2</CODE>.

<DT><CODE><CODE>range checked for each record (index map: #)</CODE></CODE>
<DD>MySQL не смог найти подходящий индекс для использования. Вместо этого для
каждой комбинации строк в обрабатываемых таблицах будет выполняться поиск
хорошего индекса для применения (если они есть). Найденный индекс будет
использован для получения строк из таблицы. Это не особенно быстро, но все же
быстрее, чем объединение без индексов.

<DT><CODE>Using filesort</CODE>
<DD>MySQL должен сделать дополнительный проход, чтобы выяснить, как получить
строки в сортируемом порядке. Сортировка выполнена, проходя все строки
согласно типу объединения (<CODE>join type</CODE>) и сохраняя ключ
сортировки+указатель на строку для всех строк, которые соответствуют
<CODE>WHERE</CODE>. Затем ключи сортируются. В заключение строки будут
получены в сортируемом порядке.

<DT><CODE>Using index</CODE>
<DD>Информация столбца получена из таблицы с применением только индексного
дерева без дополнительного поиска для чтения актуальной строки. Это может
быть сделано только, если все столбцы для таблицы являются частью одного и
того же индекса.

<DT><CODE>Using temporary</CODE>
<DD>Чтобы решить запрос, MySQL должен создать временную таблицы для хранения
промежуточных результатов вычислений и поиска. Это обычно происходит, если Вы
выполнили <CODE>ORDER BY</CODE> на наборе столбцов, отличном от того, который
был задан в предложении <CODE>GROUP BY</CODE>.

<DT><CODE>Where used</CODE>
<DD>Предложение <CODE>WHERE</CODE> будет использоваться, чтобы ограничить то,
которые строки будут согласованы для следующей таблицы или посланы
пользователю. Если Вы не имеете эту информацию, и таблица имеет тип
<CODE>ALL</CODE> или <CODE>index</CODE>, Вы можете иметь что-то неправильное
в Вашем запросе (если Вы не предполагаете выбирать/исследовать все строки из
таблицы). Если Вы хотите получать ответы на Ваши запросы с такой скоростью, с
какой только возможно, Вы должны рассмотреть применение <CODE>Using
filesort</CODE> и <CODE>Using temporary</CODE>.</DL></DL>

<P>Различные типы объединения перечислены ниже в порядке от лучших к худшим:
</P>

<P><A NAME="IDX832"></A><A NAME="IDX833"></A>
<DL COMPACT>
<DT><CODE>system</CODE>
<DD>Таблица имеет только одну строку (= system table). Это особый случай
объединения типа <CODE>const</CODE>.

<A NAME="IDX834"></A><A NAME="IDX835"></A>
<DT><CODE>const</CODE>
<DD>Таблица имеет одну соответствующую строку, которая будет читаться в
начале запроса. Потому, что имеется только одна строка, значения из столбца
в этой строке могут быть расценены как константы остальной частью
оптимизатора. Таблицы <CODE>const</CODE> очень быстры, поскольку они доступны
для чтения только однажды!

<DT><CODE>eq_ref</CODE>
<DD>Одна строка будет читаться из этой таблицы для каждой комбинации строк из
предыдущих таблиц. Это самый лучший возможный тип объединения, кроме
<CODE>const</CODE>. Это используется, когда все части индекса применяются
объединением, и индекс <CODE>UNIQUE</CODE> или <CODE>PRIMARY KEY</CODE>.

<DT><CODE>ref</CODE>
<DD>Все строки с соответствием индексных значений будут читаться из этой
таблицы для каждой комбинации строк из предыдущих таблиц. Тип
<CODE>ref</CODE> используется, если объединение использует только крайний
левый префикс ключа, или если ключ не <CODE>UNIQUE</CODE> или <CODE>PRIMARY
KEY</CODE> (другими словами, если объединение не может выбирать одиночную
строку, основанную на значении ключа).

<DT><CODE>range</CODE>
<DD>Только строки, которые находятся в данном диапазоне, будут получены,
используя индекс, чтобы выбрать строки. Столбец <CODE>key</CODE> указывает,
который индекс используется. Столбец <CODE>key_len</CODE> содержит самую
длинную часть ключа, которая использовалась. Столбец <CODE>ref</CODE>
для этого типа будет NULL.

<DT><CODE>index</CODE>
<DD>Аналогично <CODE>ALL</CODE>, за исключением того, что только индексное
дерево будет просмотрено. Это обычно быстрее, чем <CODE>ALL</CODE>, поскольку
индексный файл обычно меньше, чем файл данных.

<DT><CODE>ALL</CODE>
<DD>Полный просмотр таблицы будет выполнен для каждой комбинации строк из
предыдущих таблиц. Это обычно не очень хорошо, если таблица является первой
таблицей, не маркированной как <CODE>const</CODE>, и обычно
<STRONG>очень</STRONG> плохо во всех других случаях. Вы обычно можете
избежать <CODE>ALL</CODE>, добавляя большее количество индексов, так, чтобы
строка могла быть найдена, основываясь на постоянных значениях или значениях
столбца более ранних таблиц.</DL>

<P>Вы можете получать хорошую индикацию относительно того, насколько хорошим
является объединение, умножая все значения в столбце <CODE>rows</CODE> вывода
<CODE>EXPLAIN</CODE>. Это должно сообщить Вам грубо, сколько строк MySQL
должен исследовать, чтобы выполнить запрос. Это число также используется,
когда Вы ограничиваете запросы переменной <CODE>max_join_size</CODE>.
Подробности в разделе "<A HREF="#Server_parameters">5.5.2
Настройка параметров сервера</A>".</P>

<P>Следующий пример показывает, как <CODE>JOIN</CODE> может быть
оптимизирован, прогрессивно используя информацию, предоставляемую
<CODE>EXPLAIN</CODE>.</P>

<P>Предположим, что Вы имеете инструкцию <CODE>SELECT</CODE>, показанную
ниже, и что Вы исследуете ее, используя <CODE>EXPLAIN</CODE>:</P>
<PRE>
EXPLAIN SELECT tt.TicketNumber, tt.TimeIn, tt.ProjectReference,
               tt.EstimatedShipDate, tt.ActualShipDate, tt.ClientID,
               tt.ServiceCodes, tt.RepetitiveID, tt.CurrentProcess,
               tt.CurrentDPPerson, tt.RecordVolume, tt.DPPrinted,
               et.COUNTRY, et_1.COUNTRY, do.CUSTNAME
        FROM tt, et, et AS et_1, do WHERE tt.SubmitTime IS NULL
             AND tt.ActualPC = et.EMPLOYID AND tt.AssignedPC=et_1.EMPLOYID
             AND tt.ClientID = do.CUSTNMBR;
</PRE>

<P>Например, предположим, что:</P>

<UL><LI>Все столбцы, используемые в сравнении, определены:
<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Таблица</STRONG></TD><TD><STRONG>Столбец</STRONG></TD><TD>
<STRONG>Тип столбца</STRONG></TD></TR>
<TR><TD><CODE>tt</CODE></TD><TD><CODE>ActualPC</CODE></TD><TD>
<CODE>CHAR(10)</CODE></TD></TR>
<TR><TD><CODE>tt</CODE></TD><TD><CODE>AssignedPC</CODE></TD><TD>
<CODE>CHAR(10)</CODE></TD></TR>
<TR><TD><CODE>tt</CODE></TD><TD><CODE>ClientID</CODE></TD><TD>
<CODE>CHAR(10)</CODE></TD></TR>
<TR><TD><CODE>et</CODE></TD><TD><CODE>EMPLOYID</CODE></TD><TD>
<CODE>CHAR(15)</CODE></TD></TR>
<TR><TD><CODE>do</CODE></TD><TD><CODE>CUSTNMBR</CODE></TD><TD>
<CODE>CHAR(15)</CODE></TD></TR></TABLE>

<LI>Таблицы имеют индексы, показанные ниже:
<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Таблица</STRONG></TD><TD><STRONG>Индекс</STRONG></TD></TR>
<TR><TD><CODE>tt</CODE></TD><TD><CODE>ActualPC</CODE></TD></TR>
<TR><TD><CODE>tt</CODE></TD><TD><CODE>AssignedPC</CODE></TD></TR>
<TR><TD><CODE>tt</CODE></TD><TD><CODE>ClientID</CODE></TD></TR>
<TR><TD><CODE>et</CODE></TD><TD><CODE>EMPLOYID</CODE> (первичный ключ)</TD>
</TR>
<TR><TD><CODE>do</CODE></TD><TD><CODE>CUSTNMBR</CODE> (первичный ключ)</TD>
</TR></TABLE>

<LI>Значения <CODE>tt.ActualPC</CODE> распределены неравномерно.</UL>

<P>Первоначально, прежде, чем выполнились любые оптимизации, инструкция
<CODE>EXPLAIN</CODE> производит следующую информацию:</P>
<PRE>
table type possible_keys                key  key_len ref  rows  Extra
et    ALL  PRIMARY                      NULL NULL    NULL 74
do    ALL  PRIMARY                      NULL NULL    NULL 2135
et_1  ALL  PRIMARY                      NULL NULL    NULL 74
tt    ALL  AssignedPC,ClientID,ActualPC NULL NULL    NULL 3872
      range checked for each record (key map: 35)
</PRE>

<P>Поскольку <CODE>type</CODE> равен <CODE>ALL</CODE> для каждой таблицы,
этот вывод указывает, что MySQL делает полное объединение для всех таблиц!
Это займет очень длительное время, поскольку большое число строк в каждой
таблице должно быть исследовано! Для нашего случая это
<CODE>74*2135*74*3872=45268558720</CODE> строк. Если бы таблицы были больше,
Вы можете только воображать, как много времени потребуется.</P>

<P>Одна проблема здесь состоит в том, что MySQL не может использовать
индексы на столбцах эффективно, если они объявлены по-другому. В этом
контексте <CODE>VARCHAR</CODE> и <CODE>CHAR</CODE> то же самое, если они не
объявлены как различные длины. Потому, что <CODE>tt.ActualPC</CODE> определен
как <CODE>CHAR(10)</CODE>, а <CODE>et.EMPLOYID</CODE> объявлен как
<CODE>CHAR(15)</CODE>, имеется несоответствие длин.</P>

<P>Чтобы исправить это неравенство между длинами столбца, используйте
<CODE>ALTER TABLE</CODE>, чтобы удлинить <CODE>ActualPC</CODE> с 10 до 15:
</P>
<PRE>
mysql&#62; ALTER TABLE tt MODIFY ActualPC VARCHAR(15);
</PRE>

<P>Теперь <CODE>tt.ActualPC</CODE> и <CODE>et.EMPLOYID</CODE> равны
<CODE>VARCHAR(15)</CODE>. Выполнение инструкции <CODE>EXPLAIN</CODE>
производит этот результат:</P>
<PRE>
table type   possible_keys   key     key_len ref         rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL 3872    where used
do    ALL    PRIMARY         NULL    NULL    NULL        2135
      range checked for each record (key map: 1)
et_1  ALL    PRIMARY         NULL    NULL    NULL        74
      range checked for each record (key map: 1)
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC 1
</PRE>

<P>Это еще не совершенно, но намного лучше. Эта версия выполнена быстрее.</P>

<P>Второе исправление может быть сделано, чтобы устранить несоответствия длин
столбцов для сравнений <CODE>tt.AssignedPC=et_1.EMPLOYID</CODE> и
<CODE>tt.ClientID=do.CUSTNMBR</CODE>:</P>
<PRE>
mysql&#62; ALTER TABLE tt MODIFY AssignedPC VARCHAR(15),
                          MODIFY ClientID VARCHAR(15);
</PRE>

<P>Сейчас <CODE>EXPLAIN</CODE> выведет следующее:</P>
<PRE>
table type   possible_keys   key     key_len ref            rows     Extra
et    ALL    PRIMARY         NULL    NULL    NULL           74
tt    ref    AssignedPC,ClientID,ActualPC ActualPC 15 et.EMPLOYID 52 where used
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</PRE>

<P>Это почти столь же хорошо, как это возможно вообще. Но все же еще
недостаточно хорошо. Продолжим...</P>

<P>Остающаяся проблема состоит в том, что по умолчанию MySQL считает, что
значения в столбце <CODE>tt.ActualPC</CODE> равномерно распределены, а это не
имеет место для таблицы <CODE>tt</CODE>. Можно просто сообщить MySQL об этом:
</P>
<PRE>
shell&#62; myisamchk --analyze PATH_TO_MYSQL_DATABASE/tt
shell&#62; mysqladmin refresh
</PRE>

<P>Теперь объединение совершенно, и <CODE>EXPLAIN</CODE> выведет такой отчет:
</P>
<PRE>
table type   possible_keys   key     key_len ref            rows    Extra
tt    ALL    AssignedPC,ClientID,ActualPC NULL NULL NULL    3872    where used
et    eq_ref PRIMARY         PRIMARY 15      tt.ActualPC    1
et_1  eq_ref PRIMARY         PRIMARY 15      tt.AssignedPC  1
do    eq_ref PRIMARY         PRIMARY 15      tt.ClientID    1
</PRE>

<P>Обратите внимание, что столбец <CODE>rows</CODE> в выводе
<CODE>EXPLAIN</CODE> представляет собой обучаемое предположение оптимизатора
объединения MySQL. Чтобы оптимизировать запрос, Вы должны проверить, являются
ли числа близкими к истине. Если это не так, Вы можете получить лучшую
эффективность, используя <CODE>STRAIGHT_JOIN</CODE> в Вашей инструкции
<CODE>SELECT</CODE> и пробуя внести в список таблицы в различном порядке в
предложении <CODE>FROM</CODE> запроса.</P>

<H3><A NAME="Estimating_performance">5.2.2
Ожидаемая производительность запросов</A></H3>
<P>В большинстве случаев Вы можете оценивать эффективность, считая дисковые
установки. Для маленьких таблиц Вы можете обычно находить строку за одну
дисковую установку (поскольку индекс, вероятно, кэшируется). Для больших
таблиц Вы можете оценивать (используя индексы дерева B++), что надо
<CODE>log(число строк)/log(длина блока индекса/3*2/(длина индекса+длина
указателя данных))+1</CODE> установок, чтобы найти строку.</P>

<P>В MySQL блок индекса обычно равен 1024 байтам, а длина указателя данных
составляет 4 байта. 500000 строк с индексом длиной в 3 (medium integer)
обрабатываются за <CODE>log(500000)/log(1024/3*2/(3+4))+1</CODE>=4.</P>

<P>Поскольку вышеупомянутый индекс требовал бы приблизительно
500000*7*3/2=5.2M (считается, что индексные буфера заполнены на 2/3, что
является типичным), Вы будете, вероятно, иметь многое из индекса в памяти, и
Вы будете, вероятно, нуждаться только в 1-2 обращениях, чтобы читать данные
из OS, чтобы найти строку.</P>

<P>Для записи, однако, Вы будете нуждаться в 4 запросах установки (как
показано выше), чтобы найти, где поместить новый индекс, и обычно в 2
установках, чтобы модифицировать индекс и записать строку данных.</P>

<P>Обратите внимание, что вышеупомянутое не означает, что Ваша прикладная
программа будет требовать сложности N log N! Пока все кэшируется OS
или SQL-сервером, работа будет идти только незначительно медленнее в то
время, как таблица становится большей. После того, как данные становятся
слишком большими, чтобы кэшироваться, работа будет идти намного медленнее,
пока Ваши прикладные программы ограничены дисковыми установками (которые
растут как N log N). Чтобы избежать этого, увеличьте индексный кэш, поскольку
данные растут. Подробности в разделе
"<A HREF="#Server_parameters">5.5.2 Настройка параметров сервера
</A>".</P>

<H3><A NAME="SELECT_speed">5.2.3 Скорость запросов <CODE>SELECT</CODE></A>
</H3>
<P>Вообще, когда Вы хотите сделать медленный <CODE>SELECT ... WHERE</CODE>
быстрее, первое, что подлежит проверке, можете или нет Вы добавить индекс.
Подробности в разделе "<A HREF="#MySQL_indexes">5.4.3 Как MySQL
использует индексы</A>". Все ссылки между различными таблицами должны обычно
делаться с индексами. Вы можете использовать команду <CODE>EXPLAIN</CODE>,
чтобы определить, которые индексы используются для <CODE>SELECT</CODE>.
Подробности в разделе "<A HREF="#EXPLAIN">5.2.1 Синтаксис
<CODE>EXPLAIN</CODE> (получение информации о <CODE>SELECT</CODE>)</A>".
Некоторые общие советы:</P>

<UL><LI>Чтобы оптимизировать запросы лучше, выполните <CODE>myisamchk
--analyze</CODE> на таблице после того, как она была загружена релевантными
данными. Это модифицирует значение для каждой индексной части, которая
указывает среднее число строк, которые имеют то же самое значение. Для
уникальных индексов, это всегда 1, конечно. MySQL использует это, чтобы
решить, которые индексы выбрать, когда Вы подключаете две таблицы с
неконстантным выражением. Вы можете проверять результат из
<CODE>analyze</CODE> выполнением <CODE>SHOW INDEX FROM table_name</CODE> и
исследования столбца <CODE>Cardinality</CODE>.

<LI>Чтобы сортировать индекс и данные согласно индексу, используйте
<CODE>myisamchk --sort-index --sort-records=1</CODE> (если Вы хотите
сортировать на индексе 1). Если Вы имеете уникальный индекс, из которого Вы
хотите читать все записи, это хороший способ сделать процесс быстрее.
Обратите внимание, однако, что эта сортировка не написана оптимально и будет
брать довольно длительное время для большой таблицы!</UL>

<H3><A NAME="Where_optimizations">5.2.4
Как MySQL оптимизирует предложение <CODE>WHERE</CODE></A></H3>
<P>Оптимизация <CODE>WHERE</CODE> помещена в часть <CODE>SELECT</CODE> потому,
что она обычно используется с <CODE>SELECT</CODE>, но теми же самыми методами
оптимизируются инструкции <CODE>DELETE</CODE> и <CODE>UPDATE</CODE>.</P>

<P>Также обратите внимание, что этот раздел незавершен. MySQL делает много
оптимизаций, и авторы пакета не имели времени, чтобы документировать их все.
</P>

<P>Некоторые из оптимизаций, выполняемых MySQL перечислены ниже:</P>
<UL><LI>Удаление ненужных круглых скобок:
<PRE>
   ((a AND b) AND c OR (((a AND b) AND (c AND d))))
-&#62; (a AND b AND c) OR (a AND b AND c AND d)
</PRE>

<LI>Свертывание констант:
<PRE>
   (a&#60;b AND b=c) AND a=5
-&#62; b&#62;5 AND b=c AND a=5
</PRE>

<LI>Постоянное удаление условия (необходимо из-за свертывания констант):
<PRE>
   (B&#62;=5 AND B=5) OR (B=6 AND 5=5) OR (B=7 AND 5=6)
-&#62; B=5 OR B=6
</PRE>

<LI>Постоянные выражения, используемые индексами, оценены только однажды.

<LI><CODE>COUNT(*)</CODE> на одиночной таблице без <CODE>WHERE</CODE>
получен непосредственно из информации таблицы. Это также выполнено для любого
выражения <CODE>NOT NULL</CODE>, когда используется только с одной таблицей.

<LI>Раннее обнаружение недопустимых постоянных выражений. MySQL быстро
обнаруживает, что некоторые инструкции <CODE>SELECT</CODE> невозможны, и не
возвращает никаких строк.

<LI><CODE>HAVING</CODE> объединено с <CODE>WHERE</CODE>, если Вы не
используете <CODE>GROUP BY</CODE> или групповые функции
(<CODE>COUNT()</CODE>, <CODE>MIN()</CODE>...).

<LI>Для каждого подобъединения более простой <CODE>WHERE</CODE> будет создан,
чтобы получить быструю оценку <CODE>WHERE</CODE> для каждого подобъединения,
а также пропускать все записи как можно скорее.

<A NAME="IDX843"></A><A NAME="IDX844"></A><LI>Все постоянные таблицы читаются
сначала, перед любыми другими таблицами в запросе. Постоянная таблица:
<UL><LI>Пустая таблица или таблица с 1 строкой.
<LI>Таблица, которая используется с предложением <CODE>WHERE</CODE> на
индексе <CODE>UNIQUE</CODE> или <CODE>PRIMARY KEY</CODE>, где все индексные
части используются с постоянными выражениями и индексными частями, определена
как <CODE>NOT NULL</CODE>.</UL>

Все следующие таблицы используются как постоянные таблицы:
<PRE>
mysql&#62; SELECT * FROM t WHERE primary_key=1;
mysql&#62; SELECT * FROM t1,t2
           WHERE t1.primary_key=1 AND t2.primary_key=t1.id;
</PRE>

<LI>Самая лучшая комбинация объединений, чтобы соединить таблицы будет
найдена, пробуя все возможности. Если все столбцы в <CODE>ORDER BY</CODE> и в
<CODE>GROUP BY</CODE> исходят из той же самой таблицы, то эта таблица
использована сначала при объединении.

<LI>Если имеется предложение <CODE>ORDER BY</CODE> и отличное от него
предложение <CODE>GROUP BY</CODE>, или если <CODE>ORDER BY</CODE> или
<CODE>GROUP BY</CODE> содержит столбцы из таблиц, иных, чем первая таблица в
очереди объединений, создается временная таблица.

<LI>Если Вы используете <CODE>SQL_SMALL_RESULT</CODE>, MySQL использует
временную таблицу в памяти.

<LI>Каждый индекс таблицы делает запрос, и самый лучший индекс, который
охватывает меньшее количество, чем 30% строк, используется. Если никакой
такой индекс не может быть найден, применяется быстрый просмотр таблицы.

<LI>В некоторых случаях MySQL может читать строки из индекса без консультации
с файлом данных. Если все столбцы, взятые из индекса, числовые, то только
индексное дерево используется, чтобы решить запрос.

<LI>Прежде, чем каждая запись выводится, те, которые не соответствуют
предложению <CODE>HAVING</CODE>, будут пропущены.</UL>

<P>Некоторые примеры запросов, которые являются очень быстрыми:</P>
<PRE>
mysql&#62; SELECT COUNT(*) FROM tbl_name;
mysql&#62; SELECT MIN(key_part1),MAX(key_part1) FROM tbl_name;
mysql&#62; SELECT MAX(key_part2) FROM tbl_name WHERE key_part_1=constant;
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1,key_part2,...
                      LIMIT 10;
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1 DESC,key_part2
                      DESC,... LIMIT 10;
</PRE>

<P>Следующие запросы решены, используя только индексное дерево (все
индексированные столбцы числовые):</P>
<PRE>
mysql&#62; SELECT key_part1,key_part2 FROM tbl_name WHERE key_part1=val;
mysql&#62; SELECT COUNT(*) FROM tbl_name WHERE key_part1=val1 AND
                  key_part2=val2;
mysql&#62; SELECT key_part2 FROM tbl_name GROUP BY key_part1;
</PRE>

<P>Следующие запросы применяют индексы, чтобы получить строки в сортируемом
порядке без отдельного прохода сортировки:</P>
<PRE>
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1,key_part2,... ;
mysql&#62; SELECT ... FROM tbl_name ORDER BY key_part1 DESC,key_part2
                      DESC,... ;
</PRE>

<H3><A NAME="DISTINCT_optimization">5.2.5
Как MySQL оптимизирует <CODE>DISTINCT</CODE></A></H3>
<P><CODE>DISTINCT</CODE> преобразован в <CODE>GROUP BY</CODE> на всех
столбцах, <CODE>DISTINCT</CODE> объединенный с <CODE>ORDER BY</CODE> тоже
будет во многих случаях нуждаться во временной таблице.</P>

<P>При объединении <CODE>LIMIT #</CODE> с <CODE>DISTINCT</CODE>, MySQL
остановится, как только успешно найдет <CODE>#</CODE> уникальных строк.</P>

<P>Если Вы не используете столбцы из всех применяемых таблиц, MySQL остановит
просмотр неиспользуемых таблиц, как только найдет первое соответствие.</P>
<PRE>
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
</PRE>

<P>В этом случае t1 используется прежде t2 (проверьте с помощью
<CODE>EXPLAIN</CODE>), затем MySQL перестанет читать из t2 (для той
специфической строки в t1), когда первая строка в t2 будет найдена.</P>

<H3><A NAME="LEFT_JOIN_optimization">5.2.6 Как MySQL оптимизирует
<CODE>LEFT JOIN</CODE> и <CODE>RIGHT JOIN</CODE>
</A></H3>
<P>Действие <CODE>A LEFT JOIN B</CODE> в MySQL выполнено следующим образом:
</P>

<UL><LI>Таблица <CODE>B</CODE> установлена, чтобы зависеть от таблицы
<CODE>A</CODE>, и всех таблиц, которые зависят от <CODE>A</CODE>.

<LI>Таблица установлена <CODE>A</CODE>, чтобы зависеть от всех таблиц за
исключением <CODE>B</CODE>, которые используются в
условии <CODE>LEFT JOIN</CODE>.

<LI>Все условия <CODE>LEFT JOIN</CODE> перемещаются в <CODE>WHERE</CODE>.

<LI>Все стандартные оптимизации объединения выполнены за исключением того,
что таблица всегда читается после всех таблиц, от которых она зависит. Если
имеется круговая зависимость, то MySQL выдаст ошибку.

<LI>Все стандартные оптимизации <CODE>WHERE</CODE> выполнены.

<LI>Если имеется строка в <CODE>A</CODE>, которая соответствует предложению
<CODE>WHERE</CODE>, но не имеется никакой строки в <CODE>B</CODE>, которая
соответствует условию <CODE>LEFT JOIN</CODE>, то дополнительные строки
<CODE>B</CODE> сгенерированы со всем набором столбцов в <CODE>NULL</CODE>.

<LI>Если Вы используете <CODE>LEFT JOIN</CODE>, чтобы найти строки, которые
не существуют в некоторой таблице, и Вы имеете следующий тест:
<CODE>column_name IS NULL</CODE> в части <CODE>WHERE</CODE>, где column_name
представляет собой столбец, который объявлен как <CODE>NOT NULL</CODE>, то
MySQL перестанет искать после большего количества строк (для специфической
комбинации ключа после того, как найдет одну строку, которая соответствует
условию <CODE>LEFT JOIN</CODE>).</UL>

<P><CODE>RIGHT JOIN</CODE> реализован аналогично <CODE>LEFT JOIN</CODE>.</P>

<P>Порядок чтения таблицы, принудительно заданный <CODE>LEFT JOIN</CODE> и
<CODE>STRAIGHT JOIN</CODE>, поможет оптимизатору объединения (который
вычисляет, в каком порядке таблицы должны быть соединены) сделать работу
намного быстрее, так как имеется меньшее количество перестановок таблицы,
которые надо проверить.</P>

<P>Обратите внимание, что вышеупомянутое означает, что, если Вы делаете
запрос типа:</P>
<PRE>
SELECT * FROM a,b LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key)
         WHERE b.key=d.key
</PRE>

<P>MySQL будет делать полный просмотр <CODE>b</CODE>, поскольку <CODE>LEFT
JOIN</CODE> вынудит это читаться прежде, чем <CODE>d</CODE>.</P>

<P>Исправление в этом случае должно изменить запрос на:</P>
<PRE>
SELECT * FROM b,a LEFT JOIN c ON (c.key=a.key) LEFT JOIN d (d.key=a.key)
         WHERE b.key=d.key
</PRE>

<H3><A NAME="LIMIT_optimization">5.2.7
Как MySQL оптимизирует <CODE>LIMIT</CODE></A></H3>
<P>В некоторых случаях MySQL обработает запрос по-другому, когда Вы
используете <CODE>LIMIT #</CODE> и не используете <CODE>HAVING</CODE>:</P>

<UL><LI>Если Вы выбираете только несколько строк с <CODE>LIMIT</CODE>, MySQL
использует индексы в некоторых случаях, когда он обычно предпочел бы сделать
полный просмотр таблицы.

<LI>Если Вы используете <CODE>LIMIT #</CODE> в сочетании с <CODE>ORDER
BY</CODE>, MySQL закончит сортировку, как только найдет первые <CODE>#</CODE>
строк вместо того, чтобы сортировать целую таблицу.

<LI>При объединении <CODE>LIMIT #</CODE> с <CODE>DISTINCT</CODE> MySQL
остановится, как только найдет <CODE>#</CODE> уникальных строк.

<LI>В некоторых случаях <CODE>GROUP BY</CODE> может быть решено, читая ключ
по порядку (или сортируя по ключу) с последующим вычислением результата до
изменений значения ключа. В этом случае <CODE>LIMIT #</CODE> не будет
вычислять никакую ненужную операцию <CODE>GROUP BY</CODE>.

<LI>Как только MySQL послал первые <CODE>#</CODE> строк пользователю, он
прервет текущий запрос.

<LI><CODE>LIMIT 0</CODE> будет всегда быстро возвращать пустой набор. Это
полезно, чтобы проверить запрос и получить типы столбцов результата.

<LI>Размер временных таблиц использует <CODE>LIMIT #</CODE>, чтобы вычислить,
сколько места необходимо, чтобы решить этот запрос.</UL>

<H3><A NAME="Insert_speed">5.2.8 Скорость запросов <CODE>INSERT</CODE></A>
</H3>
<P>Время, нужное, чтобы вставить запись, состоит приблизительно из:</P>
<UL><LI>Установление связи:          (3)
<LI>Отправка запроса на сервер:  (2)
<LI>Обработка запроса:           (2)
<LI>Вставка записей:             (1 x число записей)
<LI>Вставка индексов:            (1 x количество индексов)
<LI>Завершение сеанса:           (1)</UL>

<P>Здесь числа пропорциональны полному времени. Это не учитывает время,
нужное, чтобы открыть таблицы (это выполнено лишь однажды для каждого
одновременно выполняемого запроса).</P>

<P>Размер таблицы замедляет вставку индексов на N log N (B-деревья).</P>

<P>Некоторые способы ускорить вставки:</P>
<UL><LI>Если Вы вставляете много строк от того же самого пользователя в то же
самое время, используйте многократные инструкции со списком значений
<CODE>INSERT</CODE>. Это намного быстрее, чем использование отдельных
инструкций <CODE>INSERT</CODE>. Грамотная настройка переменной
<CODE>myisam_bulk_insert_tree_size</CODE> может сделать это даже быстрее.
Подробности в разделе "<A HREF="admin.htm#SHOW_VARIABLES">4.5.5.4
Синтаксис <CODE>SHOW VARIABLES</CODE></A>".

<LI>Если Вы вставляете много строк из различных клиентов, Вы можете получить
большее быстродействие, используя инструкцию <CODE>INSERT DELAYED</CODE>.

<LI>Обратите внимание, что с <CODE>MyISAM</CODE> Вы можете вставлять строки
в то же самое время, когда работает <CODE>SELECT</CODE>, если не имеется
никаких удаленных строк в таблицах.

<LI>При загрузке таблицы из текстового файла применяется <CODE>LOAD DATA
INFILE</CODE>. Это примерно в 20 раз быстрее, чем использование
набора команд <CODE>INSERT</CODE>.

<LI>Есть способ еще более ускорить <CODE>LOAD DATA INFILE</CODE>, когда
таблица имеет много индексов. Используйте следующую процедуру:
<OL><LI>Факультативно создайте таблицу с помощью <CODE>CREATE TABLE</CODE>.
Например, при использовании <CODE>mysql</CODE> или Perl-DBI.

<LI>Выполните инструкцию <CODE>FLUSH TABLES</CODE> или команду оболочки
<CODE>mysqladmin flush-tables</CODE>.

<LI>Используйте <CODE>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</CODE>.
Это удалит все применяемые индексы из таблицы.

<LI>Вставьте данные в таблицу с помощью вызова <CODE>LOAD DATA INFILE</CODE>.
Это не будет модифицировать никакие индексы вообще и, следовательно, будет
работать очень быстро.

<LI>Если Вы собираетесь только читать таблицу в будущем, выполните
<CODE>myisampack</CODE>, чтобы сделать ее еще меньше. Подробности в разделе
<A HREF="myisam.htm#Compressed_format">7.1.2.3 Характеристики сжатых таблиц
</A>".

<LI>Освежите индексы с помощью <CODE>myisamchk -r -q
/path/to/db/tbl_name</CODE>. Это создаст индексное дерево в памяти перед
записью его на диск, что является намного быстрее потому, что это избегает
большого количества дисковых установок. Возникающее в результате индексное
дерево также совершенно сбалансировано.

<LI>Выполните инструкцию <CODE>FLUSH TABLES</CODE> или команду оболочки
<CODE>mysqladmin flush-tables</CODE>.</OL>

Эта процедура будет встроена в <CODE>LOAD DATA INFILE</CODE> в некоторой
будущей версии MySQL. Начиная с <STRONG>MySQL 4.0</STRONG>, Вы также можете
использовать <CODE>ALTER TABLE tbl_name DISABLE KEYS</CODE> вместо
<CODE>myisamchk --keys-used=0 -rq /path/to/db/tbl_name</CODE> и
<CODE>ALTER TABLE tbl_name ENABLE KEYS</CODE> вместо
<CODE>myisamchk -r -q /path/to/db/tbl_name</CODE>. Этим путем Вы также
можете обойти шаг <CODE>FLUSH TABLES</CODE>.

<LI>Вы можете ускорить вставки, блокируя Ваши таблицы:
<PRE>
mysql&#62; LOCK TABLES a WRITE;
mysql&#62; INSERT INTO a VALUES (1,23),(2,34),(4,33);
mysql&#62; INSERT INTO a VALUES (8,26),(6,29);
mysql&#62; UNLOCK TABLES;
</PRE>

Основное различие в быстродействии в том, что буфер индексов сбрасывают на
диск только однажды после того, как все инструкции <CODE>INSERT</CODE>
завершили. Обычно имелось бы так много индексных буферных потоков, сколько
есть различных инструкций <CODE>INSERT</CODE>. Блокировка не является
необходимой, если Вы можете вставлять все строки с одиночной инструкцией.
Блокировка будет также снижать общее время тестов с несколькими
подключениями, но максимальное время ожидания для некоторых потоков повысится
(потому, что они ждут блокировки). Например:
<PRE>
thread 1 does 1000 inserts
thread 2, 3, and 4 does 1 insert
thread 5 does 1000 inserts
</PRE>

Если Вы не используете блокировку, 2, 3 и 4 закончаться перед 1 и 5. Если Вы
используете блокировку, 2, 3 и 4, вероятно, не будут заканчиваться прежде,
чем 1 или 5, но общее время должно быть приблизительно на 40% лучше. Так как
операции <CODE>INSERT</CODE>, <CODE>UPDATE</CODE> и <CODE>DELETE</CODE> очень
быстры в MySQL, Вы получите лучшую полную эффективность, добавляя блокировки
вокруг всего, что делает больше, чем приблизительно 5 вставок или модификаций
в строке. Если Вы делаете очень много вставок в строке, Вы могли бы делать
<CODE>LOCK TABLES</CODE>, сопровождаемые <CODE>UNLOCK TABLES</CODE> время от
времени (примерно каждые 1000 строк), чтобы позволить другим потокам доступ к
таблице. Конечно же, <CODE>LOAD DATA INFILE</CODE> все равно намного быстрее
для загрузки данных.</UL>

<P>Чтобы дополнительно получить несколько большее быстродействие для операций
<CODE>LOAD DATA INFILE</CODE> и <CODE>INSERT</CODE>, увеличьте буфер ключа.
Подробности в разделе "<A HREF="#Server_parameters">5.5.2
Настройка параметров сервера</A>".</P>

<H3><A NAME="Update_speed">5.2.9 Скорость запросов <CODE>UPDATE</CODE></A>
</H3>
<P>Запросы модификации оптимизированы как запрос <CODE>SELECT</CODE>.
Быстродействие дополнительной записи зависит от размера данных, которые
изменяются, и числа индексов, в которые вносятся поправки. Индексы, которые
не изменены, не будет модифицироваться.</P>

<P>Также, другой способ получать быстрые модификации состоит в том, чтобы
задержать модификации, а затем сделать много модификаций в строке позже.
Выполнение многих модификаций в строке намного более быстрое, чем выполнение
их по одной, если Вы блокируете таблицу.</P>

<P>Обратите внимание, что, при работе с динамическим форматом записи
модификация записи на более длинную может привести к разделению ее на
фрагменты. Так что, если Вы делаете это часто, очень важно иногда вызывать
<CODE>OPTIMIZE TABLE</CODE>. Подробности в разделе
"<A HREF="admin.htm#OPTIMIZE_TABLE">4.5.1 Синтаксис <CODE>OPTIMIZE TABLE
</CODE></A>".</P>

<H3><A NAME="Delete_speed">5.2.10 Скорость запросов <CODE>DELETE</CODE></A>
</H3>
<P>Если надо удалить все строки из таблицы, примените вызов
<CODE>TRUNCATE TABLE table_name</CODE>.</P>

<P>Время, нужное, чтобы удалить запись, точно пропорционально числу индексов.
Чтобы удалять записи быстрее, Вы можете увеличивать размер индексного кэша.
Подробности в разделе "<A HREF="manual.htm#Server_parameters">5.5.2
Настройка параметров сервера</A>".</P>

<H3><A NAME="Tips">5.2.11 Другие советы по оптимизации</A></H3>
<UL><LI>Используйте постоянные подключения к базе данных, чтобы избежать
накладных расходов на текущие подключения. Если Вы не можете использовать
постоянные подключения, и Вы делаете много новых подключений, стоит изменить
значение переменной <CODE>thread_cache_size</CODE>. Подробности в разделе
"<A HREF="manual.htm#Server_parameters">5.5.2 Настройка параметров сервера
</A>".

<LI>Обязательно проверьте, что все Ваши запросы в самом деле используют
индексы, которые Вы создали в таблицах. В MySQL Вы можете сделать это
командой <CODE>EXPLAIN</CODE>. Подробности в разделе
"<A HREF="#EXPLAIN">5.2.1 Синтаксис <CODE>EXPLAIN</CODE>
(получение информации о <CODE>SELECT</CODE>)</A>".

<LI>Избегайте сложных запросов <CODE>SELECT</CODE> на таблицах, которые часто
модифицируются. Это должно помочь избежать проблем с блокировкой таблицы.

<LI>Новые таблицы <CODE>MyISAM</CODE> могут вставлять строки в таблицу без
удаленных строк в то же самое время, когда другой запрос ведет чтение. Если
это важно для Вас, Вы должны рассмотреть методы, где Вы не должны удалить
строки или выполните <CODE>OPTIMIZE TABLE</CODE> после того, как Вы удалили
много строк сразу.

<LI>Используйте вызов <CODE>ALTER TABLE ... ORDER BY expr1,expr2...</CODE>
если Вы обычно получаете строки в порядке expr1,expr2,... . Используя эту
опцию после внесения больших изменений для таблицы, Вы можете получить
значительно более высокую эффективность.

<LI>В некоторых случаях может иметь смысл представлять столбец, который
является хэшем, основанным на информации из других столбцов. Если этот
столбец короткий и приемлемо уникальный, это может быть намного быстрее, чем
большой индекс на многих столбцах. В MySQL это очень легко в использовании:
<CODE>SELECT * FROM table_name WHERE hash=MD5(concat(col1,col2)) AND
col_1='constant' AND col_2='constant'</CODE>

<LI>Для таблиц, которые часто изменяются, Вы должен пробовать избежать любых
столбцов типов <CODE>VARCHAR</CODE> или <CODE>BLOB</CODE>. Вы получите
динамическую длину строки, как только Вы используете хоть один стобец
<CODE>VARCHAR</CODE> или <CODE>BLOB</CODE>. Подробности в разделе
"<A HREF="glava07.htm#Table_types">7 Типы таблиц MySQL</A>".

<LI>Если Вы очень часто должны вычислять значения, основанные на информации
из большого количества строк (подобно количеству), вероятно, намного лучше
представить новую таблицу и модифицировать счетчик в реальном времени.
Модификация типа <CODE>UPDATE table set count=count+1 where
index_column=constant</CODE> очень быстрая! Это действительно важно, когда Вы
используете базы данных подобные MySQL, которые имеют только блокировку
уровня таблицы. Это также даст лучшую эффективность с большинством баз
данных, поскольку администратор блокировки строки в этом случае будет иметь
куда меньше работы.

<LI>Если Вы должны собрать статистику из больших таблиц файла регистрации,
используйте итоговые таблицы вместо того, чтобы просмотреть целую таблицу.
Поддержание резюме должно быть намного быстрее, чем попытка сделать живую
статистику. Намного быстрее получить новые итоговые таблицы из файлов
регистрации, когда происходит изменение, чем менять работающее приложение!

<LI>Если возможно, нужно классифицировать отчеты как "живые" или
"статистические", где данные, необходимые для статистических отчетов,
сгенерированы только, исходя из итоговых таблиц, которые в свою очередь были
сгенерированы из фактических данных.

<LI>Воспользуйтесь преимуществом того факта, что столбцы имеют значения по
умолчанию. Вставляйте значения явно только, когда значение, которое будет
вставлено, отличается от значения по умолчанию. Это уменьшает синтаксический
анализ, который MySQL должен сделать, и улучшает быстродействие вставки.

<LI>В некоторых случаях удобно упаковывать и сохранить данные в blob. В этом
случае Вы должны добавить некоторый дополнительный код к Вашей прикладной
программе, чтобы упаковать/распаковать данные, но это может сохранить много
времени доступа в некоторой стадии. Это удобно, когда Вы имеете данные,
которые явно не соответствуют статической структуре таблицы.

<LI>Обычно Вы должны пробовать хранить все данные неизбыточными (что названо
третьей нормальной формой в теории базы данных), но Вы не должны бояться
дублирования или создания таблиц-резюме, если Вы нуждаетесь в них, чтобы
получить большее быстродействие.

<LI>Сохраненные процедуры или UDF (определяемой пользователем функции) может
быть хорошим способом получить большую эффективность. В этом случае Вы
должны, однако, всегда иметь способ делать это некоторым другим (более
медленным) путем, если Вы используете СУБД, которая не поддерживает это.

<LI>Вы можете всегда получать неплохие результаты, кэшируя запросы/ответы в
Вашей прикладной программе и пробуя делать много вставок/модификаций в то же
самое время. Если Ваша база данных поддерживает блокировки таблиц (подобно
MySQL и Oracle), это должно помочь гарантировать, что индексный кэш
сбрасывается только однажды после выполнения всех модификаций.

<LI>Используйте <CODE>INSERT /*! DELAYED */</CODE>, если Вы не должны знать,
когда Ваши данные будут записаны. Это ускоряет дела потому, что много записей
могут быть выполнены за один дисковый обмен.

<LI>Используйте <CODE>INSERT /*! LOW_PRIORITY */</CODE>, когда Вы хотите,
чтобы Ваши вызовы select были более важными.

<LI>Используйте <CODE>SELECT /*! HIGH_PRIORITY */</CODE>, чтобы получить
select, обходящий очередь. То есть select будет выполнен, даже если имеется
кто-то ждущий, чтобы сделать запись в таблицу.

<LI>Используйте многострочную инструкцию <CODE>INSERT</CODE>, чтобы сохранить
много строк одной командой SQL (многие серверы SQL поддерживают это).

<LI>Используйте <CODE>LOAD DATA INFILE</CODE>, чтобы загрузить большие
количества данных. Это быстрее, чем нормальные вставки, а будет еще быстрее,
когда <CODE>myisamchk</CODE> интегрирован в <CODE>mysqld</CODE>.

<LI>Используйте столбцы с поддержкой <CODE>AUTO_INCREMENT</CODE>, чтобы
сделать уникальные значения.

<LI>Используйте <CODE>OPTIMIZE TABLE</CODE> время от времени, чтобы избежать
фрагментации при использовании динамического формата таблицы. Подробности в
разделе "<A HREF="admin.htm#OPTIMIZE_TABLE">4.5.1
Синтаксис <CODE>OPTIMIZE TABLE</CODE></A>".

<LI>Используйте таблицы типа <CODE>HEAP</CODE>, чтобы получить большее
быстродействие, когда это возможно. Подробности в разделе
"<A HREF="glava07.htm#Table_types">7 Типы таблиц MySQL</A>".

<LI>При использовании нормальной установки Web-сервера, изображения должны
быть сохранены как файлы. То есть сохраните только ссылку на файл в базе
данных. Основная причина для этого в том, что нормальный Web-сервер намного
лучше при кэшировании файлов, чем содержание базы данных. Так что намного
проще получить быструю систему, если Вы используете файлы.

<LI>Используйте таблицы в памяти для некритических данных, к которым
обращаются часто (подобно информации относительно последнего показанного
баннера для пользователей, которые не имеют cookie).

<LI>Столбцы с идентичной информацией в различных таблицах должны быть
объявлены идентично и иметь одинаковые имена. До Version 3.23 Вы получали
медленные объединения в противном случае. Старайтесь делать имена проще
(например, <CODE>name</CODE> вместо <CODE>customer_name</CODE> в таблице
заказчиков). Чтобы сделать Ваши имена переносными на другие SQL-серверы, Вы
должны озаботиться тем, чтобы они не превышали в длину 18 символов.

<LI>Если Вы нуждаетесь в ДЕЙСТВИТЕЛЬНО высокой скорости, Вы должны смотреть
на интерфейсы низкого уровня для хранения данных, которые поддерживают
различные серверы SQL! Например, обращаясь к MySQL <CODE>MyISAM</CODE>
непосредственно, Вы могли бы получить увеличение быстродействия в 2-5 раз в
сравнении с использованием интерфейса SQL. Чтобы сделать это, данные должны
быть на том же самом сервере, что и прикладная программа, и обычно к ним
можно обратиться только одним процессом (потому, что внешняя блокировка файла
работает очень медленно). Можно было устранить вышеупомянутые проблемы,
представляя команды <CODE>MyISAM</CODE> низкого уровня в сервере MySQL (это
могло бы быть одним простым способом получить большее количество
эффективности, если необходимо).

<LI>Во многих случаях быстрее обратиться к данным из базы данных (используя
открытое подключение), чем к текстовому файлу только потому, что база данных,
вероятно, будет более компактна, чем текстовый файл (если Вы используете
числовые данные), и это потребует меньшее количество дисковых доступов. Вы
также уменьшите код потому, что Вы не должны анализировать Ваши текстовые
файлы, чтобы найти в них границы столбца и строки.

<LI>Вы можете также использовать репликацию, чтобы ускорить работу.
Подробности в разделе "<A HREF="replicat.htm#Replication">4.10 Репликация в
MySQL</A>".

<LI>Объявление таблицы с <CODE>DELAY_KEY_WRITE=1</CODE> будет делать
модифицирование индексов быстрее, поскольку они не регистрируются на диске,
пока файл не закрыт. Обратная сторона в том, что Вы должны выполнить
<CODE>myisamchk</CODE> на этих таблицах прежде, чем Вы запускаете
<CODE>mysqld</CODE>, чтобы гарантировать, что они правильные, если что-то
уничтожило <CODE>mysqld</CODE> в середине запроса. Поскольку информация ключа
может всегда генерироваться из данных, Вы не должны терять что-нибудь,
используя <CODE>DELAY_KEY_WRITE</CODE>.</UL>

<H2><A NAME="Locking_Issues">5.3 Проблемы блокировки</A></H2>

<H3><A NAME="Internal_locking">5.3.1 Как MySQL блокирует таблицы</A></H3>
<P>Вы можете найти обсуждение различных методов блокировки в приложении.
Подробности в разделе "<A HREF="glava06.htm#Locking_methods">6.4
Методы для блокировки</A>".</P>

<P>Вся блокировка в MySQL свободна от тупика. Она управляется, всегда
запрашивая все необходимые блокировки сразу в начале запроса и всегда
блокируя таблицы в том же самом порядке.</P>

<P>Метод блокировки MySQL, использованный для операции <CODE>WRITE</CODE>,
работает следующим образом:</P>

<UL><LI>Если не имеется никаких блокировок на таблице, поместить блокировку
записи на нее.
<LI>Иначе поместить запрос блокировки в очередь блокировок записи.</UL>

<P>Метод блокировки MySQL, использованный для операции <CODE>READ</CODE>,
работает следующим образом:</P>

<UL><LI>Если не имеется блокировки записи на таблице, поместить блокировку
чтения на нее.
<LI>Иначе поместить запрос блокировки в очередь блокировок чтения.</UL>

<P>Когда блокировка освобождается, она становится доступной потокам в очереди
блокировок записи, а после них потокам в очереди блокировок чтения.</P>

<P>Это означает, что, если Вы имеете много модификаций на таблице, инструкции
<CODE>SELECT</CODE> будут ждать до окончания всех модификаций.</P>

<P>Чтобы обойти это для случая, где Вы хотите делать много операций
<CODE>INSERT</CODE> и <CODE>SELECT</CODE> на таблице, Вы можете вставлять
строки во временную таблицу и периодически модифицировать реальную таблицу
записями из временной таблицы.</P>

<P>Это может быть выполнено кодом:
<PRE>
mysql&#62; LOCK TABLES real_table WRITE, insert_table WRITE;
mysql&#62; insert into real_table select * from insert_table;
mysql&#62; TRUNCATE TABLE insert_table;
mysql&#62; UNLOCK TABLES;
</PRE>

<P>Вы можете использовать параметр <CODE>LOW_PRIORITY</CODE> с инструкциями
<CODE>INSERT</CODE>, <CODE>UPDATE</CODE> или <CODE>DELETE</CODE>, а
<CODE>HIGH_PRIORITY</CODE> только с <CODE>SELECT</CODE>, если Вы хотите
располагать по приоритетам поиск в некоторых специфических случаях. Вы можете
также запустить <CODE>mysqld</CODE> с параметром
<CODE>--low-priority-updates</CODE>, чтобы получить тот же самое поведение.
</P>

<P>Использование <CODE>SQL_BUFFER_RESULT</CODE> может также сделать
блокировку таблицы короче.</P>

<P>Вы могли бы также изменять код блокировки в <TT>mysys/thr_lock.c</TT>,
чтобы использовать одиночную очередь. В этом случае блокировки записи и
чтения имели бы тот же самый приоритет, что может помочь некоторым программам.
</P>

<H3><A NAME="Table_locking">5.3.2 Советы по блокировке таблицы</A></H3>
<P>Код блокировки таблиц в MySQL свободен от тупиков.</P>

<P>MySQL использует блокировку таблицы (вместо блокировки строки или столбца)
на всех типах таблицы, за исключением <CODE>BDB</CODE>, чтобы достичь очень
высокого быстродействия блокировки. Для больших таблиц блокировка таблицы
НАМНОГО лучше, чем блокировка строки для большинства прикладных программ, но
имеются, конечно, некоторые ловушки.</P>

<P>Для таблиц типов <CODE>BDB</CODE> и <CODE>InnoDB</CODE> MySQL использует
блокировку таблицы только, если Вы скомандовали <CODE>LOCK TABLES</CODE> или
выполняете команду, которая изменит каждую строку в таблице подобно
<CODE>ALTER TABLE</CODE>. Для этих типов таблицы я рекомендую Вам не
использовать <CODE>LOCK TABLES</CODE> вообще.</P>

<P>В MySQL Version 3.23.7 и выше Вы можете вставлять строки в таблицы типа
<CODE>MyISAM</CODE> в то же самое время, когда другие потоки читают из
таблицы. Обратите внимание, что в настоящее время это работает только, если
не имеется никаких отверстий после удаленных строк в таблице во время
вставки. Когда все отверстия будут заполнены новыми данными, параллельные
вставки снова будут допускаться автоматически.</P>

<P>Блокировка таблицы дает возможность многим потокам читать из таблицы в то
же самое время, но если поток хочет писать в таблицу, он должен сначала
получить исключительный доступ. В течение модификации все другие потоки,
которые хотят обращаться к этой специфической таблице, будут ждать, пока
модификация не завершится.</P>

<P>Поскольку модификации на таблицах обычно являются более важными, чем
<CODE>SELECT</CODE>, все инструкции, которые модифицируют таблицу, имеют
более высокий приоритет, чем те инструкции, которые получают информацию из
таблицы. Вы можете изменять это, используя <CODE>LOW_PRIORITY</CODE> с
инструкцией, которая делает модификацию, или <CODE>HIGH_PRIORITY</CODE> с
<CODE>SELECT</CODE>).</P>

<P>Начиная с MySQL Version 3.23.7, можно использовать переменную
<CODE>max_write_lock_count</CODE>, чтобы заставить MySQL временно дать всем
инструкциям <CODE>SELECT</CODE>, которые ждут таблицу, более высокий
приоритет после специфического числа вставок на таблице.</P>

<P>Блокировка таблицы, однако, не очень хороша в следующих случаях:</P>
<UL><LI>Пользователь выдает <CODE>SELECT</CODE>, который берет длительное
время, чтобы выполниться.
<LI>Другой пользователь затем выдает <CODE>UPDATE</CODE> на используемой
таблице. Этот клиент будет ждать, пока <CODE>SELECT</CODE> не закончится.
<LI>Другой пользователь выдает другую инструкцию <CODE>SELECT</CODE>
относительно той же самой таблицы. Поскольку <CODE>UPDATE</CODE> имеет более
высокий приоритет, чем <CODE>SELECT</CODE>, этот <CODE>SELECT</CODE> будет
ждать <CODE>UPDATE</CODE>, чтобы закончиться. Это будет также ждать, когда
закончится первый <CODE>SELECT</CODE>!
<LI>Поток ждет нечто подобное <CODE>full disk</CODE>, когда все потоки,
которые хотят обращаться к прикладной таблице, будут также помещены в
состояние ожидания до тех пор, пока большее количество дискового пространства
не станет доступно.</UL>

<P>Некоторые решения для этой проблемы:</P>
<UL><LI>Попытайтесь получить ускорение инструкции <CODE>SELECT</CODE>. Вам,
вероятно, придется создавать некоторые итоговые таблицы, чтобы сделать это.

<LI>Запустите <CODE>mysqld</CODE> с опцией
<CODE>--low-priority-updates</CODE>. Это даст всем инструкциям, которые
модифицируют таблицу, более низкий приоритет, чем инструкции
<CODE>SELECT</CODE>. В этом случае последняя инструкция <CODE>SELECT</CODE> в
предыдущем сценарии выполнилась бы перед инструкцией <CODE>INSERT</CODE>.

<LI>Вы можете давать специфическую инструкцию <CODE>INSERT</CODE>,
<CODE>UPDATE</CODE> или <CODE>DELETE</CODE> с более низким приоритетом,
указав атрибут <CODE>LOW_PRIORITY</CODE>.

<LI>Запустите <CODE>mysqld</CODE> с низким значением для
<STRONG>max_write_lock_count</STRONG>, чтобы дать блокировки
<CODE>READ</CODE> после того, как отработает некоторое число блокировок
<CODE>WRITE</CODE>.

<LI>Вы можете определить, что все модификации из специфического потока
должны быть выполнены с низким приоритетом, используя команду SQL:
<CODE>SET SQL_LOW_PRIORITY_UPDATES=1</CODE>. Подробности в разделе
"<A HREF="#SET_OPTION">5.5.6 Синтаксис <CODE>SET</CODE></A>".

<LI>Вы можете определять, что специфический <CODE>SELECT</CODE> очень важен с
помощью атрибута <CODE>HIGH_PRIORITY</CODE>.

<LI>Если Вы имеете проблемы с <CODE>INSERT</CODE>, объединенной с
<CODE>SELECT</CODE>, переключитесь, чтобы использовать новые таблицы типа
<CODE>MyISAM</CODE>, поскольку они поддерживают параллельную работу вызовов
<CODE>SELECT</CODE> и <CODE>INSERT</CODE>.

<LI>Если Вы главным образом смешиваете инструкции <CODE>INSERT</CODE> и
<CODE>SELECT</CODE>, атрибут <CODE>DELAYED</CODE> в вызове
<CODE>INSERT</CODE>, вероятно, решит Ваши проблемы.

<LI>Если Вы имеете проблемы с <CODE>SELECT</CODE> и <CODE>DELETE</CODE>,
опция <CODE>LIMIT</CODE> в инструкции <CODE>DELETE</CODE> может помочь.</UL>

<H2><A NAME="Optimizing_Database_Structure">5.4
Оптимизация структуры базы данных</A></H2>

<H3><A NAME="Design">5.4.1 Выбор дизайна и интерьера</A></H3>
<P>MySQL хранит данные строк и индексные данные в отдельных файлах. Многие
(почти все) другие базы данных смешивают строки и индексные данные в том же
самом файле. Я полагаю, что выбор MySQL лучше для очень широкого диапазона
современных систем.</P>

<P>Другой способ сохранять данные строк состоит в том, чтобы хранить
информацию для каждого столбца в отдельной области (примеры: SDBM и Focus).
Это вызовет падение эффективности для каждого запроса, который обращается
больше, чем к одному столбцу. Эта модель далеко не хороша для построения
универсальных баз данных.</P>

<P>Более общий случай: индекс и данные сохранены вместе (подобно
Oracle/Sybase). В этом случае Вы найдете информацию строк в листе страниц
индекса. Хорошо с этим размещением то, что во многих случаях, в зависимости
от того, как хорошо индекс кэшируется, экономится медленное дисковое чтение.
Плохо с этим размещением то, что:</P>

<UL><LI>Просмотр таблицы намного медленнее потому, что Вы должны пролистать
индексы, чтобы добраться до данных.
<LI>Вы не можете использовать только индексную таблицу, чтобы получить данные
для решения запроса.
<LI>Вы теряете много места, поскольку Вы должны дублировать индексы из узлов
(поскольку Вы не можете сохранять строку в узлах).
<LI>Удаление будет вырождать таблицу через какое-то время (поскольку индексы
в узлах обычно не модифицируются на запросах удаления).
<LI>Тяжелее кэшировать ТОЛЬКО индексные данные.</UL>

<H3><A NAME="Data_size">5.4.2 Сделайте данные как можно меньше</A></H3>
<P>Одна из наиболее распространенных оптимизаций должна получить Ваши данные
и индексы, чтобы брать так мало места на диске, насколько возможно. Это может
давать огромные улучшения потому, что диск читается меньше, и оперативная
память экономится. Индексация также берет меньшее количество ресурсов, если
выполнена на меньших столбцах.</P>

<P>MySQL поддерживает много различных типов таблиц и форматов строк. Выбор
правильного формата таблицы может давать Вам большое усиление эффективности.
Подробности в разделе "<A HREF="glava07.htm#Table_types">7 Типы таблиц MySQL
</A>".</P>

<P>Вы можете получать лучшую эффективность на таблице и минимизировать
"складские площади" на диске, используя методы, перечисленные ниже:</P>

<UL><LI>Используйте наиболее эффективные (самые маленькие) возможные типы.
MySQL имеет много разных специализированных типов, которые сохраняют дисковое
пространство и память.

<LI>Используйте меньшие целочисленные типы, если возможно, чтобы получить
меньшие таблицы. Например, <CODE>MEDIUMINT</CODE> часто бывает куда лучше,
чем <CODE>INT</CODE> в чистом виде.

<LI>Объявите столбцы как <CODE>NOT NULL</CODE>, если это возможно. Это
сделает все быстрее, и Вы сэкономите один бит на столбец. Обратите внимание,
что, если Вы действительно нуждаетесь в <CODE>NULL</CODE> в Вашей прикладной
программе, Вы должны определенно использовать это. Только не стоит иметь это
свойство заданным на всех столбцах по умолчанию.

<LI>Если Вы не имеете столбцов переменной длины (<CODE>VARCHAR</CODE>,
<CODE>TEXT</CODE> или <CODE>BLOB</CODE>), используется формат записи
фиксированного размера. Это быстрее, но, к сожалению, может тратить впустую
некоторое место. Подробности в разделе
"<A HREF="myisam.htm#MyISAM_table_formats">7.1.2 Форматы таблиц MyISAM</A>".

<LI>Первичный индекс таблицы должен быть так короток, как только возможно.
Это делает идентификацию одной строки простой и эффективной.

<LI>Для каждой таблицы Вы должны решить, который метод хранения и индексации
надлежит в ней использовать. Подробности в разделе
"<A HREF="glava07.htm#Table_types">7 Типы таблиц MySQL</A>".

<LI>Создайте только те индексы, в которых Вы действительно нуждаетесь.
Индексы хороши для поиска, но плохи, когда Вы должны сохранить что-то быстро.
Если Вы обычно обращаетесь к таблице, используя поиск на комбинации столбцов,
сделайте индекс на них. Первая индексная часть должна быть наиболее
используемым столбцом. Если Вы ВСЕГДА используете много столбцов, Вы должны
применить столбец с большим количеством дубликатов первым, чтобы получить
лучшее сжатие индекса.

<LI>Если вероятно, что столбец имеет уникальный префикс на некотором числе
первых символов, лучше индексировать только этот префикс. MySQL поддерживает
индекс на части символьного столбца. Короткие индексы быстрее не только
потому, что они берут меньшее количество дискового пространства, но также и
потому, что они дадут Вам большее количество попаданий в индексный кэш и
таким образом меньшее количество дисковых установок. Подробности в разделе
"<A HREF="#Server_parameters">5.5.2 Настройка параметров сервера
</A>".

<LI>В некоторых обстоятельствах таблицу, которая бывает просмотрена очень
часто, может быть полезно расчленить на две. Это особенно верно, если это
таблица динамического формата, и можно использовать меньшую таблицу
статического формата, которая может применяться, чтобы найти релевантные
строки при просмотре этой таблицы.</UL>

<H3><A NAME="MySQL_indexes">5.4.3 Как MySQL использует индексы</A></H3>
<P>Индексы используются, чтобы быстро найти строки со специфическим значением
одного столбца. Без индекса MySQL должен начать с первой записи и затем
пролистывать целую таблицу, пока не найдет релевантные строки. Если таблица
имеет индекс для рассматриваемых столбцов, MySQL может быстро получить
позицию, чтобы позиционироваться на середину файла данных без того, чтобы
иметь необходимость рассматривать все данные. Если таблица имеет 1000 строк,
это по крайней мере в 100 раз быстрее, чем последовательное чтение. Обратите
внимание, что если Вы должны обратиться почти ко всем 1000 строкам, быстрее
читать файл последовательно потому, что мы сэкономим дисковые установки.</P>

<P>Все индексы в MySQL (<CODE>PRIMARY</CODE>, <CODE>UNIQUE</CODE> и
<CODE>INDEX</CODE>) сохранены в B-деревьях. Строки автоматически сжимаются с
использованием конечных пробелов и префикса.</P>

<P>Индексы используются для:
<UL><LI>Быстрого поиска строк, которые соответствуют предложению
<CODE>WHERE</CODE>.

<LI>Получения строк из других таблиц при выполнении объединений.

<LI>Поиска значений <CODE>MAX()</CODE> или <CODE>MIN()</CODE> для
специфического индексированного столбца. Это оптимизировано препроцессором,
который проверяет, используете ли Вы <CODE>WHERE</CODE> key_part_#=constant
на всех частях ключа &#60;N. В этом случае MySQL будет делать одиночный поиск
ключа и заменит <CODE>MIN()</CODE> выражением с константой. Если все
выражения заменятся на константы, запрос возвратится сразу:
<PRE>
SELECT MIN(key_part2),MAX(key_part2) FROM table_name where key_part1=10
</PRE>

<LI>Сортировки или группировки таблиц, если сортировка или группировка
выполнена на крайнем левом префиксе пригодного для использования ключа
(например, <CODE>ORDER BY key_part_1,key_part_2</CODE>). Ключ читается в
обратном порядке, если все части ключа сопровождаются словом
<CODE>DESC</CODE>. Индекс может также использоваться, даже если <CODE>ORDER
BY</CODE> не соответствует индексу точно, пока все неиспользуемые индексные
части и все дополнительные столбцы в <CODE>ORDER BY</CODE> представляют собой
константы в предложении <CODE>WHERE</CODE>. Следующие запросы используют
индекс, чтобы решить часть <CODE>ORDER BY</CODE>:
<PRE>
SELECT * FROM foo ORDER BY key_part1,key_part2,key_part3;
SELECT * FROM foo WHERE column=constant ORDER BY column, key_part1;
SELECT * FROM foo WHERE key_part1=const GROUP BY key_part2;
</PRE>

<LI>В некоторых случаях запрос может быть оптимизирован, чтобы получить
значения без того, чтобы консультироваться с файлом данных. Если все
используемые столбцы для некоторой таблицы числовые и формируют крайний левый
префикс для некоторого ключа, значения могут быть получены прямо из
индексного дерева для большего быстродействия:
<PRE>
SELECT key_part3 FROM table_name WHERE key_part1=1
</PRE></UL>

<P>Предположим, что Вы выдаете следующую инструкцию <CODE>SELECT</CODE>:</P>
<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;
</PRE>

<P>Если многостолбиковый индекс существует на <CODE>col1</CODE> и
<CODE>col2</CODE>, соответствующие строки могут быть выбраны непосредственно.
Если отдельные индексы с одним столбцом существуют на <CODE>col1</CODE> и
<CODE>col2</CODE>, оптимизатор пробует находить наиболее ограничительный
индекс, решая, который индекс найдет меньшее количество строк, и используя
этот индекс, чтобы выбрать строки.</P>

<P>Если таблица имеет многостолбиковый индекс, любой крайний левый префикс
индекса может использоваться оптимизатором, чтобы найти строки. Например,
если Вы имеете индекс с тремя столбцами на <CODE>(col1,col2,col3)</CODE>, Вы
индексировали возможности поиска на <CODE>(col1)</CODE>,
<CODE>(col1,col2)</CODE> и <CODE>(col1,col2,col3)</CODE>.</P>

<P>MySQL не может использовать частичный индекс, если столбцы не формируют
крайний левый префикс из индекса. Предположим, что Вы имеете инструкции
<CODE>SELECT</CODE>, показанные ниже:</P>
<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE col1=val1;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2;
mysql&#62; SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3;
</PRE>

<P>Если индекс существует на <CODE>(col1,col2,col3)</CODE>, только первый
запрос, показанный выше, использует индекс. Второй и третий запросы включают
индексированные столбцы, но <CODE>(col2)</CODE> и <CODE>(col2,col3)</CODE>
не крайние левые префиксы для <CODE>(col1,col2,col3)</CODE>.</P>

<P><A NAME="IDX871"></A><A NAME="IDX872"></A><A NAME="IDX873"></A>
<A NAME="IDX874"></A>MySQL также использует индексы для сравнений
<CODE>LIKE</CODE>, если параметр для <CODE>LIKE</CODE> представляет собой
строку-константу, которая не начинается с группового символа. Например,
следующие инструкции <CODE>SELECT</CODE> используют индексы:</P>
<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE "Pat%_ck%";
</PRE>

<P>В первой инструкции только строки с <CODE>"Patrick" &#60;=key_col &#60;
"Patricl"</CODE> рассматриваются. Во второй инструкции будут обработаны
только строки с <CODE>"Pat" &#60;=key_col &#60; "Pau"</CODE>.</P>

<P>Следующие инструкции <CODE>SELECT</CODE> не будут использовать индексы:
<PRE>
mysql&#62; select * from tbl_name where key_col LIKE "%Patrick%";
mysql&#62; select * from tbl_name where key_col LIKE other_col;
</PRE>

<P>В первой инструкции значение <CODE>LIKE</CODE> начинается с группового
символа. Во второй инструкции значение <CODE>LIKE</CODE> не константа.</P>

<P><A NAME="IDX875"></A><A NAME="IDX876"></A>Поиск, использующий
<CODE>column_name IS NULL</CODE>, применяет индексы, если column_name
представляет собой индекс.</P>

<P>MySQL обычно использует индекс, который находит наименьшее число строк.
Индекс используется для столбцов, которые Вы сравниваете следующими
операторами: <CODE>=</CODE>, <CODE>&#62;</CODE>, <CODE>&#62;=</CODE>,
<CODE>&#60;</CODE>, <CODE>&#60;=</CODE>, <CODE>BETWEEN</CODE> и
<CODE>LIKE</CODE> с префиксом, представляющим собой не групповой символ,
например, допустимо <CODE>something%</CODE>.</P>

<P>Любой индекс, который не охватывает все уровни <CODE>AND</CODE> в
предложении <CODE>WHERE</CODE>, не используется, чтобы оптимизировать запрос.
Другими словами: чтобы быть способным использовать индекс, префикс индекса
должен использоваться в каждом <CODE>AND</CODE> в группе.</P>

<P>Следующие предложения <CODE>WHERE</CODE> используют индексы:
<PRE>
... WHERE index_part1=1 AND index_part2=2 AND other_column=3
... WHERE index=1 OR A=10 AND index=2      /* index = 1 OR index = 2 */
... WHERE index_part1='hello' AND index_part_3=5
          /* optimized like "index_part1='hello'" */
... WHERE index1=1 and index2=2 or index1=3 and index3=3;
          /* Can use index on index1 but not on index2 or index 3 */
</PRE>

<P>Эти предложения <CODE>WHERE</CODE> <STRONG>НЕ</STRONG> используют индексы:
<PRE>
... WHERE index_part2=1 AND index_part3=2  /* index_part_1 is not used */
... WHERE index=1 OR A=10                  /* Index is not used in both AND parts */
... WHERE index_part1=1 OR index_part2=10  /* No index spans all rows */
</PRE>

<P>Обратите внимание, что в некоторых случаях MySQL все равно не будет
использовать индекс, даже если можно было бы это сделать. Это связано с
особенностями логики СУБД. Некоторые из таких случаев:</P>

<UL><LI>Если использование индекса требовало бы, чтобы MySQL обратился
больше, чем к 30% строк в таблице. В этом случае просмотр таблицы, вероятно,
намного быстрее, поскольку требует, чтобы много меньшего количества дисковых
установок. Обратите внимание, что, если в запросе задан <CODE>LIMIT</CODE>,
чтобы получить только часть строк, MySQL использует индекс в любом случае,
поскольку может намного быстрее найти строки, возвращаемые в результате.</UL>

<H3><A NAME="Indexes">5.4.4 Индексы столбцов</A></H3>
<P>Все типы столбцов MySQL могут быть индексированы. Использование индексов
на релевантных столбцах представляет собой самый лучший способ улучшить
эффективность операций <CODE>SELECT</CODE>.</P>

<P>Максимальное число ключей и максимальная длина индекса определены в
драйвере таблицы. Подробности в разделе "<A HREF="glava07.htm#Table_types">7
Типы таблиц MySQL</A>". Вы можете со всеми драйверами таблицы иметь по
крайней мере 16 ключей и общую индексную длину по крайней мере в 256 байт.
</P>

<P>Для столбцов типов <CODE>CHAR</CODE> и <CODE>VARCHAR</CODE> Вы можете
индексировать префикс столбца. Это намного быстрее и требует меньшего
количества дискового пространства, чем индексация целого столбца. Синтаксис,
который надо использовать в инструкции <CODE>CREATE TABLE</CODE>, чтобы
индексировать префикс для столбца, выглядит следующим образом:</P>
<PRE>
KEY index_name (col_name(length))
</PRE>

<P>Пример ниже создает индекс первых 10 символов столбца <CODE>name</CODE>:
</P>
<PRE>
mysql&#62; CREATE TABLE test (name CHAR(200) NOT NULL,
                              KEY index_name (name(10)));
</PRE>

<P>Для столбцов <CODE>BLOB</CODE> и <CODE>TEXT</CODE> Вы должны индексировать
именно префикс столбца. Там Вы не можете индексировать весь столбец.</P>

<P>В MySQL Version 3.23.23 или позже Вы можете также создавать специальные
индексы <STRONG>FULLTEXT</STRONG>. Они используются для полнотекстового
поиска. Только тип таблицы <CODE>MyISAM</CODE> поддерживает индексы
<CODE>FULLTEXT</CODE>. Они могут быть созданы только из столбцов
<CODE>VARCHAR</CODE> и <CODE>TEXT</CODE>. Индексация всегда выполняется над
всем столбцом, частичная индексация пока не поддержана.</P>

<H3><A NAME="Multiple-column_indexes">5.4.5 Многостолбцовые индексы</A></H3>
<P>MySQL может создавать индексы на нескольких столбцах. Индекс может
включать до 15 столбцов. На столбцах типов <CODE>CHAR</CODE> и
<CODE>VARCHAR</CODE> Вы можете использовать префикс столбца как часть индекса.
</P>

<P>MySQL использует индексы на нескольких столбцах таким способом, что
запросы становятся более быстрыми, когда Вы определяете известное количество
данных для первого столбца индекса в предложении <CODE>WHERE</CODE>, даже
если Вы не определяете значения для других столбцов вообще.</P>

<P>Предположим, что таблица создана, используя следующую спецификацию:</P>
<PRE>
mysql&#62; CREATE TABLE test (id INT NOT NULL, last_name CHAR(30) NOT NULL,
           first_name CHAR(30) NOT NULL, PRIMARY KEY (id),
           INDEX name (last_name,first_name));
</PRE>

<P>Индекс <CODE>name</CODE> охватывает столбцы <CODE>last_name</CODE> и
<CODE>first_name</CODE>. Индекс будет использоваться для запросов, которые
определяют значения в известном диапазоне для <CODE>last_name</CODE> или для
<CODE>last_name</CODE> и <CODE>first_name</CODE> вместе. Следовательно,
индекс <CODE>name</CODE> будет использоваться для следующих запросов:</P>
<PRE>
mysql&#62; SELECT * FROM test WHERE last_name="Widenius";
mysql&#62; SELECT * FROM test WHERE last_name="Widenius"
                  AND first_name="Michael";
mysql&#62; SELECT * FROM test WHERE last_name="Widenius"
                  AND (first_name="Michael" OR first_name="Monty");
mysql&#62; SELECT * FROM test WHERE last_name="Widenius"
                  AND first_name &#62;="M" AND first_name &#60; "N";
</PRE>

<P>Однако, индекс <CODE>name</CODE> НЕ будет использоваться в запросах:</P>
<PRE>
mysql&#62; SELECT * FROM test WHERE first_name="Michael";
mysql&#62; SELECT * FROM test WHERE last_name="Widenius" OR
                    first_name="Michael";
</PRE>

<P>За подробностями по улучшению работы с индексами в MySQL отсылаю Вас к
разделу "<A HREF="#MySQL_indexes">5.4.3
Как MySQL использует индексы</A>".</P>

<H3><A NAME="Table_cache">5.4.6 Как MySQL открывает и закрывает таблицы</A>
</H3>
<P>Переменные <CODE>table_cache</CODE>, <CODE>max_connections</CODE> и
<CODE>max_tmp_tables</CODE> воздействуют на максимальное число файлов,
которые сервер хранит открытыми. Если Вы увеличиваете одно из них, Вы можете
нарваться на ограничение, наложенное Вашей операционной системой на число
описателей открытого файла на процесс. Однако, Вы можете обойти ограничение
многих систем. Консультируйтесь с Вашей документацией на OS, чтобы выяснить,
как это сделать потому, что методы для изменения ограничения везде свои.</P>

<P>Переменная <CODE>table_cache</CODE> связана с <CODE>max_connections</CODE>.
Например, для 200 параллельных подключений, Вы должны иметь кэш таблицы по
крайней мере <CODE>200*n</CODE>, где <CODE>n</CODE> максимальное число таблиц
в объединении. Вы также должны резервировать некоторые описатели файла
дополнительно для временных таблиц и файлов.</P>

<P>Кэш открытых таблиц может расти до максимума, заданного
<CODE>table_cache</CODE> (значение по умолчанию 64, это может быть изменено с
помощью опции <CODE>-O table_cache=#</CODE> при вызове сервера
<CODE>mysqld</CODE>). Таблица никогда не будет закрыта за исключением того
случая, когда кэш заполняется, а другой поток пробует открыть таблицу, или
если Вы используете команду <CODE>mysqladmin refresh</CODE> или
<CODE>mysqladmin flush-tables</CODE>.</P>

<P>Когда кэш таблицы заполняется, сервер использует следующую процедуру,
чтобы найти запись кэша, которую надо использовать:</P>

<UL><LI>Таблицы, которые не используются в настоящее время, будут освобождены
в порядке "позже использовалась-первой освободилась".

<LI>Если кэш полный, и никакие таблицы не могут быть освобождены, а новая
таблица должна быть открыта, кэш временно расширяется по мере необходимости.

<LI>Если кэш находится во временно расширенном состоянии, и таблица переходит
из статуса "использована" в статус "не использована", она будет закрыта и
исключена из кэша.</UL>

<P>Таблица открыта для каждого параллельного доступа. Это означает, что, если
Вы имеете два потока, обращающиеся к той же самой таблице, или обращаетесь к
таблице дважды в том же самом запросе (через <CODE>AS</CODE>), таблица должна
быть открыта дважды. Первое открытие любой таблицы берет два описателя файла,
каждое дополнительное использование таблицы берет только один описатель
файла. Лишний описатель для первого открытия используется для индексного
файла: этот описатель разделен между всеми потоками.</P>

<P>Вы можете проверять, является ли Ваш кэш таблицы слишком маленьким,
проверяя переменную <CODE>opened_tables</CODE> в <CODE>mysqld</CODE>. Если
это значение очень большое, даже если Вы не делали много вызовов
<CODE>FLUSH TABLES</CODE>, Вы должны увеличить Ваш кэш таблицы. Подробности в
разделе "<A HREF="admin.htm#SHOW_STATUS">4.5.5.3 <CODE>SHOW STATUS</CODE>
</A>".</P>

<H3><A NAME="Creating_many_tables">5.4.7 Проблемы с созданием большого
количества таблиц в базе данных</A></H3>
<P>Если Вы имеете много файлов в каталоге, операции открытия, закрытия и
создания будут медленными. Если Вы выполняете инструкции <CODE>SELECT</CODE>
относительно многих различных таблиц, будет иметься некоторое замедление,
когда кэш таблицы заполнится потому, что для каждой таблицы, которая должна
быть открыта, другая закроется. Вы можете уменьшить задержку, делая больше
кэш для таблиц.</P>

<H3><A NAME="Open_tables">5.4.8 Почему так много открытых таблиц?</A></H3>
<P>Когда Вы выполняете <CODE>mysqladmin status</CODE>, Вы будете видеть нечто
вроде этого вывода:</P>
<PRE>
Uptime: 426 Running threads: 1 Questions: 11082 Reloads: 1 Open tables: 12
</PRE>

<P>Это может несколько озадачить, если Вы имеете только 6 таблиц.</P>

<P>MySQL представляет собой многопоточное приложение, так что он может иметь
много запросов к той же самой таблице одновременно. Чтобы минимизировать
проблему с двумя потоками, имеющими различные состояния на том же самом
файле, таблица будет открыта независимо каждым параллельным потоком. Это
берет некоторую дополнительную память и один описатель файла для файла
данных. Описатель индексного файла разделен между всеми потоками.</P>

<H2><A NAME="Optimizing_the_Server">5.5 Оптимизация сервера MySQL</A></H2>

<H3><A NAME="System">5.5.1 Настройка параметров компиляции и запуска</A></H3>
<P>Начнем обзор с уровня системы, так как некоторые из этих решений должны
быть сделаны очень рано. В других случаях рассмотрение будет не очень
глубоким потому, что не сможет сильно повлиять на результаты. Однако, всегда
хорошо иметь представление относительно того, сколько можно извлечь пользы,
меняя настройки на этом уровне.</P>

<P>Используемая OS очень важна! Чтобы с толком использовать многопроцессорные
системы, нужно применять Solaris (потому, что потоки там работают очень
хорошо) или Linux (потому, что ядро 2.2 имеет очень приличную поддержку SMP).
Также на 32-разрядных машинах Linux имеет ограничение в 2G для размера файла
по умолчанию. Но это исправлено в файловых системах XFS/Reiserfs. Если Вы
имеете потребность в файлах больше, чем 2G, на Linux-intel 32 bit, Вы должны
получить заплату LFS для файловой системы ext2.</P>

<P>Другие советы и предупреждения:
<UL><LI>Если Вы имеете достаточно RAM, Вы могли бы удалить все свопы.
Некоторые операционные системы используют своп в некоторых контекстах, даже
если Вы имеете свободную память.

<LI>Используйте опцию <CODE>--skip-locking</CODE> в MySQL, чтобы избежать
внешней блокировки. Обратите внимание, что это не будет воздействовать на
функциональные возможности MySQL, пока Вы выполняете только один сервер.
Только не забудьте завершить сервер (или блокировать релевантные части)
прежде, чем Вы выполните <CODE>myisamchk</CODE>. На некоторых системах эта
опция обязательна потому, что внешняя блокировка не работает в любом случае.
Опция <CODE>--skip-locking</CODE> по умолчанию включена при компиляции с
MIT-pthreads потому, что <CODE>flock()</CODE> не полностью поддержан
MIT-pthreads на всех платформах. Это также значение по умолчанию для Linux,
поскольку блокировка файлов в Linux еще не безопасна. Единственный случай,
когда Вы не можете использовать <CODE>--skip-locking</CODE>: если Вы
выполняете много серверов MySQL (не клиентов) на тех же самых данных или
выполняете <CODE>myisamchk</CODE> на таблице без предварительной блокировки
сервера и сброса таблиц на диск. Вы можете применять
<CODE>LOCK TABLES</CODE>/<CODE>UNLOCK TABLES</CODE>, даже если Вы используете
опцию <CODE>--skip-locking</CODE></UL>

<H3><A NAME="Server_parameters">5.5.2 Настройка параметров сервера</A></H3>
<P>Вы можете получать заданные по умолчанию буферные размеры, используемые
сервером <CODE>mysqld</CODE>, этой командой:</P>
<PRE>
shell&#62; mysqld --help
</PRE>

<P>Эта команда производит список всех параметров <CODE>mysqld</CODE> и
переменных с перестраиваемой конфигурацией. Вывод включает значения по
умолчанию и выглядит так:</P>
<PRE>
Possible variables for option --set-variable (-O) are:
back_log              current value: 5
bdb_cache_size        current value: 1048540
binlog_cache_size     current_value: 32768
connect_timeout       current value: 5
delayed_insert_timeout  current value: 300
delayed_insert_limit  current value: 100
delayed_queue_size    current value: 1000
flush_time            current value: 0
interactive_timeout   current value: 28800
join_buffer_size      current value: 131072
key_buffer_size       current value: 1048540
lower_case_table_names  current value: 0
long_query_time       current value: 10
max_allowed_packet    current value: 1048576
max_binlog_cache_size current_value: 4294967295
max_connections       current value: 100
max_connect_errors    current value: 10
max_delayed_threads   current value: 20
max_heap_table_size   current value: 16777216
max_join_size         current value: 4294967295
max_sort_length       current value: 1024
max_tmp_tables        current value: 32
max_write_lock_count  current value: 4294967295
myisam_sort_buffer_size  current value: 8388608
net_buffer_length     current value: 16384
net_retry_count       current value: 10
net_read_timeout      current value: 30
net_write_timeout     current value: 60
query_buffer_size     current value: 0
record_buffer         current value: 131072
record_rnd_buffer     current value: 131072
slow_launch_time      current value: 2
sort_buffer           current value: 2097116
table_cache           current value: 64
thread_concurrency    current value: 10
tmp_table_size        current value: 1048576
thread_stack          current value: 131072
wait_timeout          current value: 28800
</PRE>

<P>Если имеется работающий сервер <CODE>mysqld</CODE>, Вы можете увидеть,
какие значения он фактически использует для переменных, выполняя эту команду:
</P>
<PRE>
shell&#62; mysqladmin variables
</PRE>

<P>Вы можете находить полное описание для всех переменных в разделе
"<A HREF="admin.htm#SHOW_VARIABLES">4.5.5.4 <CODE>SHOW VARIABLES</CODE></A>".
</P>

<P>Вы можете также видеть некоторую статистику с сервера, выдавая команду
<CODE>SHOW STATUS</CODE>. Подробности в разделе
"<A HREF="admin.htm#SHOW_STATUS">4.5.5.3 <CODE>SHOW STATUS</CODE></A>".</P>

<P>MySQL использует алгоритмы, которые являются очень хорошо масштабируемыми,
так что Вы обычно можете работать с очень небольшой памятью. Если Вы даете
MySQL больше памяти, Вы обычно будете получать лучшую эффективность.</P>

<P>При настройке сервера MySQL есть две наиболее важных переменных:
<CODE>key_buffer_size</CODE> и <CODE>table_cache</CODE>.</P>

<P>Если Вы имеете много памяти (&#62;=256M) и много таблиц и хотите
получить максимальную эффективность с умеренным числом клиентов, Вы должны
использовать нечто подобное этому:</P>
<PRE>
shell&#62; safe_mysqld -O key_buffer=64M -O table_cache=256 \
                       -O sort_buffer=4M -O record_buffer=1M &#38;
</PRE>

<P>Если Вы имеете только 128M и всего несколько таблиц, но Вы делаете много
сортировок, Вы можете использовать нечто, подобно этому:</P>
<PRE>
shell&#62; safe_mysqld -O key_buffer=16M -O sort_buffer=1M
</PRE>

<P>Если Вы имеете небольшую память и большое количество подключений,
используйте следующее решение:</P>
<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=100k \
                       -O record_buffer=100k &#38;
</PRE>

<P>Или вот это:</P>
<PRE>
shell&#62; safe_mysqld -O key_buffer=512k -O sort_buffer=16k \
                       -O table_cache=32 -O record_buffer=8k \
                       -O net_buffer=1K &#38;
</PRE>

<P>Если Вы делаете <CODE>GROUP BY</CODE> или <CODE>ORDER BY</CODE> на файлах,
которые являются намного больше, чем Ваша доступная память, Вы должны
увеличить значение <CODE>record_rnd_buffer</CODE>, чтобы ускорить чтение
строк после того, как сортировка будет выполнена.</P>

<P>Когда Вы установили MySQL, каталог <TT>support-files</TT> будет хранить
некоторые различные файлы примера <CODE>my.cnf</CODE>, например,
<TT>my-huge.cnf</TT>, <TT>my-large.cnf</TT>, <TT>my-medium.cnf</TT> и
<TT>my-small.cnf</TT>, которые Вы можете использовать как основу, чтобы
оптимизировать Вашу систему.</P>

<P>Если имеется очень много подключений, может происходить ``swapping
problem'', если <CODE>mysqld</CODE> не был конфигурирован, чтобы использовать
очень небольшую память для каждого подключения. Конечно, <CODE>mysqld</CODE>
работает много лучше, если Вы имеете достаточно памяти для всех подключений.
</P>

<P>Обратите внимание, что, если Вы изменяете опцию <CODE>mysqld</CODE>, это
остается в силе только для этого образца станции.</P>

<P>Чтобы увидеть эффект от изменения параметра, сделайте:</P>
<PRE>
shell&#62; mysqld -O key_buffer=32m --help
</PRE>

<P>Удостоверьтесь, что опция <CODE>--help</CODE> последняя; иначе эффект
любых перечисленных на командной строке после нее параметров не будет
отражен в выводе.</P>

<H3><A NAME="Compile_and_link_options">5.5.3 Как компиляция и компоновка
воздействуют на быстродействие MySQL</A></H3>
<P>Большинство следующих тестов выполнено на Linux с эталонными тестами
MySQL, но они должны дать некоторые данные для других операционных систем и
рабочих нагрузок системы.</P>

<P>Вы получаете самую быструю выполнимую программу, когда Вы компонуете ее с
опцией времени компоновки <CODE>-static</CODE>.</P>

<P>В Linux Вы получите самый быстрый код при компиляции с <CODE>pgcc</CODE>
и опцией <CODE>-O3</CODE>. Чтобы откомпилировать <TT>sql_yacc.cc</TT> с этими
параметрами, Вы нуждаетесь примерно в 200M памяти потому, что
<CODE>gcc/pgcc</CODE> требует много памяти, чтобы сделать все функции
встроенными. Вы должны также установить <CODE>CXX=gcc</CODE> при
конфигурировании MySQL, чтобы избежать включения библиотеки
<CODE>libstdc++</CODE>. Обратите внимание, что при работе с некоторыми
версиями <CODE>pgcc</CODE> возникающий в результате код выполнится только на
истинных процессорах Pentium, даже если Вы используете опцию транслятора,
чтобы возникающий в результате код работал на всех процессорах типа x586.</P>

<P>Только используя лучший транслятор и/или лучшие параметры транслятора, Вы
уже можете получить увеличение быстродействия Вашей прикладной программы на
10-30%! Это особенно важно, если Вы компилируете SQL-сервер сами.</P>

<P>Авторы пакета проверили компиляторы Cygnus CodeFusion и Fujitsu, но на
момент этого тестирования они были недостаточно свободны от ошибок, чтобы
позволить MySQL компилироваться с включенной оптимизацией.</P>

<P>Когда Вы компилируете MySQL, Вы должны включить поддержку только для тех
наборов символов, которые Вы собираетесь использовать (опция
<CODE>--with-charset=xxx</CODE>). Стандартные двоичные дистрибутивы MySQL
компилируются с поддержкой всех наборов символов.</P>

<P>Имеется список некоторых измерений, которые сделали авторы пакета:
<UL><LI>Если Вы используете <CODE>pgcc</CODE> и компилируете все с опцией
<CODE>-O6</CODE>, сервер <CODE>mysqld</CODE> на 1% быстрее, чем с
<CODE>gcc</CODE> 2.95.2.

<LI>Если Вы компонуете динамически (без <CODE>-static</CODE>), результат на
14% медленнее в Linux. Обратите внимание, что Вы все еще можете использовать
динамическую библиотеку MySQL. Это критично только для сервера.

<LI>Если Вы обработаете <CODE>mysqld</CODE> командой <CODE>strip
libexec/mysqld</CODE>, возникающий в результате двоичный код может
быть до 4% быстрее.

<LI>Если Вы подключаетесь, используя TCP/IP вместо Unix-сокетов, результат
на 7.5% медленнее на том же самом компьютере. Если Вы связываетесь с
<CODE>localhost</CODE>, MySQL по умолчанию использует именно сокеты.

<LI>Если Вы подключаетесь, используя TCP/IP с другого компьютера по 100M
Ethernet, это будет на 8-10% медленнее.

<LI>Если Вы компилируете с опцией <CODE>--with-debug=full</CODE>, теряете 20%
скорости для большинства запросов, но некоторые запросы могут еще более
замедлиться (эталонные тесты до 36%). Если Вы используете
<CODE>--with-debug</CODE>, потери составят около 15%. Запуская
<CODE>mysqld</CODE>, скомпилированный с опцией
<CODE>--with-debug=full</CODE>, с <CODE>--skip-safemalloc</CODE> конечный
результат должен быть близок к варианту <CODE>--with-debug</CODE>.

<LI>На Sun SPARCstation 20 SunPro C++ 4.2 на 5% быстрее, чем <CODE>gcc</CODE>
2.95.2.

<LI>Компиляция с помощью <CODE>gcc</CODE> 2.95.2 для ultrasparc с опциями
<CODE>-mcpu=v8 -Wa,-xarch=v8plusa</CODE> дает еще 4% эффективности.

<LI>В Solaris 2.5.1 MIT-pthreads на 8-12% медленнее своих потоков Solaris на
одном процессоре. С ростом загрузки и центральных процессоров различие
должно стать больше.

<LI>Запуск с опцией <CODE>--log-bin</CODE> сделает <STRONG>MySQL</STRONG>
примерно на 1% медленнее.

<LI>Компиляция на Linux-x86 с использованием gcc без frame pointers
<CODE>-fomit-frame-pointer</CODE> или <CODE>-fomit-frame-pointer
-ffixed-ebp</CODE> делает <CODE>mysqld</CODE> на 1-4% быстрее.</UL>

<P>Дистрибутив MySQL-Linux, собранный в MySQL AB, использовал
<CODE>pgcc</CODE>, но из-за ошибки при работе на процессорах AMD (причина в
компиляторе, а не в процессорах, они-то как раз отменные!) теперь снова
применяется обычный gcc, и так будет до тех пор, пока та ошибка не будет
решена авторами транслятора. Тем временем, если Вы имеете не-AMD машину, Вы
можете попробовать применить <CODE>pgcc</CODE>. Правда, не очень ясно, кто
победит в этом споре: то ли более совершенный компилятор <CODE>pgcc</CODE>,
то ли процессоры от AMD, которые просто по конструкции быстрее Intel...
Стандартный двоичный дистрибутив MySQL для Linux скомпонован статически,
чтобы получить большие быстродействие и переносимость.</P>

<H3><A NAME="Memory_use">5.5.4 Как MySQL использует память</A></H3>
<P>Список ниже указывает некоторые из путей, которыми сервер
<CODE>mysqld</CODE> использует память. Там, где это нужно и важно, указаны
имена соответствующих переменных сервера.</P>

<UL><LI>Буфер ключей (переменная <CODE>key_buffer_size</CODE>) разделен всеми
потоками. Другие буфера, используемые сервером, распределены как необходимо.
Подробности в разделе "<A HREF="#Server_parameters">5.5.2
Настройка параметров сервера</A>".

<LI>Каждое подключение использует некоторое специфическое для потока место:
стек (заданный по умолчанию в 64КБ, переменная <CODE>thread_stack</CODE>),
буфер подключений (переменная <CODE>net_buffer_length</CODE>) и буфер
результатов (переменная <CODE>net_buffer_length</CODE>). Буфер подключений и
буфер результатов будут динамически расширены до
<CODE>max_allowed_packet</CODE>, когда это будет необходимо. Когда запрос
обрабатывается, копия текущей строки запроса также распределена.

<LI>Все потоки совместно используют ту же самую основную память.

<LI>Только сжатые таблицы ISAM/MyISAM отображаются в памяти. Это потому, что
32-разрядное пространство памяти в 4GB недостаточно большое для наиболее
крупных таблиц. Когда системы с 64-разрядным адресным пространством станут
более распространенными, авторы пакета добавят общую поддержку для управления
памятью по этому методу.

<LI>Каждый запрос, делающий последовательный просмотр таблицы, распределяет
буфер чтений (переменная <CODE>record_buffer</CODE>).

<LI>При чтении строк в произвольном порядке (например, после сортировки)
буфер для этого будет распределен, чтобы избежать дисковых установок
(переменная <CODE>record_rnd_buffer</CODE>).

<LI>Все объединения выполнены в одном проходе, и большинство объединений
может быть выполнено без применения временной таблицы. Временные таблицы с
большой длиной записи или включающие столбцы <CODE>BLOB</CODE> сохранены на
диске. Одна проблема в MySQL до Version 3.23.2 состоит в том, что, если
таблица HEAP превышает размер <CODE>tmp_table_size</CODE>, Вы получите ошибку
<CODE>The table tbl_name is full</CODE>. В более новых версиях это обработано
автоматической заменой таблиц в памяти на дисковые по мере необходимости.
Чтобы обойти эту проблему Вы можете увеличивать временный размер таблицы,
устанавливая опцию <CODE>tmp_table_size</CODE> в <CODE>mysqld</CODE> или
устанавливая в программе пользователя SQL-опцию <CODE>SQL_BIG_TABLES</CODE>.
Подробности в разделе "<A HREF="#SET_OPTION">5.5.6 Синтаксис
<CODE>SET</CODE></A>". В MySQL Version 3.20 максимальный размер временной
таблицы был <CODE>record_buffer*16</CODE> так, что, если Вы используете эту
версию, Вы должны увеличить значение <CODE>record_buffer</CODE>. Вы можете
также запустить  <CODE>mysqld</CODE> с опцией <CODE>--big-tables</CODE>,
чтобы всегда сохранять временные таблицы на диске. Однако, это будет плохо
воздействовать на быстродействие очень многих сложных запросов.

<LI>Большинство запросов, делающих сортировку, распределяет буфер сортировки
и 0-2 временных файла в зависимости от размера набора результата. Подробности
в разделе "<A HREF="glava08.htm#Temporary_files">8.4.4 Где MySQL сохраняет
свои временные файлы.</A>".

<LI>Почти весь синтаксический анализ и вычисления выполнены в локальной
памяти. Никакая память не требуется для маленьких элементов. Память будет
распределена только для неожиданно больших строк (это выполнено с помощью
вызовов <CODE>malloc()</CODE> и <CODE>free()</CODE>).

<LI>Каждый индексный файл открыт однажды, а файл данных открыт однажды для
каждого одновременно выполняемого потока. Для каждого параллельного потока
распределены: структура таблицы, структура для каждого столбца и буфера
размером <CODE>3*n</CODE> (где <CODE>n</CODE> максимальная длина строки, не
считая столбцы типа <CODE>BLOB</CODE>). <CODE>BLOB</CODE> использует от 5 до
8 байт плюс длина данных <CODE>BLOB</CODE>. Драйвер таблиц
<CODE>ISAM</CODE>/<CODE>MyISAM</CODE> распределяет один буфер строк
дополнительно для внутреннего использования.

<LI>Для каждой таблицы, имеющей столбцы <CODE>BLOB</CODE>, буфер будет
расширен динамически, чтобы читать большие значения <CODE>BLOB</CODE>.
Если Вы просматриваете таблицу, распределяется буфер такого размера, как
самое большое значение <CODE>BLOB</CODE>.

<LI>Драйверы таблицы для всех используемых таблиц сохранены в кэше и
управляются как FIFO. Обычно кэш имеет 64 записи. Если таблица использовалась
двумя потоками в то же самое время, кэш содержит две записи для таблицы.
Подробности в разделе "<A HREF="#Table_cache">5.4.6 Как MySQL
открывает и закрывает таблицы</A>".

<LI>Команда <CODE>mysqladmin flush-tables</CODE> закрывает все таблицы,
которые не находятся в использовании, и отмечает все таблицы, находящиеся в
использовании, чтобы они были закрыты, когда работающий в настоящее время
поток завершится. Это действительно освободит много памяти.</UL>

<P><CODE>ps</CODE> и другие программы состояния системы может сообщать, что
<CODE>mysqld</CODE> использует много памяти. Это может быть вызвано стеками
потоков на различных адресах памяти. Например, Solaris-версия <CODE>ps</CODE>
считает неиспользуемую память между стеками как используемую память! Вы
можете выяснить это, проверяя доступный своп командой <CODE>swap -s</CODE>.
Сервер <CODE>mysqld</CODE> проверен с коммерческими детекторами утечки
памяти, так что в нем не должно иметься никаких утечек памяти.</P>

<H3><A NAME="DNS">5.5.5 Как MySQL использует DNS</A></H3>
<P>Когда новый процесс соединяется с <CODE>mysqld</CODE>, он запустит новый
поток, чтобы обработать запрос. Этот поток сначала проверит, находится ли
hostname в кэше hostname. Если нет, поток вызовет
<CODE>gethostbyaddr_r()</CODE> и <CODE>gethostbyname_r()</CODE>, чтобы
получить адрес машины.</P>

<P>Если операционная система не поддерживает вышеупомянутые
поточно-безопасные обращения, поток блокирует mutex и вызывает
<CODE>gethostbyaddr()</CODE> и <CODE>gethostbyname()</CODE>. Обратите
внимание, что в этом случае никакой другой поток не может обработать другое
имя до завершения первого потока.</P>

<P>Вы можете отключить поддержку DNS запуском <CODE>mysqld</CODE> с опцией
<CODE>--skip-name-resolve</CODE>. В этом случае Вы можете использовать только
IP-адреса в таблицах привилегий MySQL.</P>

<P> Если Вы имеете очень медленный DNS и много компьютеров, Вы можете
получать большую эффективность отключая DNS опцией
<CODE>--skip-name-resolve</CODE> или увеличивая определение
<CODE>HOST_CACHE_SIZE</CODE> (значение по умолчанию: 128) с последующей
перекомпиляцией сервера <CODE>mysqld</CODE>.</P>

<P>Вы можете отключать кэш hostname с помощью опции
<CODE>--skip-host-cache</CODE>. Вы можете очищать кэш hostname с помощью
команд <CODE>FLUSH HOSTS</CODE> или <CODE>mysqladmin flush-hosts</CODE>.</P>

<P>Если Вы не хотите позволять подключения по <CODE>TCP/IP</CODE>, Вы можете
сделать это, запуская <CODE>mysqld</CODE> с опцией
<CODE>--skip-networking</CODE>.</P>

<H3><A NAME="SET_OPTION">5.5.6 Синтаксис <CODE>SET</CODE></A></H3>
<PRE>
SET [OPTION] SQL_VALUE_OPTION=value, ...
</PRE>

<P><CODE>SET OPTION</CODE> устанавливает различные параметры, которые
воздействуют на работу клиента или сервера. Любая опция, которую Вы
устанавливаете, остается в силе до завершения текущего сеанса, или пока Вы не
установите ее в другое значение.</P>

<DL COMPACT>
<DT><CODE>CHARACTER SET character_set_name|DEFAULT</CODE>
<DD>Это отображает все строки для клиента по заданной карте символов. В
настоящее время единственной опцией для <CODE>character_set_name</CODE>
является <CODE>cp1251_koi8</CODE>, но Вы можете легко добавлять новые
отображения, редактируя файл <TT>sql/convert.cc</TT> в дистрибутиве исходных
текстов MySQL. Отображение значения по умолчанию может быть восстановлено,
используя значение <CODE>DEFAULT</CODE> для переменной
<CODE>character_set_name</CODE>. Обратите внимание, что синтаксис для
установки опции <CODE>CHARACTER SET</CODE> отличается от синтаксиса для
установки других параметров.

<DT><CODE>PASSWORD=PASSWORD('some password')</CODE>
<DD><A NAME="IDX910"></A>Устаналивает пароль для текущего пользователя. Любой
неанонимный пользователь может изменять свой собственный пароль!

<DT><CODE>PASSWORD FOR user=PASSWORD('some password')</CODE>
<DD>Устанавливает пароль для специфического пользователя на текущем
компьютере. Только пользователь с доступом к базе данных <CODE>mysql</CODE>
может делать это. Пользователь должен быть указан в формате
<CODE>user@hostname</CODE>, где <CODE>user</CODE> и <CODE>hostname</CODE>
указаны точно так, как они перечислены в столбцах <CODE>User</CODE> и
<CODE>Host</CODE> записи в таблице <CODE>mysql.user</CODE>. Например, если Вы
имели запись с полями <CODE>User</CODE> и <CODE>Host</CODE> равными
<CODE>bob</CODE> и <CODE>%.loc.gov</CODE>, Вы будете писать:
<PRE>
mysql&#62; SET PASSWORD FOR bob@"%.loc.gov"=PASSWORD("newpass");
или
mysql&#62; UPDATE mysql.user SET password=PASSWORD("newpass")
                  where user="bob' and host="%.loc.gov";
</PRE>

<DT><CODE>SQL_AUTO_IS_NULL=0|1</CODE>
<DD>Если установлено в <CODE>1</CODE> (значение по умолчанию), то можно
находить последнюю вставленную строку для таблицы с поддержкой
auto_increment применением следующей конструкции: <CODE>WHERE
auto_increment_column IS NULL</CODE>. Это используется некоторыми программами
ODBC, например, Access.

<DT><CODE>AUTOCOMMIT=0|1</CODE>
<DD>Если установлено в <CODE>1</CODE>, все изменения для таблицы будут
выполнен сразу. Чтобы запустить многокомандную транзакцию, Вы должны
использовать инструкцию <CODE>BEGIN</CODE>. Если установлено в <CODE>0</CODE>,
Вы должны использовать <CODE>COMMIT</CODE>/<CODE>ROLLBACK</CODE>, чтобы
принять или отменить эту транзакцию. Обратите внимание, что, когда Вы
изменяете режим с не-<CODE>AUTOCOMMIT</CODE> на <CODE>AUTOCOMMIT</CODE>,
MySQL автоматически будет делать <CODE>COMMIT</CODE> на открытых транзакциях.

<DT><CODE>SQL_BIG_TABLES=0|1</CODE>
<DD><A NAME="IDX911"></A>Если установлено в <CODE>1</CODE>, все временные
таблицы сохранены на диске, а не в памяти. Это будет немного медленнее, но Вы
не будете получать ошибку <CODE>The table tbl_name is full</CODE> для больших
операций <CODE>SELECT</CODE>, которые требуют большой временной таблицы.
Значение по умолчанию для нового подключения <CODE>0</CODE> (то есть
использовать временные таблицы в памяти).

<DT><CODE>SQL_BIG_SELECTS=0|1</CODE>
<DD>Если установлено в <CODE>0</CODE>, MySQL прервется, если
<CODE>SELECT</CODE>, вероятно, будет брать очень длительное время. Это
полезно, когда была выдана нецелесообразная инструкция <CODE>WHERE</CODE>.
Большой запрос определен как <CODE>SELECT</CODE>, которому, вероятно,
придется исследовать больше, чем <CODE>max_join_size</CODE> строк. Значение
по умолчанию для нового подключения: <CODE>1</CODE> (это позволяет выполнять
все инструкции <CODE>SELECT</CODE>).

<DT><CODE>SQL_BUFFER_RESULT=0|1</CODE>
<DD><CODE>SQL_BUFFER_RESULT</CODE> вынудит результат <CODE>SELECT</CODE>
попасть во временную таблицу. Это поможет MySQL освободить блокировку таблицы
пораньше и поможет в случаях, где требуется длительное время, чтобы послать
набор результатов пользователю.

<DT><CODE>SQL_LOW_PRIORITY_UPDATES=0|1</CODE>
<DD>Если установлено в <CODE>1</CODE>, все инструкции <CODE>INSERT</CODE>,
<CODE>UPDATE</CODE>, <CODE>DELETE</CODE> и <CODE>LOCK TABLE WRITE</CODE>
ждут до тех пор, пока не останется ни одного ждущего обработки запроса
<CODE>SELECT</CODE> или <CODE>LOCK TABLE READ</CODE> на данной таблице.

<DT><CODE>SQL_MAX_JOIN_SIZE=value|DEFAULT</CODE>
<DD>Не позволять <CODE>SELECT</CODE>, которые, вероятно, будут должны
исследовать больше, чем <CODE>value</CODE> комбинаций строк. Устанавливая это
значение, Вы можете захватывать <CODE>SELECT</CODE>, где ключи не
используются правильно. Установка этого к иному значению, чем
<CODE>DEFAULT</CODE> сбросит флажок <CODE>SQL_BIG_SELECTS</CODE>. Если Вы
снова устанавливаете флажок <CODE>SQL_BIG_SELECTS</CODE>, переменная
<CODE>SQL_MAX_JOIN_SIZE</CODE> будет игнорироваться. Вы можете устанавливать
значение по умолчанию для этой переменной, запуская <CODE>mysqld</CODE> с
опцией <CODE>-O max_join_size=#</CODE>.

<DT><CODE>SQL_SAFE_UPDATES=0|1</CODE>
<DD>Если установлено в <CODE>1</CODE>, MySQL прервется, если
<CODE>UPDATE</CODE> или <CODE>DELETE</CODE> не использует ключ или
<CODE>LIMIT</CODE> в предложении <CODE>WHERE</CODE>. Это делает возможным
захватить неправильные модификации при создании SQL-команды вручную.

<DT><CODE>SQL_SELECT_LIMIT=value|DEFAULT</CODE>
<DD>Максимальное число записей для возвращения из инструкций
<CODE>SELECT</CODE>. Если <CODE>SELECT</CODE> имеет предложение
<CODE>LIMIT</CODE>, то <CODE>LIMIT</CODE> имеет приоритет над значением в
<CODE>SQL_SELECT_LIMIT</CODE>. Значение по умолчанию для нового подключения:
``unlimited''. Если Вы изменили ограничение, значение по умолчанию может быть
восстановлено, используя значение <CODE>DEFAULT</CODE>.

<DT><CODE>SQL_LOG_OFF=0|1</CODE>
<DD>Если установлено в <CODE>1</CODE>, никакая регистрация не будет выполнена
в стандартный файл регистрации для этого пользователя, если пользователь
имеет привилегию <STRONG>process</STRONG>. Это не воздействует на
файл регистрации модификаций!

<DT><CODE>SQL_LOG_UPDATE=0|1</CODE>
<DD>Если установлено в <CODE>0</CODE>, никакая регистрация не будет выполнена
в файл регистрации модификаций для этого пользователя, если пользователь
имеет привилегию <STRONG>process</STRONG>. Это не воздействует на
стандартный файл регистрации!

<DT><CODE>SQL_QUOTE_SHOW_CREATE=0|1</CODE>
<DD>Если установлено в <CODE>1</CODE>, <CODE>SHOW CREATE TABLE</CODE>
цитирует имена столбцов и таблиц. Это <STRONG>включено</STRONG> по умолчанию
для репликации таблиц с нестандартными именами столбцов. Подробности в
разделе "<A HREF="admin.htm#SHOW_CREATE_TABLE">4.5.5.8
<CODE>SHOW CREATE TABLE</CODE></A>".

<DT><CODE>TIMESTAMP=timestamp_value|DEFAULT</CODE>
<DD>Установить время для этого пользователя. Это применяется, чтобы получить
оригинал timestamp, если Вы используете файл регистрации модификаций, чтобы
восстановить строки. <CODE>timestamp_value</CODE> должен быть в формате UNIX
Epoch timestamp, а не MySQL timestamp.

<DT><CODE>LAST_INSERT_ID=#</CODE>
<DD>Установить значение, которое будет возвращено из
<CODE>LAST_INSERT_ID()</CODE>. Это будет сохранено в файле регистрации
модификаций, когда Вы используете <CODE>LAST_INSERT_ID()</CODE> в команде,
которая модифицирует таблицу.

<DT><CODE>INSERT_ID=#</CODE>
<DD>Установить значение, которое нужно использовать следующей командой
<CODE>INSERT</CODE> или <CODE>ALTER TABLE</CODE> при вставке значения
<CODE>AUTO_INCREMENT</CODE>. Это главным образом используется вместе с файлом
для регистрации модификаций.</DL>

<H2><A NAME="Disk_issues">5.6 Дисковые проблемы</A></H2>
<UL><LI>Как упомянуто ранее, установки дисков представляют собой наиболее
узкое место эффективности. Эти проблемы становятся все более очевидными,
когда данные вырастают настолько, что эффективное кэширование становится
невозможным. Для больших баз данных, где Вы обращаетесь к данным более или
менее беспорядочно, Вы можете убедиться, что Вам понадобиться по крайней мере
одна дисковая установка, чтобы прочитать, и в двух-трех для записи. Чтобы
минимизировать эту проблему, используйте диски с низким временем поиска.

<LI>Ускорение работы с дисками:
<DL COMPACT>
<DT><STRONG>Использование символических ссылок</STRONG>
<DD>Это означает, что Вы переносите индекс и/или файлы данных с нормального
каталога данных на другой диск. Это делает время поиска и чтения меньше (если
эти диски не используются для других вещей). Подробности в разделе
"<A HREF="#Symbolic_links">5.6.1
Использование символических ссылок</A>".

<DT><STRONG>Striping</STRONG>
<DD>Striping означает, что Вы имеете много дисков и помещаете первый блок на
первый диск, второй блок на второй диск и N-й на (N mod number_of_disks)
диск. Это означает, что если нормальный размер данных меньше, чем размер
блока, Вы получите намного лучшую эффективность. Обратите внимание, что
striping очень зависит от OS и размера блока. Обратите внимание, что различие
быстродействия для striping <STRONG>очень</STRONG> зависит от параметров. В
зависимости от того, как Вы устанавливаете параметры и число дисков, Вы
можете получать различие в несколько раз. Обратите внимание, что Вы должны
выбрать как оптимизировать: для произвольного или последовательного доступа.
</DL>

<LI>Для пущей надежности Вы можете использовать RAID 0+1 (striping+mirroring,
данные равномерно размазываются на физически разные диски), но в этом случае
Вы будете нуждаться в 2*N дисках для N дисков данных. Это, вероятно, самый
лучшый вариант, если Вы имеете деньги для его реализации! Вам, вероятно,
также придется поставить некоторое программное обеспечение управления местом
на дисках, чтобы работать эффективно.

<LI>Хорошая система должна иметь не очень важные данные (которые могут быть
восстановлены) на диске RAID 0 при сохранении по-настоящему важных данных
(подобно информации хостов и файлам регистрации) на диске RAID 0+1 или RAID
N. RAID N может быть проблемой, если Вы имеете много записей из-за времени,
нужного, чтобы модифицировать биты четности.

<LI>Вы можете также устанавливать параметры для файловой системы, которую
база данных использует. Одно простое изменение должно установить файловую
систему в режим noatime. Это заставляет систему пропустить модифицирование
последнего времени доступа в inode и этим избежать ряда дисковых установок.

<LI>В Linux Вы можете получить намного большую эффективность (до 100% при
некоторых видах загрузки), используя hdpram, чтобы конфигурировать интерфейс
вашего диска! Достаточно хорошие параметры hdparm для MySQL (и, вероятно, для
многих других прикладных программ):
<PRE>
hdparm -m 16 -d 1
</PRE>

Обратите внимание, что эффективность и надежность при использовании
вышеупомянутого зависят от Ваших аппаратных средств, так что я настоятельно
советую, чтобы Вы проверили Вашу систему полностью после использования
<CODE>hdparm</CODE>. Пожалуйста, проконсультируйтесь с man-страницей на
<CODE>hdparm</CODE> для получения большего количества информации. Если
<CODE>hdparm</CODE> не используется грамотно, можно прихлопнуть все данные на
диске. Резервируйте все перед экспериментированием.

<LI>На многих операционных системах Вы можете монтировать диски с флажком
async, чтобы установить файловую систему, которую нужно модифицировать
асинхронно. Если Ваш компьютер более-менее стабилен, это должно дать Вам
большую эффективность без того, чтобы сильно жертвовать надежностью. Этот
флажок включен по умолчанию в Linux.

<LI>Если Вы не должны знать, когда к файлу в последний раз обращались (а
толку-то это знать на сервере?), Вы можете монтировать Ваши файловые системы
с указанием флажка noatime.</UL>

<H3><A NAME="Symbolic_links">5.6.1 Использование символических ссылок</A>
</H3>
<P>Вы можете перемещать таблицы и базы данных из каталога баз данных куда
хотите и заменять их на символические связи с новыми расположениями. Вы
могли бы сделать это для решения проблем с диском, например, переместить базу
данных на файловую систему с большим количеством свободного пространства или
увеличить быстродействие Вашей системы, распространяя Ваши таблицы на
различные диски.</P>

<H4><A NAME="Symbolic_links_to_databases">5.6.1.1 Использование символических
ссылок для баз данных</A></H4>
<P>Надо сначала создать каталог на некотором диске, где Вы имеете свободное
пространство, и затем создать ссылку туда из каталога баз данных MySQL:</P>
<PRE>
shell&#62; mkdir /dr1/databases/test
shell&#62; ln -s /dr1/databases/test mysqld-datadir
</PRE>

<P>MySQL не поддерживает привязку одного каталога к нескольким базам данных.
Замена каталога баз данных символической связью будет работать прекрасной,
пока Вы не сделаете символическую связь между базами данных. Предположим, что
Вы имеете базу данных <CODE>db1</CODE> в каталоге данных MySQL, а затем
делаете ссылку <CODE>db2</CODE>, которая указывает на <CODE>db1</CODE>:</P>
<PRE>
shell&#62; cd /path/to/datadir
shell&#62; ln -s db1 db2
</PRE>

<P>Теперь для любой таблицы <CODE>tbl_a</CODE> в <CODE>db1</CODE> также
имеется таблица <CODE>tbl_a</CODE> в <CODE>db2</CODE>. Если один поток
модифицирует <CODE>db1.tbl_a</CODE>, а другой в то же время правит
<CODE>db2.tbl_a</CODE>, они точно передерутся.</P>

<P>Если Вы хотите разрешить такие обращения, Вы должны изменить следующий код
в файле исходного текста <TT>mysys/mf_format.c</TT>:</P>
<PRE>
if (flag &#38; 32 || (!lstat(to,&#38;stat_buff) &#38;&
   S_ISLNK(stat_buff.st_mode)))
</PRE>

<P>на</P>
<PRE>
if (1)
</PRE>

<P>В Windows Вы можете использовать внутренние символические связи с
каталогами, компилируя MySQL с опцией <CODE>-DUSE_SYMDIR</CODE>. Это
позволяет Вам размещать различные базы данных на разных дисках. Подробности в
разделе "<A HREF="os.htm#Windows_symbolic_links">2.6.2.5 Размещение
данных на разных дисках в Windows</A>".</P>

<H4><A NAME="Symbolic_links_to_tables">5.6.1.2 Использование символических
ссылок для таблиц</A></H4>
<P>До MySQL 4.0 не стоило пользоваться ссылками без их тщательнейшего
контроля. Проблема состоит в том, что, если Вы выполняете <CODE>ALTER
TABLE</CODE>, <CODE>REPAIR TABLE</CODE> или <CODE>OPTIMIZE TABLE</CODE> на
таблице со связью, ссылка будет удалена и заменена первоначальными файлами.
Это случается потому, что вышеупомянутая команда работает, создавая временный
файл в каталоге баз данных, а когда команда завершится, первоначальный файл
она заменит на временный файл.</P>

<P>Вы не должны связывать таблицы на системе, которая не имеет полностью
рабочее обращение <CODE>realpath()</CODE>. По крайней мере Linux и Solaris
точно поддерживают <CODE>realpath()</CODE>.</P>

<P>В MySQL 4.0 ссылки полностью поддержаны только для таблиц
<CODE>MyISAM</CODE>. Для других типов таблиц Вы, вероятно, получите странные
проблемы при выполнении любой из вышеупомянутых команд.</P>

<P>Обработка символических связей в MySQL 4.0 работает следующим образом:</P>
<UL><LI>В каталоге данных Вы будете всегда иметь файл определения таблицы и
файлы данных/индекса.

<LI>Вы можете перенаправить индексный файл и файл данных к различным
каталогам, независимо друг от друга.

<LI>Установка ссылки может быть выполнена из операционной системы (если
<CODE>mysqld</CODE> не запущен) или с помощью команды <CODE>INDEX/DATA
DIRECTORY="path-to-dir"</CODE> в <CODE>CREATE TABLE</CODE>.

<LI><CODE>myisamchk</CODE> теперь уже не будет заменять ссылки на реальные
файлы, а работает непосредственно на нужных файлах. Любые временные файлы
будут созданы в том же самом каталоге, где лежит файл данных или индекса.

<LI>Когда Вы удаляете таблицу, которая использует ссылки, удалится ссылка и
файл, на который она указывает. Это хорошая причина не выполнять
<CODE>mysqld</CODE> как root, и не позволять кому попало иметь доступ для
записи к каталогам баз данных MySQL.

<LI>Если Вы переименуете таблицу с помощью <CODE>ALTER TABLE RENAME</CODE> и
не измените базу данных, ссылка в каталоге базы данных будет переименована,
как и файл данных/индекса.

<LI>Если Вы используете <CODE>ALTER TABLE RENAME</CODE>, чтобы переместить
таблицу в другую базу данных, то таблица будет перемещаться в другой каталог
баз данных, а старая ссылка и файл, на который она указывала, удалятся.

<LI>Если Вы не используете ссылки, Вы должны использовать опцию
<CODE>--skip-symlink</CODE> при запуске <CODE>mysqld</CODE>, чтобы
гарантировать, что никто не может удалять или переименовывать файл вне
каталога данных MySQL.</UL>

<P>Свойства, которые еще не поддержаны:</P>

<P><UL><LI><CODE>ALTER TABLE</CODE> игнорирует все опции
<CODE>INDEX/DATA DIRECTORY="path"</CODE>.
<LI><CODE>CREATE TABLE</CODE> не сообщает, имеет ли таблица ссылки.
<LI><CODE>mysqldump</CODE> не включает информацию ссылок в вывод.
<LI>Команды <CODE>BACKUP TABLE</CODE> и <CODE>RESTORE TABLE</CODE> не
обрабатывают ссылки вообще.</UL>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</HTML>
