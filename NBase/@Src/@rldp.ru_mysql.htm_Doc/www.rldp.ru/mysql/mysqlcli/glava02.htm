<HTML>
<HEAD>
  <TITLE>Введение в MySQL</TITLE>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
</HEAD>

<BODY>

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<H1><A NAME="Tutorial">2 Введение в MySQL</A></H1>
<P>Эта глава обеспечивает введение в MySQL, показывая, как использовать
клиент <CODE>mysql</CODE>, чтобы создавать и использовать простую базу
данных. <CODE>mysql</CODE> (иногда упоминаемый как "terminal monitor" или
"monitor") представляет собой интерактивную программу, которая позволяет Вам
соединяться с сервером MySQL, выполнять запросы и просматривать результаты.
Она может также использоваться в пакетном режиме: Вы помещаете Ваши запросы в
файл заранее, затем сообщаете, чтобы клиент <CODE>mysql</CODE> выполнил
содержимое файла. Оба пути использования будут здесь рассмотрены.</P>

<P>Чтобы увидеть список параметров <CODE>mysql</CODE>, вызовите его с опцией
<CODE>--help</CODE>:</P>
<PRE>
shell&#62; mysql --help
</PRE>

<P>Эта глава предполагает, что <CODE>mysql</CODE> установлен на Вашей машине,
и что сервер MySQL доступен.</P>

<P>Эта глава описывает весь процесс создания и использования базы данных.
Если Вы заинтересованы только в работе с уже существующей базой данных, Вы
можете пропустить части, которые описывают, как создать базу данных и
таблицы, которые она хранит.</P>

<H2><A NAME="Connecting-disconnecting">2.1 Соединение с сервером</A></H2>
<P>Чтобы соединяться с сервером, Вы обычно должны обеспечить имя пользователя,
когда Вы вызываете <CODE>mysql</CODE> и, вероятно, пароль. Если сервер
выполняется на другой машине, Вы будете также должны определить hostname.
Войдите в контакт с Вашим администратором, чтобы выяснить, какие параметры
соединения Вы должны использовать, чтобы подключиться (то есть, какой
hostname, порт, имя пользователя и пароль). Как только Вы узнаете
соответствующие параметры, Вы должны иметь возможность соединиться так:</P>
<PRE>
shell&#62; mysql -h host -u user -p
Enter password: ********
</PRE>

<P>Здесь <CODE>********</CODE> представляет Ваш пароль. Введите его, когда
<CODE>mysql</CODE> отобразит сообщение <CODE>Enter password:</CODE>.</P>

<P>Если это работает, Вы должны увидеть некоторую вводную информацию,
сопровождаемую подсказкой <CODE>mysql&#62;</CODE>:</P>
<PRE>
shell&#62; mysql -h host -u user -p
Enter password: ********
Welcome to the MySQL monitor. Commands end with ; or \g.
Your MySQL connection id is 459 to server version: 3.22.20a-log

Type 'help' for help.

mysql&#62;
</PRE>

<P>Подсказка сообщает Вам, что <CODE>mysql</CODE> готов принять команды.</P>

<P>Некоторые инсталляции MySQL позволяют пользователям соединяться как
анонимным (неназванным) пользователям с сервером на локальной машине. Если у
Вас дело обстоит именно так, Вы можете соединиться с таким сервером, вызывая
<CODE>mysql</CODE> без параметров:</P>
<PRE>
shell&#62; mysql
</PRE>

<P>После того, как Вы успешно соединились, Вы можете разъединять соединение в
любое время, набрав команду <CODE>QUIT</CODE> в ответ на подсказку
<CODE>mysql&#62;</CODE>:</P>
<PRE>
mysql&#62; QUIT
Bye
</PRE>

<P>Вы можете также разъединять связь, нажимая Control-D.</P>

<P>Большинство примеров в следующих разделах считает, что Вы связаны с
сервером. Они указывают это подсказкой <CODE>mysql&#62;</CODE>.</P>

<H2><A NAME="Entering_queries">2.2 Ввод запросов</A></H2>
<P>В этой точке более важно выяснить немного относительно того, как выдавать
запросы, чем правильно создавать базы данных. Этот раздел описывает базисные
принципы ввода команд, использование нескольких запросов, которые Вы можете
испытывать, чтобы ознакомиться с тем, как работает клиент <CODE>mysql</CODE>.
</P>

<P>Имеется простая команда, которая просит, чтобы сервер сообщил свою версию
и текущую дату. Напечатайте это как показано ниже после подсказки
<CODE>mysql&#62;</CODE> и нажмите клавишу RETURN:</P>
<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
+--------------+--------------+
| version()    | CURRENT_DATE |
+--------------+--------------+
| 3.22.20a-log | 1999-03-19   |
+--------------+--------------+
1 row in set (0.01 sec)
mysql&#62;
</PRE>

<P>Этот запрос иллюстрирует несколько вещей относительно <CODE>mysql</CODE>:
</P>

<UL><LI>Команда обычно состоит из инструкции SQL, сопровождаемой точкой с
запятой. Имеются некоторые исключительные ситуации, где точка с запятой не
требуется, например, упомянутая выше команда <CODE>QUIT</CODE>. Мы доберемся
до других позже.

<LI>Когда Вы выдаете команду, <CODE>mysql</CODE> посылает ее серверу для
выполнения и отображает результаты, затем печатает другой запрос
<CODE>mysql&#62;</CODE>, чтобы указать, что готов для приема другой команды.

<LI><CODE>mysql</CODE> отображает вывод запроса как таблицу (строки и
столбцы). Первая строка содержит метки для столбцов. Следующие строки задают
результаты запроса. Обычно, метки столбца представляют собой имена столбцов,
которые Вы выбираете из таблиц базы данных. Если Вы получаете значение
выражения, а не столбец таблицы, <CODE>mysql</CODE> маркирует столбец,
используя выражение непосредственно.

<LI><CODE>mysql</CODE> показывает, сколько строк было возвращено, и как долго
обрабатывался запрос, что дает Вам грубые данные относительно эффективности
сервера. Эти значения неточны потому, что они представляют не машинное время
или затраты времени CPU, а рамки выполнения запроса. На эти данные действуют,
например, задержки в сетевом канале. Для краткости строка ``rows in set'' не
показывается в оставшихся примерах из этой главы.</UL>

<P>Ключевые слова могут быть введены в любом регистре. Следующие запросы
эквивалентны:</P>
<PRE>
mysql&#62; SELECT VERSION(), CURRENT_DATE;
mysql&#62; select version(), current_date;
mysql&#62; SeLeCt vErSiOn(), current_DATE;
</PRE>

<P>Имеется другой запрос. Он показывает, что Вы можете использовать
<CODE>mysql</CODE> как простой калькулятор:</P>
<PRE>
mysql&#62; SELECT SIN(PI()/4), (4+1)*5;
+-------------+---------+
| SIN(PI()/4) | (4+1)*5 |
+-------------+---------+
|    0.707107 |      25 |
+-------------+---------+
</PRE>

<P>Команды, показанные к настоящему времени, были относительно короткие, с
одной строкой инструкции. Вы можете даже вводить много инструкций на одной
строке. Только закончите каждую их них точкой с запятой:</P>
<PRE>
mysql&#62; SELECT VERSION(); SELECT NOW();
+--------------+
| version()    |
+--------------+
| 3.22.20a-log |
+--------------+
+---------------------+
| NOW()               |
+---------------------+
| 1999-03-19 00:15:33 |
+---------------------+
</PRE>

<P>Однако, команды бывают и длинными. Но длинные команды, которые требуют
нескольких строк, не проблема. <CODE>mysql</CODE> определяет конец оператора,
ища точку с запятой, а не конец строки. Другими словами, <CODE>mysql</CODE>
принимает ввод свободного формата: он собирает вводимые строки, но не
выполняет их, пока не увидит точку с запятой.</P>

<P>Имеется простая инструкция с длинной строкой:</P>
<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; ,
    -&#62; CURRENT_DATE;
+--------------------+--------------+
| USER()             | CURRENT_DATE |
+--------------------+--------------+
| joesmith@localhost | 1999-03-18   |
+--------------------+--------------+
</PRE>

<P>В этом примере обратите внимание, как подсказка изменяется с
<CODE>mysql&#62;</CODE> на <CODE>-&#62;</CODE> после того, как Вы вводите
первую строку запроса. Этим <CODE>mysql</CODE> указывает, что пока не видел
полную инструкцию и ждет остальное. Подсказка Ваш друг потому, что
обеспечивает ценную обратную связь. Если Вы используете эту обратную связь,
Вы будете всегда знать, чего ждет от Вас <CODE>mysql</CODE>.</P>

<P>Если Вы решаете, что Вы не хотите выполнять команду, но находитесь в
процессе ввода, отмените ее вводом <CODE>\c</CODE>:</P>
<PRE>
mysql&#62; SELECT
    -&#62; USER()
    -&#62; \c
mysql&#62;
</PRE>

<P>Здесь также обратите внимание на подсказку. Она переключилась назад в
<CODE>mysql&#62;</CODE> после ввода <CODE>\c</CODE>, обеспечивая обратную
связь, чтобы указать, что <CODE>mysql</CODE> готов для новой команды.</P>

<P>Следующая таблица показывает все подсказки и обобщает их смысл:</P>
<P><TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Подсказка</STRONG></TD><TD><STRONG>Смысл</STRONG></TD></TR>
<TR><TD><CODE>mysql&#62;</CODE></TD><TD>Ожидание новой команды</TD></TR>
<TR><TD><CODE>-&#62;</CODE></TD><TD>Ожидание следующей строки многострочной
команды</TD></TR>
<TR><TD><CODE>'&#62;</CODE></TD><TD>Ожидание следующей строки при сборе
строки, которая начинается с одиночной кавычки (<SAMP>'</SAMP>)</TD></TR>
<TR><TD><CODE>"&#62;</CODE></TD><TD>Ожидание следующей строки при сборе
строки, которая начинается с двойной кавычки (<SAMP>"</SAMP>)</TD></TR>
</TABLE></P>

<P>Иногда многострочные инструкции происходят случайно, когда Вы
предполагаете выдавать команду на одной строке, но забываете точку с запятой
для завершения. В этом случае <CODE>mysql</CODE> ждет продолжение ввода:</P>
<PRE>
mysql&#62; SELECT USER()
    -&#62;
</PRE>

<P>Если это случается с Вами (Вы думаете, что ввели оператор, но единственный
ответ представляет собой подсказку <CODE>-&#62;</CODE>), наиболее вероятно,
что <CODE>mysql</CODE> ждет точку с запятой. Введите точку с запятой, чтобы
завершить инструкцию, и <CODE>mysql</CODE> ее выполнит:</P>
<PRE>
mysql&#62; SELECT USER()
    -&#62; ;
+--------------------+
| USER()             |
+--------------------+
| joesmith@localhost |
+--------------------+
</PRE>

<P>Подсказки <CODE>'&#62;</CODE> и <CODE>"&#62;</CODE> появляются при работе
со строкой в кавычках. В MySQL Вы можете писать строки в символах
<SAMP>'</SAMP> или <SAMP>"</SAMP> (например, <CODE>'hello'</CODE> или
<CODE>"goodbye"</CODE>), и <CODE>mysql</CODE> позволяет Вам вводить длинные
строки в виде нескольких коротких строк. Когда Вы видите подсказку
<CODE>'&#62;</CODE> или <CODE>"&#62;</CODE>, это означает, что Вы ввели
строку, которая начинается с символа кавычки <SAMP>'</SAMP> или
<SAMP>"</SAMP>, но еще не ввели вторую кавычку, которая завершает эту строку.
Это также может сообщать и об ошибке:</P>
<PRE>
mysql&#62; SELECT * FROM my_table WHERE name="Smith AND age &#60; 30;
    "&#62;
</PRE>

<P>Если Вы вводите эту инструкцию <CODE>SELECT</CODE>, то нажатие RETURN
ничего не вернет. Вместо того, чтобы задаваться вопросом, почему этот запрос
так долго выполняется, обратите внимание на подсказку <CODE>"&#62;</CODE>.
Это сообщает Вам, что <CODE>mysql</CODE> ожидает увидеть остальную часть
незавершенной строки. Вы видите ошибку в инструкции? Строка
<CODE>"Smith</CODE> пропускает вторую кавычку.</P>

<P>Что делать? Самая простая вещь: отменить команду. Однако, Вы не можете
в этом случае просто напечатать <CODE>\c</CODE>, так как <CODE>mysql</CODE>
интерпретирует это как часть, которая вводится! Вместо этого, введите
заключительный символ кавычки (чтобы <CODE>mysql</CODE> понял, что Вы
закончили строку), а уж потом <CODE>\c</CODE>:</P>
<PRE>
mysql&#62; SELECT * FROM my_table WHERE name = "Smith AND age &#60; 30;
    "&#62; "\c
mysql&#62;
</PRE>

<P>Подсказка изменяется обратно на <CODE>mysql&#62;</CODE>, указывая, что
<CODE>mysql</CODE> готов для новой команды.</P>

<P>Важно знать, что сообщают подсказки <CODE>'&#62;</CODE> и
<CODE>"&#62;</CODE>, так как если Вы по ошибке вводите незавершенную строку,
любые дальнейшие строки, которые Вы введете, будут игнорироваться
<CODE>mysql</CODE>, включая строку <CODE>QUIT</CODE>! Это может крепко
запутать, особенно, если Вы не знаете, что должны ввести кавычку завершения
прежде, чем Вы сможете отменить текущую команду.</P>

<H2><A NAME="Database_use">2.3 Создание и использование баз данных</A></H2>
<P>Теперь, когда Вы знаете, как вводить команды, самое время обратиться к
базе данных.</P>

<P>Предположим, что Вы имеете несколько домашних животных, и Вы хотели бы
следить за различными типами информации относительно их. Вы можете сделать
это, создавая таблицы, чтобы хранить Ваши данные и загружая их желательной
информацией. Затем Вы можете отвечать на различные типы вопросов относительно
Ваших животных, получая данные из таблиц. Этот раздел показывает Вам как:</P>

<UL><LI>Создать базу данных
<LI>Создать в ней таблицу
<LI>Загрузить данные в таблицу
<LI>Получить данные из имеющейся таблицы разными способами
<LI>Использовать несколько таблиц сразу</UL>

<P>База данных животных будет простой, но нетрудно думать о реальных
ситуациях, в которых подобный тип базы данных мог бы использоваться.
Например, база данных, подобная этой, могла бы использоваться фермером, чтобы
следить за домашним скотом, или ветеринаром, чтобы наблюдать за пациентами.
Дистрибутив базы животных, содержащий некоторые из запросов и типовых данных,
используемых в следующих разделах, может быть получен с Web-сайта MySQL в
<a HREF="../../../www.mysql.com/Downloads/Contrib/Examples/menagerie.tar.gz">
сжатом <CODE>tar</CODE> формате</a> или в
<a HREF="../../../www.mysql.com/Downloads/Contrib/Examples/menagerie.zip">
Zip-формате</a>.</P>

<P>Используйте инструкцию <CODE>SHOW</CODE>, чтобы выяснить то, какие базы
данных в настоящее время существуют на Вашем сервере:</P>
<PRE>
mysql&#62; SHOW DATABASES;
+----------+
| Database |
+----------+
| mysql    |
| test     |
| tmp      |
+----------+
</PRE>

<P>Список баз данных, вероятно, иной на Вашей машине, но базы с именами
<CODE>mysql</CODE> и <CODE>test</CODE>, вероятно, будут среди них. База
данных <CODE>mysql</CODE> вообще обязательна потому, что она описывает
привилегии доступа пользователей. База данных <CODE>test</CODE> часто
обеспечивается как рабочая область для начинающих пользователей (лягушатник).
Именно там проводятся разные "опыты со взрывами".</P>

<P>Если существует база данных <CODE>test</CODE>, попробуйте обратиться к ней:
</P>
<PRE>
mysql&#62; USE test
Database changed
</PRE>

<P>Обратите внимание, что <CODE>USE</CODE>, подобно <CODE>QUIT</CODE>, не
требует точки с запятой. Вы можете завершать такие инструкции точкой с
запятой, если Вы находите это приятным, такой подход не несет никакого вреда.
Инструкция <CODE>USE</CODE> должна быть задана в одной строке.</P>

<P>Вы можете использовать базу данных тестов <CODE>test</CODE> (если Вы
имеете доступ к ней) для примеров, но все, что Вы там насоздавали, может быть
удалено кем-либо еще с доступом к ней. По этой причине, Вы должны, вероятно,
спросить у Вашего администратора MySQL разрешения использовать собственную
базу данных. Предположим, что Вы хотите вызвать Ваш звероуголок
(<CODE>menagerie</CODE>). Администратор должен выполнить такую команду:</P>
<PRE>
mysql&#62; GRANT ALL ON menagerie.* TO your_mysql_name;
</PRE>

<P>Здесь <CODE>your_mysql_name</CODE> представляет собой имя пользователя
MySQL, назначенное Вам.</P>

<H3><A NAME="Creating_database">2.3.1 Создание и выбор баз данных</A></H3>
<P>Если администратор создал базу данных для Вас и установил Ваши права
доступа, Вы можете начинать использовать ее. Иначе, Вы должны создать базу
данных самостоятельно. Например:</P>
<PRE>
mysql&#62; CREATE DATABASE menagerie;
</PRE>

<P>Под Unix имена баз данных чувствительны к регистру (в отличие от ключевых
слов SQL), так что Вы должны всегда обращаться к Вашей базе данных как к
<CODE>menagerie</CODE>, но не как <CODE>Menagerie</CODE>,
<CODE>MENAGERIE</CODE> или еще как-то. Это также верно для имен таблицы. Под
Windows это ограничение не применяется, хотя Вы должны обращаться к базам
данных и таблицам, используя тот же самый регистр символов в течение запроса.
</P>

<P>Создание базы данных не выбирает ее для использования, Вы должны сделать
это явно. Чтобы объявить <CODE>menagerie</CODE> текущей (актуальной) базой
данных, используйте эту команду:</P>
<PRE>
mysql&#62; USE menagerie
Database changed
</PRE>

<P>Ваша база данных должна быть создана только однажды, но Вы должны выбирать
ее для использования каждый раз, когда Вы начинаете сеанс <CODE>mysql</CODE>.
Вы можете сделать это, выдавая инструкцию <CODE>USE</CODE> как показано выше.
Альтернативно, Вы можете выбирать базу данных в командной строке, когда Вы
вызываете <CODE>mysql</CODE>. Только определите имя после любых параметров
подключения к серверу, которые Вы должны обеспечить. Например:</P>
<PRE>
shell&#62; mysql -h host -u user -p menagerie
Enter password: ********
</PRE>

<P>Обратите внимание, что <CODE>menagerie</CODE> не Ваш пароль. Если Вы
хотите указать пароль в командной строке после опции <CODE>-p</CODE>, Вы
должны сделать это без пробела (например, как <CODE>-pmypassword</CODE>, но
не как <CODE>-p mypassword</CODE>). Однако, помещение Вашего пароля в
командную строку не рекомендуется потому, что это выставит его на всеобщее
обозрение всем пользователям Вашей машины.</P>

<H3><A NAME="Creating_tables">2.3.2 Создание таблицы</A></H3>
<P>Создание базы данных дело простое, но сейчас база пустая, о чем и сообщает
команда <CODE>SHOW TABLES</CODE>:</P>
<PRE>
mysql&#62; SHOW TABLES;
Empty set (0.00 sec)
</PRE>

<P>Наиболее трудная часть этого дела: решить, какова будет структура Вашей
базы данных, в каких таблицах Вы будете нуждаться, и какие столбцы будут в
каждой из них.</P>

<P>Вы будете иметь таблицу, которая содержит запись для каждого из Ваших
домашних животных. Она может быть названа <CODE>pet</CODE> и должна
содержать, как минимум, имя каждого животного. Так как имя само по себе не
очень интересно, таблица должна содержать и другую информацию. Например, если
больше, чем один человек в Вашем семействе имеет домашних животных, Вы могли
бы внести в список владельца каждого животного. Вы могли бы также записывать
некоторую базисную описательную информацию типа разновидности и пола.</P>

<P>Каков приблизительный возраст? Это могло бы быть интересным, но лучше не
вписывать такие данные в таблицу. Возраст изменяется, а это означает, что Вы
должны будете часто модифицировать Ваши записи. Вместо этого лучше сохранить
фиксированное значение, типа даты рождения. Затем всякий раз, когда Вы
нуждаетесь в данных о возрасте, Вы можете вычислить его как различие (но не
разность!) между текущей датой и датой рождения. MySQL обеспечивает функции
для выполнения арифметики даты, так что это нетрудно. Сохранение даты
рождения имеет также и другие преимущества:</P>

<UL><LI>Вы можете использовать базу данных для задач, типа производства
напоминаний о приближающихся со страшной скоростью любимых днях рождения.
Если Вы думаете, что этот тип запроса несколько глуп, подумайте, как здорово
он будет смотреться в контексте деловой базы данных, по которой надо
разослать постоянным клиентам поздравления с днем рождения. В плане рекламы
фирмы хорошие отношения с постоянными клиентами имеют важнейшее значение...

<LI>Вы можете вычислять возраст относительно других дат, а не текущей.
Например, если Вы сохраняете дату гибели животного, вычислить его возраст не
составит никакого труда.</UL>

<P>Пока в таблице <CODE>pet</CODE> ограничимся данными об имени, владельце,
разновидности, поле, рождении и гибели, если она произошла.</P>

<P>Используйте инструкцию <CODE>CREATE TABLE</CODE>, чтобы определить
размещение Вашей таблицы:</P>
<PRE>
mysql&#62; CREATE TABLE pet (name VARCHAR(20), owner VARCHAR(20),
    -&#62; species VARCHAR(20), sex CHAR(1), birth DATE, death DATE);
</PRE>

<P><CODE>VARCHAR</CODE> представляет собой хороший выбор для столбцов имени,
владельца и разновидности потому, что значения столбца изменяются по длине.
Длины столбцов <CODE>name</CODE>, <CODE>owner</CODE> и <CODE>species</CODE>
не должны превышать 20 символов. Вообще-то, для этого типа столбцов Вы можете
выбирать любую длину от <CODE>1</CODE> до <CODE>255</CODE>, какая кажется
наиболее приемлемой Вам. Если Вы делаете столбец недостаточных размеров,
а позже окажется, что Вы нуждаетесь в более длинном поле, MySQL обеспечивает
инструкцию <CODE>ALTER TABLE</CODE>.</P>

<P>Пол животных можно представить разными путями, например, <CODE>"m"</CODE>
и <CODE>"f"</CODE> или словами <CODE>"male"</CODE> и <CODE>"female"</CODE>.
Самое простое: использовать одиночные символы <CODE>"m"</CODE> и
<CODE>"f"</CODE>.</P>

<P>Использование типа данных <CODE>DATE</CODE> для столбцов рождения и гибели
(<CODE>birth</CODE> и <CODE>death</CODE>) явно довольно очевидный выбор.</P>

<P>Теперь, когда Вы создали таблицу, <CODE>SHOW TABLES</CODE> должен
произвести некоторый вывод:</P>
<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| pet                 |
+---------------------+
</PRE>

<P>Чтобы проверить, что Ваша таблица была создана тем путем, каким Вы
ожидали, используйте инструкцию <CODE>DESCRIBE</CODE>:</P>
<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P>Вы можете использовать <CODE>DESCRIBE</CODE> в любое время, например, если
Вы забываете имена столбцов в Вашей таблице, или каких они типов.</P>

<H3><A NAME="Loading_tables">2.3.3 Загрузка данных в таблицу</A></H3>
<P>После создания Вашей таблицы Вы должны заполнить ее. Инструкции
<CODE>LOAD DATA</CODE> и <CODE>INSERT</CODE> полезны для этого.</P>

<P>Предположим, что Ваши записи о живности могут быть описаны как показано
ниже. Заметьте, что MySQL ожидает даты в формате <CODE>YYYY-MM-DD</CODE>, это
может быть отлично от того, к чему Вы привыкли.</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>name</STRONG></TD><TD><STRONG>owner</STRONG></TD><TD><STRONG>
species</STRONG></TD><TD><STRONG>sex</STRONG></TD><TD><STRONG>birth</STRONG>
</TD><TD><STRONG>death</STRONG></TD></TR>
<TR><TD>Fluffy</TD><TD>Harold</TD><TD>кошка</TD><TD>f</TD><TD>1993-02-04</TD>
<TD></TD></TR>
<TR><TD>Claws</TD><TD>Gwen</TD><TD>кошка</TD><TD>m</TD><TD>1994-03-17</TD>
<TD></TD></TR>
<TR><TD>Buffy</TD><TD>Harold</TD><TD>собака</TD><TD>f</TD><TD>1989-05-13</TD>
<TD></TD></TR>
<TR><TD>Fang</TD><TD>Benny</TD><TD>собака</TD><TD>m</TD><TD>1990-08-27</TD>
<TD></TD></TR>
<TR><TD>Bowser</TD><TD>Diane</TD><TD>собака</TD><TD>m</TD><TD>1989-08-31</TD>
<TD>1995-07-29</TD></TR>
<TR><TD>Chirpy</TD><TD>Gwen</TD><TD>птичка</TD><TD>f</TD><TD>1998-09-11</TD>
<TD></TD></TR>
<TR><TD>Whistler</TD><TD>Gwen</TD><TD>птичка</TD><TD></TD><TD>1997-12-09</TD>
<TD></TD></TR>
<TR><TD>Slim</TD><TD>Benny</TD><TD>змея</TD><TD>m</TD><TD>1996-04-29</TD><TD>
</TD></TR></TABLE>

<P>Поскольку Вы начинаете работу с пустой таблицей, самый простой способ
заполнить ее состоит в том, чтобы создать текстовый файл, содержащий строку
для каждого из Ваших животных, затем загрузить содержимое файла в таблицу
всего одной инструкцией.</P>

<P>Вы могли бы создать текстовый файл <TT>pet.txt</TT>, содержащий одну
запись на строку, со значениями, отделяемыми позициями табуляции, указанными
в том порядке, в котором столбцы были перечислены в инструкции <CODE>CREATE
TABLE</CODE>. Для отсутствующих значений (типа неизвестного пола или дат
гибели для животных, которые все еще живут), Вы можете использовать значения
<CODE>NULL</CODE>. Чтобы представить их в Вашем текстовом файле, используйте
<CODE>\N</CODE>. Например, запись для птички Whistler выглядит примерно так
(пробелом я обозначил табуляцию):
<PRE>
Whistler Gwen птичка \N 1997-12-09 \N
</PRE></P>

<P>Чтобы загрузить текстовый файл <TT>pet.txt</TT> в таблицу
<CODE>pet</CODE>, используйте эту команду:</P>
<PRE>
mysql&#62; LOAD DATA LOCAL INFILE "pet.txt" INTO TABLE pet;
</PRE>

<P>Вы можете определять разделитель значений столбцов и маркер конца строки
в инструкции явно <CODE>LOAD DATA</CODE>, если Вы желаете, но значениями по
умолчанию являются табуляция и перевод строки. Они достаточны, чтобы
правильно прочитать файл <TT>pet.txt</TT>.</P>

<P>Когда Вы хотите добавить новые записи по одной, полезна инструкция
<CODE>INSERT</CODE>. В самой простой ее форме Вы обеспечиваете значения для
каждого столбца в том порядке, в котором столбцы были перечислены в
инструкции <CODE>CREATE TABLE</CODE>. Предположим, что Diane получила нового
хомяка Puffball. Вы можете добавить новую запись, используя инструкцию
<CODE>INSERT</CODE>, подобно этому:</P>
<PRE>
mysql&#62; INSERT INTO pet
    -&#62; VALUES ('Puffball','Diane','hamster','f','1999-03-30',NULL);
</PRE>

<P>Обратите внимание, что строка и значения даты определены как цитируемые
строки. Вы можете вставлять <CODE>NULL</CODE> непосредственно, чтобы
представить отсутствие значения.</P>

<P>Из этого примера Вы видите, что для непосредственной загрузки в таблицу
пришлось бы печатать довольно много. Инструкция <CODE>LOAD DATA</CODE>
сберегла много времени.</P>

<H3><A NAME="Retrieving_data">2.3.4 Получение информации из таблицы</A></H3>
<P>Инструкция <CODE>SELECT</CODE> используется, чтобы получить информацию из
таблицы. Общая форма инструкции:</P>
<PRE>
SELECT what_to_select FROM which_table WHERE conditions_to_satisfy
</PRE>

<P><CODE>what_to_select</CODE> указывает то, что Вы хотите увидеть. Это может
быть список столбцов или <CODE>*</CODE>, чтобы указать все столбцы.
<CODE>which_table</CODE> указывает таблицу, из которой Вы хотите получить
данные. Предложение <CODE>WHERE</CODE> факультативно. Если оно представлено,
<CODE>conditions_to_satisfy</CODE> определяет условия, которым должны
удовлетворять искомые строки.</P>

<H4><A NAME="Selecting_all">2.3.4.1 Выбор всех данных</A></H4>
<P>Самая простая форма <CODE>SELECT</CODE> получает все из таблицы:</P>
<PRE>
mysql&#62; SELECT * FROM pet;
+----------+--------+---------+------+------------+------------+
| name     | owner  | species | sex  | birth      | death      |
+----------+--------+---------+------+------------+------------+
| Fluffy   | Harold | cat     | f    | 1993-02-04 | NULL       |
| Claws    | Gwen   | cat     | m    | 1994-03-17 | NULL       |
| Buffy    | Harold | dog     | f    | 1989-05-13 | NULL       |
| Fang     | Benny  | dog     | m    | 1990-08-27 | NULL       |
| Bowser   | Diane  | dog     | m    | 1998-08-31 | 1995-07-29 |
| Chirpy   | Gwen   | bird    | f    | 1998-09-11 | NULL       |
| Whistler | Gwen   | bird    | NULL | 1997-12-09 | NULL       |
| Slim     | Benny  | snake   | m    | 1996-04-29 | NULL       |
| Puffball | Diane  | hamster | f    | 1999-03-30 | NULL       |
+----------+--------+---------+------+------------+------------+
</PRE>

<P>Эта форма <CODE>SELECT</CODE> полезна, если Вы хотите сделать обзор всей
Вашей таблицы, например, после того, как Вы только что загрузили ее начальным
набором данных. Удобно искать ошибки.</P>

<P>Как показано выше, просто получить всю таблицу. Но обычно Вы не хотите
делать это, особенно, когда таблица становится большой. Вместо этого, Вы
обычно больше заинтересованы в ответе на специфический вопрос, когда Вы
определяете некоторые ограничения на информацию, которую Вы хотите получить.
Давайте рассматривать некоторые запросы <CODE>SELECT</CODE> относительно
Ваших домашних животных в терминах вопросов, на которые они отвечают.</P>

<H4><A NAME="Selecting_rows">2.3.4.2 Выбор конкретных строк</A></H4>
<P>Вы можете выбирать только специфические строки из Вашей таблицы. Например,
если Вы хотите проверить изменение, которое Вы сделали в дате рождения
Bowser, выберите запись для Bowser подобно этому:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name = "Bowser";
+--------+-------+---------+------+------------+------------+
| name   | owner | species | sex  | birth      | death      |
+--------+-------+---------+------+------------+------------+
| Bowser | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+-------+---------+------+------------+------------+
</PRE>

<P>Вывод подтверждает, что год теперь правильно зарегистрирован как 1989, а
не 1998.</P>

<P>Сравнения строк обычно не чувствительны к регистру, так что Вы можете
определять имя как <CODE>"bowser"</CODE>, <CODE>"BOWSER"</CODE> или как
хотите. Результат запроса будет тот же самый.</P>

<P>Вы можете определять произвольные условия на любом столбце, не только
<CODE>name</CODE>. Например, если Вы хотите знать, какие животные были
рождены после 1998 года, проверьте столбец <CODE>birth</CODE>:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE birth &#62;= "1998-1-1";
+----------+-------+---------+-----+------------+-------+
| name     | owner | species | sex | birth      | death |
+----------+-------+---------+-----+------------+-------+
| Chirpy   | Gwen  | bird    | f   | 1998-09-11 | NULL  |
| Puffball | Diane | hamster | f   | 1999-03-30 | NULL  |
+----------+-------+---------+-----+------------+-------+
</PRE>

<P>Вы можете объединять условия, например, найти самок собак:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE species="dog" AND sex="f";
+-------+--------+---------+-----+------------+-------+
| name  | owner  | species | sex | birth      | death |
+-------+--------+---------+-----+------------+-------+
| Buffy | Harold | dog     | f   | 1989-05-13 | NULL  |
+-------+--------+---------+-----+------------+-------+
</PRE>

<P>Предшествующий запрос использует логический оператор <CODE>AND</CODE>.
Имеется также оператор <CODE>OR</CODE>:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE species="snake" OR species="bird";
+----------+-------+---------+------+------------+-------+
| name     | owner | species | sex  | birth      | death |
+----------+-------+---------+------+------------+-------+
| Chirpy   | Gwen  | bird    | f    | 1998-09-11 | NULL  |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL  |
| Slim     | Benny | snake   | m    | 1996-04-29 | NULL  |
+----------+-------+---------+------+------------+-------+
</PRE>

<P>Операторы <CODE>AND</CODE> и <CODE>OR</CODE> могут быть перемешаны. Тут
стоит использовать круглые скобки, чтобы указать, как именно условия
должны быть сгруппированы:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE (species = "cat" AND sex = "m")
    -&#62; OR (species = "dog" AND sex = "f");
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<H4><A NAME="Selecting_columns">2.3.4.3 Выбор произвольных столбцов</A></H4>
<P>Если Вы не хотите видеть все строки из Вашей таблицы, только укажите
столбцы, в которых вы заинтересованы, отделяя их запятыми. Например, если Вы
хотите знать, когда Ваши животные были рождены, выберите столбцы
<CODE>name</CODE> и <CODE>birth</CODE>:</P>
<PRE>
mysql&#62; SELECT name, birth FROM pet;
+----------+------------+
| name     | birth      |
+----------+------------+
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Buffy    | 1989-05-13 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>Чтобы выяснить, кто обладает домашним животным, используйте такой запрос:
</P>
<PRE>
mysql&#62; SELECT owner FROM pet;
+--------+
| owner  |
+--------+
| Harold |
| Gwen   |
| Harold |
| Benny  |
| Diane  |
| Gwen   |
| Gwen   |
| Benny  |
| Diane  |
+--------+
</PRE>

<P><A NAME="IDX376"></A>Однако, обратите внимание, что запрос просто находит
поле <CODE>owner</CODE> из каждой записи, и некоторые из них появляются
больше, чем однажды. Чтобы минимизировать вывод, получите каждую уникальную
запись вывода только однажды, добавляя ключевое слово <CODE>DISTINCT</CODE>:
</P>
<PRE>
mysql&#62; SELECT DISTINCT owner FROM pet;
+--------+
| owner  |
+--------+
| Benny  |
| Diane  |
| Gwen   |
| Harold |
+--------+
</PRE>

<P>Вы можете использовать предложение <CODE>WHERE</CODE>, чтобы объединить
выбор строки с выбором столбца. Например, чтобы получить даты рождения только
для кошек и собак, используйте запрос:</P>
<PRE>
mysql&#62; SELECT name, species, birth FROM pet
    -&#62; WHERE species = "dog" OR species = "cat";
+--------+---------+------------+
| name   | species | birth      |
+--------+---------+------------+
| Fluffy | cat     | 1993-02-04 |
| Claws  | cat     | 1994-03-17 |
| Buffy  | dog     | 1989-05-13 |
| Fang   | dog     | 1990-08-27 |
| Bowser | dog     | 1989-08-31 |
+--------+---------+------------+
</PRE>

<H4><A NAME="Sorting_rows">2.3.4.4 Сортировка строк</A></H4>
<P>Вы, возможно, отметили в предшествующих примерах, что строки результатов
не отображаются ни в каком специфическом порядке. Однако, часто проще
исследовать вывод запроса, когда строки сортируются некоторым способом. Чтобы
отсортировать результат, используйте предложение <CODE>ORDER BY</CODE>.</P>

<P>Отсортируем дни рождения нашей живности:</P>
<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth;
+----------+------------+
| name     | birth      |
+----------+------------+
| Buffy    | 1989-05-13 |
| Bowser   | 1989-08-31 |
| Fang     | 1990-08-27 |
| Fluffy   | 1993-02-04 |
| Claws    | 1994-03-17 |
| Slim     | 1996-04-29 |
| Whistler | 1997-12-09 |
| Chirpy   | 1998-09-11 |
| Puffball | 1999-03-30 |
+----------+------------+
</PRE>

<P>Чтобы сортировать в обратном порядке, добавьте к имени столбца, по
которому Вы сортируете, ключевое слово <CODE>DESC</CODE>:</P>
<PRE>
mysql&#62; SELECT name, birth FROM pet ORDER BY birth DESC;
+----------+------------+
| name     | birth      |
+----------+------------+
| Puffball | 1999-03-30 |
| Chirpy   | 1998-09-11 |
| Whistler | 1997-12-09 |
| Slim     | 1996-04-29 |
| Claws    | 1994-03-17 |
| Fluffy   | 1993-02-04 |
| Fang     | 1990-08-27 |
| Bowser   | 1989-08-31 |
| Buffy    | 1989-05-13 |
+----------+------------+
</PRE>

<P>Вы можете сортировать по нескольким столбцам сразу. Например, чтобы
сортировать типы животных, затем внутри определенных типов выполнить
сортировку по датам рождения, выполните (самых молодых зверушек надо
поместить в начало списка):</P>
<PRE>
mysql&#62; SELECT name, species, birth FROM pet ORDER BY species, birth DESC;
+----------+---------+------------+
| name     | species | birth      |
+----------+---------+------------+
| Chirpy   | bird    | 1998-09-11 |
| Whistler | bird    | 1997-12-09 |
| Claws    | cat     | 1994-03-17 |
| Fluffy   | cat     | 1993-02-04 |
| Fang     | dog     | 1990-08-27 |
| Bowser   | dog     | 1989-08-31 |
| Buffy    | dog     | 1989-05-13 |
| Puffball | hamster | 1999-03-30 |
| Slim     | snake   | 1996-04-29 |
+----------+---------+------------+
</PRE>

<P>Обратите внимание, что ключевое слово <CODE>DESC</CODE> применяется только
к имени столбца непосредственно перед ним (<CODE>birth</CODE>), а значения
<CODE>species</CODE> сортируются в порядке возрастания.</P>

<H4><A NAME="Date_calculations">2.3.4.5 Вычисление дат</A></H4>
<P>MySQL обеспечивает несколько функций, которые Вы можете использовать,
чтобы выполнить вычисления на датах, например, вычислять возрасты животных.
</P>

<P>Чтобы определять сколько лет каждому из Ваших домашних животных, надо
вычислить разницу между текущей датой и днем рожления. Следующий запрос
показывает для каждого домашнего животного дату рождения, текущую дату и
возраст в целых годах.</P>
<PRE>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; -(RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5)) AS age FROM pet;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
+----------+------------+--------------+------+
</PRE>

<P>Здесь <CODE>YEAR()</CODE> выделяет часть года даты, <CODE>RIGHT()</CODE>
убирает пять символов, которые представляют часть <CODE>MM-DD</CODE> даты.
Часть выражения, которое сравнивает значения <CODE>MM-DD</CODE>, выставляется
в 1 или 0, что корректирует различие лет, если <CODE>CURRENT_DATE</CODE>
стоит ранее в году, чем рождение (<CODE>birth</CODE>). Полное выражение
несколько перегружено, так что псевдоним (<CODE>age</CODE>) используется,
чтобы заставить столбец вывода обрести более читабельный заголовок.</P>

<P>Запрос работает, но результат мог бы быть просмотрен более легко, если
строки были выведены в некотором порядке. Это может быть выполнено, добавляя
предложение <CODE>ORDER BY name</CODE>, чтобы сортировать вывод:</P>
<PRE>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; -(RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age FROM pet ORDER BY name;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
+----------+------------+--------------+------+
</PRE>

<P>Чтобы отсортировать вывод по возрасту (<CODE>age</CODE>), а не по имени
(<CODE>name</CODE>), примените другое предложение <CODE>ORDER BY</CODE>:</P>
<PRE>
mysql&#62; SELECT name, birth, CURRENT_DATE,
    -&#62; (YEAR(CURRENT_DATE)-YEAR(birth))
    -&#62; -(RIGHT(CURRENT_DATE,5)&#60;RIGHT(birth,5))
    -&#62; AS age FROM pet ORDER BY age;
+----------+------------+--------------+------+
| name     | birth      | CURRENT_DATE | age  |
+----------+------------+--------------+------+
| Chirpy   | 1998-09-11 | 2001-08-29   |    2 |
| Puffball | 1999-03-30 | 2001-08-29   |    2 |
| Whistler | 1997-12-09 | 2001-08-29   |    3 |
| Slim     | 1996-04-29 | 2001-08-29   |    5 |
| Claws    | 1994-03-17 | 2001-08-29   |    7 |
| Fluffy   | 1993-02-04 | 2001-08-29   |    8 |
| Fang     | 1990-08-27 | 2001-08-29   |   11 |
| Bowser   | 1989-08-31 | 2001-08-29   |   11 |
| Buffy    | 1989-05-13 | 2001-08-29   |   12 |
+----------+------------+--------------+------+
</PRE>

<P>Подобный запрос может использоваться, чтобы определить возраст для
животных, которые умерли. Вы определяете такие случаи, проверяя, является или
нет значение <CODE>death</CODE> равным <CODE>NULL</CODE>. Затем, для тех,
которые не-<CODE>NULL</CODE>, вычислите разницу между <CODE>death</CODE> и
<CODE>birth</CODE>:</P>
<PRE>
mysql&#62; SELECT name, birth, death,
    -&#62; (YEAR(death)-YEAR(birth)) - (RIGHT(death,5)&#60;RIGHT(birth,5))
    -&#62; AS age
    -&#62; FROM pet WHERE death IS NOT NULL ORDER BY age;
+--------+------------+------------+------+
| name   | birth      | death      | age  |
+--------+------------+------------+------+
| Bowser | 1989-08-31 | 1995-07-29 |    5 |
+--------+------------+------------+------+
</PRE>

<P>Запрос использует <CODE>death IS NOT NULL</CODE> вместо <CODE>death !=
NULL</CODE> потому, что <CODE>NULL</CODE> специальное значение. Подробности в
разделе "<A HREF="#Working_with_NULL">2.3.4.6 Работа со значениями
<CODE>NULL</CODE></A>".</P>

<P>Что делать, если Вы хотите знать, какие животные имеют дни рождения в
следующем месяце? Для этого типа вычисления, год и день не годятся. Вы просто
хотите извлекать часть месяца из столбца <CODE>birth</CODE>. MySQL
обеспечивает несколько функций извлечения частей даты, типа
<CODE>YEAR()</CODE>, <CODE>MONTH()</CODE> и <CODE>DAYOFMONTH()</CODE>. Чтобы
увидеть, как это работает, выполните простой запрос, который отображает
значения <CODE>birth</CODE> и <CODE>MONTH(birth)</CODE>:</P>
<PRE>
mysql&#62; SELECT name, birth, MONTH(birth) FROM pet;
+----------+------------+--------------+
| name     | birth      | MONTH(birth) |
+----------+------------+--------------+
| Fluffy   | 1993-02-04 |            2 |
| Claws    | 1994-03-17 |            3 |
| Buffy    | 1989-05-13 |            5 |
| Fang     | 1990-08-27 |            8 |
| Bowser   | 1989-08-31 |            8 |
| Chirpy   | 1998-09-11 |            9 |
| Whistler | 1997-12-09 |           12 |
| Slim     | 1996-04-29 |            4 |
| Puffball | 1999-03-30 |            3 |
+----------+------------+--------------+
</PRE>

<P>Поиск животных с днями рождения в наступающем месяце прост. Предположим,
что текущий месяц апрель. Значение month равно <CODE>4</CODE>, и Вы ищете
животных, рожденных в мае (month=5):</P>
<PRE>
mysql&#62; SELECT name, birth FROM pet WHERE MONTH(birth) = 5;
+-------+------------+
| name  | birth      |
+-------+------------+
| Buffy | 1989-05-13 |
+-------+------------+
</PRE>

<P>Имеется маленькое осложнение, если текущий месяц декабрь. Здесь надо
искать животных, рожденных в январе.</P>

<P>Вы можете даже написать запрос так, чтобы это работало независимо от того,
каков текущий месяц. <CODE>DATE_ADD()</CODE> позволяет Вам добавлять интервал
времени к заданной дате. Если Вы добавляете месяц к значению
<CODE>NOW()</CODE>, а затем извлекаете часть месяца с помощью
<CODE>MONTH()</CODE>, результатом как раз и будет тот месяц, в котором надо
искать дни рождения:</P>
<PRE>
mysql&#62; SELECT name, birth FROM pet
    -&#62; WHERE MONTH(birth) = MONTH(DATE_ADD(NOW(), INTERVAL 1 MONTH));
</PRE>

<H4><A NAME="Working_with_NULL">2.3.4.6
Работа со значениями <CODE>NULL</CODE></A></H4>
<P>Значение <CODE>NULL</CODE> может удивлять, пока Вы не привыкнете к нему.
Концептуально, <CODE>NULL</CODE> означает отсутствие средств для оценки или
неизвестное значение, и это обрабатывается несколько по-другому, чем другие
значения. Для проверки на <CODE>NULL</CODE> Вы не можете использовать
арифметические операторы, например, <CODE>=</CODE>, <CODE>&#60;</CODE> или
<CODE>!=</CODE>. Чтобы показать это, попробуйте следующий запрос:</P>
<PRE>
mysql&#62; SELECT 1 = NULL, 1 != NULL, 1 &#60; NULL, 1 &#62; NULL;
+----------+-----------+----------+----------+
| 1 = NULL | 1 != NULL | 1 &#60; NULL | 1 &#62; NULL |
+----------+-----------+----------+----------+
|     NULL |      NULL |     NULL |     NULL |
+----------+-----------+----------+----------+
</PRE>

<P>Очевидно, что никакого толка от таких сравнений нет и не будет.
Используйте взамен операторы <CODE>IS NULL</CODE> и <CODE>IS NOT NULL</CODE>:
</P>
<PRE>
mysql&#62; SELECT 1 IS NULL, 1 IS NOT NULL;
+-----------+---------------+
| 1 IS NULL | 1 IS NOT NULL |
+-----------+---------------+
|         0 |             1 |
+-----------+---------------+
</PRE>

<P>В MySQL 0 или <CODE>NULL</CODE> означает false в логических операциях, а
все остальное значит true. Заданное по умолчанию значение истины в булевых
операциях равно 1.</P>

<P>Эта специальная обработка <CODE>NULL</CODE> является причиной того, почему
в предыдущем разделе было необходимо определить, которые животные умерли,
используя именно <CODE>death IS NOT NULL</CODE> вместо
<CODE>death!=NULL</CODE>.</P>

<H4><A NAME="Pattern_matching">2.3.4.7 Сравнение по шаблону</A></H4>
<P>MySQL обеспечивает стандартные шаблоны SQL, основанные на расширенных
регулярных выражениях, подобных используемым Unix-приложениями, вроде
<CODE>vi</CODE>, <CODE>grep</CODE> и <CODE>sed</CODE>.</P>

<P>SQL-шаблоны позволяют Вам использовать <SAMP>_</SAMP>, чтобы
соответствовать любому одиночному символу и <SAMP>%</SAMP>, чтобы
соответствовать произвольному числу символов (включая нулевое количество).
В MySQL SQL-шаблоны по умолчанию не чувствительны к регистру. Некоторые
примеры показываются ниже. Обратите внимание, что Вы не используете
<CODE>=</CODE> или <CODE>!=</CODE>, когда Вы применяете образцы SQL;
используйте операторы сравнения <CODE>LIKE</CODE> или <CODE>NOT LIKE</CODE>.
</P>

<P>Чтобы найти имена, начинающиеся с <SAMP>`b'</SAMP>, введите:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "b%";
+--------+--------+---------+------+------------+------------+
| name   | owner  | species | sex  | birth      | death      |
+--------+--------+---------+------+------------+------------+
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m    | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+------+------------+------------+
</PRE>

<P>Чтобы найти имена, заканчивающиеся на <SAMP>`fy'</SAMP>, введите:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%fy";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>Чтобы найти имена, содержащие <SAMP>`w'</SAMP>, введите:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "%w%";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>Чтобы найти имена, содержащие точно пять символов, используйте символ
<SAMP>_</SAMP>:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name LIKE "_____";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>Другой тип образца, поддерживаемый MySQL, это расширенные регулярные
выражения. Когда Вы проверяете соответствия для этого типа образца,
используйте операторы <CODE>REGEXP</CODE> и <CODE>NOT REGEXP</CODE> (или
<CODE>RLIKE</CODE> и <CODE>NOT RLIKE</CODE>, которые являются синонимами).
</P>

<P>Некоторые характеристики расширенных регулярных выражений:</P>
<UL><LI>Точка (<SAMP>.</SAMP>) соответствует любому одиночному символу.

<LI>Символьный класс <SAMP>[...]</SAMP> соответствует любому символу внутри
скобок. Например, <SAMP>[abc]</SAMP> соответствует <SAMP>a</SAMP>,
<SAMP>b</SAMP> или <SAMP>c</SAMP>. Чтобы задать диапазон символов,
используйте черточку. Например, <SAMP>[a-z]</SAMP> соответствует любому
латинскому символу нижнего регистра в то время, как <SAMP>[0-9]</SAMP>
определяет любую цифру.

<LI>Звездочка <SAMP>*</SAMP> соответствует нолю или большему количеству
образцов предшествующих ей. Например, <SAMP>x*</SAMP> соответствует любому
числу символов <SAMP>x</SAMP>, <SAMP>[0-9]*</SAMP> соответствует любому числу
цифр, а <SAMP>.*</SAMP> соответствует любому количеству чего-нибудь.

<LI>Регулярные выражения чувствительны к регистру, но Вы можете использовать
символьный класс, чтобы соответствовать обоим регистрам сразу. Например,
<SAMP>[aA]</SAMP> соответствует символу <SAMP>a</SAMP> нижнего или верхнего
регистра, а <SAMP>[a-zA-Z]</SAMP> соответствует любому символу.

<LI>Образец считается соответствующим, если соответствие происходит
где-нибудь в проверяемом значении. SQL учитывает соответствие только, если
оно удовлетворяет всему значению.

<LI>Чтобы закреплять образец так, чтобы он соответствовал началу или концу
проверяемого значения, используется символ циркумфлекса (<SAMP>^</SAMP>) в
начале или доллара (<SAMP>$</SAMP>) в конце образца.</UL>

<P>Чтобы проиллюстрировать, как выполняется работа регулярных выражений,
показанные выше запросы <CODE>LIKE</CODE> переделаны ниже так, чтобы
использовать их с <CODE>REGEXP</CODE>.</P>

<P>Чтобы находить имена, начинающиеся с <SAMP>b</SAMP>, примените
<SAMP>^</SAMP>, чтобы соответствовать началу имени:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^b";
+--------+--------+---------+-----+------------+------------+
| name   | owner  | species | sex | birth      | death      |
+--------+--------+---------+-----+------------+------------+
| Buffy  | Harold | dog     | f   | 1989-05-13 | NULL       |
| Bowser | Diane  | dog     | m   | 1989-08-31 | 1995-07-29 |
+--------+--------+---------+-----+------------+------------+
</PRE>

<P>До MySQL Version 3.23.4 <CODE>REGEXP</CODE> чувствителен к регистру, и
предыдущий запрос не возвратит никаких строк. Чтобы соответствовать нижнему
или верхнему регистру <SAMP>b</SAMP>, используйте этот запрос взамен:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^[bB]";
</PRE>

<P>В MySQL 3.23.4, чтобы вынудить сравнение <CODE>REGEXP</CODE> быть
чувствительным к регистру, используют ключевое слово <CODE>BINARY</CODE>,
чтобы сделать одну из строк двоичной. Этот запрос будет соответствовать
только нижнему регистру <SAMP>b</SAMP> в начале имени:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP BINARY "^b";
</PRE>

<P>Чтобы находить имена, заканчивающиеся на <SAMP>fy</SAMP>, примените
<SAMP>$</SAMP>, чтобы соответствовать концу имени:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "fy$";
+--------+--------+---------+------+------------+-------+
| name   | owner  | species | sex  | birth      | death |
+--------+--------+---------+------+------------+-------+
| Fluffy | Harold | cat     | f    | 1993-02-04 | NULL  |
| Buffy  | Harold | dog     | f    | 1989-05-13 | NULL  |
+--------+--------+---------+------+------------+-------+
</PRE>

<P>Чтобы находить имена, содержащие <SAMP>`w'</SAMP>, неважно в каком
регистре, используйте этот запрос:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "w";
+----------+-------+---------+------+------------+------------+
| name     | owner | species | sex  | birth      | death      |
+----------+-------+---------+------+------------+------------+
| Claws    | Gwen  | cat     | m    | 1994-03-17 | NULL       |
| Bowser   | Diane | dog     | m    | 1989-08-31 | 1995-07-29 |
| Whistler | Gwen  | bird    | NULL | 1997-12-09 | NULL       |
+----------+-------+---------+------+------------+------------+
</PRE>

<P>Потому, что регулярное выражение срабатывает, если соответствие происходит
где-нибудь в значении, в предыдущем запросе необязательно размещать групповой
символ с обеих сторон образца, чтобы соответствовать всему значению. Хотя
именно так пришлось бы поступить в стандартном SQL.</P>

<P>Чтобы находить имена, содержащие точно пять символов, используйте
<SAMP>^</SAMP> и <SAMP>$</SAMP>, чтобы соответствовать началу, концу имени и
пяти образцам точки <SAMP>.</SAMP> между ними:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.....$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<P>Вы могли бы также переписать предыдущий запрос, используя
<SAMP>{n}</SAMP> в операторе repeat-<CODE>n</CODE>-times:</P>
<PRE>
mysql&#62; SELECT * FROM pet WHERE name REGEXP "^.{5}$";
+-------+--------+---------+------+------------+-------+
| name  | owner  | species | sex  | birth      | death |
+-------+--------+---------+------+------------+-------+
| Claws | Gwen   | cat     | m    | 1994-03-17 | NULL  |
| Buffy | Harold | dog     | f    | 1989-05-13 | NULL  |
+-------+--------+---------+------+------------+-------+
</PRE>

<H4><A NAME="Counting_rows">2.3.4.8 Подсчет строк</A></H4>
<P>Базы данных часто используются, чтобы ответить на вопрос о том, как часто
некоторые данные попадаются в таблице. Например, Вы могли бы узнать, сколько
домашних животных Вы имеете, или сколько домашних животных имеет каждый
владелец, или Вы могли бы выполнять различные виды переписи животных.</P>

<P>Подсчет общего количества животных, которых Вы имеете, аналогичен вопросу
о том, сколько строк находятся в таблице <CODE>pet</CODE>? Дело в том, что
имеется одна запись на домашнее животное. Функция <CODE>COUNT()</CODE>
считает число не-<CODE>NULL</CODE> результатов, так что запрос для подсчета
животных выглядит следующим образом:</P>
<PRE>
mysql&#62; SELECT COUNT(*) FROM pet;
+----------+
| COUNT(*) |
+----------+
|        9 |
+----------+
</PRE>

<P>Ранее Вы нашли имена людей, которые имели домашние животных. Вы можете
использовать <CODE>COUNT()</CODE>, если хотите выяснить, сколько домашних
животных имеет каждый владелец:</P>
<PRE>
mysql&#62; SELECT owner, COUNT(*) FROM pet GROUP BY owner;
+--------+----------+
| owner  | COUNT(*) |
+--------+----------+
| Benny  |        2 |
| Diane  |        2 |
| Gwen   |        3 |
| Harold |        2 |
+--------+----------+
</PRE>

<P>Обратите внимание на использование ключевого слова <CODE>GROUP BY</CODE>,
чтобы сгруппировать вместе все записи для каждого владельца
(<CODE>owner</CODE>). Без него все, что Вы получите, это сообщение об ошибках:
</P>
<PRE>
mysql&#62; SELECT owner, COUNT(owner) FROM pet;
ERROR 1140 at line 1: Mixing of GROUP columns (MIN(),MAX(),COUNT()...)
with no GROUP columns is illegal if there is no GROUP BY clause
</PRE>

<P><CODE>COUNT()</CODE> и <CODE>GROUP BY</CODE> полезны для характеристики
Ваших данных различными способами. Следующие примеры показывают различные
способы выполнить операции переписи.</P>

<P>Число животных на разновидность:</P>
<PRE>
mysql&#62; SELECT species, COUNT(*) FROM pet GROUP BY species;
+---------+----------+
| species | COUNT(*) |
+---------+----------+
| bird    |        2 |
| cat     |        2 |
| dog     |        3 |
| hamster |        1 |
| snake   |        1 |
+---------+----------+
</PRE>

<P>Число животных на пол:</P>
<PRE>
mysql&#62; SELECT sex, COUNT(*) FROM pet GROUP BY sex;
+------+----------+
| sex  | COUNT(*) |
+------+----------+
| NULL |        1 |
| f    |        4 |
| m    |        4 |
+------+----------+
</PRE>

<P>В этом выводе <CODE>NULL</CODE> указывает неизвестный пол.</P>

<P>Число животных на комбинацию разновидности и пола:</P>
<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | NULL |        1 |
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>

<P>Вы не должны получать всю таблицу, когда Вы используете
<CODE>COUNT()</CODE>. Например, предыдущий запрос, когда он выполняется
только на кошках и собаках, выглядит следующим образом:</P>
<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE species = "dog" OR species = "cat" GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
+---------+------+----------+
</PRE>

<P>Если Вы хотите получить число животных каждого пола (только для животных,
пол которых известен):</P>
<PRE>
mysql&#62; SELECT species, sex, COUNT(*) FROM pet
    -&#62; WHERE sex IS NOT NULL GROUP BY species, sex;
+---------+------+----------+
| species | sex  | COUNT(*) |
+---------+------+----------+
| bird    | f    |        1 |
| cat     | f    |        1 |
| cat     | m    |        1 |
| dog     | f    |        1 |
| dog     | m    |        2 |
| hamster | f    |        1 |
| snake   | m    |        1 |
+---------+------+----------+
</PRE>

<H4><A NAME="Multiple_tables">2.3.4.9
Использование нескольких таблиц в одном запросе</A></H4>
<P>Таблица <CODE>pet</CODE> описывает, каких домашних животных Вы имеете.
Если Вы хотите записывать другую информацию относительно их, типа событий в
их жизнях, подобно посещениям ветеринара, или когда рождалось потомство, Вы
нуждаетесь в другой таблице. Что эта таблица должна включать? Требуется:</P>

<UL><LI>Имя, чтобы Вы знали, к которому животному каждое событие относится.
<LI>Дата, чтобы Вы знали, когда событие произошло.
<LI>Поле, чтобы описать событие.
<LI>Поле типа события, если Вы хотите разложить события по категориям.</UL>

<P>Согласно этим данным инструкция <CODE>CREATE TABLE</CODE> для таблицы
событий (<CODE>event</CODE>) могла бы выглядеть следующим образом:</P>
<PRE>
mysql&#62; CREATE TABLE event (name VARCHAR(20), date DATE,
    -&#62; type VARCHAR(15), remark VARCHAR(255));
</PRE>

<P>Как с таблицей <CODE>pet</CODE>, проще всего загрузить начальные записи,
создав разграниченный табуляциями текстовый файл, содержащий информацию:</P>

<TABLE BORDER WIDTH="100%">
<TR><TD>Fluffy</TD><TD>1995-05-15</TD><TD>Потомство</TD><TD>4 котенка, 3
female, 1 male</TD></TR>
<TR><TD>Buffy</TD><TD>1993-06-23</TD><TD>Потомство</TD><TD>5 щенков, 2
female, 3 male</TD></TR>
<TR><TD>Buffy</TD><TD>1994-06-19</TD><TD>Потомство</TD><TD>3 щенка, 3 female
</TD></TR>
<TR><TD>Chirpy</TD><TD>1999-03-21</TD><TD>Ветеринар</TD><TD>Необходимо
выпрямление клюва</TD></TR>
<TR><TD>Slim</TD><TD>1997-08-03</TD><TD>Ветеринар</TD><TD>Сломано ребро</TD>
</TR>
<TR><TD>Bowser</TD><TD>1991-10-12</TD><TD>Конура</TD></TR>
<TR><TD>Fang</TD><TD>1991-10-12</TD><TD>Конура</TD></TR>
<TR><TD>Fang</TD><TD>1998-08-28</TD><TD>День рождения</TD><TD>Подарок: новая
жевательная игрушка</TD></TR>
<TR><TD>Claws</TD><TD>1998-03-17</TD><TD>День рождения</TD><TD>Подарок:
ошейник от блох</TD></TR>
<TR><TD>Whistler</TD><TD>1998-12-09</TD><TD>День рождения</TD><TD>Первый день
рождения</TD></TR></TABLE>

<P>Загрузите записи так:</P>
<PRE>
mysql&#62; LOAD DATA LOCAL INFILE "event.txt" INTO TABLE event;
</PRE>

<P>Учитывая то, чему Вы научились (я очень надеюсь, что и правда чему-то
научились) на запросах к таблице <CODE>pet</CODE>, Вы должны быть способны
выполнить поиски на записях в таблице <CODE>event</CODE>, принципы те же
самые. Но что делать, когда таблица <CODE>event</CODE> отдельно недостаточна,
чтобы ответить на вопросы, которые Вы задаете?</P>

<P>Предположим, что Вы хотите выяснить возрасты каждого домашнего животного,
когда они имели потомство. Таблица <CODE>event</CODE> указывает, когда это
произошло, но чтобы вычислить возраст матери, Вы нуждаетесь в ее дате
рождения. Поскольку это сохранено в таблице <CODE>pet</CODE>, Вы нуждаетесь в
обеих таблицах для обработки запроса:</P>
<PRE>
mysql&#62; SELECT pet.name, (TO_DAYS(date)-TO_DAYS(birth))/365 AS age,
    -&#62; remark FROM pet, event WHERE pet.name=event.name
    -&#62; AND type="litter";
+--------+------+-----------------------------+
| name   | age  | remark                      |
+--------+------+-----------------------------+
| Fluffy | 2.27 | 4 kittens, 3 female, 1 male |
| Buffy  | 4.12 | 5 puppies, 2 female, 3 male |
| Buffy  | 5.10 | 3 puppies, 3 female         |
+--------+------+-----------------------------+
</PRE>

<P>Итак, что тут происходит?</P>

<UL><LI>Предложение <CODE>FROM</CODE> вносит в список две таблицы потому, что
запрос должен получить информацию из обеих таблиц.

<LI>При объединении (joining) информации из многих таблиц, Вы должны
определить, как записи в одной таблице могут быть согласованы с записями в
другой. Это просто потому, что они обе имеют столбец <CODE>name</CODE>.
Запрос использует предложение <CODE>WHERE</CODE>, чтобы заставить совпасть
записи в двух таблицах, основываясь на значениях <CODE>name</CODE>.

<LI>Поскольку столбец <CODE>name</CODE> есть в обеих таблицах, Вы должны
указать, относительно которой таблицы Вы его обозначаете. Это выполнено
добавлением имени таблицы к имени столбца.</UL>

<P>Вы не должны иметь две различных таблицы, чтобы выполнить объединение.
Иногда полезно присоединить таблицу к самой себе, если Вы хотите сравнивать
записи в таблице с другими записями в этой же самой таблице. Например, чтобы
найти размножающиеся пары среди Ваших домашних животных, Вы можете соединять
таблицу <CODE>pet</CODE> с самой собой, чтобы соединить самцов и самок
подобной разновидности:</P>
<PRE>
mysql&#62; SELECT p1.name, p1.sex, p2.name, p2.sex, p1.species
    -&#62; FROM pet AS p1, pet AS p2
    -&#62; WHERE p1.species=p2.species AND p1.sex="f" AND p2.sex="m";
+--------+------+--------+------+---------+
| name   | sex  | name   | sex  | species |
+--------+------+--------+------+---------+
| Fluffy | f    | Claws  | m    | cat     |
| Buffy  | f    | Fang   | m    | dog     |
| Buffy  | f    | Bowser | m    | dog     |
+--------+------+--------+------+---------+
</PRE>

<P>В этом запросе мы определяем псевдонимы для имени таблицы, чтобы
обратиться к столбцам и указываем прямо, с которым образцом таблицы каждая
ссылка столбца связана.</P>

<H2><A NAME="Getting_information">2.4
Получение информации о базах данных и таблицах</A></H2>
<P>Что, если Вы забыли имя базы данных, или таблицы или ее структуру
(например, как столбцы именованы)? MySQL решает эту проблему через несколько
инструкций, которые обеспечивают информацию относительно баз данных и таблиц,
которые это поддерживают.</P>

<P>Вы уже видели вызов <CODE>SHOW DATABASES</CODE>, который вносит в список
базы данных, управляемые сервером. Чтобы выяснять, которая база данных в
настоящее время выбрана, используйте функцию <CODE>DATABASE()</CODE>:</P>
<PRE>
mysql&#62; SELECT DATABASE();
+------------+
| DATABASE() |
+------------+
| menagerie  |
+------------+
</PRE>

<P>Если Вы не выбрали базу данных, результат пуст.</P>

<P>Чтобы выяснять какие таблицы хранит текущая база данных (например, когда
Вы не уверены относительно имени таблицы), используйте эту команду:</P>
<PRE>
mysql&#62; SHOW TABLES;
+---------------------+
| Tables in menagerie |
+---------------------+
| event               |
| pet                 |
+---------------------+
</PRE>

<P>Если Вы хотите выяснить что-то относительно структуры таблицы, команда
<CODE>DESCRIBE</CODE> очень полезна. Она отображает информацию относительно
каждого из столбцов таблицы:</P>
<PRE>
mysql&#62; DESCRIBE pet;
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| name    | varchar(20) | YES  |     | NULL    |       |
| owner   | varchar(20) | YES  |     | NULL    |       |
| species | varchar(20) | YES  |     | NULL    |       |
| sex     | char(1)     | YES  |     | NULL    |       |
| birth   | date        | YES  |     | NULL    |       |
| death   | date        | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</PRE>

<P><CODE>Field</CODE> указывает имя столбца, <CODE>Type</CODE> тип данных для
столбца, <CODE>Null</CODE> указывает, может или нет столбец содержать
значения <CODE>NULL</CODE>, <CODE>Key</CODE> указывает, индексирован или нет
столбец, а <CODE>Default</CODE> определяет значение столбца по умолчанию.</P>

<P>Если Вы имеете индексы на таблице, <CODE>SHOW INDEX FROM tbl_name</CODE>
производит информацию относительно их.</P>

<H2><A NAME="Examples">2.5 Примеры общих запросов</A></H2>
<P>Имеются примеры того, как решить некоторые общие проблемы с MySQL.</P>

<P>Некоторые из примеров используют таблицы <CODE>shop</CODE>, чтобы хранить
цену каждого изделия (номер элемента, <CODE>item</CODE>) для некоторых
торговцев (<CODE>trader</CODE>). Предположим, что каждый торговец имеет одну
фиксированную цену на изделие, тогда пара (<CODE>item</CODE>,
<CODE>trader</CODE>) является первичным ключом для записей.</P>

<P>Запустите инструмент командной строки <CODE>mysql</CODE> и
выберите базу данных:</P>
<PRE>
mysql your-database-name
</PRE>

<P>В большинстве инсталляций MySQL Вы можете использовать имя
базы данных test.</P>

<P>Вы можете создать таблицу для примера так:</P>
<PRE>
CREATE TABLE shop (article INT(4) UNSIGNED ZEROFILL DEFAULT '0000'
             NOT NULL, dealer CHAR(20) DEFAULT '' NOT NULL,
             price DOUBLE(16,2) DEFAULT '0.00' NOT NULL,
             PRIMARY KEY(article, dealer));
INSERT INTO shop VALUES
   (1,'A',3.45),(1,'B',3.99),(2,'A',10.99),
   (3,'B',1.45),(3,'C',1.69),(3,'D',1.25),(4,'D',19.95);
</PRE>

<P>Посмотрим данные примера:</P>
<PRE>
mysql&#62; SELECT * FROM shop;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | A      |  3.45 |
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | B      |  1.45 |
|    0003 | C      |  1.69 |
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

<H3><A NAME="example-Maximum-column">2.5.1 Максимальное значение для столбца
</A></H3>
<P>Что является самым большим значением для элемента?</P>
<PRE>
SELECT MAX(article) AS article FROM shop
+---------+
| article |
+---------+
|       4 |
+---------+
</PRE>

<H3><A NAME="example-Maximum-row">2.5.2
В какой строке хранится максимум некоего столбца?</A></H3>
<P>Допустим, надо найти код, торговца и цену наиболее дорогого изделия.</P>

<P>В ANSI SQL это легко может быть выполнен подзапросом:</P>
<PRE>
SELECT article, dealer, price FROM shop
       WHERE price=(SELECT MAX(price) FROM shop)
</PRE>

<P>В MySQL (который еще не имеет поддержки вложенных запросов) это делается
за два шага:</P>

<OL><LI>Получите максимальное ценовое значение из таблицы с помощью
<CODE>SELECT</CODE>.

<LI>Используя это значение, надо создать фактический запрос:
<PRE>
SELECT article, dealer, price FROM shop WHERE price=19.95
</PRE></OL>

<P>Другое решение состоит в том, чтобы сортировать все строки по убыванию
цены и получить только первую из них, используя специфическое для MySQL
предложение <CODE>LIMIT</CODE>:</P>
<PRE>
SELECT article, dealer, price FROM shop ORDER BY price DESC LIMIT 1
</PRE>

<P><STRONG>ОБРАТИТЕ ВНИМАНИЕ</STRONG>: Если имеется несколько изделий с
одинаковой ценой (например, каждое по 19.95), то <CODE>LIMIT</CODE>
показывает только одно из них.</P>

<H3><A NAME="example-Maximum-column-group">2.5.3 Максимум столбца в группе
</A></H3>
<P>Что является самой высокой ценой на изделие?</P>
<PRE>
SELECT article, MAX(price) AS price FROM shop GROUP BY article
+---------+-------+
| article | price |
+---------+-------+
|    0001 |  3.99 |
|    0002 | 10.99 |
|    0003 |  1.69 |
|    0004 | 19.95 |
+---------+-------+
</PRE>

<H3><A NAME="example-Maximum-column-group-row">2.5.4
В какой строке максимум по группе</A></H3>
<P>Для каждого изделия, найдите торгового агента с наиболее высокой ценой.
</P>

<P>В ANSI SQL я сделал бы это подзапросом:</P>
<PRE>
SELECT article, dealer, price FROM shop s1
       WHERE price=(SELECT MAX(s2.price) FROM shop s2
             WHERE s1.article = s2.article);
</PRE>

<P>В MySQL проще всего добиться такого эффекта так:</P>

<OL><LI>Получите список из записей (изделие, максимальная цена).

<LI>Для каждого изделия получите из таблицы соответствующие строки, которые
имеют максимальную цену.</OL>

<P>Это может быть легко выполнено через временную таблицу:</P>
<PRE>
CREATE TEMPORARY TABLE tmp (article INT(4) UNSIGNED ZEROFILL
       DEFAULT '0000' NOT NULL, price DOUBLE(16,2) DEFAULT '0.00'
       NOT NULL);
LOCK TABLES shop read;
INSERT INTO tmp SELECT article, MAX(price) FROM shop GROUP BY article;
SELECT shop.article, dealer, shop.price FROM shop, tmp
       WHERE shop.article=tmp.article AND shop.price=tmp.price;
UNLOCK TABLES;
DROP TABLE tmp;
</PRE>

<P>Если Вы не используете таблицу <CODE>TEMPORARY</CODE>, Вы должны также
блокировать таблицу tmp.</P>

<P>Можно это сделать одиночным запросом?</P>

<P>Да, но только используя совершенно неэффективный прием MAX-CONCAT trick:
</P>
<PRE>
SELECT article, SUBSTRING(MAX(CONCAT(LPAD(price,6,'0'),dealer)), 7)
       AS dealer, 0.00+LEFT(MAX(CONCAT(LPAD(price,6,'0'),dealer)), 6)
       AS price FROM shop GROUP BY article;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0001 | B      |  3.99 |
|    0002 | A      | 10.99 |
|    0003 | C      |  1.69 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

<H3><A NAME="example-user-variables">2.5.5 Применение переменных пользователя
</A></H3>
<P>Вы можете применять переменные пользователя MySQL, чтобы помнить
результаты без того, чтобы сохранять их во временных переменных на клиенте.
</P>

<P>Например, чтобы найти изделия с самыми высокими и низкими ценами, Вы
можете сделать следующее:</P>
<PRE>
select @min_price:=min(price),@max_price:=max(price) from shop;
select * from shop where price=@min_price or price=@max_price;
+---------+--------+-------+
| article | dealer | price |
+---------+--------+-------+
|    0003 | D      |  1.25 |
|    0004 | D      | 19.95 |
+---------+--------+-------+
</PRE>

<H3><A NAME="example-Foreign_keys">2.5.6 Использование внешних ключей</A>
</H3>
<P>Вы не нуждаетесь во внешних ключах, чтобы соединить 2 таблицы.</P>

<P>Единственная вещь, которую MySQL не делает, это <CODE>CHECK</CODE>, чтобы
удостовериться, что ключи, которые Вы используете, действительно, существуют
в таблице и автоматически не удаляет строки из таблицы с внешним ключом. Если
Вы используете Ваши ключи обычным порядком, это только улучшит работу:</P>
<PRE>
CREATE TABLE persons (id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
             name CHAR(60) NOT NULL, PRIMARY KEY (id));
CREATE TABLE shirts (id SMALLINT UNSIGNED NOT NULL AUTO_INCREMENT,
             style ENUM('t-shirt', 'polo', 'dress') NOT NULL,
             color ENUM('red', 'blue', 'orange', 'white', 'black')
             NOT NULL, owner SMALLINT UNSIGNED NOT NULL REFERENCES persons,
             PRIMARY KEY (id));
INSERT INTO persons VALUES (NULL, 'Antonio Paz');
INSERT INTO shirts VALUES (NULL, 'polo', 'blue', LAST_INSERT_ID()),
   (NULL, 'dress', 'white', LAST_INSERT_ID()),
   (NULL, 't-shirt', 'blue', LAST_INSERT_ID());
INSERT INTO persons VALUES (NULL, 'Lilliana Angelovska');
INSERT INTO shirts VALUES (NULL, 'dress', 'orange', LAST_INSERT_ID()),
   (NULL, 'polo', 'red', LAST_INSERT_ID()),
   (NULL, 'dress', 'blue', LAST_INSERT_ID()),
   (NULL, 't-shirt', 'white', LAST_INSERT_ID());
SELECT * FROM persons;
+----+---------------------+
| id | name                |
+----+---------------------+
|  1 | Antonio Paz         |
|  2 | Lilliana Angelovska |
+----+---------------------+
SELECT * FROM shirts;
+----+---------+--------+-------+
| id | style   | color  | owner |
+----+---------+--------+-------+
|  1 | polo    | blue   |     1 |
|  2 | dress   | white  |     1 |
|  3 | t-shirt | blue   |     1 |
|  4 | dress   | orange |     2 |
|  5 | polo    | red    |     2 |
|  6 | dress   | blue   |     2 |
|  7 | t-shirt | white  |     2 |
+----+---------+--------+-------+
SELECT s.* FROM persons p, shirts s WHERE p.name LIKE 'Lilliana%'
       AND s.owner = p.id AND s.color &#60;&#62; 'white';
+----+-------+--------+-------+
| id | style | color  | owner |
+----+-------+--------+-------+
|  4 | dress | orange |     2 |
|  5 | polo  | red    |     2 |
|  6 | dress | blue   |     2 |
+----+-------+--------+-------+
</PRE>

<H3><A NAME="Searching_on_two_keys">2.5.7 Поиск на двух ключах</A></H3>
<P>MySQL не оптимизирует запрос, когда Вы ищете на двух различных ключах,
объединенных с помощью <CODE>OR</CODE>. Поиск на одном ключе с
<CODE>OR</CODE> оптимизирован хорошо.</P>
<PRE>
SELECT field1_index, field2_index FROM test_table WHERE field1_index = '1'
       OR field2_index = '1'
</PRE>

<P>Причина в том, что авторы не имели времени, чтобы придумать эффективный
способ обработать это в общем случае. Обработка <CODE>AND</CODE> теперь
полностью общая и работает очень хорошо.</P>

<P>Сейчас Вы можете сделать все это очень эффективно, используя таблицу
<CODE>TEMPORARY</CODE>. Этот тип оптимизации также очень хорош, если Вы
используете очень сложные запросы, где сервер SQL путается и делает
оптимизацию в неправильном порядке.</P>
<PRE>
CREATE TEMPORARY TABLE tmp
SELECT field1_index, field2_index FROM test_table
       WHERE field1_index = '1';
INSERT INTO tmp
SELECT field1_index, field2_index FROM test_table
       WHERE field2_index = '1';
SELECT * from tmp;
DROP TABLE tmp;
</PRE>

<P>Вышеупомянутый способ выполнить этот запрос в действительности вызывает
<CODE>UNION</CODE> для двух запросов.</P>

<H3><A NAME="Calculating_days">2.5.8 Вычисление посещений за день</A></H3>
<P>Следующее предлагает идею относительно того, как Вы можете использовать
разрядные функции группы, чтобы вычислить число дней, которое пользователь
посетил страничку в сети.</P>
<PRE>
CREATE TABLE t1 (year YEAR(4), month INT(2) UNSIGNED ZEROFILL,
       day INT(2) UNSIGNED ZEROFILL);
INSERT INTO t1 VALUES(2000,1,1),(2000,1,20),(2000,1,30),
       (2000,2,2),(2000,2,23),(2000,2,23);
SELECT year,month,BIT_COUNT(BIT_OR(1&#60;&#60;day)) AS days
       FROM t1 GROUP BY year,month;
+------+-------+------+
| year | month | days |
+------+-------+------+
| 2000 |    01 |    3 |
| 2000 |    02 |    2 |
+------+-------+------+
</PRE>

<P>Вышеупомянутый запрос вычисляет, сколько различных дней использовались для
данной комбинации лет с конкретным месяцем с автоматическим
удалением двойных записей.</P>

<H2><A NAME="Batch_mode">2.6
Использование <CODE>mysql</CODE> в пакетном режиме</A></H2>
<P>В предыдущих разделах Вы использовали <CODE>mysql</CODE> в интерактивном
режиме, чтобы ввести запросы и рассматривать результаты. Вы можете также
выполнять <CODE>mysql</CODE> в пакетном режиме. Чтобы сделать это, поместите
команды, Вы хотите выполнить в файл, затем сообщать, чтобы <CODE>mysql</CODE>
читал ввод из файла:</P>
<PRE>
shell&#62; mysql &#60; batch-file
</PRE>

<P>Если Вы должны определить параметры подключения в командной строке,
команда вызова могла бы выглядеть следующим образом:</P>
<PRE>
shell&#62; mysql -h host -u user -p &#60; batch-file
Enter password: ********
</PRE>

<P>Когда Вы используете <CODE>mysql</CODE> этим способом, Вы создаете файл
скрипта, а затем выполняете скрипт.</P>

<P>Почему использование скриптов удобно? Имеется несколько причин:</P>

<UL><LI>Если Вы выполняете запрос неоднократно (скажем, каждый день или
каждую неделю), скрипт позволяет Вам избежать ввода запроса каждый раз, когда
Вы его выполняете.

<LI>Вы можете генерировать новые запросы из похожих существующих, копируя и
редактируя файлы скриптов.

<LI>Пакетный режим может также быть полезен в то время, когда Вы
разрабатываете запрос, особенно для команд с многими строками или
многооператорных последовательностей команд. Если Вы сделаете ошибку, Вы не
должны повторно вводить все. Только отредактируйте скрипт, чтобы исправить
ошибку, затем сообщите, чтобы <CODE>mysql</CODE> выполнил его снова.

<LI>Если Вы имеете запрос, который производит много вывода, Вы можете
выполнять вывод через pager вместо того, чтобы мучаться с экраном:
<PRE>
shell&#62; mysql &#60; batch-file|more
</PRE>

<LI>Вы можете захватывать вывод в файл для дальнейшей обработки:
<PRE>
shell&#62; mysql &#60; batch-file &#62; mysql.out
</PRE>

<LI>Вы можете передавать Ваш скрипт другим людям, так что они смогут
выполнять команды так же.

<LI>Некоторые ситуации не учитывают интерактивное использование, например,
когда Вы выполняете запрос из планировщика <CODE>cron</CODE>. В этом случае
Вы должны использовать пакетный режим.</UL>

<P>Заданный по умолчанию выходной формат несколько иной (более краткий),
когда Вы выполняете <CODE>mysql</CODE> в пакетном режиме. Например, вывод
<CODE>SELECT DISTINCT species FROM pet</CODE> напоминает этот образец, когда
выполнен в интерактивном режиме:</P>
<PRE>
+---------+
| species |
+---------+
| bird    |
| cat     |
| dog     |
| hamster |
| snake   |
+---------+
</PRE>

<P>Но когда выполнен в пакетном режиме, он подобен этому:</P>
<PRE>
species
bird
cat
dog
hamster
snake
</PRE>

<P>Если Вы хотите получать интерактивный выходной формат в пакетном режиме,
используйте <CODE>mysql -t</CODE>. Для добавления к выводу команд, которые
были выполнены, используется <CODE>mysql -vvv</CODE>.</P>

<H2><A NAME="Twin">2.7 Запросы из двух проектов</A></H2>
<P>Два университета ведут большой исследовательский проект. Проект включает
часть опроса, где все близнецы в Швеции старше, чем 65 лет, интервьюируются
по телефону. Близнецы, у которых встречаются некоторые критерии, передаются
на следующюю стадию. На этой последней стадии близнецы, которые хотят
участвовать, посещаются группой врачей и подвергаются всесторонним тестам.
Большее количество информации относительно проекта есть по адресу:
<PRE>
http://www.imm.ki.se/TWIN/TWINUKW.HTM
</PRE>

<P>Последняя часть проекта управляется Web-интерфесом, написанным на Perl с
базой данных под MySQL.</P>

<P>Каждую ночь (исследования ведутся днем) все данные из интервью
перемещаются в базу данных MySQL.</P>

<H3><A NAME="Twin_pool">2.7.1 Поиск всех важных близнецов</A></H3>
<P>Следующий запрос используется, чтобы определить, кто из близнецов идет во
вторую часть проекта:</P>
<PRE>
select concat(p1.id, p1.tvab) + 0 as tvid,
       concat(p1.christian_name, " ", p1.surname) as Name,
       p1.postal_code as Code, p1.city as City, pg.abrev as Area,
       if(td.participation = "Aborted", "A", " ") as A,
       p1.dead as dead1, l.event as event1, td.suspect as tsuspect1,
       id.suspect as isuspect1, td.severe as tsevere1,
       id.severe as isevere1, p2.dead as dead2, l2.event as event2,
       h2.nurse as nurse2, h2.doctor as doctor2, td2.suspect as tsuspect2,
       id2.suspect as isuspect2, td2.severe as tsevere2,
       id2.severe as isevere2, l.finish_date from twin_project as tp
       left join twin_data as td on tp.id = td.id and tp.tvab = td.tvab
       left join informant_data as id on tp.id = id.id and tp.tvab=id.tvab
       left join harmony as h on tp.id = h.id and tp.tvab = h.tvab
       left join lentus as l on tp.id = l.id and tp.tvab = l.tvab
       left join twin_data as td2 on p2.id = td2.id and p2.tvab = td2.tvab
       left join informant_data as id2 on p2.id = id2.id and
       p2.tvab=id2.tvab left join harmony as h2 on p2.id = h2.id and
       p2.tvab = h2.tvab left join lentus as l2 on p2.id = l2.id and
       p2.tvab = l2.tvab, person_data as p1, person_data as p2,
       postal_groups as pg where p1.id = tp.id and p1.tvab = tp.tvab and
       p2.id = p1.id and p2.ptvab = p1.tvab and tp.survey_no = 5 and
       (p2.dead = 0 or p2.dead=9 or (p2.dead=1 and (p2.death_date=0 or
       (((to_days(p2.death_date)-to_days(p2.birthday))/365) &#62;= 65))))
       and ((td.future_contact = 'Yes' and td.suspect = 2) or
       (td.future_contact = 'Yes' and td.suspect = 1 and id.suspect=1) or
       (ISNULL(td.suspect) and id.suspect=1 and id.future_contact='Yes') or
       (td.participation = 'Aborted' and id.suspect = 1 and
       id.future_contact = 'Yes') or (td.participation = 'Aborted' and
       ISNULL(id.suspect) and p2.dead = 0)) and l.event = 'Finished'
       and substring(p1.postal_code, 1, 2) = pg.code
       and (h.nurse is NULL or h.nurse=00 or h.doctor=00)
       and not (h.status = 'Refused' or h.status = 'Aborted'
       or h.status = 'Died' or h.status = 'Other') order by tvid;
</PRE>

<P>Как Вам такой запрос? Даю некоторые объяснения:
<DL COMPACT>
<DT><CODE>concat(p1.id, p1.tvab) + 0 as tvid</CODE>
<DD>Мы хотим сортировать на составном идентификаторе <CODE>id</CODE> и
<CODE>tvab</CODE> в числовом порядке. Добавление <CODE>0</CODE> к результату
заставляет MySQL обрабатывать его именно как число.

<DT>column <CODE>id</CODE>
<DD>Это идентифицирует пару близнецов. Это ключ во всех таблицах.

<DT>column <CODE>tvab</CODE>
<DD>Это идентифицирует близнецов в паре. Это имеет значение
<CODE>1</CODE> или <CODE>2</CODE>.

<DT>column <CODE>ptvab</CODE>
<DD>Это инверсия <CODE>tvab</CODE>. Когда <CODE>tvab</CODE> равно
<CODE>1</CODE>, <CODE>ptvab</CODE> принимает значение <CODE>2</CODE>, и
наоборот. Это существует, чтобы проще оптимизировать запрос.</DL>

<P>Этот запрос показывает среди других вещей, как делать поиск на таблице из
той же самой таблицы с объединением (<CODE>p1</CODE> и <CODE>p2</CODE>). В
примере это используется, чтобы проверить, умер ли партнер близнецов до 65
лет. Если так, строка не будет возвращена.</P>

<P>Все вышеприведенное существует во всех таблицах с информацией по
близнецам. Мы имеем ключ на паре <CODE>id,tvab</CODE> (все таблицы) и другой
паре <CODE>id,ptvab</CODE> (только в <CODE>person_data</CODE>), чтобы
сделать запросы быстрее.</P>

<P>На нашей машине (200MHz UltraSPARC) этот запрос возвращает приблизительно
150-200 строк и требует времени меньше, чем одна секунда.</P>

<P>Текущее число записей в таблицах, используемых выше:
<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Таблица</STRONG></TD><TD><STRONG>Строк</STRONG></TD></TR>
<TR><TD><CODE>person_data</CODE></TD><TD>71074</TD></TR>
<TR><TD><CODE>lentus</CODE></TD><TD>5291</TD></TR>
<TR><TD><CODE>twin_project</CODE></TD><TD>5286</TD></TR>
<TR><TD><CODE>twin_data</CODE></TD><TD>2012</TD></TR>
<TR><TD><CODE>informant_data</CODE></TD><TD>663</TD></TR>
<TR><TD><CODE>harmony</CODE> </TD><TD>381</TD></TR>
<TR><TD><CODE>postal_groups</CODE></TD><TD>100</TD></TR></TABLE></P>

<H3><A NAME="Twin_event">2.7.2 Состояние пары</A></H3>
<P>Каждое интервью завершается кодом состояния <CODE>event</CODE>. Запрос,
показанный ниже, используется, чтобы отобразить таблицу по всем парам
близнецов, у которых код одинаковый.</P>
<PRE>
select t1.event, t2.event, count(*) from lentus as t1, lentus as t2,
       twin_project as tp where t1.id = tp.id and t1.tvab=tp.tvab
       and t1.id = t2.id and tp.survey_no = 5 and t1.tvab='1' and
       t2.tvab='2' group by t1.event, t2.event;
</PRE>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</HTML>
