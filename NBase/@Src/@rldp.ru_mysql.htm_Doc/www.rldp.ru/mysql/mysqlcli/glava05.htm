<HTML>
<HEAD>
  <TITLE>Типы столбцов</TITLE>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
</HEAD>

<BODY>

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<H2><A NAME="Column_types">5 Типы столбцов</A></H2>
<P>MySQL поддерживает ряд типов столбцов, которые могут быть сгруппированы в
три категории: числовые, типы даты и времени и строковые (символьные). Этот
раздел сначала дает краткий обзор доступных типов и суммирует требования к
памяти для хранения каждого типа столбцов, затем обеспечивает более детальное
описание свойств типов в каждой категории. Краткий обзор преднамеренно
краток. Ниже следуют более подробные описания, с которыми нужно
консультироваться для получения дополнительной информации относительно
специфических типов столбцов, типа допустимых форматов значений, которые
Вы можете определять.</P>

<P>Типы столбцов, поддерживаемые MySQL, перечислены ниже. Следующие символы
кода используются в описаниях:</P>

<DL COMPACT>
<DT><CODE>M</CODE>
<DD>Указывает максимальный размер отображения. Максимальный допустимый размер
отображения равен 255.

<DT><CODE>D</CODE>
<DD>Применяется к типам с плавающей запятой и указывает число цифр после
десятичной отметки. Максимальное возможное значение равно 30, но должно быть
не больше, чем <CODE>M</CODE>-2.</DL>

<P>Квадратные скобки (<SAMP>[</SAMP> и <SAMP>]</SAMP>) указывают части
спецификаторов типа, которые являются факультативными.</P>

<P>Обратите внимание, что, если Вы определяете для столбца
<CODE>ZEROFILL</CODE>, MySQL автоматически добавит к столбцу атрибут
<CODE>UNSIGNED</CODE>.</P>

<DL COMPACT>
<DT><CODE>TINYINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD><A NAME="IDX996"></A>Очень маленькое целое число. Диапазон значений со
знаком от <CODE>-128</CODE> до <CODE>127</CODE>. Диапазон значений без знака
от <CODE>0</CODE> до <CODE>255</CODE>.

<A NAME="IDX997"></A><DT><CODE>SMALLINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>Маленькое целое число. Диапазон со знаком от <CODE>-32768</CODE> до
<CODE>32767</CODE>. Диапазон без знака от <CODE>0</CODE> до
<CODE>65535</CODE>.

<A NAME="IDX998"></A><DT><CODE>MEDIUMINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>Целое число средних размеров. Диапазон со знаком от <CODE>-8388608</CODE>
до <CODE>8388607</CODE>. Диапазон значений без знака от <CODE>0</CODE> до
<CODE>16777215</CODE>.

<A NAME="IDX999"></A><DT><CODE>INT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>Целое число нормального размера. Диапазон значений со знаком от
<CODE>-2147483648</CODE> до <CODE>2147483647</CODE>. Диапазон значений без
знака от <CODE>0</CODE> до <CODE>4294967295</CODE>.

<A NAME="IDX1000"></A><DT><CODE>INTEGER[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>Синоним для <CODE>INT</CODE>.

<A NAME="IDX1001"></A><DT><CODE>BIGINT[(M)] [UNSIGNED] [ZEROFILL]</CODE>
<DD>Большое целое число. Диапазон значений со знаком от
<CODE>-9223372036854775808</CODE> до <CODE>9223372036854775807</CODE>.
Диапазон значений без знака от <CODE>0</CODE> до
<CODE>18446744073709551615</CODE>.

<P>Некоторые вещи, которые Вы должны знать относительно столбцов типа
<CODE>BIGINT</CODE>:

<UL><LI><A NAME="IDX1002"></A>Поскольку вся арифметика выполнена, используя
значения типов <CODE>BIGINT</CODE> или <CODE>DOUBLE</CODE>, Вы не должны
использовать большие целые числа без знака, которые имеют значение по модулю
большее, чем <CODE>9223372036854775807</CODE> (63 бита) за исключением
битовых функций! Если Вы это сделаете, некоторые из последних цифр в
результате могут быть ошибочными из-за округления при преобразовании
<CODE>BIGINT</CODE> в <CODE>DOUBLE</CODE>.

<LI>Вы можете всегда сохранять точное целочисленное значение в столбце
<CODE>BIGINT</CODE>, сохраняя его как строку, в этом случае не будет никакого
промежуточного двойного представления.

<LI>В MySQL 4.0 Вы можете использовать целые числа, чтобы сохранить большие
значения без знака в строках <CODE>BIGINT</CODE>.

<LI><SAMP>-</SAMP>, <SAMP>+</SAMP> и <SAMP>*</SAMP> используют арифметику
<CODE>BIGINT</CODE>, когда оба параметра представляют собой значения типа
<CODE>INTEGER</CODE>. Это означает, что, если Вы умножаете два больших целых
числа (или результаты функций, которые возвращают целые числа), Вы можете
получить непредвиденные эффекты, когда результат больше, чем
<CODE>9223372036854775807</CODE>.</UL>

<DT><CODE>FLOAT(precision) [ZEROFILL]</CODE>
<DD>Число с плавающей запятой. Не может быть без знака. Точность
(<CODE>precision</CODE>) может быть в пределах <CODE>&#60;=24</CODE>, для
числа с одиночной точностью, или между 25 и 53, для числа двойной точности.
Эти типы подобны <CODE>FLOAT</CODE> и <CODE>DOUBLE</CODE>, описанным ниже.
<CODE>FLOAT(X)</CODE> имеет тот же самый диапазон, что и соответствующие типы
<CODE>FLOAT</CODE> и <CODE>DOUBLE</CODE>, но размер отображения и число
десятичных чисел неопределенны. В MySQL Version 3.23 это и есть истинное
значение с плавающей запятой. В старых версиях MySQL
<CODE>FLOAT(precision)</CODE> всегда имеет 2 десятичных числа. Обратите
внимание, что использование типа <CODE>FLOAT</CODE> может создавать Вам
некоторые непредвиденные проблемы, поскольку все вычисления в MySQL всегда
выполнены с двойной точностью. Этот синтаксис предусмотрен
для ODBC-совместимости.

<DT><CODE>FLOAT[(M,D)] [ZEROFILL]</CODE>
<DD>Маленькое (с одиночной точностью) число с плавающей запятой. Не может
быть без знака. Допустимые значения от <CODE>-3.402823466E+38</CODE> до
<CODE>-1.175494351E-38</CODE>, <CODE>0</CODE> и от
<CODE>1.175494351E-38</CODE> до <CODE>3.402823466E+38</CODE>. M задает размер
отображения, а D число десятичных чисел. Соответствует <CODE>FLOAT(X)</CODE>,
где X &#60;= 24.

<DT><CODE>DOUBLE[(M,D)] [ZEROFILL]</CODE>
<DD>Число нормального размера (двойная точность) с плавающей запятой. Не
может быть без знака. Допустимые значения от
<CODE>-1.7976931348623157E+308</CODE> до
<CODE>-2.2250738585072014E-308</CODE>, <CODE>0</CODE> и от
<CODE>2.2250738585072014E-308</CODE> до <CODE>1.7976931348623157E+308</CODE>.
M задает размер отображения, а D число десятичных чисел. Соответствует
<CODE>DOUBLE</CODE> без параметра или <CODE>FLOAT(X)</CODE>, где
25 &#60;= X &#60;= 53.

<DT><CODE>DOUBLE PRECISION[(M,D)] [ZEROFILL]</CODE>
<DD>
<DT><CODE>REAL[(M,D)] [ZEROFILL]</CODE>
<DD>Синонимы для <CODE>DOUBLE</CODE>.

<DT><CODE>DECIMAL[(M[,D])] [ZEROFILL]</CODE>
<DD>Распакованное число с плавающей запятой. Не может быть без знака. Ведет
себя подобно столбцу <CODE>CHAR</CODE>: "распакованный" означает, что число
сохранено как строка, используя один символ для каждой цифры значения.
Десятичная отметка и, для отрицательных чисел, знак <SAMP>-</SAMP> не
рассчитана в M (но пробел для них зарезервирован). Если <CODE>D</CODE>=0,
значения не будут иметь никакой десятичной отметки или дробной части.
Максимальный диапазон значений <CODE>DECIMAL</CODE> аналогичен
<CODE>DOUBLE</CODE>, но фактический диапазон для данного столбца
<CODE>DECIMAL</CODE> может быть задан через <CODE>M</CODE> и <CODE>D</CODE>.
Если <CODE>D</CODE> не задано, оно будет установлено в 0. Если же не задано
<CODE>M</CODE>, оно считается равным 10. Обратите внимание, что в MySQL
Version 3.22 аргумент <CODE>M</CODE> должен включать пробел, необходимый для
знака и десятичной отметки.

<DT><CODE>NUMERIC(M,D) [ZEROFILL]</CODE>
<DD>Синоним для <CODE>DECIMAL</CODE>.

<DT><CODE>DATE</CODE>
<DD>Дата. Поддерживаемый диапазон: от <CODE>1000-01-01</CODE> до
<CODE>9999-12-31</CODE>. MySQL отображает значения <CODE>DATE</CODE> в
формате <CODE>YYYY-MM-DD</CODE>, но позволяет Вам назначать значения столбцам
<CODE>DATE</CODE> используя строки или числа.

<DT><CODE>DATETIME</CODE>
<DD>Комбинация даты и времени. Поддерживаемый диапазон: от <CODE>1000-01-01
00:00:00</CODE> до <CODE>9999-12-31 23:59:59</CODE>. MySQL отображает
значения типа <CODE>DATETIME</CODE> в формате
<CODE>YYYY-MM-DD HH:MM:SS</CODE>, но позволяет Вам назначать значения
столбцам <CODE>DATETIME</CODE>, используя строки или числа.

<DT><CODE>TIMESTAMP[(M)]</CODE>
<DD>Метка времени. Поддерживаемый диапазон: от <CODE>1970-01-01
00:00:00</CODE> примерно до <CODE>2037</CODE>. MySQL  отображает значения
типа <CODE>TIMESTAMP</CODE>  в форматах <CODE>YYYYMMDDHHMMSS</CODE>,
<CODE>YYMMDDHHMMSS</CODE>, <CODE>YYYYMMDD</CODE> или <CODE>YYMMDD</CODE>, в
зависмости от значения <CODE>M</CODE>: <CODE>14</CODE> (или пропущено),
<CODE>12</CODE>, <CODE>8</CODE> или <CODE>6</CODE>, но позволяет Вам задавать
значения столбцам <CODE>TIMESTAMP</CODE>, используя строки или числа. Столбец
<CODE>TIMESTAMP</CODE> полезен для записи даты и времени операции
<CODE>INSERT</CODE> или <CODE>UPDATE</CODE> потому, что он будет
автоматически установлен к дате и времени самой последней операции, если Вы
не задаете значение самостоятельно. Вы можете также устанавливать его к
текущей дате и времени, назначая значение <CODE>NULL</CODE>.
<CODE>TIMESTAMP</CODE> всегда сохраняется в 4 байтах. Параметр <CODE>M</CODE>
воздействует только на то, как отображается столбец <CODE>TIMESTAMP</CODE>.
Обратите внимание, что столбцы <CODE>TIMESTAMP(X)</CODE> при X, равном 8 или
14, являются числами, в то время как другие столбцы <CODE>TIMESTAMP(X)</CODE>
представляют собой строки! Это только должно гарантировать, что можно надежно
сбросить таблицу в дамп, а потом восстанавливать ее с этими типами!

<DT><CODE>TIME</CODE>
<DD>Время. Поддерживаемый диапазон: от <CODE>-838:59:59</CODE> до
<CODE>838:59:59</CODE>. MySQL отображает значения типа <CODE>TIME</CODE> в
формате <CODE>HH:MM:SS</CODE>, но позволяет Вам задавать значения столбцам
<CODE>TIME</CODE>, используя строки или числа.

<DT><CODE>YEAR[(2|4)]</CODE>
<DD>Год с двумя или четыремя цифрами (по умолчанию задано 4). Допустимые
значения: от <CODE>1901</CODE> до <CODE>2155</CODE>, <CODE>0000</CODE> в
формате года с 4 цифрами, и 1970-2069, если Вы используете формат с 2
цифрами (70-69). MySQL отображают значения <CODE>YEAR</CODE> в формате
<CODE>YYYY</CODE>, но позволяет Вам указывать значения столбцам типа
<CODE>YEAR</CODE>, используя строки или числа. Впервые тип <CODE>YEAR</CODE>
появился в MySQL Version 3.22.

<DT><CODE>[NATIONAL] CHAR(M) [BINARY]</CODE>
<DD>Строка фиксированной длины, которая всегда дополняется справа пробелами
до определенной длины. Диапазон <CODE>M</CODE> от 1 до 255 символов. Конечные
пробелы будут удалены, когда значение извлекается из таблицы. Переменные
<CODE>CHAR</CODE> сортируются и сравниваются без учета регистра согласно
заданному по умолчанию набору символов, если не задано ключевое слово
<CODE>BINARY</CODE>. <CODE>NATIONAL CHAR</CODE> (короткая форма
<CODE>NCHAR</CODE>) представляет собой взятый из ANSI SQL способ определить,
что столбец CHAR должен использовать заданный набор символов CHARACTER. Это
значение по умолчанию в MySQL.

<CODE>CHAR</CODE> является сокращением для <CODE>CHARACTER</CODE>. MySQL
позволяет Вам создавать столбец типа <CODE>CHAR(0)</CODE>. Это главным
образом полезно, когда Вы должны обеспечить совместимость с некоторыми
старыми прикладными программами, которые зависят от существования столбца, но
фактически не использует значение. Это также очень удобно, когда Вы
нуждаетесь в столбце, который может брать только 2 значения:
<CODE>CHAR(0)</CODE>, который не определен как <CODE>NOT NULL</CODE>, займет
всего лишь один бит и может принимать только 2 значения: <CODE>NULL</CODE>
или <CODE>""</CODE>.

<DT><CODE>[NATIONAL] VARCHAR(M) [BINARY]</CODE>
<DD>Строка переменной длины.
A variable-length string. <STRONG>ОБРАТИТЕ ВНИМАНИЕ:</STRONG> Конечные
пробелы будут автоматически удалены, когда значение сохранено (это отличается
от спецификаций ANSI SQL). Диапазон <CODE>M</CODE> от 1 до 255 символов.
Значения типа <CODE>VARCHAR</CODE> сортируются и сравниваются без учета
регистра согласно заданному по умолчанию набору символов, если не задано
ключевое слово <CODE>BINARY</CODE>. <CODE>VARCHAR</CODE> является сокращением
для <CODE>CHARACTER VARYING</CODE>.

<DT><CODE>TINYBLOB</CODE>
<DD>
<DT><CODE>TINYTEXT</CODE>
<DD>Столбцы <CODE>BLOB</CODE> или <CODE>TEXT</CODE> имеют максимальную длину
в 255 (2^8-1) символов.

<DT><CODE>BLOB</CODE>
<DD>
<DT><CODE>TEXT</CODE>
<DD>Столбцы <CODE>BLOB</CODE> или <CODE>TEXT</CODE> имеют максимальную длину
в 65535 (2^16-1) символов.

<DT><CODE>MEDIUMBLOB</CODE>
<DD>
<DT><CODE>MEDIUMTEXT</CODE>
<DD>Столбцы <CODE>MEDIUMBLOB</CODE> или <CODE>MEDIUMTEXT</CODE> имеют
максимальную длину в 16777215 (2^24-1) символов.

<DT><CODE>LONGBLOB</CODE>
<DD>
<DT><CODE>LONGTEXT</CODE>
<DD>Столбцы <CODE>LONGBLOB</CODE> или <CODE>LONGTEXT</CODE> имеют
максимальную длину в 4294967295 (2^32-1) символов. Обратите внимание, что
поскольку протокол клиент-сервер и таблицы MyISAM имеет в настоящее время
ограничение в 16M на пакет связи/строку таблицы, Вы не можете использовать
весь диапазон этого типа.

<DT><CODE>ENUM('value1','value2',...)</CODE>
<DD>Перечисление. Строковый объект, который может иметь только одно значение,
выбранное из списка значений <CODE>value1</CODE>, <CODE>value2</CODE>,
<CODE>...</CODE>, <CODE>NULL</CODE> или специальное значение ошибки
<CODE>""</CODE>. <CODE>ENUM</CODE> может иметь максимум 65535 разных значений.

<DT><CODE>SET('value1','value2',...)</CODE>
<DD>Множество. Строковый объект, который может иметь ноль или больше
значений, каждое из которых должно быть выбрано из списка значений
<CODE>value1</CODE>, <CODE>value2</CODE>, <CODE>...</CODE>. <CODE>SET</CODE>
может иметь максимум 64 члена.</DL>

<H3><A NAME="Numeric_types">5.1 Числовые типы</A></H3>
<P>MySQL поддерживает все числовые типы ANSI/ISO SQL92. Эти типы включают
точные числовые типы данных (<CODE>NUMERIC</CODE>, <CODE>DECIMAL</CODE>,
<CODE>INTEGER</CODE> и <CODE>SMALLINT</CODE>), а также приблизительные
числовые типы данных (<CODE>FLOAT</CODE>, <CODE>REAL</CODE> и <CODE>DOUBLE
PRECISION</CODE>). Ключевое слово <CODE>INT</CODE> представляет собой синоним
для <CODE>INTEGER</CODE>, а ключевое слово <CODE>DEC</CODE> является
синонимом для <CODE>DECIMAL</CODE>.</P>

<P>Типы <CODE>NUMERIC</CODE> и <CODE>DECIMAL</CODE> выполнены как тот же
самый тип MySQL, как разрешено стандартом SQL92. Они используются для
значений, для которых важно сохранить идеальную точность, например, с
валютными данными. При объявлении столбца одного из этих типов точность и
масштаб могут быть (и обычно бывают) определены, например:</P>
<PRE>
   salary DECIMAL(9,2)
</PRE>

<P>В этом примере <CODE>9</CODE> (<CODE>точность, precision</CODE>)
представляет число значащих десятичных цифр, которые будут сохранены для
значений, а <CODE>2</CODE> (<CODE>масштаб, scale</CODE>) представляет число
цифр, которые будут сохранены после десятичной отметки. В этом случае,
следовательно, диапазон значений, которые могут быть сохранены в столбце
<CODE>salary</CODE> от <CODE>-9999999.99</CODE> до <CODE>9999999.99</CODE>.
(MySQL может фактически сохранять числа до <CODE>9999999.99</CODE> в этом
столбце потому, что не требуется сохранять знак для положительных чисел).</P>

<P>В ANSI/ISO SQL92 синтаксис <CODE>DECIMAL(p)</CODE> эквивалентен
<CODE>DECIMAL(p,0)</CODE>. Точно так же синтаксис <CODE>DECIMAL</CODE>
является эквивалентным <CODE>DECIMAL(p,0)</CODE>, где реализации позволяют
менять значение <CODE>p</CODE>. MySQL в настоящее время не поддерживает
никакую из этих различных форм типов данных
<CODE>DECIMAL</CODE>/<CODE>NUMERIC</CODE>. Это не серьезная проблема,
поскольку принципиальные выгоды этих типов происходят от способности
управлять точностью и масштабом явно.</P>

<P>Значения типов <CODE>DECIMAL</CODE> и <CODE>NUMERIC</CODE> сохранены как
строки, в не как двоичные числа с плавающей запятой, чтобы сохранить
десятичную точность значений. Один символ используется для каждой цифры
значения, десятичной отметки (если <CODE>scale</CODE> &#62; 0) и знака
<SAMP>-</SAMP> (для отрицательных чисел). Если <CODE>scale</CODE> равен 0,
значения <CODE>DECIMAL</CODE> и <CODE>NUMERIC</CODE> не содержат никакой
десятичной отметки или дробной части.</P>

<P>Максимальный диапазон значений <CODE>DECIMAL</CODE> и <CODE>NUMERIC</CODE>
аналогичен диапазону для <CODE>DOUBLE</CODE>, но фактический диапазон для
данного столбца <CODE>DECIMAL</CODE> или <CODE>NUMERIC</CODE> может быть
ограничен точностью или масштабом для данного столбца. Когда такой столбец
назначен, значение с большим количеством цифр после десятичной отметки, чем
позволяется определенным масштабом, будет округлено до заданного масштаба.
Когда происходит переполнение (столбцу присваивается значение, превышающее
его диапазон), MySQL сохраняет значение, представляющее соответствующий
максимум этого диапазона.</P>

<P>MySQL поддерживает как расширение стандарта ANSI/ISO SQL92 встроенные типы
<CODE>TINYINT</CODE>, <CODE>MEDIUMINT</CODE> и <CODE>BIGINT</CODE> как
перечислено в таблицах выше. Другое расширение поддержано MySQL для
факультативного определения ширины отображения значения в круглых скобках
после основного ключевого слова для типа (например, <CODE>INT(4)</CODE>).
Эта факультативная спецификация ширины используется для вывода значений, чья
ширина меньше, чем ширина, определенная для столбца, но не сдерживает
диапазон значений, которые могут быть сохранены в столбце, или число цифр,
которые будут отображаться для значений, чья ширина превышает заданную. Когда
используется вместе с факультативным атрибутом расширения
<CODE>ZEROFILL</CODE>, дополнение значения по умолчанию пробелами заменено на
нули. Например, для столбца, объявленного как <CODE>INT(5) ZEROFILL</CODE>,
значение <CODE>4</CODE> превратится в <CODE>00004</CODE>. Обратите внимание,
что, если Вы сохраняете значения большие, чем ширина отображения в
целочисленном столбце, Вы можете испытывать проблемы, когда MySQL генерирует
временные таблицы для некоторых сложных объединений, поскольку в этих случаях
MySQL полагает, что данные вписывались в первоначальную ширину столбца.</P>

<P>Все встроенные типы могут иметь факультативный (ненормативный) атрибут
<CODE>UNSIGNED</CODE>. Значения без знака могут использоваться, когда Вы
хотите позволять только положительные числа в столбце, и Вы нуждаетесь в
немного большем числовом диапазоне столбца.</P>

<P>Тип <CODE>FLOAT</CODE> используется, чтобы представить приблизительные
числовые типы данных. Стандарт ANSI/ISO SQL92 позволяет факультативную
спецификацию точности (но не диапазон образца) в битах после ключевого слова
<CODE>FLOAT</CODE> в круглых скобках. MySQL-реализация также поддерживает эту
факультативную спецификацию точности. Когда ключевое слово <CODE>FLOAT</CODE>
используется для типа столбца без спецификации точности, MySQL применяет
четыре байта, чтобы сохранить значения. Различный синтаксис также поддержан,
с двумя числами, заданными в круглых скобках после ключевого слова
<CODE>FLOAT</CODE>. С этой опцией первое число продолжает представлять
требования к памяти для значения в байтах, а второе определяет число цифр,
которые будут сохранены и отображаться после десятичной отметки (как с
<CODE>DECIMAL</CODE> и <CODE>NUMERIC</CODE>). Когда MySQL нужно сохранить
число для такого столбца с большим количеством цифр после десятичной отметки,
чем определено для столбца, значение будет автоматически округлено, чтобы
устранить лишние цифры.</P>

<P>Типы <CODE>REAL</CODE> и <CODE>DOUBLE PRECISION</CODE> не принимают
спецификации точности. В качестве дополнения к стандарту ANSI/ISO SQL92 MySQL
распознает <CODE>DOUBLE</CODE> как синоним для <CODE>DOUBLE PRECISION</CODE>.
В отличие от требования стандарта, чтобы точность для <CODE>REAL</CODE> была
меньшие, чем используемая для <CODE>DOUBLE PRECISION</CODE>, MySQL реализует
то и другое как 8-байтные double-precision floating-point значения (при
работе не в ANSI mode). Для максимальной мобильности код, требующий
хранение приблизительных числовых значений данных должен использовать
<CODE>FLOAT</CODE> или <CODE>DOUBLE PRECISION</CODE> без спецификации
точности или количества чисел после десятичной точки.</P>

<P>Когда нужно сохранить значение в числовом столбце, которое выходит за
диапазон, MySQL отсекает значение к соответствующей границе диапазона и
сохраняет возникающее в результате значение.</P>

<P>Например, диапазон столбца <CODE>INT</CODE> от <CODE>-2147483648</CODE> до
<CODE>2147483647</CODE>. Если Вы пробуете вставлять <CODE>-9999999999</CODE>
в столбец типа <CODE>INT</CODE>, значение будет усечено к нижей границе
диапазона и сохранено <CODE>-2147483648</CODE>. Точно так же, если Вы
пробуете вставлять <CODE>9999999999</CODE>, вместо этого будет сохранено
<CODE>2147483647</CODE>.</P>

<P>Если столбец <CODE>INT</CODE> определен как <CODE>UNSIGNED</CODE>, размер
диапазона столбца тот же самый, но произойдет сдвиг значений на
<CODE>0</CODE> и <CODE>4294967295</CODE>. Если Вы пробуете сохранять
<CODE>-9999999999</CODE> и <CODE>9999999999</CODE>, значения, сохраненные в
столбце, станут соответственно <CODE>0</CODE> и <CODE>4294967296</CODE>.</P>

<P>Преобразования, которые происходят из-за усечения, сообщаются как
``warnings'' для инструкций <CODE>ALTER TABLE</CODE>, <CODE>LOAD DATA
INFILE</CODE>, <CODE>UPDATE</CODE> и многострочного варианта
<CODE>INSERT</CODE>.</P>

<H3><A NAME="Date_and_time_types">5.2 Типы Date и Time</A></H3>
<P>Типы даты и времени: <CODE>DATETIME</CODE>, <CODE>DATE</CODE>,
<CODE>TIMESTAMP</CODE>, <CODE>TIME</CODE> и <CODE>YEAR</CODE>. Каждый из них
имеет диапазон допустимых значений, также как и некий ноль, который
используется, когда Вы определяете, действительно, запрещенное значение.
Обратите внимание, что MySQL позволяет Вам сохранять некоторые недопустимые
значения даты, например, <CODE>1999-11-31</CODE>. Причина этого в том, что
обрабатывать проверку даты ответственность прикладной программы, а не сервера
SQL. Чтобы сделать проверку даты быстрой, MySQL проверяет только то, что
месяц находится в диапазоне 0-12, и день находится в диапазоне 0-31.
Вышеупомянутые диапазоны определены так потому, что MySQL позволяет Вам
сохранять в столбцах <CODE>DATE</CODE> или <CODE>DATETIME</CODE> даты, где
день или месяц нулевой. Это чрезвычайно полезно для прикладных программ,
которые должны сохранить дату рождения, для которой Вы не знаете точную дату.
В этом случае Вы просто сохраняете дату подобно <CODE>1999-00-00</CODE> или
<CODE>1999-01-00</CODE>. Вы, конечно, не можете получать правильное значение
из функций, подобных <CODE>DATE_SUB()</CODE> или <CODE>DATE_ADD</CODE>, для
таких неправильных дат.</P>

<P>Имеются некоторые общие вещи, которые стоит иметь в виду при работе с
типами даты и времени:</P>

<UL><LI>MySQL возвращает значения для данного типа в стандартном формате, но
пытается интерпретировать ряд форматов для значений, которые Вы обеспечиваете
(например, когда Вы определяете значение, которое будет назначено переменной
или сравниваться). Однако, поддержаны только форматы, описанные в следующих
разделах. Ожидается, что Вы обеспечите допустимые значения, и непредсказуемые
результаты могут быть получены, если Вы используете значения в других форматах.

<LI>Хотя MySQL пробует интерпретировать значения в нескольких форматах, он
всегда ожидает, что часть, определяющая год, стоит на крайнем слева месте.
Даты должны быть даны в порядке год-месяц-день (например,
<CODE>98-09-04</CODE>).

<LI>MySQL автоматически преобразует значения даты и времени в числа, если
значение используется в числовом контексте, и наоборот.

<LI>Когда MySQL сталкивается со значением, которое находится вне диапазона
или иначе запрещено для типа, он устанавливает значение в ноль для этого
типа. Исключительная ситуация: вышедшие за границу диапазона значения
<CODE>TIME</CODE> урезаются до соответствующей границы. Таблица ниже
показывает нулевые значения каждого типа:

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Тип столбца</STRONG></TD><TD><STRONG>Нулевое значение
</STRONG></TD></TR>
<TR><TD><CODE>DATETIME</CODE></TD><TD><CODE>'0000-00-00 00:00:00'</CODE>
</TD></TR>
<TR><TD><CODE>DATE</CODE></TD><TD><CODE>'0000-00-00'</CODE></TD></TR>
<TR><TD><CODE>TIMESTAMP</CODE></TD><TD><CODE>00000000000000</CODE> (длина
зависит от размера отображения)</TD></TR>
<TR><TD><CODE>TIME</CODE></TD><TD><CODE>'00:00:00'</CODE></TD></TR>
<TR><TD><CODE>YEAR</CODE></TD><TD><CODE>0000</CODE></TD></TR></TABLE>

<LI>Нулевое значение специально, но Вы можете сохранять или обращаться к ним,
явно используя значения, показанные в таблице. Вы можете также делать это,
применяя значения <CODE>'0'</CODE> или <CODE>0</CODE>.

<LI>Нулевые значения даты и времени, используемые через
<STRONG>MyODBC</STRONG>, будут преобразованы автоматически в
<CODE>NULL</CODE> в <STRONG>MyODBC</STRONG> Version 2.50.12 и выше потому,
что ODBC не может обрабатывать такие значения.</UL>

<H4><A NAME="Y2K_issues">5.2.1 Проблема Y2K и типы Date</A></H4>
<P>MySQL непосредственно Y2K-безопасен, но вводимые значения таковыми не
явдяются. Любой ввод, содержащий значения года с 2 цифрами, неоднозначен
потому, что столетие неизвестно. Такие значения должны интерпретироваться в
форму с 4 цифрами потому, что MySQL сохраняет годы, внутренне всегда
используя четыре цифры.</P>

<P>Для типов <CODE>DATETIME</CODE>, <CODE>DATE</CODE>, <CODE>TIMESTAMP</CODE>
и <CODE>YEAR</CODE> MySQL интерпретирует даты с неоднозначным годом так:</P>

<UL><LI>Значения года в диапазоне <CODE>00-69</CODE> будут преобразованы в
<CODE>2000-2069</CODE>.
<LI>Значения года в диапазоне <CODE>70-99</CODE> будут преобразованы в
<CODE>1970-1999</CODE>.</UL>

<P>Не забудьте, что эти правила обеспечивают только приемлемые предположения
относительно того, что Ваши данные означают. Если логика, используемая MySQL,
не производит правильные значения, Вы должны обеспечить однозначный ввод,
содержащий значения года с 4 цифрами.</P>

<P><CODE>ORDER BY</CODE> сортирует значения типов
<CODE>YEAR/DATE/DATETIME</CODE> с 2 цифрами правильно.</P>

<P>Обратите внимание также, что некоторые функции, подобно <CODE>MIN()</CODE>
и <CODE>MAX()</CODE>, преобразуют <CODE>TIMESTAMP/DATE</CODE> в число. Это
означает, что timestamp с годом с 2 цифрами не будет работать правильно с
этими функциями. Исправление в этом случае должно преобразовать
<CODE>TIMESTAMP/DATE</CODE> к формату года с 4 цифрами или использовать нечто
вроде <CODE>MIN(DATE_ADD(timestamp,INTERVAL 0 DAYS))</CODE>.</P>

<H4><A NAME="DATETIME">5.2.2
Типы <CODE>DATETIME</CODE>, <CODE>DATE</CODE> и <CODE>TIMESTAMP</CODE></A>
</H4>
<P><A NAME="IDX1042"></A><A NAME="IDX1043"></A><A NAME="IDX1044"></A></P>
<P>Типы <CODE>DATETIME</CODE>, <CODE>DATE</CODE> и <CODE>TIMESTAMP</CODE>
связаны. Этот раздел описывает их характеристики и чем они отличаются.</P>

<P>Тип <CODE>DATETIME</CODE> используется, когда Вы нуждаетесь в значениях,
которые содержат информацию о дате и времени. MySQL получает и отображает
значения <CODE>DATETIME</CODE> в формате <CODE>YYYY-MM-DD HH:MM:SS</CODE>.
Поддерживаемый диапазон от <CODE>1000-01-01 00:00:00</CODE> до
<CODE>9999-12-31 23:59:59</CODE>.</P>

<P>Тип <CODE>DATE</CODE> используется, когда Вы нуждаетесь только в значении
даты, без части времени. MySQL получает и отображает значения
<CODE>DATE</CODE> в формате <CODE>YYYY-MM-DD</CODE>. Поддерживаемый диапазон
от <CODE>1000-01-01</CODE> до <CODE>9999-12-31</CODE>.</P>

<P>Тип столбца <CODE>TIMESTAMP</CODE> обеспечивает тип, который Вы можете
использовать, чтобы автоматически отметить операции <CODE>INSERT</CODE> или
<CODE>UPDATE</CODE> текущей датой и временем. Если Вы имеете много столбцов
типа <CODE>TIMESTAMP</CODE>, только первый модифицируется автоматически.</P>

<P>Автоматическое модифицирование первого столбца <CODE>TIMESTAMP</CODE>
происходит при любом из условий:</P>

<UL><LI>Столбец не определен явно в инструкции <CODE>INSERT</CODE> или
<CODE>LOAD DATA INFILE</CODE>.

<LI>Столбец не определен явно в инструкции <CODE>UPDATE</CODE> и некотором
другом значении изменений столбца. Обратите внимание, что
<CODE>UPDATE</CODE>, который устанавливает столбец к значению, которое тот
уже имеет, не будет заставлять столбец типа <CODE>TIMESTAMP</CODE>
модифицироваться потому, что, если Вы устанавливаете столбец к текущему
значению, MySQL игнорирует модификацию для эффективности.

<LI>Вы явно устанавливаете столбец типа <CODE>TIMESTAMP</CODE> в
<CODE>NULL</CODE>.</UL>

<P>Второй и последующие столбцы типа <CODE>TIMESTAMP</CODE> также могут быть
установлены к текущей дате и времени. Только установите столбец в
<CODE>NULL</CODE> или в <CODE>NOW()</CODE>.</P>

<P>Вы можете устанавливать любой столбец <CODE>TIMESTAMP</CODE> к значению
иному, чем текущая дата и время, устанавливая это явно. Это истинно даже для
первого столбца <CODE>TIMESTAMP</CODE>. Вы можете использовать это свойство,
если, например, Вы хотите, чтобы <CODE>TIMESTAMP</CODE> был установлен
к текущей дате и времени, когда Вы создаете строку, но не был изменен всякий
раз, когда строка модифицируется позже:</P>

<UL><LI>Позвольте MySQL устанавливать столбец, когда строка создана. Это
инициализирует переменную и установит ее в текущую дату и время.

<LI>Когда Вы выполняете последующие модификации к другим столбцам в строке,
установите столбец <CODE>TIMESTAMP</CODE> явно в текущее значение.</UL>

<P>Значения <CODE>TIMESTAMP</CODE> имеют точность в одну секунду. Значения
отображаются как числа.</P>

<P>Формат, в котором MySQL получает и отображает значения
<CODE>TIMESTAMP</CODE>, зависят от размера отображения, как иллюстрируется
таблицей ниже. Полный формат <CODE>TIMESTAMP</CODE> имеет 14 цифр, но столбцы
могут быть созданы с более короткими размерами отображения:</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Тип столбца</STRONG></TD><TD><STRONG>Формат отображения
</STRONG></TD></TR>
<TR><TD><CODE>TIMESTAMP(14)</CODE></TD><TD><CODE>YYYYMMDDHHMMSS</CODE></TD>
</TR>
<TR><TD><CODE>TIMESTAMP(12)</CODE></TD><TD><CODE>YYMMDDHHMMSS</CODE></TD>
</TR>
<TR><TD><CODE>TIMESTAMP(10)</CODE></TD><TD><CODE>YYMMDDHHMM</CODE></TD></TR>
<TR><TD><CODE>TIMESTAMP(8)</CODE></TD><TD><CODE>YYYYMMDD</CODE></TD></TR>
<TR><TD><CODE>TIMESTAMP(6)</CODE></TD><TD><CODE>YYMMDD</CODE></TD></TR>
<TR><TD><CODE>TIMESTAMP(4)</CODE></TD><TD><CODE>YYMM</CODE></TD></TR>
<TR><TD><CODE>TIMESTAMP(2)</CODE></TD><TD><CODE>YY</CODE></TD></TR></TABLE>

<P>Все столбцы типа <CODE>TIMESTAMP</CODE> имеют тот же самый размер памяти,
независимо от размера отображения. Наиболее распространенные размеры: 6, 8,
12 и 14. Вы можете определять произвольный размер при создании таблицы, но
значения 0 или больше, чем 14, будут установлены в 14. Нечетные размеры в
диапазоне от 1 до 13 будут приведены к следующему четному числу.</P>

<P>Вы можете определять значения <CODE>DATETIME</CODE>, <CODE>DATE</CODE> и
<CODE>TIMESTAMP</CODE>, использующие любой из общего набора форматов:</P>

<UL><LI>Строка в формате <CODE>YYYY-MM-DD HH:MM:SS</CODE> или <CODE>YY-MM-DD
HH:MM:SS</CODE>. Облегченный синтаксис позволяется: любой символ пунктуации
может использоваться как разделитель между частями даты или частями времени.
Например, <CODE>98-12-31 11:30:45</CODE>, <CODE>98.12.31 11+30+45</CODE>,
<CODE>98/12/31 11*30*45</CODE> и <CODE>98@12@31 11^30^45</CODE> равны.

<LI>Строка в формате <CODE>YYYY-MM-DD</CODE> или <CODE>YY-MM-DD</CODE>.
Облегченный синтаксис позволяется и здесь: например, строки
<CODE>98-12-31</CODE>, <CODE>98.12.31</CODE>, <CODE>98/12/31</CODE> и
<CODE>98@12@31</CODE> являются эквивалентными.

<LI>Строка без разделителей в формате <CODE>YYYYMMDDHHMMSS</CODE> или
<CODE>YYMMDDHHMMSS</CODE>, при условии, что строка имеет смысл как дата.
Например, <CODE>19970523091528</CODE> и <CODE>970523091528</CODE>
интерпретируются как <CODE>1997-05-23 09:15:28</CODE>, но
<CODE>971122129015</CODE> запрещен (это имеет неправильную минутную часть) и
становится <CODE>0000-00-00 00:00:00</CODE>.

<LI>Строка без разделителей в формате <CODE>YYYYMMDD</CODE> или
<CODE>YYMMDD</CODE>, при условии, что строка имеет смысл как дата. Например,
<CODE>19970523</CODE> и <CODE>970523</CODE> интерпретируются как
<CODE>1997-05-23</CODE>, но <CODE>971332</CODE> запрещен (это имеет
неправильную часть месяца) и становится <CODE>0000-00-00</CODE>.

<LI>Число в формате <CODE>YYYYMMDDHHMMSS</CODE> или <CODE>YYMMDDHHMMSS</CODE>,
при условии, что число имеет смысл как дата. Например,
<CODE>19830905132800</CODE> и <CODE>830905132800</CODE> интерпретируются как
<CODE>1983-09-05 13:28:00</CODE>.

<LI>Число в формате <CODE>YYYYMMDD</CODE> или <CODE>YYMMDD</CODE> при
условии, что число имеет смысл как дата. Например, <CODE>19830905</CODE> и
<CODE>830905</CODE> интерпретируются как <CODE>1983-09-05</CODE>.

<LI>Результат функции, которая возвращает значение которое является
приемлемым в контексте <CODE>DATETIME</CODE>, <CODE>DATE</CODE> или
<CODE>TIMESTAMP</CODE>, типа <CODE>NOW()</CODE> или
<CODE>CURRENT_DATE</CODE>.</UL>

<P>Запрещенные значения <CODE>DATETIME</CODE>, <CODE>DATE</CODE> или
<CODE>TIMESTAMP</CODE> преобразованы в нулевое значение соответствующего типа
(<CODE>0000-00-00 00:00:00</CODE>, <CODE>0000-00-00</CODE> или
<CODE>00000000000000</CODE>).</P>

<P>Для значений, определенных как строки, которые включают разделители частей
даты, не требуется определять две цифры для значений месяца или дня, которые
являются меньше, чем <CODE>10</CODE>. <CODE>1979-6-9</CODE> эквивалентно
<CODE>1979-06-09</CODE>. Точно так же для значений, определенных как строки,
которые включают разделители части времени, необязательно определять две
цифры для значений часа, минут или секунды, которые меньше, чем
<CODE>10</CODE>. <CODE>1979-10-30 1:2:3</CODE> то же самое, что и
<CODE>1979-10-30 01:02:03</CODE>.</P>

<P>Значения, определенные как числа, должны быть длиной в 6, 8, 12 или 14
цифр. Если число длиной в 8 или 14 цифр, считается, что оно в формате
<CODE>YYYYMMDD</CODE> или <CODE>YYYYMMDDHHMMSS</CODE>, и что год задан
первыми 4 цифрами. Если число длиной в 6 или 12 цифр, считается, что оно в
формате <CODE>YYMMDD</CODE> или <CODE>YYMMDDHHMMSS</CODE>, и что год задан
первыми 2 цифрами. Числа, которые не соответствуют этим длинам, дополняются
нулями до самой близкой длины.</P>

<P><A NAME="IDX1045"></A><A NAME="IDX1046"></A>Значения, определенные как
неразграниченные строки интерпретируются, используя их длину как она есть.
Это означает, что Вы не должны использовать строки короче шести символов.
Например, если Вы определяете <CODE>9903</CODE>, думая, что представите март
1999 года, Вы найдете, что MySQL вставляет ноль для даты в Вашу таблицу. Это
потому, что значения года и месяца <CODE>99</CODE> и <CODE>03</CODE>, но
часть дня пропущено, так что значение не является допустимой датой.</P>

<P>Столбцы <CODE>TIMESTAMP</CODE> сохраняют допустимые значения, используя
полную точность, с которой значение было определено, независимо от размера
отображения. Это имеет несколько значений:</P>

<UL><LI>Всегда определяйте год, месяц и день, даже если Ваш тип столбца
<CODE>TIMESTAMP(4)</CODE> или <CODE>TIMESTAMP(2)</CODE>. Иначе, значение не
будет допустимой датой, и будет сохранен <CODE>0</CODE>.

<LI>Если Вы используете <CODE>ALTER TABLE</CODE>, чтобы расширить узкий
столбец <CODE>TIMESTAMP</CODE>, будет отображаться та информация, которая
раньше была скрыта.

<LI>Точно так же сужение столбца <CODE>TIMESTAMP</CODE> не уничтожит
информацию, просто меньшее количество информации будет показываться, когда
значения столбца отображаются.

<LI>Хотя значения <CODE>TIMESTAMP</CODE> сохранены в полной точности,
единственная функция, которая функционирует непосредственно на основном
сохраненном значении, это <CODE>UNIX_TIMESTAMP()</CODE>. Другие функции
имеют дело с форматируемым значением. Вы не можете использовать функции типа
<CODE>HOUR()</CODE> или <CODE>SECOND()</CODE>, если релевантная часть
значения <CODE>TIMESTAMP</CODE> не включена в форматируемое значение.
Например, часть <CODE>HH</CODE> столбца <CODE>TIMESTAMP</CODE> не
отображается, если размер отображения меньше 10.</UL>

<P>Вы можете до некоторой степени назначать значения одного типа даты объекту
иного типа даты. Однако, может иметься некоторое изменение значения или
потери информации:</P>

<UL><LI>Если Вы назначаете значение <CODE>DATE</CODE> объекту
<CODE>DATETIME</CODE> или <CODE>TIMESTAMP</CODE>, часть времени возникающего
в результате значения будет установлена в <CODE>00:00:00</CODE> потому, что
значение <CODE>DATE</CODE> не содержит информацию для времени.

<LI>Если Вы назначаете значение <CODE>DATETIME</CODE> или
<CODE>TIMESTAMP</CODE> объекту a <CODE>DATE</CODE>, часть времени
возникающего в результате значения удалена потому, что тип <CODE>DATE</CODE>
не сохраняет информацию о времени.

<LI>Не забудьте, что, хотя <CODE>DATETIME</CODE>, <CODE>DATE</CODE> и
<CODE>TIMESTAMP</CODE> могут быть определены, используя тот же самый набор
форматов, они имеют разный диапазон значений. Например,
<CODE>TIMESTAMP</CODE> не могут быть ранее, чем <CODE>1970</CODE>, или позже,
чем <CODE>2037</CODE>. Это означает, что дата типа <CODE>1968-01-01</CODE>,
которая вполне нормальна для <CODE>DATETIME</CODE> или <CODE>DATE</CODE>,
недопустима для переменной типа <CODE>TIMESTAMP</CODE> и превратится в
<CODE>0</CODE>.</UL>

<P><A NAME="IDX1047"></A><A NAME="IDX1048"></A>Знайте некоторые ловушки при
определении значений даты:</P>

<UL><LI>Ослабленный формат, позволенный для значений, определенных как
строки, может обманывать. Например, значение типа <CODE>10:11:12</CODE> могло
бы напоминать значение времени из-за разделителя <SAMP>:</SAMP>, но если оно
используется в контексте даты будет интерпретироваться как год
<CODE>2010-11-12</CODE>. Значение <CODE>10:45:15</CODE> будет преобразовано в
<CODE>0000-00-00</CODE> потому, что <CODE>45</CODE> недопустимый месяц.

<LI>Значения года, определенные как две цифры, неоднозначны потому, что
столетие неизвестно. MySQL интерпретирует их так:

<UL><LI>Значения года в диапазоне <CODE>00-69</CODE> преобразованы в
<CODE>2000-2069</CODE>.

<LI>Значения года в диапазоне <CODE>70-99</CODE> преобразованы в
<CODE>1970-1999</CODE>.</UL></UL>

<H4><A NAME="TIME">5.2.3 Тип <CODE>TIME</CODE></A></H4>
<P>MySQL получает и отображает значения <CODE>TIME</CODE> в формате
<CODE>HH:MM:SS</CODE> (или <CODE>HHH:MM:SS</CODE> для больших значений
часов). Значения <CODE>TIME</CODE> могут располагаться в диапазоне от
<CODE>-838:59:59</CODE> до <CODE>838:59:59</CODE>. Причина того, что часть
часов может быть настолько большой в том, что тип <CODE>TIME</CODE> может
использоваться не только, чтобы представить время дня (которое должно быть
меньше, чем 24 часа), но также и прошедшее время или интервал времени между
двумя событиями (который может быть намного больше, чем 24 часа).</P>

<P>Вы можете определять значения <CODE>TIME</CODE> разными способами:</P>

<UL><LI>Как строку в формате <CODE>D HH:MM:SS.fraction</CODE>. Обратите
внимание, что MySQL все же не сохраняет дробную часть для столбца времени.
Можно также использовать один из следующих ослабленных синтаксисов:
<CODE>HH:MM:SS.fraction</CODE>, <CODE>HH:MM:SS</CODE>, <CODE>HH:MM</CODE>,
<CODE>D HH:MM:SS</CODE>, <CODE>D HH:MM</CODE>, <CODE>D HH</CODE> или
<CODE>SS</CODE>. Здесь под <CODE>D</CODE> понимаются дни в пределах 0-33.

<LI>Как строку без разделителей в формате <CODE>HHMMSS</CODE>, при условии,
что это имеет смысл как время. Например, <CODE>101112</CODE> допустимо и
будет воспринято как <CODE>10:11:12</CODE>, но <CODE>109712</CODE> из-за
неправильной минутной части превратится в <CODE>00:00:00</CODE>.

<LI>Как число в фромате <CODE>HHMMSS</CODE>, при условии, что это имеет смысл
как время. Например, <CODE>101112</CODE> допустимо и будет воспринято как
<CODE>10:11:12</CODE>. Следующие альтернативные форматы также будут поняты:
<CODE>SS</CODE>, <CODE>MMSS</CODE>, <CODE>HHMMSS</CODE>,
<CODE>HHMMSS.fraction</CODE>. Обратите внимание, что MySQL все же не
сохраняет дробную часть.

<LI>Как результат функции, которая возвращает значение, которое является
приемлемым в контексте <CODE>TIME</CODE>, например,
<CODE>CURRENT_TIME</CODE>.</UL>

<P>Для значений <CODE>TIME</CODE>, определенных как строки, которые включают
разделитель частей времени, необязательно задавать две цифры для часов,
минут или секунд, которые меньше <CODE>10</CODE>. Указание <CODE>8:3:2</CODE>
аналогично <CODE>08:03:02</CODE>.</P>

<P>Будьте внимательны относительно назначения коротких значений
<CODE>TIME</CODE>. Без точки с запятой MySQL интерпретирует значения,
используя предположение, что крайние справа цифры представляют секунды. MySQL
интерпретирует значения <CODE>TIME</CODE> как прошедшее время, а не время
дня. Например, Вы могли задавать <CODE>1112</CODE> и <CODE>1112</CODE> как
<CODE>11:12:00</CODE>, но MySQL поймет это как <CODE>00:11:12</CODE>. Точно
так же <CODE>12</CODE> и <CODE>12</CODE> интерпретируются как
<CODE>00:00:12</CODE>. Значения <CODE>TIME</CODE> с точкой с запятой вместо
этого, всегда обрабатываются как время дня. Так <CODE>11:12</CODE> будет
означать <CODE>11:12:00</CODE>, но не <CODE>00:11:12</CODE>.</P>

<P>Значения, которые находятся вне диапазона <CODE>TIME</CODE>, но допустимы
во всем остальном, будут усечены до соответствующей границы диапазона.
Например, <CODE>-850:00:00</CODE> и <CODE>850:00:00</CODE> превратятся в
<CODE>-838:59:59</CODE> и <CODE>838:59:59</CODE>.</P>

<P>Недопустимые значения <CODE>TIME</CODE> превратятся в
<CODE>00:00:00</CODE>. Обратите внимание, что так как <CODE>00:00:00</CODE>
представляет собой допустимое значение <CODE>TIME</CODE>, нет никакого
способа понять по сохраненному в таблице <CODE>00:00:00</CODE>, было ли
первоначальное значение определено как <CODE>00:00:00</CODE> или нет.</P>

<H4><A NAME="YEAR">5.2.4 Тип <CODE>YEAR</CODE></A></H4>
<P>Тип <CODE>YEAR</CODE> представляет собой тип с 1 байтом, используемый для
представления лет.</P>

<P>MySQL получает и отображает значения типа <CODE>YEAR</CODE> в формате
<CODE>YYYY</CODE>. Диапазон: от <CODE>1901</CODE> до <CODE>2155</CODE>.</P>

<P>Вы можете определять значения <CODE>YEAR</CODE> в форматах:</P>

<UL><LI>Как строка с четырьмя цифрами в диапазоне от <CODE>1901</CODE> до
<CODE>2155</CODE>.

<LI>Как число с четырьмя цифрами в диапазоне от <CODE>1901</CODE> до
<CODE>2155</CODE>.

<LI>Как строка с двумя цифрами в диапазоне от <CODE>00</CODE> до
<CODE>99</CODE>. Значения в диапазонах от <CODE>00</CODE> до <CODE>69</CODE>
и от <CODE>70</CODE> до <CODE>99</CODE> будут преобразованы в значения
<CODE>YEAR</CODE> в диапазонах от <CODE>2000</CODE> до <CODE>2069</CODE> и от
<CODE>1970</CODE> до <CODE>1999</CODE>.

<LI>Как число с двумя цифрами в диапазоне от <CODE>1</CODE> до
<CODE>99</CODE>. Значения в диапазонах от <CODE>1</CODE> до <CODE>69</CODE> и
от <CODE>70</CODE> до <CODE>99</CODE> будут преобразованы в значения
<CODE>YEAR</CODE> в диапазонах от <CODE>2001</CODE> до <CODE>2069</CODE> и от
<CODE>1970</CODE> до <CODE>1999</CODE>. Обратите внимание, что диапазон для
чисел с двумя цифрами немного иной, чем для строк с двумя цифрами потому, что
Вы не можете определять ноль непосредственно как число. Вы <EM>должны</EM>
определить это как строку <CODE>0</CODE> (или <CODE>00</CODE>), или это будет
интерпретироваться как <CODE>0000</CODE>.

<LI>Как результат функции, возвращающей значение, которое является
приемлемым в контексте <CODE>YEAR</CODE>, например, <CODE>NOW()</CODE>.</UL>

<P>Запрещенные значения <CODE>YEAR</CODE> будут преобразованы в
<CODE>0000</CODE>.</P>

<H3><A NAME="String_types">5.3 Строковые типы</A></H3>
<P>Строковыми считаются типы: <CODE>CHAR</CODE>, <CODE>VARCHAR</CODE>,
<CODE>BLOB</CODE>, <CODE>TEXT</CODE>, <CODE>ENUM</CODE> и <CODE>SET</CODE>.
Этот раздел описывает как работу типов, их требования к памяти и как
использовать их в Ваших запросах. Сразу следует отметить, что к строковым
причислены типы, которые в разных языках программирования таковыми не
являются, например, <CODE>ENUM</CODE> и <CODE>SET</CODE>.</P>

<H4><A NAME="CHAR">5.3.1 Типы <CODE>CHAR</CODE> и <CODE>VARCHAR</CODE></A>
</H4>
<P>Типы <CODE>CHAR</CODE> и <CODE>VARCHAR</CODE> подобны, но отличаются
способом их хранения и получения.</P>

<P>Длина столбца <CODE>CHAR</CODE> фиксирована и задается, когда Вы создаете
таблицу. Длина может быть любым значением между 1 и 255. В MySQL Version 3.23
длина <CODE>CHAR</CODE> может быть от 0 до 255. Когда значения
<CODE>CHAR</CODE> сохраняются в таблице, они дополняются справа пробелами до
нужной длины. Когда значения <CODE>CHAR</CODE> получены, конечные пробелы
будут автоматически удалены.</P>

<P>Значения в столбцах <CODE>VARCHAR</CODE> представляют собой строки
переменной длины. Вы можете объявлять, что столбец <CODE>VARCHAR</CODE> будет
любой длины между 1 и 255, точно как для столбцов типа <CODE>CHAR</CODE>.
Однако, в отличие от <CODE>CHAR</CODE>, значения <CODE>VARCHAR</CODE>
сохранены, используя ровно столько символов, сколько надо, плюс один байт,
чтобы записать длину (аналог типа String в языке Pascal). Значения не
дополняются, вместо этого конечные пробелы будут удалены, когда значения
сохранены в таблице. Это удаление пробелов отличается от спецификации ANSI
SQL, там они остаются.</P>

<P>Если Вы назначаете значение столбцу <CODE>CHAR</CODE> или
<CODE>VARCHAR</CODE>, которое превышает максимальную длину столбца, значение
будет усечено, чтобы поместиться в столбец.</P>

<P>Таблица ниже иллюстрирует различия между двумя типами столбцов, показывая
результат сохранения различных значений в <CODE>CHAR(4)</CODE> и
<CODE>VARCHAR(4)</CODE>:</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Значение</STRONG></TD><TD><CODE>CHAR(4)</CODE></TD><TD>
<STRONG>Для хранения надо</STRONG></TD><TD><CODE>VARCHAR(4)</CODE></TD><TD>
<STRONG>Для хранения надо</STRONG></TD></TR>
<TR><TD><CODE>''</CODE></TD><TD><CODE>'    '</CODE></TD><TD>4 байта</TD><TD>
<CODE>''</CODE></TD><TD>1 байт</TD></TR>
<TR><TD><CODE>'ab'</CODE></TD><TD><CODE>'ab  '</CODE></TD><TD>4 байта</TD>
<TD><CODE>'ab'</CODE></TD><TD>3 байта</TD></TR>
<TR><TD><CODE>'abcd'</CODE></TD><TD><CODE>'abcd'</CODE></TD><TD>4 байта</TD>
<TD> <CODE>'abcd'</CODE></TD><TD>5 байт</TD></TR>
<TR><TD><CODE>'abcdefgh'</CODE></TD><TD><CODE>'abcd'</CODE></TD><TD>4 байта
</TD><TD><CODE>'abcd'</CODE></TD><TD>5 байт</TD></TR></TABLE>

<P>Значения, полученные из столбцов <CODE>CHAR(4)</CODE> и
<CODE>VARCHAR(4)</CODE>, будут те же самые в каждом случае потому, что
конечные пробелы удалены из столбцов <CODE>CHAR</CODE> после поиска.</P>

<P>Значения в столбцах <CODE>CHAR</CODE> и <CODE>VARCHAR</CODE> сортируются и
сравниваются без учета регистра, если атрибут <CODE>BINARY</CODE> не был
определен, когда таблица была создана. Атрибут <CODE>BINARY</CODE> означает,
что значения столбца сортируются и сравниваются с учетом регистра согласно
порядку символов серверной (не клиентской!) машины MySQL. <CODE>BINARY</CODE>
не воздействует на то, как столбец будет сохранен или получен.</P>

<P>Атрибут <CODE>BINARY</CODE> липкий. Это означает, что, если столбец,
отмеченный как <CODE>BINARY</CODE>, используется в выражении, все выражение
сравнивается как значение <CODE>BINARY</CODE>.</P>

<P>MySQL может тихо изменять тип столбца <CODE>CHAR</CODE> или
<CODE>VARCHAR</CODE> при создании таблицы. Подробности в разделе
"<A HREF="glava07.htm#Silent_column_changes">7.3.1 Тихие изменения
спецификации столбца</A>".</P>

<H4><A NAME="BLOB">5.3.2 Типы <CODE>BLOB</CODE> и <CODE>TEXT</CODE></A></H4>
<P><CODE>BLOB</CODE> представляет собой двоичный большой объект, который
может хранить переменное количество данных. Есть четыре типа
<CODE>BLOB</CODE>'ов: <CODE>TINYBLOB</CODE>, <CODE>BLOB</CODE>,
<CODE>MEDIUMBLOB</CODE> и <CODE>LONGBLOB</CODE>, отличающиеся только по
максимальной длине значений, которые они могут хранить.</P>

<P>Четыре типа <CODE>TEXT</CODE>: <CODE>TINYTEXT</CODE>, <CODE>TEXT</CODE>,
<CODE>MEDIUMTEXT</CODE> и <CODE>LONGTEXT</CODE> соответствуют четырем типам
<CODE>BLOB</CODE> и имеют те же самые максимальные длины и требования к
памяти. Единственное различие между типами <CODE>BLOB</CODE> и
<CODE>TEXT</CODE> в том, что сортировка выполняется с учетом регистра для
значений типа <CODE>BLOB</CODE> и без учета регистра для <CODE>TEXT</CODE>.
</P>

<P>Если Вы назначаете значение столбцу <CODE>BLOB</CODE> или
<CODE>TEXT</CODE>, которое превышает максимальную длину для типа столбца,
значение будет усечено, чтобы поместиться.</P>

<P>В большинстве случаев Вы можете расценивать столбец <CODE>TEXT</CODE> как
<CODE>VARCHAR</CODE>, который может быть столь большим, как Вы хотите. Точно
так же Вы можете расценивать столбец <CODE>BLOB</CODE> как <CODE>VARCHAR
BINARY</CODE>. Различия в том, что:</P>

<UL><LI>Вы можете иметь индексы на столбцах <CODE>BLOB</CODE> и
<CODE>TEXT</CODE>, начиная с MySQL Version 3.23.2 и выше. Старые версии MySQL
не поддерживали это.

<LI>Не имеется никакого удаления пробелов для <CODE>BLOB</CODE> и
<CODE>TEXT</CODE>, когда значения сохранены, в противоположность
<CODE>VARCHAR</CODE>.

<LI><A NAME="IDX1057"></A><A NAME="IDX1058"></A><A NAME="IDX1059"></A>Столбцы
типов <CODE>BLOB</CODE> и <CODE>TEXT</CODE> не могут иметь значений
<CODE>DEFAULT</CODE>.</UL>

<P><STRONG>MyODBC</STRONG> определяет значения <CODE>BLOB</CODE> как
<CODE>LONGVARBINARY</CODE>, а значения типа <CODE>TEXT</CODE> как
<CODE>LONGVARCHAR</CODE>.</P>

<P>Поскольку значения <CODE>BLOB</CODE> и <CODE>TEXT</CODE> могут быть
чрезвычайно длинными, Вы можете столкнуться с ограничениями при использовании:
</P>

<UL><LI>Если Вы хотите использовать <CODE>GROUP BY</CODE> или
<CODE>ORDER BY</CODE> на столбце типа <CODE>BLOB</CODE> или <CODE>TEXT</CODE>,
Вы должны преобразовать значение столбца в объект фиксированной длины.
Стандартный способ сделать это: функция <CODE>SUBSTRING</CODE>, например:

<PRE>
mysql&#62; select comment from tbl_name,substring(comment,20) as substr
                  ORDER BY substr;
</PRE>

Если Вы не сделаете это, только первые <CODE>max_sort_length</CODE> байт
столбца используются при сортировке. Значение по умолчанию для
<CODE>max_sort_length</CODE> равно 1024, это значение может быть изменено,
используя опцию <CODE>-O</CODE> при запуске сервера <CODE>mysqld</CODE>. Вы
можете группировать на выражении, включающем значения <CODE>BLOB</CODE> или
<CODE>TEXT</CODE>, определяя позицию столбца или используя псевдоним:

<PRE>
mysql&#62; select id,substring(blob_col,1,100) from tbl_name
           GROUP BY 2;
mysql&#62; select id,substring(blob_col,1,100) as b from tbl_name
           GROUP BY b;
</PRE>

<LI>Максимальный размер объекта <CODE>BLOB</CODE> или <CODE>TEXT</CODE>
определен типом, но самое большое значение, которое Вы можете фактически
передать между клиентом и сервером, зависит от количества доступной памяти и
размера буферов связей. Вы можете изменять размер буфера сообщения, но Вы
должны сделать это на клиенте и на сервере.</UL>

<P>Обратите внимание, что каждое значение <CODE>BLOB</CODE> или
<CODE>TEXT</CODE> внутренне представляется отдельно распределенным объектом.
Это отличие от всех других типов столбца, для которых память распределена
один раз на столбец, когда таблица открывается.</P>

<H4><A NAME="ENUM">5.3.3 Тип <CODE>ENUM</CODE></A></H4>
<P><CODE>ENUM</CODE> представляет собой строковый объект, чье значение обычно
выбрано из списка допустимых значений, которые перечислены явно в
спецификации столбца при создании таблицы.</P>

<P>Значение может также быть пустой строкой (<CODE>""</CODE>) или
<CODE>NULL</CODE> при некоторых обстоятельствах:</P>

<UL><LI>Если Вы вставляете недопустимое значение в <CODE>ENUM</CODE> (то
есть, строку, которая не указана в перечне допустимых значений), взамен будет
вставлена пустая строка как специальное значение ошибки. Эта строка может
отличаться от нормальной пустой строки тем фактом, что эта имеет числовое
значение 0. Подробнее относительно этого позже...

<LI>Если <CODE>ENUM</CODE> объявлен как <CODE>NULL</CODE>, то
<CODE>NULL</CODE> также допустимое значение для столбца, и значением по
умолчанию как раз и будет именно <CODE>NULL</CODE>. Если <CODE>ENUM</CODE>
объявлен как <CODE>NOT NULL</CODE>, значением по умолчанию будет первый
элемент из списка дозволенных значений.</UL>

<P>Каждое значение перечисления имеет индекс:</P>

<UL><LI>Значения из списка допустимых элементов в спецификации столбца
пронумерованы, начиная с 1.

<LI>Индексное значение пустого значения ошибки 0. Это означает, что Вы можете
использовать следующую инструкцию <CODE>SELECT</CODE>, чтобы найти строки, в
которых были установлены недопустимые для <CODE>ENUM</CODE> значения:
<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE enum_col=0;
</PRE>

<LI>Индексом значения <CODE>NULL</CODE> является само <CODE>NULL</CODE>.</UL>

<P>Например, столбец, определенный как <CODE>ENUM("one","two","three")</CODE>,
может иметь любое из значений, показанных ниже. Индекс каждого значения также
показывается:</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Значение</STRONG></TD><TD><STRONG>Индекс</STRONG></TD></TR>
<TR><TD><CODE>NULL</CODE></TD><TD><CODE>NULL</CODE></TD></TR>
<TR><TD><CODE>""</CODE></TD><TD> 0</TD></TR>
<TR><TD><CODE>"one"</CODE></TD><TD>1</TD></TR>
<TR><TD><CODE>"two"</CODE></TD><TD>2</TD></TR>
<TR><TD><CODE>"three"</CODE></TD><TD>3</TD></TR></TABLE>

<P>Перечисление может иметь максимум 65535 элементов.</P>

<P>Регистр неважен, когда Вы назначаете значения столбцу <CODE>ENUM</CODE>.
Однако, значения, полученные из столбца позже имеют регистр с соответствием
значений, которые использовались, чтобы определить допустимые значения при
создании данной таблицы.</P>

<P>Если Вы получаете <CODE>ENUM</CODE> в числовом контексте, будет возвращен
индекс значения столбца. Например, Вы можете получать числовые значения из
столбца <CODE>ENUM</CODE> подобно этому:</P>
<PRE>
mysql&#62; SELECT enum_col+0 FROM tbl_name;
</PRE>

<P>Если Вы сохраняете число в <CODE>ENUM</CODE>, он обрабатывается как
индекс, и сохраненное значение представляет собой член перечисления с этим
индексом. Однако, это не будет работать с вызовом <CODE>LOAD DATA</CODE>,
который обрабатывает весь свой ввод как строки.</P>

<P>Значения <CODE>ENUM</CODE> сортируются согласно порядку, в котором члены
перечисления были указаны в спецификации столбца. Другими словами, значения
<CODE>ENUM</CODE> сортируются согласно их индексным числам. Например,
<CODE>"a"</CODE> окажется перед <CODE>"b"</CODE> для
<CODE>ENUM("a","b")</CODE>, но <CODE>"b"</CODE> опередит <CODE>"a"</CODE> для
<CODE>ENUM("b", "a")</CODE>. Пустые строки окажутся перед непустыми строками,
а значения <CODE>NULL</CODE> перед всеми другими значениями перечисления.</P>

<P>Если Вы хотите получать все возможные значения для столбца
<CODE>ENUM</CODE>, Вы должны использовать <CODE>SHOW COLUMNS FROM table_name
LIKE enum_column_name</CODE> и анализировать определение <CODE>ENUM</CODE> во
втором столбце вывода.</P>

<H4><A NAME="SET">5.3.4 Тип <CODE>SET</CODE></A></H4>
<P><CODE>SET</CODE> представляет собой строковый объект, который может иметь
ноль или большее количество значений, каждое из которых должно быть выбрано
из списка допустимых значений, которые перечислены явно в спецификации
столбца при создании таблицы. Значения столбца <CODE>SET</CODE>, которые
состоят из многих значений набора, определены членами, отделяемыми запятыми
(<SAMP>,</SAMP>). Следствие этого: значения членов <CODE>SET</CODE> не могут
самостоятельно содержать запятые.</P>

<P>Например, столбец, определенный как <CODE>SET("one","two") NOT
NULL</CODE>, может иметь любое из этих значений:</P>
<PRE>
""
"one"
"two"
"one,two"
</PRE>

<P><CODE>SET</CODE> может иметь максимум 64 различных членов.</P>

<P>MySQL сохраняет значения <CODE>SET</CODE> в цифровой форме, с битом
младшего разряда сохраненного значения, соответствующего первому члену
набора. Если Вы получаете значение <CODE>SET</CODE> в числовом контексте, оно
имеет набор битов, соответствующий членам набора, которые составляют значение
столбца. Например, Вы можете получить числовые значения из столбца
<CODE>SET</CODE> подобно этому:</P>
<PRE>
mysql&#62; SELECT set_col+0 FROM tbl_name;
</PRE>

<P>Если число сохранено в столбце <CODE>SET</CODE>, биты, которые установлены
в двоичном представлении числа, определяют члены набора в значении столбца.
Предположим, что столбец определен как <CODE>SET("a","b","c","d")</CODE>.
Члены имеют следующие разрядные значения:</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><CODE>SET</CODE> <STRONG>член множества</STRONG></TD><TD><STRONG>
Десятичное значение</STRONG></TD><TD><STRONG>Двоичное значение</STRONG></TD>
</TR>
<TR><TD><CODE>a</CODE></TD><TD><CODE>1</CODE></TD><TD><CODE>0001</CODE></TD>
</TR>
<TR><TD><CODE>b</CODE></TD><TD><CODE>2</CODE></TD><TD><CODE>0010</CODE></TD>
</TR>
<TR><TD><CODE>c</CODE></TD><TD><CODE>4</CODE></TD><TD><CODE>0100</CODE></TD>
</TR>
<TR><TD><CODE>d</CODE></TD><TD><CODE>8</CODE></TD><TD><CODE>1000</CODE></TD>
</TR></TABLE>

<P>Если Вы назначаете число <CODE>9</CODE> этому столбцу (в двоичной системе
это будет <CODE>1001</CODE>), то первый и четвертый члены значения
<CODE>SET</CODE> (то есть, <CODE>"a"</CODE> и <CODE>"d"</CODE>) будут
выбраны, и возникающим в результате значением будет <CODE>"a,d"</CODE>.</P>

<P>Для значения, содержащего больше, чем один элемент <CODE>SET</CODE>, не
имеет значения порядок элементов, в котором они перечислены, когда Вы
вставляете значение. Также не важно, сколько раз данный элемент перечислен в
значении. Когда значение потом будет получено из таблицы, каждый элемент в
нем появится лишь однажды, причем элементы будут перечислены согласно
порядку, в котором они были определены при создании таблицы. Например, если
столбец определен как <CODE>SET("a","b","c","d")</CODE>, то
<CODE>"a,d"</CODE>, <CODE>"d,a"</CODE> и <CODE>"d,a,a,d,d"</CODE> будут
появляться как <CODE>"a,d"</CODE> при получении данных из таблицы.</P>

<P>Значения <CODE>SET</CODE> сортируются в цифровой форме. <CODE>NULL</CODE>
расположится перед другими значениями.</P>

<P>Обычно, Вы выполняете <CODE>SELECT</CODE> на столбце <CODE>SET</CODE>,
применяя оператор <CODE>LIKE</CODE> или функцию <CODE>FIND_IN_SET()</CODE>:
</P>
<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE set_col LIKE '%value%';
mysql&#62; SELECT * FROM tbl_name WHERE FIND_IN_SET('value',set_col)&#62;0;
</PRE>

<P>Но следующее будет также работать:</P>
<PRE>
mysql&#62; SELECT * FROM tbl_name WHERE set_col = 'val1,val2';
mysql&#62; SELECT * FROM tbl_name WHERE set_col &#38; 1;
</PRE>

<P>Первая из этих инструкций ищет точное соответствие. Вторая ищет значения,
содержащие первый член набора.</P>

<P>Если Вы хотите получать все возможные значения для столбца
<CODE>SET</CODE>, Вы должны использовать: <CODE>SHOW COLUMNS FROM table_name
LIKE set_column_name</CODE> и анализировать второй столбец определения.</P>

<H3><A NAME="Choosing_types">5.4 Выбор правильного типа для столбца</A></H3>
<P>Для наиболее эффективного использования памяти, попробуйте использовать
наиболее подходящий тип во всех случаях. Например, если целочисленный столбец
будет использоваться для значений в диапазоне между <CODE>1</CODE> и
<CODE>99999</CODE>, лучшим является тип <CODE>MEDIUMINT UNSIGNED</CODE>.</P>

<P>Точное представление денежных величин обычно является проблемой. В MySQL
Вы должны использовать тип <CODE>DECIMAL</CODE>. Это сохранено как строка,
так что никакая потеря точности не должна произойти. Если точность не слишком
важна, тип <CODE>DOUBLE</CODE> также может быть достаточен.</P>

<P>Для высокой точности, Вы можете всегда преобразовывать данные в
фиксированный тип <CODE>BIGINT</CODE>. Это позволяет Вам делать все
вычисления с целыми числами и преобразовывать результаты обратно в значения с
плавающей запятой только тогда, когда это необходимо.</P>

<H3><A NAME="Other-vendor_column_types">5.5 Использование типов столбцов
из других СУБД</A></H3>
<P>Чтобы использовать код, написанный для реализаций SQL от других авторов,
MySQL отображает типы столбцов как показано в таблице ниже. Эти отображения
делают проще перенос определения таблиц:</P>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Чужой тип</STRONG></TD><TD><STRONG>Тип в MySQL</STRONG></TD>
</TR>
<TR><TD><CODE>BINARY(NUM)</CODE></TD><TD><CODE>CHAR(NUM) BINARY</CODE></TD>
</TR>
<TR><TD><CODE>CHAR VARYING(NUM)</CODE></TD><TD><CODE>VARCHAR(NUM)</CODE></TD>
</TR>
<TR><TD><CODE>FLOAT4</CODE></TD><TD><CODE>FLOAT</CODE></TD></TR>
<TR><TD><CODE>FLOAT8</CODE></TD><TD><CODE>DOUBLE</CODE></TD></TR>
<TR><TD><CODE>INT1</CODE></TD><TD><CODE>TINYINT</CODE></TD></TR>
<TR><TD><CODE>INT2</CODE></TD><TD><CODE>SMALLINT</CODE></TD></TR>
<TR><TD><CODE>INT3</CODE></TD><TD><CODE>MEDIUMINT</CODE></TD></TR>
<TR><TD><CODE>INT4</CODE></TD><TD><CODE>INT</CODE></TD></TR>
<TR><TD><CODE>INT8</CODE></TD><TD><CODE>BIGINT</CODE></TD></TR>
<TR><TD><CODE>LONG VARBINARY</CODE></TD><TD><CODE>MEDIUMBLOB</CODE></TD></TR>
<TR><TD><CODE>LONG VARCHAR</CODE></TD><TD><CODE>MEDIUMTEXT</CODE></TD></TR>
<TR><TD><CODE>MIDDLEINT</CODE></TD><TD><CODE>MEDIUMINT</CODE></TD></TR>
<TR><TD><CODE>VARBINARY(NUM)</CODE></TD><TD><CODE>VARCHAR(NUM) BINARY</CODE>
</TD></TR></TABLE>

<P>Отображение типа столбца происходит при создании таблицы. Если Вы создаете
таблицу с типами, используемыми другими авторами, а затем выдаете команду
<CODE>DESCRIBE tbl_name</CODE>, MySQL сообщает структуру таблицы,
использующую эквивалентные типы MySQL.</P>

<H3><A NAME="Storage_requirements">5.6 Требования столбцов к памяти</A></H3>
<P>Требования к памяти для каждого из типов столбцов, поддерживаемых MySQL,
перечислены ниже по категориям.</P>

<H4>5.2.6.1 Требования к памяти для чисел</H4>
<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Тип столбца</STRONG></TD><TD><STRONG>Для хранения надо
</STRONG></TD></TR>
<TR><TD><CODE>TINYINT</CODE></TD><TD>1 байт</TD></TR>
<TR><TD><CODE>SMALLINT</CODE></TD><TD>2 байта</TD></TR>
<TR><TD><CODE>MEDIUMINT</CODE></TD><TD>3 байта</TD></TR>
<TR><TD><CODE>INT</CODE></TD><TD>4 байта</TD></TR>
<TR><TD><CODE>INTEGER</CODE></TD><TD>4 байта</TD></TR>
<TR><TD><CODE>BIGINT</CODE></TD><TD>8 байта</TD></TR>
<TR><TD><CODE>FLOAT(X)</CODE></TD><TD>4, если X &#60;= 24, или 8, если 25
&#60;= X &#60;= 53</TD></TR>
<TR><TD><CODE>FLOAT</CODE></TD><TD>4 байта</TD></TR>
<TR><TD><CODE>DOUBLE</CODE></TD><TD>8 байта</TD></TR>
<TR><TD><CODE>DOUBLE PRECISION</CODE></TD><TD>8 байта</TD></TR>
<TR><TD><CODE>REAL</CODE></TD><TD>8 байта</TD></TR>
<TR><TD><CODE>DECIMAL(M,D)</CODE></TD><TD><CODE>M+2</CODE> байт, если D &#62;
0, <CODE>M+1</CODE> байт, если D=0 (<CODE>D</CODE>+2, если <CODE>M &#60; D
</CODE>)</TD></TR>
<TR><TD><CODE>NUMERIC(M,D)</CODE></TD><TD><CODE>M+2</CODE> байт, если D &#62;
0, <CODE>M+1</CODE> байт, если D=0 (<CODE>D</CODE>+2, если <CODE>M &#60; D
</CODE>)</TD></TR></TABLE>

<P><A NAME="IDX1071"></A><A NAME="IDX1072"></A><A NAME="IDX1073"></A>
<A NAME="IDX1074"></A></P><H4>5.2.6.2 Требования к памяти для даты и времени
</H4>

<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Тип столбца</STRONG></TD><TD><STRONG>Для хранения надо
</STRONG></TD></TR>
<TR><TD><CODE>DATE</CODE></TD><TD>3 байта</TD></TR>
<TR><TD><CODE>DATETIME</CODE></TD><TD>8 байта</TD></TR>
<TR><TD><CODE>TIMESTAMP</CODE></TD><TD>4 байта</TD></TR>
<TR><TD><CODE>TIME</CODE></TD><TD>3 байта</TD></TR>
<TR><TD><CODE>YEAR</CODE></TD><TD>1 байт</TD></TR></TABLE>

<H4>5.2.6.3 Требования к памяти для строк</H4>
<TABLE BORDER WIDTH="100%">
<TR><TD><STRONG>Тип столбца</STRONG></TD><TD><STRONG>Для хранения надо
</STRONG></TD></TR>
<TR><TD><CODE>CHAR(M)</CODE></TD><TD><CODE>M</CODE> байт, <CODE>1 &#60;= M
&#60;= 255</CODE></TD></TR>
<TR><TD><CODE>VARCHAR(M)</CODE></TD><TD><CODE>L</CODE>+1 байт, где
<CODE>L &#60;= M</CODE> и <CODE>1 &#60;= M &#60;= 255</CODE></TD></TR>
<TR><TD><CODE>TINYBLOB</CODE>, <CODE>TINYTEXT</CODE></TD><TD><CODE>L</CODE>+1
байт, где <CODE>L</CODE> &#60; 2^8</TD></TR>
<TR><TD><CODE>BLOB</CODE>, <CODE>TEXT</CODE></TD><TD><CODE>L</CODE>+2 байта,
где <CODE>L</CODE> &#60; 2^16</TD></TR>
<TR><TD><CODE>MEDIUMBLOB</CODE>, <CODE>MEDIUMTEXT</CODE></TD><TD>
<CODE>L</CODE>+3 байта, где <CODE>L</CODE> &#60; 2^24</TD></TR>
<TR><TD><CODE>LONGBLOB</CODE>, <CODE>LONGTEXT</CODE></TD><TD><CODE>L</CODE>+4
байта, где <CODE>L</CODE> &#60; 2^32</TD></TR>
<TR><TD><CODE>ENUM('value1','value2',...)</CODE></TD><TD>1 или 2 байта, в
зависимости от количества значений перечисления (максимум 65535 значений)
</TD></TR>
<TR><TD><CODE>SET('value1','value2',...)</CODE></TD><TD>1, 2, 3, 4 или 8
байт, в зависимости от числа членов набора (максимум 64 члена)</TD></TR>
</TABLE>

<P><A NAME="IDX1075"></A><A NAME="IDX1076"></A><A NAME="IDX1077"></A>Типы
<CODE>VARCHAR</CODE>, <CODE>BLOB</CODE> и <CODE>TEXT</CODE> представляют
собой типы переменной длины, для которых требования к памяти зависят от
фактической длины значения столбца (представлена как <CODE>L</CODE> в
предшествующей таблице). Например, столбец <CODE>VARCHAR(10)</CODE> может
хранить строку с максимальной длиной в 10 символов. Фактическая требуемая
память равна длине строки (<CODE>L</CODE>) плюс 1 байт, чтобы записать длину
строки. Для строки <CODE>abcd</CODE>, <CODE>L</CODE> равно 4, а требования к
памяти равны 5 байтам.</P>

<P>Типы <CODE>BLOB</CODE> и <CODE>TEXT</CODE> требуют 1, 2, 3 или 4 байта,
чтобы записать длину значения столбца, в зависимости от максимальной
возможной длины типа.</P>

<P>Если таблица включает любые столбцы переменной длины, формат записи будет
также переменной длины. Обратите внимание, что, когда таблица создана, MySQL
может, при некоторых условиях, изменять столбец с типа переменной длины на
тип фиксированной длины. Подробности в разделе
"<A HREF="glava07.htm#Silent_column_changes">7.3.1 Тихие изменения
спецификации столбца</A>".</P>

<P>Размер объекта <CODE>ENUM</CODE> определен числом различных значений
перечисления. Один байт используется для перечислений до 255 возможных
значений. Два байта используются для перечислений до 65535 значений.
Подробности в разделе "<A HREF="#ENUM">5.3.3 Тип <CODE>ENUM</CODE>
</A>".</P>

<P>Размер объекта <CODE>SET</CODE> определен числом различных членов набора.
Если размер набора равен <CODE>N</CODE>, то объект занимает
<CODE>(N+7)/8</CODE> байт, округленных до 1, 2, 3, 4 или 8 байт.
<CODE>SET</CODE> может иметь максимум до 64 членов. Подробности приведены в
разделе "<A HREF="#SET">5.3.4 Тип <CODE>SET</CODE></A>".</P>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</HTML>
