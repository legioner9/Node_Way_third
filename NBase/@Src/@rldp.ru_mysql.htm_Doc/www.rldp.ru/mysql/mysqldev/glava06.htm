<HTML>
<HEAD>
  <TITLE>MySQL DELPHI API</TITLE>
  <META NAME="Author" CONTENT="Alexey V. Pautov">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=koi8-r">
  <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
</HEAD>

<BODY>

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>

<H2><A NAME="Delphi">6 MySQL DELPHI API</A></H2>
<P>Пользователь имеет максимальный размер буфера связи. Размер буфера,
который распределен первоначально (16 килобайт), автоматически увеличивается
до максимального размера (максимум 16 мегабайт). Поскольку размеры буфера
растут только по запросу, просто увеличивая заданное по умолчанию
максимальное ограничение, Вы не заставите большее количество ресурсов
использоваться. Эта проверка размера обычно применяется в сложных ситуациях.
</P>

<P>Буфер связи должен быть достаточно большим, чтобы хранить одиночную
инструкцию SQL (для трафика "клиент-на сервер") и одну строку возвращенных
данных (для трафика "сервер-на-клиент"). Буфер связи каждого потока будет
динамически расширен до максимального ограничения, чтобы обработать любой
запрос или строку. Например, если Вы имеете значения <CODE>BLOB</CODE>,
которые содержат до 16M данных, Вы должны иметь ограничение буфера связи
по крайней мере в 16M (на клиенте и на сервере сразу). Заданный по умолчанию
максимум пользователя равен 16M, но заданный по умолчанию максимум сервера
равен всего 1M. Вы можете увеличивать это, меняя значение параметра
<CODE>max_allowed_packet</CODE> при запуске сервера.</P>

<P>Сервер MySQL сокращает каждый буфер связи до
<CODE>net_buffer_length</CODE> байт после каждого запроса. Для клиентуры
размер буфера, связанного с подключением, не будет уменьшен, пока подключение
не будет закрыто.</P>

<H3><A NAME="Delphi_API_datatypes">6.1 Типы данных в DELPHI API</A></H3>
<DL COMPACT>
<DT><CODE>TMYSQL</CODE>
<DD>Эта структура представляет дескриптор на одно подключение базы данных.
Это используется почти для всех функций MySQL.

<DT><CODE>TMYSQL_RES</CODE>
<DD>Эта структура представляет результат запроса, который возвращает строки
(<CODE>SELECT</CODE>, <CODE>SHOW</CODE>, <CODE>DESCRIBE</CODE>,
<CODE>EXPLAIN</CODE>). Информация, возвращенная из запроса, названа набором
результатов в остатках от этого раздела.

<DT><CODE>TMYSQL_ROW</CODE>
<DD>Это тип-безопасное представление одной строки данных. Это в настоящее
время выполнено как массив байтовых строк. Вы не можете обрабатывать их как
обычные строки с нулевым символом в конце, если значения поля могут содержать
двоичные данные потому, что такие значения могут содержать нулевые символы в
себе. Строки получены, вызывая функцию <CODE>mysql_fetch_row()</CODE>.

<DT><CODE>TMYSQL_FIELD</CODE>
<DD>Эта структура содержит информацию относительно поля, например, имя поля,
тип и размер. Члены описаны более подробно ниже. Вы можете получать структуры
<CODE>TMYSQL_FIELD</CODE> для каждого поля, неоднократно вызывая
<CODE>mysql_fetch_field()</CODE>. Значения полей не являются частью этой
структуры, они содержатся в структуре <CODE>TMYSQL_ROW</CODE>.

<DT><CODE>TMYSQL_FIELD_OFFSET</CODE>
<DD>Это тип-безопасное представление смещения в списке полей MySQL.
Используются в вызове <CODE>mysql_field_seek()</CODE>. Смещения представляют
собой номера полей внутри строки, начиная с нуля.

<DT><CODE>Tmy_ulonglong</CODE>
<DD>Тип, используемый для числа строк и для функций
<CODE>mysql_affected_rows()</CODE>, <CODE>mysql_num_rows()</CODE> и
<CODE>mysql_insert_id()</CODE>. Этот тип обеспечивает диапазон от
<CODE>0</CODE> до <CODE>1.84e19</CODE>.  На некоторых системах попытка
печатать значение типа <CODE>Tmy_ulonglong</CODE> не будет работать. Чтобы
отпечатать такое значение, преобразуйте его к типу <CODE>longint</CODE>.</DL>

<P>Структура <CODE>TMYSQL_FIELD</CODE> содержит члены, перечисленные ниже:
</P>
<DL COMPACT>
<DT><CODE>name:pchar;</CODE>
<DD>Имя поля, как строка с нулевым символом в конце.

<DT><CODE>table:pchar;</CODE>
<DD>Имя таблицы, содержащей это поле, если это не расчетное поле. Для
расчетных полей, значение <CODE>table</CODE> представлено пустой строкой.

<DT><CODE>def:pchar;</CODE>
<DD>Значение по умолчанию этого поля, как строка с нулевым символом в
конце. Это установлено только, если Вы используете
<CODE>mysql_list_fields()</CODE>.

<DT><CODE>typ:TFIELD_TYPES;</CODE>
<DD>Тип поля. Значение <CODE>typ</CODE> может быть один из следующего:

<TABLE><TR><TD><STRONG>Значение Typ</STRONG></TD><TD><STRONG>Используемый тип
</STRONG></TD></TR>
<TR><TD><CODE>FIELD_TYPE_TINY</CODE></TD><TD><CODE>TINYINT</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_SHORT</CODE></TD><TD><CODE>SMALLINT</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_LONG</CODE></TD><TD><CODE>INTEGER</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_INT24</CODE></TD><TD><CODE>MEDIUMINT</CODE></TD>
</TR>
<TR><TD><CODE>FIELD_TYPE_LONGLONG</CODE></TD><TD><CODE>BIGINT</CODE></TD>
</TR>
<TR><TD><CODE>FIELD_TYPE_DECIMAL</CODE></TD><TD><CODE>DECIMAL</CODE> или
<CODE>NUMERIC</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_FLOAT</CODE></TD><TD><CODE>FLOAT</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_DOUBLE</CODE></TD><TD><CODE>DOUBLE</CODE> или
<CODE>REAL</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_TIMESTAMP</CODE></TD><TD><CODE>TIMESTAMP</CODE></TD>
</TR>
<TR><TD><CODE>FIELD_TYPE_DATE</CODE></TD><TD><CODE>DATE</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_TIME</CODE></TD><TD><CODE>TIME</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_DATETIME</CODE></TD><TD><CODE>DATETIME</CODE></TD>
</TR>
<TR><TD><CODE>FIELD_TYPE_YEAR</CODE></TD><TD><CODE>YEAR</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_STRING</CODE></TD><TD>Строка (<CODE>CHAR</CODE> или
<CODE>VARCHAR</CODE>)</TD></TR>
<TR><TD><CODE>FIELD_TYPE_BLOB</CODE></TD><TD><CODE>BLOB</CODE> или
<CODE>TEXT</CODE> (используйте <CODE>max_length</CODE>, чтобы определить
максимальную длину поля)</TD></TR>
<TR><TD><CODE>FIELD_TYPE_SET</CODE></TD><TD><CODE>SET</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_ENUM</CODE></TD><TD><CODE>ENUM</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_NULL</CODE></TD><TD><CODE>NULL</CODE></TD></TR>
<TR><TD><CODE>FIELD_TYPE_CHAR</CODE></TD><TD>Не рекомендуется: используйте
<CODE>FIELD_TYPE_TINY</CODE></TD></TR></TABLE>

<DT><CODE>length:longword;</CODE>
<DD>Ширина поля, как она определена в описании таблицы.

<DT><CODE>max_length:longword;</CODE>
<DD>Максимальная ширина поля для набора результатов (длина самого длинного
поля для строк в наборе результатов). Если Вы используете
<CODE>mysql_store_result()</CODE> или <CODE>mysql_list_fields()</CODE>, это
содержит максимальную длину поля. Если Вы используете
<CODE>mysql_use_result()</CODE>, значение этой переменной нулевое.

<DT><CODE>flags:longword;</CODE>
<DD>Различные биты задают флажки для поля. Значение <CODE>flags</CODE>
может иметь ноль или большее количество из следующего набора битов:

<TABLE><TR><TD><STRONG>Значение Flags</STRONG></TD><TD><STRONG>Что это значит
</STRONG></TD></TR>
<TR><TD><CODE>NOT_NULL_FLAG</CODE></TD><TD>Поле не может быть
<CODE>NULL</CODE></TD></TR>
<TR><TD><CODE>PRI_KEY_FLAG</CODE></TD><TD>Поле часть первичного ключа</TD></TR>
<TR><TD><CODE>UNIQUE_KEY_FLAG</CODE></TD><TD>Поле часть уникального ключа
</TD></TR>
<TR><TD><CODE>MULTIPLE_KEY_FLAG</CODE></TD><TD>Поле часть неуникального ключа
</TD></TR>
<TR><TD><CODE>UNSIGNED_FLAG</CODE></TD><TD>Поле имеет атрибут
<CODE>UNSIGNED</CODE></TD></TR>
<TR><TD><CODE>ZEROFILL_FLAG</CODE></TD><TD>Поле имеет атрибут
<CODE>ZEROFILL</CODE></TD></TR>
<TR><TD><CODE>BINARY_FLAG</CODE></TD><TD>Поле имеет атрибут
<CODE>BINARY</CODE></TD></TR>
<TR><TD><CODE>AUTO_INCREMENT_FLAG</CODE></TD><TD>Поле имеет атрибут
<CODE>AUTO_INCREMENT</CODE></TD></TR>
<TR><TD><CODE>ENUM_FLAG</CODE></TD><TD>Поле имеет тип <CODE>ENUM</CODE></TD>
</TR>
<TR><TD><CODE>BLOB_FLAG</CODE></TD><TD>Поле имеет тип <CODE>BLOB</CODE> или
<CODE>TEXT</CODE></TD></TR>
<TR><TD><CODE>TIMESTAMP_FLAG</CODE></TD><TD>Поле имеет тип
<CODE>TIMESTAMP</CODE></TD></TR></TABLE>

Использование <CODE>BLOB_FLAG</CODE>, <CODE>ENUM_FLAG</CODE> и
<CODE>TIMESTAMP_FLAG</CODE> не рекомендуется потому, что они указывают тип
поля, а не атрибут типа. Предпочтительно проверить
<CODE>field.typ</CODE> вместо <CODE>FIELD_TYPE_BLOB</CODE>,
<CODE>FIELD_TYPE_ENUM</CODE> или <CODE>FIELD_TYPE_TIMESTAMP</CODE>. Пример
ниже иллюстрирует типичное использование <CODE>flags</CODE>:
<PRE>
if (field.flags &#38; NOT_NULL_FLAG) write("Field can't be null");
</PRE>

Вы можете использовать следующие макрокоманды, чтобы определить булево
состояние значения <CODE>flags</CODE>:
<TABLE BORDER WIDTH="100%">
<TR><TD><CODE>IS_NOT_NULL(flags)</CODE></TD><TD>Истина, если это поле
определено как <CODE>NOT NULL</CODE></TD></TR>
<TR><TD><CODE>IS_PRI_KEY(flags)</CODE></TD><TD>Истина, если это поле
первичный ключ</TD></TR>
<TR><TD><CODE>IS_BLOB(flags)</CODE></TD><TD>Истина, если это поле
<CODE>BLOB</CODE> или <CODE>TEXT</CODE></TD></TR></TABLE>

<DT><CODE>decimals:longword;</CODE>
<DD>Число допустимых десятичных чисел для числовых полей.</DL>

<H3><A NAME="Delphi_API_function_overview">6.2 Обзор функций Delphi API</A>
</H3>
<P>Функции, доступные в Delphi API, перечислены ниже и описаны более подробно
в следующем разделе. Подробности в разделе "Описание функций Delphi API".</P>

<TABLE><TR><TD><STRONG>mysql_affected_rows()</STRONG></TD><TD>
Возвращает число строк измененных последним запросом <CODE>UPDATE</CODE>,
<CODE>DELETE</CODE> или <CODE>INSERT</CODE>.</TD></TR>

<TR><TD><STRONG>mysql_close()</STRONG></TD><TD>
Закрывает подключение к серверу.</TD></TR>

<TR><TD><STRONG>mysql_connect()</STRONG></TD><TD>Соединяется с сервером.</TD>
</TR>

<TR><TD><STRONG>mysql_change_user()</STRONG></TD><TD>Меняет пользователя и
базу данных на открытом подключении.</TD></TR>

<TR><TD><STRONG>mysql_create_db()</STRONG></TD><TD>Создает базу данных.
Аналог команды SQL <CODE>CREATE DATABASE</CODE>.</TD></TR>

<TR><TD><STRONG>mysql_data_seek()</STRONG></TD><TD>Ищет произвольную строку в
наборе результатов запросов.</TD></TR>

<TR><TD><STRONG>mysql_debug()</STRONG></TD><TD>Делает <CODE>DBUG_PUSH</CODE>
для заданной строки.</TD></TR>

<TR><TD><STRONG>mysql_drop_db()</STRONG></TD><TD>Удаляет базу данных. Эта
функция аналогична команде SQL <CODE>DROP DATABASE</CODE>.</TD></TR>

<TR><TD><STRONG>mysql_dump_debug_info()</STRONG></TD><TD>Заставляет сервер
писать информацию отладки в файл регистрации.</TD></TR>

<TR><TD><STRONG>mysql_eof()</STRONG></TD><TD>Определяет, читалась или нет
последняя строка набора результатов.</TD></TR>

<TR><TD><STRONG>mysql_errno()</STRONG></TD><TD>Возвращает код ошибки для
вызванной недавно функции MySQL.</TD></TR>

<TR><TD><STRONG>mysql_error()</STRONG></TD><TD>Возвращает текстовое сообщение
об ошибке для вызванной недавно функции MySQL.</TD></TR>

<TR><TD><STRONG>mysql_real_escape_string()</STRONG></TD><TD>Выходит из
специальных символов в строке для использования в инструкции SQL, принимающей
во внимание текущий набор символов данного подключения.</TD></TR>

<TR><TD><STRONG>mysql_escape_string()</STRONG></TD><TD>Выходит из специальных
символов в строке для использования в обычной инструкции SQL.</TD></TR>

<TR><TD><STRONG>mysql_fetch_field()</STRONG></TD><TD>Возвращает тип
следующего поля таблицы.</TD></TR>

<TR><TD><STRONG>mysql_fetch_field_direct()</STRONG></TD><TD>Возвращает тип
поля таблицы, по номеру поля.</TD></TR>

<TR><TD><STRONG>mysql_fetch_fields()</STRONG></TD><TD>Возвращает массив
всех структур поля.</TD></TR>

<TR><TD><STRONG>mysql_fetch_lengths()</STRONG></TD><TD>Возвращает длины всех
столбцов в текущей (актуальной) строке.</TD></TR>

<TR><TD><STRONG>mysql_fetch_row()</STRONG></TD><TD>Выбирает следующую строку
из набора результатов.</TD></TR>

<TR><TD><STRONG>mysql_field_seek()</STRONG></TD><TD>Помещает курсор столбца в
определенный параметром столбец.</TD></TR>

<TR><TD><STRONG>mysql_field_count()</STRONG></TD><TD>Возвращает число
столбцов результата для последнего запроса.</TD></TR>

<TR><TD><STRONG>mysql_field_tell()</STRONG></TD><TD>Возвращает позицию
курсора поля, используемого для последнего вызова
<CODE>mysql_fetch_field()</CODE>.</TD></TR>

<TR><TD><STRONG>mysql_free_result()</STRONG></TD><TD>Освобождает память,
используемую набором результатов.</TD></TR>

<TR><TD><STRONG>mysql_get_client_info()</STRONG></TD><TD>Возвращает
информацию о версии программы-клиента.</TD></TR>

<TR><TD><STRONG>mysql_get_host_info()</STRONG></TD><TD>Возвращает строку,
описывающую подключение.</TD></TR>

<TR><TD><STRONG>mysql_get_proto_info()</STRONG></TD><TD>Возвращает версию
протокола, используемую подключением.</TD></TR>

<TR><TD><STRONG>mysql_get_server_info()</STRONG></TD><TD>Возвращает номер
версии сервера.</TD></TR>

<TR><TD><STRONG>mysql_info()</STRONG></TD><TD>Возвращает информацию
относительно недавно выполненного запроса.</TD></TR>

<TR><TD><STRONG>mysql_init()</STRONG></TD><TD>Получает или инициализирует
структуру <CODE>MYSQL</CODE>.</TD></TR>

<TR><TD><STRONG>mysql_insert_id()</STRONG></TD><TD>Возвращает ID,
сгенерированный для столбца с поддержкой <CODE>AUTO_INCREMENT</CODE>
предыдущим запросом.</TD></TR>

<TR><TD><STRONG>mysql_kill()</STRONG></TD><TD>Уничтожает заданный поток.
</TD></TR>

<TR><TD><STRONG>mysql_list_dbs()</STRONG></TD><TD>Возвращает имена баз
данных, соответствующие простому регулярному выражению.</TD></TR>

<TR><TD><STRONG>mysql_list_fields()</STRONG></TD><TD>Возвращает имена полей,
соответствующие простому регулярному выражению.</TD></TR>

<TR><TD><STRONG>mysql_list_processes()</STRONG></TD><TD>Возвращает список
текущих потоков сервера.</TD></TR>

<TR><TD><STRONG>mysql_list_tables()</STRONG></TD><TD>Возвращает имена таблиц,
соответствующие простому регулярному выражению.</TD></TR>

<TR><TD><STRONG>mysql_num_fields()</STRONG></TD><TD>Возвращает число столбцов
в наборе результатов.</TD></TR>

<TR><TD><STRONG>mysql_num_rows()</STRONG></TD><TD>Возвращает число строк в
наборе результатов.</TD></TR>

<TR><TD><STRONG>mysql_options()</STRONG></TD><TD>Устанавливает опции связи
для вызова <CODE>mysql_connect()</CODE>.</TD></TR>

<TR><TD><STRONG>mysql_ping()</STRONG></TD><TD>Проверяет работает или нет
подключение с сервером, повторно соединяется по мере необходимости.</TD></TR>

<TR><TD><STRONG>mysql_query()</STRONG></TD><TD>Выполняет запрос SQL,
определенный как строка с нулевым символом в конце.</TD></TR>

<TR><TD><STRONG>mysql_real_connect()</STRONG></TD><TD>Соединяется с сервером.
</TD></TR>

<TR><TD><STRONG>mysql_real_query()</STRONG></TD><TD>Выполняет запрос SQL,
определенный как рассчитанная строка.</TD></TR>

<TR><TD><STRONG>mysql_reload()</STRONG></TD><TD>Сообщает, чтобы сервер
перезагрузил таблицы предоставления привилегий.</TD></TR>

<TR><TD><STRONG>mysql_row_seek()</STRONG></TD><TD>Переходит к строке в наборе
результатов, используя значение, возвращенное из
<CODE>mysql_row_tell()</CODE>.</TD></TR>

<TR><TD><STRONG>mysql_row_tell()</STRONG></TD><TD>Возвращает позицию
курсора строки.</TD></TR>

<TR><TD><STRONG>mysql_select_db()</STRONG></TD><TD>Выбирает базу данных.</TD>
</TR>

<TR><TD><STRONG>mysql_shutdown()</STRONG></TD><TD>Закрывает сервер.</TD></TR>
<TR><TD><STRONG>mysql_stat()</STRONG></TD><TD>Возвращает состояние сервера.
</TD></TR>

<TR><TD><STRONG>mysql_store_result()</STRONG></TD><TD>Возвращает полный набор
результатов пользователю.</TD></TR>

<TR><TD><STRONG>mysql_thread_id()</STRONG></TD><TD>Возвращает ID потока.</TD>
</TR>

<TR><TD><STRONG>mysql_thread_safe()</STRONG></TD><TD>Возвращает 1, если
клиент компилируется как поточно-безопасный.</TD></TR>

<TR><TD><STRONG>mysql_use_result()</STRONG></TD><TD>Инициализирует копию
результата строка в строку.</TD></TR></TABLE>

<P>Чтобы соединиться с сервером, вызовите <CODE>mysql_init()</CODE>, чтобы
инициализировать драйвер подключения, затем вызовите
<CODE>mysql_real_connect()</CODE> с этим драйвером (наряду с другой
информацией типа hostname, имени пользователя и пароля). При подключении
<CODE>mysql_real_connect()</CODE> устанавливает флажок <CODE>reconnect</CODE>
(часть структуры MYSQL) в значение <CODE>1</CODE>. Этот флажок указывает, что
когда запрос не может выполняться из-за потерянного подключения, надо
попробовать повторно соединиться с сервером перед отказом. Когда Вы закончите
работу с подключением, вызовите <CODE>mysql_close()</CODE> для его закрытия.
</P>

<P>В то время как подключение активно, пользователь может посылать запросы
SQL серверу, применяя функции <CODE>mysql_query()</CODE> или
<CODE>mysql_real_query()</CODE>. Различие между ними в том, что
<CODE>mysql_query()</CODE> ожидает, что запрос будет определен как строка с
нулевым символом в конце, в то время как <CODE>mysql_real_query()</CODE>
ожидает рассчитанную строку. Если несет в себе двоичные данные (которые сами
по себе могут включать нулевые байты), Вы должны использовать только
<CODE>mysql_real_query()</CODE>.</P>

<P>Для каждого запроса не-<CODE>SELECT</CODE> (например, <CODE>INSERT</CODE>,
<CODE>UPDATE</CODE>, <CODE>DELETE</CODE>), Вы можете выяснить, сколько строк
были изменены, вызывая <CODE>mysql_affected_rows()</CODE>.</P>

<P>Для запросов <CODE>SELECT</CODE> Вы получаете выбранные строки в наборе
результатов. Обратите внимание, что некоторые инструкции подобны
<CODE>SELECT</CODE> в том плане, что они возвращают строки. Сюда входят
<CODE>SHOW</CODE>, <CODE>DESCRIBE</CODE> и <CODE>EXPLAIN</CODE>. Они должны
обработаться тем же самым методом, что и обычный <CODE>SELECT</CODE>.</P>

<P>Имеются два пути для пользователя, чтобы обработать наборы результатов.
Один путь состоит в том, чтобы получить весь набор результатов, вызывая
<CODE>mysql_store_result()</CODE>. Эта функция получает с сервера все строки,
возвращенные запросом и сохраняет их на клиенте. Второй путь инициализировать
построчный набор результатов, вызывая <CODE>mysql_use_result()</CODE>. Эта
функция инициализирует поиск, но фактически не получает никаких строк.</P>

<P>В обоих случаях Вы обращаетесь к строкам, вызывая
<CODE>mysql_fetch_row()</CODE>. В случае <CODE>mysql_store_result()</CODE>
<CODE>mysql_fetch_row()</CODE> обращается к строкам, которые уже были выбраны
из сервера. В случае же <CODE>mysql_use_result()</CODE>
<CODE>mysql_fetch_row()</CODE> фактически получает строку с сервера
самостоятельно. Информация относительно размера данных в каждой строке
доступна через вызов <CODE>mysql_fetch_lengths()</CODE>.</P>

<P>После того, как Вы закончите работу с набором результатов, вызовите
<CODE>mysql_free_result()</CODE>, чтобы освободить используемую память.</P>

<P>Два механизма поиска дополняют друг друга. Программы пользователя должны
выбрать подход, который является наиболее подходящим для их требований.
Практически же, клиентура имеет тенденцию обычно использовать
<CODE>mysql_store_result()</CODE>.</P>

<P>Преимущество <CODE>mysql_store_result()</CODE> в том, что, поскольку все
строки были переданы пользователю, Вы не только можете обращаться к строкам
последовательно, Вы можете также двигаться обратно в наборе результатов,
используя <CODE>mysql_data_seek()</CODE> или <CODE>mysql_row_seek()</CODE>,
чтобы изменить текущую (актуальную) позицию строки внутри набора результатов.
Вы можете также выяснять, сколько там строк, вызывая
<CODE>mysql_num_rows()</CODE>. С другой стороны, требования к памяти для
<CODE>mysql_store_result()</CODE> могут быть очень высоки для больших наборов
результатов, и Вы, вероятно, столкнетесь с проблемами нехватки памяти.</P>

<P>Преимущество <CODE>mysql_use_result()</CODE> в том, что пользователь
требует меньшего количества памяти для набора результатов потому, что это
поддерживает только одну строку одновременно (и потому, что имеется меньшее
количество дополнительных распределений для заголовков, так что
<CODE>mysql_use_result()</CODE> может быть быстрее). Недостаток: Вы должны
обработать каждую строку быстро, чтобы не держать занятым сервер. Вы не
имеете произвольного доступа к строкам внутри набора результатов (Вы можете
только обращаться к строкам последовательно), и Вы не знаете, сколько строк
находится в наборе результатов, пока Вы не получите их все. Кроме того, Вы
должны принять все строки, даже если Вы определяете в середине поиска, что
уже нашли ту информацию, которую Вы искали.</P>

<P>API позволяет клиентам ответить соответственно на запросы (получая строки
только по мере необходимости) без того, чтобы знать, является или нет запрос
<CODE>SELECT</CODE>. Вы можете делать это, вызывая
<CODE>mysql_store_result()</CODE> после каждого <CODE>mysql_query()</CODE>
(или <CODE>mysql_real_query()</CODE>). Если обращение к набору результатов
прошло успешно, запросом был <CODE>SELECT</CODE>, и Вы можете читать строки.
Если произошел сбой, вызовите <CODE>mysql_field_count()</CODE>, чтобы
определить, должен или нет фактически ожидаться результат. Если
<CODE>mysql_field_count()</CODE> возвращает ноль, запрос не возвратил никаких
данных (это показывает, что это был <CODE>INSERT</CODE>, <CODE>UPDATE</CODE>,
<CODE>DELETE</CODE> или что-то в этом роде) и не возвратит строки. Если
<CODE>mysql_field_count()</CODE> отличен от нуля, запрос должен был
возвратить строки, но не сделал этого. Это указывает, что запросом был
<CODE>SELECT</CODE>, который потерпел неудачу.</P>

<P>Вызовы <CODE>mysql_store_result()</CODE> и <CODE>mysql_use_result()</CODE>
позволяют Вам получать информацию относительно полей, которые составляют
набор результатов (число полей, их имена, типы и т.п.). Вы можете обращаться
к информации поля последовательно внутри строки, вызывая
<CODE>mysql_fetch_field()</CODE> неоднократно, или по номеру поля внутри
строки, вызывая <CODE>mysql_fetch_field_direct()</CODE> напрямую. Текущая
(актуальная) позиция курсора поля может быть изменена вызовом
<CODE>mysql_field_seek()</CODE>. Установка курсора поля воздействует на
последующие обращения к <CODE>mysql_fetch_field()</CODE>. Вы можете также
получать информацию для полей в любой момент, вызывая
<CODE>mysql_fetch_fields()</CODE>.</P>

<P>Для обнаружения и сообщения об ошибках MySQL обеспечивает доступ к
информации ошибки посредством функций <CODE>mysql_errno()</CODE> и
<CODE>mysql_error()</CODE>. Они возвращают код ошибки или сообщение об ошибке
для последней вызванной функции, позволяя Вам определить, когда ошибка
произошла, и что это было.</P>

<H3><A NAME="Delphi_API_functions">6.3 Описание функций API</A></H3>
<P>В описаниях ниже параметр или значение возврата <CODE>NULL</CODE> означает
<CODE>NULL</CODE> в смысле языка программирования C, а не MySQL-значение
<CODE>NULL</CODE>.</P>

<P>Функции, которые возвращают значение, возвращают указатель или целое
число. Если не определено иное, функции, возвращающие указатель, возвращают
значение не-<CODE>NULL</CODE>, чтобы указать успех, или значение
<CODE>NULL</CODE>, чтобы указать ошибку, а функции, возвращающие число,
возвращают целочисленный ноль, чтобы указать успех, или отличное от нуля
значение, чтобы указать ошибку. Обратите внимание, что "отличное от нуля"
означает только это. Если функциональное описание не говорит иного, не надо
проверять результат на соответствие каким-либо числам, кроме нуля.</P>
<PRE>
if (result)                  /* правильно */
    ... error ...

if (result &#60; 0)          /* неправильно */
    ... error ...

if (result = -1)             /* неправильно */
    ... error ...
</PRE>

<P>Когда функция возвращает ошибку, подраздел <STRONG>Ошибки</STRONG>
описания функции вносит в список возможные типы ошибок. Вы можете выяснить,
который из них произошел, вызывая <CODE>mysql_errno()</CODE>. Представление
строки ошибки может быть получено, вызывая <CODE>mysql_error()</CODE>.</P>

<H4><A NAME="mysql_affected_rows">6.3.1 <CODE>mysql_affected_rows()</CODE>
</A></H4>
<P><CODE>tmy_ulonglong mysql_affected_rows(mysql:PMYSQL):TMY_ULONGLONG;
stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает число строк, измененных последним <CODE>UPDATE</CODE>,
удаленных последним <CODE>DELETE</CODE> или вставленных последней инструкцией
<CODE>INSERT</CODE>. Может быть вызвана немедленно после
<CODE>mysql_query()</CODE> для <CODE>UPDATE</CODE>, <CODE>DELETE</CODE> или
<CODE>INSERT</CODE>. Для инструкции <CODE>SELECT</CODE>
<CODE>mysql_affected_rows()</CODE> работает подобно
<CODE>mysql_num_rows()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Целое число, большее, чем ноль, указывает количество обработанных строк.
Ноль указывает, что никакие записи обработаны не были. -1 указывает, что
запрос возвратил ошибку или то, что для запроса <CODE>SELECT</CODE>
<CODE>mysql_affected_rows()</CODE> был вызван до вызова
<CODE>mysql_store_result()</CODE>.</P>

<P>Если определен флажок <CODE>CLIENT_FOUND_ROWS</CODE>, при соединение с
<CODE>mysqld</CODE> <CODE>mysql_affected_rows()</CODE> возвратит число строк,
согласованных инструкцией <CODE>WHERE</CODE> для <CODE>UPDATE</CODE>.</P>

<P>Обратите внимание, что, когда использована команда <CODE>REPLACE</CODE>,
<CODE>mysql_affected_rows()</CODE> вернет 2 потому, что в этом случае одна
строка была вставлена, а затем дубликат был удален.</P>

<H4><A NAME="mysql_close">6.3.2 <CODE>mysql_close()</CODE></A></H4>
<P><CODE>mysql_close(sock:PMYSQL);stdcall;</CODE></P>

<H4>Описание</H4>
<P>Закрывает предварительно открытое подключение. <CODE>mysql_close()</CODE>
также освободит дескриптор подключения, указанный в <CODE>mysql</CODE>, если
дескриптор был распределен автоматически <CODE>mysql_init()</CODE> или
<CODE>mysql_connect()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Нет.</P>

<H4><A NAME="mysql_connect">6.3.3 <CODE>mysql_connect()</CODE></A></H4>
<P><CODE>mysql_connect(mysql: PMYSQL; const host,user,passwd:pchar):PMYSQL;
stdcall;</CODE></P>

<H4>Описание</H4>
<P>Пытается устанавливать подключение с сервером MySQL на компьютере
<CODE>host</CODE>. <CODE>mysql_connect()</CODE> должна завершиться успешно
прежде, чем Вы сможете выполнить любую из функций API, за исключением
<CODE>mysql_get_client_info()</CODE>.</P>

<P>Значения параметров такие же, как для соответствующих параметров
<CODE>mysql_real_connect()</CODE> с тем различием, что параметр подключения
может быть <CODE>NULL</CODE>. В этом случае API распределяет память для
структуры подключения автоматически и освобождает ее, когда Вы вызываете
<CODE>mysql_close()</CODE>. Недостаток этого подхода в том, что Вы не можете
получить сообщение об ошибке, если подключение терпит неудачу. Чтобы получать
информацию об ошибке из <CODE>mysql_errno()</CODE> или
<CODE>mysql_error()</CODE>, Вы должны обеспечить имеющий силу указатель
на структуру <CODE>MYSQL</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Аналогично <CODE>mysql_real_connect()</CODE>.</P>

<H4>Ошибки</H4>
<P>Аналогично <CODE>mysql_real_connect()</CODE>.</P>

<H4><A NAME="mysql_change_user">6.3.4 <CODE>mysql_change_user()</CODE></A>
</H4>
<P><CODE>mysql_change_user(mysql: PMYSQL; const user,passwd,
db:pchar):TMY_BOOL;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Меняет пользователя и заставляет базу данных, определенную как
<CODE>db</CODE>, стать заданной по умолчанию (текущей) базой данных на
подключении, определенном <CODE>mysql</CODE>. В последующих запросах эта база
данных будет значением по умолчанию для ссылок на таблицы, которые не
включают явный спецификатор базы данных.</P>

<P>Эта функция впервые была представлена в MySQL Version 3.23.3.</P>

<P><CODE>mysql_change_user()</CODE> терпит неудачу, если указанный
пользователь не может быть использован, или если он не имеет разрешения
использовать эту базу данных. В этом случае пользователь и база данных не
будут изменены вообще.</P>

<P>Параметр <CODE>db</CODE> может быть установлен в <CODE>NULL</CODE>, если
Вы не хотите иметь заданную по умолчанию базу данных.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль для успеха. Отличное от нуля, если произошла ошибка.</P>

<H4>Ошибки</H4>
<P>Аналогично <CODE>mysql_real_connect()</CODE>.</P>

<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.
<DT><CODE>ER_UNKNOWN_COM_ERROR</CODE>
<DD>Сервер MySQL не выполняет эту команду (вероятно, старая версия).
<DT><CODE>ER_ACCESS_DENIED_ERROR</CODE>
<DD>Пользователь или пароль ошибочен.
<DT><CODE>ER_BAD_DB_ERROR</CODE>
<DD>База данных не существует.
<DT><CODE>ER_DBACCESS_DENIED_ERROR</CODE>
<DD>Пользователь не имеет прав доступа к базе данных.
<DT><CODE>ER_WRONG_DB_NAME</CODE>
<DD>Имя базы данных слишком длинное.</DL>

<H4><A NAME="mysql_create_db">6.3.5 <CODE>mysql_create_db()</CODE></A></H4>
<P><CODE>mysql_create_db(mysql:PMYSQL; const db:pchar):integer;stdcall;</CODE>
</P>

<H4>Описание</H4>
<P>Создает базу данных с именем <CODE>db</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль, если база данных была создана успешно. Отличное от нуля, если в
процессе произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_data_seek">6.3.6 <CODE>mysql_data_seek()</CODE></A></H4>
<P><CODE>mysql_data_seek(res:PMYSQL_RES;offset:TMY_ULONGLONG); stdcall;
</CODE></P>

<H4>Описание</H4>
<P>Переходит к произвольной строке в наборе результатов запроса. Это требует,
чтобы структура набора результата содержала весь результат запроса, так что
<CODE>mysql_data_seek()</CODE> может использоваться только в конъюнкции с
<CODE>mysql_store_result()</CODE>, но никак не с
<CODE>mysql_use_result()</CODE>.</P>

<P>Смещение должно быть значением в диапазоне от 0 до
<CODE>mysql_num_rows(result)-1</CODE>.</P>

<H4><A NAME="mysql_debug">6.3.7 <CODE>mysql_debug()</CODE></A></H4>
<P><CODE>mysql_debug(const debug:pchar);stdcall;</CODE></P>

<H4>Описание</H4>
<P>Делает <CODE>DBUG_PUSH</CODE> с заданной строкой. Вызов
<CODE>mysql_debug()</CODE> использует библиотеку отладки Fred Fish. Чтобы
использовать эту функцию, Вы должны компилировать библиотеку клиентов так,
чтобы поддерживать отладку.</P>

<H4>Пример</H4>
<P>Обращение, показанное ниже, заставляет библиотеку клиентов генерировать
файл трассировки <TT>/tmp/client.trace</TT> на машине пользователя:</P>
<PRE>
mysql_debug("d:t:O,/tmp/client.trace");
</PRE>

<H4><A NAME="mysql_drop_db">6.3.8 <CODE>mysql_drop_db()</CODE></A></H4>
<P><CODE>mysql_drop_db(mysql:PMYSQL; const db:pchar):integer;stdcall;</CODE>
</P>

<H4>Описание</H4>
<P>Удвляет базу данных, упомянутую как параметр <CODE>db</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль, если база данных была удалена успешно. Отличное от нуля, если в
процессе произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_dump_debug_info">6.3.9 <CODE>mysql_dump_debug_info()
</CODE></A></H4>
<P><CODE>mysql_dump_debug_info(mysql:PMYSQL):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Инструктирует сервер, чтобы писать некоторую информацию отладки в файл
регистрации. Отдавший команду пользователь должен иметь привилегию
<STRONG>process</STRONG>, чтобы работать.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль, если команда была успешно выполнена. Отличное от нуля, если в
процессе произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_eof">6.3.10 <CODE>mysql_eof()</CODE></A></H4>
<P><CODE>mysql_eof(res:PMYSQL_RES):TMY_BOOL;stdcall;</CODE></P>

<H4>Описание</H4>
<P><CODE>mysql_eof()</CODE> определяет, читалась или нет последняя
строка набора результатов.</P>

<P>Если Вы приобретаете результат из успешного обращения к
<CODE>mysql_store_result()</CODE>, клиент получает весь набор в одной
операции. В этом случае возврат <CODE>NULL</CODE> из
<CODE>mysql_fetch_row()</CODE> всегда означает, что конец набора результатов
был достигнут и не нужно вызвать <CODE>mysql_eof()</CODE>.</P>

<P>С другой стороны, если Вы используете <CODE>mysql_use_result()</CODE>,
чтобы инициализировать поиск набора результата, строки набора получены с
сервера по одной, поскольку Вы вызываете <CODE>mysql_fetch_row()</CODE>
неоднократно. Потому что ошибка может происходить на подключении в течение
этого процесса, значение <CODE>NULL</CODE> из функции
<CODE>mysql_fetch_row()</CODE> не обязательно означает, что конец набора
результатов был достигнут. В этом случае, Вы можете использовать
<CODE>mysql_eof()</CODE>, чтобы определить, что там случилось. Функция
<CODE>mysql_eof()</CODE> возвращает значение, отличное от нуля, если конец
набора результатов был достигнут и ноль, если произошла ошибка.</P>

<P>Исторически <CODE>mysql_eof()</CODE> предшествует стандартной функции
MySQL <CODE>mysql_errno()</CODE> и <CODE>mysql_error()</CODE>. Так как те
функции ошибки обеспечивают ту же самую информацию, их использование
предпочтительнее <CODE>mysql_eof()</CODE>. Фактически, они обеспечивают
большее количество информации потому, что <CODE>mysql_eof()</CODE> возвращает
только булево значение, в то время как функции ошибки указывают причину.</P>

<H4>Возвращаемые значения</H4>
<P>Функция <CODE>mysql_eof()</CODE> возвращает значение, отличное от нуля,
если конец набора результатов был достигнут и ноль, если произошла ошибка.
</P>

<H4><A NAME="mysql_errno">6.3.11 <CODE>mysql_errno()</CODE></A></H4>
<P><CODE>mysql_errno(mysql:PMYSQL):longword;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Для подключения, определенного в <CODE>mysql</CODE>,
<CODE>mysql_errno()</CODE> возвращает код ошибки для вызванной функции
API, которая может сработать нормально или потерпеть неудачу. Значение
возврата 0 означает, что никакой ошибки не произошло. Числа сообщений об
ошибках клиента перечислены в файле заголовка MySQL <TT>errmsg.h</TT>.
Серверные ошибки перечислены в <TT>mysqld_error.h</TT>. В дистрибутиве
исходного кода MySQL Вы можете найти полный список сообщений об ошибках и их
кодов в файле <TT>Docs/mysqld_error.txt</TT>.</P>

<H4>Возвращаемые значения</H4>
<P>Значение кода ошибки. 0, если никакая ошибка не произошла.</P>

<H4><A NAME="mysql_error">6.3.12 <CODE>mysql_error()</CODE></A></H4>
<P><CODE>mysql_error(mysql:PMYSQL):pchar;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Для подключения, определенного в <CODE>mysql</CODE>,
<CODE>mysql_error()</CODE> возвращает сообщение об ошибках для вызванной
функции API, которая может сработать нормально или потерпеть неудачу. Пустая
строка вернется, если никакой ошибки не произошло. Это означает, что
следующие тесты эквивалентны:</P>
<PRE>
if (mysql_errno(&#38;mysql))
{
   // an error occurred
}
if (mysql_error(&#38;mysql)[0] != '\0')
{
   // an error occurred
}
</PRE>

<P>Язык сообщений об ошибках пользователя может быть изменен перекомпиляцией
библиотеки клиента MySQL. В настоящее время Вы можете выбирать сообщения
об ошибках на нескольких различных языках.</P>

<H4>Возвращаемые значения</H4>
<P>Символьная строка, которая описывает ошибку. Пустая строка, если никакой
ошибки не произошло.</P>

<H4><A NAME="mysql_escape_string">6.3.13 <CODE>mysql_escape_string()</CODE>
</A></H4>
<P>Это идентично <CODE>mysql_real_escape_string()</CODE> за исключением того,
что требуется подключение как первый параметр.
<CODE>mysql_real_escape_string()</CODE> обработает строку согласно текущему
(актуальному) набору символов, в то время как
<CODE>mysql_escape_string()</CODE> игнорирует установку charset.</P>

<H4><A NAME="mysql_fetch_field">6.3.14 <CODE>mysql_fetch_field()</CODE></A>
</H4>
<P><CODE>mysql_fetch_field(res:PMYSQL_RES):PMYSQL_FIELD;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает определение одного столбца набора результатов как структуру
<CODE>MYSQL_FIELD</CODE>. Вызовите эту функцию неоднократно, чтобы собрать
информацию относительно всех столбцов в наборе результатов.
<CODE>mysql_fetch_field()</CODE> возвращает <CODE>NULL</CODE>, когда все поля
уже обработаны или их не было вовсе.</P>

<P><CODE>mysql_fetch_field()</CODE> будет сброшен так, чтобы возвратить
информацию относительно первого поля каждый раз, когда Вы выполняете новый
запрос <CODE>SELECT</CODE>. На поле, возвращенное
<CODE>mysql_fetch_field()</CODE> также воздействуют обращения к
<CODE>mysql_field_seek()</CODE>.</P>

<P>Если Вы вызвали <CODE>mysql_query()</CODE> чтобы выполнить
<CODE>SELECT</CODE> на таблице, но не вызвали
<CODE>mysql_store_result()</CODE>, MySQL возвращает заданную по умолчанию
длину blob (8K), если Вы вызываете <CODE>mysql_fetch_field()</CODE>, чтобы
спросить о длине поля типа <CODE>BLOB</CODE>. Размер в 8K выбран потому, что
MySQL не знает максимальную длину для <CODE>BLOB</CODE>. Это должно быть
сделано с перестраиваемой конфигурацией когда-нибудь. Как только Вы получили
набор результатов, <CODE>field.max_length</CODE> хранит длину самого
большого значения для этого столбца в специфическом запросе.</P>

<H4>Возвращаемые значения</H4>
<P>Структура типа <CODE>MYSQL_FIELD</CODE> для текущего (актуального)
столбца. <CODE>NULL</CODE>, если никакие столбцы не обработаны.</P>

<H4><A NAME="mysql_fetch_fields">6.3.15 <CODE>mysql_fetch_fields()</CODE>
</A></H4>
<P><CODE>mysql_fetch_fields(res:PMYSQL_RES):PMYSQL_FIELDS;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает массив всех структур <CODE>MYSQL_FIELD</CODE> для набора
результатов. Каждая структура обеспечивает определение поля для одного
столбца набора результатов.</P>

<H4>Возвращаемые значения</H4>
<P>Массив структур <CODE>MYSQL_FIELD</CODE> для всех
столбцов набора результатов.</P>

<H4><A NAME="mysql_fetch_field_direct">6.3.16
<CODE>mysql_fetch_field_direct()</CODE></A></H4>
<P><CODE>mysql_fetch_field_direct(res:PMYSQL_RES;
fieldnr:integer):PMYSQL_FIELD;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Получает код поля <CODE>fieldnr</CODE> для столбца внутри набора
результатов, возвращает определение поля столбца как структура
<CODE>MYSQL_FIELD</CODE>. Вы можете использовать эту функцию, чтобы получить
описание для произвольного столбца. Значение <CODE>fieldnr</CODE> должно быть
в диапазоне от 0 до <CODE>mysql_num_fields(result)-1</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Структура <CODE>MYSQL_FIELD</CODE> для определенного столбца.</P>

<H4><A NAME="mysql_fetch_lengths">6.3.17 <CODE>mysql_fetch_lengths()</CODE>
</A></H4>
<P><CODE>mysql_fetch_lengths(res:PMYSQL_RES):longword;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает длины столбцов текущей (актуальной) строки внутри набора
результатов. Если Вы планируете копировать значения поля, эта информация
также полезна для оптимизации потому, что Вы можете избежать вызова
<CODE>strlen()</CODE>. Кроме того, если набор результатов содержит двоичные
данные, Вы <EM>должны</EM> использовать эту функцию, чтобы определить размер
данных потому, что функция <CODE>strlen()</CODE> возвращает неправильные
результаты для любого поля, содержащего символы пробела.</P>

<P>Длина для пустых столбцов и для столбцов, содержащих значения
<CODE>NULL</CODE>, равна нулю. Чтобы видеть, как отличить эти два случая,
обратитесь к описанию <CODE>mysql_fetch_row()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Массив длинных целых чисел без знака, представляющих размер каждого
столбца (не включая любые символы пробелов в хвосте). <CODE>NULL</CODE>, если
что-то пошло не так.</P>

<H4>Ошибки</H4>
<P><CODE>mysql_fetch_lengths()</CODE> имеет силу только для текущей строки
набора результатов. Этот вызов возвращает <CODE>NULL</CODE>, если Вы
вызываете его перед <CODE>mysql_fetch_row()</CODE> или после получения
всех строк в результате.</P>

<H4><A NAME="mysql_fetch_row">6.3.18 <CODE>mysql_fetch_row()</CODE></A></H4>
<P><CODE>mysql_fetch_row(res:PMYSQL_RES):PMYSQL_ROW;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Получает следующую строку набора результатов. Когда используется после
<CODE>mysql_store_result()</CODE>, <CODE>mysql_fetch_row()</CODE> возвращает
<CODE>NULL</CODE>, когда не имеется больше строк, чтобы получить. Когда
используется после <CODE>mysql_use_result()</CODE>,
<CODE>mysql_fetch_row()</CODE> вернет <CODE>NULL</CODE>, когда не имеется
больше строк, чтобы получить, или произошла ошибка.</P>

<P>Число значений в строке задано <CODE>mysql_num_fields(result)</CODE>. Если
<CODE>row</CODE> хранит значение возврата от обращения к
<CODE>mysql_fetch_row()</CODE>, указатели на значения меняются с
<CODE>row[0]</CODE> на <CODE>row[mysql_num_fields(result)-1]</CODE>. Значения
<CODE>NULL</CODE> в строке обозначены указателями <CODE>NULL</CODE>.</P>

<P>Длины значений полей в строке могут быть получены, вызывая
<CODE>mysql_fetch_lengths()</CODE>. Пустые поля и поля, содержащие
<CODE>NULL</CODE> имеют длину 0. Вы можете отличать их, проверяя указатель
для значения поля. Если указатель равен <CODE>NULL</CODE>, поле
<CODE>NULL</CODE>, иначе поле пустое.</P>

<H4>Возвращаемые значения</H4>
<P>Структура <CODE>MYSQL_ROW</CODE> для следующей строки. <CODE>NULL</CODE>,
если не имеется больше строк, чтобы получить, или произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_field_count">6.3.19 <CODE>mysql_field_count()</CODE></A>
</H4>
<P><CODE>mysql_field_count(mysql:PMYSQL):longword;stdcall;</CODE></P>
<P>Если Вы используете версию MySQL ранее, чем Version 3.22.24, Вы должны
вместо этого использовать <CODE>mysql_num_fields(res:PMYSQL_RES):longword;
stdcall;</CODE>.</P>

<H4>Описание</H4>
<P>Возвращает число столбцов для самого последнего запроса на подключении.
</P>

<P>Нормальное использование этой функции: когда
<CODE>mysql_store_result()</CODE> возвращает <CODE>NULL</CODE> (и таким
образом Вы не имеете никакого указателя на набор результатов). В этом случае
Вы можете вызывать <CODE>mysql_field_count()</CODE>, чтобы определить, должен
или нет <CODE>mysql_store_result()</CODE> произвести не пустой результат. Это
позволяет программе пользователя выбрать соответствующее действие без того,
чтобы знать, был или нет запрос <CODE>SELECT</CODE> (или
<CODE>SELECT</CODE>-подобным). Пример, показанный ниже иллюстрирует, как это
может быть выполнено.</P>

<H4>Возвращаемые значения</H4>
<P>Целое число без знака, представляющее число полей в наборе результатов.
</P>

<H4><A NAME="mysql_field_seek">6.3.20 <CODE>mysql_field_seek()</CODE></A>
</H4>
<P><CODE>mysql_field_seek(res:PMYSQL_RES; offset:TMYSQL_FIELD_OFFSET):
TMYSQL_FIELD_OFFSET; stdcall;</CODE></P>

<H4>Описание</H4>
<P>Устанавливает курсор поля к данному смещению. Следующее обращение к
<CODE>mysql_fetch_field()</CODE> получит определение поля столбца, связанного
именно с этим смещением.</P>

<P>Чтобы перейти к началу строки, передайте 0 как значение
<CODE>offset</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Предыдущее значение курсора поля.</P>

<H4><A NAME="mysql_field_tell">6.3.21 <CODE>mysql_field_tell()</CODE></A>
</H4>
<P><CODE>mysql_field_tell(res:PMYSQL_RES):longword;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает позицию курсора поля, используемого для последнего
<CODE>mysql_fetch_field()</CODE>. Это значение может использоваться как
параметр для <CODE>mysql_field_seek()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Текущее смещение курсора поля.</P>

<H4><A NAME="mysql_free_result">6.3.22 <CODE>mysql_free_result()</CODE></A>
</H4>
<P><CODE>mysql_free_result(res:PMYSQL_RES);stdcall;</CODE></P>

<H4>Описание</H4>
<P>Освобождает память, распределенную для набора результатов
<CODE>mysql_store_result()</CODE>, <CODE>mysql_use_result()</CODE>,
<CODE>mysql_list_dbs()</CODE> и другими подобными функциями. Когда Вы
закончили работу с набором результатов, Вы должны освободить память, которую
он использует, вызывая <CODE>mysql_free_result()</CODE>.</P>

<H4><A NAME="mysql_get_client_info">6.3.23 <CODE>mysql_get_client_info()
</CODE></A></H4>
<P><CODE>mysql_get_client_info:pchar;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает строку, которая представляет версию клиентской библиотеки.</P>

<H4>Возвращаемые значения</H4>
<P>Символьная строка, которая представляет версию клиентской библиотеки MySQL.
</P>

<H4><A NAME="mysql_get_host_info">6.3.24 <CODE>mysql_get_host_info()</CODE>
</A></H4>
<P><CODE>mysql_get_host_info(mysql:PMYSQL):pchar;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает строку, описывающую тип используемого подключения, включая имя
главного компьютера сервера.</P>

<H4>Возвращаемые значения</H4>
<P>Символьная строка, представляющая имя компьютера и тип подключения.</P>

<H4><A NAME="mysql_get_proto_info">6.3.25 <CODE>mysql_get_proto_info()
</CODE></A></H4>
<P><CODE>mysql_get_proto_info(mysql:PMYSQL):longword;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает код версии протокола, используемой текущим подключением.</P>

<H4>Возвращаемые значения</H4>
<P>Целое число без знака, представляющее версию протокола, используемую
текущим (актуальным) подключением.</P>

<H4><A NAME="mysql_get_server_info">6.3.26 <CODE>mysql_get_server_info()
</CODE></A></H4>
<P><CODE>mysql_get_server_info(mysql:PMYSQL):pchar;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает строку, которая представляет номер версии сервера.</P>

<H4>Возвращаемые значения</H4>
<P>Символьная строка, которая представляет номер версии станции.</P>

<H4><A NAME="mysql_info">6.3.27 <CODE>mysql_info()</CODE></A></H4>
<P><CODE>mysql_info(mysql:PMYSQL):pchar;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает строку, обеспечивающую информацию относительно недавно
выполненного запроса, но только для инструкций, перечисленных ниже. Для
других инструкций <CODE>mysql_info()</CODE> всегда возвращает
<CODE>NULL</CODE>. Формат строки изменяется в зависимости от типа запроса,
как описано ниже. Числа только иллюстративны: строка будет содержать
значения, соответствующие запросу.</P>

<DL COMPACT>
<DT><CODE>INSERT INTO ... SELECT ...</CODE>
<DD>Формат строки: <CODE>Records: 100 Duplicates: 0 Warnings: 0</CODE>
<DT><CODE>INSERT INTO ... VALUES (...),(...),(...)...</CODE>
<DD>Формат строки: <CODE>Records: 3  Duplicates: 0  Warnings: 0</CODE>
<DT><CODE>LOAD DATA INFILE ...</CODE>
<DD>Формат строки: <CODE>Records: 1 Deleted: 0 Skipped: 0 Warnings: 0</CODE>
<DT><CODE>ALTER TABLE</CODE>
<DD>Формат строки: <CODE>Records: 3 Duplicates: 0 Warnings: 0</CODE>
<DT><CODE>UPDATE</CODE>
<DD>Формат строки: <CODE>Rows matched: 40 Changed: 40 Warnings: 0</CODE></DL>

<P>Обратите внимание, что <CODE>mysql_info()</CODE> возвращает значение
не-<CODE>NULL</CODE> для инструкции <CODE>INSERT ... VALUES</CODE> только,
если много списков значений было определено в инструкции.</P>

<H4>Возвращаемые значения</H4>
<P>Символьная строка, представляющая дополнительную информацию относительно
последнего выполненного запроса. <CODE>NULL</CODE>, если никакая информация
не доступна для запроса.</P>

<H4><A NAME="mysql_init">6.3.28 <CODE>mysql_init()</CODE></A></H4>
<P><CODE>mysql_init(mysql: PMYSQL):PMYSQL;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Распределяет или инициализирует объект <CODE>MYSQL</CODE>, подходящий для
<CODE>mysql_real_connect()</CODE>. Если <CODE>mysql</CODE> является
указателем <CODE>NULL</CODE>, функция распределяет память, инициализирует и
возвращает новый объект. Иначе объект будет просто инициализирован, и адрес
объекта возвращен. Если <CODE>mysql_init()</CODE> распределяет новый объект,
место будет освобождено, когда будет вызвана <CODE>mysql_close()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Инициализированный дескриптор <CODE>MYSQL*</CODE>. <CODE>NULL</CODE>, если
недостаточно памяти, чтобы распределить и инициализировать новый объект.</P>

<H4>Ошибки</H4>
<P>В случае недостаточной памяти вернется <CODE>NULL</CODE>.</P>

<H4><A NAME="mysql_insert_id">6.3.29 <CODE>mysql_insert_id()</CODE></A></H4>
<P><CODE>mysql_insert_id(mysql:PMYSQL):TMY_ULONGLONG;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает ID, сгенерированный предыдущим запросом для столбца с
поддержкой <CODE>AUTO_INCREMENT</CODE>. Используйте эту функцию после того,
как Вы выполнили запрос <CODE>INSERT</CODE> для таблицы, которая содержит
поле <CODE>AUTO_INCREMENT</CODE>.</P>

<P>Обратите внимание, что <CODE>mysql_insert_id()</CODE> возвращает
<CODE>0</CODE>, если предыдущий запрос не генерирует значение
<CODE>AUTO_INCREMENT</CODE>. Если Вы должны сохранить значение для
последующего неспешного потребления убедитесь, что вызвали
<CODE>mysql_insert_id()</CODE> немедленно после того запроса,
который генерирует значение.</P>

<P><CODE>mysql_insert_id()</CODE> модифицируется после инструкций
<CODE>INSERT</CODE> и <CODE>UPDATE</CODE>, которые генерируют значение
<CODE>AUTO_INCREMENT</CODE>, или установки значения столбца с помощью
<CODE>LAST_INSERT_ID(expr)</CODE>.</P>

<P>Также обратите внимание, что значение функции SQL
<CODE>LAST_INSERT_ID()</CODE> всегда содержит самое последнее сгенерированное
значение <CODE>AUTO_INCREMENT</CODE>, и оно не будет сброшено между запросами
потому, что значение этой функции поддерживается сервером.</P>

<H4>Возвращаемые значения</H4>
<P>Значение поля <CODE>AUTO_INCREMENT</CODE>, которое модифицировалось
предыдущим запросом. 0, если не имелось никакого предыдущего запроса на
подключении, или если запрос не модифицировал <CODE>AUTO_INCREMENT</CODE>.
</P>

<H4><A NAME="mysql_kill">6.3.30 <CODE>mysql_kill()</CODE></A></H4>
<P><CODE>mysql_kill(mysql:PMYSQL;pid:longword):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Просит, чтобы сервер уничтожил поток, определенный как <CODE>pid</CODE>.
</P>

<H4>Возвращаемые значения</H4>
<P>Ноль для успеха. Отличное от нуля, если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_list_dbs">6.3.31 <CODE>mysql_list_dbs()</CODE></A></H4>
<P><CODE>mysql_list_dbs(mysql:PMYSQL;const wild:pchar):PMYSQL_RES;stdcall;
</CODE></P>

<H4>Описание</H4>
<P>Возвращает набор результатов, состоящий из имен баз данных на сервере,
которые соответствуют простому регулярному выражению, определенному
параметром <CODE>wild</CODE>. Здесь <CODE>wild</CODE> может содержать
групповые символы <SAMP>%</SAMP> или <SAMP>_</SAMP>, или может быть
<CODE>NULL</CODE>, чтобы соответствовать всем базам данных. Вызов
<CODE>mysql_list_dbs()</CODE> подобен выполнению запроса <CODE>SHOW
databases [LIKE wild]</CODE>.</P>

<P>Вы должны освободить набор результатов с помощью
<CODE>mysql_free_result()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Набор результатов <CODE>MYSQL_RES</CODE> для успеха, <CODE>NULL</CODE>,
если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_OUT_OF_MEMORY</CODE>
<DD>Не хватило памяти.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_list_fields">6.3.32 <CODE>mysql_list_fields()</CODE>
</A></H4>
<P><CODE>mysql_list_fields(mysql:PMYSQL;const table,wild:pchar):PMYSQL_RES;
stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает набор результатов, состоящий из имен полей в данной таблице,
которые соответствуют простому регулярному выражению, определенному
параметром <CODE>wild</CODE>. Здесь <CODE>wild</CODE> может содержать
групповые символы <SAMP>%</SAMP> или <SAMP>_</SAMP>, или может быть
<CODE>NULL</CODE>, чтобы соответствовать всем полям. Вызов
<CODE>mysql_list_fields()</CODE> подобен выполнению запроса <CODE>SHOW
COLUMNS FROM tbl_name [LIKE wild]</CODE>.</P>

<P>Обратите внимание, что рекомендуется, чтобы Вы использовали <CODE>SHOW
COLUMNS FROM tbl_name</CODE> вместо <CODE>mysql_list_fields()</CODE>.</P>

<P>Вы должны освободить набор результатов с помощью
<CODE>mysql_free_result()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Набор результатов <CODE>MYSQL_RES</CODE> для успеха. <CODE>NULL</CODE>,
если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_list_processes">6.3.33 <CODE>mysql_list_processes()</CODE>
</A></H4>
<P><CODE>mysql_list_processes(mysql:PMYSQL):PMYSQL_RES;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает набор результатов, описывающий текущие потоки сервера. Это тот
же самый вид информации, что и сообщаемый командой <CODE>mysqladmin
processlist</CODE> или запросом <CODE>SHOW PROCESSLIST</CODE>.</P>

<P>Вы должны освободить набор результатов с помощью
<CODE>mysql_free_result()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Набор результатов <CODE>MYSQL_RES</CODE> для успеха. <CODE>NULL</CODE>,
если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_list_tables">6.3.34 <CODE>mysql_list_tables()</CODE></A>
</H4>
<P><CODE>mysql_list_tables(mysql:PMYSQL;const wild:pchar):PMYSQL_RES;stdcall;
</CODE></P>

<H4>Описание</H4>
<P>Возвращает набор результатов, состоящий из имен таблиц в текущей базе
данных, которые соответствуют простому регулярному выражению, определенному
параметром <CODE>wild</CODE>. Здесь <CODE>wild</CODE> может содержать
групповые символы <SAMP>%</SAMP> или <SAMP>_</SAMP>, или может быть
<CODE>NULL</CODE>, чтобы соответствовать всем таблицам. Вызов
<CODE>mysql_list_tables()</CODE> подобен выполнению запроса <CODE>SHOW
tables [LIKE wild]</CODE>.</P>

<P>Вы должны освободить набор результатов с помощью
<CODE>mysql_free_result()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Набор результатов <CODE>MYSQL_RES</CODE> для успеха. <CODE>NULL</CODE>,
если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_num_fields">6.3.35 <CODE>mysql_num_fields()</CODE></A>
</H4>
<P><CODE>mysql_num_fields(res:PMYSQL_RES):longword;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает число столбцов в наборе результатов.</P>

<P>Обратите внимание, что Вы можете получать число столбцов из указателя
набора результатов или от дескриптора подключения. Вы используете дескриптор
подключения, если <CODE>mysql_store_result()</CODE> или
<CODE>mysql_use_result()</CODE> возвращает <CODE>NULL</CODE> (и таким образом
Вы не имеете никакого указателя набора результата). В этом случае Вы можете
вызывать <CODE>mysql_field_count()</CODE> чтобы определить, должен или нет
<CODE>mysql_store_result()</CODE> произвести непустой результат. Это
позволяет программе пользователя выбрать соответствующее действие без того,
чтобы знать, был или нет запрос <CODE>SELECT</CODE> (или
<CODE>SELECT</CODE>-подобным). Пример, показанный ниже иллюстрирует, как это
может быть выполнено.</P>

<H4>Возвращаемые значения</H4>
<P>Целое число без знака, представляющее число полей в наборе результатов.
</P>

<H4><A NAME="mysql_num_rows">6.3.36 <CODE>mysql_num_rows()</CODE></A></H4>
<P><CODE>mysql_num_rows(res:PMYSQL_RES):TMY_ULONGLONG;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает число строк в наборе результатов.</P>

<P>Использование <CODE>mysql_num_rows()</CODE> зависит от того, используете
ли Вы <CODE>mysql_store_result()</CODE> или <CODE>mysql_use_result()</CODE>,
чтобы получить набор результатов. Если Вы используете
<CODE>mysql_store_result()</CODE>, <CODE>mysql_num_rows()</CODE> может
быть вызван немедленно. Если Вы используете <CODE>mysql_use_result()</CODE>,
<CODE>mysql_num_rows()</CODE> не будет возвращать правильное значение, пока
все строки в наборе результатов не будут получены.</P>

<H4>Возвращаемые значения</H4>
<P>Число строк в наборе результатов.</P>

<H4><A NAME="mysql_options">6.3.37 <CODE>mysql_options()</CODE></A></H4>
<P><CODE>mysql_options(mysql:PMYSQL;option:TMYSQL_OPTION;
const arg:pchar):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Может использоваться, чтобы установить дополнительные параметры связи и
действует на поведение подключения. Эта функция может быть вызвана несколько
раз, чтобы установить несколько параметров.</P>

<P><CODE>mysql_options()</CODE> должна быть вызвана после
<CODE>mysql_init()</CODE>, но перед <CODE>mysql_connect()</CODE> или
<CODE>mysql_real_connect()</CODE>.</P>

<P>Параметр <CODE>option</CODE> представляет собой опцию, которую Вы хотите
устанавливать, <CODE>arg</CODE> задает значение для опции. Если опция целое
число, то <CODE>arg</CODE> должен указывать на значение целого числа.</P>

<P>Возможные значения параметров:</P>
<TABLE><TR><TD><STRONG>Опция</STRONG></TD><TD><STRONG>Тип аргумента</STRONG>
</TD><TD><STRONG>Действие</STRONG></TD></TR>
<TR><TD><CODE>MYSQL_OPT_CONNECT_TIMEOUT</CODE></TD><TD>
<CODE>longword</CODE></TD><TD>Время ожидания в секундах.</TD></TR>
<TR><TD><CODE>MYSQL_OPT_COMPRESS</CODE></TD><TD>TMY_BOOL</TD><TD>
Использовать сжатый протокол клиент-сервер.</TD></TR>
<TR><TD><CODE>MYSQL_OPT_NAMED_PIPE</CODE></TD><TD>TMY_BOOL</TD><TD>
Использовать именованные каналы, чтобы соединиться с сервером MySQL под NT.
</TD></TR>
<TR><TD><CODE>MYSQL_INIT_COMMAND</CODE></TD><TD><CODE>PCHAR</CODE></TD><TD>
Команда, чтобы выполнить при соединении с сервером MySQL. Будет автоматически
выполнена при повторном соединении.</TD></TR>
<TR><TD><CODE>MYSQL_READ_DEFAULT_FILE</CODE></TD><TD><CODE>PCHAR</CODE></TD>
<TD>Читать параметры из указанного файла опций вместо <TT>my.cnf</TT>.</TD>
</TR>
<TR><TD><CODE>MYSQL_READ_DEFAULT_GROUP</CODE></TD><TD><CODE>PCHAR</CODE>
</TD><TD>Читать параметры из именованной группы из файла опций
<TT>my.cnf</TT> или файла, определенного в
<CODE>MYSQL_READ_DEFAULT_FILE</CODE>.</TD></TR></TABLE>

<P>Обратите внимание, что группа <CODE>client</CODE> всегда читается, если Вы
используете <CODE>MYSQL_READ_DEFAULT_FILE</CODE> или
<CODE>MYSQL_READ_DEFAULT_GROUP</CODE>.</P>

<P>Определенная группа в файле опций может содержать следующие параметры:</P>

<TABLE><TR><TD><CODE>connect_timeout</CODE></TD><TD>Время ожидания в секундах.
В Linux это время ожидания также используется для ожидания первого ответа.
</TD></TR>
<TR><TD><CODE>compress</CODE></TD><TD>Использовать сжатый протокол
клиент-сервер.</TD></TR>
<TR><TD><CODE>database</CODE></TD><TD>Соединиться с этой базой данных, если
никакая база данных не была определена в команде подключения.</TD></TR>
<TR><TD><CODE>debug</CODE></TD><TD>Опции для отладки.</TD></TR>
<TR><TD><CODE>host</CODE></TD><TD>Имя сервера по умолчанию.</TD></TR>
<TR><TD><CODE>init-command</CODE></TD><TD>Команда, чтобы выполнить при
соединении с сервером MySQL. Будет автоматически заново выполнена при
повторном соединении, если связь прервалась.</TD></TR>
<TR><TD><CODE>interactive-timeout</CODE></TD><TD>Аналогично указанию опции
<CODE>CLIENT_INTERACTIVE</CODE> в <CODE>mysql_real_connect()</CODE>.</TD>
</TR>
<TR><TD><CODE>password</CODE></TD><TD>Пароль по умолчанию.</TD></TR>
<TR><TD><CODE>pipe</CODE></TD><TD>Использовать именованные каналы, чтобы
соединиться с сервером MySQL, работая под NT.</TD></TR>
<TR><TD><CODE>port</CODE></TD><TD>Порт по умолчанию.</TD></TR>
<TR><TD><CODE>return-found-rows</CODE></TD><TD>Сообщить
<CODE>mysql_info()</CODE> о том, что нужно возвратить найденные строки вместо
модифицируемых строк при использовании <CODE>UPDATE</CODE>.</TD></TR>
<TR><TD><CODE>socket</CODE></TD><TD>Сокет по умолчанию.</TD></TR>
<TR><TD><CODE>user</CODE></TD><TD>Пользователь по умолчанию.</TD></TR></TABLE>

<P>Обратите внимание, что <CODE>timeout</CODE> был заменен на
<CODE>connect_timeout</CODE>, но <CODE>timeout</CODE> будет все еще работать
некоторое время для совместимости.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль для успеха. Отличное от нуля, если Вы использовали неизвестную опцию.
</P>

<H4><A NAME="mysql_ping">6.3.38 <CODE>mysql_ping()</CODE></A></H4>
<P><CODE>mysql_ping(mysql:PMYSQL):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Проверяет работает или нет подключение. В случае неработоспособности будет
предпринято автоматическое переподключение.</P>

<P>Эта функция может использоваться клиентом, который долго простаивает,
чтобы определить, закрыл или нет сервер подключение, и повторно соединиться с
ним в случае необходимости.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль, если подключение работает. Отличное от нуля, если произошла ошибка.
</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_query">6.3.39 <CODE>mysql_query()</CODE></A></H4>
<P><CODE>mysql_query(mysql:PMYSQL; const q:pchar):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Выполняет запрос SQL, указанный строкой с нулевым символом в конце. Запрос
должен состоять из одиночной инструкции SQL. Вы не должны добавлять точку с
запятой (<SAMP>;</SAMP>) или <CODE>\g</CODE> для завершения запроса.</P>

<P><CODE>mysql_query()</CODE> не может использоваться для запросов, которые
содержат двоичные данные, взамен Вы должны использовать
<CODE>mysql_real_query()</CODE>. Двоичные данные могут содержать в себе
символ <SAMP>\0</SAMP>, который <CODE>mysql_query()</CODE> интерпретирует как
конец строки запроса. Если Вы хотите знать, возвратил ли запрос набор
результатов или нет, Вы можете использовать <CODE>mysql_field_count()</CODE>,
чтобы проверить это.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль, если запрос был успешен. Отличное от нуля, если произошла ошибка.
</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_real_connect">6.3.40 <CODE>mysql_real_connect()</CODE>
</A></H4>
<P><CODE>mysql_real_connect(mysql: PMYSQL; const host,user,passwd,db:pchar;
                            port:longword; const unix_socket:pchar;
                            clientflag:longword):PMYSQL;stdcall;</CODE></P>

<H4>Описание</H4>
<P><CODE>mysql_real_connect()</CODE> пытается установить подключение с
сервером MySQL, запущенным на машине <CODE>host</CODE>.
<CODE>mysql_real_connect()</CODE> должен завершиться успешно прежде, чем Вы
сможете выполнить любую из других функций API, за исключением
<CODE>mysql_get_client_info()</CODE>.</P>

<P>Параметры определены следующим образом:</P>
<UL><LI>Первый параметр должен быть адресом существующей структуры типа
<CODE>TMYSQL</CODE>. Перед вызовом <CODE>mysql_real_connect()</CODE> Вы
должны вызвать <CODE>mysql_init()</CODE>, чтобы инициализировать структуру
<CODE>TMYSQL</CODE>. Вы можете изменять много параметров подключения через
вызов <CODE>mysql_options()</CODE>.

<LI>Значением <CODE>host</CODE> может быть имя или адрес IP. Если это
<CODE>NULL</CODE> или строка <CODE>localhost</CODE>, выполняется подключение
к локальной системе. Если OS поддерживает сокеты (Unix) или именованные
каналы (Windows), именно они используются вместо стека протоколов TCP/IP,
чтобы соединиться с сервером.

<LI>Аргумент <CODE>user</CODE> содержит ID пользователя MySQL. Если
<CODE>user</CODE> равен <CODE>NULL</CODE>, предполагается текущий
пользователь. Под Unix это текущее (актуальное) имя входа в систему. Под
Windows ODBC имя пользователя должно быть определено явно!

<LI>Параметр <CODE>passwd</CODE> содержит пароль для <CODE>user</CODE>. Если
<CODE>passwd</CODE> равен <CODE>NULL</CODE>, только записи в таблице
<CODE>user</CODE>, которые имеют пустое поле пароля, будут проверены на
соответствие. Это позволяет администратору базы данных устанавливать систему
привилегий MySQL таким способом, которым пользователи получают различные
привилегии в зависимости от того, определили или нет они пароль. ОБРАТИТЕ
ВНИМАНИЕ: Не пытайтесь шифровать пароль перед вызовом
<CODE>mysql_real_connect()</CODE>: шифрование пароля обработано автоматически.

<LI><CODE>db</CODE> задает имя базы данных. Если <CODE>db</CODE> не
<CODE>NULL</CODE>, подключение установит заданную по умолчанию базу данных.

<LI>Если <CODE>port</CODE> не равен 0, значение будет использоваться как
номер порта для подключения по TCP/IP. Обратите внимание, что параметр
<CODE>host</CODE> определяет тип подключения.

<LI>Если <CODE>unix_socket</CODE> не равен <CODE>NULL</CODE>, строка
определяет сокет или именованный канал, который должен использоваться.
Обратите внимание, что параметр <CODE>host</CODE> определяет тип подключения.

<LI>Значение <CODE>client_flag</CODE> как правило равно 0, но может быть
установлено к комбинации из следующих флажков в специальных обстоятельствах:

<TABLE><TR><TD><STRONG>Имя флажка</STRONG></TD><TD><STRONG>Что он делает
</STRONG></TD></TR>
<TR><TD><CODE>CLIENT_COMPRESS</CODE></TD><TD>Использовать протокол сжатия.
</TD></TR>
<TR><TD><CODE>CLIENT_FOUND_ROWS</CODE></TD><TD>Возвратить число найденных, а
не обработанных строк.</TD></TR>
<TR><TD><CODE>CLIENT_IGNORE_SPACE</CODE></TD><TD>Позволить использовать
пробелы после имен функций. Делает все зарезервированные
слова именами функций.</TD></TR>
<TR><TD><CODE>CLIENT_INTERACTIVE</CODE></TD><TD>Позволить
<CODE>interactive_timeout</CODE> секунд (вместо <CODE>wait_timeout</CODE>
секунд) бездеятельности перед закрытием подключения.</TD></TR>
<TR><TD><CODE>CLIENT_NO_SCHEMA</CODE></TD><TD>Не позволять синтаксис
<CODE>db_name.tbl_name.col_name</CODE>. Это сделано для ODBC. Это заставляет
синтаксический анализатор генерировать ошибку, если Вы используете тот
синтаксис, который является полезным для заманивания в ловушку ошибок в
некоторых программах ODBC.</TD></TR>
<TR><TD><CODE>CLIENT_ODBC</CODE></TD><TD>Работает клиент ODBC.</TD></TR>
<TR><TD><CODE>CLIENT_SSL</CODE></TD><TD>Использовать шифрованный протокол SSL.
</TD></TR></TABLE></UL>

<H4>Возвращаемые значения</H4>
<P>Дескриптор <CODE>MYSQL*</CODE>, если подключение было успешно,
<CODE>NULL</CODE>, если подключение было неудачно. Для успешного подключения,
значение возврата: такое же, как значение первого параметра, если Вы не
передаете <CODE>NULL</CODE> для этого параметра.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_CONN_HOST_ERROR</CODE>
<DD>Не удалось связаться с сервером.
<DT><CODE>CR_CONNECTION_ERROR</CODE>
<DD>Не удалось связаться с локальным сервером.
<DT><CODE>CR_IPSOCK_ERROR</CODE>
<DD>Не удалось создать IP-сокет.
<DT><CODE>CR_OUT_OF_MEMORY</CODE>
<DD>Не хватило памяти.
<DT><CODE>CR_SOCKET_CREATE_ERROR</CODE>
<DD>Не удалось создать Unix-сокет.
<DT><CODE>CR_UNKNOWN_HOST</CODE>
<DD>Не удалось найти IP-адрес для hostname.
<DT><CODE>CR_VERSION_ERROR</CODE>
<DD>Несоответствие протоколов следовало из попытки соединиться с сервером с
помощью клиентской библиотеки, которая использует иную версию протокола. Это
может случиться, если Вы используете очень старую библиотеку, чтобы
соединиться с новым сервером, который не был запущен с параметром
<CODE>--old-protocol</CODE>.
<DT><CODE>CR_NAMEDPIPEOPEN_ERROR</CODE>
<DD>Не удалось создать именованный канал в Windows.
<DT><CODE>CR_NAMEDPIPEWAIT_ERROR</CODE>
<DD>Не удалось дождаться именованного канала в Windows.
<DT><CODE>CR_NAMEDPIPESETSTATE_ERROR</CODE>
<DD>Не удалось получить дескриптор для именованного канала в Windows.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Если <CODE>connect_timeout</CODE>&#62; 0 и требуется более, чем
<CODE>connect_timeout</CODE> секунд, чтобы соединиться с сервером, или если
сервер свалился при выполнении <CODE>init-command</CODE>, вернется это.</DL>

<P>Используя <CODE>mysql_options()</CODE>, библиотека клиентов MySQL будет
читать группы <CODE>[client]</CODE> и <CODE>your_prog_name</CODE> в файле
<CODE>my.cnf</CODE>, что гарантирует, что Ваша программа будет работать, даже
если кто-то установил MySQL некоторым ненормативным способом.</P>

<P>Обратите внимание, что на подключение <CODE>mysql_real_connect()</CODE>
устанавливает флажок <CODE>reconnect</CODE> (часть структуры TMYSQL) в
значение <CODE>1</CODE>. Этот флажок указывает, что когда запрос не может
выполниться из-за потерянного подключения, надо попробовать повторно
соединиться с сервером перед отказом.</P>

<H4><A NAME="mysql_real_escape_string">6.3.41
<CODE>mysql_real_escape_string()</CODE></A></H4>
<P><CODE>mysql_real_escape_string(mysql:PMYSQL; wto:pchar;
const wfrom:pchar; wfromlength:longword):longword;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Эта функция используется, чтобы создать допустимую строку, которую
Вы можете использовать в инструкции SQL.</P>

<P>Строка в <CODE>from</CODE> бужет закодирована до экранированной строки
SQL, принимая во внимание текущий (актуальный) набор символов подключения.
Результат будет помещен в <CODE>to</CODE> и завершающий байт пустого
указателя допишется автоматически. Символы <CODE>NUL</CODE> (ASCII 0),
<SAMP>\n</SAMP>, <SAMP>\r</SAMP>, <SAMP>\</SAMP>, <SAMP>'</SAMP>,
<SAMP>"</SAMP>, а также Control-Z, будуь экранированы.</P>

<P>Строка, указанная в <CODE>from</CODE> должна быть <CODE>length</CODE>
байтов длины. Вы должны распределить буфер по крайней мере
<CODE>length*2+1</CODE> байт. В худшем случае каждый символ должен быть
закодирован как использование двух байтов, и Вы нуждаетесь в участке памяти
для завершающего байта пустого указателя. Когда
<CODE>mysql_escape_string()</CODE> завершится, в <CODE>to</CODE> будет
строка с нулевым байтом в конце. Значение возврата: длина закодированной
строки, не включая символ завершения.</P>

<H4>Возвращаемые значения</H4>
<P>Длина значения, помещенного в <CODE>to</CODE>, не включая
нулевой символ завершения.</P>

<H4><A NAME="mysql_real_query">6.3.42 <CODE>mysql_real_query()</CODE></A>
</H4>
<P><CODE>mysql_real_query(mysql:PMYSQL; const q:pchar;
length:longword):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Выполняет запрос SQL, указанный в <CODE>query</CODE>, который должен быть
строкой длиной в <CODE>length</CODE> байт. Запрос должен состоять из
одиночной инструкции SQL. Вы не должны добавлять точку с запятой
(<SAMP>`;'</SAMP>) или <CODE>\g</CODE> для завершения запроса.</P>

<P>Вы <EM>должны</EM> использовать <CODE>mysql_real_query()</CODE> вместо
<CODE>mysql_query()</CODE> для запросов, которые содержат двоичные данные,
потому, что двоичные данные могут сами содержать символ <SAMP>\0</SAMP>.
Кроме того, <CODE>mysql_real_query()</CODE> быстрее, чем
<CODE>mysql_query()</CODE> потому, что не вызывает <CODE>strlen()</CODE>.</P>

<P>Если Вы хотите знать, возвратил ли запрос набор результатов или нет, Вы
можете использовать <CODE>mysql_field_count()</CODE>, чтобы проверить это.
Подробности в разделе "<A HREF="manual.htm#mysql_field_count">6.3.85
<CODE>mysql_field_count()</CODE></A>".</P>

<H4>Возвращаемые значения</H4>
<P>Ноль, если запрос был успешным. Отличное от нуля, если произошла ошибка.
</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_reload">6.3.43 <CODE>mysql_reload()</CODE></A></H4>
<P><CODE>mysql_reload(mysql:PMYSQL):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Просит, чтобы сервер MySQL перезагрузил таблицы предоставления привилегий.
Пользователь должен иметь привилегию <STRONG>reload</STRONG>.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль для успеха. Отличное от нуля, если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_row_seek">6.3.44 <CODE>mysql_row_seek()</CODE></A></H4>
<P><CODE>mysql_row_seek(res:PMYSQL_RES;
offset:PMYSQL_ROW_OFFSET):PMYSQL_ROW_OFFSET;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Устанавливает курсор строки на произвольную строку в наборе результатов
запросов. Это требует, чтобы структура набора результата содержала весь
результат запроса, так что <CODE>mysql_row_seek()</CODE> может использоваться
в конъюнкции только с <CODE>mysql_store_result()</CODE>, но не с
<CODE>mysql_use_result()</CODE>.</P>

<P>Смещение должно быть значением, возвращенным из
<CODE>mysql_row_tell()</CODE> для <CODE>mysql_row_seek()</CODE>. Это значение
не просто номер строки, если Вы хотите перейти к строке внутри набора
результатов, используйте <CODE>mysql_data_seek()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Предыдущее значение курсора строки. Это значение может быть передано
последующему обращению к <CODE>mysql_row_seek()</CODE>.</P>

<H4><A NAME="mysql_row_tell">6.3.45 <CODE>mysql_row_tell()</CODE></A></H4>
<P><CODE>mysql_row_tell(res:PMYSQL_RES):PMYSQL_ROWS;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает текущую (актуальную) позицию курсора строки для последнего
вызова <CODE>mysql_fetch_row()</CODE>. Это значение может использоваться как
параметр для <CODE>mysql_row_seek()</CODE>.</P>

<P>Вы должны использовать <CODE>mysql_row_tell()</CODE> только после
<CODE>mysql_store_result()</CODE>, но не после
<CODE>mysql_use_result()</CODE>.</P>

<H4>Возвращаемые значения</H4>
<P>Текущее (актуальное) смещение курсора строки.</P>

<H4><A NAME="mysql_select_db">6.3.46 <CODE>mysql_select_db()</CODE></A></H4>
<P><CODE>mysql_select_db(mysql:PMYSQL; const db:pchar):integer;stdcall;
</CODE></P>

<H4>Описание</H4>
<P>Заставляет базу данных, определенную через <CODE>db</CODE>, стать заданной
по умолчанию базой данных на подключении, определенном в <CODE>mysql</CODE>.
В последующих запросах эта база данных будет значением по умолчанию для
ссылок на таблицы, которые не включают явный спецификатор базы данных.</P>

<P><CODE>mysql_select_db()</CODE> терпит неудачу, если связанный пользователь
не имеет прав доступа, чтобы использовать базу данных.</P>

<H4>Возвращаемые значения</H4>
<P>Ноль для успеха. Отличное от нуля, если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_shutdown">6.3.47 <CODE>mysql_shutdown()</CODE></A></H4>
<P><CODE>mysql_shutdown(mysql:PMYSQL):integer;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Выключает сервер. Связанный пользователь должен иметь привилегии
закрытия системы (<STRONG>shutdown</STRONG>).</P>

<H4>Возвращаемые значения</H4>
<P>Ноль для успеха. Отличное от нуля, если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_stat">6.3.48 <CODE>mysql_stat()</CODE></A></H4>
<P><CODE>mysql_stat(mysql:PMYSQL):pchar;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает символьную строку, содержащую информацию, подобную
обеспечиваемой командой <CODE>mysqladmin status</CODE>. Это включает
uptime в секундах, число работающих потоков, количество запросов,
перезагрузок и открытых таблиц.</P>

<H4>Возвращаемые значения</H4>
<P>Символьная строка, описывающая состояние сервера. <CODE>NULL</CODE>,
если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_store_result">6.3.49 <CODE>mysql_store_result()</CODE></A>
</H4>
<P><CODE>mysql_store_result(mysql:PMYSQL):PMYSQL_RES;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Вы должны вызвать <CODE>mysql_store_result()</CODE> или
<CODE>mysql_use_result()</CODE> для каждого запроса, который успешно получает
данные (<CODE>SELECT</CODE>, <CODE>SHOW</CODE>, <CODE>DESCRIBE</CODE>,
<CODE>EXPLAIN</CODE>).</P>

<P>Вы не должны вызывать <CODE>mysql_store_result()</CODE> или
<CODE>mysql_use_result()</CODE> для других запросов, но это не причинит
вреда, если Вы вызываете <CODE>mysql_store_result()</CODE> во всех случаях.
Правда, и эффективности не прибавится... Вы могли обнаружить, что запрос не
имеет набора результатов, проверяя равенство нулю возврата
<CODE>mysql_store_result()</CODE>. Если Вы хотите знать, возвратил ли запрос
набор результатов или нет, Вы можете использовать <CODE>mysql_field_count()
</CODE>, чтобы проверить это.</P>

<P><CODE>mysql_store_result()</CODE> читает весь результат запроса,
распределяет структуру <CODE>TMYSQL_RES</CODE> и помещает
результат в эту структуру.</P>

<P><CODE>mysql_store_results()</CODE> вернет пустой указатель, если запрос не
возвращал набор результатов вообще (если запрос был, например, инструкцией
<CODE>INSERT</CODE>).</P>

<P><CODE>mysql_store_results()</CODE> также возвращает пустой указатель, если
чтение набора результатов потерпело неудачу. Вы можете проверить, получили
ли Вы ошибку, проверяя возвращает ли <CODE>mysql_error()</CODE> пустой
указатель. Если <CODE>mysql_errno()</CODE> &#60;&#62; 0, или если
<CODE>mysql_field_count()</CODE> &#60;&#62; 0, значит, есть ошибочка.</P>

<P>Пустой набор результатов будет возвращен, если не имеется никаких
возвращенных строк. Пустой набор результатов отличается от пустого указателя
как значение возврата.</P>

<P>Как только Вы вызвали <CODE>mysql_store_result()</CODE> и получили
результат, который не пустой указатель, Вы можете вызывать
<CODE>mysql_num_rows()</CODE>, чтобы выяснить, сколько строк
находится в наборе результатов.</P>

<P>Вы можете вызвать <CODE>mysql_fetch_row()</CODE>, чтобы выбрать строки из
набора результатов, или <CODE>mysql_row_seek()</CODE> и
<CODE>mysql_row_tell()</CODE>, чтобы получить или установить текущую позицию
строки внутри набора результатов.</P>

<P>Вы должны вызвать <CODE>mysql_free_result()</CODE> как только Вы закончите
работу с данным набором результатов.</P>

<H4>Возвращаемые значения</H4>
<P>Структура <CODE>MYSQL_RES</CODE> с результатами. <CODE>NULL</CODE>,
если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_OUT_OF_MEMORY</CODE>
<DD>Не хватило памяти.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H4><A NAME="mysql_thread_id">6.3.50 <CODE>mysql_thread_id()</CODE></A></H4>
<P><CODE>mysql_thread_id(mysql:PMYSQL):longword;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Возвращает ID потока текущего (актуального) подключения. Это значение
может использоваться как параметр для <CODE>mysql_kill()</CODE>, чтобы
уничтожить этот поток.</P>

<P>Если подключение потеряно, и Вы повторно соединяетесь через
<CODE>mysql_ping()</CODE>, ID потока изменится. Это означает, что Вы не
должны получить ID потока и хранить его. Надо получать ID по мере надобности.
</P>

<H4>Возвращаемые значения</H4>
<P>ID потока текущего (актуального) подключения.</P>

<H4><A NAME="mysql_use_result">6.3.51 <CODE>mysql_use_result()</CODE></A>
</H4>
<P><CODE>mysql_use_result(mysql:PMYSQL):PMYSQL_RES;stdcall;</CODE></P>

<H4>Описание</H4>
<P>Вы должны вызвать <CODE>mysql_store_result()</CODE> или
<CODE>mysql_use_result()</CODE> для каждого запроса, который успешно получает
данные (<CODE>SELECT</CODE>, <CODE>SHOW</CODE>, <CODE>DESCRIBE</CODE>,
<CODE>EXPLAIN</CODE>).</P>

<P><CODE>mysql_use_result()</CODE> инициализирует поиск набора результата, но
фактически не читает набор результатов подобно
<CODE>mysql_store_result()</CODE>. Вместо этого, каждая строка должна быть
получена индивидуально, делая обращения к <CODE>mysql_fetch_row()</CODE>. Это
читает результат запроса непосредственно с сервера без того, чтобы сохранить
его во временной таблице или локальном буфере, что несколько быстрее и
использует намного меньше памяти, чем <CODE>mysql_store_result()</CODE>.
Пользователь распределит память только для текущей (актуальной) строки и
буфера связей, который может сам вырасти до <CODE>max_allowed_packet</CODE>.
</P>

<P>С другой стороны, Вы не должны использовать
<CODE>mysql_use_result()</CODE> если Вы делаете много обработки для каждой
строки на стороне пользователя, или если вывод послан экрану, на котором
пользователь может напечатать <CODE>^S</CODE> (приостановить показ данных).
Это свяжет сервер и не даст другим потокам модифицировать любые таблицы, из
которых выбираются данные.</P>

<P>При использовании <CODE>mysql_use_result()</CODE> Вы должны выполнять
<CODE>mysql_fetch_row()</CODE> до тех пор, пока значение не вернется значение
<CODE>NULL</CODE>, иначе невыбранные строки будут возвращены как часть набора
результатов для Вашего следующего запроса. API выдает ошибку
"<CODE>Commands out of sync; You can't run this command now</CODE>", если Вы
забываете про это!</P>

<P>Вы не можете использовать <CODE>mysql_data_seek()</CODE>,
<CODE>mysql_row_seek()</CODE>, <CODE>mysql_row_tell()</CODE>,
<CODE>mysql_num_rows()</CODE> или <CODE>mysql_affected_rows()</CODE> с
результатом, возвращенным из <CODE>mysql_use_result()</CODE>, и при этом Вы
не можете выдавать другие запросы, пока не закончится
<CODE>mysql_use_result()</CODE>. Однако, после того, как Вы выбрали все
строки, <CODE>mysql_num_rows()</CODE> точно возвратит число выбранных строк.
</P>

<P>Вы должны вызвать <CODE>mysql_free_result()</CODE> как только Вы закончили
с этим набором результатов.</P>

<H4>Возвращаемые значения</H4>
<P>Структура <CODE>TMYSQL_RES</CODE>. <CODE>NULL</CODE>,
если произошла ошибка.</P>

<H4>Ошибки</H4>
<DL COMPACT>
<DT><CODE>CR_COMMANDS_OUT_OF_SYNC</CODE>
<DD>Команды были выполнены в неподходящем порядке.
<DT><CODE>CR_OUT_OF_MEMORY</CODE>
<DD>Не хватило памяти.
<DT><CODE>CR_SERVER_GONE_ERROR</CODE>
<DD>Сервер MySQL занят.
<DT><CODE>CR_SERVER_LOST</CODE>
<DD>Подключение было потеряно в течение запроса.
<DT><CODE>CR_UNKNOWN_ERROR</CODE>
<DD>Произошла неизвестная ошибка.</DL>

<H3><A NAME="Delphi_API_problems">6.4 Общие вопросы и проблемы
при использовании API</A></H3>

<H4><A NAME="NULL_mysql_store_result">6.4.1 Почему при успехе
<CODE>mysql_query()</CODE> вызов <CODE>mysql_store_result()</CODE>
иногда возвращает <CODE>NULL?</CODE></A></H4>

<P>Когда это случается, это означает, что одно из следующего произошло:</P>
<UL><LI>Имелся сбой <CODE>malloc()</CODE> (например, если набор результатов
был слишком большой).
<LI>Данные не могли прочитаться (произошла ошибка на подключении).
<LI>Запрос не возвратил никакие данные (например, это был
<CODE>INSERT</CODE>, <CODE>UPDATE</CODE> или <CODE>DELETE</CODE>).</UL>

<P>Вы можете всегда проверить, должна или нет инструкция произвести непустой
результат, вызывая <CODE>mysql_field_count()</CODE>. Если
<CODE>mysql_field_count()</CODE> вернет ноль, результат пуст, и последний
запрос был инструкцией, которая не возвращает значения (например,
<CODE>INSERT</CODE> или <CODE>DELETE</CODE>). Если
<CODE>mysql_field_count()</CODE> вернет не ноль, инструкция должна была
произвести не пустой результат.</P>

<P>Вы можете проверить наличие ошибки вызовом <CODE>mysql_error()</CODE> или
<CODE>mysql_errno()</CODE>.</P>

<H4><A NAME="Query_results">6.4.2 Какой результаты я могу
получить из запроса?</A></H4>
<P>В дополнение к набору результатов, возвращенному запросом, Вы можете также
получать следующую информацию:</P>

<UL><LI><CODE>mysql_affected_rows()</CODE> возвращает число строк, на которые
воздействует последний запрос при выполнении <CODE>INSERT</CODE>,
<CODE>UPDATE</CODE> или <CODE>DELETE</CODE>. Исключительная ситуация:
<CODE>DELETE</CODE> используется без предложения <CODE>WHERE</CODE>, таблица
будет пересоздана пустой, что намного быстрее! В этом случае
<CODE>mysql_affected_rows()</CODE> возвращает ноль для числа записей.

<LI><CODE>mysql_num_rows()</CODE> возвращает число строк в наборе
результатов. При использовании <CODE>mysql_store_result()</CODE>
<CODE>mysql_num_rows()</CODE> может быть вызван, как только отработает
<CODE>mysql_store_result()</CODE>. При использовании
<CODE>mysql_use_result()</CODE> <CODE>mysql_num_rows()</CODE> может быть
вызван только после того, как Вы выбрали все строки с помощью
<CODE>mysql_fetch_row()</CODE>.

<LI><CODE>mysql_insert_id()</CODE> возвращает ID, сгенерированный последним
запросом, который вставил строку в таблицу с индексом
<CODE>AUTO_INCREMENT</CODE>. Подробности в разделе
"6.3.126 <CODE>mysql_insert_id()</CODE>".

<LI>Некоторые запросы (<CODE>LOAD DATA INFILE ...</CODE>, <CODE>INSERT INTO
... SELECT ...</CODE>, <CODE>UPDATE</CODE>) возвращают дополнительную
информацию. Результат возвращен через <CODE>mysql_info()</CODE>.
<CODE>mysql_info()</CODE> вернет <CODE>NULL</CODE> если не имеется
никакой дополнительной информации.</UL>

<H4><A NAME="Getting_unique_ID">6.4.3 Как я могу получить уникальный ID для
последней вставленной строки?</A></H4>
<P>Если Вы вставляете запись в таблицу, содержащую столбец, который имеет
атрибут <CODE>AUTO_INCREMENT</CODE>, Вы можете получать последнее значение
ID вызовом <CODE>mysql_insert_id()</CODE>.</P>

<P>Вы можете также получать ID, используя функцию
<CODE>LAST_INSERT_ID()</CODE> в строке запроса, которую Вы передаете
<CODE>mysql_query()</CODE>.</P>

<P>Вы можете проверять, используется ли индекс <CODE>AUTO_INCREMENT</CODE>,
выполняя следующий код. Это также проверит, был ли запрос <CODE>INSERT</CODE>
с индексом <CODE>AUTO_INCREMENT</CODE>:</P>
<PRE>
if (mysql_error(pmysql)[0]=0) &#38;& (mysql_num_fields(result)=0) &#38;&
   (mysql_insert_id(pmysql) != 0) then begin
   used_id := mysql_insert_id(pmysql);
end;
</PRE>

<P>Недавно сгенерированный ID хранится на сервере с привязкой к подключению.
Это не будет изменено другим пользователем. Это не будет даже изменено, если
Вы модифицируете другой столбец <CODE>AUTO_INCREMENT</CODE> не со специальным
значением (то есть значением, которое не <CODE>NULL</CODE> и не
<CODE>0</CODE>).</P>

<P>Если Вы хотите использовать ID, который был сгенерирован для одной
таблицы и вставлять его во вторую таблицу, Вы можете использовать инструкции
SQL подобно этому:
<PRE>
INSERT INTO foo (auto,text)
  VALUES(NULL,'text');              # generate ID by inserting NULL
INSERT INTO foo2 (id,text)
  VALUES(LAST_INSERT_ID(),'text');  # use ID in second table
</PRE></P>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</HTML>
