<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
   <META NAME="Author" CONTENT="Alexey V. Pautov">
   <title>Глава 5. Сохраненные процедуры и функции</title>
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
      alink="#0000FF">

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>


<h2><a name="stored-procedures"></a>
Глава 5. Сохраненные процедуры и функции</h2>
<p>Сохраненные подпрограммы (процедуры и функции) обеспечиваются в MySQL 5.0.
Сохраненная процедура представляет собой набор инструкций SQL, которые могут
быть сохранены на сервере. Если это было выполнено, клиентура не должна
хранить индивидуальные инструкции, а может обратиться к сохраненной процедуре.
</p>

<p>Некоторые ситуации, где сохраненные подпрограммы могут
быть особенно полезны:</p>
<ul type="disc"><li><p>Когда много прикладных программ написано на различных
языках или работают на различных платформах, но должны выполнить те же самые
операции с базой данных.</p></li>

<li><p>Когда защита первостепенна. Банки, например, используют сохраненные
процедуры и функции для всех общих операций. Это обеспечивает
непротиворечивую и безопасную среду, и подпрограммы могут гарантировать, что
каждая операция правильно регистрируется. В такой установке прикладные
программы (и их пользователи!) не имеют никакого доступа к таблицам базы
данных непосредственно, а могут только выполнять специфические сохраненные
подпрограммы. То есть, при всем желании, не смогут приписать лишний ноль...
</p></li></ul>

<p>Сохраненные подпрограммы могут обеспечивать улучшенную эффективность,
потому что меньшее количество информации должно быть переслано между клиентом
и сервером. Правда это увеличивает нагрузку на сервер, поскольку большее
количество работы выполнено на сервере. Рассмотрите это, если много машин
пользователя (типа Web-серверов) обслуживаются только одним
сервером базы данных.</p>

<p>Сохраненные подпрограммы также позволяют Вам иметь библиотеки функций
непосредственно на сервере. Это свойство, общедоступное в современных языках
прикладных программ, которые позволяют такой проект внутренне (например,
используя классы). Использование этих свойств языка прикладной программы
пользователя полезно для программиста даже вне контекста
использования базы данных.</p>

<p>MySQL следует синтаксису SQL:2003 для сохраненных подпрограмм, который
также используется в IBM DB2.</p>
<p>MySQL-реализация сохраненных подпрограмм все еще доделывается. Весь
синтаксис, описанный в этой главе, обеспечивается, а любые ограничения и
расширения зарегистрированы где надо.</p>

<p>Рекурсивные сохраненные процедуры заблокированы по умолчанию, но могут
допускаться на сервере, устанавливая переменную
<code>max_sp_recursion_depth</code> в значение, отличное от нуля. Сохраненные
функции не могут быть рекурсивными.</p>

<h2><a name="stored-procedure-privileges"></a>5.1. Сохраненные подпрограммы
и таблицы предоставления привилегий</h2>
<p>Сохраненные подпрограммы требуют таблицы <code>proc</code> в базе данных
<code>mysql</code>. Эта таблица создана в течение процедуры установки MySQL
5.0. Если Вы наращиваете вычислительные возможности до MySQL 5.0 из более
ранней версии, убедитесь, что модифицировали Ваши таблицы предоставления
привилегий, чтобы удостовериться, что таблица <code>proc</code> существует.
</p>

<p>Сервер управляет таблицей <code>mysql.proc</code> в ответ на инструкции,
которые создают, изменяют или удаляют сохраненные подпрограммы. Это значит,
что сервер не обратит внимания на ручное манипулирование этой таблицей.</p>

<p>Начиная с MySQL 5.0.3, система предоставления берет сохраненные
подпрограммы во внимание следующим образом:</p>
<ul type="disc"><li><p>Привилегия <code>CREATE ROUTINE</code> необходима,
чтобы создать сохраненные подпрограммы.</p></li>

<li><p>Привилегия <code>ALTER ROUTINE</code> необходима, чтобы изменять или
удалять сохраненные подпрограммы. Эта привилегия предоставляется
автоматически создателю подпрограммы.</p></li>

<li><p>Привилегия <code>EXECUTE</code> необходима, чтобы выполнить
сохраненные подпрограммы. Эта привилегия предоставляется автоматически
создателю подпрограммы. Также, по умолчанию характеристика
<code>SQL SECURITY</code> для подпрограммы выставлена в <code>DEFINER</code>,
что разрешает пользователям, которые имеют доступ к базе данных, с которой
подпрограмма связана, выполнить эту подпрограмму.</p></li></ul>

<h2><a name="stored-procedure-syntax"></a>5.2. Синтаксис хранимых процедур
</h2>
<p>Сохраненная подпрограмма является процедурой или функцией. Сохраненные
подпрограммы созданы командами <code>CREATE PROCEDURE</code> и <code>CREATE
FUNCTION</code>. Процедура вызывается, используя инструкцию
<code>CALL</code>, и может только передавать обратные значения, используя
переменные вывода. Функция может быть названа точно так же, как и любая
другая функция языка (то есть, вызывая имя функции), и может возвращать
скалярное значение. Сохраненные подпрограммы, разумеется, могут вызывать
другие сохраненные подпрограммы.</p>

<p>Начиная с MySQL 5.0.1, сохраненная процедура или функция хранится не как
попало, а связана со специфической базой данных.
Это имеет несколько импликаций:</p>

<ul type="disc"><li><p>Когда подпрограмма вызывается, выполняется неявный
вызов <code>USE <code>db_name</code></code> (и отменяется, когда подпрограмма
завершается). Инструкции <code>USE</code> внутри
сохраненных подпрограмм отвергнуты.</p></li>

<li><p>Вы можете квалифицировать стандартные имена с именем базы данных. Это
может использоваться, чтобы обратиться к подпрограмме, которая не в текущей
(актуальной) базе данных. Например, чтобы вызвать сохраненную процедуру
<code>p</code> или функцию <code>f</code>, которые связаны с базой данных
<code>test</code>, Вы можете скомандовать <code>CALL
test.p()</code> или <code>test.f()</code>.</p></li>
<li><p>Когда база данных удалена, все сохраненные подпрограммы, связанные с
ней, также удалены.</p></li></ul>

<p>В MySQL 5.0.0 сохраненные подпрограммы глобальны и не связаны с базой
данных. Они наследуют заданную по умолчанию базу данных с вызывающего
оператора. Если внутри подпрограммы выполнено <code>USE <code>db_name</code>
</code>, первоначальная заданная по умолчанию база данных восстановлена
после стандартного выхода.</p>

<p>MySQL поддерживает самое полезное расширение, которое позволяет
использование регулярных инструкций <code>SELECT</code> (то есть, без того,
чтобы использовать курсоры или локальные переменные) внутри сохраненной
процедуры. Набор результатов такого запроса просто послан непосредственно
пользователю. Многократные инструкции <code>SELECT</code> генерируют много
наборов результатов, так что пользователь должен применять библиотеку
клиентов MySQL, что поддерживает много наборов результатов. Это означает, что
библиотека должна быть от MySQL не ниже 4.1. Пользователь должен также
определить опцию <code>CLIENT_MULTI_STATEMENTS</code>, когда соединяется. Для
программ на C, это может быть выполнено функцией
<code>mysql_real_connect()</code> из C API.</p>
<p>Следующие разделы описывают синтаксис, используемый, чтобы создавать,
изменять, удалять и вызвать сохраненные процедуры и функции.</p>

<h3><a name="create-procedure"></a>5.2.1. Синтаксис <code>CREATE
PROCEDURE</code> и <code>CREATE FUNCTION</code></h3>
<pre>
CREATE
   [DEFINER = { <code>user</code> | CURRENT_USER }]
   PROCEDURE <code>sp_name</code> ([<code>proc_parameter</code>[,...]])
   [<code>characteristic</code> ...] <code>routine_body</code>

CREATE
   [DEFINER = { <code>user</code> | CURRENT_USER }]
   FUNCTION <code>sp_name</code> ([<code>func_parameter</code>[,...]])
   RETURNS <code>type</code>
   [<code>characteristic</code> ...] <code>routine_body</code>

<code>proc_parameter</code>:
   [IN | OUT | INOUT] <code>param_name</code> <code>type</code>

<code>func_parameter</code>:
<code>param_name</code> <code>type</code>

<code>type</code>:
<code>Любой допустимый тип данных MySQL</code>

<code>characteristic</code>:
LANGUAGE SQL | [NOT] DETERMINISTIC
   | {CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA}
   | SQL SECURITY {DEFINER | INVOKER}
   | COMMENT '<code>string</code>'

<code>routine_body</code>:
<code>Допустимая инструкция процедуры SQL</code>
</pre>

<p>Эти инструкции создают сохраненные подпрограммы. С MySQL 5.0.3, чтобы
использовать их, необходимо иметь привилегию <code>CREATE ROUTINE</code>.
Если двоичная регистрация допускается, эти инструкции могут также требовать
привилегии <code>SUPER</code>. MySQL автоматически предоставляет создателю
привилегии <code>ALTER ROUTINE</code> и <code>EXECUTE</code>.</p>

<p>По умолчанию, подпрограмма связана с заданной по умолчанию базой данных.
Чтобы сопоставить подпрограмму явно с другой базой данных, определите имя как
<code>db_name.sp_name</code>, когда Вы создаете ее.</p>

<p>Если стандартное имя совпадает с именем встроенной функции SQL, Вы должны
использовать пробел между именем и следующей круглой скобкой при определении
подпрограммы или происходит синтаксическая ошибка. Это также истина, когда Вы
вызываете подпрограмму позже. По этой причине, мы предлагаем избегать
многократно использовать имена существующих функций SQL для Ваших
собственных сохраненных подпрограмм.</p>

<p>SQL-режим <code>IGNORE_SPACE</code> применяется к встроенным функциям, но
не к сохраненным подпрограммам. Всегда допустимо иметь пробелы после
стандартного имени, независимо от того, допускается
ли <code>IGNORE_SPACE</code>.</p>

<p>Список параметров, включенный внутри круглых скобок, должен всегда
присутствовать. Если не имеется никаких параметров, должен использоваться
пустой список параметров <code>()</code>.</p>

<p>Каждый параметр может быть объявлен, чтобы использовать любой тип
достоверных данных, за исключением того, что не может
использоваться атрибут <code>COLLATE</code>.</p>

<p>Каждый параметр представляет собой по умолчанию параметр <code>IN</code>.
Чтобы определять иное для параметра, используйте ключевое слово
<code>OUT</code> или <code>INOUT</code> перед именем параметра.</p>

<p><span class="bold"><strong>Обратите внимание</strong></span>: определение
параметра как <code>IN</code>, <code>OUT</code> или <code>INOUT</code>
допустимо только для <code>PROCEDURE</code>! Параметры <code>FUNCTION</code>
всегда расцениваются как параметры <code>IN</code>.</p>

<p>Параметр <code>IN</code> передает значение в процедуру. Процедура могла бы
изменять значение, но модификация не видима вызывающему оператору, когда
процедура завершается. Параметр <code>OUT</code> передает значение из
процедуры обратно вызывающему оператору. Начальное значение внутри процедуры
<code>NULL</code>, и значение видимо вызывающему оператору, когда процедура
завершается. Параметр <code>INOUT</code> инициализирован вызывающим
оператором, может изменяться процедурой, и любое изменение, сделанное
процедурой, видимо вызывающему оператору, когда процедура завершается.</p>

<p>Для каждого параметра <code>OUT</code> или <code>INOUT</code> передайте
определяемую пользователем переменную так, чтобы Вы могли получать значение,
когда процедура завершается. Если Вы вызываете процедуру изнутри другой
сохраненной процедуры или функции, Вы можете также передавать стандартный
параметр или локальную стандартную переменную как параметр
<code>IN</code> или <code>INOUT</code>.</p>

<p>Предложение <code>RETURNS</code> может быть определено только для
<code>FUNCTION</code>, для которой это является обязательным. Это указывает
тип возврата функции, и функциональное тело должно содержать
инструкцию <code>RETURN <code>value</code></code>.</p>

<p><code>routine_body</code> состоит из допустимой инструкции процедуры SQL.
Это может быть простая инструкция типа <code>SELECT</code> или <code>INSERT
</code>, либо это может быть составная инструкция, использующая
<code>BEGIN</code> и <code>END</code>. Синтаксис составного оператора описан
в разделе "<a href="#begin-end">5.2.5. Синтаксис
составного оператора <code>BEGIN ... END</code></a>". Составные инструкции
могут содержать объявления, циклы и другие инструкции управляющей структуры.
Синтаксис для этих инструкций описан позже в этой главе. Некоторые инструкции
не позволяются в сохраненных подпрограммах.</p>

<p>Инструкция <code>CREATE FUNCTION</code> использовалась в более ранних
версиях MySQL, чтобы поддерживать UDFs (user-defined functions). UDF
продолжает обеспечиваться, даже с существованием сохраненных функций. UDF
может быть расценен как внешняя сохраненная функция. Однако, обратите
внимание, что сохраненные функции совместно используют их
пространство имен с UDF.</p>

<p>Процедура или функция рассматривается как детерминированная (<span
class="quote">deterministic</span>), если она всегда производит тот же самый
результат для тех же самых входных параметров, или недетерминированная
(<span class="quote">not deterministic</span>) в противном случае. Если при
определении функции не задано <code>DETERMINISTIC</code> или <code>NOT
DETERMINISTIC</code>, берется значение по умолчанию <code>NOT DETERMINISTIC
</code>.</p>

<p>Подпрограмма, которая содержит функцию <code>NOW()</code> (или ее
синонимы) или <code>RAND()</code> не детерминирована, но она все еще может
быть безопасна для репликации. Для <code>NOW()</code> двоичный файл
регистрации включает timestamp и все копирует правильно. <code>RAND()</code>
также копирует правильно, пока это вызывается только один раз внутри
подпрограммы. Вы можете рассматривать стандартное выполнение timestamp и
начальное значение случайного числа как неявные вводы, которые являются
идентичными на главном и подчиненном узлах для репликации.</p>

<p>В настоящее время характеристика <code>DETERMINISTIC</code> принята, но
еще не используется оптимизатором. Однако, если двоичная регистрация
допускается, эта характеристика воздействует на то, которые стандартные
определения MySQL принимает.</p>

<p>Несколько характеристик обеспечивают информацию относительно характера
использования данных подпрограммой. <code>CONTAINS SQL</code> указывает, что
подпрограмма не содержит инструкции, которые читают или записывают данные.
<code>NO SQL</code> указывает, что подпрограмма не содержит никаких
инструкций SQL. <code>READS SQL DATA</code> указывает, что подпрограмма
содержит инструкции, которые читают данные, но не инструкции, чтобы те данные
записывать. <code>MODIFIES SQL DATA</code> указывает, что подпрограмма
содержит инструкции, которые могут записывать данные. <code>CONTAINS
SQL</code> значение по умолчанию, если ни одна из этих характеристик не дана
явно. Эти характеристики только консультативные. Сервер не использует их,
чтобы ограничить то, какие виды инструкций подпрограмме позволено выполнить.
</p>

<p>Характеристика <code>SQL SECURITY</code> может использоваться, чтобы
определить, должна ли подпрограмма быть выполнена, используя разрешения
пользователя, который создает подпрограмму, или пользователя, который ее
вызывает. Значение по умолчанию: <code>DEFINER</code>. Это свойство ново в
SQL:2003. Создатель или исполнитель должен иметь разрешение обратиться к базе
данных, с которой подпрограмма связана. Начиная с MySQL 5.0.3, необходимо
иметь привилегию <code>EXECUTE</code>, чтобы выполнить подпрограмму.
Пользователь, который должен иметь эту привилегию, является создателем или
исполнителем в зависимости от того, как установлена
характеристика <code>SQL SECURITY</code>.</p>

<p>Факультативное предложение <code>DEFINER</code> определяет логин MySQL,
который нужно использовать при проверке привилегий доступа в стандартном
времени выполнения для подпрограмм, которые имеют характеристику <code>SQL
SECURITY DEFINER</code>. Предложение <code>DEFINER</code> было
добавлено в MySQL 5.0.20.</p>

<p>Если дано значение <code>user</code>, это должно быть логином MySQL в
формате <code>'<code>user_name</code>'@'<code>host_name</code>'</code>
(тот же самый формат используется в инструкции <code>GRANT</code>). Параметры
<code>user_name</code> и <code>host_name</code> обязательны.
<code>CURRENT_USER</code> также может быть дан как
<code>CURRENT_USER()</code>. Заданное по умолчанию для <code>DEFINER</code>:
пользователь, который выполняет <code>CREATE PROCEDURE</code>, <code>CREATE
FUNCTION</code> или инструкцию (аналогично <code>DEFINER=CURRENT_USER</code>).
</p>

<p>Если Вы определяете предложение <code>DEFINER</code>, Вы не можете
устанавливать значение к любому логину (только к Вашему собственному), если
Вы не имеете привилегию <code>SUPER</code>. Эти правила определяют допустимые
значения пользователя <code>DEFINER</code>:</p>

<ul type="disc"><li><p>Если Вы не имеете привилегию <code>SUPER</code>,
единственное допустимое значение <code>user</code>: Ваш собственный логин,
определенный буквально или используя <code>CURRENT_USER</code>. Вы не можете
устанавливать <code>DEFINER</code> к некоторому другому логину.</p></li>

<li><p>Если Вы имеете привилегию <code>SUPER</code>, Вы можете определять
любой синтаксически допустимый логин. Если он фактически не существует,
будет сгенерировано предупреждение.</p>

<p>Хотя возможно создать подпрограммы с несуществующим значением
<code>DEFINER</code>, ошибка происходит, если подпрограмма выполняется с
привилегиями <code>DEFINER</code>, но сам <code>DEFINER</code> не существует
во время выполнения.</p></li></ul>

<p>MySQL сохраняет установку переменной системы <code>sql_mode</code>,
которая была во время создания подпрограммы, и всегда выполняет подпрограмму
именно с этой установкой.</p>

<p>Когда подпрограмма вызывается, выполняется неявное
<code>USE <code>db_name</code></code> (и отменяется по завершении).
Инструкции <code>USE</code> внутри сохраненных подпрограмм отвергнуты.</p>

<p>Начиная с MySQL 5.0.18, сервер использует тип данных стандартного
параметра или функционального возвращаемого значения следующим образом. Эти
правила также относятся к локальным стандартным переменным,
созданным инструкцией <code>DECLARE</code>.</p>

<ul type="disc"><li><p>Назначения проверены на предмет несоответствия типов
данных и переполнение. Преобразование и проблемы переполнения приводит к
предупреждениям или ошибкам в строгом режиме.</p></li>

<li><p>Для символьных типов данных, если имеется предложение
<code>CHARACTER SET</code> в объявлении, используются определенный набор
символов и заданное по умолчанию объединение. Если не имеется никакого такого
предложения, используются наборы символов базы данных и объединение, которые
были актуальными во время написания подпрограммы (они заданы значениями
переменных системы <code>character_set_database</code> и
<code>collation_database</code>). Атрибут <code>COLLATE</code> не
обеспечивается. Это включает использование <code>BINARY</code>, потому что в
этом контексте <code>BINARY</code> определяет двоичное
объединение набора символов.</p></li>

<li><p>Только скалярные значения могут быть назначены к параметрам или
переменным. Например, инструкция типа
<code>SET x=(SELECT 1,2)</code> глубоко ошибочна.</p></li></ul>

<p>До MySQL 5.0.18 параметры, возвращаемые значения и локальные переменные
обрабатываются как элементы в выражениях, и подчиненны автоматическому
(тихому) преобразованию и усечению. Сохраненные функции игнорируют
установку <code>sql_mode</code>.</p>

<p>Предложение <code>COMMENT</code> представляет собой очередное расширение
MySQL и может использоваться, чтобы описать сохраненную подпрограмму. Эта
информация отображается командами <code>SHOW CREATE PROCEDURE</code> и
<code>SHOW CREATE FUNCTION</code>.</p>

<p>MySQL позволяет подпрограммам содержать инструкции DDL, например,
<code>CREATE</code> и <code>DROP</code>. MySQL также позволяет сохраненным
процедурам (но не сохраненным функциям) содержать SQL-инструкции транзакций,
типа <code>COMMIT</code>. Сохраненные функции не могут содержать инструкции,
которые делают явное или неявное завершение транзакции или обратную
перемотку. Поддержка для этих инструкций не требуется стандартом SQL, который
четко заявляет, что каждый поставщик СУБД может решать, позволять ли это.</p>

<p>Сохраненные подпрограммы не могут использовать
<code>LOAD DATA INFILE</code>.</p>
<p>Инструкции, которые возвращают набор результатов, не могут использоваться
внутри сохраненной функции. Это включает инструкции <code>SELECT</code>,
которые не используют <code>INTO</code>, чтобы выбрать значения столбца в
переменные, инструкции <code>SHOW</code> и другие инструкции, типа
<code>EXPLAIN</code>. Для инструкций, которые могут быть заданы при
функциональном определении, но возвращают набо результатов, произойдет
ошибочка <code>Not allowed to return a result set from a function</code>
(<code>ER_SP_NO_RETSET_IN_FUNC</code>). Для инструкций, которые могут быть
определены только во время выполнения, происходит ошибка <code>PROCEDURE %s
can't return a result set in the given context</code>
(<code>ER_SP_BADSELECT</code>).</p>

<p><span class="bold"><strong>Обратите внимание</strong></span>: до MySQL
5.0.10 сохраненные функции, созданные с <code>CREATE FUNCTION</code>, не
должны содержать ссылки к таблицам, с ограниченными исключительными
ситуациями. Они могут включать некоторые инструкции <code>SET</code>, которые
содержат ссылки на таблицы, например, <code>SET a:= (SELECT
MAX(id) FROM t)</code>, и инструкции <code>SELECT</code>, которые выбирают
значения непосредственно в переменные, например,
<code>SELECT i INTO var1 FROM t</code>.</p>

<p>Следующее показывает пример простой сохраненной процедуры, которая
использует параметр <code>OUT</code>. Пример использует команду
<code>delimiter</code> клиента <span><strong>mysql</strong></span>, чтобы
изменить операторный разделитель с <code>;</code> на <code>//</code> в то
время как процедура определяется. Это позволяет использовать разделитель
<code>;</code> в теле процедуры, которое будет передано на сервер.</p>

<pre>
mysql&gt; delimiter //
mysql&gt; CREATE PROCEDURE simpleproc (OUT param1 INT)
    -&gt; BEGIN
    -&gt;   SELECT COUNT(*) INTO param1 FROM t;
    -&gt; END;
    -&gt; //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; delimiter ;
mysql&gt; CALL simpleproc(@a);
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT @a;
+------+
| @a   |
+------+
| 3    |
+------+
1 row in set (0.00 sec)
</pre>

<p>При использовании команды <code>delimiter</code>, Вы должны избежать
использования наклонной черты влево (<code>\</code>), потому что это
escape-символ для MySQL.</p>

<p>Следующее представляет собой пример функции, которая берет параметр,
выполняет операцию, использующую функцию SQL, и возвращает результат. В этом
случае, ненужно использовать разделитель, потому что функциональное
определение не содержит никакой внутренней <code>;</code>, значит точку с
запятой можно использовать как операторный разделитель:</p>

<pre>
mysql&gt; CREATE FUNCTION hello (s CHAR(20)) RETURNS CHAR(50)
    -&gt; RETURN CONCAT('Hello, ',s,'!');
Query OK, 0 rows affected (0.00 sec)

mysql&gt; SELECT hello('world');
+----------------+
| hello('world') |
+----------------+
| Hello, world!  |
+----------------+
1 row in set (0.00 sec)
</pre>

<p>Сохраненная функция возвращает значение типа данных, определенного в
предложении <code>RETURNS</code>. Если инструкция <code>RETURN</code>
возвращает значение иного типа, значение приведено к соответствующему типу.
Например, если функция возвращает значение <code>ENUM</code> или
<code>SET</code>, но инструкция <code>RETURN</code> возвращает целое число,
значение, возвращенное из функции: строка для соответствующего
<code>ENUM</code>-члена набора элементов <code>SET</code>.</p>

<h3><a name="alter-procedure"></a>5.2.2. Синтаксис <code>ALTER
PROCEDURE</code> и <code>ALTER FUNCTION</code></h3>
<pre>
ALTER {PROCEDURE | FUNCTION} <code>sp_name</code>
      [<code>characteristic</code> ...]

<code>characteristic</code>:
{CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }
   | SQL SECURITY { DEFINER | INVOKER }
   | COMMENT '<code>string</code>'
</pre>

<p>Эта инструкция может использоваться, чтобы изменить характеристики
сохраненной процедуры или функции. Начиная с MySQL 5.0.3, Вы должны иметь
привилегию <code>ALTER ROUTINE</code> для подпрограммы. Эта привилегия
предоставляется автоматически стандартному создателю. Если двоичная
регистрация допускается, эта инструкция могла бы также требовать привилегии
<code>SUPER</code>. Больше чем одно изменение может быть определено в команде
<code>ALTER PROCEDURE</code> или <code>ALTER FUNCTION</code>.</p>

<h3><a name="drop-procedure"></a>5.2.3. Синтаксис <code>DROP
PROCEDURE</code> и <code>DROP FUNCTION</code></h3>
<pre>
DROP {PROCEDURE | FUNCTION} [IF EXISTS] <code>sp_name</code>
</pre>

<p>Эта инструкция используется, чтобы удалить сохраненную процедуру или
функцию. То есть определенная подпрограмма будет удалена с сервера. Начиная с
MySQL 5.0.3, Вы должны иметь привилегию <code>ALTER ROUTINE</code> для
подпрограммы. Такая привилегия предоставляется автоматически создателю.</p>

<p>Предложение <code>IF EXISTS</code> является расширением MySQL. Это
предотвращает ошибку, если процедура или функция не существует. Будет
произведено предупреждение, которое может просматриваться с помощью
команды <code>SHOW WARNINGS</code>.</p>

<h3><a name="call"></a>5.2.4. Синтаксис команды <code>CALL</code></h3>
<pre>
CALL <code>sp_name</code>([<code>parameter</code>[,...]])
</pre>
<p>Инструкция <code>CALL</code> вызывает процедуру, которая была определена
предварительно, с помощью команды <code>CREATE PROCEDURE</code>.</p>

<p><code>CALL</code> может передавать обратно значения к параметрам
использования вызывающего оператора, которые объявлены как <code>OUT</code>
или <code>INOUT</code>. Это также вернет число строк, на которые
воздействовал запрос, это же значение программа пользователя может получать в
уровне SQL, вызывая функцию <code>ROW_COUNT()</code> или из C API функцией
<code>mysql_affected_rows()</code>.</p>

<p>Чтобы вернуть значение из процедуры, использующей параметр
<code>OUT</code> или <code>INOUT</code>, передайте параметр посредством
переменной пользователя, и затем проверьте значение переменной после возврата
из процедуры. Если Вы вызываете процедуру изнутри другой сохраненной
процедуры или функции, Вы можете также передавать стандартный параметр или
локальную стандартную переменную как параметр <code>IN</code> или
<code>INOUT</code>. Для параметра <code>INOUT</code> инициализируйте
значение перед его передачей процедуре. Следующая процедура имеет параметр
<code>OUT</code>, который процедура устанавливает в текущую (актуальную)
версию сервера, и значение <code>INOUT</code>, которое процедура увеличивает:
</p>

<pre>
CREATE PROCEDURE p (OUT ver_param VARCHAR(25), INOUT incr_param INT)
BEGIN
  # Set value of OUT parameter
  SELECT VERSION() INTO ver_param;
  # Increment value of INOUT parameter
  SET incr_param = incr_param + 1;
END;
</pre>

<p>Перед вызовом процедуры, инициализируйте переменную, которая будет
передана как параметр <code>INOUT</code>. После вызова процедуры, значения в
двух переменных будут установлены или изменены:</p>

<pre>
mysql&gt; SET @increment = 10;
mysql&gt; CALL p(@version, @increment);
mysql&gt; SELECT @version, @increment;
+------------+------------+
| @version   | @increment |
+------------+------------+
| 5.0.25-log | 11         |
+------------+------------+
</pre>

<p>Если Вы пишете программы на C, которые выполняют сохраненные процедуры с
инструкцией SQL <code>CALL</code>, Вы должны установить флажок
<code>CLIENT_MULTI_RESULTS</code>, когда Вы вызываете
<code>mysql_real_connect()</code>, либо установить
<code>CLIENT_MULTI_STATEMENTS</code>. Это потому, что каждый
<code>CALL</code> возвращает результат, чтобы указать состояние обращения, в
дополнение к любым наборам результатов, которые могли бы быть возвращены
инструкциями, выполненными внутри процедуры. Чтобы обрабатывать результат
инструкции <code>CALL</code>, используйте цикл, который вызывает
<code>mysql_next_result()</code> чтобы определить, имеется ли
большее количество результатов.</p>

<h3><a name="begin-end"></a>5.2.5. Синтаксис составного оператора
<code>BEGIN ... END</code></h3>
<pre>
   [<code>begin_label</code>:] BEGIN
   [<code>statement_list</code>]
END [<code>end_label</code>]
</pre>

<p>Синтаксис <code>BEGIN ... END</code> используется для записи составных
инструкций, которые могут появляться внутри сохраненных подпрограмм и
триггеров. Составная инструкция может содержать много инструкций, взятых в
ключевые слова <code>BEGIN</code> и <code>END</code>. Здесь
<code>statement_list</code> представляет список инструкций. Каждая инструкция
внутри <code>statement_list</code> должна быть завершена операторным
разделителем точкой с запятой (<code>;</code>). Обратите внимание, что список
<code>statement_list</code> факультативный, что означает, что пустая
составная инструкция (<code>BEGIN END</code>) допустима.</p>

<p>Использование многих инструкций требует, чтобы пользователь был способен
послать операторные строки, содержащие операторный разделитель <code>;</code>.
Это обработано в клиенте командной строки <span><strong>mysql</strong></span>
командой <code>delimiter</code>. Изменение разделителя конца инструкции
<code>;</code> (например, на <code>//</code>) позволяет <code>;</code>
использоваться в стандартном теле.</p>

<p>Составная инструкция может быть помечена. <code>end_label</code>
не может быть дан, если <code>begin_label</code> также не присутствует.
Если оба присутствуют, они должны быть те же самые.</p>

<p>Факультативное предложение <code>[NOT] ATOMIC</code> еще не
обеспечивается. Это означает, что никакие точки сохранения транзакций не
установлены в начале блока команды, и предложение <code>BEGIN</code>,
используемое в этом контексте не имеет никакого эффекта на
текущей (актуальной) транзакции.</p>

<h3><a name="declare"></a>5.2.6. Синтаксис <code>DECLARE</code></h3>
<p>Инструкция <code>DECLARE</code> используется, чтобы определить различные
элементы, локальные для подпрограммы:</p>

<ul type="disc"><li><p>Локальные переменные. Подробности в разделе
"<a href="#variables-in-stored-procedures">5.2.7.
Переменные в сохраненных подпрограммах</a>".</p></li>

<li><p>Условия и драйверы. Подробности в разделе
"<a href="#conditions-and-handlers">5.2.8. Условия и драйверы
</a>".</p></li>
<li><p>Курсоры. Подробности в разделе
"<a href="#cursors">5.2.9. Курсоры</a>".</p></li></ul>

<p>Инструкции <code>SIGNAL</code> и <code>RESIGNAL</code> в настоящее
время не обеспечиваются.</p>
<p><code>DECLARE</code> позволяется только внутри <code>BEGIN ... END</code>
и должен быть в начале, перед любыми другими инструкциями.</p>

<p>Объявления должны следовать за некоторым порядком. Курсоры должны быть
объявлены перед объявлением драйверов и переменных, условия должны быть
объявлены перед объявлениями, курсорами или драйверами.</p>

<h3><a name="variables-in-stored-procedures"></a>5.2.7.
Переменные в сохраненных подпрограммах</h3>
<p>Вы можете объявлять и использовать переменные внутри подпрограммы.</p>

<h4><a name="declare-local-variables"></a>5.2.7.1. Локальные переменные
<code>DECLARE</code></h4>
<pre>
DECLARE <code>var_name</code>[,...] <code>type</code>
        [DEFAULT <code>value</code>]
</pre>

<p>Эта инструкция используется, чтобы объявить локальные переменные. Чтобы
обеспечивать значение по умолчанию для переменной, включите предложение
<code>DEFAULT</code>. Значение может быть определено как выражение, оно не
обязательно должно быть константой. Если предложение <code>DEFAULT</code>
отсутствует, начальное значение <code>NULL</code>.</p>

<p>Локальные переменные обрабатываются подобно стандартным параметрам
относительно типа данных и проверки переполнения.</p>

<p>Область (контекст) локальной переменной: внутри блока
<code>BEGIN ... END</code>, где это объявлено. Переменная может упоминаться
в блоках, вложенных внутри блока объявления, за исключением тех блоков,
которые объявляют переменную с тем же самым именем.</p>

<h4><a name="set-statement"></a>5.2.7.2. Команда <code>SET</code></h4>
<pre>
SET <code>var_name</code> = <code>expr</code>
    [, <code>var_name</code> = <code>expr</code>] ...
</pre>

<p>Инструкция <code>SET</code> в сохраненных подпрограммах представляет собой
расширенную версию общей инструкции <code>SET</code>. Вызванные переменные
могут быть объявлены внутри подпрограммы или глобальными переменными системы.
</p>

<p>Инструкция <code>SET</code> в сохраненных подпрограммах выполнена как
часть синтаксиса <code>SET</code>. Это позволяет расширенный синтаксис
<code>SET a=x, b=y, ...</code>, где различные виды переменных (локально
объявленные, глобальные и переменные сеанса сервера могут быть смешаны. Это
также позволяет комбинации локальных переменных и некоторых параметров,
которые имеют смысл только для переменных системы. В этом случае, параметры
распознаны, но игнорируются.</p>

<h4><a name="select-into-statement"></a>5.2.7.3. Команда
<code>SELECT ... INTO</code></h4>
<pre>
SELECT <code>col_name</code>[,...]
       INTO <code>var_name</code>[,...] <code>table_expr</code>
</pre>

<p>Этот синтаксис <code>SELECT</code> сохраняет выбранные столбцы
непосредственно в переменные. Следовательно, только одиночная строка
может быть получена.</p>

<pre>
SELECT id,data INTO x,y FROM test.t1 LIMIT 1;
</pre>

<p>Имена переменных пользователя не чувствительны к регистру.
<span class="bold"><strong>Важно</strong></span>: имена переменных SQL не
должны совпадать с именами столбцов. Если инструкция SQL, типа
<code>SELECT ... INTO</code>, содержит ссылку к столбцу, и есть объявленная
локальная переменная с тем же самым именем, MySQL в настоящее время
интерпретирует ссылку как имя переменной. Например, в следующей инструкции
<code>xname</code> интерпретируется как ссылка к переменной, а не к
столбцу с именем <code>xname</code>:</p>

<pre>
CREATE PROCEDURE sp1 (x VARCHAR(5))
BEGIN
  DECLARE xname VARCHAR(5) DEFAULT 'bob';
  DECLARE newname VARCHAR(5);
  DECLARE xid INT;
  SELECT xname, id INTO newname, xid FROM table1 WHERE xname = xname;
  SELECT newname;
END;
</pre>

<p>Когда эта процедура вызвана, переменная <code>newname</code> возвращает
значение <code>'bob'</code> независимо от значения
столбца <code>table1.xname</code>.</p>

<h3><a name="conditions-and-handlers"></a>5.2.8. Условия и драйверы</h3>
<p>Некоторые условия могут требовать специфической обработки. Эти условия
могут касаться ошибок или общего управления потоком
данных внутри подпрограммы.</p>

<h4><a name="declare-conditions"></a>5.2.8.1. <code>DECLARE</code> условий
</h4>
<pre>
DECLARE <code>condition_name</code> CONDITION FOR
        <code>condition_value</code>

<code>condition_value</code>:
SQLSTATE [VALUE] <code>sqlstate_value</code>
   | <code>mysql_error_code</code>
</pre>

<p>Эта инструкция определяет условия, которые нуждаются в специфической
обработке. Это сопоставляет имя с определенным условием ошибки. Имя может
впоследствии использоваться в инструкции <code>DECLARE HANDLER</code>.</p>

<p>Здесь <code>condition_value</code> может быть значением
SQLSTATE или же кодом ошибки MySQL.</p>

<h4><a name="declare-handlers"></a>5.2.8.2. <code>DECLARE</code> драйвера
</h4>
<pre>
DECLARE <code>handler_type</code> HANDLER FOR
        <code>condition_value</code>[,...] <code>statement</code>

<code>handler_type</code>:
   CONTINUE | EXIT | UNDO

<code>condition_value</code>:
SQLSTATE [VALUE] <code>sqlstate_value</code>
   | <code>condition_name</code> | SQLWARNING | NOT FOUND | SQLEXCEPTION
   | <code>mysql_error_code</code>
</pre>

<p>Инструкция <code>DECLARE ... HANDLER</code> определяет драйверы, с каждым
из которых может иметь дело одно или большее количество условий. Если одно из
этих условий происходит, определенная инструкция <code>statement</code> будет
выполнена. Инструкция может быть простой инструкцией (например,
<code>SET <code>var_name</code> = <code>value</code></code>), или
это может быть составной инструкцией, записанной с помощью парочки
<code>BEGIN</code> и <code>END</code>.</p>

<p>Для драйвера <code>CONTINUE</code> выполнение текущей подпрограммы
продолжается после выполнения инструкции драйвера. Для драйвера
<code>EXIT</code> выполнение завершается для составной инструкции
<code>BEGIN ... END</code>, в которой драйвер объявлен. Это истинно, даже
если условие происходит во внутреннем блоке. Инструкция типа драйвера
<code>UNDO</code> еще не обеспечивается (пока?).</p>

<p>Если происходит условие, для которого никакой драйвер не был объявлен,
заданное по умолчанию действие: <code>EXIT</code>.</p>

<p>Параметр <code>condition_value</code> может быть любым
из следующих значений:</p>

<ul type="disc"><li><p>Значение SQLSTATE или MySQL-код ошибки.</p></li>
<li><p>Имя условия, предварительно определенное с
<code>DECLARE ... CONDITION</code>.</p></li>

<li><p><code>SQLWARNING</code> (краткая запись для всех кодов
SQLSTATE, которые начинаются с <code>01</code>).</p></li>
<li><p><code>NOT FOUND</code> (краткая запись для всех кодов
SQLSTATE, которые начинаются с <code>02</code>).</p></li>

<li><p><code>SQLEXCEPTION</code> (краткая запись для всех кодов SQLSTATE, не
охваченных <code>SQLWARNING</code> или <code>NOT FOUND</code>).</p></li></ul>
<p>Пример:</p>

<pre>
mysql&gt; CREATE TABLE test.t (s1 int,primary key (s1));
Query OK, 0 rows affected (0.00 sec)

mysql&gt; delimiter //
mysql&gt; CREATE PROCEDURE handlerdemo ()
    -&gt; BEGIN
    -&gt;   DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2 = 1;
    -&gt;   SET @x = 1;
    -&gt;   INSERT INTO test.t VALUES (1);
    -&gt;   SET @x = 2;
    -&gt;   INSERT INTO test.t VALUES (1);
    -&gt;   SET @x = 3;
    -&gt; END;
    -&gt; //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; CALL handlerdemo()//
Query OK, 0 rows affected (0.00 sec)
mysql&gt; SELECT @x//
+------+
| @x   |
+------+
| 3    |
+------+
1 row in set (0.00 sec)
</pre>

<p>Пример сопоставляет драйвер с SQLSTATE 23000, который происходит для
ошибки дублирования ключа. Обратите внимание, что <code>@x</code> равен
<code>3</code>, это показывает что MySQL перейдет к концу процедуры. Если
строка <code>DECLARE CONTINUE HANDLER FOR SQLSTATE '23000' SET @x2
= 1;</code> не была представлена, MySQL примет заданный по умолчанию путь
(<code>EXIT</code>) после второй неудачи <code>INSERT</code> из-за
ограничения <code>PRIMARY KEY</code>, а
<code>SELECT @x</code> возвратит <code>2</code>.</p>

<p>Если Вы хотите игнорировать условие, Вы можете объявлять драйвер
<code>CONTINUE</code> для этого и сопоставлять его с пустым блоком. Например:
</p>

<pre>
DECLARE CONTINUE HANDLER FOR SQLWARNING BEGIN END;
</pre>

<h3><a name="cursors"></a>5.2.9. Курсоры</h3>
<p>Простые курсоры обеспечиваются внутри сохраненных процедур и функций.
Синтаксис как во внедренном SQL. Курсоры в настоящее время только для чтения,
не поддерживают прокрутку и нечувствительны. Последнее означает, что сервер
может или не может делать копию таблицы результата.</p>

<p>Курсоры должны быть объявлены перед объявлением драйверов и переменных, а
условия должны быть объявлены перед объявлением курсоров и драйверов.</p>
<p>Пример:</p>
<pre>
CREATE PROCEDURE curdemo()
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE a CHAR(16);
  DECLARE b,c INT;
  DECLARE cur1 CURSOR FOR SELECT id,data FROM test.t1;
  DECLARE cur2 CURSOR FOR SELECT i FROM test.t2;
  DECLARE CONTINUE HANDLER FOR SQLSTATE '02000' SET done = 1;
  OPEN cur1;
  OPEN cur2;
  REPEAT
    FETCH cur1 INTO a, b;
    FETCH cur2 INTO c;
    IF NOT done THEN
       IF b &lt; c THEN INSERT INTO test.t3 VALUES (a,b);
          ELSE INSERT INTO test.t3 VALUES (a,c);
       END IF;
    END IF;
  UNTIL done END REPEAT;
  CLOSE cur1;
  CLOSE cur2;
END
</pre>

<h4><a name="declare-cursors"></a>5.2.9.1. Объявление курсоров</h4>
<pre>
DECLARE <code>cursor_name</code>
        CURSOR FOR <code>select_statement</code>
</pre>

<p>Эта инструкция объявляет курсор. Много курсоров может быть объявлено в
подпрограмме, но каждый курсор в данном блоке должен иметь уникальное имя.
</p>

<p>Инструкция <code>SELECT</code> не может иметь предложение
<code>INTO</code>.</p>

<h4><a name="open"></a>5.2.9.2. Инструкция <code>OPEN</code></h4>
<pre>
OPEN <code>cursor_name</code>
</pre>
<p>Эта инструкция открывает предварительно объявленный курсор.</p>

<h4><a name="fetch"></a>5.2.9.3. Инструкция <code>FETCH</code></h4>
<pre>
FETCH <code>cursor_name</code>
INTO <code>var_name</code> [, <code>var_name</code>] ...
</pre>
<p>Эта инструкция выбирает следующую строку (если строка существует),
используя определенный открытый курсор, и продвигает указатель курсора.</p>

<p>Если больше нет доступных строк, происходит условие No Data со значением
SQLSTATE 02000. Чтобы обнаружить это условие, Вы можете установить драйвер
для этого. Пример показывается в разделе
"<a href="#cursors">5.2.9. Курсоры</a>".</p>

<h4><a name="close"></a>5.2.9.4. Инструкция <code>CLOSE</code></h4>
<pre>
CLOSE <code>cursor_name</code>
</pre>

<p>Эта инструкция закрывает предварительно открытый курсор. Если курсор не
закрыт явно, он все равно закроется в конце составной инструкции, в которой
он был объявлен.</p>

<h3><a name="flow-control-constructs"></a>5.2.10. Конструкции управления
потоком данных</h3>
<p>Конструкции <code>IF</code>, <code>CASE</code>, <code>LOOP</code>,
<code>WHILE</code>, <code>REPLACE</code> <code>ITERATE</code> и
<code>LEAVE</code> полностью выполнены.</p>

<p>Многие из этих конструкций содержат другие инструкции, как обозначено
спецификациями грамматики в следующих разделах. Такие конструкции могут быть
вложены. Например, <code>IF</code> мог бы содержать цикл времени, который
непосредственно содержит <code>WHILE</code>, который в свою очередь включает
в себя оператор <code>CASE</code>. Циклы <code>FOR</code> в настоящее
время не обеспечиваются.</p>

<h4><a name="if-statement"></a>5.2.10.1. Инструкция <code>IF</code></h4>
<pre>
IF <code>search_condition</code> THEN <code>statement_list</code>
   [ELSEIF <code>search_condition</code>
   THEN <code>statement_list</code>] ...
   [ELSE <code>statement_list</code>]
END IF
</pre>

<p><code>IF</code> реализован как базисная условная конструкция. Если
выражение <code>search_condition</code> истинно, соответствующий список
инструкции SQL выполнен. Если пары <code>search_condition</code> не нашлось,
будет выполнен операторный список в предложении <code>ELSE</code>. Каждый
<code>statement_list</code> состоит из одной или
большего количества инструкций.</p>

<p><span class="bold"><strong>Обратите внимание</strong></span>: имеется
также функция <code>IF()</code>, которая отличается от команды
<code>IF</code>, описанной здесь.</p>

<h4><a name="case-statement"></a>5.2.10.2. Инструкция <code>CASE</code></h4>
<pre>
   CASE <code>case_value</code> WHEN <code>when_value</code>
        THEN <code>statement_list</code>
        [WHEN <code>when_value</code> THEN <code>statement_list</code>] ...
        [ELSE <code>statement_list</code>]
   END CASE
</pre>

<p>Или:</p>
<pre>
   CASE WHEN <code>search_condition</code> THEN <code>statement_list</code>
        [WHEN <code>search_condition</code> THEN <code>statement_list</code>] ...
        [ELSE <code>statement_list</code>]
   END CASE
</pre>

<p>Инструкция <code>CASE</code> для сохраненных подпрограмм осуществляет
сложную условную конструкцию. Если <code>search_condition</code> равно true,
соответствующий список инструкций SQL выполнен. Если никакие условия не
подошли, отрабатывается операторный список в предложении <code>ELSE</code>.
Каждый <code>statement_list</code> состоит из одной или
большего количества инструкций.</p>

<p><span class="bold"><strong>Обратите внимание</strong></span>: синтаксис
инструкции <code>CASE</code>, показанной здесь для использования внутри
сохраненных подпрограмм немного отличается от такового выражения в SQL.
Инструкция <code>CASE</code> не может иметь предложение <code>ELSE
NULL</code>, и она завершена <code>END CASE</code> вместо <code>END</code>.
</p>

<h4><a name="loop-statement"></a>5.2.10.3. Инструкция <code>LOOP</code></h4>
<pre>
   [<code>begin_label</code>:] LOOP
    <code>statement_list</code>
   END LOOP [<code>end_label</code>]
</pre>

<p><code>LOOP</code> осуществляет простую конструкцию цикла, допуская
повторенное выполнение операторного списка, который состоит из одной или
большего количества инструкций. Инструкции внутри цикла повторены, пока цикл
не покидается. Обычно это выполнено инструкцией <code>LEAVE</code>.</p>

<p>Инструкция <code>LOOP</code> может быть помечена. <code>end_label</code>
не может быть дан, если нет <code>begin_label</code>. Если оба присутствуют,
они должны быть те же самые.</p>

<h4><a name="leave-statement"></a>5.2.10.4. Инструкция <code>LEAVE</code>
</h4>
<pre>
LEAVE <code>label</code>
</pre>

<p>Эта инструкция используется, чтобы из выйти любой помеченной конструкции
управления потоком данных. Это может использоваться внутри <code>BEGIN ...
END</code> или же конструкций цикла (<code>LOOP</code>,
<code>REPEAT</code>, <code>WHILE</code>).</p>

<h4><a name="iterate-statement"></a>5.2.10.5. Инструкция
<code>ITERATE</code></h4>
<pre>
ITERATE <code>label</code>
</pre>

<p><code>ITERATE</code> может появляться только внутри инструкций
<code>LOOP</code>, <code>REPEAT</code> и <code>WHILE</code>.
<code>ITERATE</code> означает "<span class="quote">выполнить цикл снова
</span>".</p>

<p>Пример:</p>
<pre>
CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END
</pre>

<h4><a name="repeat-statement"></a>5.2.10.6. Инструкция <code>REPEAT</code>
</h4>
<pre>
[<code>begin_label</code>:]
  REPEAT <code>statement_list</code>
    UNTIL <code>search_condition</code>
  END REPEAT
[<code>end_label</code>]
</pre>

<p>Операторный список внутри инструкции <code>REPEAT</code> повторен, пока
<code>search_condition</code> равно true. Таким образом, <code>REPEAT</code>
всегда проходит цикл по крайней мере один раз. Перечень
<code>statement_list</code> состоит из одной или большего числа инструкций.
Инструкция <code>REPEAT</code> может быть помечена по обычным правилам.
</p>

<pre>
mysql&gt; delimiter //
mysql&gt; CREATE PROCEDURE dorepeat(p1 INT)
    -&gt; BEGIN
    -&gt;   SET @x = 0;
    -&gt;   REPEAT SET @x = @x + 1; UNTIL @x &gt; p1 END REPEAT;
    -&gt; END
    -&gt; //
Query OK, 0 rows affected (0.00 sec)

mysql&gt; CALL dorepeat(1000)//
Query OK, 0 rows affected (0.00 sec)
mysql&gt; SELECT @x//
+------+
| @x   |
+------+
| 1001 |
+------+
1 row in set (0.00 sec)
</pre>

<h4><a name="while-statement"></a>5.2.10.7. Инструкция <code>WHILE</code>
</h4>
<pre>
[<code>begin_label</code>:]
  WHILE <code>search_condition</code> DO <code>statement_list</code>
  END WHILE
[<code>end_label</code>]
</pre>

<p>Операторный список внутри инструкции <code>WHILE</code> повторен, пока
<code>search_condition</code> равно true. Инструкция <code>WHILE</code>
может быть помечена. Пример:</p>

<pre>
CREATE PROCEDURE dowhile()
BEGIN
  DECLARE v1 INT DEFAULT 5;
  WHILE v1 &gt; 0 DO
    ...
    SET v1 = v1 - 1;
  END WHILE;
END
</pre>

<h2><a name="stored-procedure-last-insert-id"></a>5.3. Сохраненные
процедуры, функции, триггеры и <code>LAST_INSERT_ID()</code></h2>
<p>Внутри тела сохраненной подпрограммы (процедуры или функции) или триггера
значение <code>LAST_INSERT_ID()</code> меняется по обычным правилам. Эффект
сохраненной подпрограммы или триггера на значение
<code>LAST_INSERT_ID()</code>, который замечен следующими инструкциями,
зависит от вида подпрограммы:</p>

<ul type="disc"><li><p>Если сохраненная процедура выполняет инструкции,
которые изменяют значение <code>LAST_INSERT_ID()</code>, измененное значение
будет замечено инструкциями, которые следуют за вызовом процедуры.</p></li>

<li><p>Для сохраненных функций и триггеров, которые меняют значение, оно
восстановлено, когда функция или триггер завершат работу, так что последующие
инструкции не будут видеть измененное значение.</p></li></ul>

<h2><a name="stored-procedure-replication-faq"></a>5.4. Сохраненные
процедуры, функции, триггеры и репликация</h2>
<ul type="disc"><li><p>В MySQL 5.0 сохраненные процедуры и
функции работают с репликацией?</p>

<p>Да, стандартные действия, выполненные в сохраненных процедурах и функциях,
скопируются. Имеются несколько ограничений, которые описаны подробно в
разделе "<a href="#stored-procedure-logging">5.5.
Двоичная регистрация сохраненных подпрограмм и триггеров</a>".</p></li>

<li><p>Будут ли сохраненные процедуры и функции, созданные на главном
сервере, скопированы на подчиненный?</p>
<p>Да, создание сохраненных процедур и функций, выполненное через нормальные
инструкции DDL, скопируется на подчиненный, так что объекты будут
существовать на обеих серверах. Инструкции <code>ALTER</code> и
<code>DROP</code> для сохраненных процедур и функций также скопируются.
</p></li>

<li><p>Как реплицируются действия, которые происходят внутри сохраненных
процедур и скопированных функций?</p>

<p>MySQL записывает каждое событие DML, которое происходит в сохраненной
процедуре, и копирует эти индивидуальные действия на подчиненный сервер.
Фактические обращения, сделанные, чтобы выполнить сохраненные процедуры не
скопируются. Сохраненные функции, которые изменяют данные, регистрируются как
функциональные вызовы, а не как события DML, которые происходят
внутри каждой функции.</p></li>

<li><p>Есть ли специальные требования защиты для использования сохраненных
процедур и функций вместе с репликацией?</p>
<p>Да. Поскольку подчиненный сервер имеет полномочия, выполнить любое
операторное чтение из двоичного файла регистрации главного сервера,
специальные ограничения защиты существуют для использования сохраненных
функций с репликацией. Если репликация или двоичная регистрация вообще (с
целью восстановления в контрольной точке активна, то MySQL DBA имеет два
параметров защиты для них:</p>

<ul type="circle"><li><p>Любому пользователю, желающему создать сохраненные
функции, нужно предоставлять <code>SUPER</code> привилегию.</p></li>
<li><p>В качестве альтернативы, DBA может устанавливать переменную системы
<code>log_bin_trust_function_creators</code> в 1, что позволяет любому со
стандартной привилегией <code>CREATE ROUTINE</code>
создавать сохраненные функции.</p></li></ul>

<p>Обратите внимание: до MySQL 5.0.16 эти ограничения также относятся к
сохраненным процедурам, и переменная системы именована
<code>log_bin_trust_routine_creators</code>.</p></li>

<li><p>Какие ограничения существуют для копирования сохраненной
процедуры и функциональных действий?</p>
<p>Не детерминированные (произвольные) или основанные на времени действия,
внедренные в сохраненных процедурах, не могут копироваться правильно. Для
них очень характерны беспорядочно произведенные не предсказуемые результаты,
которые не могут быть точно воспроизведены, а, следовательно, произвольные
действия, скопированные на подчиненный сервер, не будут отражать, что именно
выполнили на главном сервере. Обратите внимание, что объявление сохраненных
функций как <code>DETERMINISTIC</code> или установка переменной системы
<code>log_bin_trust_function_creators</code> в 0 не будет позволять вызывать
произвольно оцененные операции.</p>

<p>Кроме того, основанные на времени действия не могут быть воспроизведены на
подчиненном сервере, потому что синхронизация таких действий в сохраненной
процедуре не восстанавливаема через двоичный файл регистрации, используемый
для репликации. Он записывает только события DML и не разлагает их на
множители в ограничениях синхронизации.</p>

<p>В заключение, нетранзакционные таблицы, для которых происходят ошибки в
течение больших действий DML (типа объемных вставок), могут испытывать
проблемы дублирования, в которых главный сервер может частично
модифицироваться из действия DML, но никакие модификации не выполнены на
подчиненном из-за ошибок, которые произошли. Обойти проблему можно с
ключевым словом <code>IGNORE</code> так, чтобы модификации на главном
сервере, которые вызывают ошибки, игнорировались, а модификации, которые не
вызывают ошибок, скопируются на подчиненный.</p></li>

<li><p>Предшествующие ограничения воздействуют на способность MySQL делать
восстановление до контрольной точки?</p>
<p>Те же самые ограничения, которые воздействуют на репликацию, воздействуют
и на восстановление до контрольной точки.</p></li>

<li><p>Что будет делать MySQL, чтобы исправить вышеупомянутые ограничения?
</p>
<p>Будущий выпуск MySQL, как ожидается, даст выбор в том, как репликация
должна быть обработана:</p>

<ul type="circle"><li><p>Операторно-основанная репликация (текущая реализация).
</p></li>

<li><p>Дублирование уровня строки (которое решит все
ограничения, описанные ранее).</p></li></ul></li>

<li><p>Триггеры работают с репликацией?</p>
<p>Триггеры и репликация в MySQL 5.0 работают также как в большинстве других
СУБД: действия, выполненные через триггеры на главном сервере, не скопируются
на подчиненный. Вместо этого, триггеры, которые существуют на таблицах,
которые постоянно находятся на главном сервере, должны быть созданы на
соответствующих таблицах на любых подчиненных серверах так, чтобы триггеры
активизировались там соответственно главному.</p></li>

<li><p>Как действия, выполненные через триггер на главном сервере,
скопированы на подчиненный?</p>
<p>Сначала, триггеры, которые существуют на главном сервере, должны быть
вновь созданы на подчиненном сервере. Если это выполнено, поток дублирования
работает как любая другая стандартная инструкция DML, которая участвует в
дублировании. Например, рассмотрите таблицу <code>EMP</code>, которая имеет
триггер <code>AFTER</code> insert, существующий на главном сервере. Та же
самая таблица и триггер существуют также и на подчиненном сервере. Поток
дублирования был бы:

</p><ol type="1"><li><p>Инструкция <code>INSERT</code> сделана в
<code>EMP</code>.</p></li>
<li><p>Триггер <code>AFTER</code> сработал на <code>EMP</code>.</p></li>

<li><p>Инструкция <code>INSERT</code> записана в двоичный файл регистрации.
</p></li>
<li><p>Подчиненный сервер подбирает инструкцию <code>INSERT</code> к
<code>EMP</code> и выполняет ее.</p></li>
<li><p>Триггер <code>AFTER</code> в <code>EMP</code>, который существует на
подчиненном сервере, активизируется.</p></li></ol></li></ul>

<h2><a name="stored-procedure-logging"></a>5.5. Двоичная регистрация
сохраненных подпрограмм и триггеров</h2>
<p>Двоичный файл регистрации содержит информацию относительно инструкций SQL,
которые изменяют содержание базы данных. Эта информация сохранена в форме
события. Это описывает модификации. Двоичный файл регистрации имеет
две важных цели:</p>

<ul type="disc"><li><p>Для дублирования главный сервер посылает события,
содержащиеся в двоичном файле регистрации, всем остальным серверам, которые
выполняют события, чтобы сделать те же самые изменения данных, которые были
сделаны на главном сервере.</p></li>

<li><p>Некоторые операции восстановления данных требуют использования
двоичного файла регистрации. После того, как файл с резервной копией был
восстановлен, события в двоичном файле регистрации, которые были записаны
после того, как копия была сделана, заново выполнены. Эти события обновляют
базы данных после момента копии.</p></li></ul>

<p>Этот раздел описывает разработку двоичной регистрации в MySQL 5.0
относительно сохраненных подпрограмм (процедуры и функции) и триггеров.
Обсуждение сначала подводит итог изменений, которые имели место в реализации
регистрации, а затем приводит текущие условия
использования сохраненных подпрограмм.</p>

<p>Вообще, проблемы, описанные здесь, следуют из того факта, что двоичная
регистрация происходит на уровне инструкции SQL. Будущие версии MySQL, как
ожидается, выполнят уровень двоичной регистрации строки, которая определяет
изменения для индивидуальных строк в результате выполняющихся инструкций SQL.
</p>

<p>Если не отмечено иное, замечания здесь принимают, что Вы допустили
двоичную регистрацию, запуская сервер с опцией <code>--log-bin</code>.
Если двоичный файл регистрации не допускается, дублирование невозможно, так
как отсутствует двоичный файл регистрации для восстановления данных.</p>

<p>Разработка регистрации сохраненной подпрограммы в MySQL 5.0 может быть
получена в итоге следующим образом:</p>

<ul type="disc"><li><p>До MySQL 5.0.6: в начальной реализации регистрации
сохраненной подпрограммы, инструкции, которые создают сохраненные
подпрограммы, и инструкции <code>CALL</code> не регистрируются. Эти
вычеркивания могут вызывать проблемы для восстановления данных и дублирования.
</p></li>

<li><p>MySQL 5.0.6: инструкции, которые создают сохраненные подпрограммы, и
инструкции <code>CALL</code> регистрируются. Сохраненные функциональные
вызовы регистрируются, когда они происходят в инструкциях, которые
модифицируют данные (потому что те инструкции регистрируются). Однако,
функциональные вызовы не регистрируются, когда они происходят в инструкциях
типа <code>SELECT</code>, которые не изменяют данные, даже если изменение
данных происходит непосредственно внутри функции, это может вызвать проблемы.
При некоторых обстоятельствах, функции и процедуры могут иметь различные
эффекты если выполнено в разное время или на различных серверах (главном или
подчиненном), и таким образом они могут быть опасны для восстановления данных
или дублирования. Чтобы обрабатывать это, приняты меры, чтобы позволить
идентификацию безопасных подпрограмм и предотвратить создание опасных
подпрограмм (за исключением создаваемых
пользователями с достаточными привилегиями).</p></li>

<li><p>MySQL 5.0.12: для сохраненных функций, когда функциональный вызов,
который изменяет данные, происходит внутри не регистрируемой инструкции типа
<code>SELECT</code>, сервер регистрирует инструкцию
<code>DO <code>func_name</code>()</code>, которая вызывает функцию так, чтобы
функция была выполнена в течение восстановления данных или дублирования на
подчиненные серверы. Для сохраненных процедур, сервер не регистрирует
инструкции <code>CALL</code>. Вместо этого, он регистрирует индивидуальные
инструкции внутри процедуры, которые выполнены в результате
<code>CALL</code>. Это устраняет проблемы, которые могут происходить, когда
процедура выполнялась бы на подчиненном сервере иным способом,
чем на главном.</p></li>

<li><p>MySQL 5.0.16: процедура, регистрирующая изменения, сделанные в 5.0.12,
позволяет ослабить условия на опасных подпрограммах для сохраненных процедур.
Следовательно, интерфейс пользователя для управления этими условиями
пересмотрен, чтобы применить только к функциям. Создатели процедуры больше
не связаны ими.</p></li>

<li><p>MySQL 5.0.17: регистрация сохраненных функций также, как и инструкции
<code>DO <code>func_name</code>()</code> (для изменений, сделанных в 5.0.12),
регистрируется как инструкции <code>SELECT <code>func_name</code>()</code>
для лучшего контроля проверки ошибок.</p></li></ul>

<p>Как следствие предшествующих изменений, следующие условия в настоящее
время обращаются к созданию сохраненных функций, когда двоичная регистрация
допускается. Эти условия не относятся к созданию сохраненных процедур.</p>

<ul type="disc"><li><p>Чтобы создавать или изменять сохраненную функцию, Вы
должны иметь привилегию <code>SUPER</code>, в дополнение к привилегии
<code>CREATE ROUTINE</code> или <code>ALTER ROUTINE</code>,
которая обычно требуется.</p></li>

<li><p>Когда Вы создаете сохраненную функцию, Вы должны объявить, что это
детерминировано или не изменяет данные. Иначе, это может быть опасно для
восстановления данных или дублирования. Два набора функциональных
характеристик применяются здесь:</p>

<ul type="circle"><li><p>Характеристики <code>DETERMINISTIC</code> и
<code>NOT DETERMINISTIC</code> указывают, производит ли функция всегда тот же
самый результат для входных данных. Значение по умолчанию: <code>NOT
DETERMINISTIC</code>, если никакая характеристика не дана, так что Вы должны
определить <code>DETERMINISTIC</code> явно, чтобы объявить,
что функция детерминирована.</p>

<p>Использование функции <code>NOW()</code> (или синонимов) либо
<code>RAND()</code> не обязательно делает функцию не детерминированной. Для
<code>NOW()</code> двоичный файл регистрации включает timestamp и все
копирует правильно. <code>RAND()</code> также копируется правильно, пока это
вызывается только один раз внутри функции. Вы можете рассматривать
функциональное выполнение timestamp и начальное значение случайного числа как
неявные вводы, которые являются идентичными на главном и подчиненном серверах.
</p>

<p><code>SYSDATE()</code> не воздействует на timestamp в двоичном файле
регистрации, так что это заставляет сохраненные подпрограммы быть не
детерминированными, если используется регистрация, основанная на командах.
Этого не происходит, если сервер запущен с опцией
<code>--sysdate-is-now</code>, чтобы заставить <code>SYSDATE()</code> быть
псевдонимом для <code>NOW()</code>.</p></li>

<li><p>Характеристики <code>CONTAINS SQL</code>, <code>NO SQL</code>,
<code>READS SQL DATA</code> и <code>MODIFIES SQL DATA</code> обеспечивают
информацию относительно того, читает ли функция или записывает данные.
<code>NO SQL</code> или <code>READS SQL DATA</code> указывают, что функция не
изменяет данные, но Вы должны определить одну из них явно, потому что
значение по умолчанию: <code>CONTAINS SQL</code>, если никакая
характеристика не дана.</p></li></ul>

<p>По умолчанию для инструкции <code>CREATE FUNCTION</code>, которая будет
принята, должны быть определены явно <code>DETERMINISTIC</code> или что-то из
<code>NO SQL</code> и <code>READS SQL DATA</code>. Иначе происходит ошибка:
</p>

<pre>
ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL,
or READS SQL DATA in its declaration and binary logging is enabled (you
*might* want to use the less safe log_bin_trust_function_creators variable)
</pre>

<p>Оценка характера функции основана на честности ее создателя: MySQL не
проверяет, что функция, объявленная <code>DETERMINISTIC</code>, не содержит
никаких инструкций, которые производят не детерминированные результаты.
</p></li>

<li><p>Чтобы ослабить предшествующие условия на функциональном создании (что
Вы должны иметь привилегию <code>SUPER</code>, и что функция должна быть
объявлена детерминированной или не изменять данные), установите глобальную
переменную системы <code>log_bin_trust_function_creators</code> в 1. По
умолчанию, эта переменная имеет значение 0, но Вы можете изменить это:</p>
<pre>
mysql&gt; SET GLOBAL log_bin_trust_function_creators = 1;
</pre>

<p>Вы можете также устанавливать эту переменную, используя опцию
<code>--log-bin-trust-function-creators</code> при старте сервера.</p>
<p>Если двоичная регистрация не допускается,
<code>log_bin_trust_function_creators</code> не применяется, и для
стандартного создания не требуется привилегия <code>SUPER</code>.
</p></li></ul>

<p>Триггер подобен сохраненным функциям, так что предшествующие замечания
относительно функций также относятся к ним со следующей исключительной
ситуацией: <code>CREATE TRIGGER</code> не имеет факультативной характеристики
<code>DETERMINISTIC</code>, так что триггеры приняты, чтобы быть всегда
детерминированными. Однако, это предположение могло бы в некоторых случаях
быть недопустимым. Например, функция <code>UUID()</code> не детерминирована
(и не копируется!). Вы должны быть внимательны относительно использования
таких функций в триггерах.</p>

<p>Триггер может модифицировать таблицы (начиная с MySQL 5.0.10), так что
сообщения об ошибках, подобны тем же для сохраненных функций с <code>CREATE
TRIGGER</code>, если Вы не имеете привилегии <code>SUPER</code>, а
<code>log_bin_trust_function_creators</code> равна 0.</p>

<h2><a name="faqs-stored-procs"></a>5.6
MySQL 5 FAQ по хранимым подпрограммам</h2>
<p><a name="qandaitem-28-4-3"></a><span class="bold"><strong>5.6.1:
</strong></span><span class="bold"><strong>Есть ли форум для обсуждения
сохраненных подпрограмм в MySQL?</strong></span></p>
<p>Да. <a href="../../../forums.mysql.com/list.php@98" target="_top">
http://forums.mysql.com/list.php?98</a>.</p>

<p><a name="qandaitem-28-4-4"></a><span class="bold"><strong>5.6.2:
</strong></span><span class="bold"><strong>Где я могу найти спецификацию ANSI
SQL 2003 для сохраненных процедур?</strong></span></p>

<p>К сожалению, официальные спецификации не свободно доступны (ANSI делает их
доступными для приобретения). Однако, имеются книги, типа
<em class="citetitle">SQL-99 Complete, Really</em> by Peter Gulutzan and
Trudy Pelzer, которые дают всесторонний краткий обзор стандарта, включая
покрытие сохраненных процедур.</p>

<p><a name="qandaitem-28-4-5"></a><span class="bold"><strong>5.6.3:
</strong></span><span class="bold"><strong>
Как управлять сохраненными подпрограммами?</strong></span></p>

<p>Лучше использовать чистую схему наименования сохраненных подпрограмм. Вы
можете управлять сохраненными подпрограммами с помощью
<code>CREATE [FUNCTION|PROCEDURE]</code>,
<code>ALTER [FUNCTION|PROCEDURE]</code>,
<code>DROP [FUNCTION|PROCEDURE]</code> и
<code>SHOW CREATE [FUNCTION|PROCEDURE]</code>. Вы можете получать информацию
относительно существующих сохраненных процедур, используя таблицу
<code>ROUTINES</code> в базе данных <code>INFORMATION_SCHEMA</code>.</p>

<p><a name="qandaitem-28-4-6"></a><span class="bold"><strong>5.6.4:
</strong></span><span class="bold"><strong>Есть ли способ просматривать все
сохраненные процедуры и функции в базе данных?</strong></span></p>

<p>Да. Для базы данных <em><code>dbname</code></em> используйте этот запрос
к таблице <code>INFORMATION_SCHEMA.ROUTINES</code>:</p>
<pre>
SELECT ROUTINE_TYPE, ROUTINE_NAME
       FROM INFORMATION_SCHEMA.ROUTINES
       WHERE ROUTINE_SCHEMA='<em><code>dbname</code></em>';
</pre>

<p>Тело сохраненной подпрограммы может просматриваться, используя
<code>SHOW CREATE FUNCTION</code> (для сохраненной функции) или
<code>SHOW CREATE PROCEDURE</code> (для сохраненной процедуры).</p>

<p><a name="qandaitem-28-4-7"></a><span class="bold"><strong>5.6.5:
</strong></span><span class="bold"><strong>
Где сохраненные процедуры сохранены?</strong></span></p>

<p>В таблице <code>proc</code> базы данных <code>mysql</code>. Однако, Вы не
должны обращаться к таблицам в базе данных системы непосредственно. Вместо
этого, используйте <code>SHOW CREATE FUNCTION</code>, чтобы получить
информацию относительно сохраненных функций и
<code>SHOW CREATE PROCEDURE</code>, чтобы получить информацию
относительно сохраненных процедур.</p>

<p>Вы можете также сделать запрос к таблице <code>ROUTINES</code> в базе
данных <code>INFORMATION_SCHEMA</code> для информации
относительно этой таблицы.</p>

<p><a name="qandaitem-28-4-8"></a><span class="bold"><strong>5.6.6:
</strong></span><span class="bold"><strong>Возможно ли группировать
сохраненные процедуры или функции в пакеты?</strong></span></p>
<p>Нет. Это не обеспечивается в MySQL 5.1.</p>

<p><a name="qandaitem-28-4-9"></a><span class="bold"><strong>5.6.7:
</strong></span><span class="bold"><strong>Может сохраненная процедура
вызывать другую сохраненную процедуру?</strong></span></p>
<p>Да.</p>

<p><a name="qandaitem-28-4-10"></a><span class="bold"><strong>5.6.8:
</strong></span><span class="bold"><strong>
Может сохраненная процедура вызывать триггер?</strong></span></p>
<p>Сохраненная процедура может выполнять инструкцию SQL, типа
<code>UPDATE</code>, которая вызывает триггер.</p>

<p><a name="qandaitem-28-4-11"></a><span class="bold"><strong>5.6.9:
</strong></span><span class="bold"><strong>
Может сохраненная процедура обращаться к таблицам?</strong></span></p>
<p>Да. Сохраненная процедура может обращаться к таблицам.</p>

<p><a name="qandaitem-28-4-12"></a><span class="bold"><strong>5.6.10:
</strong></span><span class="bold"><strong>Может сохраненная процедура
выдать ошибку прикладной программы?</strong></span></p>
<p>В MySQL 5.1 нет. Предполагается выполнять стандартные SQL-инструкции
<code>SIGNAL</code> и <code>RESIGNAL</code> в будущем.</p>

<p><a name="qandaitem-28-4-13"></a><span class="bold"><strong>5.6.11:
</strong></span><span class="bold"><strong>Может сохраненная процедура
обеспечивать обработку особых ситуаций?</strong></span></p>
<p>MySQL осуществляет определения <code>HANDLER</code>
согласно стандарту SQL.</p>

<p><a name="qandaitem-28-4-14"></a><span class="bold"><strong>5.6.12:
</strong></span><span class="bold"><strong>Может сохраненная процедура в
MySQL 5.1 вернуть набор результатов?</strong></span></p>

<p><span class="emphasis"><em>Сохраненная процедура</em></span> может, а вот
сохраненная функция нет. Если Вы выполняете обычный <code>SELECT</code>
внутри сохраненной процедуры, набор результатов возвращен непосредственно
пользователю. Вы должны использовать клиент-серверный протокол MySQL 4.1 (или
выше), чтобы это сработало. Это означает, что например, в PHP Вы должны
использовать расширение <code>mysqli</code> вместо <code>mysql</code>.</p>

<p><a name="qandaitem-28-4-15"></a><span class="bold"><strong>5.6.13:
</strong></span><span class="bold"><strong>
<code>WITH RECOMPILE</code> обеспечивается для сохраненных процедур?
</strong></span></p>
<p>В MySQL 5.1 нет.</p>

<p><a name="qandaitem-28-4-16"></a><span class="bold"><strong>5.6.14:
</strong></span><span class="bold"><strong>Есть ли в MySQL аналог
<code>mod_plsql</code> как шлюза к Apache, чтобы общаться непосредственно с
сохраннеными процедурами в базе данных?</strong></span></p>
<p>Не имеется никакого эквивалента в MySQL 5.1.</p>

<p><a name="qandaitem-28-4-17"></a><span class="bold"><strong>5.6.15:
</strong></span><span class="bold"><strong>
Я могу передавать массив как ввод сохраненной процедуре?</strong></span></p>
<p>В MySQL 5.1 нет.</p>

<p><a name="qandaitem-28-4-18"></a><span class="bold"><strong>5.6.16:
</strong></span><span class="bold"><strong>Я могу передавать курсор как
параметр <code>IN</code> для сохраненной процедуры?</strong></span></p>
<p>В MySQL 5.1 курсоры доступны только внутри сохраненных процедур.</p>

<p><a name="qandaitem-28-4-19"></a><span class="bold"><strong>5.6.17:
</strong></span><span class="bold"><strong>Я могу возвращать курсор как
параметр <code>OUT</code> из сохраненной процедуры?</strong></span></p>

<p>В MySQL 5.1 курсоры доступны только внутри сохраненных процедур. Однако,
если Вы не открываете курсор на <code>SELECT</code>, результат будет послан
непосредственно пользователю. Вы можете также применить
<code>SELECT INTO</code> в переменные.</p>

<p><a name="qandaitem-28-4-20"></a><span class="bold"><strong>5.6.18:
</strong></span><span class="bold"><strong>Я могу распечатывать значение
переменной внутри сохраненной подпрограммы для целей отладки?
</strong></span></p>

<p>Да, Вы можете делать это в сохраненной процедуре, но не в сохраненной
функции. Если Вы выполняете обычный <code>SELECT</code> внутри сохраненной
процедуры, набор результатов возвращен непосредственно пользователю. Вы
должны будете использовать протокол MySQL 4.1 (или выше). В PHP Вы должны
использовать расширение <code>mysqli</code> вместо <code>mysql</code>.</p>

<p><a name="qandaitem-28-4-21"></a><span class="bold"><strong>5.6.19:
</strong></span><span class="bold"><strong>Я могу передавать или отменять
транзакции внутри сохраненной процедуры?</strong></span></p>
<p>Да. Однако, Вы не можете выполнять транзакционные операции
внутри сохраненной функции.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</html>
