<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
   <META NAME="Author" CONTENT="Alexey V. Pautov">
   <title>Глава 2. Типы памяти и таблиц</title>
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
      alink="#0000FF">

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>


<h2><a name="storage-engines"></a>Глава 2. Типы памяти и таблиц</h2>
<p>MySQL поддерживает несколько типов памяти, которые действуют как драйверы
для различных типов таблицы.</p>

<p>С MySQL 5.1 MySQL AB представил новую подключаемую архитектуру памяти,
которая позволяет типам памяти загружаться и выгружаться по мере надобности.
Если раньше приходилось перекомпилировать сервер, чтобы встроить поддержку
соответствующего типа таблиц, теперь это не требуется.</p>
<p>Эта глава описывает каждый из типов памяти MySQL, кроме <code>NDB
Cluster</code>. Это также содержит описание новой архитектуры хранения.</p>

<h2><a name="pluggable-storage-overview"></a>2.1. Краткий обзор архитектуры
хранения данных в MySQL</h2>
<p>Архитектура хранения данных в MySQL позволяет профессионалу базы данных
выбирать специализированный тип памяти для специфической потребности
прикладной программы. Сервер MySQL изолирует прикладного программиста и DBA
от всех подробностей реализации низкого уровня памяти, обеспечивая
непротиворечивую и простую модель прикладной программы и API. Таким образом,
хотя имеются различные возможности различных типов памяти, прикладная
программа ограждена от этих различий.</p>

<p>Такой подход обеспечивает стандартный набор управления и услуг поддержки,
которые являются общими среди всех основных типов памяти. Эта эффективная и
модульная архитектура обеспечивает огромные выгоды для всех.
</p>

<p>Прикладной программист и DBA взаимодействует с базой данных MySQL через
Connector API и сервисные уровни, которые стоят выше типов памяти. Если
изменения прикладной программы вызывают необходимость сменить тип памяти, то
не придется особо напрягаться.</p>

<h3><a name="pluggable-storage-common-layer"></a>2.1.1. Общий уровень
сервера базы данных</h3>
<p>Подключаемая архитектура памяти MySQL представляет собой компонент сервера
базы данных, который является ответственным за выполнение фактических
операции ввода-вывода данных для базы данных, а также предоставления и
предписания некоторых наборов свойств, в которых нуждается специфическая
прикладная программа. Главная польза в том, что Вы в любой момент
используете то, что Вам удобно, затрачивая минимум усилий и экономя много
ресурсов системы сервера.</p>

<p>Чем вообще отличаются типы памяти? Основные отличия включают:</p>
<ul type="disc"><li><p><span class="emphasis"><em>Concurrency</em></span>:
некоторые прикладные программы имеют более гранулированные требования
блокировки (типа блокировок уровня строки) чем другие. Выбор правильной
блокирующей стратегии может уменьшать непроизводительные затраты и,
следовательно, улучшать полную эффективность. Эта область также включает
поддержку возможностей типа многоверсионного управления параллелизма или
предоставления кадра чтения.</p></li>

<li><p><span class="emphasis"><em>Transaction Support</em></span>: не каждая
прикладная программа нуждается в транзакциях, но для тех, которым это надо,
имеются очень хорошо определенные требования типа совместимости с ACID.
</p></li>

<li><p><span class="emphasis"><em>Referential Integrity</em></span>: иногда
надо, чтобы сервер в реляционной базе данных поддерживал справочную
целостность через DDL-определенные внешние ключи.</p></li>

<li><p><span class="emphasis"><em>Physical Storage</em></span>: это включает
все от полного размера страницы для таблиц и индексов до формата,
используемого для сохранения данных на физический диск.</p></li>

<li><p><span class="emphasis"><em>Index Support</em></span>: различные
прикладные программы имеют тенденцию извлекать пользу из различных индексных
cтратегий. Каждый тип памяти вообще имеет собственные методы индексации, хотя
некоторые (типа индексов B-tree) общие на почти всех типах.</p></li>

<li><p><span class="emphasis"><em>Memory Caches</em></span>: различные
прикладные программы лучше отвечают одним кэширующим cтратегиям, чем другим,
хотя некоторые кэши памяти общие на всех типах хранения.</p></li>

<li><p><span class="emphasis"><em>Performance Aids</em></span>: это включает
многократные потоки ввода-вывода для параллельных операций, параллелизма
потоков, введения контрольных точек базы данных, объемной обработки вставки и
тому подобных функций.</p></li>

<li><p><span class="emphasis"><em>Miscellaneous Target Features</em></span>:
это может включать поддержку для географических операций, ограничения защиты
для некоторых операций манипулирования данными и других подобных свойств.
</p></li></ul>

<p>Каждый набор съемных компонентов инфраструктуры памяти разработан, чтобы
предложить выборочный набор выгод для специфической прикладной программы.
Наоборот, уход от набора лишних свойств компонента уменьшает ненужные
непроизводительные затраты. Надо усвоить, что понимание набора требований
специфической прикладной программы и выбор соответствующего типа памяти
MySQL может иметь драматическое воздействие на полную эффективность системы.
</p>

<h3><a name="pluggable-storage"></a>2.1.2. Съемная архитектура памяти</h3>
<p>В MySQL 5.1 MySQL AB представила новую съемную архитектуру памяти, которая
позволяет загружать и выгружать типы памяти (ранее известные как драйверы
таблиц) по мере надобности, не перезапуская сервер.</p>

<h4><a name="pluggable-storage-plugging"></a>2.1.2.1. Подключение типа памяти
</h4>
<p>Прежде, чем тип памяти сможет использоваться, сменная общедоступная
библиотека должна быть загружена в MySQL используя инструкцию
<code>INSTALL PLUGIN</code>. Например, если сменный тип памяти
<code>EXAMPLE</code> называется <code>ha_example</code>, а общедоступная
библиотека именована <code>ha_example.so</code>, то Вы загружаете
это следующей инструкцией:</p>
<pre>
INSTALL PLUGIN ha_example SONAME 'ha_example.so';
</pre>

<p>Общедоступная библиотека должна быть размещена в каталоге для сменных
модулей сервера MySQL, расположение которого задано переменной
системы <code>plugin_dir</code>.</p>

<h4><a name="pluggable-storage-unplugging"></a>
2.1.2.2. Отключение типа памяти</h4>
<p>Чтобы отключить тип памяти, используйте
инструкцию <code>UNINSTALL PLUGIN</code>:</p>
<pre>
UNINSTALL PLUGIN ha_example;
</pre>

<p>Если Вы отключаете тип памяти, который необходим существующим таблицам, те
таблицы станут недоступными, но будут все еще присутствовать на диске.
Гарантируйте, что не имеется никаких таблиц, использующих этот тип памяти
прежде, чем Вы его отключите.</p>

<h4><a name="pluggable-storage-security"></a>2.1.2.3.
Безопасность и сменные типы памяти</h4>
<p>Чтобы устанавливать съемный тип памяти, сменный файл должен быть размещен
в сменном каталоге MySQL, а пользователь, выдающий инструкцию
<code>INSTALL PLUGIN</code> должен иметь привилегию <code>INSERT</code> для
таблицы <code>mysql.plugin</code>.</p>

<h2><a name="storage-engine-overview"></a>2.2. Обеспечиваемые типы памяти
</h2>
<p>MySQL 5.1 поддерживает следующие типы памяти:</p>
<ul type="disc"><li><p>
<code>MyISAM</code>: применяемый по умолчанию тип памяти MySQL, который
наиболее используется в Web, хранилищах данных и других средах прикладных
программ. <code>MyISAM</code> обеспечивается во всех конфигурациях MySQL.
Описан в книге "Руководство администратора СУБД MYSQL", глава 7, раздел
"<A HREF="../../../www.botik.ru/~rldp/mysql/mysqladm/myisam.htm">7.1
Таблицы MyISAM</A>".</p></li>

<li><p><code>InnoDB</code>: использован для прикладных программ диалоговой
обработки запросов и ряда свойств, включая поддержку транзакций ACID и
внешние ключи. <code>InnoDB</code> включен по умолчанию во все двоичные
дистрибутивы MySQL 5.1. Описан в книге "Руководство администратора СУБД
MYSQL", глава 7, раздел
"<A HREF="../../../www.botik.ru/~rldp/mysql/mysqladm/tables.htm">7.6
Таблицы InnoDB</A>".</p></li>

<li><p><a href="#se-falcon"><code>Falcon</code></a>: работает с
многократными потоками и безопасной средой транзакции, которая безопасно
хранит данные при обеспечении весьма высокой производительности.</p>

<p><span class="bold"><strong>ПРЕДУПРЕЖДЕНИЕ:</strong></span> Falcon в
настоящее время обеспечивается только внутри ветки MySQL 5.1 и не
рассматривается готовым к выпуску. Это обеспечивается только для целей
тестирования и оценки на этой стадии.</p></li>

<li><p><code>Memory</code>: сохраняет все данные в RAM для чрезвычайно
быстрого доступа в средах, которые требуют быстрых поисковых таблиц. Этот
тип памяти был прежде известен как <code>HEAP</code>. Описан в книге
"Руководство администратора СУБД MYSQL", глава 7, раздел
"<A HREF="../../../www.botik.ru/~rldp/mysql/mysqladm/isam.htm#HEAP">
7.4 Таблицы HEAP</A>".</p></li>

<li><p><code>Merge</code></a>: позволяет MySQL DBA или разработчику логически
группировать ряд идентичных <code>MyISAM</code>-таблиц и ссылаться на них как
на один объект. Хороши для VLDB-сред, типа хранилищ данных. Описан в книге
"Руководство администратора СУБД MYSQL", глава 7, раздел
"<A HREF="../../../www.botik.ru/~rldp/mysql/mysqladm/merge.htm#MERGE">
7.2 Таблицы MERGE</A>".</p></li>

<li><p><a href="#archive-storage-engine"><code>Archive</code></a>:
обеспечивает совершенное решение для сохранения и восстановления больших
количеств редко используемых исторических, архивированных данных.</p></li>

<li><p><a href="#federated-storage-engine"><code>Federated</code>
</a>: предлагает способность связать отдельные серверы MySQL, чтобы создать
одну логическую базу данных из многих физических. Очень хорош для
распределенной среды данных.</p></li>

<li><p><code>NDB Cluster (он же NDB)</code></a>: кластерный вариант базы
данных, который особенно подходит для прикладных программ с
высокоэффективными потребностями поисковой таблицы, которые также требуют
самой высокой возможной степени полезного времени и доступности. Описан
подробно в моей работе
"<A HREF="../../../www.botik.ru/~rldp/mysql/mysql/cluster/cluster.htm">
MySQL Cluster</A>".</p></li>

<li><p><a href="#csv-storage-engine"><code>CSV</code></a>: хранит
данные в текстовых файлах, использующих отделяемый запятыми формат значений.
Вы можете использовать CSV, чтобы легко обмениваться данными между другим
программным обеспечением и прикладными программами, которые могут
импортировать и экспортировать в формате CSV.</p></li>

<li><p><a href="#blackhole-storage-engine"><code>Blackhole</code>
</a>: принимает к записи, но не сохраняет данные, а поиски всегда возвращают
пустой набор. Функциональные возможности могут использоваться в
распределенном проекте базы данных, где данные автоматически скопируются, но
не сохранены локально.</p></li>

<li><p><a href="#example-storage-engine"><code>Example</code></a>:
это тип памяти, который не делает ничего. Вы можете создавать таблицы с ним,
но никакие данные не могут быть сохранены в них или восстановлены из них.
Цель этого типа памяти в том, чтобы служить примером того, как вообще надо
писать типы памяти. Это прежде всего представляет интерес для разработчиков.
</p></li></ul>

<p>Эта глава описывает каждый из типов памяти MySQL,
кроме <i>MySQL Cluster</i>.</p>
<p>Важно не забыть, что Вы не ограничены использованием одного и того же типа
памяти для всего сервера или схемы: Вы можете использовать различные типы
памяти для каждой таблицы в схеме.</p>

<h3><a name="storage-engine-choosing"></a>2.2.1. Выбор типа памяти</h3>
<p>Различные типы памяти, обеспеченные MySQL, разработаны для различных
случаев использования. Чтобы использовать съемную архитектуру памяти, хорошо
иметь представление относительно выгод и недостатков различных типов памяти
(хранения). Следующая таблица обеспечивает краткий обзор некоторых
вариантов, обеспеченных MySQL:</p>

<table border="1"><tbody><tr><td><span class="bold"><strong>Свойство</strong>
</span></td><td><span class="bold"><strong>MyISAM</strong></span></td>
<td><span class="bold"><strong>Memory</strong></span></td>
<td><span class="bold"><strong>InnoDB</strong></span></td>
<td><span class="bold"><strong>Archive</strong></span></td>
<td><span class="bold"><strong>NDB</strong></span></td></tr>

<tr><td>Ограничения памяти</td><td>256 TB</td><td>Да</td><td>64TB</td>
<td>Нет</td><td>384 EB<sup>[4]</sup></td></tr>
<tr><td>Транзакции</td><td>Нет</td><td>Нет</td><td>Да</td><td>Нет</td>
<td>Да</td></tr>

<tr><td>Блокировка степени детализации</td><td>Таблица</td><td>Таблица</td>
<td>Строка</td><td>Строка</td><td>Строка</td></tr>
<tr><td>MVCC (кадр чтения)</td><td>Нет</td><td>Нет</td><td>Да</td>
<td>Да</td><td>Нет</td></tr>

<tr><td>География</td><td>Да</td><td>Нет</td><td>Да<sup>[1]</sup></td>
<td>Да<sup>[1]</sup></td><td>Да<sup>[1]</sup></td></tr>
<tr><td>Индексы B-tree</td><td>Да</td><td>Да</td><td>Да</td>
<td>Нет</td><td>Да</td></tr>

<tr><td>Hash-индексы</td><td>Нет</td><td>Да</td><td>Нет</td><td>Нет</td>
<td>Да</td></tr>
<tr><td>Поисковые индексы Full-text</td><td>Да</td><td>Нет</td><td>Нет</td>
<td>Нет</td><td>Нет</td></tr>

<tr><td>Индексы для кластера</td><td>Нет</td><td>Нет</td><td>Да</td>
<td>Нет</td><td>Нет</td></tr>
<tr><td>Кэширование данных</td><td>Нет</td><td>Не определено</td><td>Да</td>
<td>Нет</td><td>Да</td></tr>

<tr><td>Кэширование индексов</td><td>Да</td><td>Не определено</td><td>Да</td>
<td>Нет</td><td>Да</td></tr>
<tr><td>Сжатие данных</td><td>Да</td><td>Нет</td><td>Нет</td><td>Да</td>
<td>Нет</td></tr>

<tr><td>Шифрование данных<sup>[2]</sup></td><td>Да</td><td>Да</td>
<td>Да</td><td>Да</td><td>Да</td></tr>
<tr><td>Cluster</td><td>Нет</td><td>Нет</td><td>Нет</td>
<td>Нет</td><td>Да</td></tr>

<tr><td>Репликация<sup>[3]</sup></td><td>Да</td><td>Да</td>
<td>Да</td><td>Да</td><td>Да</td></tr>
<tr><td>Поддержка внешнего ключа</td><td>Нет</td><td>Нет</td><td>Да</td>
<td>Нет</td><td>Нет</td></tr>

<tr><td>Копия / восстановление на момент времени<sup>[3]</sup></td>
<td>Да</td><td>Да</td><td>Да</td><td>Да</td><td>Да</td></tr>
<tr><td>Поддержка кэша запросов</td><td>Да</td><td>Да</td><td>Да</td>
<td>Да</td><td>Да</td></tr>
<tr><td>Модификация статистики для словаря данных</td><td>Да</td><td>Да</td>
<td>Да</td><td>Да</td><td>Да</td></tr></tbody></table>

<p>Некоторые необходимые пояснения:
<ul type="disc"><li><p>[1] Поддерживает пространственные типы данных, но
не выполняет индексацию таких данных.</p></li>

<li><p>[2] Выполнено в сервере (через функции шифрования),
а не в типе памяти.</p></li>
<li><p>[3] Выполнено в сервере, а не в типе памяти.</p></li>
<li><p>[4] EB = exabyte (экзабайт = 1024 * 1024 терабайт).</p></li></ul>

<h3><a name="storage-engine-compare-transactions"></a>2.2.2. Сравнение
транзакционных и не транзакционных таблиц</h3>
<p>Транзакционно-безопасные таблицы (TST) имеют несколько преимуществ над не
транзакционно-безопасными таблицами (NTST):</p>

<ul type="disc"><li><p>Они более надежные. Даже если MySQL терпит крах, или
Вы получаете аппаратные проблемы, Вы можете получить Ваши данные обратно
автоматическим восстановлением или из копии плюс файл регистрации транзакции.
</p></li>

<li><p>Вы можете объединять много инструкций и принимать их все в то же самое
время инструкцией <code>COMMIT</code> (если autocommit выключен).</p></li>
<li><p>Вы можете выполнять <code>ROLLBACK</code>, чтобы игнорировать Ваши
изменения (если autocommit выключен).</p></li>

<li><p>Если произошел сбой модификации, все Ваши изменения вернутся. С не
транзакционно-безопасными таблицами все изменения, которые
имели место, постоянны.</p></li>

<li><p>Транзакционно-безопасные типы памяти могут обеспечивать лучший
параллелизм для таблиц, которые делают много
модификаций одновременно с чтением.</p></li></ul>

<p>Вы можете объединять транзакционно-безопасные и не
транзакционно-безопасные таблицы в тех же самых инструкциях. Однако, хотя
MySQL поддерживает несколько транзакционно-безопасных типов памяти
(хранения), для самых лучших результатов, Вы не должны смешивать различные
типы внутри транзакции с заблокированным autocommit. Например, если Вы
делаете это, изменения для не транзакционно-безопасной таблицы все еще
совершены немедленно и не могут быть прокручены обратно.</p>

<p>Не транзакционно-безопасные таблицы также имеют несколько преимуществ,
которые происходят из того, что не имеется никаких непроизводительных
затрат на транзакции:</p>

<ul type="disc"><li><p>Намного быстрее.</p></li>
<li><p>Более низкие требования дискового пространства.</p></li>
<li><p>Меньшее количество памяти требуется, чтобы выполнить модификации.
</p></li></ul>

<h3><a name="storage-engines-other"></a>2.2.3. Другие типы памяти</h3>
<p>Другие типы памяти могут быть доступны от третьих лиц, которые
использовали Custom Storage Engine interface.</p>

<p>Вы можете находить подробную информацию в списке типов памяти третьего
лица на странице MySQL Forge Storage Engines
<a href="../../../forge.mysql.com/projects/search.php@t=tag&k=storage%20engine" target="_top">
http://forge.mysql.com/projects/search.php?t=tag&amp;k=storage%20engine</a>.
</p>

<p><b>Примечание.</b> типы памяти от третьего лица не обеспечиваются MySQL.
Для дальнейшей информации, документации, руководств по установке, ошибкам,
сообщениям, любой справки или помощи по работе с этими типами памяти,
пожалуйста, входите в контакт с разработчиком непосредственно.</p>

<p>На текущий момент есть следующие сторонние типы памяти:</p>
<ul type="disc"><li><p><span class="bold"><strong>
<a href="../../../forge.mysql.com/projects/view.php@id=43" target="_top">
PrimeBase XT (PBXT)</a></strong></span>: PBXT был разработан для современного
web-основанного параллелизма.</p></li>

<li><p><span class="bold"><strong>
<a href="../../../forge.mysql.com/projects/view.php@id=82" target="_top">
RitmarkFS</a></strong></span> RitmarkFS позволяет Вам обращаться и управлять
файловой системой, используя SQL-запросы. RitmarkFS также поддерживает
репликацию файловых систем и трэкинг изменений.</p></li>

<li><p><span class="bold"><strong>
<a href="../../../forge.mysql.com/projects/view.php@id=91" target="_top">
Distributed Data Engine</a></strong></span>: Open Source проект, который
специализирован, чтобы обеспечить поддержку распределенных данных согласно
статистике рабочей нагрузки.</p></li>

<li><p><span class="bold"><strong>
<a href="../../../forge.mysql.com/projects/view.php@id=98" target="_top">
mdbtools</a></strong></span>: съемный тип памяти, который позволяет доступ
только для чтения к  <code>.mdb</code>-файлам базы данных Microsoft Access.
</p></li>

<li><p><span class="bold"><strong>
<a href="../../../forge.mysql.com/projects/view.php@id=139" target="_top">
solidDB for MySQL</a></strong></span> разработан для задание-критических
реализаций, которые требуют транзакционные базы данных. solidDB многопоточный
драйвер, который полностью поддерживает ACID со всеми ожидаемыми уровнями
изоляции транзакции, блокировкой уровня строки и многоверсионным управлением
параллелизма (MVCC) с не блокируемыми чтением и записью.</p></li></ul>

<p>Для подробной информации относительно разработки типа памяти, который
может использоваться со съемной архитектурой памяти обратитесь к
<a href="../../../dev.mysql.com/doc/internals/en/custom-engine.html"
target="_top">Writing a Custom Storage Engine</a> в MySQL Internals.</p>

<h2><a name="storage-engine-setting"></a>2.3. Установка типа памяти</h2>
<p>Когда Вы создаете новую таблицу, Вы можете определять, который тип памяти
использовать, добавляя опцию <code>ENGINE</code> к
инструкции <code>CREATE TABLE</code>:</p>
<pre>
CREATE TABLE t (i INT) ENGINE = INNODB;
</pre>

<p>Если Вы опускаете опцию <code>ENGINE</code> или <code>TYPE</code>,
используется заданный по умолчанию памяти. Обычно это <code>MyISAM</code>,
но Вы можете изменять это, используя опцию сервера
<code>--default-storage-engine</code> или
<code>--default-table-type</code>, либо устанавливая опцию
<code>default-storage-engine</code> или <code>default-table-type</code> в
файле конфигурации <code>my.cnf</code>.</p>

<p>Вы можете устанавливать заданный по умолчанию тип памяти, который нужно
использовать в течение текущего сеанса, устанавливая
переменную <code>storage_engine</code>:</p>
<pre>
SET storage_engine=MYISAM;
</pre>

<p>Когда MySQL установлен на Windows, используя MySQL Configuration Wizard,
<code>InnoDB</code> может быть выбран как значение по
умолчанию вместо <code>MyISAM</code>.</p>

<p>Чтобы преобразовывать таблицу из одного типа памяти в другой, используйте
инструкцию <code>ALTER TABLE</code>, которая указывает новый тип памяти:</p>
<pre>
ALTER TABLE t ENGINE = MYISAM;
</pre>

<p>Если Вы пробуете использовать тип памяти, который не компилируется в
сервер (или компилируется, но дезактивирован), MySQL взамен создает таблицу,
использующую заданный по умолчанию тип памяти, обычно <code>MyISAM</code>.
Это поведение удобно, когда Вы хотите копировать таблицы между серверами
MySQL, которые поддерживают различные типы памяти.</p>

<p>Эта автоматическая замена заданного по умолчанию типа памяти для
недоступных типов может путать новых пользователей MySQL. Предупреждение
сгенерировано всякий раз, когда тип памяти автоматически изменен.</p>

<p>Для новых таблиц MySQL всегда создает <code>.frm</code>-файл, чтобы
сохранить определения столбцов и таблицу. Индекс таблицы и данные может быть
сохранен в одном или большем количестве других файлов, в зависимости от типа
памяти. Сервер создает <code>.frm</code>-файл выше уровня типа памяти.
Индивидуальные типы создают любые дополнительные файлы, требуемые для таблиц,
с которыми они управляются. Если имя таблицы содержит специальные символы,
имена для файлов таблицы содержат закодированные версии тех символов. База
данных может содержать таблицы различных типов. То есть, не все таблицы
должны быть созданы с тем же самым типом памяти.</p>

<h2><a name="se-falcon"></a>2.4. Тип памяти Falcon</h2>
<p>Тип памяти Falcon был разработан с современными требованиями базы данных в
памяти, и особенно для использования в web-сайтах большого объема или другой
среде, которая требует высокой эффективности, при обеспечении транзакций и
регистрации функциональных возможностей, требуемых в этой среде.</p>

<h3>Предупреждение</h3>
<p>Falcon в настоящее время Alpha-релиз и не должен использоваться в
промышленных средах. Falcon в настоящее время обеспечивается только внутри
ветви MySQL 5.1 и не рассматривается готовым. Это обеспечивается только
для целей оценки и тестирования. Обратите внимание, что MySQL 5.1 Falcon не
может включать все ошибки или свойства, которые
применяются к главному дереву 5.1.</p>

<p>Falcon в настоящее время доступен только для 32-разрядной Windows и
32 или 64-разрядной Linux. Дополнительные платформы будут добавлены
после alpha-версии.</p>

<h3><a name="se-falcon-features"></a>2.4.1. Свойства Falcon</h3>
<p>Falcon был разработан для систем, которые способны поддерживать большую
память и многопоточные или мультиядерные среды CPU. Большинство 64-битных
систем представляют собой идеальные платформы для Falcon, где имеется большое
доступное пространство памяти и 2, 4 или 8-ядерные CPU. Это также может быть
развернуто внутри стандартной 32-разрядной среды.</p>

<p>Falcon поддерживает ряд главных особенностей, которые делают возможным его
применение в среде с большими нагрузками:</p>
<ul type="disc"><li><p>Multi Version Concurrency Control (MVCC) дает
возможность записям и таблицам модифицироваться без непроизводительных
затрат, связанных с блокировками уровня строки. Реализация MVCC фактически
устраняет потребность блокировать таблицы или строки в
течение процесса модификации.</p></li>

<li><p>Гибкая блокировка, включая гибкие уровни блокировки и интеллектуальное
обнаружение тупика хранит защищенные данные и транзакции, выполняя текущие
операции в максиальном быстродействии.</p></li>

<li><p>Оптимизирован для современных CPU, чтобы поддерживать много потоков,
позволяя много транзакций и быструю обработку каждой транзакции.</p></li>
<li><p>Transaction-safe (полностью совместим с ACID) и способен обрабатывать
многократные параллельные транзакции.</p></li>

<li><p>Последовательный файл регистрации обеспечивает высокую эффективность и
возможности восстановления без того, чтобы жертвовать эффективностью.
</p></li>
<li><p>Продвинутые индексы B-Tree.</p></li>

<li><p>Сервер предписывает справочную целостность и всегда
гарантирует проверку правильности данных.</p></li>
<li><p>Сжатие данных сохраняет информацию на диск в сжатом формате, сжимая и
декомпрессируя данные на лету. Результат в меньших и более эффективных
физических размерах данных.</p></li>

<li><p>Интеллектуальное дисковое управление автоматически управляет размером
файла на диске, расширениями и восстановлением места.</p></li>
<li><p>Данные и индексное кэширование обеспечивают быстрый доступ к данным
без требования загрузить индексные данные с диска.</p></li>
<li><p>Неявные точки сохранения гарантируют целостность
данных в течение транзакций.</p></li></ul>

<h3><a name="se-falcon-configuration"></a>2.4.2. Параметры конфигурации</h3>
<p>Параметры конфигурированы через стандартный файл <code>my.cnf</code> или
<code>my.ini</code>. Параметры могут быть конфигурированы, определяя имя
параметра и соответствующее значение через пробел. Значения Memory могут быть
определены в байтах или числом, сопровождаемым <code>kb</code>,
<code>mb</code> или <code>gb</code>.</p>

<ul type="disc"><li><p><code>falcon_min_record_memory</code>
(Record Cache Base) устанавливает минимальный объем памяти, который будет
распределен для кэширования данных при записи. Когда кэш-память убирает
мусор, процесс остановится, пока использование кэша не достигнет этого
значения. Значение по умолчанию:
<code>falcon_max_record_memory</code>/2 (10 MB).</p></li>

<li><p><code>falcon_max_record_memory</code> (Record Cache Top) устанавливает
максимальный размер памяти, которая будет распределена для кэширования данных
при записи. Значение по умолчанию 20 MB.</p></li>

<li><p><code>falcon_page_cache_size</code> (Page Cache Size) устанавливает
объем памяти, который будет распределен для кэширования страниц из файла
пространства таблицы. Значение по умолчанию 4 MB.</p></li></ul>

<p>Связь между кэшем записи и кэшем страницы управляется информацией, которая
кэшируется каждой системой. Целые записи, которые находятся в активном
использовании (читаемые или модифицируемые) сохранены внутри кэша записи,
однако, данные <code>BLOB</code> сохранены только внутри кэша страницы.</p>

<p>Кэш страницы используется, чтобы сохранить метаданные базы данных, данные
<code>BLOB</code> и индексы таблицы.</p>
<p>Параметры Falcon также могут быть установлены в командной строке
<span><strong>mysqld</strong></span> через использование следующих
параметров командной строки:</p>

<ul type="disc"><li><p><code>--falcon-max-record-memory=#</code></p></li>
<li><p><code>--falcon-min-record-memory=#</code></p></li>
<li><p><code>--falcon-page-cache-size=#</code></p></li></ul>

<p>Вы можете также допускать и отключать тип памяти Falcon при запуске,
обеспечивая эти параметры <span><strong>mysqld</strong></span>, если этот
<code>mysqld</code> включает тип памяти Falcon:</p>
<ul type="disc"><li><p><code>--falcon</code> включает Falcon.</p></li>
<li><p><code>--skip-falcon</code> выключает Falcon.</p></li></ul>

<h3><a name="se-falcon-createdb"></a>2.4.3.
Создание пространства таблиц Falcon</h3>
<p>Внутри Falcon все данные внутри одной базы данных сохранены внутри
одиночного пространства таблиц, которое в свою очередь сохранено внутри
одного файла в структуре каталогов MySQL. Одиночная база данных Falcon
создаст три главных файла. Один файл содержит данные Falcon и будет сохранен
в файле с именем базы данных Falcon с расширением <code>.fts</code>.
Например, таблицы Falcon определенные в базе данных <code>test</code>, будут
сохранены внутри файла <code>test.fts</code> в каталоге баз данных MySQL.</p>

<p>Два других файла содержат дисковую копию последовательного файла
регистрации Falcon. Они также созданы внутри области соответствующей базы
данных. В будущем выпуске Вы сможете определить альтернативное расположение
для этих журналов. Так с вышеупомянутым файлом данных примера
<code>test.fts</code> журналы будет именованы
<code>test.fl1</code> и <code>test.fl2</code>.</p>

<p>Определения таблицы, как с другими типами памяти MySQL, сохранены в файл
<code>.frm</code> в каталоге базы данных. Например, таблица
<code>falcontest</code> в базе данных <code>test</code> создаст файл
определения (описания) таблицы <code>falcontest.frm</code> в каталоге test.
</p>

<p>При создании таблицы внутри базы данных MySQL, где соответствующий файл
пространства таблиц Falcon не существует, это будет автоматически создано с
файлом данных и журналами.</p>

<h3><a name="se-falcon-createtable"></a>2.4.4.
Создание таблиц и индексов в Falcon</h3>
<p>Falcon поддерживает все стандартные типы данных
столбцов, обеспечиваемые MySQL.</p>

<p>Чтобы создать таблицу, которая использует Falcon, примените опцию
<code>ENGINE = Falcon</code> в инструкции <code>CREATE TABLE</code>:</p>
<pre>
CREATE TABLE names (id INT, fname VARCHAR (20),
                    lname VARCHAR (20)) ENGINE=Falcon
</pre>

<p>Индексы могут быть созданы, используя все стандартные методы, например, Вы
можете явно определять индекс на столбце:</p>
<pre>
CREATE TABLE ids (id int, index (id)) ENGINE=Falcon
</pre>

<p>Генерируйте один как часть первичного ключа:</p>
<pre>
CREATE TABLE ids (id int),PRIMARY KEY (id) ENGINE=Falcon
</pre>

<p>Или Вы можете создавать много ключей и многократные индексы:</p>
<pre>
CREATE TABLE t1 (id int NOT NULL, id2 int NOT NULL, id3 int NOT NULL,
                 name CHAR(30), primary key (id, id2),
                 index index_id3 (id3)) ENGINE=Falcon
</pre>

<h3><a name="se-falcon-principles"></a>2.4.5. Принципы и терминология</h3>
<p>Вы должны понять следующие базисные принципы и терминологию.</p>
<p>MySQL Falcon объединяет продвинутые методы с упрощенной структурой,
которая приводит к высокоэффективной транзакционной базе данных, которая
требует небольшого сопровождения или поиска неисправностей
администратором базы данных.</p>

<ul type="disc"><li><p><span class="bold"><strong>Файл данных пользователя
</strong></span> сохраняет данные Falcon.</p></li>
<li><p><span class="bold"><strong>Последовательный файл регистрации Falcon
</strong></span> содержит недавно совершенные изменения данных, индексные
изменения и транзакционную информацию. Также обеспечивает
средства восстановления данных.</p></li>

<li><p><span class="bold"><strong>Кэш страницы</strong></span> хранит
страницы базы данных.</p></li>
<li><p><span class="bold"><strong>Кэш записи</strong></span> хранит копии
активных и нейтральных записей.</p></li>
<li><p><span class="bold"><strong>Память системы</strong></span> хранит
информацию контекста транзакции, индексные акселераторы и метаданные системы.
</p></li>

<li><p><span class="bold"><strong>Рабочие потоки</strong></span> являются
фоновыми потоками. Имеются два потока: поток "gopher" перемещает данные из
последовательный файла регистрации Falcon в кэш страницы базы данных и из
кэша страниц на диск. Второй поток программы записи страницы, который
пишет страницы с blob.</p></li></ul>

<h4><a name="se-falcon-principles-tablespace"></a>
2.4.5.1. Файл и структуры данных Falcon</h4>
<p>Одиночные файлы базы данных Falcon хранят все данные записи, индексы,
структуру базы данных и другую информацию.
Индивидуальная информация сохранена в ряде страниц.</p>

<p>Страницы описывают блок распределения оперативной памяти в Falcon.
Страницы используются, чтобы сохранить данные и индексировать информацию.
Размер страницы и то, как Falcon кэширует и распределяет страницы для
использования при сохранении информации, воздействует на эффективность в
зависимости от записей, которые сохраняются.</p>

<p>Страницы, кэшируемые в памяти используются, чтобы сохранить индексы,
blob'ы и структурные данные для конкретного пространства таблиц. Активные
записи сохранены внутри отдельного кэша записей.</p>

<p>Все транзакции в базе данных регистрируются и сохранены внутри отдельного
журнала. Журнал автоматически сбрасывается и изменения записываются на диск,
когда имеется команда <code>COMMIT</code>, когда включен auto-commit или
автоматически через каждые 30 секунд, когда транзакции не используются.</p>

<h4><a name="se-falcon-principles-logging"></a>
2.4.5.2. Последовательный файл регистрации Falcon</h4>
<p>Falcon использует последовательный файл регистрации, чтобы сохранить
некоторые типы информации до того, как данные окончательно сохранятся в базе
данных. Файл регистрации используется, чтобы сохранить
следующие типы информации:</p>

<ul type="disc"><li><p>Записи данных в течение совершающейся фазы.</p></li>
<li><p>Физические изменения базы данных, требуемые для восстановления данных
после аварийного отказа.</p></li>

<li><p>Логические изменения базы данных, требуемые для восстановления ресурса
после аварийного отказа.</p></li>
<li><p>Изменения статуса для всех активных транзакций.</p></li></ul>

<p>Все транзакции в Falcon записаны в последовательный файл регистрации
Falcon, а затем переданы к базе данных автоматически, если включен
<code>AUTOCOMMIT</code>, или вручную, когда
используется команда <code>COMMIT</code>.</p>

<p>Регистрация информации сохранена в памяти, и несохранные изменения файла
регистрации периодически сбрасываются на диск. Фоновый поток обрабатывает
содержание файла регистрации, передавая) изменения файла регистрации в базу
данных. Передающий процесс устанавливает конечное состояние всех записей и
страниц, независимо от любых вмешивающихся состояний, только конечное
состояние фактически записано на диск.</p>

<p>Обратите внимание, однако, что последовательный файл регистрации только
модифицирует данные записи через кэш страницы в оперативной памяти.
Фактические данные записи будут записаны на диск, когда происходит процесс
контрольной точки. Исключительная ситуация к этому правилу: индексные и
blob-записи, которые немедленно записаны на диск как часть процесса.</p>

<p>Falcon создает два последовательных журнала. Первый журнал используется,
чтобы сохранить последовательные данные файла регистрации, пока файл
регистрации не достигает определенного размера. Если только этот размер был
достигнут, регистрация переключена на второй последовательный журнал.
Процесс продолжает читать из первого журнала, пока все транзакции не будут
записаны в базу данных. Первый журнал затем освобожден и вновь создан.</p>

<p>Входы файла регистрации во втором файле затем обработаны до тех пор, пока
все транзакции в файле регистрации завершены. Тот файл затем освобожден и
вновь создан, готовым к использованию, как только первый журнал наполнится
или станет блокированным для передачи.</p>

<h5><a name="se-falcon-principles-logging-rollback"></a>
2.4.5.2.1. Процесс обратной перемотки</h5>
<p>Обратные перемотки транзакции обработаны потоком для соответствующей
транзакции. Процесс обратной перемотки выполняет следующие действия:</p>

<ul type="disc"><li><p>Отступающие индексные модификации.</p></li>
<li><p>Отменяет любые данные blob, созданные транзакцией.</p></li>
<li><p>Освобождает распределенные слоты записи.</p></li>
<li><p>Отменяет версию записи, созданную в памяти.</p></li></ul>

<h5><a name="se-falcon-principles-logging-groupcommit"></a>
2.4.5.2.2. Групповое завершение транзакций</h5>
<p>Для эффективности Falcon использует систему, которая гарантирует, что все
ждущие обработки модификации последовательного файла регистрации записаны на
диск в то же самое время. Falcon может иметь многократные активные
транзакции, но транзакции записывают все ждущие обработки изменения
последовательного файла регистрации на диск только однократно, уменьшая число
записей на диск и улучшая полную эффективность последовательного
файла регистрации. Например:</p>

<ol type="1"><li><p>Транзакция 1 создает все необходимые входы файла
регистрации и начинает записывать файл регистрации на диск.</p></li>
<li><p>В то время как транзакция 1 завершается, транзакции 2 и 3 записывают
их входы в последовательный файл регистрации.</p></li>

<li><p>Как только транзакция 1 закончила физическую запись, или транзакция 2
или 3 (но не обе) запишут незаписанную часть данных, находящуюся в
оперативной памяти, файл регистрации будет готов к сбросу на диск. Потому как
обе транзакции произошли после с последней записи на диск последовательного
файла регистрации, информация для обемх записана на диск в то же самое время.
</p></li>

<li><p>В то время как транзакции 2 и 3 записывают, транзакции 4, 5 и 6
записываются в журнал в оперативной памяти. Когда запись для 2 и 3
завершается, входы для 4, 5 и 6 записаны.</p></li></ol>

<p>Результат вышеупомянутого процесса: имеются только три физические записи
на диск, даже при том, что имеется шесть транзакций в последовательности:</p>
<ul type="disc"><li><p>Транзакция 1,</p></li>
<li><p>Транзакции 2 и 3,</p></li>
<li><p>Транзакции 4, 5 и 6.</p></li></ul>

<p>Процесс продолжает работать только с одной транзакцией, записывающей все
последовательные входы файла регистрации в оперативной памяти на диск,
начиная с последней записи. Вся система гарантирует, что оперативная память и
дисковый файл регистрации сохраняются в синхронизации с самым низким
количеством физических записей на диск.</p>

<p>Вышеупомянутый процесс работает в тандеме с использованием двух
последовательных журналов, чтобы гарантировать, что информация в оперативной
памяти и на диске обновляется своевременно.</p>

<h4><a name="se-falcon-principles-recovery"></a>2.4.5.3.
Восстановление аварийного отказа Falcon</h4>
<p>Последовательный файл регистрации Falcon используется автоматически, когда
первая таблица в базе данных Falcon открыта, чтобы восстановить транзакции и
модифицировать базу данных. Когда транзакции и изменения записаны в
последовательный файл регистрации, он включает входы, которые записывают
изменения для всех областей базы данных, включая индексы, изменения для
данных <code>BLOB</code> и любые структурные изменения базы данных.</p>

<p>В течение восстановления аварийного отказа Falcon исследует
последовательный файл регистрации и идентифицирует первый вход, который не
был передан к базе данных. Процесс восстановления записывает все незаписанные
данные, изменяет индекс и данные blob, освобождая любые необходимые слоты
записи (из удаленных записей) и завершая любые структурные изменения.</p>

<h4><a name="se-falcon-principles-caches"></a>2.4.5.4. Кэши памяти Falcon
</h4>
<p>Falcon был разработан, чтобы выполняться лучше всего на системах с щедрыми
объемами памяти. Кэши памяти, используемые Falcon подобны в некоторых
отношениях другим СУБД и MySQL. Однако, структура кэш имеет ряд
усовершенствований по сравнению с традиционной cтратегией кэширующей памяти.
Механизмы, используемые Falcon относительно кэширования памяти включают:</p>

<ul type="disc"><li><p><span class="bold"><strong>Log Cache</strong></span>
информация файла регистрации сохраняется в памяти и сбрасывается на диск,
когда транзакции совершаются. Falcon хранит восемь окон для чтения и записи в
журнал, и каждое окно 1 MB.</p></li>

<li><p><span class="bold"><strong>System and Index Cache</strong></span>
данные, необходимые Falcon (определения таблицы и полей, состояние транзакции
и т.д.) также поддерживаются в памяти для справочника. Кроме того, локальные
индексные акселераторы представляют индексные сегменты, созданные
выполняющейся транзакцией, также сохранены в памяти системы. Когда транзакция
изменяет индексированные поля, это формирует индексный раздел акселератора в
памяти системы, представляя изменения. При завершении транзакции все
индексные измене ния для транзакции записаны в сортируемом порядке в
последовательный вход и позже объединены с постоянным индексом.</p></li>

<li><p><span class="bold"><strong>Page Cache</strong></span> страницы базы
данных читаются с диска для специфической базы данных. Размер кэша страницы
управляется параметром <code>falcon_page_cache_size</code>, значение по
умолчанию которого 4 MB установлено в файле <code>my.cnf</code>. Хотя
изменения записи и индекса идут в последовательный файл регистрации прежде,
чем запишутся в страницы базы данных, данные blob записаны непосредственно в
кэш страницы. Это не дает регистрировать большие элементы данных, которые
редко вызваны или изменены транзакцией, которая создает их.</p></li>

<li><p><span class="bold"><strong>Record Cache</strong></span> кэш записи
представляет собой область памяти в зоне ожидания строк, которые были
запрошены запросами конечного пользователя для специфической базы данных или
созданы активными транзакциями. Обратите внимание, что этот кэш отличается от
традиционных кэшей данных тем, что только специфические строки, необходимые
прикладным программам, постоянно находятся в кэше в противоположность всем
данным страницы (которая может содержать только подмножества необходимой
информации). Кэш записи может хранить несколько версий записей, которые
изменились или удалены. Эта методика гарантирует, что активные данные,
необходимые, чтобы удовлетворять запросы пользователя находятся в памяти,
сокращают время доступа к строке и уменьшают кэш, не включая незапрошенную
информацию. Кэш записи также помогает в обеспечении механизм многоверсионного
управления параллелизма (MVCC). Кэш записи управляется двумя параметрами.
Параметр <code>falcon_min_record_memory</code> (заданный по умолчанию в 10
MB) определяет минимальное количество RAM, обеспеченной кэшу записи, а
<code>falcon_max_record_memory</code> (заданный по умолчанию в 20 MB)
ограничивает общую сумму памяти, доступной кэшу.</p></li>

<li><p>Из-за поддержки кэша записи транзакциями, используется
поток-мусоросборщик, чтобы гарантировать только горячие данные постоянно
находятся в кэше. Когда ограничение <code>falcon_max_record_memory</code>
достигнуто, Falcon рассматривает демографию данных в кэше и удаляет самые
старые поколения. Этот процесс более усложнен, чем стандартный алгоритм LRU,
используемый многими системами баз данных, но это более эффективно и быстро.
</p></li></ul>

<h4><a name="se-falcon-principles-threads"></a>2.4.5.5. Потоки Falcon</h4>
<p>Falcon использует два рабочих потока, чтобы обработать информацию внутри
структур Falcon. Один поток посвящен перемещению совершенных изменений данных
из файла регистрации на страницы и объединению индексных изменений с
постоянными индексными данными. Второй обрабатывает периодический сброс кэша
страницы и убирает мусор, распределенный внутри кэша записи.</p>

<h4><a name="se-falcon-principles-compression"></a>2.4.5.6. Сжатие данных
</h4>
<p>Данные, сохраненные в пространстве таблиц Falcon сжаты на диске, но
сохранены в несжатом формате в памяти. Сжатие происходит автоматически, когда
данные переданы на диск.</p>

<h4><a name="se-falcon-principles-recordslot"></a>2.4.5.7. Слот записи</h4>
<p>Слот записи представляет собой внутренний идентификатор записи, который
используется, чтобы найти записи в памяти и на диске. Это по существу
указатель на страницы, которые содержат данные для специфической записи.
Новый слот записи создан для каждой записи на время продолжительности
существования этой записи. Слот записи освобожден только, когда запись
удалена из базы данных.</p>

<h3><a name="se-falcon-limits"></a>2.4.6. Ограничения</h3>
<p>Имеется ряд ограничений в alpha-версии Falcon.
В дальнейшем они постепенно будут сниматься:</p>

<ul type="disc"><li><p>Не работает <code>SELECT FOR UPDATE</code>.</p></li>
<li><p>Для Alpha-версии максимальная длина ключа ограничена 1100 байтами.
</p></li>

<li><p>Уровни изоляции Serializable не обеспечиваются.</p></li>
<li><p>Конфигурация времени ожидания для блокировки не обеспечивается.
</p></li>

<li><p>Распределенные транзакции не обеспечиваются.</p></li>
<li><p>Имеется ограничение 2<sup>32</sup> (4.29 миллиарда) строк для
одиночной таблицы. Используя много таблиц внутри того же самого пространства
таблиц Вы можете иметь больше, чем это число записей. В будущем выпуске это
ограничение будет удалено.</p></li>

<li><p>Размеры страницы с перестраиваемой конфигурацией не обеспечиваются, но
запланированы на будущий выпуск.</p></li>
<li><p>Таблицы Falcon могут поддерживать до 32000 столбцов.</p></li>

<li><p>Каждое пространство таблиц имеет ограничение в 2<sup>32</sup> страниц
внутри одиночного пространства. Через комбинацию размера страницы и
максимального числа страниц имеется ограничение 140737488355328 байт
(128 TB) одиночного пространства таблиц.</p></li>

<li><p>Интерактивное резервирование не обеспечивается, но поддержка
запланирована в будущем выпуске.</p></li>
<li><p>Поддержка внешнего ключа в настоящее время недоступна.</p></li></ul>

<p>Хотя максимальная доступная память внутри пространства таблиц 128 TB,
истинное число записей и объем данных, которые Вы можете сохранять, зависит
от ряда факторов:</p>

<ul type="disc"><li><p>Требования памяти записью.</p></li>
<li><p>Индексные требования памяти.</p></li>
<li><p>Коэффициент сжатия сохраненных данных.</p></li></ul>

<p>Из-за сложной связи между памятью, индексом и средствами сжатия невозможно
предсказать или вычислить количество памяти на диске, требуемое для
специфического набора данных.</p>

<h2><a name="example-storage-engine"></a>2.5.
Тип памяти <code>EXAMPLE</code></h2>
<p>Тип памяти <code>EXAMPLE</code> представляет собой заглушку, которая не
делает ничего. Он только показывает, как надо разрабатывать типы памяти.</p>

<p>Тип памяти <code>EXAMPLE</code> включен в двоичные дистрибутивы MySQL-Max.
Чтобы его включить, если Вы формируете MySQL из исходного текста, вызовите
<span><strong>configure</strong></span> с опцией
<code>--with-example-storage-engine</code>.</p>

<p>Чтобы исследовать исходник типа памяти <code>EXAMPLE</code>, смотрите
каталог <code>storage/example</code> исходных текстов MySQL.</p>
<p>Когда Вы создаете таблицу типа <code>EXAMPLE</code>, сервер честно создает
файл формата таблицы в каталоге баз данных. Имя файла начинается с имени
таблицы и имеет расширение <code>.frm</code>. Никакие другие файлы не
созданы. Никакие данные не могут быть сохранены в таблицу.
Запросы возвращают пустой результат:</p>

<pre>
mysql&gt; CREATE TABLE test (i INT) ENGINE = EXAMPLE;
Query OK, 0 rows affected (0.78 sec)
mysql&gt; INSERT INTO test VALUES(1),(2),(3);
ERROR 1031 (HY000): Table storage engine for 'test' doesn't ┬╗
                    have this option
mysql&gt; SELECT * FROM test;
Empty set (0.31 sec)
</pre>
<p>Тип <code>EXAMPLE</code> не поддерживает индексацию.</p>

<h2><a name="federated-storage-engine"></a>2.6.
Тип памяти <code>FEDERATED</code></h2>
<p>Тип памяти <code>FEDERATED</code> обращается к данным в таблицах удаленных
баз данных, а не в локальных таблицах.</p>

<p>Тип памяти <code>FEDERATED</code> включен в двоичные дистрибутивы
MySQL-Max. Чтобы его включить, если Вы формируете MySQL из исходного текста,
вызовите <span><strong>configure</strong></span> с опцией
<code>--with-federated-storage-engine</code>.</p>

<p>Чтобы исследовать исходник типа памяти <code>FEDERATED</code>, смотрите
каталог <code>sql</code> исходных текстов MySQL.</p>
<p><span class="bold"><strong>Дополнительные ресурсы:</strong></span></p>

<ul type="disc"><li><p>Форум, специализированный на типе
<code>FEDERATED</code>, доступен на
<a href="../../../forums.mysql.com/list.php@105" target="_top">
http://forums.mysql.com/list.php?105</a>.</p></li></ul>

<h3><a name="federated-description"></a>2.6.1. Описание типа памяти
<code>FEDERATED</code></h3>
<p>Когда Вы создаете таблицу типа <code>FEDERATED</code>, сервер создает файл
формата таблицы в каталоге баз данных. Имя файла начинается с имени таблицы и
имеет расширение <code>.frm</code>. Никакие другие файлы не созданы, потому
что фактические данные находятся в удаленной таблице. Это отличается от
способа, которым работают типы памяти для локальных таблиц.</p>

<p>Для локальных таблиц базы данных файлы данных локальны. Например, если Вы
создаете <code>MyISAM</code>-таблицу с именем <code>users</code>, драйвер
<code>MyISAM</code> создает файл данных, именованный <code>users.MYD</code>.
Драйвер для локальных таблиц читает, вставляет, удаляет и модифицирует данные
в локальных файлах данных, и строки сохранены в частном формате драйвера.
Чтобы читать строки, драйвер должен анализировать данные в столбцах. Чтобы
записывать строки, значения столбцов должны быть преобразованы в формат
строки, используемый драйвером и записаны в локальный файл данных.</p>

<p>А вот в типе памяти <code>FEDERATED</code> не имеется никаких
локальных файлов данных для таблицы (например, нет файла <code>.MYD</code>).
Вместо этого удаленная база данных сохраняет данные, которые обычно были бы в
таблице. Локальный сервер соединяется с удаленным и использует клиентское API
MySQL, чтобы читать, удалять, модифицировать и вставлять данные в удаленной
таблице. Поиск данных инициализирован через инструкции SQL
<code>SELECT * FROM <em><code>tbl_name</code></em></code>. Чтобы читать
результат, строки выбраны по одной, используя функцию C API
<code>mysql_fetch_row()</code>, а затем преобразуя столбцы в наборе
результатов <code>SELECT</code> к формату, который ожидает
получить драйвер <code>FEDERATED</code>.</p>

<p>Поток информации таков:</p>
<ol type="1"><li><p>SQL-обращения выданы локально.</p></li>
<li><p>Используется MySQL handler API (данные в формате драйвера).</p></li>
<li><p>Клиентский API MySQL (данные преобразованы в обращения SQL).</p></li>

<li><p>Удаленная база данных -&gt; клиентский API MySQL.</p></li>
<li><p>Конвертация набора результатов (если надо) к формату драйвера.
</p></li></ol>

<h3><a name="federated-use"></a>2.6.2. Как использовать таблицы
<code>FEDERATED</code></h3>
<p>Процедура для использования таблиц <code>FEDERATED</code> очень проста.
Обычно Вы имеете два выполняемых сервера. В принципе возможно использовать
другую таблицу, которая управляется тем же самым сервером, хотя имеются
некоторые хитрости при этом.</p>

<p>Сначала Вы должны иметь таблицу на удаленном сервере, к которой Вы хотите
обращаться, используя таблицу <code>FEDERATED</code>. Предположите, что
удаленная таблица находится в базе данных <code>federated</code> и
определена подобно этому:</p>

<pre>
CREATE TABLE test_table (id INT(20) NOT NULL AUTO_INCREMENT,
                         name VARCHAR(32) NOT NULL DEFAULT '',
                         other INT(20) NOT NULL DEFAULT '0', PRIMARY KEY(id),
                         INDEX name (name), INDEX other_key (other))
                         ENGINE=MyISAM DEFAULT CHARSET=latin1;
</pre>

<p>Пример использует таблицу <code>MyISAM</code>, но таблица могла бы
использовать любой тип памяти.</p>
<p>Затем создайте таблицу <code>FEDERATED</code> на локальном сервере для
доступа к удаленной таблице:</p>

<pre>
CREATE TABLE federated_table (id INT(20) NOT NULL AUTO_INCREMENT,
                              name VARCHAR(32) NOT NULL DEFAULT '',
                              otherINT(20) NOT NULL DEFAULT '0',
                              PRIMARY KEY(id), INDEX name (name),
                              INDEX other_key (other)) ENGINE=FEDERATED
                              DEFAULT CHARSET=latin1
       CONNECTION='mysql://root@remote_host:9306/federated/test_table';
</pre>

<p><span class="bold"><strong>Обратите внимание</strong></span>:
<code>CONNECTION</code> заменяет <code>COMMENT</code>, используемый в
некоторых предыдущих версиях MySQL.</p>

<p>Структура этой таблицы должна быть точно такая же, как у удаленной
таблицы, за исключением того, что опция <code>ENGINE</code> таблицы должна
быть <code>FEDERATED</code>, а опция таблицы <code>CONNECTION</code> задает
строку подключения, которая указывает для драйвера <code>FEDERATED</code>,
как соединиться с удаленным сервером.</p>

<p>Тип памяти <code>FEDERATED</code> создает только файл
<code>test_table.frm</code> в базе данных <code>federated</code>.</p>
<p>Удаленная информация хоста указывает удаленный сервер, с которым Ваш
локальный соединяется, а база данных и информация таблицы указывают, которую
удаленную таблицу использовать как источник данных. В этом примере удаленный
сервер обозначен как <code>remote_host</code> (порт 9306), так что на
удаленной системе должен быть сервер MySQL, слушающий порт 9306.</p>

<p>Общая форма строки подключения в опции <code>CONNECTION</code> такова:</p>
<pre>
<em><code>scheme</code></em>://<em><code>user_name</code></em>[:<em><code>password</code></em>]@<em><code>host_name</code>
</em>[:<em><code>port_num</code></em>]/<em><code>db_name</code></em>/<em><code>tbl_name</code></em>
</pre>

<p>Только <code>mysql</code> обеспечивается как значение
<em><code>scheme</code></em> в этот момент, пароль и
номер порта факультативны.</p>

<p>Имеются некоторые примеры строк подключения:</p>
<pre>
CONNECTION='mysql://username:password@hostname:port/database/tablename'
CONNECTION='mysql://username@hostname/database/tablename'
CONNECTION='mysql://username:password@hostname/database/tablename'
</pre>

<p>Использование <code>CONNECTION</code> для определения строки подключения
не оптимально и, вероятно, измениться в будущем.</p>
<p>Потому что любой пароль, заданный в строке подключения, сохранен как
простой текст, он может быть замечен любым пользователем, который может
применить <code>SHOW CREATE TABLE</code> или <code>SHOW TABLE STATUS</code>
для таблицы <code>FEDERATED</code> или сделать запрос таблицы
<code>TABLES</code> в базе данных <code>INFORMATION_SCHEMA</code>.</p>

<h3><a name="federated-limitations"></a>2.6.3.
Ограничения типа памяти <code>FEDERATED</code></h3>
<p>Далее перечислены свойства, которые
<code>FEDERATED</code> не поддерживает:</p>

<ul type="disc"><li><p>В первой версии удаленный сервер должен быть
MySQL-сервером. Поддержка <code>FEDERATED</code> для других СУБД может
быть добавлена в будущем.</p></li>

<li><p>Удаленная таблица, на которую указывает таблица
<code>FEDERATED</code>, ДОЛЖНА существовать прежде, чем Вы попробуете
обращаться к ней через драйвер <code>FEDERATED</code>.</p></li>

<li><p>Возможно для одной таблицы <code>FEDERATED</code> указывать на другую,
но Вы должны быть внимательны, чтобы не создать цикл.</p></li>
<li><p>Не имеется никакой поддержки транзакций.</p></li>

<li><p>Не имеется никакого способа, чтобы узнать, изменилась ли удаленная
таблица. Причина этого в том, что эта таблица должна работать подобно файлу
данных, который никогда не был записан в чем-нибудь другом, чем база данных.
Целостность данных в локальной таблице могла бы быть нарушена, если бы
имелось любое изменение для удаленной базы данных.</p></li>

<li><p><code>FEDERATED</code> понимает <code>SELECT</code>,
<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code> и индексы.
Это не поддерживает <code>ALTER TABLE</code> или любые инструкции Data
Definition Language, кроме <code>DROP TABLE</code>. Текущая реализация не
использует подготовленные инструкции.</p></li>

<li><p>Любая инструкция <code>DROP TABLE</code>, выданная для таблицы
<code>FEDERATED</code>, удалит только локальную таблицу, но не удаленную.
</p></li>

<li><p>Реализованы <code>SELECT</code>, <code>INSERT</code>,
<code>UPDATE</code> и <code>DELETE</code>, но не <code>HANDLER</code>.
</p></li>

<li><p>Таблицы <code>FEDERATED</code> не работают с кэшем запроса.
</p></li></ul>
<p>Некоторые из этих ограничений могут сниматься в
будущих версиях драйвера <code>FEDERATED</code>.</p>

<h2><a name="archive-storage-engine"></a>
2.7. Тип памяти <code>ARCHIVE</code></h2>
<p>Тип памяти <code>ARCHIVE</code> используется для сохранения больших
количеств данных без индексов в очень маленьком файле.</p>

<p>Тип памяти <code>ARCHIVE</code> включен в двоичные дистрибутивы MySQL.
Чтобы его включить, если Вы формируете MySQL из исходного текста,
вызовите <span><strong>configure</strong></span> с опцией
<code>--with-archive-storage-engine</code>.</p>

<p>Чтобы исследовать исходник типа памяти <code>ARCHIVE</code>, смотрите
каталог <code>storage/archive</code> исходных текстов MySQL.</p>

<p>Вы можете проверять, является ли доступным тип памяти
<code>ARCHIVE</code> этой инструкцией:</p>
<pre>
mysql&gt; SHOW VARIABLES LIKE 'have_archive';
</pre>

<p>Когда Вы создаете таблицу типа <code>ARCHIVE</code>, сервер создает файл
формата таблицы в каталоге баз данных. Имя файла начинается с имени таблицы и
имеет расширение <code>.frm</code>. Драйвер памяти создает и другие файлы,
имена коих начинаются с имени таблицы. Данные и файлы метаданных имеют
расширения <code>.ARZ</code> и <code>.ARM</code>, соответственно. Файл
<code>.ARN</code> может появляться при операциях оптимизации.</p>

<p>Драйвер типа памяти <code>ARCHIVE</code> понимает <code>INSERT</code> и
<code>SELECT</code>, но не <code>DELETE</code>, <code>REPLACE</code> или
<code>UPDATE</code>. Это поддерживает операции <code>ORDER BY</code> столбцы
<code>BLOB</code> и в основном все, кроме пространственных, типы данных.
Блокировка уровня строки использована в <code>ARCHIVE</code>.</p>

<p>Начиная с MySQL 5.1.6, тип <code>ARCHIVE</code> поддерживает атрибут
столбца <code>AUTO_INCREMENT</code>. Такие столбцы могут иметь уникальный или
не-уникальный индекс. Попытка создавать индекс на любом другом столбце
приводит к ошибке. Тип памяти <code>ARCHIVE</code> также поддерживает опцию
таблицы <code>AUTO_INCREMENT</code> в <code>CREATE TABLE</code> и
<code>ALTER TABLE</code>, чтобы определить начальное значение
последовательности для новой таблицы или сбросить значение последовательности
для существующей таблицы, соответственно.</p>

<p>Начиная с MySQL 5.1.6, тип <code>ARCHIVE</code> игнорирует столбцы
<code>BLOB</code>, если они не запрошены, и просматривает их прошлое при
чтении. Прежде, следующий две инструкции имели ту же самую логику, но с
5.1.6 вторая намного более эффективна, чем первая:</p>

<pre>
SELECT a, b, blob_col FROM archive_table;
SELECT a, b FROM archive_table;
</pre>

<p><span class="bold"><strong>Хранение:</strong></span> строки сжаты, когда
они вставлены. Тип памяти <code>ARCHIVE</code> использует сжатие данных
<code>zlib</code> без потерь (подробности на сайте
<a href="../../../www.zlib.net/default.htm" target="_top">http://www.zlib.net/</a>).
Вы можете использовать <code>OPTIMIZE TABLE</code>, чтобы анализировать
таблицу и упаковывать ее в меньший формат (причины применения именно
<code>OPTIMIZE TABLE</code>, изложены ниже). Тип памяти также поддерживает
<code>CHECK TABLE</code>. Имеются несколько типов
вставок, которые используются:</p>

<ul type="disc"><li><p>Инструкция <code>INSERT</code> только помещает строки
в буфер сжатий, а буферные пишется по мере необходимости. Вставка в буфер
защищена блокировкой. <code>SELECT</code> сбрасывает все данные на диск, если
вставки не были <code>INSERT DELAYED</code> (такие сбрасываются
по мере необходимости).</p></li>

<li><p>Объемная вставка видима только после того, как завершается, если
другие вставки не происходят в то же самое время, тогда это может быть
замечено частично. <code>SELECT</code> никогда не вызывает сброс объемной
вставки, если нормальная вставка не происходит в это время.</p></li></ul>

<p><span class="bold"><strong>Поиск</strong></span>: при поиске строки
несжаты по требованию, не имеется никакого кэша строк. Операция
<code>SELECT</code> выполняет полный просмотр таблицы. Когда происходит
<code>SELECT</code>, это выясняет, сколько строк в настоящее время доступны,
и читает это число строк. <code>SELECT</code> выполняется как
непротиворечивое чтение. Обратите внимание, что большое количество инструкций
<code>SELECT</code> в течение вставки может ухудшать сжатие, если только
отсроченные вставки не используется. Чтобы достигать лучшего сжатия, Вы
можете использовать <code>OPTIMIZE TABLE</code> или
<code>REPAIR TABLE</code>. Число строк в таблицах <code>ARCHIVE</code>,
сообщенное <code>SHOW TABLE STATUS</code>, всегда точно.</p>

<p><span class="bold"><strong>Дополнительные ресурсы:</strong></span></p>
<ul type="disc"><li><p>Форум, специализированный на типе
<code>ARCHIVE</code>, доступен на
<a href="../../../forums.mysql.com/list.php@112" target="_top">
http://forums.mysql.com/list.php?112</a>.</p></li></ul>

<h2><a name="csv-storage-engine"></a>2.8. Тип памяти <code>CSV</code></h2>
<p>Тип памяти <code>CSV</code> хранит данные в текстовых файлах, использующих
разделяемый запятыми формат значений.</p>

<p>Чтобы включить этот тип памяти, используйте опцию
<code>--with-csv-storage-engine</code> в скрипте
<span><strong>configure</strong></span> при сборке MySQL.</p>

<p>Тип памяти <code>CSV</code> включен в двоичные дистрибутивы MySQL-Max.
Чтобы его включить, если Вы формируете MySQL из исходного текста,
вызовите <span><strong>configure</strong></span> с опцией
<code>--with-csv-storage-engine</code>. Чтобы исследовать исходник типа
памяти <code>CSV</code>, смотрите каталог <code>storage/csv</code>
исходных текстов MySQL.</p>

<p>Когда Вы создаете таблицу <code>CSV</code>, сервер создает файл формата
таблицы в каталоге баз данных. Имя файла начинается с имени таблицы и
имеет расширение <code>.frm</code>. Тип памяти также создает файл данных. Имя
его начинается с имени таблицы и имеет расширение <code>.CSV</code>. Файл
данных представляет собой простой текстовый файл. Когда Вы сохраняете данные
в таблицу, тип памяти сохраняет это в файл данных в разделяемом
запятыми формате значений.</p>

<pre>
mysql&gt; CREATE TABLE test(i INT, c CHAR(10)) ENGINE = CSV;
Query OK, 0 rows affected (0.12 sec)
mysql&gt; INSERT INTO test VALUES(1,'record one'),(2,'record two');
Query OK, 2 rows affected (0.00 sec)
Records: 2 Duplicates: 0 Warnings: 0

mysql&gt; SELECT * FROM test;
+---+------------+
| i | c          |
+---+------------+
| 1 | record one |
| 2 | record two |
+---+------------+
2 rows in set (0.00 sec)
</pre>

<p>Начиная с MySQL 5.1.9, при создании таблицы CSV также создается
соответствующий метафайл, который сохраняет состояние таблицы и число строк,
которые существуют в таблице. Имя этого файла такое же, как имя таблицы,
но с расширением <code>CSM</code>.</p>

<p>Если Вы исследуете файл <code>test.CSV</code> в каталоге баз данных
созданный, выполняя предшествующие инструкции, его содержимое должно
выглядеть следующим образом:</p>

<pre>
"1","record one"
"2","record two"
</pre>
<p>Этот формат может читаться и даже записываться прикладными программами
электронных таблицы типа Microsoft Excel или StarOffice Calc.</p>

<h3><a name="se-csv-repair"></a>
2.8.1. Восстановление и проверка таблицы CSV</h3>
<p><span class="bold"><strong>
Функциональные возможности, представленные в версии 5.1.9.
</strong></span></p>

<p>Тип памяти CSV поддерживает команды <code>CHECK</code> и
<code>REPAIR</code>, чтобы проверить и, если возможно, отремонтировать
поврежденную таблицу CSV.</p>

<p>При выполнении команды <code>CHECK</code> файл CSV будет проверен на
правильность, ища правильные разделители полей, экранированные поля
(соответствующие кавычками и/или их отсутствию), правильное число полей,
сравниваемых с определением таблицы и существование соответствующего
метафайла CSV. Первая недопустимая обнаруженная строка сообщит ошибку.
Проверка допустимой таблицы производит вывод, аналогично показанному ниже:
</p>

<pre>
mysql&gt; check table csvtest;
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | status   | OK       |
+--------------+-------+----------+----------+
1 row in set (0.00 sec)
</pre>

<p>Проверка на разрушенной таблице возвращает неисправность:</p>
<pre>
mysql&gt; check table csvtest;
+--------------+-------+----------+----------+
| Table        | Op    | Msg_type | Msg_text |
+--------------+-------+----------+----------+
| test.csvtest | check | error    | Corrupt  |
+--------------+-------+----------+----------+
1 row in set (0.01 sec)
</pre>

<p>Если сбой проверки произошел, таблица отмечена как разрушенная. Если
только таблица была отмечена как разрушенная, она будет автоматически
восстановлена, когда Вы затем выполняете инструкцию <code>CHECK</code> или
<code>SELECT</code>. Соответствующее разрушенное состояние и новое состояние
будут отображаться при выполнении <code>CHECK</code>:</p>

<pre>
mysql&gt; check table csvtest;
+--------------+-------+----------+----------------------------+
| Table        | Op    | Msg_type | Msg_text                   |
+--------------+-------+----------+----------------------------+
| test.csvtest | check | warning  | Table is marked as crashed |
| test.csvtest | check | status   | OK                         |
+--------------+-------+----------+----------------------------+
2 rows in set (0.08 sec)
</pre>

<p>Для ремонта таблицы Вы можете использовать <code>REPAIR</code>, это
скопирует так много допустимых строк из существующих CSV данных, сколько
возможно, а затем заменяет существующий CSV файл на восстановленные строки.
Любые строки вне разрушенных данных будут потеряны.</p>

<pre>
mysql&gt; repair table csvtest;
+--------------+--------+----------+----------+
| Table        | Op     | Msg_type | Msg_text |
+--------------+--------+----------+----------+
| test.csvtest | repair | status   | OK       |
+--------------+--------+----------+----------+
1 row in set (0.02 sec)
</pre>

<h3>Предупреждение</h3>
<p>Обратите внимание, что в течение ремонта только строки из CSV файла до
первой поврежденной строки скопированы к новой таблице. Все другие строки,
даже допустимые строки, до первой поврежденной строки удалены!</p>

<h3><a name="se-csv-limitations"></a>2.8.2. Ограничения CSV</h3>
<p><span class="bold"><strong>Важно</strong></span>: тип памяти
<code>CSV</code> не поддерживает индексацию.</p>

<p>Выделение разделов не обеспечивается для таблиц, использующих
<code>CSV</code>. Начиная с MySQL 5.1.12, больше не возможно создать разбитую
на разделы таблицу <code>CSV</code>
(<a href="../../../bugs.mysql.com/19307" target="_top">Глюк #19307</a>).</p>

<h2><a name="blackhole-storage-engine"></a>2.9.
Тип памяти <code>BLACKHOLE</code></h2>
<p>Тип памяти <code>BLACKHOLE</code> действует как черная дыра. Это принимает
данные, но не сохраняет их. Поиски всегда возвращают пустой результат:</p>

<pre>
mysql&gt; CREATE TABLE test(i INT, c CHAR(10)) ENGINE = BLACKHOLE;
Query OK, 0 rows affected (0.03 sec)
mysql&gt; INSERT INTO test VALUES(1,'record one'), (2,'record two');
Query OK, 2 rows affected (0.00 sec)
Records: 2 Duplicates: 0 Warnings: 0
mysql&gt; SELECT * FROM test;
Empty set (0.00 sec)
</pre>

<p>Тип памяти <code>BLACKHOLE</code> включен в двоичные дистрибутивы
MySQL-Max. Чтобы его включить, если Вы формируете MySQL из исходного текста,
вызовите <span><strong>configure</strong></span> с опцией
<code>--with-blackhole-storage-engine</code>. Чтобы исследовать исходник типа
памяти <code>BLACKHOLE</code>, смотрите каталог <code>sql</code>
исходных текстов MySQL.</p>

<p>Когда Вы создаете таблицу <code>BLACKHOLE</code>, сервер создает файл
формата таблицы в каталоге баз данных. Имя файла начинается с имени таблицы и
имеет расширение <code>.frm</code>. Не имеется никаких других
файлов, связанных с таблицей.</p>

<p>Тип памяти <code>BLACKHOLE</code> поддерживает все виды индексов. То есть,
Вы можете включать индексные объявления в определении таблицы. Вы можете
проверять наличие поддержки типа памяти
<code>BLACKHOLE</code> этой инструкцией:</p>
<pre>
mysql&gt; SHOW VARIABLES LIKE 'have_blackhole_engine';
</pre>

<p>Вставки в таблицу не сохраняют <code>BLACKHOLE</code> никакие данные, но
если двоичный файл регистрации допускается, инструкции SQL прилежно в нем
регистрируются (и скопируются на подчиненные серверы). Это может быть полезно
как повторитель или фильтрующий механизм. Например, предположите, что Ваша
прикладная программа требует подчиненно-побочных правил фильтрации, но
передача всех двоичных данных файла регистрации подчиненным порождает
чрезмерно большой трафик. В таком случае возможно поставить на главном
сервере <span class="quote">макет</span> подчиненного процесса, чей заданный
по умолчанию тип памяти <code>BLACKHOLE</code>, описанный следующим образом:
</p>

<p>Главный пишет в свой двоичный файл регистрации.
<span class="quote">Макет</span> <span><strong>mysqld</strong></span>
обрабатывает действия как подчиненный, применяя желательную комбинацию правил
<code>replicate-do-*</code> и <code>replicate-ignore-*</code> после чего
пишет новый, собственный, отфильтрованный двоичный файл регистрации. Этот
фильтрованный файл регистрации передается подчиненному.</p>

<p>Фиктивный процесс фактически не сохраняет никакие данные, так что имеется
немного непроизводительных затрат обработки, которые возникают, выполняя
дополнительный процесс <span><strong>mysqld</strong></span> на главном
сервере репликации. Этот тип установки может быть повторен с дополнительными
подчиненными серверами репликации.</p>

<p>Другие возможные использования типа памяти <code>BLACKHOLE</code>:</p>
<ul type="disc"><li><p>Проверка синтаксиса файла дампа.</p></li>
<li><p>Измерение непроизводительных затрат из двоичной регистрации, сравнивая
эффективность, используя <code>BLACKHOLE</code> с и без двоичной регистрации.
</p></li>

<li><p><code>BLACKHOLE</code> по существу тип памяти пустой команды, так что
это могло бы использоваться для нахождения критических параметров
эффективности, не связанных с типом памяти непосредственно.</p></li></ul>

<p>Начиная с MySQL 5.1.4, тип памяти <code>BLACKHOLE</code> знает транзакции
в том смысле, что совершенные транзакции записаны в двоичный файл
регистрации, а отмененные транзакции уже нет.</p>

<h2><a name="faqs-storage-engines"></a>2.10 MySQL 5 FAQ по
таблицам и типам памяти</h2>
<p><span class="bold"><strong>Questions and Answers</strong></span></p>
<p><a name="qandaitem-28-2-2"></a><span class="bold"><strong>2.10.1:
</strong></span><span class="bold"><strong>Имеются ли любые новые
типы памяти в MySQL 5.1?</strong></span></p>
<p>MySQL 5.1 представляет alpha-версию нового типа памяти Falcon.</p>

<p>Также имелись значительные усовершенствования существующих типов памяти, в
частности для <code>NDB</code>, который формирует
основание MySQL Cluster.</p>

<p><a name="qandaitem-28-2-3"></a><span class="bold"><strong>2.10.2:
</strong></span><span class="bold"><strong>А какие-то типы памяти были
удалены в MySQL 5.1?</strong></span></p>

<p>Да. MySQL 5.1 больше не поддерживает <code>BDB</code>. Любые существующие
таблицы <code>BDB</code> должны быть преобразованы в другой тип перед
обновлением до MySQL 5.1.</p>

<p><a name="qandaitem-28-2-4"></a><span class="bold"><strong>2.10.3:
</strong></span><span class="bold"><strong>Каковы уникальные выгоды
типа памяти <code>ARCHIVE</code>?</strong></span></p>

<p>Тип памяти <code>ARCHIVE</code> идеально подходит для сохранения больших
количеств данных без индексов, это имеет очень маленький размер и выполняет
поиск данных с помощью сканирования таблицы.</p>

<p><a name="qandaitem-28-2-5"></a><span class="bold"><strong>2.10.4:
</strong></span><span class="bold"><strong>Какие новые свойства в MySQL 5.1
относятся ко всем типам памяти?</strong></span></p>

<p>Общие новые свойства типа views, сохраненных процедур, триггеров,
<code>INFORMATION_SCHEMA</code>, точной математики (тип столбца
<code>DECIMAL</code>), а также тип столбца <code>BIT</code> относятся ко всем
типам памяти. Имеются также добавления и изменения для специфических типов.
</p>

<p><a name="qandaitem-28-8-2"></a><span class="bold"><strong>2.10.5:
</strong></span><span class="bold"><strong>Какие изменения в поддерживаемые
типы таблиц внесены в MySQL 5.1?</strong></span></p>

<p>Поддержка изменилась следующим образом:</p>
<ul type="disc"><li><p>Поддержка для таблиц <code>ISAM</code> была удалена в
MySQL 5.0, и Вы должны теперь использовать таблицы <code>MyISAM</code> вместо
<code>ISAM</code>. Чтобы преобразовать таблицу <em><code>tblname</code></em>
из типа <code>ISAM</code> в <code>MyISAM</code>, просто выдайте
инструкцию типа этой:</p>
<pre>
ALTER TABLE <em><code>tblname</code></em> ENGINE=MYISAM;
</pre></li>

<li><p>Внутренний <code>RAID</code> для таблиц <code>MyISAM</code> был также
удален в MySQL 5.0. Это прежде использовалось, чтобы позволить большие
таблицы в файловых системах, которые не поддерживали размеры файла больше,
чем 2 GB. Все современные файловые системы учитывают большие таблицы, кроме
того, теперь имеются другие решения типа таблиц <code>MERGE</code> и views.
</p></li>

<li><p>Тип столбца <code>VARCHAR</code> теперь сохраняет конечные пробелы во
всех типах памяти.</p></li>
<li><p>Таблицы <code>MEMORY</code> (прежде известные как таблицы
<code>HEAP</code>) также могут содержать столбцы <code>VARCHAR</code>.
</p></li></ul>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</html>
