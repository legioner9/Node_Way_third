<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=koi8-r">
   <META NAME="GENERATOR" CONTENT="Dos Navigator 1.51.04/DOS.">
   <META NAME="Author" CONTENT="Alexey V. Pautov">
   <title>Глава 6. Триггеры</title>
</head>

<body bgcolor="white" text="black" link="#0000FF" vlink="#840084"
      alink="#0000FF">

<script type="text/javascript">
nN = navigator.appName;
function fsearch(str)
{
  if (document.fform.myradio[0].checked) {
     open('../../../yandex.ru/sitesearch@text=' + str + '&site=' +
          document.location.hostname);
  } else {open('../../../yandex.ru/sitesearch@text=' + str);}
}

function MouseUpHandler(e)
{
  if (nN == 'Netscape' || nN == 'Opera') {
     if (document.getSelection()) {
        str = document.getSelection();
        newstr = str.replace(/\n+/g, ' ');
        str = newstr.replace(/\ +/g, ' ');
        if (str.length > 100) {
           var i;
           i = 0;
           str = str.slice(0, 100);
           i = str.lastIndexOf(' ');
           if (i > 0){str = str.slice(0, i);}
        }
        document.fform.strf.value = str;
     }
  } else if(nN == 'Microsoft Internet Explorer') {
    if (document.selection.createRange()) {
       var range = document.selection.createRange();
       var str = range.text;
    }
    if (str) {
       str = str.replace(/\ +/g, " ");
       document.fform.strf.value = str;
    }
  }
  return true;
}
if (window.Event) {document.captureEvents(Event.MOUSEUP);}
document.onmouseup = MouseUpHandler;
</script>

<center><table><tr><td><a href="../../default.htm">
<IMG SRC="../../img/b_book.gif" ALT="RussianLDP" HEIGHT=48 WIDTH=55
ALIGN=ABSCENTER></a></td>

<td><!--Rating@Mail.ru COUNTEr-->
<a target=_top href="../../../top.mail.ru/jump@from=1364238">
<img src="../../../d1.cd.b4.a1.top.list.ru/counter@id=1364238;t=230"
border=0 height=31 width=88 alt="Рейтинг@Mail.ru"/></a>
</td><!--/COUNTER-->

<td><!-- begin of Top100 code -->
<script id="top100Counter" type="text/javascript"
src="../../../cnt.rambler.ru/top100.jcn@1448139"></script>
<noscript><a href="../../../top100.rambler.ru/top100/default.htm">
<img src="../../../cnt.rambler.ru/top100.cnt@1448139" alt="Rambler's Top100"
width="81" height="63" border="0" /></a></noscript>
<!-- end of Top100 code --></td>

<td><!-- HotLog -->
<script type="text/javascript" language="javascript">
hotlog_js="1.0";
hotlog_r=""+Math.random()+"&s=525943&im=127&r="+escape(document.referrer)+
"&pg="+escape(window.location.href);
document.cookie="hotlog=1; path=/"; hotlog_r+="&c="+(document.cookie?"Y":"N");
</script>
<script type="text/javascript" language="javascript1.1">
hotlog_js="1.1";hotlog_r+="&j="+(navigator.javaEnabled()?"Y":"N")
</script>

<script type="text/javascript" language="javascript1.2">
hotlog_js="1.2";
hotlog_r+="&wh="+screen.width+'x'+screen.height+"&px="+
(((navigator.appName.substring(0,3)=="Mic"))?
screen.colorDepth:screen.pixelDepth)</script>

<script type="text/javascript" language="javascript1.3">
hotlog_js="1.3"</script>
<script type="text/javascript" language="javascript">
hotlog_r+="&js="+hotlog_js;
document.write("<a href='../../../click.hotlog.ru/@525943' target='_top'>
<img "+" src='http://hit27.hotlog.ru/cgi-bin/hotlog/count?"+
hotlog_r+"&' border=0 width=88 height=31 alt=HotLog><\/a>")</script>

<noscript>
<a href="../../../click.hotlog.ru/@525943" target="_top">
<img src="../../../hit27.hotlog.ru/cgi-bin/hotlog/count@s=525943&im=127"
border="0" width="88" height="31" alt="HotLog"></a></noscript></td>
<!-- /HotLog -->

<td><!--LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='../../../www.liveinternet.ru/click' "+
"target=_blank><img src='http://counter.yadro.ru/hit?t52.15;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+"' alt='' title='LiveInternet: показано число просмотров и"+
" посетителей за 24 часа' "+"border=0 width=88 height=31><\/a>")//-->
</script></td></tr>
<!--/LiveInternet-->

<tr><td><FONT SIZE=-1><b>WebMoney:&nbsp;</b><br>
WMZ Z294115950220&nbsp;<br>
WMR R409981405661&nbsp;<br>
WME E134003968233&nbsp;</FONT></td>

<td><FONT SIZE=-1><b>Visa&nbsp;</b><br>
4274 3200 2453 6495&nbsp;</FONT></td>
</tr></table></center>
<P><index><table><tr><td>


<h2><a name="triggers"></a>Глава 6. Триггеры</h2>
<p>Поддержка для триггеров включена, начиная с MySQL 5.0.2. Триггер
представляет собой именованный объект базы данных, который связан с таблицей,
и он будет активизирован, когда специфическое событие происходит для таблицы.
Например, следующие инструкции создают таблицу и вызывают триггер
<code>INSERT</code>. Он суммирует значения, вставленные в один
из столбцов таблицы:</p>

<pre>
mysql&gt; CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));
Query OK, 0 rows affected (0.03 sec)

mysql&gt; <strong><code>CREATE TRIGGER ins_sum BEFORE INSERT ON account</code></strong>
    -&gt; <strong><code>FOR EACH ROW SET @sum = @sum + NEW.amount;</code></strong>
Query OK, 0 rows affected (0.06 sec)
</pre>

<p>Эта глава описывает синтаксис для создания и удаления триггеров,
показывает некоторые примеры того, как использовать их. Обсуждение
ограничений на использование дано в разделе
"<a href="restrict.htm#routine-restrictions">
11.1. Ограничения на сохраненные подпрограммы и триггеры</a>".</p>

<h2><a name="create-trigger"></a>6.1. Синтаксис <code>CREATE TRIGGER</code>
</h2>
<pre>
CREATE
  [DEFINER = {<em><code>user</code></em> | CURRENT_USER}]
  TRIGGER <em><code>trigger_name</code></em> <em><code>trigger_time</code></em> <em><code>trigger_event</code></em>
  ON <em><code>tbl_name</code></em> FOR EACH ROW <em><code>trigger_stmt</code></em>
</pre>

<p>Эта инструкция создает новый триггер. <code>CREATE TRIGGER</code> была
добавлена в MySQL 5.0.2. В настоящее время использование
требует привилегии <code>SUPER</code>.</p>

<p>Триггер становится связанным с таблицей с именем
<em><code>tbl_name</code></em>, которое должно обратиться к постоянной
таблице. Вы не можете связывать триггер с view или таблицей
<code>TEMPORARY</code>.</p>

<p>Когда триггер активизирован, предложение <code>DEFINER</code> определяет
привилегии, которые применяются, как описано ниже в этом разделе.</p>

<p><em><code>trigger_time</code></em> задает время действия. Это может быть
<code>BEFORE</code> или <code>AFTER</code>, чтобы задать, что триггер
активизируется прежде или после инструкции, которая активизировала это.</p>

<p><em><code>trigger_event</code></em> указывает вид инструкции, которая
активизирует триггер. Здесь <em><code>trigger_event</code></em> может быть
одним из следующего:</p>

<ul type="disc"><li><p><code>INSERT</code>: всякий раз, когда новая строка
вставлена в таблицу. Например, через команды <code>INSERT</code>, <code>LOAD
DATA</code> или <code>REPLACE</code>.</p></li>

<li><p><code>UPDATE</code>: всякий раз, когда строка изменяется. Например,
через инструкцию <code>UPDATE</code>.</p></li>
<li><p><code>DELETE</code>: всякий раз, когда строка удалена из таблицы.
Например, через инструкции <code>DELETE</code> и <code>REPLACE</code>.
Однако, инструкции <code>DROP TABLE</code> и <code>TRUNCATE</code>
относительно таблицы <span><em>НЕ</em></span> активизируют триггер, потому
что они не используют <code>DELETE</code>!</p></li></ul>

<p>Важно понять, что <em><code>trigger_event</code></em> не представляет
литеральный тип инструкции SQL, которая активизирует триггер, поскольку это
представляет тип операции таблицы. Например, триггер <code>INSERT</code>
активизирован не только инструкцией <code>INSERT</code>, но и <code>LOAD
DATA</code>, потому что обе инструкции вставляют строки в таблицу.</p>

<p>Не может быть двух триггеров для данной таблицы, которые имеют те же самые
время действия и событие. Например, Вы не можете иметь два триггера
<code>BEFORE UPDATE</code> для таблицы. Но Вы можете иметь <code>BEFORE
UPDATE</code> и <code>BEFORE INSERT</code> или <code>BEFORE
UPDATE</code> и <code>AFTER UPDATE</code>.</p>

<p><em><code>trigger_stmt</code></em> задает инструкцию, которая будет
выполнена, когда триггер активизируется. Если Вы хотите выполнять много
инструкций, используйте операторную конструкцию <code>BEGIN ... END</code>.
Это также дает возможность Вам использовать те же самые инструкции, которые
являются допустимыми внутри сохраненных подпрограмм.</p>

<p><span class="bold"><strong>Замечание</strong></span>: в настоящее время
триггеры не активизированы каскадными действиями внешнего ключа. Это
ограничение будет сниматься как можно скорее.</p>

<p><span class="bold"><strong>Обратите внимание</strong></span>: до MySQL
5.0.10 триггер не может содержать прямые ссылки к именам таблиц. С MySQL
5.0.10, Вы можете записывать имена, как показано в этом примере:</p>

<pre>
CREATE TABLE test1(a1 INT);
CREATE TABLE test2(a2 INT);
CREATE TABLE test3(a3 INT NOT NULL AUTO_INCREMENT PRIMARY KEY);
CREATE TABLE test4(a4 INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
                   b4 INT DEFAULT 0);
DELIMITER |
CREATE TRIGGER testref BEFORE INSERT ON test1
  FOR EACH ROW BEGIN
    INSERT INTO test2 SET a2 = NEW.a1;
    DELETE FROM test3 WHERE a3 = NEW.a1;
    UPDATE test4 SET b4 = b4 + 1 WHERE a4 = NEW.a1;
  END;
|
DELIMITER ;
INSERT INTO test3 (a3) VALUES
  (NULL), (NULL), (NULL), (NULL), (NULL),
  (NULL), (NULL), (NULL), (NULL), (NULL);
INSERT INTO test4 (a4) VALUES
  (0), (0), (0), (0), (0), (0), (0), (0), (0), (0);
</pre>

<p>Предположим, что Вы вставляете следующие значения в таблицу
<code>test1</code> как показано здесь:</p>
<pre>
mysql&gt; <strong><code>INSERT INTO test1 VALUES </code></strong>
    -&gt; <strong><code>(1), (3), (1), (7), (1), (8), (4), (4);</code></strong>
Query OK, 8 rows affected (0.01 sec)
Records: 8  Duplicates: 0  Warnings: 0
</pre>

<p>В результате данные в четырех таблицах будут следующие:</p>
<pre>
mysql&gt; <strong><code>SELECT * FROM test1;</code></strong>
+------+
| a1   |
+------+
|    1 |
|    3 |
|    1 |
|    7 |
|    1 |
|    8 |
|    4 |
|    4 |
+------+
8 rows in set (0.00 sec)

mysql&gt; <strong><code>SELECT * FROM test2;</code></strong>
+------+
| a2   |
+------+
|    1 |
|    3 |
|    1 |
|    7 |
|    1 |
|    8 |
|    4 |
|    4 |
+------+
8 rows in set (0.00 sec)

mysql&gt; <strong><code>SELECT * FROM test3;</code></strong>
+----+
| a3 |
+----+
|  2 |
|  5 |
|  6 |
|  9 |
| 10 |
+----+
5 rows in set (0.00 sec)

mysql&gt; <strong><code>SELECT * FROM test4;</code></strong>
+----+------+
| a4 | b4   |
+----+------+
|  1 |    3 |
|  2 |    0 |
|  3 |    1 |
|  4 |    2 |
|  5 |    0 |
|  6 |    0 |
|  7 |    1 |
|  8 |    1 |
|  9 |    0 |
| 10 |    0 |
+----+------+
10 rows in set (0.00 sec)
</pre>

<p>Вы можете обратиться к столбцам в подчиненной таблице (таблице, связанной
с вызывающей), используя псевдонимы <code>OLD</code> и <code>NEW</code>.
<code>OLD.<em><code>col_name</code></em></code> обращается к столбцу
существующей строки прежде, чем она модифицируется или удалится.
<code>NEW.<em><code>col_name</code></em></code> обращается к столбцу новой
строки, которая будет вставлена, или же к существующей строке после того,
как она модифицируется.</p>

<p>Предложение <code>DEFINER</code> определяет логин MySQL, который нужно
использовать при проверке привилегий доступа в вызове триггера. Это было
добавлено в MySQL 5.0.17. Если дано значение <em><code>user</code></em>,
это должно быть логином MySQL в формате
<code>'<em><code>user_name</code></em>'@'<em><code>host_name</code></em>'</code>
(как в команде <code>GRANT</code>). Требуются переменные
<em><code>user_name</code></em> и <em><code>host_name</code></em>.
<code>CURRENT_USER</code> также может быть дан как
<code>CURRENT_USER()</code>. Заданное по умолчанию значение
<code>DEFINER</code>: пользователь, который выполняет инструкцию
<code>CREATE TRIGGER</code>. Это также, как
<code>DEFINER = CURRENT_USER</code>.</p>

<p>Если Вы определяете предложение <code>DEFINER</code>, Вы не можете
устанавливать значение к любому логину, кроме Вашего собственного, если Вы не
имеете привилегию <code>SUPER</code>. Эти правила определяют допустимые
значения пользователя в <code>DEFINER</code>:</p>

<ul type="disc"><li><p>Если Вы не имеете привилегии <code>SUPER</code>,
единственное допустимое значение <em><code>user</code></em>: Ваш собственный
логин, определенный буквально или используя <code>CURRENT_USER</code>. Вы не
можете устанавливать <code>DEFINER</code> к некоторому другому логину.</p>
</li>

<li><p>Если Вы имеете привилегию <code>SUPER</code>, Вы можете определять
любое синтаксически допустимое имя пользователя. Если такого логина
фактически не существует, будет сгенерировано предупреждение.</p>

<p>Хотя возможно создать триггер с несуществующим значением
<code>DEFINER</code>, делать этого не следует, поскольку триггер не будет
активизирован, пока <code>DEFINER</code> фактически не существует. Иначе,
поведение относительно проверки привилегии неопределенно.</p></li></ul>

<p>Обратите внимание: так как MySQL в настоящее время требует, чтобы была
привилегия <code>SUPER</code> для использования <code>CREATE TRIGGER</code>,
только второе из предшествующих правил применяется. MySQL 5.1.6 вводит
право <code>TRIGGER</code> и требует, чтобы эта привилегия наличествовала для
создания триггера, так что с этой версии оба правила работают, а
<code>SUPER</code> требуется только для определения значения
<code>DEFINER</code> другого, чем Ваш собственный логин.</p>

<p>Начиная с MySQL 5.0.17, MySQL проверяет привилегии триггера подобно этому:
</p>
<ul type="disc"><li><p>В момент вызова <code>CREATE TRIGGER</code>
пользователь, который выдает инструкцию, должен
иметь привилегию <code>SUPER</code>.</p></li>

<li><p>При срабатывании триггера привилегии проверены на соответствие
<code>DEFINER</code>. Пользователь должен иметь эти привилегии:</p>
<ul type="circle"><li><p><code>SUPER</code>.</p></li>

<li><p><code>SELECT</code> для подчиненной таблицы, если ссылки к столбцам
таблицы происходят через <code>OLD.<em><code>col_name</code></em></code> или
or <code>NEW.<em><code>col_name</code></em></code> в определении триггера.
</p></li>

<li><p><code>UPDATE</code> для подчиненной таблицы, если столбцы таблицы
являются адресатами <code>SET NEW.<em><code>col_name</code></em> =
<em><code>value</code></em></code>, назначенными в определении триггера.
</p></li>
<li><p>Любые другие привилегии обычно требуются для
инструкций, выполненных триггером.</p></li></ul></li></ul>

<p>До MySQL 5.0.17, MySQL проверяет привилегии подобно этому:</p>
<ul type="disc"><li><p> При вызове <code>CREATE TRIGGER</code> пользователь,
который выдает инструкцию, должен иметь привилегию <code>SUPER</code>.
</p></li>

<li><p>В момент активации триггера привилегии проверены для пользователя, чьи
действия заставили триггер сработать. Этот пользователь должен иметь любые
привилегии, которые требуются для инструкций, выполняемых триггером.
</p></li></ul>

<p>Обратите внимание, что введение предложения <code>DEFINER</code> меняет
значение <code>CURRENT_USER()</code> в определении триггера: функция
<code>CURRENT_USER()</code> работает со значением <code>DEFINER</code> в
MySQL 5.0.17 (и выше) или с тем пользователем, чьи действия заставили
выполниться триггер (до MySQL 5.0.17).</p>

<h2><a name="drop-trigger"></a>6.2. Синтаксис <code>DROP TRIGGER</code></h2>
<pre>
DROP TRIGGER [<em><code>schema_name</code></em>.]<em><code>trigger_name</code></em>
</pre>

<p>Это уничтожает триггер. Имя базы данных опционально. Если оно не задано,
триггер удаляется из заданной по умолчанию базы данных, Вызов <code>DROP
TRIGGER</code> был добавлен в MySQL 5.0.2.
Использование требует привилегии <code>SUPER</code>.</p>

<p><span class="bold"><strong>Обратите внимание:</strong></span> До MySQL
5.0.10, имя таблицы требовалось вместо имени схемы
(<code><em><code>table_name</code></em>.<em><code>trigger_name</code></em>
</code>). При обновлении с MySQL 5.0 до MySQL 5.0.10 или выше, Вы должны
удалить все триггеры перед обновлением и вновь создать их впоследствии, иначе
вызов <code>DROP TRIGGER</code> не работает после обновления.</p>

<p>Кроме того, триггеры, созданные в MySQL 5.0.16 или выше, не могут быть
удалены в MySQL 5.0.15 или ниже. Если Вы желаете выполнить такой возврат, Вы
также должны в этом случае удалить все триггеры и заново их пересоздать
после смены версий.</p>

<h2><a name="using-triggers"></a>6.3. Использование триггеров</h2>
<p>Поддержка триггеров включена, начиная с MySQL 5.0.2. Этот раздел
обсуждает, как использовать триггеры и некоторые их ограничений.</p>

<p>Триггер является именованным объектом базы данных, который связан с
таблицей, и активизируется, когда специфическое событие происходит для этой
таблицы. Это очень здорово, когда Вы должны выполнить проверки значений,
которые будут вставлены в таблицу или выполнять вычисления на
значениях, включаемых в модификации.</p>

<p>Триггер связан с таблицей и определен, чтобы активизироваться, когда
для таблицы выполняется инструкция <code>INSERT</code>, <code>DELETE</code>
или <code>UPDATE</code>. Триггер может быть установлен, чтобы
активизироваться прежде или после вызова инструкции. Например, Вы можете
иметь триггер, срабатывающий перед удалением каждой строки из таблицы, или
после каждой модификации уже существующей строки в таблице.</p>

<p>Имеется простой пример, который связывает триггер с таблицей для
инструкций <code>INSERT</code>. Это действует как сумматор, чтобы суммировать
значения, вставленные в один из столбцов таблицы.</p>

<p>Следующие инструкции создают таблицу и триггер для нее:</p>
<pre>
mysql&gt; CREATE TABLE account (acct_num INT, amount DECIMAL(10,2));
mysql&gt; CREATE TRIGGER ins_sum BEFORE INSERT ON account
    -&gt;        FOR EACH ROW SET @sum = @sum + NEW.amount;
</pre>

<p>Команда <code>CREATE TRIGGER</code> создает триггер <code>ins_sum</code>,
который связан с таблицей <code>account</code>. Это также включает
предложения, которые определяют время активации, событие вызова, и что делать
с активированным триггером дальше:</p>

<ul type="disc"><li><p>Ключевое слово <code>BEFORE</code> указывает время
срабатывания. В этом случае триггер должен активизировать перед каждой
строкой, вставленной в таблицу. Другое допустимое ключевое
слово здесь: <code>AFTER</code>.</p></li>

<li><p>Ключевое слово <code>INSERT</code> указывает событие, которое
активизирует триггер. В этом примере триггер срабатывает от инструкции
<code>INSERT</code>. Вы можете также создавать триггеры для
инструкций <code>DELETE</code> и <code>UPDATE</code>.</p></li>

<li><p>Инструкция <code>FOR EACH ROW</code> определяет, что триггер должен
сработать один раз для каждой строки, на которую воздействует инструкция в
примере. Собственно триггер представляет собой в данном случае простой
<code>SET</code>, который накапливает значения, вставленные в столбец
<code>amount</code>. Инструкция обращается к столбцу как
<code>NEW.amount</code>, что означает "значение столбца <code>amount</code>,
которое будет вставлено в новую строку".</p></li></ul>

<p>Чтобы использовать триггер, установите переменную сумматора в ноль,
выполните инструкцию <code>INSERT</code>, а затем посмотрите то, какое
значение переменная имеет позже:</p>

<pre>
mysql&gt; SET @sum = 0;
mysql&gt; INSERT INTO account VALUES(137,14.98),(141,1937.50),(97,-100.00);
mysql&gt; SELECT @sum AS 'Total amount inserted';
+-----------------------+
| Total amount inserted |
+-----------------------+
| 1852.48               |
+-----------------------+
</pre>

<p>В этом случае значение <code>@sum</code> после выполнения команды
<code>INSERT</code> равно <code>14.98 + 1937.50 - 100</code> или
<code>1852.48</code>.</p>

<p>Для уничтожения триггера выполните <code>DROP TRIGGER</code>. Вы должны
определить имя схемы, если триггер не в заданной по умолчанию схеме:</p>
<pre>
mysql&gt; <strong><code>DROP TRIGGER test.ins_sum;</code></strong>
</pre>

<p>Имена триггеров существуют в пространстве имен схемы. Это означает, что
все триггеры должны иметь уникальные имена внутри схемы. Триггеры в различных
схемах могут иметь то же самое имя.</p>

<p>В дополнение к требованию, чтобы имя триггера было уникальным для схемы,
имеются другие ограничения на типы триггеров, которые можно создавать. Вы не
можете иметь два триггера для таблицы, которые имеют то же самое событие и
время активации. Например, Вы не можете определять два триггера типа
<code>BEFORE INSERT</code> или <code>AFTER UPDATE</code> для таблицы. Это
редко должно быть значительным ограничением, поскольку запросто можно
определить триггер, выполняющий много инструкций с помощью конструкции
<code>BEGIN ... END</code> после <code>FOR EACH ROW</code>.</p>

<p>Ключевые слова <code>OLD</code> и <code>NEW</code> дают возможность Вам
обратиться к столбцам в строках, на которые воздействует триггер
<code>OLD</code> и <code>NEW</code> не чувствительны к регистру. В триггере
<code>INSERT</code> может использоваться только <code>NEW.<em><code>col_name
</code></em></code>: не имеется никакой старой строки. В триггере
<code>DELETE</code> не ожидается никакой новой строки, так что может
использоваться исключительно <code>OLD.<em><code>col_name</code></em></code>.
В триггере <code>UPDATE</code> Вы можете использовать
<code>OLD.<em><code>col_name</code></em></code>, чтобы обратиться к столбцам
строки прежде, чем они изменятся, и <code>NEW.<em><code>col_name</code></em>
</code>, чтобы обратиться к ним уже после внесения изменений.</p>

<p>Столбец, именованный <code>OLD</code> только для чтения. Вы можете
обратиться к этому столбцу (если Вы имеете привилегию <code>SELECT</code>, но
не изменяете его. Столбец, именованный <code>NEW</code> может упоминаться,
если Вы имеете привилегию <code>SELECT</code> для него. В триггере
<code>BEFORE</code> Вы можете также изменять значение с <code>SET
NEW.<em><code>col_name</code></em> =
<em><code>value</code></em></code>, если Вы имеете привилегию
<code>UPDATE</code> для этого. Это означает, что Вы можете использовать
триггер, чтобы изменить значения, которые будут вставлены в новую строку, или
использовать это, чтобы модифицировать строку.</p>

<p>В триггере <code>BEFORE</code> значение <code>NEW</code> для столбца
<code>AUTO_INCREMENT</code>: 0, а не автоматически сгенерированный порядковый
номер, который будет сгенерирован, когда новая запись фактически вставлена.
</p>

<p><code>OLD</code> и <code>NEW</code> представляют собой
MySQL-расширения триггеров.</p>
<p>Используя конструкцию <code>BEGIN ... END</code>, Вы можете определять
триггер, который выполняет много инструкций. Внутри блока <code>BEGIN</code>
Вы также можете использовать другой синтаксис, который позволяется внутри
сохраненных подпрограмм, типа условных выражений и циклов. Однако, точно как
для сохраненных подпрограмм, если Вы используете программу
<span><strong>mysql</strong></span>, чтобы определить триггер, необходимо
переопределить операторный разделитель <span><strong>mysql</strong></span>
так, чтобы Вы могли использовать <code>;</code> как операторный разделитель
внутри описания триггера. Следующий пример иллюстрирует эти моменты. Это
определяет триггер <code>UPDATE</code>, который проверяет новое значение,
которое нужно использовать для модифицирования каждой строки, и изменяет
значение, чтобы оставаться внутри диапазона от 0 до 100. Это должно быть
триггером типа <code>BEFORE</code>, потому что значение должно быть проверено
прежде, чем оно используется, чтобы модифицировать строку:</p>

<pre>
mysql&gt; delimiter //
mysql&gt; CREATE TRIGGER upd_check BEFORE UPDATE ON account
    -&gt;        FOR EACH ROW
    -&gt; BEGIN
    -&gt;   IF NEW.amount &lt; 0 THEN SET NEW.amount = 0;
    -&gt;      ELSEIF NEW.amount &gt; 100 THEN SET NEW.amount = 100;
    -&gt;   END IF;
    -&gt; END;//
mysql&gt; delimiter ;
</pre>

<p>Может быть проще определить сохраненную процедуру отдельно и затем вызвать
ее из триггера простой инструкцией <code>CALL</code>. Это также выгодно, если
Вы хотите вызывать ту же самую подпрограмму изнутри нескольких триггеров.</p>

<p>Имеются некоторые ограничения на то, что может появляться в инструкциях:
<ul type="disc"><li><p>Триггер не может использовать инструкцию
<code>CALL</code>, чтобы вызвать сохраненные процедуры, которые возвращают
данные пользователю или применяют динамический SQL. Процедурам позволяется
возвратить данные триггеру через параметры
<code>OUT</code> или <code>INOUT</code>.</p></li>

<li><p>Триггер не может использовать инструкции, которые явно или неявно
начинают или заканчивают транзакцию, типа <code>START
TRANSACTION</code>, <code>COMMIT</code> или <code>ROLLBACK</code>.</p></li>
<li><p>До MySQL 5.0.10 триггер не может содержать прямые
ссылки к именам таблиц.</p></li></ul>

<p>MySQL обрабатывает ошибки в выполнении триггеров следующим образом:</p>
<ul type="disc"><li><p>Если проблемы с триггером <code>BEFORE</code>,
операции на соответствующей строке просто не выполняются.</p></li>

<li><p>Триггер <code>BEFORE</code> активизирован попыткой вставить или
изменить строку, независимо от того, удачной ли была попытка.</p></li>
<li><p>Триггер <code>AFTER</code> выполнен только, если триггер
<code>BEFORE</code> и операция со строкой (вместе!) выполняются успешно.
</p></li>

<li><p>Ошибка в триггере <code>BEFORE</code> или <code>AFTER</code>
вызывает сбой всей инструкции, которая вызвала триггер.</p></li>
<li><p>Для транзакционных таблиц сбой инструкции должен вызвать обратную
перемотку всех изменений, выполняемых инструкцией. Сбой триггера также
вызывает обратную перемотку, поскольку является причиной сбоя команды в
целом. Для нетранзакционных таблиц такая обратная перемотка не может быть
выполнены, так что, хотя операторный сбой произошел, любые изменения,
выполненные до ошибки, остаются в силе.</p></li></ul>

<h2><a name="faqs-triggers"></a>6.4. MySQL 5 FAQ по триггерам</h2>
<p><a name="qandaitem-28-5-2"></a><span class="bold"><strong>6.4.1:
</strong></span><span class="bold"><strong>Имеется ли форум для
обсуждения триггеров в MySQL?</strong></span></p>
<p>Да. <a href="../../../forums.mysql.com/list.php@99" target="_top">
http://forums.mysql.com/list.php?99</a>.</p>

<p><a name="qandaitem-28-5-3"></a><span class="bold"><strong>6.4.2:
</strong></span><span class="bold"><strong>MySQL 5.1 имеет триггеры
операторного уровня или уровня строки?</strong></span></p>

<p>В MySQL 5.1 все триггеры <code>FOR EACH ROW</code>, то есть триггер
активизирован для каждой строки, которая вставлена, модифицируется или
удалена. MySQL 5.1 не поддерживает использование триггеров
<code>FOR EACH STATEMENT</code>.</p>

<p><a name="qandaitem-28-5-4"></a><span class="bold"><strong>6.4.3:
</strong></span><span class="bold"><strong>Имеется ли любое значение по
умолчанию для триггеров?</strong></span></p>

<p>Неявно. MySQL имеет специфическое специальное поведение для некоторых
столбцов <code>TIMESTAMP</code>, а также для столбцов, которые определены,
используя <code>AUTO_INCREMENT</code>.</p>

<p><a name="qandaitem-28-5-5"></a><span class="bold"><strong>6.4.4:
</strong></span><span class="bold"><strong>Как управлять триггерами в MySQL?
</strong></span></p>

<p>В MySQL 5.1 триггер может быть создан, используя инструкцию <code>CREATE
TRIGGER</code>, а удален инструкцией <code>DROP TRIGGER</code>.</p>
<p>Информация относительно триггеров может быть получена, запрашивая таблицу
<code>INFORMATION_SCHEMA.TRIGGERS</code>.</p>

<p><a name="qandaitem-28-5-6"></a><span class="bold"><strong>6.4.5:
</strong></span><span class="bold"><strong>Имеется ли способ просмотреть все
триггеры в конкретной базе данных?</strong></span></p>

<p>Да. Вы можете получать распечатку всех триггеров, определенных в базе
данных <code>dbname</code>, запросом к таблице
<code>INFORMATION_SCHEMA.TRIGGERS</code> примерно так:</p>

<pre>
SELECT TRIGGER_NAME, EVENT_MANIPULATION, EVENT_OBJECT_TABLE,
       ACTION_STATEMENT FROM INFORMATION_SCHEMA.TRIGGERS
       WHERE TRIGGER_SCHEMA='<em><code>dbname</code></em>';
</pre>
<p>Вы можете также использовать инструкцию <code>SHOW TRIGGERS</code>,
которая является специфической для MySQL.
</p>

<p><a name="qandaitem-28-5-7"></a><span class="bold"><strong>6.4.6:
</strong></span><span class="bold"><strong>Где хранятся триггеры?
</strong></span></p>
<p>Триггеры в настоящее время сохранены в
<code>.TRG</code>-файлах, один такой файл на таблицу.
Другими словами, триггер принадлежит таблице.</p>

<p>В будущем, мы планируем изменять это так, чтобы информация триггера
включалась в <code>.FRM</code>-файл, который определяет структуру таблицы.
Также планируется сделать триггеры уровня базы данных, чтобы привести их в
согласие с SQL-стандартом.</p>

<p><a name="qandaitem-28-5-8"></a><span class="bold"><strong>6.4.7:
</strong></span><span class="bold"><strong>
Может триггер вызывать сохраненную процедуру?</strong></span></p>
<p>Да.</p>

<p><a name="qandaitem-28-5-9"></a><span class="bold"><strong>6.4.8:
</strong></span><span class="bold"><strong>
Может триггер обращаться к таблицам?</strong></span></p>

<p>Триггер может обращаться к старым и новым данным в собственной таблице.
Через сохраненную процедуру, многотабличную модификацию или инструкцию
удаления триггер может также воздействовать и на другие таблицы.</p>

<p><a name="qandaitem-28-5-10"></a><span class="bold"><strong>6.4.9:
</strong></span><span class="bold"><strong>Может триггер вызывать
внешнюю прикладную программу через UDF?</strong></span></p>
<p>Нет, не в настоящее время.</p>

<p><a name="qandaitem-28-5-11"></a><span class="bold"><strong>6.4.10:
</strong></span><span class="bold"><strong>Может триггер модифицировать
таблицы на удаленном сервере?</strong></span></p>
<p>Да. Таблица на удаленном сервере могла бы модифицироваться, используя
тип памяти <code>FEDERATED</code>.</p>

</index></td><td width="20%">
<script type="text/javascript">
    var begun_auto_colors           = new Array();
    var begun_auto_fonts_size       = new Array();
    var begun_auto_pad              =       97517308;     // идентификатор площадки
    var begun_auto_limit            =              5;     // число объявлений выводимых на площадке
    var begun_auto_width            =            250;     // ширина блока объявлений
    begun_auto_colors[0]            =      '#0000CC';     // цвет ссылки объявлений
    begun_auto_colors[1]            =      '#000000';     // цвет текста объявления
    begun_auto_colors[2]            =      '#00CC00';     // цвет домена объявления
    begun_auto_colors[3]            =      '#FFFFFF';     // цвет фона блока объявлений
    begun_auto_fonts_size[0]        =          '9pt';     // р-мер шрифта ссылки объявлений
    begun_auto_fonts_size[1]        =          '9pt';     // р-мер шрифта текста объявления
    begun_auto_fonts_size[2]        =          '8pt';     // р-мер шрифта домена объявления
    begun_auto_fonts_size[3]        =          '8pt';     // р-мер шрифта заглушки
    var begun_block_type            =     'Vertical';     // тип блока
    var begun_rambler_type          =              1;     // цвет блока поиска Рамблер
    begun_koi8 = 1;
</script>
<script src="../../../autocontext.begun.ru/autocontext.js"
type="text/javascript"></script>
</td></tr></table>

<p><table><tr><td>
<form method="get" name="fform" onSubmit="fsearch(strf.value);
return false;">
<input type="hidden" name="clid" value="39177">
<b>Поиск</b><table><tr>
<td><input type="text" name="strf" size="15" style="font-size: 9pt" /></td></tr>
<tr><td><font size="-1"><input type="radio" name="myradio" value="0"
checked id="at_site"/>
<label for="at_site">На сайте</label><br/>
<input type="radio" name="myradio" value="1" id="at_ya">
<label for="at_ya">В Яндексе</label></font></td></tr>

<tr><td><input type="submit" value="Найти" style="font-size: 9pt"></td></tr>
</table></form></td>
<td>&nbsp;</td><td><script language="JavaScript"
src="../../../b190.takru.com/in.php@id=199275">
</script></td></tr></table></p>

<p><center><table><tr><td><font size="+1"><B>Найди своих коллег!</B></font><BR>
<script language="javascript"
src="../../../rldp.lovemesweet.ru/banner/db.js.php@rows=01&cols=05&bg=33FF33&sex=0&afrom=18&ato=99&headgif=&sf=1&nwnd=1&pmin=0&cid=RU&tid=0&smu=0&tcl1=000000&tcl2=FF0000">
</script></td>

<td><iframe src="../../../www.linuxcenter.ru/trans/list.phtml@ref=121965&n=5&price=yes"
frameborder="0" vspace="0" hspace="0" width="300" height="350" marginwidth="0"
marginheight="0" scrolling="no"></iframe></td></tr></table></center></p>

<script type="text/javascript" src="../../../bin-layer.ru/popup-686-1.js">
</script>


</BODY>
</html>
