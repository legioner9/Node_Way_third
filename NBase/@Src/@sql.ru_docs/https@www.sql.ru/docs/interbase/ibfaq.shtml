<HTML>
<HEAD>
<TITLE>Borland IB Database FAQ. [SQL.RU]</TITLE>
<META http-equiv="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Window-target" CONTENT="_top">
<META HTTP-EQUIV="Last-Modified" CONTENT="29-03-2001">
<META NAME="Description" CONTENT="Использование языка SQL, создание клиент-серверных систем. Конференция по MSSQL, Oracle, Interbase, MySQL. Полезные ссылки, документация, рекомендации по разработке информационных систем, сертификация, заказ книг и многое другое.">
<META NAME="Keywords" CONTENT="SQL, конференция, Database Server, Oracle, Interbase, MySQL, документация, статьи, примеры, книги, ссылки, сертификация, работа, СУБД">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../form.css">
</HEAD>
<BODY BGCOLOR="#FFFFFF" leftmargin="3" topmargin="3" marginheight="3" marginwidth="3">
<noindex>
<TABLE BGCOLOR="#000000" WIDTH=100% CELLPADDING=0 CELLSPACING=0 BORDER=0>
<TR><TD>

<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=1 BORDER=0>
<TR BGCOLOR="#6699CC"><TD><TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=100% BORDER=0 BGCOLOR="#6699CC">
<TR><TD COLSPAN=3><IMG SRC="../../images/blank.gif" height=3 width=1 alt=""></TD></TR>
<TR><TD VALIGN=TOP>&nbsp;<FONT FACE="Verdana,Arial" SIZE=5 COLOR=lightyellow>SQL.RU<BR><FONT SIZE=-5>&nbsp;client/server technologies</FONT></FONT></TD>
<TD WIDTH=468 HEIGHT=60 BGCOLOR=#6699CC ALIGN=RIGHT></TD>
<TD WIDTH=2><IMG SRC="../../images/blank.gif" height=1 width=2 alt=""></TD></TR>                                                      	
<TR HEIGHT=4><TD COLSPAN=3><IMG SRC="../../images/blank.gif" height=5 width=1 alt=""></TD></TR></TABLE>

</TD></TR>

<TR HEIGHT=15><TD bgcolor=#006699><FONT FACE="Verdana,Arial" SIZE=1 COLOR=WHITE><B><A CLASS="menu" 
HREF="../../default.htm">&nbsp;<FONT COLOR=white>Главная</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../docs">&nbsp;<FONT COLOR=yellow>Документация</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../articles">&nbsp;<FONT COLOR=white>Статьи</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../books">&nbsp;<FONT COLOR=white>Книги</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../forum/actualforum.aspx">&nbsp;<FONT COLOR=white>Форум</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../blogs">&nbsp;<FONT COLOR=white>Блоги</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../poll">&nbsp;<FONT COLOR=white>Опросы</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../forum/actualtopics.aspx@bid=11">&nbsp;<FONT COLOR=white>Гостевая</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../subscribe">&nbsp;<FONT COLOR=white>Рассылка</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../job">&nbsp;<FONT COLOR=white>Работа</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../search">&nbsp;<FONT COLOR=white>Поиск</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../faq">&nbsp;<FONT COLOR=white>FAQ</FONT>&nbsp;</A>|</B></FONT></TD></TR>
<TR><TD BGCOLOR=#F5F5F5>
</noindex>
<TABLE BORDER=0 CELLSPACING=10><TR><TD>
<CENTER>
<H2 class="headline">
Borland IB Database FAQ</H2></CENTER> 
<BR><B>Borland ИнтерБэйз Q&amp;A, версия 2.02 от 31 мая 1999</B><BR>последняя 
редакция от 17 ноября 1999 года.<BR><B>Часто задаваемые вопросы и ответы по 
Borland IB Database</B> <BR><B>Материал подготовлен в Демо-центре 
клиент-серверных технологий. (Epsylon Technologies)</B></CENTER>
<DIV align=right><I><FONT color=#ff0000>Материал не является официальной 
информацией компании Borland.</FONT></I></DIV>
<DIV align=right>
<P><B>источники</B>: Borland International, Борланд АО, релиз IB Database 4.0, 
4.1, 4.2, 5.0, 5.1, 5.5, 5.6, различные источники на WWW-серверах, текущая 
переписка, московский семинар по Delphi и конференции, листсервер ESUNIX1, 
листсервер mers.com. </P></DIV>
<P><B>Cоставители</B>: <A href="mailto:dima@demo.ru">Дмитрий Кузьменко</A> 
<P><B>Этот документ содержит наиболее часто предоставляемую информацию по 
Borland IB Database.</B> 
<P>
<P>&nbsp; 
<TABLE cellPadding=2 cellSpacing=8 width="100%">
  <TBODY>
  <TR>
    <TD><B><A href="#1.1">1.1 Работает-ли 
      IB с русскими буквами ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.2">1.2 Я установил 
      Delphi 2.0 C/S, но почему-то использование русских кодировок приводит к 
      ошибке ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.3">1.3 Почему 
      таблица или select показываетс в Grid быстро, а перемещение в конец 
      таблицы происходит долго ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.4">1.4 Как я могу 
      работать с IB с клиентского компьютера ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.5">1.5 В каких 
      версиях IB поддерживаются уведомлени о событиях (Event Alerts) 
  ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.6">1.6 Сколько 
      памяти использует IB на сервере ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.7">1.7 У меня 
      возникают проблемы с открытием базы данных. USERNAME и PASSWORD вроде-бы 
      правильные.</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.8">1.8 Можно-ли 
      создать пользователя БД при помощи SQL-команды ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.9">1.9 Что такое 
      ISC4.GDB ? Для чего нужна эта БД ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.10">1.10 Я создал БД 
      с правами пользователей в Local IB. После переноса этой БД на IB for NT 
      все пользователи куда-то "пропали". В чем дело ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.11">1.11 Как 
      переносить базы данных между разными IB ? Например между Local IB и IB for 
      NetWare ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.12">1.12 Почему IB 
      работает неустойчиво на NetWare 4.x ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.13">1.13 Включение 
      WAL на NetWare ухудшает производительность на 80% при вставках записей, и 
      только на 15% - при обновлениях. Почему ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.14">1.14 Есть-ли 
      способ восстановить несохраненные (uncommitted) изменения БД, например в 
      случае отключения питания ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.15">1.15 Можно-ли в 
      запросах делать поиск по BLOB ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.16">1.16 Почему я 
      при вополнении запросов получаю "ошибку при создании файла 'SAA.AAA' 
      ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.17">1.17 Можно-ли 
      создать индекс по полю view ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.18">1.18 Почему в 
      операторе SELECT для VIEW нельзя использовать ORDER BY ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.19">1.19 Как 
      оптимизировать запросы ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.20">1.20 Какой 
      максимальный размер базы данных IB ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.21">1.21 Сколько БД 
      я могу открыть в одной транзакции ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.22">1.22 Сколько 
      таблиц может быть в одной БД ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.23">1.23 Сколько 
      строк и столбцов может быть у одной таблицы ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.24">1.24 Сколько 
      индексов может быть в БД или у таблицы ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.25">1.25 Сколько 
      событий можно вызвать из одной процедуры или триггера ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.26">1.26 Сколько 
      таблиц можно объединять в join?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.27">1.27 Сколько 
      уровней вложенности может иметь запрос ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.28">1.28 Сколько 
      полей можно использовать в одном составном (композитном) индексе 
    ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.29">1.29 Какая 
      глубина рекурсии допустима для триггеров или хранимых процедур 
  ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.30">1.30 Какой 
      максимальный размер текста хранимой процедуры или триггера?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.31">1.31 Сколько UDF 
      и фильтров blob можно определить для одной БД ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.32">1.32 Сколько 
      клиентов могут зарегистрироваться на одно событие ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.33">1.33 Как 
      освободить ресурсы, занятые IB ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.34">1.34 Как 
      осуществить referental integrity между разными БД ? Или как связать 
      таблицы из разных БД ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.35">1.35 Как 
      скопировать данные между БД ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.36">1.36 Как 
      конвертировать разные наборы символов ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.37">1.37 
      Поддерживает-ли IB репликацию и интерфейс X/Open XA ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.38">1.38 Можно-ли 
      использовать имя таблицы как параметр хранимой процедуры ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.39">1.39 Может-ли IB 
      шифровать данные в БД или при передаче по сети ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.40">1.40 Как 
      определить дисковое пространство, необходимое для хранения БД 
  ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.41">1.41 Как выбрать 
      размер страницы БД ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.42">1.42 
      "Архитектура множественных поколений записи" приводит иногда к странным 
      результатам - большое количество update без commit "тормозит" некоторые 
      другие запросы, пока для БД не сделать "sweep". В чем причина 
  ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.43">1.43 
      Поддерживает-ли IB поля типа autoincrement ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.44">1.44 На каком 
      языке пишутся хранимые процедуры ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.45">1.45 Как сделать 
      модуль UDF видимым IB ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.46">1.46 Есть-ли в 
      IB функция SUBSTR и вообще, почему в IB так мало встроенных функций 
      ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.47">1.47 Как можно 
      создавать UDF ? (определяемые пользователем функции)</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.48">1.48 Что такое 
      SHADOW в IB ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.49">1.49 Как 
      посмотреть содержимое или обновить теневую (shadow) БД ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.50">1.50 Почему 
      после выдачи Commit или RollBack при открытых таблицах или запросах они 
      перечитываются полностью ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.51">1.51 Как 
      избавиться от ошибки "multiple rows in singleton select" ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.52">1.52 Что такое 
      "метаданные" ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.53">1.53 Где IB 
      хранит информацию о метаданных ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.54">1.54 Почему 
      невозможно использовать домены (DOMAIN) в хранимых процедурах 
  ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.55">1.55 После 
      удаления хранимой процедуры невозможно удалить таблицы, использовавшиеся в 
      этой процедуре.</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.56">1.56 Как 
      получить QUERY PLAN при работе с IB API ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.57">1.57 Мне нужны 
      временные таблицы, но их нет в IB. Что делать ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.58">1.58 Что такое 
      "глубина индекса" (index depth), показываемая в Database 
    Analysis?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.59">1.59 Как часто 
      нужно делать Database Sweep ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.60">1.60 Запрос с 
      вычислением максимального (MAX) значения работает медленно.</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.61">1.61 Можно-ли 
      использовать stored procedures во view</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.62">1.62 Ошибка "low 
      volume of metadata change" или Как часто можно менять метаданные (например 
      изменять структуру таблиц)?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.63">1.63 
      Многоверсионность метаданных, или как поддерживается модификация структур 
      таблиц.</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.64">1.64 Почему 
      рекомендуется периодически делать backup/restore ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.65">1.65 Как 
      работает многоверсионность записей ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.66">1.66 Какие 
      блокировки обеспечивает IB ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.67">1.67 
      Существуют-ли в IB блокировки по чтению ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.68">1.68 Какие 
      уровни изоляции поддерживает IB ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.69">1.69 С какими 
      транзакциями работают BDE, WISQL ... ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.70">1.70 Можно-ли 
      управлять параметрами транзакций IB из BDE ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.71">1.71 Что такое 
      BLR ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.72">1.72 Что такое 
      UDF ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.73">1.73 Не 
      восстанавливаются (restore) процедуры (sp) с QUERY PLAN. Что делать 
      ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.74">1.74 Почему 
      Server Manager не показывает Database Connections на WinNT ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.75">1.75 Что такое 
      архитектура SuperServer ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.76">1.76 
      Соответствует-ли реализация SQL в IB стандарту ANSI и какому 
  ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.77">1.77 Можно-ли 
      поместить GDB-файл на другой компьютер ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.78">1.78 В чем 
      разница между OAT и OIT ? (старейшей активной и старейшей заинтересованной 
      транзакцией).</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.79">1.79 В чем 
      разница между CHAR и VARCHAR ? Что лучше использовать ?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.80">1.80 Можно-ли 
      поместить БД IB на CD-ROM ?</A></B> </TD></TR>
  <TR>
    <TD><A href="#1.81"><B>1.81 Как 
      выполнить create procedure/trigger при помощи TQuery?</B></A> </TD></TR>
  <TR>
    <TD><B><A href="#1.82">1.82 Как 
      установить генератор в нужное значение в процедуре или 
  триггере?</A></B></TD></TR>
  <TR>
    <TD><B><A href="#1.83">1.83 Не могу 
      подсоединиться к IB из под web-сервера IIS, Netscape, Baikonur и 
    др</A></B></TD></TR>
  <TR>
    <TD><A href="#1.84"><B>1.84 Ошибка при 
      установке "Internal error near IBcheck"</B></A></TD></TR>
  <TR>
    <TD>&nbsp; </TD></TR></TBODY></TABLE><A name=1.1></A><B>1.1 Работает-ли IB с 
русскими буквами ?</B> 
<P>Да, как с кодировкой 866 так и с 1251, как из Delphi 1.0, так и из Delphi 
2.0. Для того, чтобы в БД в строковых полях использовались русские буквы, 
необходимо при создании БД указать в качестве дополнительного параметра фразу: 
<P>DEFAULT CHARACTER SET WIN1251 
<P>А в BDECFG32 в драйвере IB и его псевдонимах (aliases) указать языковый 
драйвер Pdox ANSI Cyrillic. Такие установки обеспечат нормальную работу с 
кодировкой 1251. (в TDatabase.Params этот языковый драйвер указывается как 
LANGDRIVER=ancyrr). 
<P>Дополнительно, если вы предполагаете использовать выражение UPPER в SQL 
запросах, то Вам потребуется при создании таблиц IB использовать уточнение 
COLLATION SEQUENCE для строковых полей. 
<P>К сожалению, установить COLLATE PXW_CYRL по умолчанию для базы данных 
невозможно (такой параметр отсутствует). Поэтому таблицы IB, созданные при 
помощи Database Desktop или компонента TTable не будут иметь правильного COLLATE 
для работы с функцией SQL UPPER. (Эта проблема, необходимо отметить, не 
относится к работе с регистром русских букв внутри Delphi, поскольку для этого 
внутри VCL используются функции Windows, правильно переводящие буквы кодировки 
1251 в верхний регистр и обратно.) 
<P>Например, если возможен запрос такого типа: 
<P>SELECT * FROM CUSTOMERS <BR>WHERE UPPER(NAME) = 'ИВАНОВ' 
<P>То таблицу CUSTOMERS придется создавать при помощи текста 
<P>CREATE TABLE CUSTOMERS ( <BR>ID INTEGER NOT NULL, <BR>NAME CHAR(30) COLLATE 
PXW_CYRL, <BR>PRIMARY KEY (ID)) 
<P>фраза COLLATE PXW_CYRL заставляет IB использовать таблицу трансляции символов 
PXW_CYRL вместо WIN1251 (которая устанавливается по умолчанию для DEFAULT 
CHARACTER SET WIN1251). 
<P>Однако можно использовать указание порядка сортировки "на ходу", без указания 
порядка сортировки в описании таблицы - при помощи того-же спецификатора 
COLLATE. В этом случае запросы могут выглядеть следующим образом: 
<P>SELECT * FROM CUSTOMERS <BR>WHERE UPPER(NAME COLLATE PXW_CYRL) = 'ИВАНОВ' 
<P>Учтите, что если Вы используете ORDER BY NAME, то порядок записей у полей с 
COLLATE PXW_CYRL будет отличаться от имеющих только CHARACTER SET WIN1251. В 
этом случае необходимо и в ORDER BY указывать COLLATE. Например 
<P>SELECT * FROM CUSTOMERS <BR>WHERE UPPER(NAME COLLATE PXW_CYRL) = 'ИВАНОВ' 
<BR>ORDER BY NAME COLLATE PXW_CYRL 
<P><I>примечание</I>: решить проблему с изменением данных в русской кодировке 
при использовании ODBC-драйвера можно следующим образом: напрямую указывать 
кодировку перед строковым значением, содержащим русские символы. 
<P>INSERT INTO MYTABLE VALUES (1, _win1251 'Привет!'). 
<P>К сожалению, такой способ приводит к тому, что со стандартными компонентами 
TTable и TQuery можно работать только используя дополнительный компонент 
UpdateSQL (который позволяет переопределить запросы выдаваемые этими 
компонентами при INSERT, UPDATE, DELETE, и кроме этого присутствует только в 
Delphi 2.0). 
<P>ODBC-драйвер, поставляемый в дистрибутиве IB 5.5 позволяет указать кодировку 
win1251 для алиаса, при этом никаких манипуляций с _win1251 не требуется. 
<P><A name=1.2></A><B>1.2 Я установил Delphi X.0 C/S, но почему-то использование 
русских кодировок приводит к ошибке ?</B> 
<P>Проблемы с созданием БД с кодировкой WIN1251 могут быть если у Вас 
бета-версия Delphi. Еще одна причина - пробелы в имени каталога, в котором 
<BR>находятся файлы локального IB (Program Files\Borland\Delphi X.0\IntrBase), 
или база данных (gdb-файл). 
<P>Если вам не хочется переустанавливать IB, то вы можете сделать следующее: 
<LI>предварительно выгрузив локальный IB (если он виден на TaskBar), переместите 
каталог IntrBase в каталог, не содержащий в имени пробелов или на диск C: 
(C:\IntrBase). 
<LI>Запустите RegEdit. В Registry реально к IB имеют отношение две строки: 
автоматический запуск Local IB и путь к файлу лицензии IB. 
<LI>Найдите эти две строки и измените путь в этих строках на новый. 
<P><BR><A name=1.3></A><B>1.3 Почему таблица или select показывается в Grid 
быстро, а перемещение в конец таблицы происходит долго ?</B> 
<P>Когда вы открываете набор данных при помощи TTable, BDE производит fetch 
только такого количества записей, которые помещаются в Grid. Если вы захотели 
переместиться в конец таблицы, то для большинства SQL-серверов возможно 
перемещение по записям только вперед - т.е. если вам потребуется поместить 
указатель в середину таблицы то BDE пришлось-бы заново перечитывать записи с ее 
начала. Причина такой работы в том, что SQL-серверы в большинстве возвращают 
результаты запросов в виде последовательных наборов записей. В навигационных БД 
напротив, возможно физическое позиционирование на любую запись таблицы. 
<P>Если SQL-сервер поддерживает двунаправленные скроллируемые курсоры, то полное 
кэширование записей запроса выполняться BDE не будет. 
<P>Кроме этого, TTable и TQuery работают по разному. TQuery при перемещении в 
конец таблицы действительно сделает выборку всех записей, т.к. он и не может 
иначе - для выполнения задано конкретное SQL-выражение. 
<P>TTable-же напротив, показывает всю таблицу, и запросы для получения 
содержимого таблицы формируются автоматически. Поэтому TTable при нажатии вами в 
TDBGrid клавиш Ctrl-End сформирует запрос типа 
<P>SELECT * FROM TABLE ORDER BY INDEXFIELD DESC 
<P>и покажет только видимые в DBGrid записи "с конца". При этом, если нет DESC 
индекса по полю INDEXFIELD, сортировка данных (ORDER BY) будет производиться на 
диске. И чем больше записей в таблице, тем дольше. Для того, чтобы перемещение 
по Ctrl-End для TTable происходило быстро, нужно создать DESC индекс по полю 
сортировки. В этом случае операцию перехода в конец таблицы TTable выполнит 
практически мгновенно. Пользователи Delphi C/S могут посмотреть операторы, 
выдаваемые TTable SQL-серверу при помощи SQL Monitor. 
<P><A name=1.4></A><B>1.4 Как я могу работать с IB с клиентского компьютера 
?</B> 
<P>Можно использовать IB API (либо наборы компонт FreeIBComponents, IBObjects 
или IBX, работающие напрямую с IB API), BDE+SQL Links, либо ODBC-драйвер. 
<BR>Схема обмена данными между этими компонентами следующая 
<P>GDS32.DLL-&gt;IB прямое обращение к IB API <BR>ODBC-&gt;GDS32.DLL-&gt; IB 
работа через ODBC <BR>BDE-&gt;SQL Link-&gt;GDS32.DLL-&gt;IB работа через BDE 
<BR>BDE-&gt;ODBC-&gt;GDS32.DLL-&gt;IB работа через BDE, ODBC вместо SQL Link. 
<P>Практически во всех случаях вам не требуется производить какие-либо 
специфические настройки. 
<P><A name=1.5></A><B>1.5 В каких версиях IB поддерживаются уведомления о 
событиях (Event Alerts) ?</B> 
<P>Во всех, кроме локального IB для Windows 3.1. Это очень сильно урезанная 
версия IB, даже по сравнению с Local IB 4.1 for Windows95.<BR>Устойчивая работа 
Event Alerters зависит как от используемого компонента (см. 
ib.demo.ru/download.htm), так и от сервиспаков, установленных на NT Server или 
Workstation. Например, уведомление о событиях работает, если<BR>установлен SP3 и 
postsp3 hotfix TEARDROP2,<BR>либо установлен SP4 (большой, т.е. ~70мегабайт). 
<P>EventAlerters могут работать неустойчиво, если для SP3 не установлен 
teardrop2, либо вообще не работать, если установлен SP4 размером ~32 мегабайта 
(из-за версии tcpip.sys). Если клиентами являются NT Workstation, настоятельно 
рекомендуется на клиентах установить тот же SP и постфиксы, что и для сервера. 
<P><A name=1.6></A><B>1.6 Сколько памяти использует IB на сервере ?</B> 
<P>Минимально при запуске - от 1.2 до 3 Мб, далее память распределяется 
динамически в зависимости от запросов, выполняемых клиентами (от 40 до 400К на 
клиента). Кроме этого, объем используемой памяти сильно зависит от архитектуры 
сервера (IB 4.0 и IB 4.2, IB 5.x для NT и IB 5.x для Linux), размера кэша 
страниц БД и других настроек. Подробнее по настройкам см. PERFORM.HLP в каталоге 
INTRBASE\BIN 
<P><A name=1.7></A><B>1.7 У меня возникают проблемы с открытием базы данных. 
USERNAME и PASSWORD вроде-бы правильные.</B> 
<P>Может быть, что в момент ввода пароля клавиатура переключена в режим Caps 
Lock - а пароль является регистрочувствительным. После установки действуют имя 
пользователя SYSDBA и пароль masterkey. Они предназначены для работы 
Администратора БД. Из соображений security вы должны изменить пароль masterkey, 
чтобы никто кроме вас не смог подсоединиться к IB. Также, ни в коем случае 
нельзя удалять пользователя SYSDBA, иначе вы потеряете доступ к системным 
таблицам. 
<P><A name=1.8></A><B>1.8 Можно-ли создать пользователя БД при помощи 
SQL-команды ?</B> 
<P>Нет. Единственно правильный способ - использовать Server Manager. (Tasks | 
User Security), либо утилиту командной строки GSEC, либо IB user API (для IB 
5.x). См. ib.demo.ru/download.htm, www.borland.com/devsupport/bde/. 
<P><A name=1.9></A><B>1.9 Что такое ISC4.GDB ? Для чего нужна эта БД ?</B> 
<P>БД ISC4.GDB используется IB для хранения информации о пользователях (имена, 
пароли и т.п.). Удалять этот файл нельзя. Вы можете создать alias на эту БД и 
посмотреть ее содержимое, но программно не сможете создавать или изменять 
пользователей поскольку шифрация и дешифрация пароля выполняется IB. 
<P><A name=1.10></A><B>1.10 Я создал БД с правами пользователей в Local IB. 
После переноса этой БД на IB for NT все пользователи куда-то "пропали". В чем 
дело ?</B> 
<P>Причина в том, что информация о пользователях IB хранится в специальном файле 
ISC4.GDB, и является общей для всех БД на конкретном компьютере. Очевидно что в 
вашем случае на сервере IB for NT отсутствовали пользователи, заведенные вами 
для Local IB. Вам придется создать всех ваших пользователей и для IB for NT (при 
помощи Server Manager). То же самое будет и при переносе базы данных между 
серверами IB. Т.е. на обоих серверах пользователи должны быть созданы отдельно. 
<P>Если версии IB и платформы на обоих серверах совпадают, то ISC4.GDB можно 
просто скопировать. Разумеется, при отсутствии подсоединений. (еще лучше вообще 
выключить сервер БД на время копирования isc4.gdb). 
<P>Перенести isc4.gdb между платформами можно следующим способом: сделать backup 
isc4.gdb, восстановить на нужном сервере эту БД в другое имя (например 
isc4_new.gdb), остановить сервер IB, удалить старую isc4.gdb и переименовать 
isc4_new.gdb. 
<P><A name=1.11></A><B>1.11 Как переносить базы данных между разными IB ? 
Например между Local IB и IB for NetWare (Linux)?</B> 
<P>Для переноса нужно использовать операцию backup/restore, т.к. формат хранения 
данных для разных платформ разный. Переносить БД без backup/restore можно только 
в том случае, если у IB-источника и IB-приемника совпадает версия ODS - OnDisk 
Structure. Версию ODS можно увидеть в Server Manager после подсоединения к БД и 
вызову пункта меню Tasks/Database Statistics (Database Header, ODS version). Как 
правило, даже у одной и той же версии IB, но для разных операционных систем 
версия ODS разная. 
<P><A name=1.12></A><B>1.12 Почему IB работает неустойчиво на NetWare 4.x ?</B> 
<P>Для NetWare 4.x нужно использовать IB 4.2.2. Предыдущие версии IB for Netware 
сертифицированы только для NetWare 3.11/3.12.<BR>Для NetWare 5.x выпущена версия 
IB 5.6. 
<P><A name=1.13></A><B>1.13 Включение WAL на NetWare ухудшает производительность 
на 80% при вставках записей, и только на 15% - при обновлениях. Почему ?</B> 
<P>Файл WAL должен быть расположен на другом винчестере чем основная БД. (это-же 
относится и к теневой БД). В этом случае ухудшения производительности не будет. 
Кроме этого вы должны учитывать, что запись в WAL происходит синхронно с БД, 
поэтому сравнивать "производительность" WAL с асинхронными изменениями в БД 
некорректно. 
<P><A name=1.14></A><B>1.14 Есть-ли способ восстановить несохраненные 
(uncommitted) изменения БД, например в случае отключения питания ?</B> 
<P>Нет. Такие изменения будут потеряны. Т.е. БД останется в состоянии, 
соответствующем последней подтвержденной (committed) транзакции. Несохраненные 
данные в БД останутся в виде "осиротевших" страниц, которые можно очистить при 
помощи Server Manager, пункт меню Validate Database, или в виде "мусорных" 
версий записей, которые будут очищены при очередном чтении данных. 
<P>Вполне возможно, что этот вопрос вызван тем, что восстановление состояния БД 
в IB отличается от других широкораспространенных SQL-серверов (Oracle, Informix, 
...). IB не требует выполнения каких-то специфических действий для продолжения 
работы с БД в случае сбоя питания - изменения, происходящие до COMMIT, не 
записываются на место актуальных данных (т.е. отсутствует режим Dirty Read), 
поэтому они будут просто потеряны, а БД останется в рабочем состоянии. 
<P><I>примечание</I>: считается что транзакция - логический блок действий, 
переводящий БД из одного целостного состояния в другое. Поэтому даже если сервер 
позволяет восстановить uncommitted изменения, то делать этого не стоит. 
<P><A name=1.15></A><B>1.15 Можно-ли в запросах делать поиск по BLOB ?</B> 
<P>Да. Поиск по строковым (CHAR, VARCHAR) полям или по BLOB можно производить 
при помощи операторов CONTAINING, STARTING WITH и LIKE. Например 
<P>SELECT * FROM MYTABLE <BR>WHERE BLOBFIELD CONTAINING 'sometext'; 
<P>Поиск по умолчанию считается case-insensitive (регистро-нечувствительный), 
поэтому для латинских букв строку поиска можно задавать строчными буквами (в 
нижнем регистре). В этом случае при поиске 'sometext' в ответ войдут записи с 
'sometext', 'SOMETEXT' и 'SomeText'. К сожалению, для BLOB невозможно указать 
COLLATE для правильного перевода русских букв в верхний регистр, поэтому поиск 
слов, содержащих русские буквы, будет производиться только по точному 
совпадению. 
<P>При поиске подтип BLOB (SUB_TYPE 0 или 1 - текст или binary) не имеет 
значения, т.к. подтип имеет значение только для приложения, или для фильтров 
BLOB. BLOB-ы разных подтипов хранятся абсолютно одинаковым способом. 
<P><A name=1.16></A><B>1.16 Почему я при вополнении запросов получаю "ошибку при 
создании файла 'SAA.AAA' ?</B> 
<P>Этот файл является временным, и создается когда при выполнении запроса 
возникает необходимость в сортировке результата. Ошибка может возникать при 
нехватке дискового пространства на томе, куда указывает TEMP. Для NT при работе 
IB в режиме сервиса необходимо изменить переменную TEMP для System (см. My 
Computer/Properties/Environment). Для IB 5.x можно указать диски и размер 
временных файлов в файле конфигурации IBCONFIG, или в переменной окружения 
INTERBASE_TMP (см. Operations Guide, стр92). Например:<BR>
<P>TMP_DIRECTORY "c:\" 10000000<BR>TMP_DIRECTORY "e:\temp\" 100000000<BR>Может 
быть указано несколько дисков или каталогов, которые будут использоваться 
последовательно. Размер должен быть указан в байтах. Кавычки для имени диска и 
каталога обязательны. 
<P><A name=1.17></A><B>1.17 Можно-ли создать индекс по полю view ?</B> 
<P>Нет. Индекс должен быть у поля таблицы, входящей во view. View является видом 
на таблицу или несколько таблиц, поэтому не может иметь физического индекса как 
у обычной таблицы. 
<P>Если вы хотите использовать индексы в компоненте TTable, то делать это нужно 
не через свойство IndexName, а указывая поле, по которому вы хотите 
отсортировать таблицу или view, непосредственно в свойстве IndexFieldNames. 
SQL-сервер сам разберется, есть-ли по такому полю индекс, и сможет-ли он 
использовать его для ускорения обработки запросов. 
<P><A name=1.18></A><B>1.18 Почему в операторе SELECT для VIEW нельзя 
использовать ORDER BY ?</B> 
<P>Вообще независимо от наличия индексов записи в таблице располагаются в том 
порядке, в котором они добавлялись. Поскольку view представляет из себя 
"виртуальную" таблицу, то записи также должны быть представлены в произвольном 
порядке. 
<P><A name=1.19></A><B>1.19 Как оптимизировать запросы ?</B> 
<P>Вот несколько простых рекомендаций для оптимизации запросов: </P>
<LI>избегайте явного использования outer join 
<LI>используйте неявный join (select a,b, from a1, b1 where ...) вместо явного. 
<LI>пробуйте разный порядок таблицы в запросе для получения оптимальной 
производительности (также и для явного join) 
<LI>пробуйте ваши запросы в WISQL, включив Show Query Plan и Show Statistics. 
<LI>используйте индексы по полям, участвующим в условиях where. 
<LI>не забывайте делать SET STATISTICS по индексам, созданным вами специально 
для ускорения запросов. 
<P>К сожалению, не существует точных правил по оптимизации запросов - это путь 
проб и ошибок, т.к. невозможно заранее предсказать ни ваши запросы, ни ваши 
реальные данные. 
<P><I>примечание</I>: бывают ситуации, когда оптимизатор "настаивает" на 
использовании всех индексов по определенному столбцу, даже если создан 
специальный композитный индекс по всем полям where. В этом случае необходимо 
принудительно заставить оптимизатор IB использовать нужный запрос, причем 
скорость отработки такого запроса может ускориться в 10 раз. 
<P><A name=1.20></A><B>1.20 Каков максимальный размер базы данных IB ?</B> 
<P>Borland и независимые эксперты сообщают, что IB может обслуживать файлы БД 
размером в ~10-20 гигабайт. Существует также ограничение на размер одного файла 
БД, которое в основном зависит от ограничений используемой файловой системы, и 
составляет от 2 до 4 гигабайт. В любом случае не стоит допускать увеличения 
размера одного файла БД выше 2 гигабайт (создайте один или более вторичных 
файлов заранее). Многофайловая БД может состоять из 65535 файлов, таким образом 
теоретический предел для одной базы данных IB - 132 терабайта. 
<P><A name=1.21></A><B>1.21 Сколько БД я могу открыть в одной транзакции ?</B> 
<P>Не существует архитектурнго ограничения на такую возможность. Пользователи 
сообщают о работе одновременно с 17-ю БД. 
<P><A name=1.22></A><B>1.22 Сколько таблиц может быть в одной БД ?</B> 
<P>65,536. Количество определяется переменной типа SHORT. 
<P><A name=1.23></A><B>1.23 Сколько строк и столбцов может быть у одной таблицы 
?</B> 
<P>Не существует ограничений на количество записей таблицы. Размер записи может 
быть не более 64К, поэтому максимальное количество столбцов зависит от 
используемых типов полей. Длины BLOB и VARCHAR в это число не входят, т.к они 
хранятся отдельно от основной записи. 
<P><A name=1.24></A><B>1.24 Сколько индексов может быть в БД или у таблицы ?</B> 

<P>Можно создать в одной БД до 65535 индексов. Все они могут быть и для одной 
таблицы. 
<P><A name=1.25></A><B>1.25 Сколько событий можно вызвать из одной процедуры или 
триггера ?</B> 
<P>Ограничений на количество POST_EVENT нет, однако на клиентском месте 
ограничения могут быть. Например компонент IBEventAlerter в поставке Delphi 
может зарегистрировать максимально 15 событий. 
<P><A name=1.26></A><B>1.26 Сколько таблиц можно объединять в join?</B> 
<P>Нет архитектурных ограничений. Пользователи сообщают о запросах одновременно 
по 15-и таблицам. 
<P><I>примечание</I>: оптимизатор 5.x для более чем 7-и объединяемых явным или 
неявным join производит операцию SORT MERGE (сортировка слиянием). Это приводит 
к сильному замедлению запроса как минимум прямо пропорционально количеству 
записей в таблицах. Эту проблему можно исправить только если запрос вроде 
<P>select H.id, ...<BR>from H, A, B, C, D, E, F, G<BR>where a.id = h.aid and 
b.id = h.bid and c.id = h.cid and d.id = h.did and e.id = h.eid and f.id = h.fid 
and g.id = h.gid 
<P>привести к виду 
<P>select H.ID, <BR>H.AID, (select A.NAME from A where A.ID = H.AID), <BR>H.BID, 
(select B.NAME from B where B.ID = H.BID), <BR>H.CID, (select C.NAME from C 
where C.ID = H.CID), <BR>H.DID, (select D.NAME from D where D.ID = H.DID), 
<BR>H.EID, (select E.NAME from E where E.ID = H.EID), <BR>H.FID, (select F.NAME 
from F where F.ID = H.FID), <BR>H.GID, (select G.NAME from G where G.ID = 
H.GID)<BR>from H 
<P><A name=1.27></A><B>1.27 Сколько уровней вложенности может иметь запрос ?</B> 

<P>Нет архитектурных ограничений. Пользователи сообщают о запросах вложенностью 
около 16-и. 
<P><A name=1.28></A><B>1.28 Сколько полей можно использовать в одном составном 
(композитном) индексе ?</B> 
<P>До 16 полей. Обратите внимание, что в документации по IB сказано: "создание 
foreing key по двум и более полям ошибки не вызывает, но не обрабатывается". 
Кроме этого, оптимизатор будет использовать такой индекс только в том случае, 
если в предложении WHERE или ORDER BY указаны все поля, составляющие этот 
индекс, и для ORDER BY именно в том порядке, в котором они упоминаются в 
индексе. 
<P><A name=1.29></A><B>1.29 Какая глубина рекурсии допустима для триггеров или 
хранимых процедур ?</B> 
<P>Триггеры и хранимые процедуры имеют ограничение в 1000 рекурсивных вызовов 
под UNIX, и около 700 - под NT. Реально это число меньше, и зависит от 
количества локальных переменных в хранимой процедуре, а также от объема текста 
самой процедуры. 
<P>Рекурсия для триггеров означает например выполнение UPDATE в триггере BEFORE 
UPDATE для одной и той же таблицы, или выполнение в триггере процедуры, которая 
модифицирует эту же таблицу, что вызывает срабатывание того же триггера. 
<P><A name=1.30></A><B>1.30 Какой максимальный размер текста хранимой процедуры 
или триггера?</B> 
<P>Размер скомпилированной процедуры или триггера может быть до 48K. 
(скомпилированные процедуры и триггеры находятся в blob-полях RDB$TRIGGER_BLR и 
RDB$PROCEDURE_BLR соответствующих системных таблиц RDB$TRIGGERS и 
RDB$PROCEDURES). 
<P>В любом случае не стоит доводить даже исходный текст процедур и триггеров до 
таких размеров - разбираться в таких текстах будет очень трудно. 
<P><A name=1.31></A><B>1.31 Сколько UDF и фильтров blob можно определить для 
одной БД ?</B> 
<P>Имя UDF ограничено длиной в 31 символ. Количество параметров UDF - не более 
10. Других ограничений нет. 
<P><A name=1.32></A><B>1.32 Сколько клиентов могут зарегистрироваться на одно 
событие ?</B> 
<P>Такого ограничения не существует. 
<P><A name=1.33></A><B>1.33 Как освободить ресурсы, занятые IB ?</B> 
<P>Сделайте серверу IB ShutDown при помощи Server Manager. 
<P><A name=1.34></A><B>1.34 Как осуществить referental integrity между разными 
БД ? Или как связать таблицы из разных БД ?</B> 
<P>Автоматической поддержки RI между разными БД нет (т.к. таблицы одной БД не 
видны из другой). Вам придется это делать программно, используя two-phase commit 
при прямом доступе к IB либо из разных TDatabase через BDE. В последнем случае 
при объединении таблиц записи будут извлечены из БД на клиентскую часть и только 
затем объединены. 
<P>Ситуация с отсутствием возможности связывания таблиц из разных БД считается 
нормальной, т.к. целостность данных должна обеспечиваться только в пределах 
одной БД. Кроме этого, невозможно объединить словарь данных у разных БД (это 
относится практически ко всем SQL-серверам). 
<P><A name=1.35></A><B>1.35 Как скопировать данные между БД ?</B> 
<P>Такая возможность присуствует в IB 4.0, 4.1 (утилита QLI) однако отсутствует 
в IB 4.2. Вам придется написать собственную программу с использованием BDE или 
IB API. В простейшем случае можно обойтись утилитами DATAPUMP или Database 
Desktop. Также см. ib.demo.ru/download.htm. 
<P><A name=1.36></A><B>1.36 Как конвертировать разные наборы символов ?</B> 
<P>Преобразование кодировок обслуживается автоматически, при операциях 
копирования и при запросах. Таким образом, если вы создадите поле с новой 
кодировкой символов, то при копировании данных в это поле они отконвертируются. 
<P><A name=1.37></A><B>1.37 Поддерживает-ли IB репликацию и интерфейс X/Open XA 
?</B> 
<P>IB не поддерживает репликацию или X/Open в версиях 4.0, 4.1, 4.2, 5.0, 5.1, 
5.5, 5.6. <BR>IB 6.0 будет содержать репликатор. В настоящее время существует 
несколько сторонних реализаций репликаторов, найти которые можно на ib.demo.ru. 
<P><A name=1.38></A><B>1.38 Можно-ли использовать имя таблицы как параметр 
хранимой процедуры ?</B> 
<P>Нет, но можно передать какое-либо строковое или числовое значение, чтобы 
обработать его по IF .. ELSE. 
<P>Хранимая процедура не может динамически получать имя таблицы. (похоже что 
причиной является то, что текст хранимой процедуры "скомпилирован" в BLR, 
который невозможно интерпретировать). 
<P><A name=1.39></A><B>1.39 Может-ли IB шифровать данные в БД или при передаче 
по сети ?</B> 
<P>IB не поддерживает шифрование вообще. Считается что быстрые алгоритмы 
шифрования использовать не имеет смысла из-за их низкой степени защищенности, а 
серъезные алгоритмы шифрования работают слишком медленно для нормальной работы с 
БД (по скорости отклика). Поэтому защиту БД от несанкционированного доступа 
должна обеспечивать операционная система, а защиту передаваемых данных - 
специальное оборудование. 
<P><A name=1.40></A><B>1.40 Как определить дисковое пространство, необходимое 
для хранения БД ?</B> 
<P>Точно посчитать размер БД не представляется возможным. Однако для 
предсказания размера БД можно использовать определенные утверждения: </P>
<LI>При импорте данных страницы (data pages) заполняются наполовину, если для 
базы данных не указан флаг no_reserve (по умолчанию). Таким образом объем 
импортированных данных будет в два раза больше (если данные импортируются из 
текстовых файлов). Размер ключа индекса в байтах равен 5 + длина поля, однако 
индексы упаковываются даже при вставке записей. 
<LI>При импорте данных страницы индексов заполняются тем плотнее, чем меньше 
разница между индексируемыми значениями. Если IB не может произвести сжатие 
ключей, то индексные страницы будут заполнены наполовину. 
<LI>При восстановлении (restore) данных страницы данных будут заполнены опять-же 
наполовину, а страницы индексов - полностью. 
<LI>Поля типов CHAR и VARCHAR хранят столько символов, сколько занимает значение 
поля. 
<LI>Строковые поля и также числовые последовательности при обновлении могут быть 
упакованы по алгоритму RLE. 
<LI>BLOB-поля хранятся сегментами (по умолчанию 80 байт), т.е. на одной странице 
данных может помещаться несколько значений BLOB если их суммарный размер меньше 
размера страницы. 
<P>Необходимо также учитывать, что при работе с БД возможно динамическое 
создание страниц, необходимых для хранения версий записей. Эти страницы не 
возвращаются файловой системе даже при операции database sweep. Как следствие 
этого, БД занимает минимально возможный объем только после операций 
backup/restore, и максимальный - при частом обновлении данных большим 
количеством пользователей. 
<P><A name=1.41></A><B>1.41</B> <B>Как выбрать размер страницы БД ?</B> 
<P>Этому посвящен один из разделов IB Data Definition Guide. Теоретически имеет 
смысл увеличить до 4К (с умолчательного 1К) размер страницы, если большее кол-во 
таблиц в вашей БД имеет количество записей &gt; 200000 (200 тыс.). Не забудьте, 
что увеличение размера страницы повлечет увеличение размера кэш-буфера IB, т.к. 
он измеряется в страницах. 
<P>Безусловно, нужно ориентироваться на конкретную задачу - если ваше приложение 
часто выбирает случайные записи из БД, то производительность при увеличении 
размера страницы может ухудшиться (больше обмена с диском), и наоборот - для 
последовательных выборок больший размер страницы предпочтительнее. 
<P><A name=1.42></A><B>1.42 "Архитектура множественных поколений записи" 
приводит иногда к странным результатам - большое количество update без commit 
"тормозит" некоторые другие запросы, пока для БД не сделать "sweep". В чем 
причина ?</B> 
<P>Архитектура множественных поколений записи" требует "кооперативной сборки 
мусора". Это означает что каждый запрос который обнаружит неактуальные записи 
должен удалить их. Это позволяет значительно уменьшить блокировки и ускорить 
операции commit/rollback. Однако, как вы заметили, иногда выполнение запросов 
может сильно замедляться если на диске много "устаревших" записей. Это 
происходит из-за того, что изменения записываются как delta между старой и новой 
записью, и при чтении новой записи IB должен ее "собрать" из старых данных и 
delta. Для оптимизации "сборки" записей IB заполняет страницы данных только 
наполовину, оставляя вторую половину для хранения возможных delta. Если это 
пространство исчерпывается, то IB распределяет новые страницы для хранения 
delta. В этом случае ухудшается IO (для сборки записей приходится читать 
дополнительные страницы), которое и приводит к ухудшению общей 
производительности. 
<P>Реально, большинство приложений не обновляют всю БД непрерывно, поэтому 
затраты на поколения записей оказываются несущественными в смысле общей 
производительности. (т.е. для хранения delta хватает свободного пространства на 
страницах данных, и не возникает лишнего обмена с диском). 
<P>Другие SQL-серверы, которые не поддерживают множественные поколения записей, 
могут порождать проблемы другого рода - для запросов с изоляцией Repeatable Read 
либо полное дублирование данных, либо полное блокирование обновляемых таблиц. 
<P>Кроме того, logging в других SQL-серверах может вызывать похожее ухудшение 
производительности. 
<P><A name=1.43></A><B>1.43 Поддерживает-ли IB поля типа autoincrement ?</B> 
<P>В явном виде нет - вместо этого в IB существует другой механизм, называемый 
"генераторами". Генератор - некая переменная, значение которой может быть 
получено и увеличено на некоторое значение (дельту) при помощи встроенной 
функции GEN_ID. Создать генератор можно фразой 
<P>CREATE GENERATOR MYGENERATOR; 
<P>Обычно генераторы используют в триггерах, при этом текст триггера может быть 
следующим: 
<P>CREATE TRIGGER TI_CLIENTS FOR CLIENTS <BR>ACTIVE BEFORE INSERT POSITION 0 
<BR>AS <BR>&nbsp;&nbsp;&nbsp; BEGIN 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IF (new.CLIENT_ID IS NULL) THEN 
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CLIENT_ID 
= GEN_ID(MYGENERATOR, 1); <BR>&nbsp;&nbsp;&nbsp; END 
<P>Вместо значения "1" может быть использовано любое число, на которое нужно 
иметь приращение текущего значения генератора. 
<P>Механизм генераторов гарантирует что даже при конкурентном (параллельном) 
вызове функции GEN_ID каждому пользователю будет выдаваться уникальное значение. 
Последнее значение генератора всегда запоминается в БД, поэтому разработчику не 
нужно заботиться о "восстановлении" его максимального значения после 
подсоединения к БД. 
<P>Генераторы являются переменными типа integer (longint), таким образом если 
предположить что новое значение возвращается в среднем с интервалом в 3 секунды, 
значений генератора хватит приблизительно на 270 лет. 
<P><I>примечание</I>: если вы воспользуетесь приведенным выше примером 
использования генератора в триггере, то у вас может возникнуть следующая 
проблема - при добавлении записей с клиентского места новые записи будут 
"пропадать", или будет появляться сообщение BDE "Record/Key deleted". Это 
связано с тем, что клиенту никаким образом не может быть передана информация об 
идентификаторе сформированом в триггере на сервере. 
<P>Т.е. новую запись можно будет увидеть только либо перевыполнив запрос либо 
переместившись в конец таблицы (если еще не произошел fetch всех записей. Для 
исключения такой ситуации можно создать хранимую процедуру возвращающую значение 
генератора (так-же как и для триггера), и вызывать эту процедуру _перед_ 
созданием новой записи (для Delphi - TTable.BeforePost). Вместо процедуры можно 
использовать запрос select gen_id(mygen, 1) from rdb$database. 
<P><A name=1.44></A><B>1.44 На каком языке пишутся хранимые процедуры ?</B> 
<P>Хранимые процедуры пишутся на языке SQL включая некоторые расширения - begin, 
end, exception, exit, if then else и т.д. За более подробной информацией 
обращайтесь к IB Language Reference или IB Data Definition Guide (в печатном или 
электронном виде). 
<P><A name=1.45></A><B>1.45 Как сделать модуль UDF видимым IB ?</B> 
<P>DLL с UDF нужно поместить либо в тот каталог, где находится исполняемый файл 
IB, либо в WINDOWS\SYSTEM либо в WINNT\SYSTEM32.Не имеет смысла помещать UDF DLL 
в каталог, где находится БД. 
<P>Регистрацию функций подключаемых UDF можно производить в любой момент - DLL 
будет загружена в память только при первом обращении к любой из функций UDF DLL. 

<P><I>примечание</I>: вы должны учитывать особенности работы с UDF в IB версий 
4.2 и выше (с архитектурой SuperServer). 
<P><A name=1.46></A><B>1.46 Есть-ли в IB функция SUBSTR и вообще, почему в IB 
так мало встроенных функций ?</B> 
<P>Функции SUBSTR в IB нет, но такую функцию можно достаточно просто написать и 
подключиь к IB. Начиная с версии 5.0 SubStr и другие функции поставляются в 
комплекте с IB, однако для их использования их нужно объявить в базе данных 
явно. 
<P><A name=1.47></A><B>1.47 Как можно создавать UDF ? (определяемые 
пользователем функции)</B> 
<P>Определяемые пользователем функции (UDF) могут быть на любом языке 
программирования (компилятор которого поддерживает создание DLL), например на 
Delphi 2.0 для IB 4.0 for Windows NT или Windows 95, и на C для IB под Windows- 
и Unix-платформах. 
<P>Для ознакомления с написанием UDF на Delphi можно обратиться к UDF Starter 
Kit, распространяемому ДемоЦентром. Это наиболее полное описание того, как можно 
писать UDF и какие параметры в них можно обрабатывать. Вместе с тем предлагаемые 
функции можно использовать как готовый набор. 
<P><A name=1.48></A><B>1.48 Что такое SHADOW в IB ?</B> 
<P>Shadow - это программное "зеркалирование" БД. Все операции записи, 
производимые над каким-либо файлом GDB параллельно производятся и над 
соответствующим файлом SHADOW. При сбое GDB вы можете остановить работу 
пользователей и просто скопировать Shadow на место оригинальной БД (GDB), после 
чего продолжить работу. Необходимо учитывать, что поддержка Shadow замедляет 
операции изменения БД. Желательно чтобы Shadow располагалась на другом 
винчестере, и еще лучше если винчестеры с GDB и Shadow будут иметь разные 
контроллеры - в этом случае запись будет распараллеливаться. 
<P>В ДемоЦентре проводились элементарные тесты на Local IB 4.1 (из комплекта 
Delphi 2.0) под Windows95. Тест представлял собой добавление 10000 (десять 
тысяч) записей в пустую БД, каждые 1000 записей обрамлялись 
StartTransaction-Commit. Использовался HDD с контроллером IDE: (одна запись = 
~100 байт + BLOB-поле 512К) 
<P>&nbsp;усредненное время 
<TABLE border=1 width="56%">
  <TBODY>
  <TR>
    <TD noWrap>без Shadow&nbsp;</TD>
    <TD>&nbsp;4мин 40сек&nbsp;</TD></TR>
  <TR>
    <TD>с Shadow на том-же винчестере&nbsp;</TD>
    <TD>&nbsp;6мин 00сек&nbsp;</TD></TR>
  <TR>
    <TD>с Shadow на другом винчестере&nbsp;</TD>
    <TD>&nbsp;4мин 50сек&nbsp;</TD></TR></TBODY></TABLE>Разумеется, при интенсивной 
многопользовательской работе и достаточно большой базе данных теоретически 
должны ожидаться следующие результаты коэффициент замедления 
<TABLE border=1 width="56%">
  <TBODY>
  <TR>
    <TD noWrap>без Shadow&nbsp;</TD>
    <TD>&nbsp;1&nbsp;</TD></TR>
  <TR>
    <TD>с Shadow на том-же винчестере&nbsp;</TD>
    <TD>&nbsp;1.6 (минимум в полтора раза)&nbsp;</TD></TR>
  <TR>
    <TD>с Shadow на разных винчестерах&nbsp;</TD>
    <TD>&nbsp;~1 (почти без замедления)&nbsp;</TD></TR></TBODY></TABLE>&nbsp;Кроме 
того, очень сильное влияние на быстродействие IB оказывает параметр Forced 
Writes - немедленное сохранение изменений страниц. Вы можете включить или 
выключить этот параметр для конкретной БД на ходу при помощи Server Manager. При 
выключенном Forced Writes работа с БД происходит в 5-6 раз быстрее, но есть 
опасность потерять БД при внезапном выключении питания 
сервера.<BR><I>примечание</I>: при работе со SCSI-устройствами, или IDE с 
драйвером BusMaster, разница при работе с включенным или выключенным Forced 
Writes будет минимальна, если вообще заметна. 
<P><A name=1.49></A><B>1.49 Как посмотреть содержимое или обновить теневую 
(shadow) БД ?</B> 
<P>Такие операции нельзя проводить над теневой БД. IB автоматически обеспечивает 
полное соответствие оригинальной БД и ее тени. Изменения в теневой БД происходят 
не на уровне транзакций, а на уровне модификаций страниц основной БД. 
<P><A name=1.50></A><B>1.50 Почему после выдачи Commit или RollBack при открытых 
таблицах или запросах они перечитываются полностью ?</B> 
<P>Начнем с того, что такое перечитывание в BDE происходит не всегда. Если вы 
открываете TTable или TQuery в контексте какой-либо транзакции, то содержимое 
этих источников данных определяется уровнем изоляции транзакции (ReadCommitted 
или RepeatableRead). Если при открытых источниках данных завершить транзакцию 
подтверждением или откатом, то контекст транзакции сменится - вступит в действие 
т.н. неявная транзакция, которая стартует после соединения с БД. В результате 
данные, прочитанные до смены контекста могут стать неактуальными, поэтому BDE 
фактически переоткрывает курсоры. А поскольку неизвестно, на какой строке 
выборки завершилась явная транзакция, считываются все записи (fetch до конца 
таблицы). 
<P>Следует избегать таких ситуаций, и по крайней мере достаточно большие выборки 
закрывать перед завершением или началом явной транзакции. 
<P>Более подробную информацию о поведении BDE при commit/rollback вы сможете 
получить в BDE32.HLP, пункт DbiEndTran. 
<P><A name=1.51></A><B>1.51 Как избавиться от ошибки "multiple rows in singleton 
select" ?</B> 
<P>Очевидно что данная ошибка происходит в вашем триггере или хранимой 
процедуре. Обычный SELECT внутри триггера или процедуры должен возвращать одну 
строку (row), т.к. при двух и более строках IB не знает куда поместить значения 
полей этих строк. Если ваш SELECT возвращает несколько записей, то нужно 
пользоваться конструкцией FOR SELECT ... INTO ... DO ... которая производит 
обработку возвращаемого набора записей в цикле. 
<P>Если-же вы уверены, что ваш SELECT должен вернуть только одну запись, а 
ошибка все-таки возникает, то давайте рассмотрим следующую ситуацию: </P>
<LI>существуют таблицы ORDERS (заказы) и CLIENTS (клиенты). 
<LI>обе эти таблицы имеют поле связи CLIENT_ID INTEGER. 
<LI>для того чтобы вытащить информацию о клиенте используется запрос: <BR>
<P>SELECT CLIENT_ID, CLIENT_NAME <BR>FROM CLIENTS <BR>WHERE CLIENT_ID = ? 
<P>где ? - либо значение либо переменная. 
<P>Теперь представим себе, что этот запрос должен выполняться в триггере при 
вставке записи в таблицу ORDERS 
<P>CREATE TRIGGER TI_ORDERS FOR ORDERS <BR>ACTIVE AFTER INSERT POSITION 0 <BR>AS 
<BR>DECLARE VARIABLE CID INTEGER; <BR>DECLARE VARIABLE CNAME CHAR(30); <BR>BEGIN 
<BR>&nbsp;&nbsp;&nbsp; SELECT C.CLIENT_ID, C.CLIENT_NAME <BR>&nbsp;&nbsp;&nbsp; 
FROM CLIENTS C <BR>&nbsp;&nbsp;&nbsp; WHERE C.CLIENT_ID = CLIENT_ID 
<BR>&nbsp;&nbsp;&nbsp; INTO :CID, :CNAME; <BR>&nbsp;&nbsp;&nbsp; ... 
<P>Итак, поскольку в запросе использован псевдоним C (FROM CLIENTS C), то якобы 
существует гарантия что в предложении WHERE будут сравниваться поле C.CLIENT_ID 
из таблицы CLIENTS и поле CLIENT_ID из таблицы ORDERS (в триггере доступны имена 
полей собственной таблицы). На самом деле даже использование псевдонимов не дает 
гарантии что переменные будут разичаться, и получается что в предложении WHERE 
сравнивается само с собой поле таблицы CLIENTS.CLIENT_ID, и в запросе 
возвращается ВСЯ таблица CLIENTS. 
<P>Вот почему возникает вышеупомянутое сообщение об ошибке. 
<P>Избавиться от него можно несколькими путями: </P>
<LI>Использовать разные имена полей для связи между CLIENTS и ORDERS. например 
OCLIENT_ID и CCLIENT_ID. 
<LI>Использовать уточнитель new.CLIENT_ID, несмотря на то что в документации 
указано что для триггеров последействия (AFTER) он не имеет смысла. <BR>
<P>SELECT C.CLIENT_ID, C.CLIENT_NAME <BR>FROM CLIENTS C <BR>WHERE C.CLIENT_ID = 
new.CLIENT_ID <BR>... </P>
<LI>Перед запросом поместить CLIENT_ID в локальную переменную, и в запросе 
использовать сравнение не с полем, а с этой локальной&nbsp; переменной. <BR>
<P>CID=CLIENT_ID; <BR>SELECT C.CLIENT_ID, C.CLIENT_NAME <BR>FROM CLIENTS C 
<BR>WHERE C.CLIENT_ID = :CID <BR>... 
<P><A name=1.52></A><B>1.52 Что такое "метаданные" ?</B> 
<P>Метаданные - это информация о таблицах пользователя, триггерах, процедурах, 
связях между таблицами, индексах, и т.п. 
<P><A name=1.53></A><B>1.53 Где Borland IB хранит информацию о метаданных ?</B> 
<P>IB хранит информацию о метаданных в таблицах, имена которых начинаются с 
RDB$. Например, информация о связях между таблицами находится в таблице 
RDB$RELATIONS. Список системных таблиц и их назначение вы можете посмотреть в 
книге Borland IB Language Reference (или IBLR.PDF в электронном виде. находится 
в каталоге \MANUALS дистрибутива Delphi 1.0.x) 
<P>! Не рекомендуется вносить изменения напрямую в системные таблицы, этим можно 
испортить БД. При необходимости изменения системных таблиц вы должны 
руководствоваться IB Language Reference ! 
<P><A name=1.54></A><B>1.54 Почему невозможно использовать домены (DOMAIN) в 
хранимых процедурах ?</B> 
<P>Отвечает один из разработчиков IB David Schnepper: 
<P>"Потому что мы не стали реализовывать это. Попробую вспомнить причины, хотя 
это было около 4-х лет назад: </P>
<LI>достаточно трудно осуществлять domain validation в параметрах ввода/вывода 
SP (например define domain age smallint check (age &gt;=0 and age &lt;=150);) 
<LI>также трудно обеспечивать изменение доменов-параметров SP при модификации 
домена. (например, используем AGE в SP, затем даем команду alter domain age 
float. С другой стороны, в реализации SQL в IB нет возможности модифицировать 
домен, но это возможно операторами GDML). Такое изменение домена приведет к 
необходимости перекомпиляции SP, а в любой момент времени нельзя гарантировать 
что SP не используется в момент изменения домена. 
<LI>в настоящее время стандарт "draft SQL PSM", на котором базируется наша 
реализация SP, не разрешает использовать домены в SP. Кроме того, я не в курсе 
текущей ситуации со этим стандартом. 
<P>Безусловно, ни один из этих пунктов не облегчит вам жизнь, но хотя-бы даст 
понимание почему данная возможность не реализована в IB 4.0, 4.1, 4.2". 
<P><A name=1.55></A><B>1.55 После удаления хранимой процедуры невозможно удалить 
таблицы, использовавшиеся в этой процедуре.</B> 
<P>После drop procedure нужно выдать commit, и только после этого делать drop 
table. В крайнем случае нужно убедиться, что процедура действительно удалена, и 
удалить запись с ее именем в таблице RDB$DEPENDENCIES. Этот баг исправлен в IB 
5.x. 
<P><A name=1.56></A><B>1.56 Как получить QUERY PLAN при работе с IB API ?</B> 
<P>Нужно использовать функцию isc_dsql_sql_info(), запросив данные 
isc_info_sql_getplan. К сожалению, пользоваться этой функцией для запросов, 
выдаваемых через BDE невозможно, т.к. она требует предварительного вызова 
isc_dsql_prepare, которая в свою очередь использует native transaction handle 
(недоступный в BDE). 
<P><A name=1.57></A><B>1.57 Мне нужны временные таблицы, но их нет в IB. Что 
делать ?</B> 
<P>IB не расчитан на частое изменение метаданных, поэтому создание таблицы на 
ходу и ее удаление не является хорошим приемом. Вместо временной таблицы вы 
можете создать постоянную таблицу для тех-же целей с первым полем равным USER (и 
входящим в первичный ключ). В этом случае даже если несколько пользователей 
начнут добавлять записи в такую таблицу, конфликта между ними не будет. Вместо 
USER можно использовать генератор (generator), который будет действовать на все 
время работы пользователя. Тогда если ваше приложение не использует регистрацию 
IB, и все USER одинаковы, генераторы предотвратят конфликт между пользователями. 

<P><A name=1.58></A><B>1.58 Что такое "глубина индекса" (index depth), 
показываемая в Database Analysis?</B> 
<P>"Глубина индекса" это то-же что и глубина B-дерева. Если вам незнаком этот 
термин, то следует обратиться к соответствующей литературе. Вообще глубиной 
индекса определяется скорость поиска в индексе - т.е. именно столько страниц 
придется прочитать IB чтобы найти указатель на нужную запись (при поисках типа 
WHERE, но не ORDER BY). Естественно, что чем меньше глубина индекса тем лучше. 
Оптимальной считается 3. 
<P>Если при просмотре в Database Analysis (или GSTAT) глубина какого-то индекса 
окажется 4 или выше, то его необходимо деактивировать и активировать обратно 
(т.е. перестроить - set index inactive/active). Это не всегда может помочь, т.к. 
на глубину индекса в первую очередь влияет длина ключа и количество записей в 
таблице. 
<P>Кроме того, при анализе заполнения индексных страниц (fill distribution) 
нужно учитывать, что IB заполняет страницы в среднем наполовину для оптимизации 
изменений индексов (или данных) транзакциями. Т.е. заполнение страниц 40-59% 
можно считать нормальным. 
<P>Вообще упаковка (пересоздание) индексов считается эффективной только для 
таблиц, в которых записи изменяются нечасто. 
<P><A name=1.59></A><B>1.59</B> <B>Как часто нужно делать Database Sweep ?</B> 
<P>БД имеет по умолчанию параметр начала Sweep в 20000 транзакций. Это может 
показаться большим, но для реальных приложений 20000 транзакций - именно то 
число, когда в БД скапливается достаточно "мусора". 
<P>Количество "мусора" в БД определяется тем, насколько часто происходят 
вставки, изменения и удаления. Версии записей удаляются только тогда, когда они 
не нужны старейшей активной транзакции (OAT). 
<P>Вообще "sweep interval" - это разница между OAT и OIT (старейшей активной и 
старейшей заинтересованной транзакцией), при котором необходимо делать sweep. 
Если номер OIT увеличивается также, как и OAT, автоматический sweep может и не 
наступить. Одной из наиболее вероятных причин увеличения номера OIT является 
завершение транзакции операцией ROLLBACK. 
<P>При выполнении Sweep освободившиеся страницы не возвращаются операционной 
системе - они будут использоваться IB как свободные страницы. 
<P>Если вы хотите самостоятельно и регулярно делать Sweep, то можно это делать, 
например в ночное время когда нет работающих пользователей, при помощи утилиты 
GFIX. Кроме того, выключить автоматический sweep можно установив "sweep 
interval" = 0. 
<P><I>примечание</I>: следить за OAT-OIT можно периодически получая статистику 
по конкретной БД при помощи Server Manager (или утилиты GSTAT). 
<P><I>примечание</I>: например если вы вставите в таблицу 1000000 (миллион) 
записей, завершая вставку каждой операцией commit, то автоматический sweep 
запущен не будет (OAT-OIT постоянно и очень мало). Однако так поступать тоже не 
стоит, т.к. вставка будет происходить очень медленно - лучше всего в одной 
транзакции вставлять 100-200 записей. 
<P><I>примечание</I>: в IB 5.5 есть баг, который приводит к падению сервера при 
SWEEP, если в базе данных есть индексы по полям, возможно содержащим значения 
NULL. В этом случае необходимо отключить автоматический SWEEP (установить в 0), 
а операцию backup производить с установленным флагом Disable garbage collection. 
Данный баг исправлен в IB 5.6. 
<P><A name=1.60></A><B>1.60 Запрос с вычислением максимального (MAX) значения 
работает медленно.</B> 
<P>Да, к сожалению оптимизатор IB 4.x не использовал индексы при вычислении MAX, 
даже если специально указать условие выбора или сортировки по полю, имеющему 
индекс. А для IB 5.x индексы могут быть использованы как однонаправленные - ASC 
индекс для функции MIN, и DESC индекс для функции MAX. 
<P>Тем не менее, проблему можно решить следующим способом: 
<P>Создать индекс по убыванию (DESC) по полю, которое используется в MAX. Если 
вы работаете из Delphi, то нужно выполнить следующий запрос 
<P>SELECT FIELD FROM TABLE ORDER BY FIELD DESC 
<P>В этом случае запрос отработает мгновенно, и достаточно будет получить с 
сервера первую запись - она и будет содержать максимальное значение нужного 
поля. 
<P>Однако если вы попытаетесь выдать такой запрос например в WISQL или ISQL, то 
кроме выполнения запроса будут получены еще и все записи, что может занять 
достаточно длительное время. В этом случае нужно создать хранимую процедуру, 
возвращающую результат такого запроса (FOR SELECT ...). WISQL не выбирает все 
записи из хранимой процедуры, а только первую. Ею и окажется нужная вам запись. 
Эту-же хранимую процедуру можно использовать и из Delphi (StoredProc1.ExecProc) 
не прибегая к помощи компонента TQuery. 
<P>примечание: не стоит использовать MAX для генерации уникальных 
идентификаторов - вместо этого лучше использовать <A 
href="generator.shtml">механизм генераторов</A>. 
<P><A name=1.61></A><B>1.61 Можно-ли использовать stored procedures во view</B> 
<P>Вообще это нарушает правила построения VIEW, т.к. VIEW должны основываться на 
таблицах, и возвращать записи в их естественном порядке (так как они хранятся в 
таблицах). В хранимой процедуре возможна выдача как "псевдотаблиц" (вычисляемые 
значения) так и записей таблиц в отличном от естественного порядке (FOR SELECT с 
ORDER BY). 
<P>Кроме этого, view по умолчанию предполагается редактируемым, а хранимые 
процедуры как правило не обеспечивают редактирование возвращаемых ими наборов 
данных. 
<P>К сожалению, в IB отсутствует контроль за использованием SP во view поэтому 
для версии 4.1 такое view создать просто невозможно (GPF), а в версии 4.2 такое 
view не работает (GPF при SELECT * FROM MYVIEW). 
<P><A name=1.62></A><B>1.62 Ошибка "low volume of metadata change" или Как часто 
можно менять метаданные (например изменять структуру таблиц)?</B> 
<P>существует ограничение на 255 модификаций метаданных между backup/restore. 
Например 
<P>create table changes_a_lot (a smallint); /* версия 0 */ <BR>alter table 
changes_a_lot add b smallint; /* версия 1 */ <BR>... <BR>alter table 
changes_a_lot drop b; /* версия 254 */ <BR>alter table changes_a_lot add 
constraint ... /* ой! версия 255 ! */ 
<P>Кроме этого счетчик метаданных таблицы увеличивается при каждой модификации 
триггера этой таблицы, в том числе и при ACTIVE/INACTIVE триггера. 
<P>Вообще метаданные изменяются нечасто если ваша БД находится в промышленном 
использовании, а не на стадии разработки. <BR>Так что если вы получили подобное 
сообщение об ошибке - сделайте backup и restore вашей БД, и продолжайте 
работать. 
<P><A name=1.63></A><B>1.63 Многоверсионность метаданных, или как поддерживается 
модификация структур таблиц.</B> 

<P><A name=1.64></A><B>1.64 Почему рекомендуется периодически делать 
backup/restore ?</B> 
<P>Вообще, backup предназначен для резервирования данных на случай сбоя системы. 
Кроме того, backup/restore делает несколько полезных вещей: </P>
<LI>сбрасывает счетчики версий метаданных 
<LI>перепаковывает записи на страницах данных 
<LI>убирает старые версии записей (как sweep) 
<LI>перестраивает индексы 
<LI>возвращает дисковое пространство операционной системе 
<LI>очищает "дыры" в многофайловой БД 
<LI>при восстановлении можно изменить размер страницы. 
<P><A name=1.65></A><B>1.65 Как работает многоверсионность записей ?</B> 
<P>Многоверсионность записей работает следующим образом: </P>
<LI><B>при удалении</B> запись помечается на удаление, и может быть удалена 
только после commit этой транзакции. Если транзакции repeatableread, видящие 
такую запись, все еще активны, то запись остается "неудаленной" до тех пор пока 
они не завершатся. Когда в записи никто не заинтересован, она помечается на 
окончательное удаление и будет физически удалена либо при database sweep, либо 
при старте другой транзакции (и запроса) которая могла-бы прочитать эту запись. 
<LI><B>при вставке</B> записи, запись не видна до тех пор пока вставившая ее 
транзакция не будет завершена. Если в данный момент активны транзакции 
repeatableread, то они не увидят такую запись даже если был сделан commit для 
вставляемой записи, поскольку их transaction id меньше чем у транзакции, 
вставившей запись. 
<LI><B>при изменении</B> записи, пока транзакция не закончена, на свободное 
место страницы данных записываются только измененные поля (delta). Транзакция, 
изменившая запись, вынуждена производить "сборку" записи из старых и новых 
значений чтобы увидеть актуальные данные. Другие транзакции будут видеть старые 
версии записей, поэтому блокировок по чтению не возникает. Delta не может 
превышать 256 байт,&nbsp; кроме этого изменения полей blob не сохраняются как 
delta, т.к. в записи хранится не содержимое blob а его идентификатор (изменения 
blob сохраняются на отдельных страницах, но не на целой странице на 1 blob, а 
сегментами). Если изменений много, то IB выделяет для их хранения&nbsp; 
дополнительные страницы данных. При большом количестве изменений "сборка" 
записей может вызвать более интенсивный обмен с диском и общее ухудшение 
производительности. 
<P>Возможна ситуация, при которой существует несколько версий одной записи, а не 
две как это кажется (старая и новая). Например транзакция 1 видит версию 1, 
транзакция 2 обновляет ее до версии 2, транзакция 3 видит версию 2, транзакция 2 
подтверждает изменения но версия 2 остается видимой для транзакции 3, транзакция 
4 обновляет запись до версии 3 и т.д. 
<P><A name=1.66></A><B>1.66 Какие блокировки обеспечивает IB ?</B> 
<P>SQL-сервер IB использует "оптимистические блокировки" на уровне записей. Это 
означает, что чтение данных никогда не блокирует их от изменений. И наоборот, 
изменение данных не приводит к их блокировке по чтению (хотя возможен режим, 
когда транзакция будет при чтении ждать завершения транзакции, изменившей 
записи). 
<P>Суть блокировок обеспечивается механизмом многоверсионности записей - запись 
блокируется от изменений транзакцией только если эта запись была изменена или 
удалена другой транзакцией. 
<P>Вообще в IB блокировки в общепринятом смысле отсутствуют. При изменении 
записи проверяется, есть-ли у этой записи указатель на старую версию записи, и 
совпадает-ли идентификатор текущей транзакции с идентификатором транзакции, 
изменившей запись. Если такой указатель есть - считается что в этот момент 
кто-то другой уже изменил запись, но не подтвердил ее изменения, и только в этом 
случае запись считается "заблокированной" от изменений. 
<P><A name=1.67></A><B>1.67 Существуют-ли в IB блокировки по чтению ?</B> 
<P>Нет. Невозможно заблокировать запись чтением, и невозможно заблокировать 
запись от чтения. Запись можно блокировать от изменения или удаления только 
заблаговременным обновлением. Т.е. чтобы никто другой не мог сделать UPDATE 
записи, вы должны тоже выдать UPDATE этой-же записи ("холостой" UPDATE). 
<P>Есть только один случай, когда при чтении обновленной записи IB выдает 
deadlock - если ваша транзакция стартовала с параметрами 
<P>SET TRANSACTION READ WRITE NO WAIT READ COMMITTED NO RECORD_VERSION. 
<P>Такая транзакция не будет иметь возможности читать старые версии записей, 
если есть новые версии этих записей (режим NO RECORD_VERSION). <BR>Этот уровень 
изоляции ошибочно использовался в BDE вплоть до версии 4.01. В 4.01 и выше 
транзакция ReadCommitted имеет параметр RECORD_VERSION. Подробнее об этом см. <A 
href="deadlocks.shtml">статью</A>. 
<P><A name=1.68></A><B>1.68 Какие уровни изоляции поддерживает IB ?</B> 
<P>Для начала заметим, что режим Dirty Read (чтение неподтвержденных записей) IB 
не поддерживает. Т.е. такая ситуация в механизме многоверсионности&nbsp; записей 
просто невозможна. 
<P>Поддерживаемые уровни: </P>
<LI><B>Read Committed</B> - чтение подтвержденных записей, то-же самое что и 
"невоспроизводимое чтение". 
<LI><B>Repeatable Read</B>- воспроизводимое чтение (snapshot). Видны только те 
версии записей, которые существовали на момент начала такой транзакции. Внутри 
такой транзакции разрешено не только чтение, но и вставка/удаление/модификация 
записей. 
<LI><B>SNAPSHOT TABLE STABILITY</B> - snapshot с резервированием таблиц. Таблицы 
могут быть заблокированы от изменения, но никогда - от чтения. (В Delphi этот 
режим включить невозможно, т.к. BDE не может управлять параметрами транзакций 
любого SQL-сервера. Через IB API - возможно) 
<P><I>примечание</I>: у транзакций IB есть большое количество дополнительных 
параметров, которые можно изменять только через IB API. При работе из BDE 
используются умолчательные значения этих параметров. Более подробно см. IB API 
Guide.<BR><I>примечание</I>: в BDE 5.01 (www.borland.com/devsupport/bde) для IB 
появилась поддержка режима WAIT/NO WAIT и COMMIT/COMMIT RETAIN через параметры 
алиаса. 
<P><A name=1.69></A><B>1.69 С какими транзакциями работают BDE, WISQL ... ?</B> 
<P>BDE как универсальный интерфейс доступа к данным работает с тремя типами 
транзакций - DirtyRead, ReadCommitted, RepeatableRead. Вместо DirtyRead для IB 
используется ReadCommitted. 
<P>Вы можете стартовать любую из этих транзакций из Delphi, установив нужный 
уровень изоляции в свойстве TDatabase.Transisolation и вызвав метод 
TDatabase.StartTransaction. 
<P>Если вы не управляете началом транзакции самостоятельно, то независимо от 
установленного уровня изоляции в TDatabase.TransIsolation BDE автоматически 
подтверждает любые изменения данных следующими транзакциями: 
<P><B>Delphi 1.0, версия BDE &lt;= 2.5 RepeatableRead</B> 
<P><B>Delphi 2.0, версия BDE = 3.x ReadCommitted</B> 
<P><B>Delphi 3.0, версия BDE &gt;= 4.0 RepeatableRead</B> 
<P>Для того чтобы изменить транзакцию по умолчанию (ReadCommitted) для BDE =3.x 
на RepeatableRead, вы должны изменить при помощи BDECFG значение параметра 
DRIVER FLAGS с пустого на 512 (см. справку BDECFG либо READLINK.TXT). <BR>В BDE 
версии 4.0 и выше для IB можно при помощи флагов управлять не только типом 
транзакции, но и способом ее завершения по умолчанию (COMMIT или COMMIT RETAIN), 
что позволяет избежать автоматического перечитывания записей при COMMIT в режиме 
BDE SHARED AUTOCOMMIT. Более подробно см. READLINK.TXT из поставки Delphi 3.0 
C/S, или BDEREADME.TXT из BDE 5.01 update. 
<P>WISQL по умолчанию стартует транзакцию SET TRANSACTION SNAPSHOT, т.е. 
RepeatableRead. В WISQL вы можете стартовать любую транзакцию IB (см. SET 
TRANSACTION в HELP или документации). 
<P><A name=1.70></A><B>1.70 Можно-ли управлять параметрами транзакций IB из BDE 
?</B> 
<P>К сожалению, нет. Нет способа получить из BDE native transaction handle для 
IB, поэтому изменить характеристики транзакции IB или стартовать свою транзакцию 
через BDE невозможно. 
<P>Компоненты прямого доступа FIBC, IBX, IBObjects могут устанавливать любые 
параметры транзакций, осуществлять двухфазный коммит и открывать любое 
количество транзакций в одном соединении. 
<P><A name=1.71></A><B>1.71 Что такое BLR ?</B> 
<P>Binary Language Representation. В таком виде хранятся и исполняются в IB 
триггеры, хранимые процедуры, контроль полей и prepared queries. 
<P>Может-быть кому-то покажется странным, но язык SQL не является 
интерпретируемым. Например, имена полей в операторе SELECT могут быть обработаны 
только после разбора имен таблиц, участвующих в этом SELECT. 
<P><A name=1.72></A><B>1.72 Что такое UDF ?</B> 
<P>User Defined Functions - функции, определяемые пользователем. Вы можете на C 
или C++ (для любой платформы) или на Delphi 2.0 (для Windows NT) написать 
собственные функции и расширить таким образом функциональность IB. 
<P>(исключением является IB for NetWare, т.к. для написания UDF пользователю 
пришлось-бы писать NLM. Кроме того, некорректная работа такого NLM могла-бы 
повлечь за собой "падение" сервера NetWare.) 
<P>Существуют как свободно распространяемые библиотеки UDF, так и коммерческие 
(от MER Systems, более 100 функций). 
<P>ДемоЦентр предлагает вам собственный бесплатный набор UDF, который больше 
представляет собой подробнейший "учебник" для написания собственных UDF на 
Delphi 2.0. Безусловно в этом наборе вы найдете множество полезных функций, 
таких как работа с датами, строками, varchar, поиск подстроки в BLOB и т.п. 
<P>Также весьма популярна бесплатная библиотека FreeUDFLib, содержащая большое 
количество функций в исходных текстах (Delphi). <BR>см. раздел UDF в "<A 
href="../../../ib.demo.ru/download.htm">Файлах и утилитах</A>". 
<P><A name=1.73></A><B>1.73 Не восстанавливаются (restore) процедуры (sp) с 
QUERY PLAN. Что делать ?</B> 
<P>Это действительно ошибка в GBAK. Исправлено в IB 5.0. 
<P>Тем кто продолжает работать на версиях 4.x, можно предложить следующее 
решение: <BR>перед backup выполнить скрипт, который заменит проблемные процедуры 
на пустые <BR>alter procedure xxx as begin suspend; end^ <BR>... <BR>А после 
restore выполнить скрипт, восстанавливающий текст процедур. 
<P><A name=1.74></A><B>1.74 Почему Server Manager не показывает Database 
Connections на WinNT ?</B> 
<P>Этот пункт меню "платформо-зависимый". Для NetWare и Local IB он разрешен, а 
для IB 4.0, 4.1 for NT - запрещен. 
<P>Для IB 4.2 и 5.0 for NT этот пункт разрешен, поскольку с версии 4.2 IB имеет 
архитектуру SuperServer. 
<P><I>примечание</I>: версия IB 5.1 for RH Linux 5.2 имеет архитектуру Classic, 
и не позволяет просматривать количество активных соединений. 
<P><A name=1.75></A><B>1.75 Что такое архитектура SuperServer ?</B> 
<P>Исторически сложилось так, что первоначально SQL-серверы работали в 
архитектуре, когда подсоединение нового пользователя вызывало создание нового 
процесса SQL-сервера, работающего в отдельном адресном пространстве. Такие 
процессы могли общаться друг с другом только через Shared Memory или похожие 
механизмы. 
<P>Постепенно большинство производителей SQL-серверов пришли к выводу, что такая 
архитектура устарела, и перешли на новую - SuperServer. Это громкое слово 
всего-лишь означает, что на каждого пользователя создается новый поток (thread) 
вместо процесса. Таким образом потоками можно управлять в одном адресном 
пространстве, можно оптимизировать кэширование считываемых разными потоками 
данных, и т.д. Однако понятно, что такая архитектура менее устойчива к сбоям 
отдельных потоков (это относится ко всем реализациям данной архитектуры). 
<P>IB соответствует архитектуре SuperServer с версии 4.2, 5.x для Windows95/NT, 
5.x для Solaris и HP-UX, 5.6 для SCO. 
<P>На NetWare архитектура SuperServer была всегда. 
<P><A name=1.76></A><B>1.76 Соответствует-ли реализация SQL в IB стандарту ANSI 
и какому ?</B> 
<P>Реализация SQL в IB соответствует entry level ANSI SQL-92. Это означает, что 
все возможности, заявленные в entry level, реализованы в IB. Также в IB 
реализованы некоторые возможности более высокого уровня (например домены), но 
для соответствия intermediate или full level требуется полная реализация 
соответствующего уровня, чего пока нет не только в IB, но и практически в любых 
других SQL-серверах. 
<P><A name=1.77></A><B>1.77 Можно-ли поместить GDB-файл на другой компьютер 
?</B> 
<P>Это возможно только для 16-разрядного Local IB. Для 32-разрядных версий IB 
это невозможно. Даже если-бы это и было возможно, то надежность такой системы 
была-бы весьма низка. Вообще возможность помещать GDB на файл-сервер была 
специально отключена для того, чтобы исключить возможность доступа к одному-и 
тому-же GDB с разных станций, использующих Local IB или с других операционных 
систем. IB, как и любой другой SQL-сервер, может обеспечивать корректную работу 
с БД только как сервер (т.е. самостоятельно предоставляя конкурентный доступ к 
БД нескольким пользователям одновременно), а не в режиме разделения файла в 
сети. 
<P><A name=1.78></A><B>1.78 В чем разница между OAT и OIT ? (старейшей активной 
и старейшей заинтересованной транзакцией).</B> 
<P>Контроль конкурентного доступа в IB базируется не на основе блокировок 
записей или страниц, а на версиях записей. Во-первых, каждая транзакция получает 
при своем старте последовательный номер (идентификатор транзакции). Во-вторых, 
каждая запись имеет идентификатор создавшей ее транзакции, и иногда указатель на 
предыдущую версию записи. 
<P>Базовая идея состоит в том, что ядро IB старается обеспечить каждой 
транзакции "вид" целостной БД начиная от момента старта этой транзакции. Для 
этого, ядро определяет состояние версии записи для транзакции, выбирающей 
записи. Если запись была создана транзакцией, завершенной перед стартовавшей 
транзакцией, то такая транзакция увидит эту запись. Если запись была создана 
отмененной транзакцией (rolled back), то запись будет "очищена" (перезаписана 
другой версией или удалена со страницы данных). Если запись была создана 
транзакцией, которая все еще активна на момент старта выбирающей записи 
транзакции, то ядро IB использует указатель на "старую" запись, либо игнорирует 
запись полностью (при отсутствии "старой" версии). 
<P>В файле БД существует набор страниц, называемых Transaction Inventory Pages 
(TIP), в которых хранится информация о всех стартовавших транзакциях. Каждая 
транзакция может находиться в четырех состояниях: activ (активная, committed 
(подтвержденная), rolled back (отмененная), in limbo ("зависшая" между фазами 
при двухфазном подтверждении транзакций - two phase commit). 
<P>Состояние транзакций может быть изменено автоматически записью в 
соответствующую страницу TIP. 
<P>Для отслеживания состояний взаимосвязанных транзакций, каждая транзакция 
должна знать состояние других транзакций на момент своего старта. Эта информация 
может быть получена копированием страниц TIP во внутренний блок транзакции. 
Поскольку номер транзакции постоянно увеличивается, увеличивается и размер 
внутреннего блока транзакции и количество прочитываемых страниц TIP, что 
приводит к увеличению "стоимости" старта транзакции. 
<P>Для контроля "стоимости" старта транзакции, IB имеет концепцию 
"заинтересованной" (interesting) и "скучающей" (boring) транзакций. Boring 
транзакция - это либо подтвержденная либо полностью завершенная транзакция. 
Заинтересованная транзакция - либо активная либо "зависшая". Поэтому для 
стартовавшей транзакции нет необходимости знать состояние всех транзакций в БД, 
а только те, которые были (или еще есть) после "старейшей заинтересованной" 
транзакции. 
<P><I>Sweeping - это "домашняя уборка", которая трансформирует "погибшую" но 
заинтересованную транзакцию в "скучающую" транзакцию.</I> 
<P>Вообще процесс sweep - ничего более последовательного сканирования всех 
таблиц БД. Поскольку обнаружение "мертвой" версии записи приведет к "сбору 
мусора", sweep превращает все "старейшие заинтересованные транзакции в 
"скучающие" транзакции, снижая стоимость старта новой транзакции. Sweep никого 
не блокирует и требует очень мало ресурсов. 
<P>Итак sweep - не такое уж большое дело. В большинстве СУБД процесс sweep 
делает очень малую "сборку мусора", т.к. в них отсутствует подобная IB 
многоверсионность записей. В нашем случае sweep подтверждает что весь мусор 
собран и транзакции переведены в состояние "скучающих". Кроме того, для хранения 
состояния транзакции используется два бита (четыре состояния), поэтому 
затягивание со sweep не очень сильно влияет на производительность. 
<P>Проблемы со sweep в общем относятся к не процессу sweep, а к тому что кто-то 
стартовал 20000 транзакций. Старт одной транзакции имеет среднюю стоимость 
(запись на диск, сканирование TIP, создание собственного блока и блокирование 
его lock manager-ом), но старт и подтверждение 20000 транзакций - очень высокую 
стоимость. 
<P>Если вы собираетесь добавить в таблицу 20000 записей, лучше это делать в 
одной транзакции нежели в 20000 отдельных. 
<P><I>примечание: максимально подробное описание этого вопроса вы найдете в <A 
href="oitoat.shtml">статье</A>.</I> 
<P><A name=1.79></A><B>1.79 В чем разница между CHAR и VARCHAR ? Что лучше 
использовать ?</B> 
<P>Разработчики утверждают, что разницы практически нет - особенности VARCHAR в 
том, что используется дополнительно два байта для хранения длины, а CHAR 
игнорирует пробелы в конце хранимой строки. 
<P>Если вы собираетесь хранить строки длиной не более 40-50 символов, то лучше 
использовать CHAR. (Особенности строковых типов данных
Давайте сначала повторим описание этих типов данных из документации (Data Definition Guide): 
CHAR(n) - n символов, от 1 до 32767, строковый тип фиксированной длины. Если содержимое поля меньше указанного размера, то оно "выравнивается" дополнительными пробелами. 
VARCHAR(n) - n символов, от 1 до 32767, строковый тип переменной длины. Пробелы в конце содержимого поля игнорируются). 
<P><I>При передаче по сети в текущих версиях IB VARCHAR передается так-же как и 
CHAR (т.е. неэффективно). Исправлено в IB 5.0.</I> 
<P><A name=1.80></A><B>1.80 Можно-ли поместить БД IB на CD-ROM ?</B> 
<P>В IB 4.x и 5.x база данных должна быть всегда доступна на запись, т.к. даже 
простая выборка (чтение) из БД стартует транзакцию, а информация о транзакции 
должна быть записана в БД. 
<P>Возможность работать с read-only базами данных, а следовательно и помещать их 
на CD-ROM, появится только в IB 6.0. 
<P><A name=1.81></A><B>1.81 Как выполнить create procedure/trigger при помощи 
TQuery?</B> 
<P>Для этого у TQuery нужно установить property ParamCheck:=False. При этом 
текст запроса не будет проверяться на наличие параметров, которые предваряются 
двоеточием (:). Никаких других изменений не требуется. 
<P><A name=1.82></A><B>1.82 Как установить генератор в нужное значение в 
процедуре или триггере?</B> 
<P>Действительно, оператор SET GENERATOR... является оператором DDL, а операторы 
DDL не допускаются в триггерах или процедурах. Установить значение генератора в 
нужное можно очень простым способом (например в 0):<BR>...<BR>TMP=GEN_ID(MYGEN, 
-GEN_ID(MY_GEN, 0));<BR>... 
<P>Т.е. увеличить значение генератора на его текущее отрицательное значение. 
<P><A name=1.83></A><B>1.83 Не могу подсоединиться к IB из под web-сервера IIS, 
Netscape, Baikonur и др.</B> 
<P>Если вы обращаетесь к IB из IIS, Baikonur и т.п. Web-серверов, то нужно 
использовать строку коннекта как для удаленного сервера, т.к. локальное 
подсоединение работать не будет. Например, 'server:c:\dir\data.gdb' или 
'\\server\c:\data.gdb'. 
<P><B><A name=1.84></A>1.84 Ошибка при установке "Internal error near 
IBcheck"</B> 
<P>Эта ошибка вызвана порчей ключа registry инсталлятором Delphi 4. Исправить ее 
можно, запустив RegEdit и проверив ключ HK_CURRENT_USER/Environment. Значение 
PATH должно быть строкового типа. Если это не так, то PATH надо поменять (или 
пересоздать) на строковое значение. 

</TD></TR></TABLE>
</TD></TR>
<TR BGCOLOR=#6699CC><TD><TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD BGCOLOR=#6699CC VALIGN=CENTER HEIGHT = 40><FONT SIZE=-10>
<!-- begin of Rambler's Top100 code -->
<img src="../../../counter.rambler.ru/top100.cnt@236431" alt="" width="1" height="1" border="0" />
<!--end of Top100 code-->
<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=0 BORDER=0 CLASS="tableborder"><TR BGCOLOR="#6699CC"><TD>
<!-- begin of Top100 logo -->
<a href="../../../top100.rambler.ru/home@id=236431">
<img src="../../../top100-images.rambler.ru/top100/banner-88x31-rambler-gray2.gif" alt="Rambler's Top100"
width="88" height="31" border="0" /></a>
<!-- end of Top100 logo -->
</FONT>
<!--Rating@Mail.ru COUNTER--><a target=_top
href="../../../top.mail.ru/jump@from=58574"><img
src="../../../top.list.ru/counter@id=58574;t=94"
border=0 height=18 width=88
alt="Рейтинг@Mail.ru"></a><!--/COUNTER-->
<!-- Yandex.Metrika counter --><!--ipt type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter9237463 = new Ya.Metrika({id:9237463, trackLinks:true, accurateTrackBounce:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</scri--><noscript><div><img src="../../../https@mc.yandex.ru/watch/9237463" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter -->
</TD>
<TD BGCOLOR=#6699CC ALIGN=right><FONT COLOR=white FACE="Tahoma,Arial" SIZE=1>&nbsp;Administrator:&nbsp;<A STYLE="color :white" HREF="../../../www.sql.ru/feedback.aspx">Обратная связь</A>&nbsp;<BR>Copyright: <FONT COLOR=white>SQL.Ru  2000-2013&nbsp;</FONT></FONT></TD></TR></TABLE>
</TD></TR></TABLE></TD></TR></TABLE>

</BODY></HTML>

