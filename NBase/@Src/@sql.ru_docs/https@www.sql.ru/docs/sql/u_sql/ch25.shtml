<HTML>
<HEAD>
<TITLE>Понимание SQL. Глава 25. Использование SQL с другим языком ( вложенный SQL ). [SQL.RU]</TITLE>
<META http-equiv="Content-Type" CONTENT="text/html; charset=windows-1251">
<META HTTP-EQUIV="Window-target" CONTENT="_top">
<META HTTP-EQUIV="Last-Modified" CONTENT="29-03-2001">
<META NAME="Description" CONTENT="Использование языка SQL, создание клиент-серверных систем. Конференция по MSSQL, Oracle, Interbase, MySQL. Полезные ссылки, документация, рекомендации по разработке информационных систем, сертификация, заказ книг и многое другое.">
<META NAME="Keywords" CONTENT="SQL, конференция, Database Server, Oracle, Interbase, MySQL, документация, статьи, примеры, книги, ссылки, сертификация, работа, СУБД">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../../../form.css">
</HEAD>
<BODY BGCOLOR="#FFFFFF" leftmargin="3" topmargin="3" marginheight="3" marginwidth="3">
<noindex>
<TABLE BGCOLOR="#000000" WIDTH=100% CELLPADDING=0 CELLSPACING=0 BORDER=0>
<TR><TD>

<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=1 BORDER=0>
<TR BGCOLOR="#6699CC"><TD><TABLE CELLSPACING=0 CELLPADDING=0 WIDTH=100% BORDER=0 BGCOLOR="#6699CC">
<TR><TD COLSPAN=3><IMG SRC="../../../images/blank.gif" height=3 width=1 alt=""></TD></TR>
<TR><TD VALIGN=TOP>&nbsp;<FONT FACE="Verdana,Arial" SIZE=5 COLOR=lightyellow>SQL.RU<BR><FONT SIZE=-5>&nbsp;client/server technologies</FONT></FONT></TD>
<TD WIDTH=468 HEIGHT=60 BGCOLOR=#6699CC ALIGN=RIGHT></TD>
<TD WIDTH=2><IMG SRC="../../../images/blank.gif" height=1 width=2 alt=""></TD></TR>                                                      	
<TR HEIGHT=4><TD COLSPAN=3><IMG SRC="../../../images/blank.gif" height=5 width=1 alt=""></TD></TR></TABLE>

</TD></TR>

<TR HEIGHT=15><TD bgcolor=#006699><FONT FACE="Verdana,Arial" SIZE=1 COLOR=WHITE><B><A CLASS="menu" 
HREF="../../../default.htm">&nbsp;<FONT COLOR=white>Главная</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../../docs">&nbsp;<FONT COLOR=yellow>Документация</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../../articles">&nbsp;<FONT COLOR=white>Статьи</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../../books">&nbsp;<FONT COLOR=white>Книги</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../../forum/actualforum.aspx">&nbsp;<FONT COLOR=white>Форум</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../../blogs">&nbsp;<FONT COLOR=white>Блоги</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../../poll">&nbsp;<FONT COLOR=white>Опросы</FONT>&nbsp;</A>|<A CLASS="menu" 
HREF="../../../forum/actualtopics.aspx@bid=11">&nbsp;<FONT COLOR=white>Гостевая</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../../subscribe">&nbsp;<FONT COLOR=white>Рассылка</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../../job">&nbsp;<FONT COLOR=white>Работа</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../../search">&nbsp;<FONT COLOR=white>Поиск</FONT>&nbsp;</A>|<A CLASS="menu"
HREF="../../../faq">&nbsp;<FONT COLOR=white>FAQ</FONT>&nbsp;</A>|</B></FONT></TD></TR>
<TR><TD BGCOLOR=#F5F5F5>
</noindex>

<TABLE BORDER=0 CELLSPACING=10><TR><TD>
<CENTER>
<H2 class="headline">
25. ИСПОЛЬЗОВАНИЕ SQL С ДРУГИМ ЯЗЫКОМ ( ВЛОЖЕННЫЙ SQL )</H2></CENTER> 
В этой главе вы узнаете как sql используется 
для расширения программ написанных на других языках. Хотя непроцедурность языка SQL делает его очень мощным, в то же время это накладывает на него большое число ограничений. 
Чтобы преодолеть эти ограничения, вы можете включать SQL в программы написанные на том или другом процедурном языке( имеющем определенный алгоритм). Для наших примеров, мы выбрали Паскаль, считая что 
этот язык наиболее прост в понимании  для начинающих, и еще потому, 
что Паскаль - один из языков для которых ANSI имеет полуофициальный 
стандарт. 
 <a name="25.1"></a>
<H3>ЧТО ТАКОЕ - ВЛОЖЕНИЕ SQL</H3> 
 
Чтобы вложить SQL в другой язык, вы должны использовать пакет программ который бы обеспечивал поддержку вложения SQL в этот язык и 
конечно же, поддержку самого языка. Естественно, вы должны быть знакомы с языком который вы используете. Главным образом, вы будете использовать команды SQL для работы в таблицах базы данных, передачи 
результатов вывода в программу и получение ввода из программы в которую они вкладываются, обобщенно ссылаясь к главной программе 
( которая может или не может принимать их из диалога или посылать 
обратно в диалог пользователя и программы ). 
 <a name="25.2"></a>
<H3>ЗАЧЕМ ВКЛАДЫВАТЬ SQL?</H3> 
 
Хотя и мы потратили некоторое врем на то чтобы показать что умеет делать SQL , но если вы - опытный программист, вы вероятно отметили, что 
сам по себе, он не очень полезен при написании программ. 
Самое очевидное ограничение - это то, что в то врем как SQL может сразу выполнить пакет команды, интерактивный SQL в основном выполняет 
по одной команде в каждый момент времени. 
Типы логических конструкций типа if ... then ( "если ... то" ), for ... do 
( "для ... выполнить") и  while ... repeat( "пока ... повторять" ) - используемых для структур большинства компьютерных программ, здесь отсутствуют, так что вы не сможете принять решение - выполнять ли, как выполнять, или как долго выполнять одно действие в результате другого действия. Кроме того, интерактивный SQL не может делать многого со значениями, кроме ввода их в таблицу, размещения или распределения их с помощью запросов, и конечно вывода их на какое-то устройство. 
<BR><BR> 
Более традиционные языки, однако, сильны именно в этих областях. 
Они разработаны так чтобы программист мог начинать обработку данных, 
и основываясь на ее результатах, решать, делать ли это действие или другое, или же повторять действие до тех пока не встретится некоторое условие, создавая логические маршруты и циклы. Значения сохраняются в переменных, которые могут использоваться и изменяться с помощью любого 
числа команд. Это дает вам возможность указывать пользователям на ввод 
или вывод этих команд из файла, и возможность форматировать вывод сложными способами ( например, преобразовывать числовых данных в диаграммы ). 
Цель вложенного SQL состоит в том, чтобы объединить эти возможности, 
позволяющие вам создавать сложные процедурные программы которые 
адресуют базу данных посредством SQL - позволяя вам устранить сложные действия в таблицах на процедурном языке который не ориентирован на такую структуру данных, в тоже время поддерживая структурную 
строгость процедурного языка. 
 <a name="25.3"></a>
<H3>КАК ДЕЛАЮТСЯ ВЛОЖЕНИЯ SQL.</H3> 
 
Команды SQL помещаются в исходный текст главной программы, которой 
предшествует фраза - EXEC SQL ( EXECute SQL ). Далее устанавливаются некоторые команды которые являются специальными для вложенной 
формы SQL, и которые будут представлены в этой главе. 
  Строго говор, стандарт ANSI не поддерживает вложенный SQL как таковой. Он поддерживает понятие, называемое - модуль, который более точно, 
является вызываемым набором процедур SQL, а не вложением в другой язык. Официальное определение синтаксиса вложения SQL, будет включать 
расширение официального синтаксиса каждого языка в который может вкладываться SQL, что весьма долга и неблагодарна задача, которую ANSI 
избегает. Однако, ANSI обеспечивает четыре приложения ( не являющиеся 
частью стандарта ), которые определяют синтаксис вложения SQL для четырех языков: КОБОЛ, ПАСКАЛЬ, ФОРТРАН, и ПЛ/1. 
Язык C - также широко поддерживается как и другие языки. 
Когда вы вставляете команды SQL в текст программы написанной на друг- 
ом языке, вы должны выполнить предкомпиляцию  прежде, чем вы окончательно ее скомпилируете. 
  Программа называемая прекомпилятором ( или препроцессором ), будет 
просматривать текст вашей программы и преобразовывать команды SQL, 
в форму удобную для использования базовым языком. 
<BR><BR> 
Затем вы используете обычный транслятор чтобы преобразовывать программу из исходного текста в выполняемый код. 
  Согласно подходу к модульному языку определенному ANSI, основная программа вызывает процедуры SQL. Процедуры выбирают параметры из глав- 
ной программы, и возвращают уже обработанные значения, обратно в основную программу. Модуль может содержать любое число процедур, каждая из 
которых состоит из одиночной команды SQL. Иде в том, чтобы процедуры 
могли работать тем же самым способом что и процедуры на языке в который они были вложены( хотя модуль еще должен идентифицировать базовый 
язык из-за различий в типах данных различных языков ). 
Реализации могут удовлетворить стандарту, выполнив вложение SQL таким 
способом, как если бы модули уже были точно определены. Для этой цели 
прекомпилятор будет создавать модуль, называемый модулем доступа. Только 
один модуль, содержащий любое число процедур SQL, может существовать 
для данной программы. Размещение операторов SQL непосредственно в главном коде, происходит более просто и более практично чем непосредственно 
создание самих модулей. 
  Каждая из программ использующих вложение SQL, связана с ID доступа, 
во время ее выполнения. ID доступа, связанный с программой, должен иметь 
все привилегии чтобы выполнять операции SQL, выполняемые в программе. 
Вообще то, вложенная программа SQL регистрируется в базе данных, также 
как и пользователь, выполняющий программу. Более подробно, это определяет проектировщик, но вероятно было бы неплохо для включить в вашу программу команду CONNECT или ей подобную. 
 <a name="25.4"></a>
<H3>ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ ОСНОВНОГО ЯЗЫКА В SQL </H3> 
 
Основной способ которым SQL и части базового языка ваших программ будут  связываться друг с другом - это с помощью значений переменных. 
Естественно, что разные языки распознают различные типы данных для переменных. ANSI определяет эквиваленты SQL для четыре базовых языков - 
ПЛ/1, Паскаль, КОБОЛ, и ФОРТРАН; все это подробности описаны в 
<A href="b.shtml">Приложении B</A>. 
Эквиваленты для других языков - определяет проектировщик. 
 
  Имейте в виду, что типы, такие как DATE, не распознаются ANSI; и 
следовательно никаких эквивалентных типов данных для базовых языков, 
не существуют в стандарте ANSI. Более сложные типы данных базового 
языка, такие как матрицы, не имеют эквивалентов в SQL. 
Вы можете использовать переменные из главной программы во вложенных операторах SQL везде, где вы будете использовать выражения значений. ( SQL, используемый в этой главе, будет пониматься как  вложенный SQL, до тех пор пока это не будет оговорено особо. ) 
  Текущим значением переменной, может быть значение, используемое в 
команде. Главные переменные должны - 
<BR><BR> 
*  быть объявлеными в SQL DECLARE SESSION ( РАЗДЕЛ 
   ОБЪЯВЛЕНИЙ ) который будет описан далее. 
<BR><BR>
*  иметь совместимый тип данных с их функциями в команде SQL 
   ( например, числовой тип если он вставляется в числовое поле ) 
<BR><BR> 
*  быть назначенными значению во врем их использования в команде 
   SQL, если команда SQL самостоятельно не может сделать назначение. 
<BR><BR> 
*  предшествовать двоеточию (:) когда они упоминаются в команде SQL 
<BR><BR> 
Так как главные переменные отличаются от имен столбцов SQL наличием 
у них двоеточия, вы можете использовать переменные с теми же самыми 
именами что и ваши столбцы, если это конечно нужно. 
Предположим что вы имеете четыре переменных в вашей программе, с 
именами:  id_num, salesperson, loc, и comm. Они содержат значения 
которые вы хотите вставить в таблицу Продавцов. Вы могли бы вложить 
следующую команду SQL в вашу программу: 
<PRE> 
      EXEC SQL INSERT INTO Salespeople 
         VALUES ( :id_num, :salesperson, :loc, :comm) 
</PRE> 
Текущие значения этих переменных будут помещены в таблицу. Как вы 
можете видеть, переменна comm имеет то же самое им что и столбец в 
который это значение вкладывается. 
Обратите внимание, что точка с запятой в конце команды отсутствует. Это 
потому, что соответствующее завершение для вложенной команды SQL за- 
висит от языка для которого делается вложение. 
<BR><BR> 
Для Паскаля и PL/1, это будет точка с запятой; для КОБОЛА, слово 
END-EXEC ; и для ФОРТРАНА не будет никакого завершения. 
В других языках это зависит от реализации, и поэтому мы договоримся 
что будем использовать точку с запятой (в этой книге) всегда, чтобы не 
противоречить интерактивному SQL и  Паскалю. Паскаль завершает вложенный SQL и собственные команды одинаково - точкой с запятой. 
Способ сделать команду полностью такой как описана выше, состоит в 
том, чтобы включать ее в цикл и повторять ее, с различными значения- 
ми переменных, как например показано в следующем примере: 
<PRE> 
        while not end-ot-file (input) do 
           begin 
           readln (id_num, salesperson, loc, comm); 
           EXEC SOL INSERT INTO Salespeople 
              VALUES (:id_num, :salesperson, :loc, :comm); 
           end; 
</PRE> 
  Фрагмент программы на ПАСКАЛЕ, определяет цикл, который будет 
считывать значения из файла, сохранять их в четырех проименованных 
переменных, сохранять значения этих переменных в таблице Продавцов, 
и затем считывать следующие четыре значения, повтор этот процесс 
до тех пор пока весь входной файл не прочитается. Считается, что каждый набор значений завершается возвратом каретки ( для незнакомых 
с Паскалем, функция readln считывает вводимую информацию и пере- 
ходит на следующую строку источника этой информации). Это дает вам 
простой способ передать данные из текстового файла в реляционную структуру. 
   Конечно, вы можете сначала обработать данные любыми возможными 
способами на вашем главном языке, например для исключения всех комиссионных ниже значения .12 
<PRE> 
          while not end-ot-file (input) do 
             begin 
             readln (id_num, salesperson, loc, comm); 
             if comm &gt; = .12 then 
             EXEC SQL INSERT INTO Salespeople 
                VALUES (:id_num, :salesperson, :loc, :comm); 
             end; 
</PRE> 
Только строки которые встретят условие comm &gt;= .12 будут вставлены в 
вывод. Это показывает что можно использовать и циклы и условия как 
нормальные для главного языка.
<a name="25.5"></a>
<H3>ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ</H3> 
 
Все переменные на которые имеется ссылка в предложениях SQL, должны сначала быть объявлены в SQL DECLARE SECTION ( РАЗДЕЛе ОБЪЯВЛЕНИЙ ), использующем обычный синтаксис главного языка. Вы можете иметь любое число таких разделов в программе, и они могут размещаться где-нибудь в коде перед используемой переменной, подчиненной ограничениям определенным в соответствии с главным языком. 
Раздел объявлений должен начинать и кончаться вложенными командами 
SQL - BEGIN DECLARE SECTION ( Начало Раздела Объявлений ) 
и END DECLARE SECTION ( Конец Раздела Объявлений ), которым предшествует, как обычно EXEC SQL (Выполнить). 
  Чтобы объявить переменные используемые в предыдущем примере, вы 
можете ввести следующее: 
<PRE> 
          EXEC SQL BEGIN DECLARE SECTION; 
          Var 
             id-num:       integer; 
             Salesperson:  packed array (1 . .10) ot char; 
             loc:            packed array (1. .10) ot char; 
             comm:         real; 
          EXEC SQL END DECLARE SECTION; 
</PRE> 
Для незнакомых с ПАСКАЛем, Var - это заголовок который предшествует 
ряду объявляемых переменных, и упакованным ( или распакованным ) массивам являющимися серией фиксированных переменных значений различаемых с помощью номеров( например, третий символ loc будет loc (3) ). 
Использование точки с запятой после каждой переменной указывает на то 
что это - Паскаль, а не SQL. 
 <a name="25.6"></a>
<H3>ИЗВЛЕЧЕНИЕ ЗНАЧЕНИЙ ПЕРЕМЕННЫХ</H3> 
 
 Кроме помещения значений переменных в таблицы используя команды 
SQL, вы можете использовать SQL чтобы получать значения для этих переменных. Один из способов делать это - с помощью разновидности команды SELECT которая содержит предложение INTO. Давайте вернемся 
к нашему предыдущему примеру и переместим строку Peel из таблицы 
Продавцов в наши переменные главного языка. 
<PRE> 
             EXEC SQL SELECT snum, sname, city, comm 
               INTO :id_num, :salesperson, :loc, :comm 
               FROM Salespeople 
               WHERE snum = 1001; 
</PRE> 
Выбранные значения помещаются в переменные с упорядоченными именами указанными в предложении INTO. Разумеется, переменные с именами указанными в предложении INTO должны иметь соответствующий 
тип чтобы принять эти значения, и должна быть своя переменная для ка- 
ждого выбранного столбца. 
Если не учитывать присутствие предложения INTO, то этот запрос - похож на любой другой. Однако, предложение INTO добавляет значительное ограничение к запросу. Запрос должен извлекать не более одной строки. Если он извлекает много строк, все они не могут быть вставлены 
одновременно в одну и ту же переменную. Команда естественно потер- 
пит неудачу. По этой причине, SELECT INTO должно использоваться 
только при следующих условиях: 
<BR><BR> 
*  когда вы используете предикат проверяющий значения, которое как вы 
   знаете, могут быть уникальным, как в этом примере. Значения которые, 
   как вы знаете, могут быть уникальными - это те значения которые имеют принудительное ограничение уникальности или уникальный индекс, 
   как это говорилось в <A href="ch17.shtml">Главах 17</A> и <A href="ch18.shtml">18</A>. 
<BR><BR> 
*  когда вы используете одну или более агрегатных функций и не используете GROUP BY. 
<BR><BR> 
*  когда вы используете SELECT DISTINCT во внешнем ключе с предикатом ссылающимся на единственное значение родительского ключа 
   (обеспечивая вашей системе предписание справочной целостность), 
   как в следующем примере: 
<PRE> 
           EXEC SQL SELECT DISTINCT snum 
             INTO :salesnum 
             FROM Customers 
             WHERE snum = 
               (SELECT snum 
                   FROM Salespeople 
                   WHERE sname = 'Motika'); 
</PRE> 
Предполагалось что Salespeople.sname и Salespeople.snum - это соответственно, уникальный и первичный ключи этой таблицы, а Customers.snum 
- это внешний ключ ссылающийся на Salespeople.snum, и вы предполагали что этот запрос произведет единственную строку. 
Имеются другие случаи, когда вы можете знаете, что запрос должен про- 
извести единственную строку вывода, но они мало известны и, в большинстве случаев, вы основываетесь на том что ваши данные имеют целостность, которая не может быть предписана с помощью ограничений. Не 
полагайтесь на это! Вы создаете программу которая, вероятно, будет использоваться в течение некоторого времени, и лучше всего проиграть ее 
чтобы быть гарантированным в будущем от возможных отказов. Во всяком случае, нет необходимости группировать запросы которые производят 
одиночные строки, поскольку SELECT INTO - используется только для 
удобства. 
  Как вы увидите, вы можете использовать запросы выводящие многочисленные строки, используя курсор. 
 <a name="25.7"></a>
<H3>КУРСОР</H3> 
 
Одна из сильных качеств SQL - это способность функционировать на всех 
строках таблицы, чтобы встретить определенное условие как блок запись, 
не зная сколько таких строк там может быть. Если десять строк удовлетворяют предикату, то запрос может вывести все десять строк. Если десять 
миллионов строк определены, все десять миллионов строк будут выведены. 
Это несколько затруднительно, когда вы попробуете связать это с другими 
языками. Как вы сможете назначать вывод запроса для переменных когда 
вы не знаете как велик будет вывод ?  Решение состоит в том, чтобы использовать то, что называется - курсором. 
Вы вероятно знакомы с курсором, как с мигающей черточкой, которая отмечает вашу позицию на экране компьютера. Вы можете рассматривать 
SQL курсор как устройство, которое аналогично этому, отмечает ваше место в выводе запроса, хотя аналоги не полна. 
  Курсор - это вид переменной, которая связана с запросом. Значением этой переменной может быть каждая строка, которая выводится при запросе. 
Подобно главным переменным, курсоры должны быть объявлены прежде, 
чем они будут использованы. Это делается командой DECLARE CURSOR, 
следующим образом: 
<PRE> 
                EXEC SQL DECLARE CURSOR Londonsales FOR 
                  SELECT * 
                  FROM Salespeople 
                  WHERE city = 'London'; 
</PRE> 
Запрос не выполнится немедленно; он - только определяется. Курсор не- 
много напоминает представление, в котором курсор содержит запрос, 
а содержание курсора - напоминает любой вывод запроса, каждый раз 
когда курсор становится открытым. Однако, в отличие от базовых таблиц 
или представлений, строки курсора упорядочены: имеются первая, вторая... 
... и последняя строка курсора. Этот порядок может быть произвольным 
с явным управлением с помощью предложения ORDER BY в запросе, или 
же по умолчанию следовать какому-то упорядочению определяемому инструментально-определяемой схемой. 
Когда вы находите точку в вашей программе в которой вы хотите выполнить запрос, вы открываете курсор с помощью следующей команды: 
<PRE> 
       EXEC SQL OPEN CURSOR Londonsales; 
</PRE> 
Значения в курсоре могут быть получены, когда вы выполняете именно 
эту команду, но не предыдущую команду DECLARE и не последующую 
команду FETСH. Затем, вы используете команду FETCH чтобы извлечь 
вывод из этого запроса, по одной строке в каждый момент времени. 
<PRE> 
       EXEC SQL FETCH Londonsales INTO :id_num, 
        :salesperson, :loc, :comm; 
</PRE> 
   Это выражение переместит значения из первой выбранной строки, в 
переменные. Друга команда FETCH выводит следующий набор значений. Идея состоит в том, чтобы поместить команду FETCH внутрь цикла, 
так чтобы выбрав строку, вы могли переместив набор значений из этой 
строки в переменные, возвращались обратно в цикл чтобы переместить 
следующий набор значений в те же самые переменные. 
Например, возможно вам нужно чтобы вывод выдавался по одной строке, 
спрашивая каждый раз у пользователя, хочет ли он продолжить чтобы увидеть следующую строку 
<PRE> 
         Look_at_more:= True; 
            EXEC SQL OPEN CURSOR Londonsales; 
             while Look_at_more do 
               begin 
               EXEC SQL FETCH Londonsales 
               INTO :id_num, :Salesperson, :loc, :comm; 
               writeln (id_num, Salesperson, loc, comm); 
               writeln ('Do you want to see more data? (Y/N)'); 
               readln (response); 
               it response = 'N' then Look_at_more: = False 
               end; 
            EXEC SQL CLOSE CURSOR Londonsales; 
</PRE> 
В Паскале, знак  : = означает - " является назначенным значением из ", 
в то врем как  =  еще имеет обычное значение " равно ". Функция 
writeln записывает ее вывод, и затем переходит к новой строке. 
Одиночные кавычки вокруг символьных значений во втором writeln и в 
предложении if ... then  - обычны для Паскаля, что случается при 
дубликатах в SQL. 
   В результате этого фрагмента, Булевая переменна с именем Look_at 
_more должна быть установлена в состояние верно, открыт курсор, и 
введен цикл.  Внутри цикла, строка выбирается из курсора и выводится 
на экран. У пользователя спрашивают, хочет ли он видеть следующую 
строку. Пока он не ответил N ( Нет ), цикл повторяется, и следующая 
строка значений будет выбрана. 
  Хотя переменные Look_at_more и ответ должны быть объявлены как 
Булевая переменна и символьная(char) переменна, соответственно, в 
разделе объявлений переменных в Паскаля, они не должны быть включены в раздел объявлений SQL, потому что они не используются в командах SQL. 
  Как вы можете видеть, двоеточия перед именами переменных  не используются для не-SQL операторов. Далее обратите внимание, что имеется оператор CLOSE CURSOR соответствующий оператору OPEN 
CURSOR. Он, как вы поняли, освобождает курсор значений, поэтому 
запрос будет нужно выполнить повторно с оператором OPEN CURSOR, 
прежде чем перейти в  выбору следующих значений. 
Это необязательно для тех строк которые были выбраны запросом после закрытия курсора, хотя это и обычна процедура. 
Пока курсор закрыт, SQL не следит за тем, какие строки были выбраны. 
Если вы открываете курсор снова, запрос повторно выполняется с этой 
точки, и вы начинаете все сначала. 
Этот пример не обеспечивает автоматический выхода из цикла, когда 
все строки уже будут выбраны. Когда у FETCH нет больше строк которые надо извлекать, он просто не меняет значений в переменных предложения INTO. Следовательно, если данные исчерпались, эти переменные будут неоднократно выводиться с идентичными значениями, до тех 
пор пока пользователь не завершит цикл, введя ответ - N. 
<a name="25.8"></a>
<H3>SQL КОДЫ</H3>  
 
Хорошо было бы знать, когда данные будут исчерпаны, так чтобы можно 
было сообщить об этом пользователю и цикл завершился бы автоматически. 
Это - даже более важно чем например знать что команда SQL выполнена 
с ошибкой. Переменна SQLCODE ( называемая еще SQLCOD в 
ФОРТРАНе ) предназначена чтобы обеспечить эту функцию. Она должна быть определена как переменна главного языка и должна иметь 
тип данных который в главном языке соответствует одному из точных 
числовых типов SQL, как это показано в <A href="b.shtml">Приложении B</A>. 
Значение SQLCODE устанавливается каждый раз, когда выполняется 
команда SQL. В основном существуют три возможности: 
 
1. Команда выполнилась без ошибки, но не произвела никакого 
   действия.  Для различных команд это выглядит по разному: 
<BR><BR> 
    а) Для SELECT, ни одна строка не выбрана запросом. 
<BR><BR> 
    б) Для FETCH, последняя строка уже была выбрана, или ни 
       одной строки не выбрано запросом в курсоре. 
<BR><BR> 
    в) Для INSERT, ни одной строки не было вставлено ( подразумевается что запрос использовался чтобы сгенерировать значения для вставки, и был отвергнут при попытке извлечения любой строки. 
<BR><BR> 
    г)  Для UPDATE и DELETE, ни одна строка не ответила условию предиката, и следовательно никаких изменений сделано 
        в таблице не будет. 
<BR><BR> 
     В любом случае, будет установлен код  SQLCODE = 100. 
<BR><BR> 
2. Команда выполнилась нормально, не удовлетворив ни одному из 
    выше указанных условий. В этом случае, будет установлен код 
     SQLCOD = 0. 
<BR><BR> 
3.  Команда сгенерировала ошибку. Если это случилось, изменения 
   сделанные к базе данных текущей транзакцией, будут восстановлены( см. Главу 23 ). 
   В этом случае будет установлен код SQLCODE = некоторому отрицательному числу, определяемому проектировщиком. Задача этого числа, идентифицировать проблему, так точно насколько это возможно. В принципе, ваша система должна быть снабжена подпрограммой, которая в этом случае, должна выполниться чтобы вы- 
   дать для вас информацию расшифровывающее значение негатив- 
   ного числа определенного вашим проектировщиком. В этом случае 
   некоторое сообщение об ошибке будет выведено на экран или за- 
   писано в файл протокола, а программа в это врем выполнит восстановление изменений для текущей транзакции, отключится от базы данных и выйдет из нее. Теперь мы можем усовершенствовать 
 <a name="25.9"></a>
<H3>ИСПОЛЬЗОВАНИЕ SQLCODE ДЛЯ УПРАВЛЕНИЯ ЦИКЛАМИ</H3> 
 
наш предыдущий пример для выхода из цикла автоматически, при условии что курсор пуст, все строки выбраны, или произошла ошибка: 
<PRE> 
            Look_at_more: = lhe; 
            EXEC SQL OPEN CURSOR Londonsales; 
              while Look_at_more 
              and SQLCODE = O do 
                begin 
                EXEC SQL FETCH London$ales 
                   INTO :id_num, :Salesperson, :loc, :comm; 
                writeln (id_num, Salesperson, loc, comm); 
                writeln ('Do you want to see more data? (Y/N)'); 
                readln (response); 
                If response = 'N' then Look_at_more: = Fabe; 
                end; 
            EXEC SQL CLOSE CURSOR Londonsales; 
</PRE> <a name="25.10"></a>
<H3>ПРЕДЛОЖЕНИЕ WHENEVER</H3> 
 
Это удобно для выхода при выполненном условии - все строки выбраны. 
Но если вы получили ошибку, вы должны предпринять нечто такое, что 
описано для третьего случая, выше. Для этой цели, SQL предоставляет 
предложение GOTO. Фактически, SQL позволяет вам применять его до- 
статочно широко, так что программа может выполнить команду GOTO 
автоматически, если будет произведено определенное значение SQLCODE. Вы можете сделать это совместно с предложением WHENEVER. 
Имеется кусок из примера для этого случая: 
<PRE> 
  EXEC SQL WHENEVER SQLERROR GOTO Error_handler; 
  EXEC SQL WHENEVER NOT FOUND CONTINUE; 
</PRE> 
SQLERROR- это другой способ сообщить что SQLCODE &lt; 0; а NOT 
FOUND - это другой способ сообщить что SQLCODE = 100. ( Некоторые реализации называют последний случай еще как - SQLWARNING.) 
Error_handler - это им того места в программе в которое будет пере- 
несено выполнение программы если произошла ошибка ( GOTO может 
состоять из одного или двух слов ). Такое место определяется любым способом соответствующим для главного языка, например, с помощью метки в Паскале, или имени раздела или имени параграфа в КОБОЛЕ ( в 
дальнейшем мы будем использовать термин - метка ).  Метка более удач- 
но идентифицирует стандартную процедуру распространяемую проектировщиком для включения во все программы. 
<BR><BR> 
 
CONTINUE не делает чего-то специального для значения SQLCODE. Оно 
также является значением по умолчанию. если вы не используете команду 
WHENEVER, определяющую значение SQLCODE. Однако, эти неактивные 
определения дают вам возможность переключаться вперед и назад, выполняя и не выполняя действия, в различных точках(метках) вашей программы. 
Например, если ваша программа включает в себя несколько команд INSERT, 
использующих запросы, которые реально должны производить значения, вы 
могли бы напечатать специальное сообщение или сделать что-то такое, что 
поясняло бы, что запросы возвращаются пустыми и никакие значения не бы- 
ли вставлены. В этом случае, вы можете ввести следующее: 
<PRE> 
 EXEC SQL WHENEVER NOT FOUND GOTO No_rows; 
</PRE> 
No_rows - это метка в некотором коде, содержащем определенное действие. С другой стороны, если вам нужно сделать выборку в программе поз- 
же, вы можете ввести следующее в этой точке, 
<PRE> 
 EXEC SQL WHENEVER NOT FOUND CONTINUE; 
</PRE> 
что бы выполнение выборки повторялось до тех пор пока все строки не будут извлечены, что является нормальной процедурой не требующей специальной обработки. 
 <a name="25.11"></a>
<H3>МОДИФИЦИРОВАНИЕ КУРСОРОВ</H3> 
Курсоры могут также быть использованы, чтобы выбирать группу строк 
из таблицы, которые могут быть затем модифицированы или удалены од- 
на за другой. Это дает вам возможность, обходить некоторые ограничения 
предикатов используемых в командах UPDATE и DELETE. Вы можете 
ссылаться на таблицу задействованную в предикате запроса курсора или любом из его подзапросов, которые вы не можете выполнить в предикатах 
самих этих команд. Как подчеркнуто в <A href="ch16.shtml">Главе 16</A>, стандарт SQL отклоняет 
попытку удалить всех пользователей с рейтингом ниже среднего, в следующей форме: 
<PRE> 
                 EXEC SQL DELETE FROM Customers 
                   WHERE rating &lt; 
                      ( SELECT AVG (rating) 
                        FROM Customers); 
</PRE> 
Однако, вы можете получить тот же эффект, используя запрос для выбора соответствующих строк, запомнив их в курсоре, и выполнив DELETE 
с использованием курсора. Сначала вы должны объявить курсор: 
<PRE> 
               EXEC SQL DECLARE Belowavg CURSOR FOR 
                 SELECT * 
                   FROM Customers 
                   WHERE rating &lt; 
                      (SELECT AVG (rating) 
                        FROM Customers); 
</PRE> 
Затем вы должны создать цикл, чтобы удалить всех заказчиков выбранных 
курсором: 
<PRE> 
            EXEC SQL WHENEVER SQLERROR GOTO Error_handler; 
             EXEC SQL OPEN CURSOR Belowavg; 
             while not SOLCODE = 100 do 
               begin 
               EXEC SOL FETCH Belowavg INTO :a, :b, :c, :d, :e; 
               EXEC SOL DELETE FROM Customers 
                 WHERE CURRENT OF Belowavg; 
               end; 
             EXEC SOL CLOSE CURSOR Belowavg; 
</PRE> 
Предложение WHERE CURRENT OF означает что DELETE применяется к строке которая в настоящее время выбрана курсором. Здесь подразумевается, что и курсор и команда DELETE, ссылаются на одну и ту же таблицу, и следовательно, что запрос в курсоре - это не объединение. 
  Курсор должен также быть модифицируемым.  Являясь модифицируемым, курсор должен удовлетворять тем же условиям что и представления 
( см. <A href="ch21.shtml">Главу 21</A> ). Кроме того, ORDER BY и UNION, которые не разрешены в представлениях, в курсорах - разрешаются, но предохраняют курсор от 
модифицируемости. Обратите внимание в вышеупомянутом примере, что 
мы должны выбирать строки из курсора в набор переменных, даже если 
мы не собирались использовать эти переменные. Этого требует синтаксис команды FETCH. UPDATE работает так же. 
Вы можете увеличить значение комиссионных всем продавцам, которые 
имеют заказчиков с оценкой=300, следующим способом. Сначала вы объявляете курсор: 
<PRE> 
        EXEC SOL DECLARE CURSOR High_Cust AS 
           SELECT * 
              FROM Salespeople 
              WHERE snum IN 
                 (SELECT snum 
                    FROM Customers 
                    WHERE rating = 300); 
</PRE> 
Затем вы выполняете модификации в цикле: 
<PRE> 
            EXEC SQL OPEN CURSOR High_cust; 
            while SQLCODE = 0 do 
               begin 
               EXEC SOL FETCH High_cust 
                  INTO :id_num, :salesperson, :loc, :comm; 
               EXEC SQL UPDATE Salespeople 
                  SET comm = comm + .01 
                  WHERE CURRENT OF High_cust; 
               end; 
            EXEC SQL CLOSE CURSOR High_cust; 
</PRE> 
Обратите внимание: что некоторые реализации требуют, чтобы вы указы- 
вали в определении курсора, что курсор будет использоваться для выполнения команды UPDATE на определенных столбцах. Это делается с помощью заключительной фразы определения курсора - FOR UPDATE <COLUMN list>. Чтобы объявить курсор High_cust таким способом, так чтобы вы мог- 
ли модифицировать командой UPDATE столбец comm, вы должны ввести 
следующее предложение: 
<PRE> 
             EXEC SQL DECLARE CURSOR High_Cust AS 
                SELECT * 
                   FROM Salespeople 
                   WHERE snum IN 
                      (SELECT snum 
                          FROM Customers 
                          WHERE rating = 300) 
                 FOR UPDATE OF comm; 
</PRE> 
Это обеспечит вас определенной защитой от случайных модификаций, 
которые могут разрушить весь порядок в базе данных. 
 
 <a name="25.12"></a>
<H3>ПЕРЕМЕННАЯ INDICATOR</H3>  
 
Пустые (NULLS) значения - это специальные маркеры определяемые сам- 
ой SQL. Они не могут помещаться в главные переменные. Попытка вставить NULL значения в главную переменную будет некорректна, так как главные языки не поддерживают NULL значений в SQL, по определению. Хо- 
т результат при попытке вставить NULL значение в главную переменную 
определяет проектировщик, этот результат не должен противоречить теории 
базы данных, и поэтому обязан произвести ошибку: код SQLCODE в виде 
отрицательного числа, и вызвать подпрограмму управления ошибкой. Естественно вам нужно этого избежать. Поэтому, вы можете выбрать NULL значения с допустимыми значениями, не приводящими к разрушению вашей 
программы. Даже если программа и не разрушится, значения в главных 
переменных станут неправильными, потому что они не могут иметь NULL 
значений. Альтернативным методом предоставляемым для этой ситуацией 
является - функция переменной indicator(указатель). 
Переменна indicator - объявлена в разделе объявлений SQL напоминает 
другие переменные. Она может иметь тип главного языка который соответствует числовому типу в SQL. Всякий раз, когда вы выполняете операцию, 
которая должна поместить NULL значение в переменную главного языка, 
вы должны использовать переменную indicator, для надежности. 
Вы помещаете переменную indicator в команду SQL непосредственно после 
переменной главного языка которую вы хотите защитить, без каких-либо пробелов или запятых, хотя вы и можете, при желании, вставить слово - 
INDICATOR. 
Переменной indicator в команде, изначально присваивается значение 0. 
Однако, если производитс значение NULL , переменна indicator станов- 
итс равной отрицательному числу. Вы можете проверить значение перем- 
енной indicator, чтобы узнать, было ли найдено значение NULL.  Давайте 
предположим, что пол city и comm, таблицы Продавцов, не имеют ограни- 
чени NOT NULL, и что мы объвили вразделе обьвлений SQL, две 
ПАСКАЛЬевские переменные целого типа, i_a и i_b. 
( Нет ничего такого в разделеобьвлений, что могло бы представить их 
как переменные indicator. Они станут переменными indicator, когда бу- 
дут использоваться как переменные indicator. ) 
 Имеется одна возможность: 
<PRE> 
      EXEC SQL OPEN CURSOR High_cust; 
      while SQLCODE = O do 
         begin 
         EXEC SQL FETCH High_cust 
            INTO :id_num, :salesperson, 
               :loc:i_a, :commINDlCATOR:i_b; 
         If i_a &gt; = O and i_b &gt; = O then 
                       {no NULLs produced} 
              EXEC SQL UPDATE Salespeople 
                 SET comm = comm + .01 
                 WHERE CURRENT OF Hlgh_cust; 
         else 
                    {one or both NULL} 
         begin 
            If i_a &lt; O then 
                 writeln ('salesperson ', id_num, ' has no city'); 
            If i_b &lt; O then 
                 writeln ('salesperson ', id_num, ' has no 
                 commission'); 
         end; 
                   {else} 
         end; {while} 
      EXEC SQL CLOSE CURSOR High_cust; 
</PRE> 
Как вы видите, мы включили, ключевое слово INDICATOR в одном случае, 
и исключили его в другом случае, чтобы показать, что эффект будет одинаковым в любом случае. Каждая строка будет выбрана, но команда UPDATE 
выполнится только если NULL значения не будут обнаружены. 
Если будут обнаружены NULL значения, выполнится еще одна часть программы, которая распечатает предупреждающее сообщение, где было найдено 
каждое NULL значение. 
 Обратите внимание: переменные indicator должны проверяться в главном 
языке, как указывалось выше, а не в предложении WHERE команды SQL. 
  Последнее в принципе не запрещено, но результат часто бывает непредвиденным. 
 <a name="25.13"></a>
<H3>ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННОЙ INDICATOR ДЛЯ ЭМУЛЯЦИИ NULL ЗНАЧЕНИЙ SQL</H3> 
 
  Друга возможность состоит в том, чтобы обрабатывать переменную 
indicator, связывая ее с каждой переменной главного языка, специальным способом, эмулирующим поведение NULL значений SQL. 
  Всякий раз, когда вы используете одно из этих значений в вашей программе, например в предложении if ... then, вы можете сначала проверить связанную переменную indicator, является ли ее значение=NULL. 
Если это так, то вы обрабатываете переменную по-другому. Например, 
если NULL значение было извлечено из пол city для главной перемен- 
ной city, которая связана с переменной indicator - i_city, вы должны 
установить значение city равное последовательности пробелов. Это будет необходимо, только если вы будете распечатывать его на принтере; 
его значение не должно отличаться от логики вашей программы. 
Естественно, i_city автоматически устанавливается в отрицательное значение. Предположим, что вы имели следующую конструкцию в вашей 
программе: 
<PRE> 
        If sity = 'London' then 
             comm: = comm + .01 
        else comm: = comm - .01 
</PRE> 
Любое значение, вводимое в переменную city, или будет равно "London" 
или не будет равно. Следовательно, в каждом случае значение комиссионных будет либо увеличено либо уменьшено. Однако, эквивалентные 
команды в SQL выполняются по разному: 
<PRE> 
         EXEC SQL UPDATE Salespeople 
            SET comm = comm + .01 
            WHERE sity = 'London'; 
</PRE> 
 и 
<PRE> 
         EXEC SQL UPDATE Salespeople 
            SET comm = comm  .01; 
            WHERE sity &lt; &gt; 'London'; 
</PRE> 
( Вариант на ПАСКАЛе работает только с единственным значением, в то 
врем как вариант на SQL  работает со всеми таблицами. ) 
Если значение city в варианте на SQL будет равно значению NULL , оба 
предиката будут неизвестны, и значение comm, следовательно, не будет 
изменено в любом случае. 
  Вы можете использовать переменную indicator чтобы сделать поведение вашего главного языка непротиворечащим этому, с помощью создания условия, которое исключает NULL значения: 
<PRE> 
        If i_city &gt; = O then 
             begin 
             If city = 'London' then 
                  comm: = comm + .01 
             else comm: = comm - .01; 
             end; 
       {begin and end нужны здесь только для понимания} 
</PRE>
<H5>ПРИМЕЧАНИЕ: Последняя строка этого примера содержит ремарку - { begin и end 
необходимы только для понимания }</H5>В более сложной программ, вы можете захотеть установить Булевую переменную в "верно" , чтобы указать что значение city =NULL. Затем вы 
можете просто проверять эту переменную всякий раз, когда вам это 
необходимо. 
<a name="25.14"></a>
<H3>ДРУГОЕ ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННОЙ INDICATOR</H3> 

Переменна indicator также может использоваться для назначения значения NULL. Просто добавьте ее к имени главной переменной в команде 
UPDATE или INSERT тем же способом что и в команде SELECT. 
Если переменна indicator имеет отрицательное значение, значение NULL 
будет помещено в поле.  Например, следующая команда помещает значения NULL в пол city и comm, таблицы Продавцов, всякий раз, когда 
переменные indicator -  i_a или i_b будут отрицательными; в противном 
случае она помещает туда значения главных переменных: 
<PRE>
EXEC SQL INSERT INTO Salespeople 
 VALUES (:Id_num, :salesperson, :loc:i_a, :comm:i_b); 
</PRE>
Переменна indicator используется также, чтобы показывать отбрасываемую 
строку. Это произойдет если вы вставляете значения символов SQL в главную переменную которая не достаточно длинна чтобы вместить все символы. 
Это особа проблема с нестандартным типами данных - VARCHAR и LONG 
( смотри <A href="c.shtml">Приложению C</A> ). В этом случае, переменна будет заполнена 
первыми символами строки, а последние символы будут потеряны. 
Если используется переменна indicator, она будет установлена в положительное значение, указывающее на длину отбрасываемой части строки, позволяя таким образом вам узнать, сколько символов было потеряно. 

В этом случае, Вы можете проверить с помощью просмотра -значение переменной  indicator &gt; 0, или &lt; 0. 
<a name="25.15"></a>
<H3>РЕЗЮМЕ</H3> 

Команды SQL вкладываются в процедурные языках, чтобы объединить силы двух подходов. Некоторые дополнительные средства SQL необходимы, 
чтобы выполнить эту работу. Вложенные команды SQL транслируемые программой, называемой прекомпилятором, в форму пригодную для использования транслятором главного языка, и используемые в этом главном языке, как вызовы процедуры к подпрограммам которые создает прекомпилятор, называются - модулями доступа. 
ANSI поддерживает вложение SQL в языки: ПАСКАЛЬ, ФОРТРАН, 
КОБОЛ, и PL/I. 
Другие языки также используются, особенно Си.  В попытке кратко описать вложенный SQL, имеются наиболее важные места в этой главе: 
<BR><BR>
*  Все вложенные команды SQL начинаются словами EXEC SQL и заканчиваются способом который зависит от используемого главного языка. 
<BR><BR>
*  Все главные переменные доступные в командах SQL, должны быть объявлены в разделе объявлений SQL прежде, чем они будут использованы. 
<BR><BR>
*  Всем главным переменным должно предшествовать двоеточие когда они 
используются в команде SQL. 
<BR><BR>
*  Запросы могут сохранять свой вывод непосредственно в главных переменных, используя предложение INTO, если и только если, они выбирают 
единственную строку. 
<BR><BR>
*  Курсоры могут использоваться для сохранения вывода запроса, и доступа 
к одной строке в каждый момент времени. Курсоры бывают объявлеными 
( если определяют запрос в котором будут содержаться), открытыми( если 
выполняют запрос ), и закрытыми ( если удаляют вывод запроса из курсора ). Если курсор открыт, команда FETCH, используется чтобы перемещать его по очереди  к каждой строке вывода запроса. 
<BR><BR>
*  Курсоры являются модифицируемыми или только-чтение. Чтобы стать 
модифицируемым, курсор должен удовлетворять всем критериям которым удовлетворяет просмотр; кроме того, он не должен использовать 
предложений ORDER BY или UNION, которые в любом случае не 
могут использоваться просмотрами. Не модифицируемый курсор является курсором только-чтение. 
<BR><BR>
*  Если курсор модифицируемый, он может использоваться для определения, какие строки задействованы вложенными командами UPDATE  и 
DELETE через предложение WHERE CURRENT OF. 
DELETE или UPDATE должны быть вне той таблицы к которой кур- 
сор обращаетс в запросе. 
<BR><BR>
*  SQLCODE должен быть объявлен как переменна числового типа для 
каждой программы которая будет использовать вложенный SQL. Его 
значение устанавливается автоматически после выполнения каждой 
команды SQL. 
<BR><BR>
*  Если команда SQL выполнена как обычно, но не произвела вывода или 
ожидаемого изменения в базе данных, SQLCODE = 100. Если команда 
произвела ошибку, SQLCODE будет равняться некоторому аппаратно- 
определенному отрицательному числу которое описывает ошибку. 
В противном случае, SQLCODE = 0. 
<BR><BR>
*  Предложение WHENEVER может использоваться для определения действия которое нужно предпринять когда SQLCODE = 100 (не  найдено) 
или когда SQLCODE равен отрицательному числу ( SQLERROR ). 
Действием может быть или переход к некоторой определенной метке в 
программе ( GOTO <LABEL> ) или отсутствие какого-либо действия вообще( продолжить).   Последнее, установлено по умолчанию. 
<BR><BR>
*  Числовые переменные могут также использоваться как переменные 
indicator. Переменные indicator следуют за другим именами переменных в  команде SQL, без каких бы то ни было посторонних символов 
кроме (необязательного) слова INDICATOR. 
<BR><BR>
*  Обычно, значение переменной indicator = 0. Если команда SQL пытается поместить NULL значение в главную переменную которая использует  indicator, indicator будет установлен в отрицательное значение. 
Этот факт можно использоваться чтобы предотвращать ошибки, и для 
помечания NULL значений SQL для специальной обработки их в глав- 
ной программе. 
<BR><BR>
*  Переменна indicator может использоваться для вставки NULL значений в команды SQL - INSERT или UPDATE. Она также может 
принимать положительное значение указывающее на длину отбрасываемой части строки не поместившейся в предельные границы какой- 
нибудь переменной, куда эта строка помещалась. 

<a name="25.16"></a>
<H3>РАБОТА С SQL</H3>  


Обратите внимание: Ответы для этих упражнений написаны в псевдокодах, являющихся английским языком описания логики, которой должна 
следовать программа. Это сделано для того чтобы помочь читателям 
которые могут быть незнакомы с ПАСКАЛем(или любым другим языком). 
Кроме того это лучше сфокусирует ваше внимание на включаемых понятиях, опуская частности того или другого языка. Чтобы непротиворечить 
нашим примерам, стиль псевдокода будет напоминать Паскаль. 
Мы опустим из программ все что не относится напрямую к рассматриваемым вопросам, например, определение устройств ввода-вывода, подключение к базе данных, и так далее. Конечно, имеется много способов 
чтобы выполнять такие упражнения; и совсем не обязательно что представленные варианты решений являются самыми удачными. 
<BR><BR>
1. Разработайте простую программу которая выберет все комбинации по- 
лей snum и cnum  из таблиц Порядков и Заказчиков и выясните, всегда ли предыдущая комбинация такая же как последующая. Если комбинация из таблицы Порядков не найдена в таблице Заказчиков, значение пол snum для этой строки будет изменено на удовлетворяющее 
условию совпадения. Вы должны помнить, что курсор с подзапросом - 
модифицируем ( ANSI ограничение, также применимо к просмотрам, 
и что базисна целостность базы данных это не тоже самое что проверка на ошибку( т.е. первичные ключи уникальны, все пол cnums в 
таблице Порядков правильны, и так далее ). 
Проверьте раздел объявлений, и убедитесь что там объявлены все используемые курсоры. 
<BR><BR>
2. Предположим, что ваша программа предписывает ANSI запрещение 
курсоры или просмотры использующие модифицируемые подзапросы. Как вы должны изменить вышеупомянутую программу? 
<BR><BR>
3. Разработайте программу которая подсказывает пользователям изменить значения пол city продавца, автоматически увеличивает комиссионные на .01 для продавца переводимого в Барселону и уменьшает их на .01 для продавца переводимого в Сан Хосе. Кроме того, 
продавец находящийся в Лондоне должен потерять .02 из своих комиссионных, независимо от того меняет он город или нет, в то врем 
как продавец не находящийся в Лондоне должен иметь увеличение 
комиссионных на .02. 
Изменение в комиссионных основывающееся на нахождении продавца в Лондоне, может применяться независимо от того куда тот переводится. 
Выясните могут  ли поле city или поле comm содержать NULL значения, и обработайте их, как это делается в SQL. 
Предупреждение! : эта программа имеет некоторые сокращения. 
<BR><BR>
( См. <A href="a.shtml#25">Приложение A</A>  -  для ответов. ) 
</LABEL>
</TD></TR></TABLE>
</TD></TR>
<TR BGCOLOR=#6699CC><TD><TABLE WIDTH=100% BORDER=0 CELLSPACING=0 CELLPADDING=0><TR><TD BGCOLOR=#6699CC VALIGN=CENTER HEIGHT = 40><FONT SIZE=-10>
<!-- begin of Rambler's Top100 code -->
<img src="../../../../counter.rambler.ru/top100.cnt@236431" alt="" width="1" height="1" border="0" />
<!--end of Top100 code-->
<TABLE WIDTH=100% CELLPADDING=0 CELLSPACING=0 BORDER=0 CLASS="tableborder"><TR BGCOLOR="#6699CC"><TD>
<!-- begin of Top100 logo -->
<a href="../../../../top100.rambler.ru/home@id=236431">
<img src="../../../../top100-images.rambler.ru/top100/banner-88x31-rambler-gray2.gif" alt="Rambler's Top100"
width="88" height="31" border="0" /></a>
<!-- end of Top100 logo -->
</FONT>
<!--Rating@Mail.ru COUNTER--><a target=_top
href="../../../../top.mail.ru/jump@from=58574"><img
src="../../../../top.list.ru/counter@id=58574;t=94"
border=0 height=18 width=88
alt="Рейтинг@Mail.ru"></a><!--/COUNTER-->
<!-- Yandex.Metrika counter --><!--ipt type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter9237463 = new Ya.Metrika({id:9237463, trackLinks:true, accurateTrackBounce:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</scri--><noscript><div><img src="../../../../https@mc.yandex.ru/watch/9237463" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter -->
</TD>
<TD BGCOLOR=#6699CC ALIGN=right><FONT COLOR=white FACE="Tahoma,Arial" SIZE=1>&nbsp;Administrator:&nbsp;<A STYLE="color :white" HREF="../../../../www.sql.ru/feedback.aspx">Обратная связь</A>&nbsp;<BR>Copyright: <FONT COLOR=white>SQL.Ru  2000-2013&nbsp;</FONT></FONT></TD></TR></TABLE>
</TD></TR></TABLE></TD></TR></TABLE>

</BODY></HTML>

