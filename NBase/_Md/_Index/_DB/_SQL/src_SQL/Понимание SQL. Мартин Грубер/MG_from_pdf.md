<!-- Start Document Outline -->

* [Команда SELECT](#команда-select)
* [Команды UPDATE, INSERT, DELETE](#команды-update-insert-delete)
	* [UPDATE](#update)
	* [INSERT](#insert)
	* [DELETE](#delete)
* [Команда CREATE TABLE](#команда-create-table)
* [ПРЕДИСЛОВИЕ](#предисловие)
	* [Глава 1. ВВЕДЕНИЕ В РЕЛЯЦИОННУЮ БАЗУ ДАННЫХ](#глава-1-введение-в-реляционную-базу-данных)
		* [СВЯЗЫВАНИЕ ОДНОЙ ТАБЛИЦЫ С ДРУГОЙ](#связывание-одной-таблицы-с-другой)
		* [ПОРЯДОК СТРОК ПРОИЗВОЛЕН](#порядок-строк-произволен)
		* [ИДЕНТИФИКАЦИЯ СТРОК (ПЕРВИЧНЫЕ КЛЮЧИ )](#идентификация-строк-первичные-ключи-)
		* [СТОЛБЦЫ ИМЕНУЮТСЯ И НУМЕРУЮТСЯ](#столбцы-именуются-и-нумеруются)
		* [ТИПОВАЯ БАЗА ДАННЫХ](#типовая-база-данных)
		* [РЕЗЮМЕ](#резюме)
	* [Глава 2. SQL : ОБЗОР.](#глава-2-sql--обзор)
		* [КАК РАБОТАЕТ SQL?](#как-работает-sql)
		* [ЧТО ДЕЛАЕТ ANSI?](#что-делает-ansi)
		* [ИНТЕРАКТИВНЫЙ И ВЛОЖЕННЫЙ SQL](#интерактивный-и-вложенный-sql)
		* [СУБПОДРАЗДЕЛЕНИЯ SQL](#субподразделения-sql)
		* [РАЗЛИЧНЫЕ ТИПЫ ДАННЫХ](#различные-типы-данных)
		* [SQL НЕСОГЛАСОВАННОСТИ](#sql-несогласованности)
		* [ЧТО ТАКОЕ - ПОЛЬЗОВАТЕЛЬ?](#что-такое---пользователь)
		* [УСЛОВИЯ И ТЕРМИНОЛОГИЯ](#условия-и-терминология)
		* [РЕЗЮМЕ](#резюме-1)
	* [Глава 3. ИСПОЛЬЗОВАНИЕ SQL ДЛЯ ИЗВЛЕЧЕНИЯ ИНФОРМАЦИИ ИЗ ТАБЛИЦ.](#глава-3-использование-sql-для-извлечения-информации-из-таблиц)
		* [СОЗДАНИЕ ЗАПРОСА](#создание-запроса)
		* [ЧТО ТАКОЕ ЗАПРОС?](#что-такое-запрос)
		* [ГДЕ ПРИМЕНЯЮТСЯ ЗАПРОСЫ?](#где-применяются-запросы)
		* [КОМАНДА SELECT](#команда-select-1)
		* [SQL Execution Log](#sql-execution-log)
		* [ВЫБИРАЙТЕ ВСЕГДА САМЫЙ ПРОСТОЙ СПОСОБ](#выбирайте-всегда-самый-простой-способ)
		* [ОПИСАНИЕ SELECT](#описание-select)
		* [ПРОСМОТР ТОЛЬКО ОПРЕДЕЛЕННОГО СТОЛБЦА ТАБЛИЦЫ](#просмотр-только-определенного-столбца-таблицы)
		* [ПЕРЕУПОРЯДОЧЕНИЕ СТОЛБЦА](#переупорядочение-столбца)
		* [ПАРАМЕТРЫ DISTINCT](#параметры-distinct)
		* [DISTINCT ВМЕСТО ALL](#distinct-вместо-all)
		* [КВАЛИФИЦИРОВАННЫЙ ВЫБОР ПРИ ИСПОЛЬЗОВАНИИ ПРЕДЛОЖЕНИЙ](#квалифицированный-выбор-при-использовании-предложений)
		* [РЕЗЮМЕ](#резюме-2)
		* [РАБОТА С SQL](#работа-с-sql)
	* [Глава 4. ИСПОЛЬЗОВАНИЕ РЕЛЯЦИОННЫХ И БУЛЕВЫХ ОПЕРАТОРОВ ДЛЯ СОЗДАНИЯ БОЛЕЕ ИЗОЩРЕННЫХ ПРЕДИКАТОВ](#глава-4-использование-реляционных-и-булевых-операторов-для-создания-более-изощренных-предикатов)
		* [РЕЛЯЦИОННЫЕ ОПЕРАТОРЫ](#реляционные-операторы)
		* [БУЛЕВЫ ОПЕРАТОРЫ](#булевы-операторы)
		* [РЕЗЮМЕ](#резюме-3)
		* [РАБОТА С SQL](#работа-с-sql-1)
	* [Глава 5. ИСПОЛЬЗОВАНИЕ СПЕЦИАЛЬНЫХ ОПЕРАТОРОВ В УСЛОВИЯХ](#глава-5-использование-специальных-операторов-в-условиях)
		* [ОПЕРАТОР IN](#оператор-in)
		* [ОПЕРАТОР BETWEEN](#оператор-between)
		* [РАБОТА С НУЛЕВЫМИ( NULL ) ЗНАЧЕНИЯМИ](#работа-с-нулевыми-null--значениями)
		* [NULL ОПЕРАТОР](#null-оператор)
		* [ИСПОЛЬЗОВАНИЕ NOT СО СПЕЦИАЛЬНЫМИ ОПЕРАТОРАМИ](#использование-not-со-специальными-операторами)
		* [РЕЗЮМЕ](#резюме-4)
		* [РАБОТА С SQL](#работа-с-sql-2)
	* [Глава 6. ОБОБЩЕНИЕ ДАННЫХ С ПОМОЩЬЮ АГРЕГАТНЫХ ФУНКЦИЙ](#глава-6-обобщение-данных-с-помощью-агрегатных-функций)
		* [ЧТО ТАКОЕ АГРЕГАТНЫЕ ФУНКЦИИ?](#что-такое-агрегатные-функции)
		* [КАК ИСПОЛЬЗОВАТЬ АГРЕГАТНЫЕ ФУНКЦИИ?](#как-использовать-агрегатные-функции)
		* [ИСПОЛЬЗОВАНИЕ COUNT СО СТРОКАМИ, А НЕ ЗНАЧЕНИЯМИ](#использование-count-со-строками-а-не-значениями)
		* [ВКЛЮЧЕНИЕ ДУБЛИКАТОВ В АГРЕГАТНЫЕ ФУНКЦИИ](#включение-дубликатов-в-агрегатные-функции)
		* [АГРЕГАТЫ ПОСТРОЕННЫЕ НА СКАЛЯРНОМ ВЫРАЖЕНИИ](#агрегаты-построенные-на-скалярном-выражении)
		* [ПРЕДЛОЖЕНИЕ GROUP BY](#предложение-group-by)
		* [ПРЕДЛОЖЕНИЕ HAVING](#предложение-having)
		* [НЕ ДЕЛАЙТЕ ВЛОЖЕННЫХ АГРЕГАТОВ](#не-делайте-вложенных-агрегатов)
		* [РЕЗЮМЕ](#резюме-5)
	* [Глава 7. ФОРМИРОВАНИЕ ВЫВОДОВ ЗАПРОСОВ](#глава-7-формирование-выводов-запросов)
		* [СТРОКИ И ВЫРАЖЕНИЯ](#строки-и-выражения)
		* [СКАЛЯРНОЕ ВЫРАЖЕНИЕ С ПОМОЩЬЮ ВЫБРАННЫХ ПОЛЕЙ](#скалярное-выражение-с-помощью-выбранных-полей)
		* [СТОЛБЦЫ ВЫВОДА](#столбцы-вывода)
		* [ПОМЕЩЕНИЕ ТЕКСТА В ВАШЕМ ВЫВОДЕ ЗАПРОСА](#помещение-текста-в-вашем-выводе-запроса)
		* [УПОРЯДОЧЕНИЕ ВЫВОДА ПОЛЕЙ](#упорядочение-вывода-полей)
		* [УПОРЯДОЧЕНИЕ АГРЕГАТНЫХ ГРУПП](#упорядочение-агрегатных-групп)
		* [УПОРЯДОЧЕНИЕ ВЫВОДА ПО НОМЕРУ СТОЛБЦА](#упорядочение-вывода-по-номеру-столбца)
		* [УПОРЯДОЧЕНИЕ С ПОМОЩЬЮ ОПРЕТОРА NULL](#упорядочение-с-помощью-опретора-null)
		* [РЕЗЮМЕ](#резюме-6)
		* [РАБОТА С SQL](#работа-с-sql-3)
	* [Глава 8. ЗАПРАШИВАНИЕ МНОГОЧИСЛЕНЫХ ТАБЛИЦ ТАКЖЕ КАК ОДНОЙ](#глава-8-запрашивание-многочисленых-таблиц-также-как-одной)
		* [ОБЪЕДИНЕНИЕ ТАБЛИЦ](#объединение-таблиц)
		* [ИМЕНА ТАБЛИЦ И СТОЛБЦОВ](#имена-таблиц-и-столбцов)
		* [СОЗДАНИЕ ОБЬЕДИНЕНИЯ](#создание-обьединения)
		* [ОБЪЕДИНЕНИЕ ТАБЛИЦ ЧЕРЕЗ СПРАВОЧНУЮ ЦЕЛОСТНОСТЬ](#объединение-таблиц-через-справочную-целостность)
		* [ОБЪЕДИНЕНИЯ ТАБЛИЦ ПО РАВЕНСТВУ ЗНАЧЕНИЙ В СТОЛБЦАХ И ДРУГИЕ ВИДЫ ОБЪЕДИНЕНИЙ](#объединения-таблиц-по-равенству-значений-в-столбцах-и-другие-виды-объединений)
		* [ОБЪЕДИНЕНИЕ БОЛЕЕ ДВУХ ТАБЛИЦ](#объединение-более-двух-таблиц)
		* [РЕЗЮМЕ](#резюме-7)
		* [РАБОТА С SQL](#работа-с-sql-4)

<!-- End Document Outline -->

# Команда SELECT
 
       SELECT * | { [ DISTINCT | ALL] <value expression>.,..}
        FROM { <table name> [ <alias> ] }.,..
        [ WHERE <predicate>]
        [ GROUP BY { <column name> | <integer> }.,..]
        [ HAVING <predicate>]
        [ ORDERBY { <column name> | <integer> }.,..]
        [ { UNION [ALL]
     
     
       SELECT * | { [DISTINCT | ALL] < value expression >.,..}
        FROM { <table name> [<alias>]} .,..
        [ WHERE <predicate>
        [ GROUP BY { <columnname> | <integer> }.,..]
        [ HAVING <predicate>]
        [ ORDER BY { <columnname> | <integer> }.,..] } ] ...;
       Элементы, используемые в команде SELECT

   
|    ЭЛЕМЕНТ                               |    ОПРЕДЕЛЕНИЕ                           |
|------------------------------------------|------------------------------------------|
|    &lt;value expression&gt;<br style="margin: 0px; padding: 0px;"> |    Выражение, которое производит значение. Оно может включать в себя или содержать &lt;column name&gt;.<br style="margin: 0px; padding: 0px;"> |
|    &lt;table name&gt;<br style="margin: 0px; padding: 0px;"> |    Имя или синоним таблицы или представления<br style="margin: 0px; padding: 0px;"> |
|    &lt;alias&gt;<br style="margin: 0px; padding: 0px;"> |    Временный синоним для &lt;table name&gt;, определеный в этой таблице и используемый только в этой команде<br style="margin: 0px; padding: 0px;"> |
|    &lt;predicate&gt;<br style="margin: 0px; padding: 0px;"> |    Условие , которое может быть верным или неверным для каждой строки или комбинации строк таблицы в предложении FROM.<br style="margin: 0px; padding: 0px;"> |
|    &lt;column name&gt;<br style="margin: 0px; padding: 0px;"> |    Имя столбца в таблице.<br style="margin: 0px; padding: 0px;"> |
|    &lt;integer&gt;<br style="margin: 0px; padding: 0px;"> |    Число с десятичной точкой. В этом случае, оно показывает &lt;value expression&gt; в предложении SELECT с помощью идентификации его местоположения в этом предложении.<br style="margin: 0px; padding: 0px;"> |


   
   
# Команды UPDATE, INSERT, DELETE

## UPDATE
     
       UPDATE <tablename>
        SET { | }.,. .< column name> = <value expresslon> [ WHERE <predlcate>
        | WHERE CURRENT OF <cursor name> (*только для вложения*) ];
## INSERT
     
       INSERT INTO < table name> [(<column name> .,. ]
        { VALUES ( <value expression> .,.. ) } | <query>;
## DELETE
     
       DELETE FROM <table name>
        [ WHERE <predicate>
        | WHERE CURRENT OF <cursor name> (*только для вложения*) ];
    Элементы, используемые в командах МОДИФИКАЦИИ

|    ЭЛЕМЕНТ                               |    ОПРЕДЕЛЕНИЕ                           |
|------------------------------------------|------------------------------------------|
|    &lt;cursor name&gt;<br style="margin: 0px; padding: 0px;"> |    Имя курсора используемого в этой программе.<br style="margin: 0px; padding: 0px;"> |
|    &lt;query&gt;<br style="margin: 0px; padding: 0px;"> |    Допустимая команда SELECT.<br style="margin: 0px; padding: 0px;"> |


   Допустимая команда SELECT.

   Для других элементов смотри команду SELECT.
   Символы Используемые в Синтаксисе Предлжения

|    СИМВОЛ                                |    ОБЪЯСНЕНИЕ                            |
|------------------------------------------|------------------------------------------|
| \|<br style="margin: 0px; padding: 0px;"> |    Любой предшествующий знаку (\|) символ может быть произвольно<br style="margin: 0px; padding: 0px;">   заменен на любой следующий за (\|). Это — символический способ высказывания "или" ("or").<br style="margin: 0px; padding: 0px;"> |
|    { }<br style="margin: 0px; padding: 0px;"> |    Все, что включено в фигурные скобки обрабатывается как модуль с целью оценки \|, .,.. или других символов.<br style="margin: 0px; padding: 0px;"> |
|    [ ]<br style="margin: 0px; padding: 0px;"> |    Все,включенное в квадратные скобки является необязательным<br style="margin: 0px; padding: 0px;"> |
|    ...<br style="margin: 0px; padding: 0px;"> |    Любое, предшествующее этому, может повторяться любое число раз.<br style="margin: 0px; padding: 0px;"> |
|    .,..<br style="margin: 0px; padding: 0px;"> |    Любое, предшествующее этому, и в каждом случае отделенное<br style="margin: 0px; padding: 0px;"> |


   
   
# Команда CREATE TABLE
 
    CREATE TABLE <table name>
    ( { <column name> <data type> | <size>]
    [<colcnstrnt> ...]} .,.. );
    [<tabconstrnt>] .,.. );
Элементы, используемые в команде CREATE TABLE
    
|    ЭЛЕМЕНТ                               |    ОПРЕДЕЛЕНИЕ                           |
|------------------------------------------|------------------------------------------|
|    &lt;table name&gt;<br style="margin: 0px; padding: 0px;"> |    Имя таблицы создаваемой этой командой.<br style="margin: 0px; padding: 0px;"> |
|    &lt;column name&gt;<br style="margin: 0px; padding: 0px;"> |    Имя столбца таблицы.<br style="margin: 0px; padding: 0px;"> |
|    &lt;data type&gt;<br style="margin: 0px; padding: 0px;"> |    Тип данных<br style="margin: 0px; padding: 0px;"> |


   Тип данных, который может содержаться в столбце.
Может быть любым из следующих:
 
    INTEGER (ЦЕЛОЕ ЧИСЛО),
    CHARACTER (СИМВОЛЬНОЕ),
    DECIMAL (ДЕСЯТИЧНОЕ),
    NUMERIC (ЧИСЛОВОЕ),
    SMALLINT (НАИМЕНЬШЕЕ)
    
    FLOAT (С ПЛАВАЮЩЕЙ ТОЧКОЙ)
    
    REAL (РЕАЛЬНОЕ),
    DOUBLE PRECISION (УДВОЕННАЯ ТОЧНОСТЬ С ПЛАВАЮЩЕЙ ТОЧКОЙ),
    LONG * (ДЛИННОЕ *),
    VARCHAR * (ПЕРЕМЕННОЕ СИМВОЛЬНОЕ *),
    DATE * (ДАТА *),
    TIME * (ВРЕМЯ *)
 
   (* — указывает на нестандартный для SQL тип данных)
 
   <size> Размер. Его значение зависит от <data type>.
   <colconstrnt> Может быть любым из следующих:
   
    NOT NULL (НЕ НУЛЕВОЙ),
    UNIQUE (УНИКАЛЬНЫЙ),
    PRIMARY KEY (ПЕРВИЧНЫЙ КЛЮЧ),
    CHECK(<predicate>) (ПРОВЕРКА предиката),
    DEFAULT = <value expression> (ПО УМОЛЧАНИЮ = значимому выражению)
    REFERENCES <table name> [(<column name> .,.. )] (ССЫЛКА НА имя таблицы [(имя столбца) ] )
    <tabconstrnt> Может быть любым из следующих:
    UNIQUE (УНИКАЛЬНЫЙ),
    PRIMARY KEY (ПЕРВИЧНЫЙ КЛЮЧ),
    CHECK (ПРОВЕРКА предиката )
    FOREIGN KEY(<column name>) (ВНЕШНИЙ КЛЮЧ)
    REFERENCES <table name> [(<column name> .,.. )] (ССЫЛКА НА имя таблицы [( имя столбца) ].
     
# ПРЕДИСЛОВИЕ
   "ПОНИМАНИЕ SQL" - это полный учебник по программированию на Структурированном Языке Запросов, написанный специально для тех, кто будет использовать SQL в процессе работы. Даже если это ваш первый опыт с компьютерами или управлением базами данных, книга "ПОНИМАНИЕ SQL" очень быстро научит вас свободно работать с реальной SQL, использованию простых запросов, а также снабдит вас ясными понятиями об автоматизированном управлении базой данных. Книга даст вам краткое, удобное в чтении введение в реляционные базы данных. Предоставит вам обучающие программы, чтобы, овладевая командами SQL шаг за шагом, помочь вам узнать, как извлекать и обрабатывать информацию, содержащуюся в таблицах данных, т.е.:
   * выбирать информацию, с которой вы хотите работать
   * добавлять, удалять, и модифицировать информацию в таблице данных
   * использовать и-или, верно/неверно и другие условия для обнуления определенной информации
   * использовать специальные функции SQL для суммирования ваших данных.
   Книга покажет Вам, как эффективно работать с многочислеными таблицами данных, используя улучшеную технику для запроса более чем одной таблицы одновременно, строить комплекс запросов и подзапросов, и использовать представления, чтобы создавать базы данных и работать с базами данных раздельно с многими таблицами.
   Научит создавать новые таблицы данных для пользовательских деловых прикладных программ. Вы исследуете принципы эффективного проектирования базы данных, а также техники для обеспечения целостности данных и их защиты.
   Вы узнаете, как использовать SQL с другими языками в специальной главе SQL для программистов.
   "ПОНИМАНИЕ SQL" - необходима и пригодна для любой реализации Структурированного Языка Запроса. Книга включает и краткий справочный стандарт SQL и руководство к общим нестандартным особенностям SQL.
Об Авторе
   Мартин Грубер - свободный писатель, учитель и консультант из Сан-Франциско.
   В дополнении к написанию и редактированию книг, руководств пользователей и документации, он работает в широком спектре интересов, связанных с компьютерами и компьютерными базами данных.
## Глава 1. ВВЕДЕНИЕ В РЕЛЯЦИОННУЮ БАЗУ ДАННЫХ
 
   SQL (ОБЫЧНО ПРОИЗНОСИМАЯ КАК "SEEQUEL" ["СЭКВЭЛ"]) символизирует собой Структурированный Язык Запросов. Это - язык который дает вам возможностьсоздавать и работать в реляционных базах данных, которые являются наборами связанной информации сохраняемой в таблицах.
   Мир баз данных становится все более и более единым, что привело к необходимости создания стандартного языка который мог бы использоваться чтобы функционировать в большом количестве различных видов компьютерных сред. Стандартный язык позволит пользователям знающим один набор команд, использовать их чтобы создавать, отыскивать, изменять, и передавать информацию независимо от того работают ли они на персональном компьютере, сетевой рабочей станции, или на универсальной ЭВМ.
   В нашем все более и более взаимосвязанном компьютерном мире, пользователь снабженый таким языком, имеет огромное преимущество в использовании и обобщении информации из ряда источников с помощью большого колличества способов.
   Элегантность и независимость от специфики компьютерных технологий, а также его поддержка лидерами промышленности в области технологии реляционных баз данных, сделало SQL, и вероятно в течение обозримого будущего оставит его, основным стандартным языком. По этой причине, любой кто хочет работать с базами данных 90-х годов должен знать SQL.
   Стандарт SQL определяется ANSI (Американским Национальным Институтом Стандартов) и в данное время также принимается ISO (МЕЖДУНАРОДНОЙ ОРГАНИЗАЦИЕЙ ПО СТАНДАРТИЗАЦИИ). Однако, большинство коммерческих программ баз данных расширяют SQL без уведомления ANSI, добавляя разные другие особенности в этот язык, которые, как они считают, будут весьма полезны. Иногда они несколько нарушают стандарт языка, хотя хорошие идеи имеют тенденцию развиваться и вскоре становиться стандартами "рынка" сами по себе в силу полезности своих качеств. В этой книге, мы будем, в основном, следовать стандарту ANSI, но одновременно иногда будет показывать и некоторые наиболее общие отклонения от его стандарта.
   Вы должны проконсультироваться с документацией вашего пакета программ который вы будете использовать, чтобы знать где в нем этот стандарт видоизменен. ПРЕЖДЕ, ЧЕМ ВЫ СМОЖЕТЕ ИСПОЛЬЗОВАТЬ SQL, ВЫ должны понять что такое реляционные базы данных. В этой главе, мы это объясним, и покажем насколько реляционные базы данных полезны. Мы не будем обсуждать SQL именно здесь, и если вы уже знаете эти понятия довольно хорошо, вы можете просто пропустить эту главу. В любом случае, вы должны рассмотреть три таблицы которые предоставляются и объясняются в конце главы; они станут основой наших примеров в этой книге. Вторая копия этих таблиц находится Приложении E, и мы рекомендуем скопировать их для удобства ссылки к ним.
ЧТО ТАКОЕ - РЕЛЯЦИОННАЯ БАЗА ДАННЫХ?
   Реляционная база данных - это тело связанной информации, сохраняемой в двумерных таблицах. Напоминает адресную или телефонную книгу. В книге имеется большое количество входов, каждый из которых соответствует определеной особенности. Для каждой такой особенности, может быть несколько независимых фрагментов данных, например имя, телефонный номер, и адрес. Предположим, что вы должны сформатировать эту адресную книгу в виде таблицы со строками и столбцами. Каждая строка (называемая также записью ) будет соответствовать определенной особенности; каждый столбец будет содержать значение для каждого типа данных - имени, телефонного номера, и адреса представляемого в каждой строке. Адресная книга могла бы выглядеть следующим образом:
 

|    Имя                                   |    Телефон                               |    Адрес                                 |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    Gerry Farish<br style="margin: 0px; padding: 0px;"> |    ( 415)365-8775 127<br style="margin: 0px; padding: 0px;"> |    Primrose Ave.,SF<br style="margin: 0px; padding: 0px;"> |
|    Celia Brock<br style="margin: 0px; padding: 0px;"> |    ( 707)874-3553 246<br style="margin: 0px; padding: 0px;"> |    #3rd St.,Sonoma<br style="margin: 0px; padding: 0px;"> |
|    Yves Grillet<br style="margin: 0px; padding: 0px;"> |    ( 762)976-3665<br style="margin: 0px; padding: 0px;"> |    778 Modernas,Barcelona<br style="margin: 0px; padding: 0px;"> |


 
   То что вы получили является основой реляционной базы данных как и было определено в начале этого обсуждения - а именно, двумерной (строка и столбец ) таблицей информации. Однако, реляционные базы данных редко состоят из одной таблицы. Такая таблица меньше чем файловая система. Создав несколько таблиц взаимосвязанной информации, вы сможете выполнить более сложные и мощные операции с вашими данными. Мощность базы данных зависит от связи которую вы можете создать между фрагментами информации, а не от самого фрагмента информации.
 
### СВЯЗЫВАНИЕ ОДНОЙ ТАБЛИЦЫ С ДРУГОЙ
   Позвольте нам использовать пример нашей адресной книги чтобы начать обсуждение базы данных которая может реально использоваться в деловой ситуации. Предположим, что персонажи в нашей первой таблице (адресной книги ) - это пациенты больницы. В другой таблице, мы могли бы запомнить дополнительную информацию об этих пациентах. Столбцы второй таблицы могли бы быть помечены как Пациент, Доктор, Страховка, и Балланс.
   
   |    Пациент                               |    Доктор                                |    Страховка                             |    Балланс                               |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    Farish<br style="margin: 0px; padding: 0px;"> |    Drume<br style="margin: 0px; padding: 0px;"> |    B.C./B.S.<br style="margin: 0px; padding: 0px;"> |    $272.99<br style="margin: 0px; padding: 0px;"> |
|    Grillet<br style="margin: 0px; padding: 0px;"> |    Halben<br style="margin: 0px; padding: 0px;"> |    None<br style="margin: 0px; padding: 0px;"> |    $44. 76<br style="margin: 0px; padding: 0px;"> |
|    Brock<br style="margin: 0px; padding: 0px;"> |    Halben<br style="margin: 0px; padding: 0px;"> |    Health,Inc.<br style="margin: 0px; padding: 0px;"> |    $9077.47<br style="margin: 0px; padding: 0px;"> |

 
   Много мощных функций можно выполнить извлекая информацию из этих таблиц согласно указанным параметрам, особенно когда эти параметры включают в себя фрагменты информации свзанные в различных таблицах друг с другом. Например, возьмем - докторов. Предположим доктор Halben захотел получить номера телефонов всех своих пациентов. Чтобы извлечь эту информацию, он мог бы связать таблицу с номерами телефонов пациентов (по адресной книге ) с таблицей которая бы указывала, какой из пациентов - его. Хотя, в этом простом примере, он мог бы держать это в голове и сразу получать номера телефонов пациентов Grillet и Brock, эти таблицы могут быть слишком большими и слишком сложными. Программы реляционной базы данных разрабатывались для того чтобы обрабатывать большие и сложные совокупности данных такого типа, что очевидно является более универсальным методом в деловом мире. Даже если бы база данных больницы содержала сотни или тысячи имен - как это вероятно и бывает на практике - одна команда SQL могла бы выдать доктору Halben информацию в которой он нуждался почти немедленно.
### ПОРЯДОК СТРОК ПРОИЗВОЛЕН
   Чтобы поддерживать максимальную гибкость, строки таблицы, по определению, не должны находиться ни в каком определенном порядке. С этой точки зрения, в этом структура базы данных отличается от нашей адресной книги. Вход в адресную книгу обычно упорядочивается в алфавитном порядке. В системах с реляционной базой данных, имеется одна мощная возможность для пользоватей - это способность упорядочивать информацию так чтобы они могли восстанавливать ее.
   Рассмотрим вторую таблицу. Иногда Вам необходимо видеть эту информацию упорядоченной в алфавитном порядке по именам, иногда в возрастающем или убывающем порядке, а иногда сгруппированной по отношению к какому-нибудь доктору. Наложение порядка набора в строках будет сталкиваться со способностью заказчика изменять его, поэтому строки всегда рассматриваются как неупорядоченные. По этой причине, вы не можете просто сказать:" Мы хотим посмотреть пятую строку таблицы. " Пренебрегая порядком в котором данные вводились или любым другим критерием, мы определим, не ту строку, хотя она и будет пятой. Строки таблицы которые рассматриваются, не будут в какой-либо определенной последовательности.
### ИДЕНТИФИКАЦИЯ СТРОК (ПЕРВИЧНЫЕ КЛЮЧИ )
   По этим и другим причинам, вы должны иметь столбец в вашей таблице который бы уникально идентифицировал каждую строку. Обычно, этот столбец содержит номер - например, номер пациента назначаемый каждому пациенту. Конечно, вы могли бы использовать имя пациентов, но возможно что имеется несколько Mary Smiths; и в этом случае, вы не будете иметь другого способа чтобы отличить этих пациентов друг от друга.
   Вот почему номера так необходимы. Такой уникальный столбец( или уникальная группа столбцов ), используемый чтобы идентифицировать каждую строку и храненить все строки отдельно, называются - первичными ключами таблицы.
   Первичные ключи таблицы важный элемент в структуре базы данных. Они - основа вашей системы записи в файл; и когда вы хотите найти определенную строку в таблице, вы ссылаетесь к этому первичному ключу. Кроме того, первичные ключи гарантируют, что ваши данные имеют определенную целостность. Если первичный ключ правильно используется и поддерживается, вы будете знать что нет пустых строк таблицы и что каждая строка отличается от любой другой строки. Мы будем обсуждать ключи и далее когда поговорим относительно справочной целостности в Главе 19.
### СТОЛБЦЫ ИМЕНУЮТСЯ И НУМЕРУЮТСЯ
   В отличие от строк, столбцы таблицы (также называемые полями ) упорядочиваются и именуются. Таким образом, в нашей таблице адресной книги, возможно указать на " адрес столбца " или на " столбец 3 ". Конечно, это означает что каждый столбец данной таблицы должен иметь уникальное имя чтобы избежать неоднозначности. Лучше всего если эти имена указывают на содержание поля. В типовых таблицах этой книги, мы будем использовать такие сокращения для имени столбца, как cname для имени заказчика, и odate для даты порядка. Мы также дадим каждой таблице личный числовой номер столбца в качестве первичного ключа. Следующий раздел будет объяснять эти таблицы и их ключи более подробно.
### ТИПОВАЯ БАЗА ДАННЫХ
   Таблицы 1.1, 1.2, и 1.3 составляют реляционную базу данных которая является минимально достаточной чтобы легко ее отслеживать, и достаточно полной, чтобы иллюстрировать главные понятия и практику использования SQL.
   Эти таблицы напечатаны в этой главе а также в Приложении E. Так как они будут использоваться для иллюстрирования различных особенностей SQL по всей этой книге, мы рекомендуем чтобы вы скопировали их, для удобства ссылки к ним.
   Вы могли уже обратить внимание что первый столбец каждой таблицы содержит номера чьи значения различны для каждой строки. Как вы наверное и предположили, это - первичные ключи таблиц. Некоторые из этих номеров также показаны в столбцах других таблиц. В этом нет ничего неверного. Они поазывают связь между строками которые используют значение принимаемое из первичного ключа, и строками где это значение используется в самом первичном ключе.
 
   Таблица 1.1: Продавцы
  
  |    SNUM                                  |    SNAME                                 |    CITY                                  |    COMM                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    .12<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    .13<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    .11<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |    .15<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    .10<br style="margin: 0px; padding: 0px;"> |
 
   
Таблица 1.2: Заказчики

|    CNUM                                  |    CNAME                                 |     CITY                                 |    RATING                                |    SNUM                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2002<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    2003<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    SanJose<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    SanJose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |

Таблица 1.3: Порядки

|    ONUM                                  |    AMT                                   |    ODATE                                 |    CNUM                                  |    SNUM                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3001<br style="margin: 0px; padding: 0px;"> |    18.69<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3005<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3007<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |



   Например, поле snum в таблице Заказчиков указывает, какому продавцу назначен данный заказчик. Номер поля snum связан с таблицей Продавцов, которая дает информацию об этих продавцах. Очевидно, что продавец которому назначены заказчики должен уже существовать - то есть, значение snum из таблицы Заказчиков должно также быть представлено в таблице Продавцов. Если это так, то говорят, что "система находится в состоянии справочной целостности ".
 
   Этот вывод будет более полно и формально объяснен в Главе 19.
   ПРИМЕЧАНИЕ: Эти три представленых таблицы в тексте имеют русские имена - Продавцов, Заказчиков и Порядков, и далее будут упоминаться именно под этими именами. Имена любых других применяемых в книге таблиц будут написаны по английски что бы отличать их от наших базовых таблиц этой базы данных. Кроме того в целях однозначности, имена заказчиков, продавцов, Системных Каталогов а также полей в тексте, также будут даны на латыни.
   Таблицы приведены как пример к похожей ситуации в реальной жизни, когда вы будете использовать SQL чтобы следить за продавцами, их заказчиками, и порядками заказчиков. Давайте рассмотрим эти три таблицы и значения их полей.
 
   Здесь показаны столбцы Таблицы 1.1
   
   |    ПОЛЕ                                  |    СОДЕРЖАНИЕ                            |
|------------------------------------------|------------------------------------------|
|    snum<br style="margin: 0px; padding: 0px;"> |    уникальный номер назначенный каждому продавцу<br style="margin: 0px; padding: 0px;">   ( " номер служащего " ).<br style="margin: 0px; padding: 0px;"> |
|    sname<br style="margin: 0px; padding: 0px;"> |    имя продавца.<br style="margin: 0px; padding: 0px;"> |
|    city<br style="margin: 0px; padding: 0px;"> |    расположение продавца( город )<br style="margin: 0px; padding: 0px;"> |
|    comm<br style="margin: 0px; padding: 0px;"> |    комиссионные продавцов в десятичной форме<br style="margin: 0px; padding: 0px;"> |

 Таблица 1.2 содержит следующие столбцы:
 
|    ПОЛЕ                                  |    СОДЕРЖАНИЕ                            |
|------------------------------------------|------------------------------------------|
|    cnum<br style="margin: 0px; padding: 0px;"> |    уникальный номер назначенный каждому заказчику<br style="margin: 0px; padding: 0px;"> |
|    cname<br style="margin: 0px; padding: 0px;"> |    имя заказчика<br style="margin: 0px; padding: 0px;"> |
|    city<br style="margin: 0px; padding: 0px;"> |    расположение заказчика( город )<br style="margin: 0px; padding: 0px;"> |
|    rating<br style="margin: 0px; padding: 0px;"> |    код указывающего уровень предпочтения данного заказчика<br style="margin: 0px; padding: 0px;">   перед другими. Более высокий номер указывают на большее<br style="margin: 0px; padding: 0px;">   предпочтение( рейтинг )<br style="margin: 0px; padding: 0px;"> |
|    snum<br style="margin: 0px; padding: 0px;"> |    номер продавца назначенного этому заказчику<br style="margin: 0px; padding: 0px;">   ( из таблицы Продавцов )<br style="margin: 0px; padding: 0px;"> |

И имеются столбцы в Таблице 1.3:

|    ПОЛЕ                                  |    СОДЕРЖАНИЕ                            |
|------------------------------------------|------------------------------------------|
|    onum<br style="margin: 0px; padding: 0px;"> |    уникальный номер данный каждому приобретению<br style="margin: 0px; padding: 0px;"> |
|    amt<br style="margin: 0px; padding: 0px;"> |    значение суммы приобретений<br style="margin: 0px; padding: 0px;"> |
|    odate<br style="margin: 0px; padding: 0px;"> |    дата приобретения<br style="margin: 0px; padding: 0px;"> |
|    cnum<br style="margin: 0px; padding: 0px;"> |    номер заказчика делающего приобретение<br style="margin: 0px; padding: 0px;">   ( из таблицы Заказчиков )<br style="margin: 0px; padding: 0px;"> |
|    snum<br style="margin: 0px; padding: 0px;"> |    номер продавца продающего приобретение<br style="margin: 0px; padding: 0px;">   ( из таблицы Продавцов)<br style="margin: 0px; padding: 0px;"> |

 
### РЕЗЮМЕ
 
   Теперь вы знаете что такое реляционная база данных, понятие, которое звучит сложнее чем есть на самом деле. Вы также изучили некоторые фундаментальные принципы относительно того, как сделаны таблицы - как работают строки и столбцы, как первичные ключи отличают строки друга друга, и как столбцы могут ссылаться к значениям в других столбцах.
   Вы поняли что запись это синоним строки, и что поле это синоним столбца. Оба термина встречаются в обсуждении SQL, и мы будем использовать их в равной степени в этой книге.
   
## Глава 2. SQL : ОБЗОР.
 
   ЭТА ГЛАВА ПОЗАКОМИТ ВАС СО СТРУКТУРОЙ SQL языка а также с определенными общими выводами, такими как тип данных которые эти поля могут содержать и некоторые области неоднозначностей которые существуют в SQL.
   Она педназначена обеспечить связь с более конкретной информацией в последующих главах. Вы не должны запоминать каждую подробность упомянутую в этой главе. Краткий обзор представлен здесь в одной удобно размещеной области, многие подробности которой вы можете иметь чтобы в последствии ссылаться к ним по мере овладения языком. Мы поместили все это в начало книги чтобы ориентировать вас на мир SQL без упрощенного подхода к его проблемам и в тоже время дать Вам привычные в будущем места для ссылки к ним когда у Вас появятся вопросы. Этот материал может стать более понятным когда мы перейдем к описанию конкретных команд SQL, начинающихся с Главы 3.
### КАК РАБОТАЕТ SQL?
   SQL это язык ориентированный специально на реляционные базы данных.
   Он устраняет много работы которую вы должны были бы сделать если бы вы использовали универсальный язык программирования, напрмер C. Чтобы сформировать реляционную базу данных на C, вам необходимо было бы начать с самого начала. Вы должны были бы определить объект - называемый таблицей которая могла бы расти чтобы иметь любое число строк, а затем создавать постепенно процедуры для помещения значений в нее и извлечения из них. Если бы вы захотели найти некоторые определенные строки, вам необходимо было бы выполнить по шагам процедуру, подобную следующей :
 
   * Рассмотрите строку таблицы.
   * Выполните проверку - является ли эта строка одной из строк которая вам нужна.
   * Если это так, сохраните ее где-нибудь пока вся таблица не будет проверена.
   * Проверьте имеются ли другие строки в таблице.
   * Если имеются, возвратитесь на шаг 1.
   * Если строк больше нет, вывести все значения сохраненные в шаге 3.
 
   ( Конечно, это не фактический набор C команд, а только логика шагов которые должны были бы быть включены в реальную программу.) SQL сэкономит вам все это. Команды в SQL могут работать со всеми группами таблиц как с единым объектом и могут обрабатывать любое количество информации извлеченной или полученной из их, в виде единого модуля.
 
 ### ЧТО ДЕЛАЕТ ANSI?
   Как мы уже рассказывали в Введении, стандарт SQL определяется с помощью кода ANSI (Американский Национальный Институт Стандартов). ANSI не изобретал SQL. Это по существу изобретение IBM. Но другие компании подхватили SQL сразу же, по крайней мере одна компания (Oracle) отбила у IBM право на рыночную продажу SQL продуктов.
   После того как появился ряд конкурирующих программ SQL на рынке, ANSI определил стандарт к которому они должны быть приведены (определение таких стандартов и является функцией ANSI ).
   Однако после этого, появились некоторые проблемы. Возникли они в результате стандартизации ANSI ввиде некоторых ограничений. Так как не всегда ANSI определяет то что является наиболее полезным, то программы пытаются соответствовать стандарту ANSI не позволяя ему ограничивать их слишком сильно. Это, в свою очередь, ведет к случайным несогласованностям. Программы Баз Данных обычно дают ANSI SQL дополнительные особенности и часто ослабляют многие ограничения из большинства из них.
   Следовательно, общие разновидности ANSI будут также рассмотрены. Хотя мы очевидно не сможем объять каждое исключение или разновидность, удачные идеи имеют тенденцию к внедрению и использованию в различных программах даже когда они не определены стандартом ANSI.
   ANSI - это вид минимального стандарта и вы можете делать больше чем он позволяет, хотя и должны выполнять его указания при выполнении задач которые он определяет.
 
### ИНТЕРАКТИВНЫЙ И ВЛОЖЕННЫЙ SQL
   Имеются два SQL: Интерактивный и Вложенный. Большей частью, обе формы работают одинаково, но используются различно. Интерактивный SQL используется для функционирования непосредственно в базе данных чтобы производить вывод для использования его заказчиком. В этой форме SQL, когда вы введете команду, она сейчас же выполнится и вы сможете увидеть вывод (если он вообще получится) - немедленно.
   Вложенный SQL состоит из команд SQL помещенных внутри программ, которые обычно написаны на некотором другом языке (типа КОБОЛА или Паскаля).
   Это делает эти программы более мощными и эффективным. Однако, допуская эти языки, приходится иметь дело с структурой SQL и стилем управления данных который требует некоторых расширений к интерактивному SQL. Передача SQL команд во вложенный SQL является выдаваемой ("passed off") для переменных или параметров используемых программой в которую они были вложены.
   В этой книге, мы будем представлять SQL в интерактивной форме. Это даст нам возможность обсуждать команды и их эффекты не заботясь о том как они связаны с помощью интерфейса с другими языками. Интерактивный SQL - это форма наиболее полезная непрограммистам. Все что вы узнаете относительно интерактивного SQL в основном применимо и к вложенной форме. Изменения необходимые для использования вложенной формы будут использованы в последней главе этой книги.
 
### СУБПОДРАЗДЕЛЕНИЯ SQL
   И в интерактивной и во вложенной формах SQL, имеются многочисленные части, или субподразделения. Так как вы вероятно сталкнетесь с этой терминологией при чтении SQL, мы дадим некоторые пояснения.
   К сожалению, эти термины не используются повсеместно во всех реализациях. Они подчеркиваются ANSI и полезны на концептуальном уровне, но большинство SQL программ практически не обрабатывают их отдельно, так что они по существу становятся функциональными категориями команд SQL.
   DDL (Язык Определения Данных ) - так называемый Язык Описания Схемы в ANSI, состоит из команд которые создают объекты (таблицы, индексы, просмотры, и так далее ) в базе данных.
   DML (Язык Манипулирования Данными) - это набор команд которые определяют какие значения представлены в таблицах в любой момент времени.
   DCD (Язык Управления Данными) состоит из средств которые определяют, разрешить ли пользователю выполнять определенные действия или нет.
   Они являются составными частями DDL в ANSI. Не забывайте эти имена.
   Это не различные языки, а разделы команд SQL сгруппированных по их функциям.
 
### РАЗЛИЧНЫЕ ТИПЫ ДАННЫХ
 
   Не все типы значений которые могут занимать поля таблицы - логически одинаковые. Наиболее очевидное различие - между числами и текстом. Вы не можете помещать числа в алфавитном порядке или вычитать одно имя из другого. Так как системы с реляционной базой данных базируются на связях между фрагментами информации, различные типы данных должны понятно отличаться друга от друга, так чтобы соответствующие процессы и срав нения. могли быть в них выполнены.
   В SQL, это делается с помощью назначения каждому полю - типа данных который укаазывает на тип значения которое это поле может содержать.
   Все значения в данном поле должны иметь одинаковый тип. В таблице Заказчиков, например, cname и city - содержат строки текста для оценки, snum, и cnum - это уже номера. По этой причине, вы не можете ввести значение Highest(Наивысший) или значение None(Никакой) в поле rating, которое имеет числовой тип данных. Это ограничение удачно, так как оно налагает некоторую структурность на ваши данные. Вы часто будете сравнивать некоторые или все значения в данном поле, поэтому вы можете выполнять действие только на определенных строках а не на всех. Вы не могли бы сделать этого если бы значения полей имели смешанный тип данных.
   К сожалению, определение этих типов данных является основной областью в которой большинство коммерческих программ баз данных и официальный стандарт SQL, не всегда совпадают. ANSI SQL стандарт распознает только текст и тип номера, в то время как большинство коммерческих программ используют другие специальные типы. Такие как, DATA(ДАТА) и TIME(ВРЕМЯ) - фактически почти стандартные типы( хотя точный формат их меняется). Некоторые пакеты также поддерживают такие типы, как например MONEY(ДЕНЬГИ) и BINARY (ДВОИЧНЫЕ). (MONEY - это специальная система исчисления используемая компьютерами. Вся информация в компьютере передается двоичными числами и затем преобразовываются в другие системы, что бы мы могли легко использовать их и понимать.)
   ANSI определяет несколько различных типов значений чисел, различия между которыми - довольно тонки и иногда их путают. Разрешенные ANSI типы данных перечислены в Приложении B.
   Сложность числовых типов ANSI можно, по крайней мере частично,объяснить усилием сделать вложенный SQL, совместимым с рядом других языков.
   Два типа чисел ANSI, INTEGER(ЦЕЛОЕ ЧИСЛО) и DECIMAL (ДЕСЯТИЧНОЕ ЧИСЛО) (которые можно сокращать как INT и DEC, соответственно ), будут адекватны для наших целей, также как и для целей большинства практических деловых прикладных программ. Естественно, что тип ЦЕЛОЕ можно представить как ДЕСЯТИЧНОЕ ЧИСЛО которое не содержит никаких цифр справа от десятичной точки.
   Тип для текста - CHAR (или СИМВОЛ ), который относится к строке текста. Поле типа CHAR имеет определенную длину, которая определяется максимальным числом символов которые могут быть введены в это поле.
   Больше всего реализаций также имеют нестандартный тип называемый VARCHAR(ПЕРЕМЕННОЕ ЧИСЛО СИМВОЛОВ), который является текстовой строкой которая может иметь любую длину до определенного реализацией максимума (обычно 254 символа). CHARACTER и VARCHAR значения включаются в одиночные кавычки как "текст". Различие между CHAR и VARCHAR в том, что CHAR должен резервировать достаточное количество памяти для максимальной длины строки, а VARCHAR распределяет память так как это необходимо.
   Символьные типы состоят из всех печатных символов, включая числа.
   Однако, номер 1 не то же что символ "1". Символ "1" - только другой печатный фрагмент текста, не определяемый системой как наличие числового значения 1.
   Например 1 + 1=2, но "1" + "1" не равняется "2".
   Символьные значения сохраняются в компьютере как двоичные значения, но показываются пользователю как печатный текст. Преобразование следует за форматом определяемым системой которую вы используете. Этот формат преобразования будет одним из двух стандартных типов (возможно с расширениями) используемых в компьютерных системах: в ASCII коде (используемом во всех персональных и малых компьютерах ) и EBCDIC коде (Расширенном Двоично-Десятичном Коде Объмена Информации) (используемом в больших компьютерах). Определенные операции, такие как упорядочивание в алфавитном порядке значений поля, будет изменяться вместе с форматом. Применение этих двух форматов будет обсуждаться в Главе 4.
   Мы должны следить за рынком, а не ANSI, в использовании типа называемого DATE(ДАТОЙ). (В системе, которая не распознает тип ДАТА, вы конечно можете обьявить дату как символьное или числовое поле, но это сделает большинство операций более трудоемкими. ) Вы должны смотреть свою документацию по пакету программ которые вы будете использовать, чтобы выяснить точно, какие типы данных она поддерживает.   

 
### SQL НЕСОГЛАСОВАННОСТИ
   Вы можете понять из предшествующего обсуждения, что имеются самостоятельные несогласованности внутри продуктов мира SQL. SQL появился из коммерческого мира баз данных как инструмент, и был позже превращен в стандарт ANSI. К сожалению, ANSI не всегда определяет наибольшую пользу, поэтому программы пытаются соответствовать стандарту ANSI не позволяя ему ограничивать их слишком сильно. ANSI - вид минимального стандарта - вы можете делать больше чем он это позволяет, но вы должны быть способны получить те же самые результаты что и при выполнении той же самой задачи.
 
### ЧТО ТАКОЕ - ПОЛЬЗОВАТЕЛЬ?
   SQL обычно находится в компьютерных системах которые имеют больше чем одного пользователя, и следовательно должны делать различие между ними (ваше семейство PC может иметь любое число пользователей, но оно обычно не имеет способов чтобы отличвать одного от другого). Обычно, в такой системе, каждый пользователь имеет некий вид кода проверки прав который идентифицирует его или ее (терминология изменяется). В начале сеанса с компьютером, пользователь входит в систему (регистрируется), сообщая компьютеру кто этот пользователь, идентифицированный с помощью определенного ID(Идентификатора). Любое колличество людей использующих тот же самый ID доступа, являются отдельными пользователями; и аналогично, один человек может представлять большое количество пользователей (в разное время ), используя различные доступные Идентификаторы.
   SQL следует этому примеру. Действия в большинстве сред SQL приведены к специальному доступному Идентификатору который точно соответствует определенному пользователю. Таблица или другой объект принадлежит пользователю, который имеет над ним полную власть. Пользователь может или не может иметь привилегии чтобы выполнять действие над объектом.
   Для наших целей, мы договоримся, что любой пользователь имеет привилегии необходимые чтобы выполнять любое действие, пока мы не возвратимся специально к обсуждению привилегий в Главе 22.
   Специальное значение - USER(ПОЛЬЗОВАТЕЛЬ) может использоваться как аргумент в команде. Оно указывает на доступный Идентификатор пользователя, выдавшего команду.
 
### УСЛОВИЯ И ТЕРМИНОЛОГИЯ
   Ключевые слова - это слова которые имеют специальное значение в SQL. Они могут быть командами, но не текстом и не именами объектов. Мы будем выделять ключевые слова печатая их ЗАГЛАВНЫМИ БУКВАМИ. Вы должны соблюдать осторожность чтобы не путать ключевые слова с терминами.
   SQL имеет определенные специальные термины которые используются чтобы описывать его. Среди них - такие слова как запрос, предложение, и предикат, которые являются важнейшими в описании и понимании языка но не означают что-нибудь самостоятельное для SQL.
   Команды, или предложения, являются инструкциями которыми Вы обращаетесь к SQL базе данных. Команды состоят из одной или более отдельных логических частей называемых предложениями. Предложения начинаются ключевым словом для которого они являются проименованными, и состоят из ключевых слов и аргументов. Например предложения с которыми вы можете сталкиваться - это " FROM Salespeope " и " WHERE city="London".
   Аргументы завершают или изменяют значение предложения. В примерах выше, Salespeople - аргумент, а FROM - ключевое слово предложения FROM.
   Аналогично, " city="London" " - агрумент предложения WHERE. Объекты - структуры в базе данных которым даны имена и сохраняются в памяти.
   Они включают в себя базовые таблицы, представления (два типа таблиц), и индексы.
   Чтобы показать Вам как формируются команды, мы будем делать это на примерах. Имеется, однако, более формальный метод описания команд использующих стандартизированные условные обозначения. Мы будем использовать его в более поздних главах, для удобства чтобы понимать эти условные обозначения в случае если вы столкнетесь с ним в других SQL документах. Квадратные скобки ([ ] ) будут указывать части которые могут неиспользоваться, а многоточия (... ) указывать что все предшествующее им может повторяться любое число раз. Слова обозначенные в угловых скобках (&lt;>) - специальные термины которые объясняют что они собой представляют.
   Мы упростили стандартную терминологию SQL значительно, но без ухудшения его понимания.
 
### РЕЗЮМЕ
 
   Мы быстро прошли основы в этой главе. Но нашим намерением и было - просто пролететь над основами SQL, так чтобы вы могли понять идею относительно всего объема. Когда мы возвратимся к основе в следующей главе, некоторые вещи станут более конкретными. Теперь вы знаете кое-что относительно SQL - какова его структура, как он используется, как он представляет данные, и как они определяются (и некоторые несогласованности появляющиеся при этом ), и некоторые условные обозначения и термины используемые чтобы описывать их. Все это - много информации для одной главы; мы не ожидаем что бы вы запомнили все эти подробности, но вы сможете вернуться позже к ним если понадобится. По Главе 3, мы будем идти, показывая конкретно, как формируются команды и что они делают. Мы представим вам команду SQL используемую чтобы извлекать информацию из таблиц, и которая является наиболее широко используемой командой в SQL. К концу этой главы, вы будете способны извлекать конкретную информацию из вашей базы данных с высокой степенью точности.
   
## Глава 3. ИСПОЛЬЗОВАНИЕ SQL ДЛЯ ИЗВЛЕЧЕНИЯ ИНФОРМАЦИИ ИЗ ТАБЛИЦ.
 
   В ЭТОЙ ГЛАВЕ МЫ ПОКАЖЕМ ВАМ КАК ИЗВЛЕКАТЬ информацию из таблиц. Вы узнаете как опускать или переупорядочивать столбцы и как автоматически устранять избыточность данных из вашего вывода. В заключение, вы узнаете как устанавливать условие( проверку ) которую вы можете использовать чтобы определить какие строки таблицы используются в выводе. Эта последняя особенность, будет далее описана в более поздних главах и является одной из наиболее изящных и мощных в SQL.
### СОЗДАНИЕ ЗАПРОСА
   Как мы подчеркивали ранее, SQL символизирует собой Структурированный Язык Запросов. Запросы - вероятно наиболее часто используемый аспект SQL. Фактически, для категории SQL пользователей, маловероятно чтобы кто-либо использовал этот язык для чего-то друго. По этой причине, мы будем начинать наше обсуждение SQL с обсуждения запроса и как он выполняется на этом языке.
### ЧТО ТАКОЕ ЗАПРОС?
   Запрос - команда которую вы даете вашей программе базы данных, и которая сообщает ей чтобы она вывела определенную информацию из таблиц в память. Эта информация обычно посылается непосредственно на экран компьютера или терминала которым вы пользуетесь, хотя, в большинстве случаев, ее можно также послать принтеру, сохранить в файле (как объект в памяти компьютера ), или представить как вводную информацию для другой команды или процесса.
### ГДЕ ПРИМЕНЯЮТСЯ ЗАПРОСЫ?
   Запросы обычно рассматриваются как часть языка DML. Однако, так как запрос не меняет информацию в таблицах, а просто показывает ее пользователю, мы будем рассматривать запросы как самостоятельную категорию среди команд DML которые производят действие, а не просто показывают содержание базы данных.
   Все запросы в SQL состоят из одиночной команды. Структура этой команды обманчиво проста, потому что вы должны расширять ее так чтобы выполнить высоко сложные оценки и обработки данных. Эта команда называется - SELECT(ВЫБОР).
### КОМАНДА SELECT
   В самой простой форме, команда SELECT просто инструктирует базу данных чтобы извлечь информацию из таблицы. Например, вы могли бы вывести таблицу Продавцов напечатав следующее:
 
   SELECT snum, sname, sity, comm
   FROM Salespeople;
   Вывод для этого запроса показывается в таблице 3.1.
 
### SQL Execution Log
 
    SELECT snum, sname, sity, comm FROM Salespeople;
    
|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    0.13<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |    0.15<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    0.10<br style="margin: 0px; padding: 0px;"> |

Таблица 3.1: команда SELECT

   Другими словами, эта команда просто выводит все данные из таблицы. Большинство программ будут также давать заголовки столбца как выше, а некоторые позволяют детальное форматирование вывода, но это уже вне стандартной спецификации.
   Имеется объяснение каждой части этой команды:
   **SELECT** Ключевое слово которое сообщает базе данных что эта команда - запрос. Все запросы начинаются этим словом, сопровождаемым пробелом.
   snum, sname Это - список столбцов из таблицы которые выбираются запросом. Любые столбцы не перечисленные здесь не будут включены в вывод команды. Это, конечно, не значит что они будут удалены или их информация будет стерта из таблиц, потому что запрос не воздействует на информацию в таблицах; он только показывает данные.
   **FROM FROM** - ключевое слово, подобно **SELECT**, которое должно Salespeople быть представлено в каждом запросе. Оно сопровождается пробелом и затем именем таблицы используемой в качестве источника информации. В данном случае - это таблица Продавцов(Salespeople).
   Точка с запятой используется во всех интерактивных командах SQL чтобы сообщать базе данных что команда заполнена и готова выполниться.
   В некоторых системах наклонная черта влево (\) в строке, является индикатором конца команды.
   Естественно, запрос такого характера не обязательно будет упорядочивать вывод любым указаным способом. Та же самая команда выполненная с теми же самыми данными но в разное время не сможет вывести тот же самый порядок. Обычно, строки обнаруживаются в том порядке в котором они найдены в таблице, поскольку как мы установили в предыдущей главе - этот порядок произволен. Это не обязательно будет тот порядок в котором данные вводились или сохранялись. Вы можете упорядочивать вывод командами SQL непосредственно: с помощью специального предложения.
   Позже, мы покажем как это делается. А сейчас, просто усвойте, что в отсутствии явного упорядочения, нет никакого определенного порядка в вашем выводе.
   Наше использование возврата (Клавиша ENTER ) является произвольным. Мы должны точно установить как удобнее составить запрос, в несколько строк или в одну строку, следующим образом:
 
    SELECT snum, sname, city, comm FROM Salespeople;
   С тех пор как SQL использует точку с запятой чтобы указывать конец команды, большинство программ SQL обрабатывают возврат (через нажим Возврат или клавишу ENTER ) как пробел. Это - хорошая идея чтобы использовать возвраты и выравнивание что мы делали это ранее, чтобы сделать ваши команды более легкими для чтения и более правильными.
### ВЫБИРАЙТЕ ВСЕГДА САМЫЙ ПРОСТОЙ СПОСОБ
   Если вы хотите видеть каждый столбец таблицы, имеется необязательное сокращение которое вы можете использовать. Звездочка (*) может применяться для вывода полного списка столбцов следующим образом:
 
    SELECT *
    FROM Salespeople;
   Это привыведет к тому же результату что и наша предыдущая команда.
### ОПИСАНИЕ SELECT
   В общем случае, команда SELECT начинается с ключевого слова SELECT, сопровождаемого пробелом. После этого должен следовать список имен столбцов которые вы хотите видеть, отделяемые запятыми. Если вы хотите видеть все столбцы таблицы, вы можете заменить этот список звездочкой (*). Ключевое слово FROM следующее далее, сопровождается пробелом и именем таблицы запрос к которой делается. В заключение, точка с запятой (; ) должна использоваться чтобы закончить запрос и указать что команда готова к выполнению.
   

### ПРОСМОТР ТОЛЬКО ОПРЕДЕЛЕННОГО СТОЛБЦА ТАБЛИЦЫ
   Команда SELECT способна извлечь строго определенную информацию из таблицы. Сначала, мы можем предоставить возможность увидеть только определенные столбцы таблицы. Это выполняется легко, простым исключением столбцов которые вы не хотите видеть, из части команды SELECT. Например, запрос
 
    SELECT sname, comm
    FROM Salespeople;
 
   будет производить вывод показанный в Таблице 3.2.
 
    SQL Execution Log
    SELECT snum, comm FROM Salespeople;
    
|    sname                                 |    comm                                  |
|------------------------------------------|------------------------------------------|
|    Peel<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    Serres<br style="margin: 0px; padding: 0px;"> |    0.13<br style="margin: 0px; padding: 0px;"> |
|    Motika<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |
|    Rifkin<br style="margin: 0px; padding: 0px;"> |    0.15<br style="margin: 0px; padding: 0px;"> |
|    Axelrod<br style="margin: 0px; padding: 0px;"> |    0.10                                  |


   Таблица 3.2: Выбор определенных столбцов
   Могут иметься таблицы которые имеют большое количество столбцов содержащих данные, не все из которых являются относящимися к поставленой задаче. Следовательно, вы можете найти способ подбора и выбора только полезных для Вас столбцов.
###  ПЕРЕУПОРЯДОЧЕНИЕ СТОЛБЦА
   Даже если столбцы таблицы, по определению, упорядоченны, это не означает что вы будете восстанавливать их в том же порядке. Конечно, звездочка (*) покажет все столбцы в их естественном порядке, но если вы укажете столбцы отдельно, вы можете получить их в том порядке котором хотите. Давайте рассмотрим таблицу Порядков, содержащую дату приобретения(odate), номер продавца(snum), номер порядка(onum), и суммы приобретения(amt):
 
    SELECT odate, snum, onum, amt
    FROM Orders;
 
   Вывод этого запроса показан Таблице 3.3.
 
    SQL Execution Log
    SELECT odate, snum, onum, amt FROM Orders;
    
|    odate                                 |    snum                                  |    onum                                  |    amt                                   |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |    3001<br style="margin: 0px; padding: 0px;"> |    18.69<br style="margin: 0px; padding: 0px;"> |
|    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |
|    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |
|    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |    3005<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |
|    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |    3006<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |
|    10/04/1990<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |
|    10/04/1990<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |    3007<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |
|    10/05/1990<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |
|    10/06/1990<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |    3010<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |
|    10/06/1990<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |


   Рисунок 3.3: Реконструкция столбцов
   Как вы можете видеть, структура информации в таблицах - это просто основа для активной перестройки структуры в SQL.
    УДАЛЕНИЕ ИЗБЫТОЧНЫХ ДАННЫХ
   **DISTINCT** (ОТЛИЧИЕ) - аргумент который обеспечивает Вас способом устранять двойные значения из вашего предложения SELECT. Предположим что вы хотите знать какие продавцы в настоящее время имеют свои порядки в таблице Порядков. Под порядком (здесь и далее) будет пониматься запись в таблицу Порядков, регистрирующую приобретения сделанные в определенный день определенным заказчиком у определенного продавца на определенную сумму). Вам не нужно знать, сколько порядков имеет каждый; вам нужен только список номеров продавцов (snum). Поэтому Вы можете ввести:
 
    SELECT snum
    FROM Orders;
 
   для получения вывода показанного в Таблице 3.4
 
    SQL Execution Log
    SELECT snum FROM Orders;
    
|    snum                                  |
|------------------------------------------|
|    1007<br style="margin: 0px; padding: 0px;"> |
|    1001<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |
|    1001<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |
|    1001                                  |

Таблица 3.4: SELECT с дублированием номеров продавцов.
 
   Для получения списка без дубликатов, для удобочитаемости, вы можете ввести следующее:
    SELECT DISTINCT snum
    FROM Orders;
 
   Вывод для этого запроса показан в Таблице 3.5.
   Другими словами, DISTINCT следит за тем, какие значения были ранее, так что бы они не были продублированы в списке. Это - полезный способ избежать избыточности данных, но важно что бы при этом вы понимали что вы делаете. Если вы не хотите потерять некоторые данные, вы не должны безоглядно использовать DISTINCT, потому что это может скрыть какую-то проблему или какие-то важные данные. Например, вы могли бы предположить что имена всех ваших заказчиков различны. Если кто-то помещает второго Clemens в таблицу Заказчиков, а вы используете SELECT DISTINCT cname, вы не будете даже знать о существовании двойника. Вы можете получить не того Clemens и даже не знать об этом. Так как вы не ожидаете избыточности, в этом случае вы не должны использовать DISTINCT.
### ПАРАМЕТРЫ DISTINCT
   DISTINCT может указываться только один раз в данном предложении SELECT. Если предложение выбирает многочисленные поля,
 
    SQL Execution Log
    SELECT DISTINCT snum FROM Orders;

|    snum                                  |
|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |


   Таблица 3.5: SELECT без дублирования
   DISTINCT опускает строки где все выбранные поля идентичны. Строки в которых некоторые значения одинаковы а некоторые различны - будут сохранены. DISTINCT, фактически, приводит к показу всей строки вывода, не указывая полей (за исключением когда он используется внутри агрегатных функций, как описано в Главе 6 ), так что нет никакого смысла чтобы его повторять.
### DISTINCT ВМЕСТО ALL
   Вместо DISTINCT, вы можете указать - ALL. Это будет иметь противоположный эффект, дублирование строк вывода сохранится. Так как это - тот же самый случай когда вы не указываете ни DISTINCT ни ALL, то ALL - по существу скорее пояснительный, а не действующий аргумент.
 
### КВАЛИФИЦИРОВАННЫЙ ВЫБОР ПРИ ИСПОЛЬЗОВАНИИ ПРЕДЛОЖЕНИЙ
   Таблицы имеют тенденцию становиться очень большими, поскольку с течением времени, все большее и большее количество строк в нее добавляется. Поскольку обычно из них только определенные строки интересуют вас в данное время, SQL дает возможность вам устанавливать критерии чтобы определить какие строки будут выбраны для вывода.
   WHERE - предложение команды SELECT, которое позволяет вам устанавливать предикаты, условие которых может быть или верным или неверным для любой строки таблицы. Команда извлекает только те строки из таблицы для которой такое утверждение верно. Например, предположим вы хотите видеть имена и комиссионные всех продавцов в Лондоне. Вы можете ввести такую команду:
 
    SELECT sname, city
    FROM Salespeople;
    WHERE city="LONDON";
   Когда предложение WHERE представлено, программа базы данных просматривает всю таблицу по одной строке и исследует каждую строку чтобы определить верно ли утверждение. Следовательно, для записи Peel, программа рассмотрит текущее значение столбца city, определит что оно равно "London", и включит эту строку в вывод. Запись для Serres не будет включена, и так далее.
   Вывод для вышеупомянутого запроса показан в Таблице 3.6.
   
    SQL Execution Log
    SELECT sname, city FROM Salespeople WHERE city='London'
    
|    sname city                            |
|------------------------------------------|
|    Peel London<br style="margin: 0px; padding: 0px;"> |
|    Motika London<br style="margin: 0px; padding: 0px;"> |

 
   Рисунок 3.6: SELECT c предложением WHERE
   Давайте попробуем пример с числовым полем в предложении WHERE. Поле rating таблицы Заказчиков предназначено чтобы разделять заказчиков на группы основанные на некоторых критериях которые могут быть получены в итоге через этот номер. Возможно это - форма оценки кредита или оценки основанной на томе предыдущих приобретений. Такие числовые коды могут быть полезны в реляционных базах данных как способ подведения итогов сложной информации. Мы можем выбрать всех заказчиков с рейтингом 100, следующим образом:
 
    SELECT *
    FROM Customers
    WHERE rating=100;
   Одиночные кавычки не используются здесь потому, что оценка - это числовое поле. Результаты запроса показаны в Таблице 3.7.
   Предложение WHERE совместимо с предыдущим материалом в этой главе. Другими словами, вы можете использовать номера столбцов, устранять дубликаты, или переупорядочивать столбцы в команде SELECT которая использует WHERE. Однако, вы можете изменять порядок столбцов для имен только в предложении SELECT, но не в предложении WHERE.
   
    SQL Execution Log
       SELECT * FROM Customers WHERE rating=100;

|    сnum                                  |    cname                                 |    city                                  |     rating                               |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |


   Рисунок 3.7: SELECT с числовым полем в предикате
### РЕЗЮМЕ
   Теперь вы знаете несколько способов заставить таблицу давать вам ту информацию какую вы хотите, а не просто выбрасывать наружу все ее содержание. Вы можете переупорядочивать столбцы таблицы или устранять любую из них. Вы можете решать, хотите вы видеть дублированные значения или нет.
   Наиболее важно то, что вы можете устанавливать условие называемое предикатом которое определяет или не определяет указанную строку таблицы из тысяч таких же строк, будет ли она выбрана для вывода.
   Предикаты могут становиться очень сложными, предоставляя вам высокую точность в решении, какие строки вам выбирать с помощью запроса. Именно эта способность решать точно, что вы хотите видеть, делает запросы SQL такими мощными. Следующие несколько глав будут посвещены, в большей мере, особенностям которые расширяют мощность предикатов. В Главе 4, вам будут представлены операторы иные чем те которые используются в условиях предиката, а также способы объединения многочисленых условий в единый предикат.
### РАБОТА С SQL
 
   * Напишите команду SELECT которая бы вывела номер порядка, сумму, и дату для всех строк из таблицы Порядков.
   * Напишите запрос который вывел бы все строки из таблицы Заказчиков для которых номер продавца=1001.
   * Напишите запрос который вывел бы таблицу со столбцами в следующем порядке: city, sname, snum, comm.
   * Напишите команду SELECT которая вывела бы оценку(rating), сопровождаемую именем каждого заказчика в San Jose.
   * Напишите запрос который вывел бы значения snum всех продавцов в текущем порядке из таблицы Порядков без каких бы то ни было повторений.
   
## Глава 4. ИСПОЛЬЗОВАНИЕ РЕЛЯЦИОННЫХ И БУЛЕВЫХ ОПЕРАТОРОВ ДЛЯ СОЗДАНИЯ БОЛЕЕ ИЗОЩРЕННЫХ ПРЕДИКАТОВ
 
   В ГЛАВЕ 3, ВЫ УЗНАЛИ ЧТО ПРЕДИКАТЫ МОГУТ оценивать равенство оператора как верного или неверного. Они могут также оценивать другие виды связей кроме равенств. Эта глава будет исследовать другие реляционные операторы используемые в SQL. Вы также узнаете как использовать операторы Буля, чтобы изменять и объединять значения предиката. С помощью операторов Буля (или проще говоря логических операторов), одиночный предикат может содержать любое число условий. Это позволяет вам создавать очень сложные предикаты. Использование круглых скобок в структуре этих сложных предикатов будет также объясняться.
### РЕЛЯЦИОННЫЕ ОПЕРАТОРЫ
   Реляционный оператор - математический символ который указывает на определенный тип сравнения между двумя значениями. Вы уже видели как используются равенства, такие как 2 + 3 = 5 или city = "London". Но также имеются другие реляционные операторы. Предположим что вы хотите видеть всех Продавцов с их комиссионными выше определенного значения.

  Вы можете использовать тип сравнения "больше чем" - (>). Реляционные операторы которыми распологает SQL :
 
    = Равный
    \> Больше чем
    \< Меньше чем|    snum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2004<br style="margin: 0px; padding: 0px;"> |    Crass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cirneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |

    \>= Больше чем или равно
    <= Меньше чем или равно
    <> Не равно

   Эти операторы имеют стандартные значения для числовых значений. Для значения символа, их определение зависит от формата преобразования, ASCII или EBCDIC, который вы используете. SQL сравнивает символьные значения в терминах основных номеров как определено в формате преобразования. Даже значение символа, такого как "1", который представляет номер, не обязательно равняется номеру который он представляет. Вы можете использовать реляционные операторы чтобы установить алфавитный порядок - например, "a" < "n" где средство a первое в алфавитном порядке - но все это ограничивается с помощью параметра преобразования формата.
   И в ASCII и в EBCDIC, символы - по значению: меньше чем все другие символы которым они предшествуют в алфавитном порядке и имеют один вариант( верхний или нижний). В ASCII, все символы верхнего регистра меньше чем все символы нижнего регистра, поэтому "Z" < "a", а все номера - меньше чем все символы, поэтому "1" < "Z". То же относится и к EBCDIC. Чтобы сохранить обсуждение более простым, мы допустим что вы будете использовать текстовый формат ASCII. Проконсультируйтесь с вашей документацией системы если вы неуверены какой формат вы используете или как он работает.
   Значения сравниваемые здесь называются - скалярными значениями. Скалярные значения производяться скалярными выражениями; 1 + 2 - это скалярное выражение которое производит скалярное значение 3. Скалярное значение может быть символом или числом, хотя очевидно что только номера используются с арифметическими операторами, такими как +(плюс) или *(звезда).
   Предикаты обычно сравнивают значения скалярных величин, используя или реляционные операторы или специальные операторы SQL чтобы увидеть верно ли это сравнение. Некоторые операторы SQL описаны в Главе 5.
   Предположим что вы хотите увидеть всех заказчиков с оценкой(rating) выше 200. Так как 200 - это скалярное значение, как и значение в столбце оценки, для их сравнения вы можете использовать реляционный оператор.
 
    SELECT *
    FROM Customers
    WHERE rating > 200;
 
   Вывод для этого запроса показывается в Таблице 4.1.
   Конечно, если бы мы захотели увидеть еще и заказчиков с оценкой равной 200, мы стали бы использовать предикат
 
    rating >=200
### БУЛЕВЫ ОПЕРАТОРЫ
   Основные Булевы операторы также распознаются в SQL. Выражения Буля - являются или верными или неверными, подобно предикатам. Булевы операторы связывают одно или более верных/неверных значений и производят едиственное верное/или/неверное значение. Стандартными операторами Буля распознаваемыми в SQL являются:
 
    AND, OR, и NOT.
 
SQL Execution Log
 
    SELECT * FROM Customers WHERE rating > 200;
    
  Таблица 4.1: Использование больше чем (>)
   Существуют другие, более сложные, операторы Буля (типа "исключенный или"), но они могут быть сформированы из этих трех простых операторов - AND, OR, NOT.
   Как вы можете понять, Булева верня / неверная логика - основана на цифровой компьютерной операции; и фактически, весь SQL( или любой другой язык ) может быть сведен до уровня Булевой логики.
   Операторы Буля и как они работают
 
   * AND берет два Буля (в форме A AND B) как аргументы и оценивает их по отношению к истине, верны ли они оба.
   * OR берет два Буля (в форме A OR B) как аргументы и оценивает на правильность, верен ли один из них.
   * NOT берет одиночный Булев (в форме NOT A) как аргументы и заменяет его значение с неверного на верное или верное на неверное.
 
   Связывая предикаты с операторами Буля, вы можете значительно увеличить их возможности. Предположим вы хотите видеть всех заказчиков в San Jose которые имеют оценку(рейтинг) выше 200:
 
    SELECT *
    FROM Customers
    WHERE city=" San Jose'
    AND rating > 200;
 
   Вывод для этого запроса показан на Таблице 4.2. Имеется только один заказчик который удовлетворяет этому условию.
   Если вы же используете OR вы получите всех заказчиков которые находились в San Jose или(OR) которые имели оценку выше 200.
 
SQL Execution Log

   SELECT * FROM Customers WHERE city='San Jose' AND rating > 200;
   
|    сnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2008<br style="margin: 0px; padding: 0px;"> |    Cirneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |


   Таблица 4.2: SELECT использующий AND
   
    SELECT *
    FROM Customers
    WHERE city=" San Jose'
    OR rating > 200;
   Вывод для этого запроса показывается в Таблице 4.3.
   NOT может использоваться для инвертирования значений Буля. Имеется пример запроса с NOT:
   
    SELECT *
    FROM Customers
    WHERE city=" San Jose'
    OR NOT rating > 200;
 
   Вывод этого запроса показывается в Таблице 4.4.
SQL Execution Log

    SELECT * FROM Customers WHERE city='San Jose' OR rating > 200;
    
|    сnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2003<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cirneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |

   Рисунок 4.4: SELECT использующий NOT
   Все записи за исключением Grass были выбраны. Grass не был в San Jose, и его оценка была больше чем 200, так что он потерпел неудачу при обеих проверках. В каждой из других строк встретился один или другой или оба критериев. Обратите внимание что оператор NOT должен предшествовать Булеву оператору, чье значение должно измениться, и не должен помещаться перед реляционным оператором. Например неправильным вводом оценки предиката будет:
 
    rating NOT > 200
 
   Он выдаст другую отметку. А как SQL оценит следующее?
 
    SELECT *
    FROM Customers
    WHERE NOT city=" San Jose'
    OR rating > 200;
   NOT применяется здесь только к выражению city='SanJose', или к выражению rating > 200 тоже ? Как и написано, правильный ответ будет прежним. SQL может применять NOT с выражением Буля только сразу после него. Вы можете получить другой результат при команде:
   
    SELECT *
    FROM Customers
    WHERE NOT( city=" San Jose'
    OR rating > 200 );
   Здесь SQL понимает круглые скобки как означающие, что все внутри них будет оцениваться первым и обрабатываться как единое выражение с помощью всего что снаружи них (это является стандартной интерпретацией математике). Другими словами, SQL берет каждую строку и определяет, соответствует ли истине равенство city =" San Jose' или равенство rating > 200. Если любое условие верно, выражение Буля внутри круглых скобок верно. Однако, если выражение Буля внутри круглых скобок верно, предикат как единое целое неверен, потому что NOT преобразует верно в неверно и наоборот.
   Вывод для этого запроса - показывается в Рисунке 4.5. Имеется намеренно сложный пример. Посмотрим сможете ли вы проследить его логику (вывод показан в Рисунке 4.6 ):
   
    SELECT *
    FROM Orders
    WHERE NOT ((odate=10/03/1990 AND snum >1002)
    OR amt > 2000.00);
 
SQL Execution Log

    SELECT * FROM Customers WHERE NOT
    (city='San Jose' OR rating > 200);
    
|    сnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2002<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |

Рисунок 4.5: SELECT использующий NOT и вводное предложение
 
SQL Execution Log

    SELECT * FROM Orders WHERE NOT
    ((odate=10/03/1990 AND snum > 1002)OR amt > 2000.00);
    
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3007<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |


   Рисунок 4.6: Полный (комплексный) запрос
   Несмотря на то что Булевы опреаторы индивидуально просты, они не так просты когда комбинируются в комплексное выражение.
   Способ оценки комплекса Булева состоит в том, чтобы оценивать Булевы выражения наиболее глубоко вложенные в круглых скобках, объединять их в единичное Булево значение, и затем объединять его с верхними значениями.
   Имеется подробное объяснение того как пример выше был вычислен. Наиболее глубоко вложенные выражения Буля в предикате - это odate=10/03/1990 и snum > 1002 являются объединеными с помощью AND, формируя одно выражение Буля которое будет оценено как верное для всех строк в которых встретились оба эти условия. Это составное Булево выражение (которое мы будем называть Булево номер 1, или B1 для краткости) объдиняется с выражением (amt) > 2000.00 (B2) с помощью OR, формируя третье выражение (B3), которое является верным для данной строки, если или B1 или B2 - верны для этой строки.
   B3 полностью содержится в круглых скобках которым предшествует NOT, формируя последнее выражение Буля(B4), которое является условием предиката.
   Таким образом B4, предикат запроса, - будет верен всякий раз, когда B3 неправилен. B3 - неправилен всегда, когда B1 и B2 - оба неверны. B1 неправилен для строки если дата порядка строки не 10/03/1990, или если значение snum не большее чем 1002. B2 неправилен для всех строк, значения суммы приобретений которых не превышает 2000.00. Любая строка со значением выше 2000.00 сделает B2 - верным; в результате B3 будет верен, а B4 нет. Следовательно, все эти строки будут удалены из вывода.
   Из оставшихся, строки которые на 3 Октября имеют snum > 1002 (такие как строки для onum 3001 на 3 Октября со snum=1007 ), делают B1 верным, с помощью верного B3 и неверного предиката запроса. Они будут также удалены из вывода. Вывод показан для строк которые оставлены.
### РЕЗЮМЕ
   В этой главе, вы значительно расширили ваше знакомство с предикатами. Теперь вы можете находить значения которые связаны с данным значением любым способом - определяемым различными реляционными операторами.
   
   Вы можете также использовать операторы Буля AND и OR чтобы много условий, каждое из которых автономно в предикатах, объединять в единый предикат. Оператор Буля NOT, как вы уже видели, может изменять значение условия или группы условий на противоположное.
   Булевы и Реляционные операторы могут эффективно управляться с помощью круглых скобок, которые определяют порядок, в котором операции будут выполнены. Эти операции применимы к любому уровню сложности и вы поняли как сложные условия могут создаваться из этих простых частей.
   Теперь, когда мы показали как используются стандартные математические операторы, мы можем перейти к операторам которые являются исключительными в SQL. Это мы сделаем в Главе 5.
 
### РАБОТА С SQL
   * Напишите запрос который может дать вам все порядки со значениями суммы выше чем $1,000.
   * Напишите запрос который может выдать вам поля sname и city для всех продавцов в Лондоне с комиссионными выше .10 .
   * Напишите запрос к таблице Заказчиков чей вывод может включить всех заказчиков с оценкой=&lt; 100, если они не находятся в Риме.
   * Что может быть выведено в результате следующего запроса?
 
    SELECT *
    FROM Orders
    WHERE (amt < 1000 OR
    NOT (odate=10/03/1990
    AND cnum > 2003 ));
 
   * Что может быть выведено в результате следующего запроса?
 
    SELECT *
    FROM Orders
    WHERE NOT ((odate=10/03/1990 OR snum > 1006)
    AND amt >=1500 );
 
   * Как можно проще переписать такой запрос?
 
    SELECT snum, sname, city, comm
    FROM Salespeople
    WHERE (comm > + .12 OR
    comm < .14 );
    
## Глава 5. ИСПОЛЬЗОВАНИЕ СПЕЦИАЛЬНЫХ ОПЕРАТОРОВ В УСЛОВИЯХ
 
   В ДОПОЛНЕНИИ К РЕЛЯЦИОННЫМ И БУЛЕВСКИМ операторам обсуждаемым в Главе 4, SQL использует специальные операторы IN, BETWEEN, LIKE, и IS NULL. В этой главе, вы узнаете как их использовать и как реляционные операторы позволяют создавать более сложные и мощные предикаты. Обсуждение оператора IS NULL будет включать отсутствие данных и значение NULL, которое указывает на то: что данные отсутствуют. Вы также узнаете о разновидностях использования оператора NOT применяющегося с этими операторами.
### ОПЕРАТОР IN
   Оператор IN определяет набор значений в которое данное значение может или не может быть включено. В соответствии с нашей учебной базой данных на которой вы обучаетесь по настоящее временя, если вы хотите найти всех продавцов, которые размещены в Barcelona или в London, вы должны использовать следующий запрос (вывод показывается в Таблице5.1 ):
 
    SELECT *
    FROM Salespeople
    WHERE city='Barcelona'
    OR city='London';
 
   Имеется и более простой способ получить ту же информацию:
 
    SELECT *
    FROM Salespeople
    WHERE city IN ('Barcelona', 'London' );
 
   Вывод для этого запроса показывается в Таблице 5.2.
   Как вы можете видеть, IN определяет набор значений с помощью имен членов набора заключеных в круглые скобки и отделенных запятыми. Он затем проверяет различные значения указанного поля пытаясь найти совпадение со значениями из набора. Если это случается, то предикат верен. Когда наборсодержит значения номеров а не символов, одиночные кавычки опускаются. Давайте найдем всех заказчиков относящихся к продавцам имеющих значения snum=1001, 1007, и 1004. Вывод для следующего запроса показан в Таблице 5.3:
 
    SELECT *
    FROM Customers
    WHERE cnum IN (1001, 1007, 1004 );
 
SQL Execution Log

    SELECT * FROM Salespeople WHERE city=
    'Barcelona' OR city='London';
    
|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |    0.15<br style="margin: 0px; padding: 0px;"> |


   Таблица 5.1 Нахождение продавцов в Барселоне и Лондоне
 
SQL Execution Log

    SELECT * FROM Salespeople WHERE city IN
    ('Barcelona', 'London');
    
|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |    0.15<br style="margin: 0px; padding: 0px;"> |

  Таблица 5.2 SELECT использует IN
 
SQL Execution Log

    SELECT * FROM Customers WHERE snum IN (1001, 1007, 1004 );
    
|    snum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |

   Таблица 5.3: SELECT использует IN с номерами
### ОПЕРАТОР BETWEEN
   Оператор BETWEEN похож на оператор IN. В отличии от определения по номерам из набора, как это делает IN, BETWEEN определяет диапазон, значения которого должны уменьшаться что делает предикат верным. Вы должны ввести ключевое слово BETWEEN с начальным значением, ключевое AND и конечное значение. В отличие от IN, BETWEEN чувствителен к порядку, и первое значение в предложении должно быть первым по алфавитному или числовому порядку. (Обратите Внимание что, в отличие от Английского языка, SQL не говорит что "значение находится (между)BETWEEN значением и значением|, а просто "значение BETWEEN значение значение|.
   Это применимо и к оператору LIKE). Следующий пример будет извлекать из таблицы Продавцов всех продавцов с комиссионными между .10 и .12 (вывод показывается в Таблице 5.4):
 
    SELECT *
    FROM Salespeople
    WHERE comm BETWEEN .10 AND .12;
 
   Для включенного оператора BETWEEN, значение совпадающее с любым из двух значений границы (в этом случае, .10 и .12 ) заставляет предикат быть верным.
 
SQL Execution Log

    SELECT * FROM Salespeople WHERE comm BETWEEN .10 AND .12;

|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    0.10<br style="margin: 0px; padding: 0px;"> |

Таблица 5.4: SELECT использует BETWEEN
   SQL не делает непосредственной поддержки невключения BETWEEN. Вы должны или определить ваши граничные значения так, чтобы включающая интерпретация была приемлема, или сделать что-нибудь типа этого:
   
    SELECT *
    FROM Salespeople
    WHERE (comm BETWEEN .10, AND .12 )
    AND NOT comm IN (.10, .12 );
   Вывод для этого запроса показывается в Таблица 5.5. По общему признанию, это немного неуклюже, но зато показывает как эти новые операторы могут комбинироваться с операторами Буля чтобы производить более сложные предикаты. В основном, вы используете IN и BETWEEN также как вы использовали реляционные операторы чтобы сравнивать значения, которые берутся либо из набора (для IN ) либо из диапазона (для BETWEEN ).
   Также, подобно реляционным операторам, BETWEEN может работать с символьными полями в терминах эквивалентов ASCII. Это означает что вы можете использовать BETWEEN чтобы выбирать ряд значений из упорядоченных по алфавиту значений.
 
SQL Execution Log

    SELECT * FROM Salespeople WHERE
    ( comm BETWEEN .10 AND .12 AND NOT comm IN (.10 .12);
    
|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |

Таблица 5.5: Сделать BETWEEN - невключенным
   Этот запрос выбирает всех заказчиков чьи имена попали в определенный алфавитный диапазон:
   
    SELECT *
    FROM Customers
    WHERE cname BETWEEN 'A' AND 'G';
   Вывод для этого запроса показывается в Таблице 5.6.
   Обратите Внимание что Grass и Giovanni отсутствуют, даже при включенном BETWEEN. Это происходит из-за того что BETWEEN сравнивает строк неравной длины. Строка 'G' более короткая чем строка Giovanni, поэтому BETWEEN выводит 'G' с пробелами. Пробелы предшествуют символам в алфавитном порядке (в большинстве реализаций ), поэтому Giovanni не выбирается. То же самое происходит с Grass. Важно помнить это когда вы используете BETWEEN для извлечения значений из алфавитных диапазонов.
   Обычно вы указываете диапазон с помощью символа начала диапазона и символа конца( вместо которого можно просто поставить z ).
 
SQL Execution Log

    SELECT * FROM Customers WHERE cname BETWEEN 'A' AND 'G';
    
|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2006<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |

   Таблица 5. 6: Использование BETWEEN в алфавитных порядках
ОПЕРАТОР LIKE
   LIKE применим только к полям типа CHAR или VARCHAR, с которыми он используется чтобы находить подстроки. Т.е. он ищет поле символа чтобы видеть, совпадает ли с условием часть его строки. В качестве условия он использует групповые символы(wildkards) - специальные символы которые могут соответствовать чему-нибудь.
 
   * Имеются два типа групповых символов используемых с LIKE:
   символ подчеркивания (_ ) замещает любой одиночный символ. Например, 'b_t' будет соответствовать словам 'bat' или 'bit', но не будет
   * соответствовать 'brat'.
   знак процента (%) замещает последовательность любого числа символов
   (включая символы нуля). Например '%p%t' будет соответствовать словам
   'put', 'posit', или 'opt', но не 'spite'.
 
   Давайте найдем всех заказчиков чьи имена начинаются с G (вывод показывается в Таблице 5.7 ):
 
    SELECT
    FROM Customers
    WHERE cname LIKE 'G%';
 
SQL Execution Log

    SELECT * FROM Customers WHERE cname LIKE 'G';

|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2002<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |

Таблица 5. 7: SELECT использует LIKE с %
 
   LIKE может быть удобен если вы ищете имя или другое значение, и если вы не помните как они точно пишутся. Предположим что вы неуверены как записано по буквам имя одного из ваших продавцов Peal или Peel. Вы можете просто использовать ту часть которую вы знаете и групповые символы чтобы находить все возможные пары (вывод этого запроса показывается в Таблице 5.8 ):
 
    SELECT *
    FROM Salespeople
    WHERE sname LIKE 'P _ _ l %';
 
   Групповые символы подчеркивания, каждый из которых представляет один символ, добавят только два символа к уже существующим 'P' и 'l', поэтому имя наподобии Prettel не может быть показано. Групповой символ ' % ' - в конце строки необходим в большинстве реализаций если длина поля sname больше чем число символов в имени Peel (потому что некоторые другие значения sname - длиннее чем четыре символа). В таком случае, значение поля sname, фактически сохраняемое как имя Peel, сопровождается рядом пробелов. Следовательно, символ 'l' не будет рассматриваться концом строки. Групповой символ ' % ' - просто соответствует этим пробелам. Это необязательно, если поля sname имеет тип - VARCHAR.
 
SQL Execution Log

    SELECT * FROM Salespeople WHERE sname LIKE ' P 1% ';
    
|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |


Таблица 5.8: SELECT использует LIKE с подчеркиванием (_)
   А что же Вы будете делать если вам нужно искать знак процента или знак подчеркивания в строке? В LIKE предикате, вы можете определить любой одиночный символ как символ ESC. Символ ESC используется сразу перед процентом или подчеркиванием в предикате, и означает что процент или подчеркивание будет интерпретироваться как символ а не как групповой символ. Например, мы могли бы найти наш sname столбец где присутствует подчеркивание, следующим образом:
   
    SELECT *
    FROM Salespeople
    WHERE sname LIKE '%/_%'ESCAPE'/';
   С этими данными не будет никакого вывода, потому что мы не включили никакого подчеркивания в имя нашего продавца. Предложение ESCAPE определяет '/ ' как символ ESC. Символ ESC используемый в LIKE строке, сопровождается знаком процента, знаком подчеркивания, или знаком ESCAPE, который будет искаться в столбце, а не обрабатываться как групповой символ. Символ ESC должен быть одиночным символом и применяться только к одиночному символу сразу после него.
   В примере выше, символ процента начала и символ процента окончания обрабатываются как групповые символы; только подчеркивание предоставлено само себе.
   Как упомянуто выше, символ ESC может также использоваться самостоятельно. Другими словами, если вы будете искать столбец с вашим символом ESC, вы просто вводите его дважды. Во-первых это будет означать что символ ESC "берет следующий символ буквально как символ", и во-вторых что символ ESC самостоятелен.
   Имеется предыдущий пример который пересмотрен чтобы искать местонахождение строки '_/' в sname столбце:
 
    SELECT *
    FROM Salespeople
    WHERE sname LIKE ' % /_ / / %'ESCAPE'/';
 
   Снова не будет никакого вывода с такими данными. Строка сравнивается с содержанием любой последовательности символов (%), сопровождаемых символом подчеркивания (/_ ), символом ESC (// ), и любой последовательностью символов в конце строки (% ).
### РАБОТА С НУЛЕВЫМИ( NULL ) ЗНАЧЕНИЯМИ
   Часто, будут иметься записи в таблице которые не имеют никаких значений для каждого поля, например потому что информация не завершена, или потому что это поле просто не заполнялось. SQL учитывает такой вариант, позволяя вам вводить значение NULL(ПУСТОЙ) в поле, вместо значения. Когда значение поля равно NULL, это означает, что программа базы данных специально промаркировала это поле как не имеющее никакого значения для этой строки (или записи). Это отличается от просто назначения полю, значения нуля или пробела, которые база данных будет обрабатывать также как и любое другое значение. Точно также, как NULL не является техническим значением, оно не имеет и типа данных. Оно может помещаться в любой тип поля. Тем ни менее, NULL в SQL часто упоминается как нуль.
   Предположим, что вы получили нового заказчика который еще не был назначен продавцу. Чем ждать продавца к которому его нужно назначить, вы можете ввести заказчика в базу данных теперь же, так что он не потеряется при перестановке.
   Вы можете ввести строку для заказчика со значением NULL в поле snum и заполнить это поле значением позже, когда продавец будет назначен.
 
### NULL ОПЕРАТОР
   Так как NULL указывает на отсутствие значения, вы не можете знать каков будет результат любого сравнения с использованием NULL. Когда NULL сравнивается с любым значением, даже с другим таким же NULL, результат будет ни верным ни неверным, он - неизвестен. Неизвестный Булев, вообще ведет себя также как неверная строка, которая произведя неизвестное значение в предикате не будет выбрана запросом - имейте ввиду что в то время как NOT(неверное) - равнятся верно, NOT (неизвестное) - равняется неизвестно.
   Следовательно, выражение типа 'city=NULL' или 'city IN (NULL)' будет неизвестно, независимо от значения city.
   Часто вы должны делать различия между неверно и неизвестно - между строками содержащими значения столбцов которые не соответствуют условию предиката и которые содержат NULL в столбцах. По этой причине, SQL предоставляет специальный оператор IS, который используется с ключевым словом NULL, для размещения значения NULL.
   Найдем все записи в нашей таблице Заказчиков с NULL значениями в city столбце:
   
    SELECT *
    FROM Customers
    WHERE city IS NULL;
   Здесь не будет никакого вывода, потому что мы не имеем никаких значений NULL в наших типовых таблицах. Значения NULL - очень важны, и мы вернемся к ним позже.
 
### ИСПОЛЬЗОВАНИЕ NOT СО СПЕЦИАЛЬНЫМИ ОПЕРАТОРАМИ
   Специальные операторы которые мы изучали в этой главе могут немедленно предшествовать Булеву NOT.
   Он противоположен реляционным операторам, которые должны иметь оператор NOT - вводимым выражением. Например, если мы хотим устранить NULL из нашего вывода, мы будем использовать NOT чтобы изменить на противоположное значение предиката:
 
    SELECT *
    FROM Customers
    WHERE city NOT NULL;
   При отсутствии значений NULL( как в нашем случае ), будет выведена вся таблица Заказчиков. Аналогично можно ввести следующее
    
    SELECT *
    FROM Customers
    WHERE NOT city IS NULL;
 
   - что также приемлемо.
   Мы можем также использовать NOT с IN:
   
    SELECT *
    FROM Salespeople
    WHERE city NOT IN ('London', 'San Jose' );
   А это - другой способ подобного же выражения
   
    SELECT *
    FROM Salespeople
    WHERE NOT city IN ('London', ' San Jose' );
   Вывод для этого запроса показывается в Таблице 5.9.
   Таким же способом Вы можете использовать NOT BETWEEN и NOT LIKE.
 
SQL Execution Log

    SELECT * FROM Salespeople WHERE sity NOT IN
    ('London', 'San Jose');
    
|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1003<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |    0.15<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    0.10<br style="margin: 0px; padding: 0px;"> |

Таблица 5. 9: Использование NOT с IN
 
### РЕЗЮМЕ
   Теперь вы можете создавать предикаты в терминах связей специально определенных SQL. Вы можете искать значения в определенном диапазоне (BETWEEN) или в числовом наборе (IN), или вы можете искать символьные значения которые соответствуют тексту внутри параметров (LIKE).
   Вы также изучили некоторые вещи относительно того как SQL поступает при отсутствии данных - что реальность мировой базы данных - используя NULL вместо конкретных значений. Вы можете извлекать или исключать значения NULL из вашего вывода используя оператор IS NULL. Теперь, когда вы имеете в вашем распоряжении весь набор стандартных математических и специальных операторов, вы можете переходить к специальным функциям SQL которые работают на всех группах значений, а не просто на одиночном значении, что важно.
   Это уже тема Главы 6.
 
### РАБОТА С SQL
   Напишите два запроса которые могли бы вывести все порядки на 3 или 4 Октября 1990
   * Напишите запрос который выберет всех заказчиков обслуживаемых продавцами Peel или Motika. (Подсказка: из наших типовых таблиц, поле snum связывает вторую таблицу с первой )
   * Напишите запрос, который может вывести всех заказчиков чьи имена начинаются с буквы попадающей в диапазон от A до G.
   * Напишите запрос который выберет всех пользователей чьи имена начинаются с буквы C.
   * Напишите запрос который выберет все порядки имеющие нулевые значения или NULL в поле amt(сумма).
   
## Глава 6. ОБОБЩЕНИЕ ДАННЫХ С ПОМОЩЬЮ АГРЕГАТНЫХ ФУНКЦИЙ
 
   В ЭТОЙ ГЛАВЕ, ВЫ ПЕРЕЙДЕТЕ ОТ ПРОСТОГО использования запросов к извлечению значений из базы данных и определению, как вы можете использовать эти значения чтобы получить из них информацию. Это делается с помощью агрегатных или общих функций которые берут группы значений из поля и сводят их до одиночного значения. Вы узнаете как использовать эти функции, как определить группы значений к которым они будут применяться, и как определить какие группы выбираются для вывода. Вы будете также видеть при каких условиях вы сможете объединить значения поля с этой полученной информацией в одиночном запросе.
 
### ЧТО ТАКОЕ АГРЕГАТНЫЕ ФУНКЦИИ?
   Запросы могут производить обобщенное групповое значение полей точно также как и значение одного поля. Это делает с помощью агрегатых функций. Агрегатные функции производят одиночное значение для всей группы таблицы. Имеется список этих функций:
   * COUNT производит номера строк или не-NULL значения полей которые выбрал запрос.
   * SUM производит арифметическую сумму всех выбранных значений данного поля.
   * AVG производит усреднение всех выбранных значений данного поля.
   * MAX производит наибольшее из всех выбранных значений данного поля.
   * MIN производит наименьшее из всех выбранных значений данного поля.
 
### КАК ИСПОЛЬЗОВАТЬ АГРЕГАТНЫЕ ФУНКЦИИ?
   Агрегатные функции используются подобно именам полей в предложении SELECT запроса, но с одним исключением, они берут имена поля как аргументы. Только числовые поля могут использоваться с SUM и AVG. С COUNT, MAX, и MIN, могут использоваться и числовые или символьные поля. Когда они используются с символьными полями, MAX и MIN будут транслировать их в эквивалент ASCII, который должен сообщать, что MIN будет означать первое, а MAX последнее значение в алфавитном порядке( выдача алфавит ного упорядочения обсуждается более подробно в Главе 4). Чтобы найти SUM всех наших покупок в таблицы Порядков, мы можем ввести следующий запрос, с его выводом в Таблице 6.1:
 
    SELECT SUM ((amt))
    FROM Orders;
 
SQL Execution Log

    SELECT SUM (amt) FROM Orders;
    
|    26658.4 |
|------------|

Таблица 6.1: Выбор суммы
   Это конечно, отличается от выбора поля при котором возвращается одиночное значение, независимо от того сколько строк находится в таблице.
   Из-за этого, агрегатные функции и поля не могут выбираться одновременно, пока предложение GROUP BY (описанное далее) не будет использовано.
   Нахождение усредненой суммы - это похожая операция (вывод следующего запроса показывается в Таблице 6.2 ):
 
    SELECT AVG (amt)
    FROM Orders;
 
SQL Execution Log

    SELECT AVG (amt) FROM Orders;
    
|    5 |
|------|



Таблица 6.3: Подсчет значений поля
   Вы можете выбирать многочисленые счета( COUNT ) из полей с помощью DISTINCT в одиночном запросе который, как мы видели в Главе 3, не выполнялся когда вы выбирали строки с помощью DISTINCT. DISTINCT может использоваться таким образом, с любой функцией агрегата, но наиболее часто он используется с COUNT. С MAX и MIN, это просто не будет иметь никакого эффекта, а SUM и AVG, вы обычно применяете для включения повторяемых значений, так как они законно эффективнее общих и средних значений всех столбцов.
### ИСПОЛЬЗОВАНИЕ COUNT СО СТРОКАМИ, А НЕ ЗНАЧЕНИЯМИ
   Чтобы подсчитать общее число строк в таблице, используйте функцию COUNT со звездочкой вместо имени поля, как например в следующем примере, вывод из которого показан в Таблице.4:
    

    SELECT COUNT (*)
    FROM Customers
 
   COUNT со звездочкой включает и NULL и дубликаты, по этой причине DISTINCT не может быть использован. DISTINCT может производить более высокие номера чем COUNT особого поля, который удаляет все строки, имеющие избыточные или NULL данные в этом поле.
 
SQL Execution Log

    SELECT COUNT (*) FROM Customers;
    
|    7 |
|------|

Таблица 6. 4: Подсчет строк вместо значений
 
   DISTINCT не применим c COUNT (*), потому, что он не имеет никакого действия в хорошо разработаной и поддерживаемой базе данных. В такой базе данных, не должно быть ни таких строк, которые бы являлись полностью пустыми, ни дубликатов (первые не содержат никаких данных, а последние полностью избыточны). Если, с другой стороны, все таки имеются полностью пустые или избыточные строки, вы вероятно не захотите чтобы COUNT скрыл от вас эту информацию.
### ВКЛЮЧЕНИЕ ДУБЛИКАТОВ В АГРЕГАТНЫЕ ФУНКЦИИ
   Агрегатные функции могут также (в большинстве реализаций ) использовать аргумент ALL, который помещается перед именем поля, подобно DISTINCT, но означает противоположное: - включать дубликаты. ANSI технически не позволяет этого для COUNT, но многие реализации ослабляют это ограничение.
   Различия между ALL и * когда они используются с COUNT -
   * ALL использует имя_поля как аргумент.
   * ALL не может подсчитать значения NULL.
 
   Пока * является единственым аргументом который включает NULL значения, и он используется только с COUNT; функции отличные от COUNT игнорируют значения NULL в любом случае. Следующая команда подсчитает(COUNT) число не-NULL значений в поле rating в таблице Заказчиков (включая повторения ):
 
    SELECT COUNT (ALL rating )
    FROM Customers;
 
### АГРЕГАТЫ ПОСТРОЕННЫЕ НА СКАЛЯРНОМ ВЫРАЖЕНИИ
   До этого, вы использовали агрегатные функции с одиночными полями как аргументами. Вы можете также использовать агрегатные функции с аргументами которые состоят из скалярных выражений включающих одно или более полей. (Если вы это делаете, DISTINCT не разрешается. ) Предположим, что таблица Порядков имеет еще один столбец который хранит предыдущий неуплаченый баланс (поле blnc) для каждого заказчика. Вы должны найти этот текущий баланс, добавлением суммы приобретений к предыдущему балансу. Вы можете найти наибольший неуплаченый баланс следующим образом:
 
    SELECT MAX (blnc + (amt) )
    FROM Orders;
 
   Для каждой строки таблицы, этот запрос будет складывать blnc и amt для этого заказчика и выбирать самое большое значение которое он найдет. Конечно, пока заказчики могут иметь многочисленые порядки, их неуплаченый баланс оценивается отдельно для каждого порядка. Возможно, порядок с более поздней датой будет иметь самый большой неуплаченый баланс. Иначе, старый баланс должен быть выбран как в запросе выше. Фактически, имеются большое количество ситуаций в SQL где вы можете использовать скалярные выражения с полями или вместо полей, как вы увидете это в Главе 7.
### ПРЕДЛОЖЕНИЕ GROUP BY
   Предложение GROUP BY позволяет вам определять подмножество значений в особом поле в терминах другого поля, и применять функцию агрегата к подмножеству. Это дает вам возможность объединять поля и агрегатные функции в едином предложении SELECT. Например, предположим что вы хотите найти наибольшую сумму приобретений полученную каждым продавцом.
   Вы можете сделать раздельный запрос для каждого из них, выбрав MAX (amt) из таблицы Порядков для каждого значения поля snum. GROUP BY, однако, позволит Вам поместить их все в одну команду:
 
    SELECT snum, MAX (amt)
    FROM Orders
    GROUP BY snum;
 
   Вывод для этого запроса показывается в Таблице 6.5.
 
SQL Execution Log

    SELECT snum, MAX (amt) FROM Orders GROUP BY snum;

|    snum                                  |                                          |
|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |
|    1014<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |

   Таблица 6.5: Нахождение максимальной суммы продажи у каждого продавца
 
   GROUP BY применяет агрегатные функции независимо от серий групп которые определяются с помощью значения поля в целом. В этом случае, каждая группа состоит из всех строк с тем же самым значением поля snum, и MAX функция применяется отдельно для каждой такой группы. Это значение поля, к которому применяется GROUP BY, имеет, по определению, только одно значение на группу вывода, также как это делает агрегатная функция. Результатом является совместимость которая позволяет агрегатам и полям объединяться таким образом.
   Вы можете также использовать GROUP BY с многочислеными полями. Совершенствуя вышеупомянутый пример далее, предположим что вы хотите увидеть наибольшую сумму приобретений получаемую каждым продавцом каждый день. Чтобы сделать это, вы должны сгруппировать таблицу Порядков по датам продавцов, и применить функцию MAX к каждой такой группе, подобно этому:
 
    SELECT snum, odate, MAX ((amt))
    FROM Orders
    GROUP BY snum, odate;
 
   Вывод для этого запроса показывается в Рисунке 6.6.
 
SQL Execution Log

    SELECT snum, odate, MAX (amt)
    FROM Orders GROUP BY snum, odate;

|    snum                                  |    odate                                 |                                          |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |
|    1001<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |
|    1001<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |
|    1014<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |


   Таблица 6.6: Нахождение наибольшей суммы приобретений на каждый день
   Конечно же, пустые группы, в дни когда текущий продавец не имел порядков, не будут показаны в выводе.
### ПРЕДЛОЖЕНИЕ HAVING
   Предположим, что в предыдущем примере, вы хотели бы увидеть только максимальную сумму приобретений значение которой выше $3000.00. Вы не сможете использовать агрегатную функцию в предложении WHERE (если вы не используете подзапрос, описанный позже ), потому что предикаты оце ниваются в терминах одиночной строки, а агрегатные функции оцениваются в терминах групп строк. Это означает что вы не сможете сделать что-нибудь подобно следующему:
 
    SELECT snum, odate, MAX (amt)
    FROM Oreders
    WHERE MAX ((amt)) > 3000.00
    GROUP BY snum, odate;
 
   Это будет отклонением от строгой интерпретации ANSI. Чтобы увидеть максимальную стоимость приобретений свыше $3000.00, вы можете использовать предложение HAVING.
   Предложение HAVING определяет критерии используемые чтобы удалять определенные группы из вывода, точно также как предложение WHERE делает это для индивидуальных строк.
   Правильной командой будет следующяя:
 
    SELECT snum, odate, MAX ((amt))
    FROM Orders
    GROUP BY snum, odate
    HAVING MAX ((amt)) > 3000.00;
 
   Вывод для этого запроса показывается в Таблице 6. 7.
 
SQL Execution Log

    SELECT snum, odate, MAX (amt) FROM Orders
    GROUP BY snum, odate HAVING MAX (amt) > 3000.00;
 
 |    snum                                  |    odate                                 |
|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |
|    1001<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |

Таблица 6. 7: Удаление групп агрегатных значений
   Аргументы в предложении HAVING следуют тем же самым правилам что и в предложении SELECT, состоящей из команд использующих GROUP BY. Они должны иметь одно значение на группу вывода. Следующая команда будет запрещена:
 
    SELECT snum, MAX (amt)
    FROM Orders
    GROUP BY snum
    HAVING odate=10/03/1988;
 
   Поле оdate не может быть вызвано предложением HAVING, потому что оно может иметь (и действительно имеет ) больше чем одно значение на группу вывода. Чтобы избегать такой ситуации, предложение HAVING должно ссылаться только на агрегаты и поля выбранные GROUP BY. Имеется правильный способ сделать вышеупомянутый запрос( вывод показывается в Таблице 6.8 ):
 
    SELECT snum, MAX (amt)
    FROM Orders
    WHEREodate=10/03/1990
    GROUP BY snum;
 
SQL Execution Log

    SELECT snum, odate, MAX (amt)
    FROM Orders GROUP BY snum, odate;
 
 |    snum                                  |                                          |
|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |
|    1014<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |

Таблица 6.8: Максимальное значение суммы приобретений у каждого
   продавца на 3 Октября
   Поскольку поля odate нет, не может быть и выбраных полей, значение этих данных меньше чем в некоторых других примерах. Вывод должен вероятно включать что-нибудь такое что говорит - " это - самые большие порядки на 3 Октября." В Главе 7, мы покажем как вставлять текст в ваш вывод.
   Как и говорилось ранее, HAVING может использовать только аргументы которые имеют одно значение на группу вывода. Практически, ссылки на агрегатные функции - наиболее общие, но и поля выбранные с помощью GROUP BY также допустимы. Например, мы хотим увидеть наибольшие порядки для Serres и Rifkin:
 
    SELECT snum, MAX (amt)
    FROM Orders
    GROUP BY snum
    HAVING snum B (1002,1007);
   Вывод для этого запроса показывается в Таблице 6.9.
 
SQL Execution Log

    SELECT snum, MAX (amt)| FROM Orders
    GROUP BY snum HAVING snum IN (1002, 1007 );

|    snum                                  |                                          |
|------------------------------------------|------------------------------------------|
|    1002<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |

 Таблица 6. 9: Использование HAVING с GROUP BY полями
### НЕ ДЕЛАЙТЕ ВЛОЖЕННЫХ АГРЕГАТОВ
   В строгой интерпретации ANSI SQL, вы не можете использовать агрегат агрегата. Предположим что вы хотите выяснять, в какой день имелась наибольшая сумма приобретений. Если вы попробуете сделать это, то ваша
 
   SELECT odate, MAX (SUM (amt) )
   FROM Orders
   GROUP BY odate;
 
   команда будет вероятно отклонена. (Некоторые реализации не предписывают этого ограничения, которое является выгодным, потому что вложенные агрегаты могут быть очень полезны, даже если они и несколько проблематичны.) В вышеупомянутой команде, например, SUM должен применяться к каждой группе поля odate, а MAX ко всем группам, производящим одиночное значение для всех групп. Однако предложение GROUP BY подразумевает что должна иметься одна строка вывода для каждой группы поля odate.
 
### РЕЗЮМЕ
   Теперь вы используете запросы несколько по-другому. Способность получать, а не просто размещать значения, очень мощна. Это означает что вы не обязательно должны следить за определенной информацией если вы можете сформулировать запрос так чтобы ее получить. Запрос будет давать вам по-минутные результаты, в то время как таблица общего или среднего значений будет хороша только некоторое время после ее модификации. Это не должно наводить на мысль, что агрегатные функции могут полностью вытеснить потребность в отслеживании информации такой например как эта.
   Вы можете применять эти агрегаты для групп значений определенны предложением GROUP BY. Эти группы имеют значение поля в целом, и могут постоянно находиться внутри других групп которые имеют значение поля в целом. В то же время, предикаты еще используются чтобы определять какие строки агрегатной функции применяются.
   Объединенные вместе, эти особенности делают возможным, производить агрегаты основанные на сильно определенных подмножествах значений в поле. Затем вы можете определять другое условие для исключения определенных результатов групп с предложением HAVING.
   Теперь, когда вы стали знатоком большого количества того как запрос производит значения, мы покажем вам, в Главе 7, некоторые вещи которые вы можете делать со значениями которые он производит.

РАБОТА С SQL
   * Напишите запрос который сосчитал бы все суммы приобретений на 3 Октября.
   * Напишите запрос который сосчитал бы число различных не-NULL значений поля city в таблице Заказчиков.
   * Напишите запрос который выбрал бы нименьшую сумму для каждого заказчика.
   * Напишите запрос который бы выбирал заказчиков в алфавитном порядке, чьи имена начинаются с буквы G.
   * Напишите запрос который выбрал бы высшую оценку в каждом городе.
   * Напишите запрос который сосчитал бы число заказчиков регистрирующих каждый день свои порядки. (Если продавец имел более одного порядка в данный день, он должен учитываться только один раз.)
 
 ## Глава 7. ФОРМИРОВАНИЕ ВЫВОДОВ ЗАПРОСОВ
 
   ЭТА ГЛАВА РАСШИРИТ ВАШИ ВОЗМОЖНОСТИ в работе с выводом который производит запрос. Вы узнаете как вставлять текст и константы между выбранных полей, как использовать выбранные поля в математических выражениях, чьи результаты затем становятся выводом, и как сделать чтобы ваши значения выводились в определенном порядке. Эта последняя особенность включена, чтобы упорядочивать ваш вывод по любым столбцам, любым полученным значениям этого столбца, или по обеим.
### СТРОКИ И ВЫРАЖЕНИЯ
   Большинство основанных на SQL баз данных предоставляют специальные средства позволяющие Вам совершенствовать вывод ваших запросов. Конечно, они претерпевают значительные изменения от программы к программе, и их обсуждение здесь не входит в наши задачи, однако, имеются пять особенностей созданых в стандарте SQL которые позволяют вам делать больше чем просто вывод значений полей и агрегатных данных.
### СКАЛЯРНОЕ ВЫРАЖЕНИЕ С ПОМОЩЬЮ ВЫБРАННЫХ ПОЛЕЙ
   Предположим что вы хотите выполнять простые числовые вычисления данных чтобы затем помещать их в форму больше соответствующую вашим потребностям. SQL позволяет вам помещать скалярные выражения и константы среди выбраных полей. Эти выражения могут дополнять или замещать поля в предложениях SELECT, и могут включать в себя одно или более выбранных полей. Например, вы можете пожелать, представить комиссионные вашего продавца в процентном отношении а не как десятичные числа. Просто достаточно:
 
    SELECT snum, sname, city, comm * 100
    FROM Salespeople;
 
   Вывод из этого запроса показывается в Таблице 7.1.
### СТОЛБЦЫ ВЫВОДА
   Последний столбец предшествующего примера непомечен( т.е. без наименования), потому что это - столбец вывода. Столбцы вывода - это столбцы данных созданные запросом способом, иным чем просто извлечение их из таблицы. Вы создаете их всякий раз, когда вы используете агрегатные
 
SQL Execution Log
 
    SELECT snum, sname, city, comm * 100 FROM Salespeople;
    
|    snum                                  |    sname                                 |    city                                  |                                          |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    12.000000<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    13.000000<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    11.000000<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |    15.000000<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    10.000000<br style="margin: 0px; padding: 0px;"> |


   Таблица 7.1: Помещение выражения в вашем запросе функции, константы, или выражения в предложении SELECT запроса. Так как имя столбца - один из атрибутов таблицы, столбцы которые приходят не из таблиц не имеют никаких имен. Другими словами непомеченные, столбцы вывода могут обрабатываться также как и столбцы извлеченные из таблиц, почти во всех ситуациях.
### ПОМЕЩЕНИЕ ТЕКСТА В ВАШЕМ ВЫВОДЕ ЗАПРОСА
   Символ 'A', когда ничего не значит сам по себе, - является констан той, такой например как число 1. Вы можете вставлять константы в предложение SELECT запроса, включая и текст. Однако символьные константы, в отличие от числовых констант, не могут использоваться в выражениях.
   Вы можете иметь выражение 1 + 2 в вашем предложении SELECT, но вы не можете использовать выражение типа 'A' + 'B'; это приемлемо только если мы имеем в виду что 'A' и 'B' это просто буквы, а не переменные и не символы.
   Тем ни менее, возможность вставлять текст в вывод ваших запросов очень удобная штука.
   Вы можете усовершенствовать предыдущий пример представив комиссионные как проценты со знаком процента (%). Это даст вам возможность помещать в вывод такие единицы как символы и комментарии, как например в следующем примере (вывод показывается в Таблице 7.2 )
 
    SELECT snum, sname, city, ' % ', comm * 100
    FROM Salespeople;
 
SQL Execution Log
 
    SELECT snum, sname, city, '%' comm * 100
    FROM Salespeople;
    
|    snum                                  |    sname                                 |    city                                  |                                          |                                          |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    %<br style="margin: 0px; padding: 0px;"> |    12.000000<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    %<br style="margin: 0px; padding: 0px;"> |    13.000000<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    %<br style="margin: 0px; padding: 0px;"> |    11.000000<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |    %<br style="margin: 0px; padding: 0px;"> |    15.000000<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    %<br style="margin: 0px; padding: 0px;"> |    10.000000<br style="margin: 0px; padding: 0px;"> |

Таблица 7.2: Вставка символов в ваш вывод
   Обратите внимание что пробел перед процентом вставляется как часть строки. Эта же самая особенность может использоваться чтобы маркировать вывод вместе с вставляемыми комментариями. Вы должны помнить, что этот же самый комментарий будет напечатан в каждой строке вывода, а не просто один раз для всей таблицы. Предположим что вы генерируете вывод для отчета который бы указывал число порядков получаемых в течение каждого дня. Вы можете промаркировать ваш вывод (см. Таблицу 7.3 ) сформировав запрос следующим образом:
 
    SELECT ' For ', odate, ', there are ',
    COUNT (DISTINCT onum ), 'orders.'
    FROM Orders
    GROUP BY odate;
 
   Грамматической некорректности вывода, на 5 Октября, невозможно избежать не создав запроса, еще более сложного чем этот. (Вы будете должны использовать два запроса с UNION, который
 
SQL Execution Log
 
    SELECT 'For', odate, ', ' there are ' ,
    COUNT (DISTINCT onum), ' orders '
    FROM Orders GROUP BY odate;
 
 |    odate                                 |                                          |                                          |                                          |                                          |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    For<br style="margin: 0px; padding: 0px;"> |    10/03/1990 ,<br style="margin: 0px; padding: 0px;"> |    there are<br style="margin: 0px; padding: 0px;"> |    5<br style="margin: 0px; padding: 0px;"> |    orders.<br style="margin: 0px; padding: 0px;"> |
|    For<br style="margin: 0px; padding: 0px;"> |    10/04/1990 ,<br style="margin: 0px; padding: 0px;"> |    there are<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |    orders.<br style="margin: 0px; padding: 0px;"> |
|    For<br style="margin: 0px; padding: 0px;"> |    10/05/1990 ,<br style="margin: 0px; padding: 0px;"> |    there are<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |    orders.<br style="margin: 0px; padding: 0px;"> |
|    For<br style="margin: 0px; padding: 0px;"> |    10/06/1990 ,<br style="margin: 0px; padding: 0px;"> |    there are<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |    orders.<br style="margin: 0px; padding: 0px;"> |


   Таблица 7.3: Комбинация текста, значений поля, и агрегатов
 
   мы будем описывать в Главе 14. ) Как вы можете видеть, одиночный неизменный комментарий для каждой строки таблицы может быть очень полезен, но имеет ограничения. Иногда изящнее и полезнее, произвести один ком ментарий для всего вывода в целом, или производить свой собственный комментарии для каждой строки.
   Различные программы использующие SQL часто обеспечивают специальные средства типа генератора отчетов( например Report Writer), которые разработаны чтобы форматировать и совершенствовать вывод. Вложенный SQL может также эксплуатировать возможности того языка в который он вложен. SQL сам по себе интересен прежде всего при операциях с данными. Вывод, по существу, это информация, и программа использующая SQL может часто использовать эту информацию и помещать ее в более привлекательную форму. Это, однако, вне сферы самой SQL.
 
### УПОРЯДОЧЕНИЕ ВЫВОДА ПОЛЕЙ
   Как мы подчеркивали, таблицы - это неупорядоченные наборы данных, и данные которе выходят из их, не обязательно появляются в какой-то определенной последовательности. SQL использует команду ORDER BY чтобы позволять вам упорядочивать ваш вывод. Эта команда упорядочивает вывод запроса согласно значениям в том или ином количестве выбранных столбцов. Многочисленые столбцы упорядочиваются один внутри другого, также как с GROUP BY, и вы можете определять возрастание (ASC ) или убывание (DESC ) для каждого столбца. По умолчанию установлено - возростание. Давайте рассмотрим нашу таблицу порядка приводимую в порядок с помощью номера заказчика (обратите внимание на значения в cnum столбце):
 
    SELECT *
    FROM Orders
    ORDER BY cnum DESC;
 
   Вывод показывается в Рисунке 7.4.
 
SQL Execution Log

    SELECT * FROM Orders ORDER BY cnum DESC;
    
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3001<br style="margin: 0px; padding: 0px;"> |    18.69<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3007<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3005<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |


   Таблица 7. 4: Упорядочение вывода с помощью убывания поля
УПОРЯДОЧЕНИЕ С ПОМОЩЬЮ МНОГОЧИСЛЕНЫХ СТОЛБЦОВ
   Мы можем также упорядочивать таблицу с помощью другого столбца, например с помощью поля amt, внутри упорядочения поля cnum. (вывод показан в Таблице 7.5 ):
 
    SELECT *
    FROM Orders
    ORDER BY cnum DESC, amt DESC;
 
SQL Execution Log

    SELECT * FROM Orders
    ORDER BY cnum DESC, amt DESC;
    
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3001<br style="margin: 0px; padding: 0px;"> |    18.69<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3007<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3005<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |


   Таблица 7.5: Упорядочение вывода с помощью многочисленых полей
 
   Вы можете использовать ORDER BY таким же способом сразу с любым числом столбцов. Обратите внимание что, во всех случаях, столбцы которые упорядочиваются должны быть указаны в выборе SELECT. Это - требование ANSI которые в большинстве, но не всегда, предписано системе. Следующая команда, например, будет запрещена:
 
    SELECT cname, city
    FROM Customers
    GROUP BY cnum;
 
   Так как поле cnum не было выбранным полем, GROUP BY не cможет найти его чтобы использовать для упорядочения вывода. Даже если ваша система позволяет это, смысл упорядочения не будет понятен из вывода, так что включение (в предложение SELECT) всех столбцов, используемых в предложении ORDER BY, в принципе желательно.
   
### УПОРЯДОЧЕНИЕ АГРЕГАТНЫХ ГРУПП
   ORDER BY может кроме того, использоваться с GROUP BY для упорядочения групп. Если это так, то ORDER BY всегда приходит последним. Вот - пример из последней главы с добавлением предложения ORDER BY. Перед сгруппированием вывода, порядок групп был произвольным; и мы, теперь, заставим группы размещаться в последовательности:
 
    SELECT snum, odate, MAX (amt)
    FROM Orders
    GROUP BY snum, odate
    GROUP BY snum;
 
   Вывод показывается в Таблице 7.6.
 
SQL Execution Log
    
    SELECT snum, odate, MAX (amt) FROM Orders
    GROUP BY snum, odate ORDER BY snum ;

|    snum                                  |    odate                                 |    amt                                   |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |
|    1001<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |
|    1001<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    75.75<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |


 Таблица 7.6: Упорядочение с помощью группы
   Так как мы не указывали на возрастание или убывание порядка, возрастание используется по умолчанию.
### УПОРЯДОЧЕНИЕ ВЫВОДА ПО НОМЕРУ СТОЛБЦА
   Вместо имен столбца, вы можете использовать их порядковые номера для указания поля используемого в упорядочении вывода. Эти номера могут ссылаться не на порядок столбцов в таблице, а на их порядок в выводе.
   Другими словами, поле упомянутое в предложении SELECT первым, для ORDER BY - это поле 1, независимо от того каким по порядку оно стоит в таблице. Например, вы можете использовать следующую команду чтобы увидеть определенные поля таблицы Продавцов, упорядоченными в порядке убывания к наименьшему значению комиссионных (вывод показывается в Таблице7.7 ):
 
    SELECT sname, comm
    FROM Salespeople
    GROUP BY 2 DESC;
 
 
SQL Execution Log

    SELECT sname, comm FROM Salespeople
    ORDER BY 2 DESC;
    
|    sname                                 |    comm                                  |
|------------------------------------------|------------------------------------------|
|    Peel<br style="margin: 0px; padding: 0px;"> |    0.17<br style="margin: 0px; padding: 0px;"> |
|    Serres<br style="margin: 0px; padding: 0px;"> |    0.13<br style="margin: 0px; padding: 0px;"> |
|    Rifkin<br style="margin: 0px; padding: 0px;"> |    0.15<br style="margin: 0px; padding: 0px;"> |


   Таблица 7. 7: Упорядочение использующее номера
   Одна из основных целей этой возможности ORDER BY - дать вам возможность использовать GROUP BY со столбцами вывода также как и со столбцами таблицы. Столбцы производимые агрегатной функцией, константы, или выражения в предложении SELECT запроса, абсолютнопригодны для использования с GROUP BY, если они ссылаются к ним с помощью номера. Например, давайте сосчитаем порядки каждого из наших продавцов, и выведем результаты в убывающем порядке, как показано в Таблице 7.8:
   
    SELECT snum, COUNT (DISTINCT onum )
    FROM Orders
    GROUP BY snum
    ORDER BY 2 DESC;
 
SQL Execution Log
    SELECT snum, odate, MAX (amt) FROM Orders
    GROUP BY snum ORDER BY 2 DESC;
    
|    snum                                  |    odate                                 |
|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    3<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    3<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |

аблица 7.8: Упорядочение с помощью столбца вывода
   В этом случае, вы должны использовать номер столбца, так как столбец вывода не имеет имени; и вы не должны использовать саму агрегатную функцию. Строго говоря по правилам ANSI SQL, следующее не будет работать, хотя некоторые системы и пренебрегают этим требованием:
 
    SELECT snum, COUNT (DISTINCT onum )
    FROM Orders
    GROUP BY snum
    GROUP BY COUNTОМ (DISTINCT onum ) DESC;
 
   Это будет отклонено большинством систем!
### УПОРЯДОЧЕНИЕ С ПОМОЩЬЮ ОПРЕТОРА NULL
   Если имеются пустые значения (NULL) в поле которое вы используете для упорядочивания вашего вывода, они могутут или следовать или предшествовать каждому другому значению в поле. Это - возможность которую ANSI оставил для индивидуальных программ. Данная программа использует ту или иную форму.
### РЕЗЮМЕ
   В этой главе, вы изучили как заставить ваши запросы делать больше, чем просто выводить значения полей или объединять функциональные данные таблиц. Вы можете использовать поля в выражениях: например, вы можете умножить числовое поле на 10 или даже умножить его на другое числовое поле. Кроме того, вы можете помещать константы, включая и символы, в ваш вывод, что позволяет вам помещать текст непосредственно в запрос и получать его в выводе вместе с данными таблицы.
   Это дает вам возможность помечать или объяснять ваш вывод различными способами.
   Вы также изучили как упорядочивать ваш вывод. Даже если таблица сама по себе остается неупорядоченной, предложение ORDER BY дает вам возможность управлять порядком вывода строк данного запроса. Вывод запроса может быть в порядке возрастания или убывания, и столбцы могут быть вложенными один внутрь другого.
   Понятие выводимых столбцов объяснялось в этой главе. Вы теперь знаете что выводимые столбцы можно использовать чтобы упорядочивать вывод запроса, но эти столбцы - без имени, и следовательно должны опреде ляться их порядковым номером в предложении ORDER BY.
   Теперь, когда вы увидели что можно делать с выводом запроса основанного на одиночной таблице, настало время чтобы перейти к возможностям улучшенного запроса и узнать как сделать запрос любого числа таблиц в одной команде, определив связи между ними как вы это обычно делали.
   Это будет темой Главы 8.
### РАБОТА С SQL
   * Предположим что каждый продавец имеет 12% комиссионных. Напишите запрос к таблице Порядков который мог бы вывести номер порядка, номер продавца, и сумму комиссионных продавца для этого порядка.
   * Напишите запрос к таблице Заказчиков который мог бы найти высшуюоценку в каждом городе. Вывод должен быть в такой форме: For the city (city), the highest rating is: (rating).
   * Напишите запрос который выводил бы список заказчиков в нисходящемпорядке. Вывод поля оценки( rating ) должден сопровождаться именем закзчика и его номером.
   * Напишите запрос который бы выводил общие порядки на каждый день и помещал результаты в нисходящем порядке.
   
## Глава 8. ЗАПРАШИВАНИЕ МНОГОЧИСЛЕНЫХ ТАБЛИЦ ТАКЖЕ КАК ОДНОЙ
 
   ДО ЭТОГО, КАЖДЫЙ ЗАПРОС КОТОРЫЙ МЫ ИССЛЕДОВАЛИ основывался на одиночной таблице. В этой главе, вы узнаете как сделать запрос любого числа таблиц с помощью одной команды. Это - чрезвычайно мощное средство потому что оно не только объединяет вывод из многочисленых таблиц, но и определяет связи между ними. Вы обучитесь различным формам которые могут использовать эти связи, а также устанавливать и использовать их чтобы удовлетворять возможным специальным требованиям.
### ОБЪЕДИНЕНИЕ ТАБЛИЦ
   Одна из наиболее важных особенностей запросов SQL - это их способность определять связи между многочислеными таблицами и выводить информацию из них в терминах этих связей, всю внутри одной команды. Этот вид операции называется - объединением, которое является одним из видов операций в реляционных базах данных. Как установлено в Главе 1, главное в реляционном подходе это связи которые можно создавать между позициями данных в таблицах. Используя обьединения, мы непосредственно связываем информацию с любым номером таблицы, и таким образом способныоздавать связи между сравнимыми фрагментами данных. При обьединении, таблицы представленые списком в предложении FROM запроса, отделяются запятыми. Предикат запроса может ссылаться к любому столбцу любой связанной таблицы и, следовательно, может использоваться для связи между ими. Обычно, предикат сравнивает значения в столбцах различных таблиц чтобы определить, удовлетворяет ли WHERE установленному условию.
### ИМЕНА ТАБЛИЦ И СТОЛБЦОВ
   Полное имя столбца таблицы фактически состоит из имени таблицы, сопровождаемого точкой и затем именем столбца. Имеются несколько примеров имен:
   
    Salespeople.snu
    Salespeople.city
    Orders.odate
 
   До этого, вы могли опускать имена таблиц потому что вы запрашивали только одну таблицу одновременно, а SQL достаточно интелектуален чтобы присвоить соответствующий префикс, имени таблицы. Даже когда вы делаете запрос многочисленых таблиц, вы еще можете опускать имена таблиц, если все ее столбцы имеют различные имена. Но это не всегда так бывает. Например, мы имеем две типовые таблицы со столбцами называемыми city.
   Если мы должны связать эти столбцы( кратковременно ), мы будем должны указать их с именами Salespeople.city или Customers.city, чтобы SQL мог их различать.
### СОЗДАНИЕ ОБЬЕДИНЕНИЯ
   Предположим что вы хотите поставить в соответствии вашему продавцу ваших заказчиков в городе в котором они живут, поэтому вы увидите все комбинации продавцов и заказчиков для этого города. Вы будете должны брать каждого продавца и искать в таблице Заказчиков всех заказчиков того же самого города. Вы могли бы сделать это, введя следующую команду (вывод показывается в Таблице 8.1 ):
 
    SELECT Customers.cname, Salespeople.sname,
    Salespeople.city
    FROM Salespeople, Customers
    WHERE Salespeople.city=Customers.city;
    
SQL Execution Log

    SELECT Customers.cname, Salespeople.sname, Salespeople.city
    FROM Salespeople, Customers WHERE Salespeople.city=Customers.city
    
|    cname                                 |    cname                                 |    city                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    Hoffman<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    Hoffman<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    Liu<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |
|    Cisneros<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |
|    Hoffman<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    Clemens<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |


Таблица 8.1: Объединение двух таблиц
   Так как это поле city имеется и в таблице Продавцов и таблице Заказчиков, имена таблиц должны использоваться как префиксы. Хотя это необходимо только когда два или более полей имеют одно и то же имя, в любом случае это хорошая идея включать имя таблицы в обьединение для лучшего понимания и непротиворечивости. Несмотря на это, мы будем, в наших примерах далее, использовать имена таблицы только когда необходимо, так что будет ясно, когда они необходимы а когда нет.
   Что SQL в основном делает в обьединении - так это исследует каждую комбинацию строк двух или более возможных таблиц, и проверяет эти комбинации по их предикатам. В предыдущем примере, требовалась строка продавца Peel из таблицы Продавцов и объединение ее с каждой строкой таблицы Пользователей, по одной в каждый момент времени. Если комбинация производит значение которое делает предикат верным, и если поле city из строк таблиц Заказчика равно London, то Peel - это то запрашиваемое значение которое комбинация выберет для вывода. То же самое будет затем выполнено для каждого продавца в таблице Продавцов (у некоторых из которых небыло никаких заказчиков в этих городах).
### ОБЪЕДИНЕНИЕ ТАБЛИЦ ЧЕРЕЗ СПРАВОЧНУЮ ЦЕЛОСТНОСТЬ
   Эта особенность часто используется просто для эксплуатации связей встроенных в базу данных. В предыдущем примере, мы установили связь между двумя таблицами в обьединении. Это прекрасно. Но эти таблицы, уже были соединены через snum поле. Эта связь называется состоянием справочной целостности, как мы уже говорили в Главе 1. Используя обьединение можно извлекать данные в терминах этой связи. Например, чтобы показать имена всех заказчиков соответствующих продавцам которые их обслуживают, мы будем использовать такой запрос:
   
    SELECT Customers.cname, Salespeople.sname
    FROM Customers, Salespeople
    WHERE Salespeople.snum=Customers.snum;
   Вывод этого запроса показывается в Таблица 8.2.
   Это - пример обьединения, в котором столбцы используются для определения предиката запроса, и в этом случае, snum столбцы из обеих таблиц, удалены из вывода. И это прекрасно. Вывод показывает какие заказчики каким продавцом обслуживаются; значения поля snum которые устанавливают связь - отсутствуют. Однако если вы введете их в вывод, то вы должны или удостовериться что вывод понятен сам по себе или обеспечить коментарий к данным при выводе.
   
 
SQL Execution Log

    SELECT Customers.cname, Salespeople.sname,
    FROM Salespeople, Customers
    WHERE Salespeople.snum=Customers.snum
    
|    cname                                 |    sname                                 |
|------------------------------------------|------------------------------------------|
|    Hoffman<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |
|    Giovanni<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |
|    Liu<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |
|    Grass<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |
|    Clemens<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |
|    Cisneros<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |
|    Pereira<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |

Таблица 8.2: Объединение продавцов с их заказчикам
### ОБЪЕДИНЕНИЯ ТАБЛИЦ ПО РАВЕНСТВУ ЗНАЧЕНИЙ В СТОЛБЦАХ И ДРУГИЕ ВИДЫ ОБЪЕДИНЕНИЙ
   Обьединения которые используют предикаты основанные на равенствах называются - объединениями по равенству. Все наши примеры в этой главе до настоящего времени, относились именно к этой категории, потому что все условия в предложениях WHERE базировались на математических выражениях использующих знак равно (=). Строки 'city='London' и 'Salespeople.snum=Orders.snum ' - примеры таких типов равенств найденных в предикатах. Объединения по равенству - это вероятно наиболее общий вид объединения, но имеются и другие. Вы можете, фактически, использовать любой из реляционных операторов в обьединении. Здесь показан пример другого вида объединения (вывод показывается в Таблице 8.3):
 
    SELECT sname, cname
    FROM Salespeople, Customers
    WHERE sname < cname
    AND rating < 200;
 
SQL Execution Log

    SELECT sname, cname FROM Salespeople, Customers
    WHERE sname < cname AND rating < 200;
    
|    sname                                 |    cname                                 |
|------------------------------------------|------------------------------------------|
|    Peel<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |
|    Motika<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |
|    Axelrod<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |
|    Axelrod<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |
|    Axelrod<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |


   Таблица 8.3: Обьединение основанное на неравенстве
   Эта команда не часто бывает полезна. Она воспроизводит все комбинации имени продавца и имени заказчика так, что первый предшествует последнему в алфавитном порядке, а последний имеет оценку меньше чем 200.
   Обычно, вы не создаете сложных связей подобно этой, и, по этой причине, вы вероятно будете строить наиболее общие объединения по равенству, но вы должны хорошо знать и другие возможности.
### ОБЪЕДИНЕНИЕ БОЛЕЕ ДВУХ ТАБЛИЦ
   Вы можете также создавать запросы объединяющие более двух таблиц.
   Предположим что мы хотим найти все порядки заказчиков не находящихся в тех городах где находятся их продавцы.Для этого необходимо связать все три наши типовые таблицы (вывод показывается в Таблице 8.4 ):
 
    SELECT onum, cname, Orders.cnum, Orders.snum
    FROM Salespeople, Customers,Orders
    WHERE Customers.city < > Salespeople.city
    AND Orders.cnum=Customers.cnum
    AND Orders.snum=Salespeople.snum;
 
SQL Execution Log

    SELECT onum, cname, Orders.cnum, Orders.snum
    FROM Salespeople, Customers, Orders
    WHERE Customers.city < > Salespeople.city
    AND Orders.cnum=Customers.cnum
    AND Orders.snum=Salespeople.snum;
    
|    onum                                  |    cname                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3001<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3002<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3007<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |


   Таблица 8. 4: Объединение трех таблиц
   Хотя эта команда выглядит скорее как комплексная, вы можете следовать за логикой, просто проверяя - что заказчики не размещены в тех городах где размещены их продавцы (совпадение двух snum полей ), и что перечисленные порядки - выполнены с помощью этих заказчиков( совпадение порядков с полями cnum и snum в таблице Порядков ).
### РЕЗЮМЕ
   Теперь вы больше не ограничиваетесь просмотром одной таблицы в каждый момент времени. Кроме того, вы можете делать сложные сравнения между любыми полями любого числа таблиц и использовать полученные результаты чтобы решать какую информацию вы бы хотели видеть. Фактически, эта методика настолько полезна для построения связей, что она часто используется для создания их внутри одиночной таблицы. Это будет правильным: вы сможете объединить таблицу с собой, а это очень удобная вещь.
   Это будет темой Главы 9.
### РАБОТА С SQL
   * Напишите запрос который бы вывел список номеров порядков сопровождающихся именем заказчика который создавал эти порядки.
   * Напишите запрос который бы выдавал имена продавца и заказчика для каждого порядка после номера порядков.
   * Напишите запрос который бы выводил всех заказчиков обслуживаемых продавцом с комиссионными выше 12% . Выведите имя заказчика, имя продавца, и ставку комиссионных продавца.
   * Напишите запрос который вычислил бы сумму комиссионных продавца для каждого порядка заказчика с оценкой выше 100.



 
 
