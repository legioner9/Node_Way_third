## Глава 19. ПОДДЕРЖКА ЦЕЛОСТНОСТИ ВАШИХ ДАННЫХ
 
   РАНЕЕ В ЭТОЙ КНИГЕ, МЫ УКАЗЫВАЛИ НА ОПРЕДЕЛЕННЫЕ связи которые существуют между некоторыми полями наших типовых таблиц. Поле snum таблицы Заказчиков, например, соответствует полю snum в таблице Продавцов и таблице Порядков. Поле cnum таблицы Заказчиков также соответствует полю cnum таблицы Порядков. Мы назвали этот тип связи - справочной целостностью; и в ходе обсуждения, вы видели как ее можно использовать.
 
   В этой главе, вы будете исследовать справочную целостность более подробно и выясним все относительно ограничений которые вы можете использовать чтобы ее поддерживать. Вы также увидете, как предписывается это ограничение когда вы используете команды модификации DML. Поскольку справочная целостность включает в себя связь полей или групп полей, часто в разных таблицах, это действие может быть несколько сложнее чем другие ограничения. По этой причине, хорошо иметь с ней полное знакомство, даже если вы не планируете создавать таблицы. Ваши команды модификации могут стать эффективнее с помощью ограничения справочной целостности (как и с помощью других ограничений, но ограничение справочной целостности может воздействовать на другие таблицы кроме тех в которых оно определено), а определенные функции запроса, такие как обьединения, являются многократно структурированы в терминах связей справочной целостности (как подчеркивалось в Главе 8 ).
### ВНЕШНИЙ КЛЮЧ И РОДИТЕЛЬСКИЙ КЛЮЧ
   Когда все значения в одном поле таблицы представлены в поле другой таблицы, мы говорим что первое поле ссылается на второе. Это указывает на прямую связь между значениями двух полей. Например, каждый из заказчиков в таблице Заказчиков имеет поле snum которое указывает на продавца назначенного в таблице Продавцов. Для каждого порядка в таблице Порядков, имеется один и только этот продавец и один и только этот заказчик. Это отображается с помощью полей snum и cnum в таблице Порядков.
   Когда одно поле в таблице ссылается на другое, оно называется - внешним ключом; а поле на которое оно ссылается, называется - родительским ключом. Так что поле snum таблицы Заказчиков - это внешний ключ, а поле snum на которое оно ссылается в таблице Продавцов - это родительский ключ.
   Аналогично, поля cnum и snum таблицы Порядков - это внешние ключи которые ссылаются к их родительским ключам с именами в таблице Заказчиков и таблице Продавцов. Имена внешнего ключа и родительского ключа не обязательно должны быть одинаковыми, это - только соглашение которому мы следуем чтобы делать соединение более понятным.
### МНОГО-СТОЛБЦОВЫЕ ВНЕШНИЕ КЛЮЧИ
   В действительности, внешний ключ не обязательно состоит только из одного поля. Подобно первичному ключу, внешний ключ может иметь любое число полей, которые все обрабатываются как единый модуль. Внешний ключ и родительский ключ на который он ссылается, конечно же, должны иметь одинаковый номер и тип поля, и находиться в одинаковом порядке.
   Внешние ключи состоящие из одного поля - те что мы использовали исключительно в наших типовых таблицах, наиболее общие. Чтобы сохранить простоту нашего обсуждения, мы будем часто говорить о внешнем ключе как об одиночном столбце. Это не случайно. Если это не отметить, любой скажет о поле которое является внешним ключом, что оно также относится и к группе полей которая является внешним ключом.
### СМЫСЛ ВНЕШНЕГО И РОДИТЕЛЬСКОГО КЛЮЧЕЙ
   Когда поле - является внешним ключом, оно определеным образом связано с таблицей на которую он ссылается. Вы, фактически, говорите - "каждое значение в этом поле (внешнем ключе ) непосредственно привязано к значению в другом поле (родительском ключе )." Каждое значение (каждая строка ) внешнего ключа должно недвусмысленно ссылаться к одному и только этому значению (строке) родительского ключа. Если это так, то фактически ваша система, как говорится, будет в состоянии справочной целостности.
   Вы можете увидеть это на примере. Внешний ключ snum в таблице Заказчиков имеет значение 1001 для строк Hoffman и Clemens. Предположим что мы имели две строки в таблице Продавцов со значением в поле snum=1001. Как мы узнаем, к которому из двух продавцов были назначены заказчики Hoffman и Clemens ? Аналогично, если нет никаких таких строк в таблице Продавцов, мы получим Hoffman и Clemens назначенными к продавцу которого не существует!
   
Понятно, что каждое значение во внешнем ключе должно быть представлено один, и только один раз, в родительском ключе.
   Фактически, данное значение внешнего ключа может ссылаться только к одному значению родительского ключа не предполагая обратной возможности: т.е. любое число внешних ключей может ссылать к единственному значению родительского ключа. Вы можете увидеть это в типовых таблицах наших примеров. И Hoffman и Clemens назначены к Peel, так что оба их значения внешнего ключа совпадают с одним и тем же родительским ключом, что очень хорошо. Значение внешнего ключа должно ссылаться только к одному значению родительского ключа, зато значение родительского ключа может ссылаться с помощью любого колличества значений внешнего ключа. В качестве иллюстрации, значения внешнего ключа из таблицы Заказчиков, совпавшие с их родительским ключом в Продавцов таблице, показываются на Рисунке 19.1. Для удобства мы не учитывали поля не относящиеся к этому примеру.
### ОГРАНИЧЕНИЕ FOREIGN KEY
   SQL поддерживает справочную целостность с ограничением FOREIGN KEY.
   Хотя ограничение FOREIGN KEY - это новая особенность в SQL, оно еще не обеспечивает его универсальности. Кроме того, некоторые его реализации, более сложны чем другие. Эта функция должна ограничивать значения которые вы можете ввести в вашу базу данных чтобы заставить внешний ключ и родительский ключ соответствовать принципу справочной целостности. Одно из действий ограничения Внешнего Ключа - это отбрасывание значений для полей ограниченных как внешний ключ который еще не представлен в родительском ключе. Это ограничение также воздействует на вашу способность изменять или удалять значения родительского ключа (мы будем обсуждать это позже в этой главе ).
### КАК МОЖНО ПОЛЯ ПРЕДСТАВИТЬ В КАЧЕСТВЕ ВНЕШНИХ КЛЮЧЕЙ
   Вы используете ограничение FOREIGN KEY в команде CREATE TABLE (или ALTER TABLE ), которая содержит поле которое вы хотите обьявить внешним ключом. Вы даете имя родительскому ключу на которое вы будете ссылаться внутри ограничения FOREIGN KEY. Помещение этого ограничения в команду - такое же что в для других ограничений обсужденных в предыдущей главе.
 
    {}
 
   Рисунок 19.1: Внешний Ключ таблицы Заказчиков с родительским ключом
   Подобно большинству ограничений, оно может быть ограничением таблицы или столбца, в форме таблицы позволяющей использовать многочисленые поля как один внешний ключ.
### ВНЕШНИЙ КЛЮЧ КАК ОГРАНИЧЕНИЕ ТАБЛИЦЫ
   Синтаксис ограничения таблицы FOREIGN KEY:
 
    FOREIGN KEY <column list> REFERENCES
    <pktable> [ <column list> ]
 
   Первый список столбцов - это список из одного или более столбцов таблицы, которые отделены запятыми и будут созданы или изменены этой командой. Pktable - это таблица содержащая родительский ключ. Она может быть таблицей, которая создается или изменяется текущей командой.
   Второй список столбцов - это список столбцов которые будут составлять родительский ключ. Списки двух столбцов должны быть совместимы, т.е.:
   * Они должны иметь одинаковое число столбцов.
   * В данной последовательности, первый, второй, третий, и т.д., столбцы списка столбцов внешнего ключа, должны иметь одинаковые типы данных и размеры, что и первый, второй, третий, и т.д., столбцы списка столбцов родительского ключа. Столбцы в списках обоих столбцов не должны иметь одинаковых имен, хотя мы и использовали такой способ в наших примерах чтобы делать связь более понятной.
 
   Создадим таблицу Заказчиков с полем snum определенным в качестве внешнего ключа ссылающегося на таблицу Продавцов:
 
    CREATE TABLE Customers
    ( cnum integer NOT NULL PRIMARY KEY
    cname char(10),
    city char(10),
    snum integer,
    FOREIGN KEY (snum) REFERENCES Salespeople
    ( snum );
 
   Имейте в виду, что при использовании ALTER TABLE вместо CREATE TABLE, для применения ограничения FOREIGN KEY, значения которые Вы указываете во внешнем ключе и родительском ключе, должны быть в состоянии справочной целостности. Иначе команда будет отклонена. Хотя ALTER TABLE очень полезна из-за ее удобства, вы должны будете в вашей системе, по возможности каждый раз, сначала формировать структурные принципы, типа справочной целостности.
### ВНЕШНИЙ КЛЮЧ КАК ОГРАНИЧЕНИЕ СТОЛБЦОВ
   Вариант ограничения столбца ограничением FOREIGN KEY - по другому называется - ссылочное ограничение (REFERENCES), так как он фактически не содержит в себе слов FOREIGN KEY, а просто использует слово REFERENCES, и далее имя родительского ключа, подобно этому:
 
    CREATE TABLE Customers
    ( cnum integer NOT NULL PRIMARY KEY,
    cname char(10),
    city char(10),
    snum integer REFERENCES Salespeople (snum));
 
   Вышеупомянутое определяет Customers.snum как внешний ключ у которого родительский ключ - это Salespeople.snum. Это эквивалентно такому ограничению таблицы:
 
    FOREIGN KEY (snum) REGERENCES Salespeople (snum)
    
### НЕ УКАЗЫВАТЬ СПИСОК СТОЛБЦОВ ПЕРВИЧНЫХ КЛЮЧЕЙ
   Используя ограничение FOREIGN KEY таблицы или столбца, вы можете не указывать список столбцов родительского ключа если родительский ключ имеет ограничение PRIMARY KEY. Естественно, в случае ключей со многими полями, порядок столбцов во внешних и первичных ключах должен совпадать, и, в любом случае, принцип совместимости между двумя ключами все еще применим. Например, если мы поместили ограничение PRIMARY KEY в поле snum таблицы Продавцов, мы могли бы использовать его как внешний ключ в таблице Заказчиков (подобно предыдущему примеру) в этой команде:
 
    CREATE TABLE Customers
    ( cnum integer NOT NULL PRIMARY KEY,
    cname char(10),
    city char(10),
    snum integer REFERENCES Salespeople);
 
   Это средство встраивалось в язык, чтобы поощрять вас использовать первичные ключи в качестве родительских ключей.
### КАК СПРАВОЧНАЯ ЦЕЛОСТНОСТЬ ОГРАНИЧИВАЕТ ЗНАЧЕНИЯ РОДИТЕЛЬСКОГО КЛЮЧА
   Поддержание справочной целостности требует некоторых ограничений на значения, которые могут быть представлены в полях, обьявленных как внешний ключ и родительский ключ. Родительский ключ должен быть структурен, чтобы гарантировать, что каждое значение внешнего ключа будет соответствовать одной указанной строке. Это означает, что он (ключ) должен быть уникальным и не содержать никаких пустых значений(NULL).
   Этого не достаточно для родительского ключа в случае выполнения такого требования как при объявлении внешнего ключа. SQL должен быть уверен что двойные значения или пустые значения (NULL) не были введены в родительский ключ. Следовательно вы должны убедиться, что все поля, которые используются как родительские ключи, имеют или ограничение PRIMARY KEY или ограничение UNIQUE, наподобии ограничения NOT NULL.
### ПЕРВИЧНЫЙ КЛЮЧ КАК УНИКАЛЬНЫЙ ВНЕШНИЙ КЛЮЧ
   Ссылка ваших внешних ключей только на первичные ключи, как мы это делали в типовых таблицах, - хорошая стратегия. Когда вы используете внешние ключи, вы связываете их не просто с родительскими ключами на которые они ссылаются; вы связываете их с определенной строкой таблицы где этот родительский ключ будет найден. Сам по себе родительский ключ не обеспечивает никакой информации которая бы не была уже представлена во внешнем ключе. Смысл, например, поля snum как внешнего ключа в таблице Заказчиков - это связь которую он обеспечивает, не к значению поля snum на которое он ссылается, а к другой информации в таблице Продавцов, такой например как, имена продавцов, их местоположение, и так далее. Внешний ключ - это не просто связь между двумя идентичными значениями; это - связь, с помощью этих двух значений, между двумя строками таблицы указанной в запросе.
   Это поле snum может использоваться чтобы связывать любую информацию в строке из таблицы Заказчиков со ссылочной строкой из таблицы Продавцов - например чтобы узнать - живут ли они в том же самом городе, кто имеет более длинное имя, имеет ли продавец кроме данного заказчика каких-то других заказчиков, и так далее.
   Так как цель первичного ключа состоит в том, чтобы идентифицировать уникальность строки, это более логичный и менее неоднозначный выбор для внешнего ключа. Для любого внешнего ключа который использует уникальный ключ как родительский ключ, вы должны создать внешний ключ который бы использовал первичный ключ той же самой таблицы для того же самого действия. Внешний ключ который не имеет никакой другой цели кроме связывания строк, напоминает первичный ключ используемый исключительно для идентификации строк, и является хорошим средством сохранить структуру вашей базы данных ясной и простой, и - следовательно создающей меньше трудностей.
### ОГРАНИЧЕНИЯ ВНЕШНЕГО КЛЮЧА
   Внешний ключ, в частности, может содержать только те значения которые фактически представлены в родительском ключе или пустые(NULL). Попытка ввести другие значения в этот ключ будет отклонена.
   Вы можете обьявить внешний ключ как NOT NULL, но это необязательно, и в большинстве случаев, нежелательно. Например, предположим, что вы вводите заказчика не зная заранее, к какому продавцу он будет назначен. Лучший выход в этой ситуации, будет если использовать значение NOT NULL, которое должно быть изменено позже на конкретное значение.
### ЧТО СЛУЧИТСЯ, ЕСЛИ ВЫ ВЫПОЛНИТЕ КОМАНДУ МОДИФИКАЦИИ
   Давайте условимся, что все внешние ключи созданые в наших таблицах примеров, обьявлены и предписаны с ограничениями внешнего ключа, следующим образом:
 
    CREATE TABLE Salespeople
    (snum integer NOT NULL PRIMARY KEY,
    sname char(10) NOT NULL,
    city char(10),
    comm decimal);

    CREATE TABLE Customers
    (cnum integer NOT NULL PRIMARY KEY,
    cname char(10) NOT NULL,
    city char(10),
    rating integer,
    snum integer,
    FOREIGN KEY (snum) REFERENCES Salespeople,
    UNIQUE (cnum, snum) ;
    
    CREATE TABLE Orders
    (cnum integer NOT NULL PRIMARY KEY,
    amt decimal,
    odate date NOT NULL,
    cnum integer NOT NULL
    snum integer NOT NULL
    FOREIGN KEY (cnum, snum) REFERENCES
    CUSTOMERS (cnum, snum);
 
### ВКЛЮЧЕНИЕ ОПИСАНИЙ ТАБЛИЦЫ
   Имеется несколько атрибутов таких определений о которых нужно поговорить. Причина по которой мы решили сделать поля cnum и snum в таблице Порядков, единым внешним ключом - это гарантия того, что для каждого заказчика содержащегося в порядках, продавец кредитующий этот порядок - тот же что и указаный в таблице Заказчиков. Чтобы создать такой внешний ключ, мы были бы должны поместить ограничение таблицы UNIQUE в два поля таблицы Заказчиков, даже если оно необязательно для самой этой таблицы. Пока поле cnum в этой таблица имеет ограничение PRIMARY KEY, оно будет уникально в любом случае, и следовательно невозможно получить еще одну комбинацию поля cnum с каким-то другим полем.
   Создание внешнего ключа таким способом поддерживает целостность базы данных, даже если при этом вам будет запрещено внутреннее прерывание по ошибке и кредитовать любого продавца, иного чем тот который назначен именно этому заказчику. С точки зрения поддержания целостности базы данных, внутренние прерывания (или исключения ) конечно же нежелательны. Если вы их допускаете и в то же время хотите поддерживать целостность вашей базы данных, вы можете обьявить поля snum и cnum в таблице Порядков независимыми внешними ключами этих полей в таблице Продавцов и таблице Заказчиков, соответственно. Фактически, использование поля snum в таблице Порядков, как мы это делали, необязательно, хотя это полезно было сделать для разнообразия. Поле cnum связывая каждый порядок заказчиков в таблице Заказчиков, в таблице Порядков и в таблице Заказчиков, должно всегда быть общим чтобы находить правильное поле snum для данного порядка (не разрешая никаких исключений).
   Это означает что мы записываем фрагмент информации - какой заказчик назначен к какому продавцу - дважды, и нужно будет выполнять дополнительную работу чтобы удостовериться, что обе версии согласуются. Если мы не имеем ограничения внешнего ключа как сказано выше, эта ситуация будет особенно проблематична, потому что каждый порядок нужно будет проверять вручную (вместе с запросом ), чтобы удостовериться что именно соответствующий продавец кредитовал каждую соответствующую продажу.
   
 Наличие такого типа информационной избыточности в вашей базе данных, называется деморализация (denormalization ), что не желательно в идеальной реляционной базе данных, хотя практически и может быть разрешена. Деморализация может заставить некоторые запросы выполняться быстрее, поскольку запрос в одной таблице выполняется всегда значительно быстрее чем в обьединении.
### ДЕЙСТВИЕ ОГРАНИЧЕНИЙ
   Как такие ограничения воздействуют на возможность и невозможность Вами использовать команды модификации DML? Для полей, определенных как внешние ключи, ответ довольно простой: любые значения которые вы помещаете в эти поля с командой INSERT или UPDATE должны уже быть представлены в их родительских кючах. Вы можете помещать пустые(NULL) значения в эти поля, несмотря на то что значения NULL не позволительны в родительских ключах, если они имеют ограничение NOT NULL. Вы можете удалять (DELETE ) любые строки с внешними ключами не используя родительские ключи вообще. Поскольку затронут вопрос об изменении значений родительского ключа, ответ, по определению ANSI, еще проще, но возможно несколько более ограничен: любое значение родительского ключа ссылаемого с помощью значения внешнего ключа, не может быть удалено или изменено. Это означает, например, что вы не можете удалить заказчика из таблицы Заказчиков пока он еще имеет порядки в таблице Порядков. В зависимости от того, как вы используете эти таблицы, это может быть или желательно или хлопотно. Однако - это конечно лучше чем иметь систему, которая позволит вам удалить заказчика с текущими порядками и оставить таблицу Порядков ссылающейся на несуществующих заказчиков.
   Смысл этой системы оганичения в том, что создатель таблицы Порядков, используя таблицу Заказчиков и таблицу Продавцов как родительские ключи может наложить значительные ограничения на действия в этих таблицах. По этой причине, вы не сможете использовать таблицу которой вы не распоряжаетесь (т.е. не вы ее создавали и не вы являетесь ее владельцем), пока владелец(создатель) этой таблицы специально не передаст вам на это право (что объясняется в Главе 22).
   Имеются некоторые другие возможные действия изменения родительского ключа, которые не являются частью ANSI, но могут быть найдены в некоторых коммерческих программах. Если вы хотите изменить или удалить текущее ссылочное значение родительского ключа, имеется по существу три возможности:
 
   * Вы можете ограничить, или запретить, изменение (способом ANSI ), обозначив, что изменения в родительском ключе - ограничены.
   * Вы можете сделать изменение в родительском ключе и тем самым сделать изменения во внешнем ключе автоматическим, что называется - каскадным изменением.
   * Вы можете сделать изменение в родительском ключе, и установить внешний ключ в NULL, автоматически (полагая, что NULLS разрешен во внешнем ключе ), что называется - пустым изменением внешнего ключа.
 
   Даже в пределах этих трех категорий, вы можете не захотеть обрабатывать все команды модификации таким способом. INSERT, конечно, к делу не относится. Он помещает новые значения родительского ключа в таблицу, так что ни одно из этих значений не может быть вызвано в данный момент. Однако, вы можете захотеть позволить модификациям быть каскадными, но без удалений, и наоборот. Лучшей может быть ситуация которая позволит вам определять любую из трех категорий, независимо от команд UPDATE и DELETE. Мы будем следовательно ссылаться на эффект модификации (update effects) и эффект удаления (delete effects ), котторые определяют, что случитс если вы выполните команды UPDATE или DELETE в родительском ключе. Эти эффекты, о которых мы говорили, называются: Ограниченные (RESTRICTED) изменения, Каскадируемые (CASCADES) изменения, и Пустые (NULL) изменения.
   Фактические возможности вашей системы должны быть в строгом стандарте ANSI - это эффекты модификации и удаления, оба, автоматически ограниченнные - для более идеальной ситуации описаной выше. В качестве иллюстрации, мы покажем несколько примеров того, что вы можете делать с полным набором эффектов модификации и удаления. Конечно, эффекты модификации и удаления, являющиеся нестандартными средствами, испытывают недостаток в стандартном госинтаксисе. Синтаксис который мы используем здесь, прост в написании и будет служить в дальнейшем для иллюстрации функций этих эффектов.
   Для полноты эксперимента, позволим себе предположить что вы имеете причину изменить поле snum таблицы Продавцов в случае, когда наша таблица Продавцов изменяет разделы. (Обычно изменение первичных ключей это не то что мы рекомендуем делать практически. Просто это еще один из доводов для имеющихся первичных ключей которые не умеют делать ничего другого кроме как, действовать как первичные ключи: они не должны изменяться. ) Когда вы изменяете номер продавца, вы хотите чтобы были сохранены все его заказчики. Онако, если этот продавец покидает свою фирму или компанию, вы можете не захотеть удалить его заказчиков, при удалении его самого из базы данных. Взамен, вы захотите убедиться, что заказчики назначены кому-нибудь еще. Чтобы сделать это вы должны указать UPDATE с Каскадируемым эффектом, и DELETE с Ограниченным эффектом.
 
    CREATE TABLE Customers
    (cnum integer NOT NULL PRIMARY KEY,
    cname char(10) NOT NULL,
    city char(10),
    rating integer,
    snum integer REFERENCES Salespeople,
    UPDATE OF Salespeople CASCADES,
    DELETE OF Salespeople RESTRICTED);
 
   Если вы теперь попробуете удалить Peel из таблицы Продавцов, команда будет не допустима, пока вы не измените значение поля snum заказчиков Hoffman и Clemens для другого назначенного продавца. С другой стороны, вы можете изменить значение поля snum для Peel на 1009, и Hoffman и Clemens будут также автоматически изменены.
   Третий эффект - Пустые (NULL) изменения. Бывает, что когда продавцы оставляют компанию, их текущие порядки не передаются другому продавцу.
   С другой стороны, вы хотите отменить все порядки автоматически для заказчиков, чьи счета вы удалите. Изменив номера продавца или заказчика можно просто передать их ему. Пример ниже показывает, как вы можете создать таблицу Порядков с использованием этих эффектов.
 
    CREATE TABLE Orders
    (onum integer NOT NULL PRIMARY KEY,
    amt decimal,
    odate date NOT NULL
    cnum integer NOT NULL REFERENCES Customers
    snum integer REFERENCES Salespeople,
    UPDATE OF Customers CASCADES,
    DELETE OF Customers CASCADES,
    UPDATE OF Salespeople CASCADES,
    DELETE OF Salespeople NULLS);
 
   Конечно, в команде DELETE с эффектом Пустого изменения в таблице Продавцов, ограничение NOT NULL должно быть удалено из поля snum.
### ВНЕШНИЕ КЛЮЧИ КОТОРЫЕ ССЫЛАЮТСЯ ОБРАТНО К ИХ ПОДЧИНЕНЫМ ТАБЛИЦАМ
   Как было упомянуто ранее, ограничение FOREIGN KEY может представить имя этой частной таблице, как таблицы родительского ключа. Далеко не будучи простой, эта особенность может пригодиться. Предположим, что мы имеем таблицу Employees с полем manager(администратор). Это поле содержит номера каждого из служащих, некоторые из которых являются еще и администраторами. Но так как каждый администратор - в то же время остается служащим, то он естественно будут также представлен в этой таблице. Давайте создадим таблицу, где номер служащего (столбец с именем empno ), объявляется как первичный ключ, а администратор, как внешний ключ, будет ссылаться на нее:
 
    CREATE TABLE Employees
    (empno integer NOT NULL PRIMARY KEY,
    name char(10) NOT NULL UNIOUE,
    manager integer REFERENCES Employees);
 
   ( Так как внешний ключ это ссылаемый первичный ключ таблицы, список столбцов может быть исключен. ) Имеется содержание этой таблицы:
 
|    EMPNO                                 |    NAME                                  |    MANAGER                               |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    1003<br style="margin: 0px; padding: 0px;"> |    Terrence<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Atali<br style="margin: 0px; padding: 0px;"> |    NULL<br style="margin: 0px; padding: 0px;"> |
|    1688<br style="margin: 0px; padding: 0px;"> |    McKenna<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    2002<br style="margin: 0px; padding: 0px;"> |    Collier<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |

  Как вы можете видеть, каждый из них( но не Atali ), ссылается на другого служащего в таблице как на своего администратора. Atali, имеющий наивысший номер в таблице, должен иметь значение установленное в NULL. Это дает другой принцип справочной целостности. Внешний ключ, который ссылается обратно к частной таблице, должен позволять значения=NULL. Если это не так, как бы вы могли вставить первую строку ? Даже если эта первая строка ссылается к себе самой, значение родительского ключа должно уже быть установлено, когда вводится значение внешнего ключа. Этот принцип будет верен, даже если внешний ключ ссылается обратно к частной таблице не напрямую а с помощью ссылки к другой таблице, которая затем ссылается обратно к таблице внешнего ключа. Например, предположим, что наша таблица Продавцов имеет дополнительное поле
   которое ссылается на таблицу Заказчиков, так, что каждая таблица ссылается на другую, как показано в следующем операторе CREATE TABLE:
 
    CREATE TABLE Salespeople
    (snum integer NOT NULL PRIMARY KEY,
    sname char(10) NOT NULL,
    city char(10),
    comm declmal,
    cnum integer REFERENCES Customers);
    
    CREATE TABLE Customers
    (cnum integer NOT NULL PRIMARY KEY,
    cname char(10) NOT NULL,
    city char(10),
    rating integer,
    snum integer REFERENCES Salespeople);
 
   Это называется - перекрестной ссылкой. SQL поддерживает это теоретически, но практически это может составить проблему. Любая таблица из этих двух, созданная первой является ссылочной таблицей которая еще не существует для другой. В интересах обеспечения перекрестной ссылки, SQL фактически позволяет это, но никакая таблица не будет пригодна для использования пока они обе находятся в процессе создания. С другой стороны, если эти две таблицы создаются различными пользователями, проблема становится еще более трудной. Перекрестная ссылка может стать полезным инструментом, но она не без неоднозначности и опасностей.
   Предшествующий пример, например, не совсем пригоден для использования: потому что он ограничивает продавца одиночным заказчиком, и кроме того совсем необязательно использовать перекресную ссылку чтобы достичь этого. Мы рекомендуем чтобы вы были осторожны в его использовании и анализировали, как ваши программы управляют эффектами модификации и удаления а также процессами привилегий и диалоговой обработки запросов перед тем как вы создаете перекресную систему справочной целостности.
   ( Привилегии и диалоговая обработка запросов будут обсуждаться, соответственно, в Главах 22 И 23.)
### РЕЗЮМЕ
   Теперь вы имеете достаточно хороше управление справочной целостностью. Основная идея в том, что все значения внешнего ключа ссылаются к указанной строке родительского ключа. Это означает, что каждое значение внешнего ключа должно быть представлено один раз, и только один раз, в родительском ключе. Всякий раз, когда значение помещается во внешний ключ, родительский ключ проверяется, чтобы удостовериться, что его значение представлено; иначе, команда будет отклонена. Родительский ключ должен иметь Первичный Ключ (PRIMARY KEY) или Уникальное (UNIQUE) ограничение, гарантирующее, что значение не будет представлено более чем один раз. Попытка изменить значение родительского ключа, которое в настоящее время представлено во внешнем ключе, будет вообще отклонена. Ваша система может, однако, предложить вам выбор, чтобы получить значение внешнего ключа установленого в NULL или для получения нового значения родителького ключа, и указания какой из них может быть получен независимо для команд UPDATE и DELETE. Этим завершается наше обсуждение команды CREATE TABLE. Далее мы представим вас другому типу команды - CREATE. В Главе 20, вы обучитесь представлению объектов данных которые выглядят и действуют подобно таблице, но в действительности являются результатами запросов. Некоторые функции ограничений могут также выполняться представлениями, так что вы сможете лучше оценить вашу потребность к ограничениям, после того, как вы прочитаете следующие три главы.

### РАБОТА С SQL
   * Создайте таблицу с именем Cityorders. Она должна содержать такие же поля onum, amt, и snum что и таблица Порядков, и такие же поля cnum и city что и таблица Заказчиков, так что порядок каждого заказчика будет вводиться в эту таблицу вместе с его городом. Поле оnum будет первичным ключом Cityorders. Все поля в Cityorders должны иметь ограничения при сравнении с таблицами Заказчиков и Порядков. Допускается, что родительские ключи в этих таблицах уже имеют соответствующие ограничения.
   * Усложним проблему. Переопределите таблицу Порядков следующим образом: добавьте новый столбец с именем prev, который будет идентифицирован для каждого порядка, поле onum предыдущего порядка для этого текущего заказчика. Выполните это с использованием внешнего ключа ссылающегося на саму таблицу Порядков. Внешний ключ должен ссылаться также на поле cnum заказчика, обеспечивающего определенную предписанную связь между текущим порядком и ссылаемым.
   

## Глава 20. ВВЕДЕНИЕ: ПРЕДСТАВЛЕНИЯ
 
   ПРЕДСТАВЛЕНИЕ (VIEW) - ОБЪЕКТ ДАННЫХ КОТОРЫЙ не содержит никаких данных его владельца. Это - тип таблицы, чье содержание выбирается из других таблиц с помощью выполнения запроса. Поскольку значения в этих таблицах меняются, то автоматически, их значения могут быть показаны представлением.
   В этой главе, вы узнаете что такое представления, как они создаются, и немного об их возможностях и ограничениях. Использование представлений основанных на улучшеных средствах запросов, таких как обьединение и подзапрос, разработаных очень тщательно, в некоторых случаях даст больший выиигрыш по сравнениию с запросами.
### ЧТО ТАКОЕ ПРЕДСТАВЛЕНИЕ?
   Типы таблиц, с которыми вы имели дело до сих пор, назывались - базовыми таблицами. Это - таблицы, которые содержат данные. Однако имеется другой вид таблиц: - представления. Представления - это таблицы чье содержание выбирается или получается из других таблиц. Они работают в запросах и операторах DML точно также как и основные таблицы, но не содержат никаких собственных данных. Представления - подобны окнам, через которые вы просматриваете информацию( как она есть, или в другой форме, как вы потом увидите ), которая фактически хранится в базовой таблице. Представление - это фактически запрос, который выполняется всякий раз, когда представление становится темой команды. Вывод запроса при этом в каждый момент становится содержанием представления.
### КОМАНДА CREATE VIEW
   Вы создаете представление командой CREATE VIEW. Она состоит из слов CREATE VIEW (СОЗДАТЬ ПРЕДСТАВЛЕНИЕ), имени представления которое нужно создать, слова AS (КАК), и далее запроса, как в следующем примере:
 
    CREATE VIEW Londonstaff
    AS SELECT *
    FROM Salespeople
    WHERE city='London';
 
   Теперь Вы имеете представление, называемое Londonstaff. Вы можете использовать это представление точно так же как и любую другую таблицу. Она может быть запрошена, модифицирована, вставлена в, удалена из, и соединена с, другими таблицами и представлениями. Давайте сделаем запрос такого представления (вывод показан в Таблице 20.1):
 
    SELECT *
    FROM Londonstaff;
 
SQL Execution Log

    SELECT * FROM Londonstaff;
    
|    snum                                  |    sname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.1200<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.1100<br style="margin: 0px; padding: 0px;"> |

Таблица 20.1: Представление Londonstaff
   Когда вы приказываете SQL выбрать(SELECT) все строки (* ) из представления, он выполняет запрос содержащий в определении - Loncfonstaff, и возвращает все из его вывода. Имея предикат в запросе представления, можно вывести только те строки из представления, которые будут удовлетворять этому предикату. Вы могли бы вспомнить, что в Главе 15, вы имели таблицу, называемую Londonstaff, в которую вы вставляли это же самое содержание (конечно, мы понимаем что таблица - не слишком велика. Если это так, вы будете должны выбрать другое имя для вашего представления). Преимущество использования представления, по сравнению с основной таблицы, в том, что представление будет модифицировано автоматически всякий раз, когда таблица лежащая в его основе изменяется.
   Содержание представления не фиксировано, и переназначается каждый раз когда вы ссылаетесь на представление в команде. Если вы добавите завтра другого, живущего в Лондоне продавца, он автоматически появится в представлении.
   Представления значительно расширяют управление вашими данными. Это - превосходный способ дать публичный доступ к некоторой, но не всей информации в таблице. Если вы хотите чтобы ваш продавец был показан в таблице Продавцов, но при этом не были показаны комиссии других продавцов, вы могли бы создать представление с использованием следующего оператора (вывод показан в Таблице 20.2 )
 
    CREATE VIEW Salesown
    AS SELECT snum, sname, city
    FROM Salespeople:
 
SQL Execution Log

    SELECT * FROM Salesown;

|    snum                                  |    sname                                 |    city                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barcelona<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |

 Таблица 20.2: Представление Salesown
 
   Другими словами, это представление - такое же как для таблицы Продавцов, за исключением того, что поле comm, не упоминалось в запросе, и следовательно не было включено в представление.
### МОДИФИЦИРОВАНИЕ ПРЕДСТАВЛЕНИЙ
   Представление может теперь изменяться командами модификации DML, но модификация не будет воздействовать на само представление. Команды будут на самом деле перенаправлены к базовой таблице:
 
    UPDATE Salesown
    SET city='Palo Alto'
    WHERE snum=1004;
 
   Его действие идентично выполнению той же команды в таблице Продавцов. Однако, если значение комиссионных продавца будет обработано командой UPDATE
 
    UPDATE Salesown
    SET comm=.20
    WHERE snum=1004;
 
   она будет отвергнута, так как поле comm отсутствует в представлении Salesown. Это важное замечание, показывающее что не все представления могут быть модифицированы. Мы будем исследовать проблемы модификации представлений в Главе 21.
### ИМЕНОВАНИЕ СТОЛБЦОВ
   В нашем примере, поля наших представлений имеют свои имена, полученые прямо из имен полей основной таблицы. Это удобно. Однако, иногда вам нужно снабжать ваши столбцы новыми именами:
   * когда некоторые столбцы являются выводимыми, и проэтому не имеющими имен.
   * когда два или более столбцов в объединении, имеют те же имена что в их базовой таблице.
 
   Имена, которые могут стать именами полей, даются в круглых скобках, после имени таблиц. Они не будут запрошены, если совпадают с именами полей запрашиваемой таблицы. Тип данных и размер этих полей будут отличаются от запрашиваемых полей которые "передаются" в них. Обычно вы не указываете новых имен полей, но если вы все таки сделали это, вы должны делать это для каждого поля в представлении.
### КОМБИНИРОВАНИЕ ПРЕДИКАТОВ ПРЕДСТАВЛЕНИЙ И ОСНОВНЫХ ЗАПРОСОВ В ПРЕДСТАВЛЕНИЯХ
   Когда вы делаете запрос представления, вы собственно, запрашиваете запрос. Основной способ для SQL обойти это, - объединить предикаты двух запросов в один. Давайте посмотрим еще раз на наше представление с именем Londonstaff :
 
    CREATE VIEW Londonstaff
    AS SELECT *
    FROM Salespeople
    WHERE city='London';
 
   Если мы выполняем следующий запрос в этом представлении
 
    SELECT *
    FROM Londonstaff
    WHERE comm > .12;
 
   он такой же как если бы мы выполнили следующее в таблице Продавцов:
 
    SELECT *
    FROM Salespeople
    WHERE city='London'
    AND comm > .12;
 
   Это прекрасно, за исключением того, что появляется возможная проблема с представлением. Имеется возможность комбинации из двух полностью допустимых предикатов и получения предиката который не будет работать. Например, предположим что мы создаем (CREATE) следующее представление:
 
    CREATE VIEW Ratingcount (rating, number)
    AS SELECT rating, COUNT (*)
    FROM Customers
    GROUP BY rating;
 
   Это дает нам число заказчиков которые мы имеем для каждого уровня оценки(rating). Вы можете затем сделать запрос этого представления чтобы выяснить, имеется ли какая-нибудь оценка, в настоящее время назначенная для трех заказчиков:
 
    SELECT *
    FROM Ratingcount
    WHERE number=3;
 
   Посмотрим что случится если мы скомбинируем два предиката:
 
    SELECT rating, COUNT (*)
    FROM Customers
    WHERE COUNT (*)=3
    GROUP BY rating;
 
   Это недопустимый запрос. Агрегатные функции, такие как COUNT (СЧЕТ), не могут использоваться в предикате. Првильным способом при формировании вышеупомянутого запроса, конечно же будет следующий:
 
    SELECT rating, COUNT (*)
    FROM Customers
    GROUP BY rating;
    HAVING COUNT (*)=3;
 
   Но SQL может не выполнить превращения. Может ли равноценный запрос вместо запроса Ratingcount потерпеть неудачу? Да может! Это - неоднозначная область SQL, где методика использования представлений может дать хорошие результаты. Самое лучшее что можно сделать в случае, когда об этом ничего не сказано в вашей системной документации, так это попытка в ней разобраться. Если команда допустима, вы можете использовать представления чтобы установить некоторые ограничения SQL в синтаксисе запроса.
### ГРУППОВЫЕ ПРЕДСТАВЛЕНИЯ
   Групповные представления - это представления, наподобии запроса Ratingcount в предыдущем примере, который содержит предложение GROUP BY, или который основывается на других групповных представлениях.
   Групповые представления могут стать превосходным способом обрабатывать полученную информацию непрерывно. Предположим, что каждый день вы должны следить за порядком номеров заказчиков, номерами продавцов принимающих порядки, номерами порядков, средним от порядков, и общей суммой приобретений в порядках.
   Чем конструировать каждый раз сложный запрос, вы можете просто создать следующее представление:
 
    CREATE VIEW Totalforday
    AS SELECT odate, COUNT (DISTINCT cnum), COUNT
    (DISTINCT snum), COUNT (onum), AVG
    (amt), SUM (amt)
    FROM Orders
    GROUP BY odate;
 
   Теперь вы сможете увидеть всю эту информацию с помощью простого запроса:
 
    SELECT *
    FROM Totalforday;
 
   Как мы видели, SQL запросы могут дать вам полный комплекс возможностей, так что представления обеспечивают вас чрезвычайно гибким и мощным инструментом чтобы определить точно, как ваши данные могут быть использованы. Они могут также делать вашу работу более простой, переформатируя данные удобным для вас способом и исключив двойную работу.
### ПРЕДСТАВЛЕНИЯ И ОБЬЕДИНЕНИЯ
   Представления не требуют чтобы их вывод осуществлялся из одной базовой таблицы. Так как почти любой допустимый запрос SQL может быть использован в представлении, он может выводить информацию из любого числа базовых таблиц, или из других представлений. Мы можем, например, создать представление которое показывало бы, порядки продавца и заказчика по имени:


    CREATE VIEW Nameorders
    AS SELECT onum, amt, a.snum, sname, cname
    FROM Orders a, Customers b, Salespeople c
    WHERE a.cnum=b.cnum
    AND a.snum=c.snum;
 
   Теперь вы можете выбрать (SELECT) все порядки заказчика или продавца (* ), или можете увидеть эту информацию для любого порядка. Например, чтобы увидеть все порядки продавца Rifkin, вы должны ввести следующий запрос (вывод показан в Таблице 20.3 ):
 
    SELECT *
    FROM Nameorders
    WHERE sname='Rifkin';
 
SQL Execution Log

    SELECT * FROM Nameorders WHERE sname='Rifkin';
    
|    onum                                  |    amt                                   |    snum                                  |    sname                                 |    cname                                 |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3001<br style="margin: 0px; padding: 0px;"> |    18.69<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |
    

   Таблица 20.3: Порядки Rifkin показаные в Nameorders
 
   Вы можете также объединять представления с другими таблицами, или базовыми таблицами или представлениями, поэтому вы можете увидеть все порядки Axelrodа и значения его комиссиионных в каждом порядке:
    
    SELECT a.sname, cname, amt comm
    FROM Nameorders a, Salespeople b
    WHERE a.sname='Axelrod'
    AND b.snum=a.snum;
 
   Вывод для этого запроса показывается в Таблице 20.4.
 
   В предикате, мы могли бы написать - " WHERE a.sname=|Axelrod' AND b.sname=|Axelrod| ", но предикат который мы использовали здесь более общеупотребительный. Кроме того поле snum - это первичный ключ таблицы Продавцов, и следовательно должен по определению быть уникальным.
 
SQL Execution Log

    SELECT a.sname, cname, amt * comm FROM Nameorders a, Salespeople b
    WHERE a.sname='Axelrod' AND b.snum=a.snum;

|    onum                                  |    amt                                   |    snum                                  |    sname                                 |    cname                                 |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3001<br style="margin: 0px; padding: 0px;"> |    18.69<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.16<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |

Таблица 20. 4: Обьединение основной таблицы с представлением
 
   Если бы там например было два Axelrodf, вариант с именем, будет обединять вместе их данные. Более предпочтительный вариант - использовать поле snum чтобы хранить его отдельно.
### ПРЕДСТАВЛЕНИЯ И ПОДЗАПРОСЫ
   Представления могут также использовать и подзапросы, включая соотнесенные подзапросы. Предположим ваша компания предусматривает премию для тех продавцов которые имеют заказчика с самым высоким порядком для любой указанной даты. Вы можете проследить эту информацию с помощью представления:
 
    CREATE VIEW Elitesalesforce
    AS SELECT b.odate, a.snum, a.sname,
    FROM Salespeople a, Orders b
    WHERE a.snum=b.snum
    AND b.amt=
    (SELECT MAX (amt)
    FROM Orders c
    WHERE c.odate=b.odate);
 
   Если, с другой стороны, премия будет назначаться только продавцу который имел самый высокий порядок за последние десять лет, вам необходимо будет проследить их в другом представлении основанном на первом:
 
    CREATE VIEW Bonus
    AS SELECT DISTINCT snum, sname
    FROM Elitesalesforce a
    WHERE 10 <=
    (SELECT COUNT (*)
    FROM Elitesalestorce b
    WHERE a.snum=b.snum);
 
   Извлечение из этой таблицы продавца, который будет получать премию - выпоняется простым вопросом:
 
    SELECT *
    FROM Bonus;
 
   Теперь мы видим истинную мощность SQL. Извлечение той же полученной информации программами RPG или COBOL будет более длительной процедурой. В SQL, это - только вопрос из двух комплексных команд, сохраненных, как представление совместно с простым запросом. При самостоятельном запросе - мы должны заботится об этом каждый день, потому что информация которую извлекает запрос, непрерывно меняется чтобы отражать текущее состояние базы данных.
### ЧТО НЕ МОГУТ ДЕЛАТЬ ПРЕДСТАВЛЕНИЯ
   Имеются большое количество типов представлений (включая многие из наших примеров в этой главе ) которые являются доступными только для чтения. Это означает, что их можно запрашивать, но они не могут подвергаться действиям команд модификации. (Мы будем рассматривать эту тему в Главе 21.)
   Имеются также некоторые виды запросов, которые не допустимы в определениях представлений. Одиночное представление должно основываться на одиночном запросе; ОБЪЕДИНЕНИЕ (UNION) и ОБЪЕДИНЕНИЕ ВСЕГО (UNIOM ALL) не разрешаются. УПОРЯДОЧЕНИЕ ПО(ORDER BY) никогда не используется в определении представлений. Вывод запроса формирует содержание представления, которое напоминает базовую таблицу и является - по определению - неупорядоченным.
### УДАЛЕНИЕ ПРЕДСТАВЛЕНИЙ
   Синтаксис удаления представления из базы данных подобен синтаксису удаления базовых таблиц:
 
    DROP VIEW < view name >
 
   В этом нет необходимости, однако, сначала надо удалить все содержание как это делается с базовой таблицей, потому что содержание представления не является созданым и сохраняется в течении определеной команды. Базовая таблица из которой представление выводится, не эффективна когда представление удалено. Помните, вы должны являться владельцем представления чтобы иметь возможность удалить его.
### РЕЗЮМЕ
   Теперь, когда вы можете использовать представления, ваша способность отслеживать и обрабатывать содержание вашей базы данных, значительно расширилась. Любые вещи которые вы можете создать с запросом, вы всегда сможете определить как представление. Запросы этих представлений, фактически, запрос запроса. Использование представлений и для удобства и для защиты, также удобно как и многие возможности представлений для форматирования и получения значений из постоянно меняющегося содержания вашей базы данных. Имеется один главный вывод относительно представлений, это способность к модификации, которую мы выбрали в отличии от Главы 21. Как показано, вы можете модифицировать представления также как и базовую таблицу, с помощью изменений применяемых к таблице из которой получается представление, но это не всегда возможно.
### РАБОТА С SQL
   * Создайте представление которое бы показывало всех заказчиков которые имеют самые высокие оценки.
   * Создайте представление которое бы показывало номер продавца в каждом городе.
   * Создайте представление которое бы показывало усредненый и общий порядки для каждого продавца после его имени. Предполагается, что все имена - уникальны.
   * Создайте представление которое бы показывало каждого продавца с многочислеными заказчиками.

## Глава 21. ИЗМЕНЕНИЕ ЗНАЧЕНИЙ С ПОМОЩЬЮ ПРЕДСТАВЛЕНИЙ
 
   ЭТА ГЛАВА РАССКАЗЫВАЕТ О КОМАНДАХ МОДИФИКАЦИИ ЯЗЫКА DML - ВСТАВИТЬ(INSERT), ИЗМЕНИТЬ(UPDATE), и УДАЛИТЬ(DELETE) - когда они применя ются для представлений. Как упомянуто в предыдущей главе, использование команд модификации в представлениях - это косвенный способ использования их в ссылочных таблицах с помощью запросов представлений. Однако, не все представления могут модифицироваться.
   В этой главе, мы будем обсуждать правила определяющие, является ли представление модифицируемым. Кроме того, вы обучитесь использованию предложения WITH CHECK OPTION, которое управляет указанными значениями, которые можно вводить в таблицу с помощью представления.
   Как упомянуто в Главе 18, это, в некоторых случаях, может быть желательным вариантом непосредственного ограничения таблицы.
### МОДИФИЦИРОВАНИЕ ПРЕДСТАВЛЕНИЯ
   Один из наиболее трудных и неоднозначных аспектов представлений - непосредственное их использование с командами модификации DML. Как упомянуто в предыдущей главе, эти команды фактически воздействуют на значения в базовой таблице представления. Это является некоторым противоречием. Представление состоит из результатов запроса, и когда вы модифицируете представление, вы модифицируете набор результатов запроса. Но модификация не должна воздействовать на запрос ; она должна воздействовать на значения в таблице к которой был сделан запрос, и таким образом изменять вывод запроса. Это не простой вопрос. Следующий оператор будет создавать представление показанное в Таблице 21.1:
 
    CREATE VIEW Citymatch (custcity, salescity)
    AS SELECT DISTINCT a.city, b.city
    FROM Customers a, Salespeople b
    WHERE a.snum=b.snum;
 
   Это представление показывает все совпадения заказчиков с их продавцами так, что имеется по крайней мере один заказчик в городе_заказчика обслуживаемый продавцом в городе_продавца.
   Например, одна строка этой таблицы - London London - показывает, что имеется по крайней мере один заказчик в Лондоне,обслуживаемый продавцом в Лондоне. Эта строка может быть произведена при совпадении Hoffmanа с его продавцом Peel, причем если оба они из Лондона.
 
SQL Execution Log
 
    SELECT * FROM Citymatch;

|    custcity                              |    salescity                             |
|------------------------------------------|------------------------------------------|
|    Berlin<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |
|    London<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    Rome<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    Rome<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |
|    San Jose<br style="margin: 0px; padding: 0px;"> |    Barselona<br style="margin: 0px; padding: 0px;"> |
|    San Jose<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |


   Таблица 21.1: Представление совпадения по городам
   Однако, то же самое значение будет произведено при совпадении Clemens из Лондона, с его продавцом, который также оказался с именем - Peel. Пока отличающиеся комбинации городов выбирались конкретно, только одна строка из этих значений была произведена.
   Даже если вы не получите выбора используя отличия, вы все еще будете в том же самом положении, потому что вы будете тогда иметь две строки в представлении с идентичными значениями, то-есть с обоими столбцами равными " Lоndon London ". Эти две строки представления будут отличаться друг от друга, так что вы пока не сможете сообщить, какая строка представления исходила из каких значений базовых таблиц( имейте в виду, что запросы не использующие предложение ORDER BY, производят вывод в произвольном порядке. Это относится также и к запросам используемым внутри представлений, которые не могут использовать ORDER BY. Таким образом, порядок из двух строк не может быть использован для их отличий. Это означает, что мы будем снова обращаться к выводу строк которые не могут быть точно связаны с указаными строками запрашиваемой таблицы. Что если вы пробуете удалить строку | London London | из представления? Означало бы это удаление Hoffmanа из таблицы Заказчиков, удаление Clemens из той же таблицы, или удаление их обоих? Должен ли SQL также удалить Peel из таблицы Продавцов? На эти вопросы невозможно ответить точно, поэтому удаления не разрешены в представлениях такого типа. Представление Citymatch - это пример представления только_чтение, оно может быть только запрошено, но не изменено.
### ОПРЕДЕЛЕНИЕ МОДИФИЦИРУЕМОСТИ ПРЕДСТАВЛЕНИЯ
   Если команды модификации могут выполняться в представлении, представление как сообщалось будет модифицируемым; в противном случае оно предназначено только для чтения при запросе. Непротивореча этой терминологии, мы будем использовать выражение "модифицируемое представление"(updating a view), чтоы означает возможность выполнения в представление любой из трех команд модификации DML (Вставить, Изменить и Удалить ), которые могут изменять значения. Как вы определите, является ли представление модифицируемым? В теории базы данных, это - пока обсуждаемая тема. Основной ее принцип такой: модифицирумое представление - это представление в котором команда модификации может выполниться, чтобы изменить одну и только одну строку основной таблицы в каждый момент времени, не воздействуя на любые другие строки любой таблицы.

 Использование этого принципа на практике, однако, затруднено. Кроме того, некоторые представления, которые являются модифицируемыми в теории, на самом деле не являются модифицируемыми в SQL. Критерии по которые определяют, является ли представление модифицируемым или нет, в SQL, следующие:
   * Оно должно выводиться в одну и только в одну базовую таблицу.
   * Оно должно содержать первичный ключ этой таблицы (это технически не предписывается стандартом ANSI, но было бы неплохо придерживаться этому).
   * Оно не должно иметь никаких полей, которые бы являлись агрегатнымифункциями.
   * Оно не должно содержать DISTINCT в своем определении.
   * Оно не должно использовать GROUP BY или HAVING в своем определении.
   * Оно не должно использовать подзапросы (это - ANSI_ограничение которое не предписано для некоторых реализаций )
   * Оно может быть использовано в другом представлении, но это представление должно также быть модифицируемыми.
   * Оно не должно использовать константы, строки, или выражения значений (например: comm * 100 ) среди выбранных полей вывода.
   * Для INSERT, оно должно содержать любые поля основной таблицы которые имеют ограничение NOT NULL, если другое ограничение по умолчанию, не определено.
 
### МОДИФИЦИРУЕМЫЕ ПРЕДСТАВЛЕНИЯ И ПРЕДСТАВЛЕНИЯ ТОЛЬКО_ЧТЕНИЕ.
   Одно из этих ограничений то, что модифицируемые представления, фактически, подобны окнам в базовых таблицах. Они показывают кое-что, но не обязательно все, из содержимого таблицы. Они могут ограничивать определенные строки (использованием предикатов), или специально именованные столбцы (с исключениями ), но они представляют значения непосредственно и не выводит их информацию, с использованием составных функций и выражений.
   Они также не сравнивают строки таблиц друг с другом (как в обьединениях и подзапросах, или как с DISTINCT ).
   Различия между модифицируемыми представлениями и представлениями только_чтение неслучайны.
   Цели для которых вы их используете, часто различны. Модифицируемые представления, в основном, используются точно так же как и базовые таблицы. Фактически, пользователи не могут даже осознать, является ли объект который они запрашивают, базовой таблицей или представлением.
   Это превосходный механизм защиты для сокрытия частей таблицы, которые являются конфиденциальными или не относятся к потребностям данного пользователя. (В Главе 22, мы покажем вам, как позволить пользователям обращаться к представлению, а не к базовой таблице ).
   Представления только_чтение, с другой стороны, позволяют вам получать и переформатировать данные более рационально. Они дают вам библиотеку сложных запросов, которые вы можете выполнить и повторить снова, сохраняя полученную вами информацию до последней минуты. Кроме того, результаты этих запросов в таблицах, которые могут затем использоваться в запросах самостоятельно (например, в обьединениях ) имеют преимущество над просто выполнением запросов.
   Представления только_чтение могут также иметь прикладные программы защиты. Например, вы можете захотеть, чтобы некоторые пользователи видели агрегатные данные, такие как усредненное значение комиссионных продавца, не видя индивидуальных значений комиссионных.
 
### ЧТО ЯВЛЯЕТСЯ - МОДИФИЦИРУЕМЫМИ ПРЕДСТАВЛЕНИЕМ
   Имеются некоторые примеры модифицируемых представлений и представлений только_чтение:
 
    CREATE VIEW Dateorders (odate, ocount)
    AS SELECT odate, COUNT (*)
    FROM Orders
    GROUP BY odate;
 
   Это - представление только_чтение из-за присутствия в нем агрегатной функции и GROUP BY.
 
    CREATE VIEW Londoncust
    AS SELECT *
    FROM Customers
    WHERE city='London';
 
   А это - представление модифицируемое.
 
    CREATE VIEW SJsales (name, number, percentage)
    AS SELECT sname, snum, comm 100
    FROM Salespeople
    WHERE city='SanJose';
 
   Это - представление только_чтение из-за выражения " comm * 100 " . При этом, однако, возможны переупорядочение и переименование полей. Некоторые программы будут позволять удаление в этом представлении или в порядках столбцов snum и sname.
 
    CREATE VIEW Salesonthird
    AS SELECT *
    FROM Salespeople
    WHERE snum IN
    (SELECT snum
    FROM Orders
    WHERE odate=10/03/1990);
 
   Это - представление только_чтение в ANSI из-за присутствия в нем подзапроса. В некоторых программах, это может быть приемлемо.
 
    CREATE VIEW Someorders
    AS SELECT snum, onum, cnum
    FROM Orders
    WHERE odate IN (10/03/1990,10/05/1990);
 
   Это - модифицируемое представление.
 
### ПРОВЕРКА ЗНАЧЕНИЙ ПОМЕЩАЕМЫХ В ПРЕДСТАВЛЕНИЕ
   Другой вывод о модифицируемости представления тот, что вы можете вводить значения которые " проглатываются " (swallowed) в базовой таблице. Рассмотрим такое представление:
 
    CREATE VIEW Highratings
    AS SELECT cnum, rating
    FROM Customers
    WHERE rating=300;
 
   Это - представление модифицируемое. Оно просто ограничивает ваш доступ к определенным строкам и столбцам в таблице. Предположим, что вы вставляете (INSERT) следующую строку:
 
    INSERT INTO Highratings
    VALUES (2018, 200);
 
   Это - допустимая команда INSERT в этом представлении. Строка будет вставлена, с помощью представления Highratings, в таблицу Заказчиков.
   Однако когда она появится там, она исчезнет из представления, поскольку значение оценки не равно 300. Это - обычная проблема.
   Значение 200 может быть просто напечатано, но теперь строка находится уже в таблице Заказчиков где вы не можете даже увидеть ее. Пользователь не сможет понять, почему введя строку он не может ее увидеть, и будет неспособен при этом удалить ее. Вы можете быть гарантированы от модификаций такого типа с помощью включения WITH CHECK OPTION (С ОПЦИЕЙ ПРОВЕРКИ) в определение представления. Мы можем использовать WITH CHECK OPTION в определении представления Highratmgs.
 
    CREATE VIEW Highratings
    AS SELECT cnum, rating
    FROM Customers
    WHERE rating=300
    WITH CHECK OPTION;
 
   Вышеупомянутая вставка будет отклонена.
   WITH CHECK OPTION - производит действие все_или_ничего (all-or-nothing). Вы помещаете его в определение представления, а не в команду DML, так что или все команды модификации в представлении будут проверяться, или ни одна не будет проверена. Обычно вы хотите использовать опцию проверки, используя ее в определении представления, что может быть удобно.
   В общем, вы должны использовать эту опцию, если у вас нет причины, разрешать представлению помещать в таблицу значения, которые он сам не может содержать.
 
### ПРЕДИКАТЫ И ИСКЛЮЧЕННЫЕ ПОЛЯ
   Похожая проблема, которую вы должны знать, включает в себя вставку строк в представление с предикатом, базирующемся на одном или более исключенных полей. Например, может показаться разумным, чтобы создать Londonstaff подобно этому:
 
    CREATE VIEW Londonsta1t
    AS SELECT snum, sname, comm
    FROM Salespeople
    WHERE city='London';
 
   В конце концов, зачем включать значение city, если все значения city будут одинаковыми.
   А как будет выглядит картинка получаемая всякий раз, когда мы пробуем вставить строку. Так как мы не можем указать значение city как значение по умолчанию, этим значением вероятно будет NULL, и оно будет введено в поле city (NULL используется если другое значение по умолчанию значение не было определено. См. Главу 18 для подробностей ).
   Так как в этм случае поле city не будет равняться значению London, вставляемая строка будет исключена из представления.
   Это будет верным для любой строки которую вы попробуете вставить в просмотр Londonstaff. Все они должны быть введены с помощью представления Londonstaff в таблицу Продавцов, и затем исключены из самого представления( если определением по умолчанию был не London, то это особый случай). Пользователь не сможет вводить строки в это представление, хотя все еще неизвестно, может ли он вводить строки в базовую таблицу. Даже если мы добавим WITH CHECK OPTION в определение представления
 
    CREATE VIEW Londonstate
    AS SELECT snum, sname, comm
    FROM Salespeople
    WHERE city='London'
    WITH CHECK OPTION;
 
   проблема не обязательно будет решена. В результате этого мы получим представление которое мы могли бы модифицировать или из которого мы могли бы удалять, но не вставлять в него. В некоторых случаях, это может быть хорошо; хотя возможно нет смысла пользователям имеющим доступ к этому представлению иметь возможность добавлять строки. Но вы должны точно определить что может произойти прежде, чем вы создадите такое представление.
   Даже если это не всегда может обеспечить Вас полезной информацией, полезно включать в ваше представление все поля, на которые имеется ссылка в предикате. Если вы не хотите видеть эти поля в вашем выводе, вы всегда сможете исключить их из запроса в представлении, в противоположность запросу внутри представления. Другими словами, вы могли бы определить представление Londonstaff подобно этому:
 
    CREATE VIEW Londonstaff
    AS SELECT *
    FROM Salespeople
    WHERE city='London'
    WITH CHECK OPTION;
 
   Эта команда заполнит представление одинаковыми значениями в поле city, которые вы можете просто исключить из вывода с помощью запроса в котором указаны только те поля которые вы хотите видеть
 
    SELECT snum, sname, comm
    FROM Londonstaff;
### ПРОВЕРКА ПРЕДСТАВЛЕНИЙ КОТОРЫЕ БАЗИРУЮТСЯ НА ДРУГИХ ПРЕДСТАВЛЕНИЯХ
   Еще одно надо упоминуть относительно предложения WITH CHECK OPTION в ANSI: оно не делает каскадированного изменения : Оно применяется только в представлениях в которых оно определено, но не в представлениях основанных на этом представлении. Например, в предыдущем примере
 
    CREATE VIEW Highratings
    AS SELECT cnum, rating
    FROM Customers
    WHERE rating=300
    WITH CHECK OPTION;
 
   попытка вставить или модифицировать значение оценки не равное 300 потерпит неудачу. Однако, мы можем создать второе представление (с идентичным содержанием ) основанное на первом:
 
    CREATE VIEW Myratings
    AS SELECT *
    FROM Highratings;
 
   Теперь мы можем модифицировать оценки не равные 300:
 
    UPDATE Myratings
    SET rating=200
    WHERE cnum=2004;
 
   Эта команда выполняемая так как если бы она выполнялась как первое представление, будет допустима. Предложение WITH CHECK OPTION просто гарантирует, что любая модификация в представлении, произведет значения, которые удовлетворяют предикату этого представления. Модификация других представлений базирующихся на первом текущем, является все еще допустимой, если эти представления не защищены предложениями WITH CHECK OPTION внутри этих представлений. Даже если такие предложения установлены, они проверяют только те предикаты представлений в которых они содержатся. Так например, даже если представление Myratings создавалось следующим образом
 
    CREATE VIEW Myratings
    AS SELECT *
    FROM Highratings
    WITH CHECK OPTION;
 
   проблема не будет решена. Предложение WITH CHECK OPTION будет исследовать только предикат представления Myratings. Пока у Myratings, фактически, не имеется никакого предиката, WITH CHECK OPTION ничего не будет делать. Если используется предикат, то он будет проверяться всякий раз, когда представление Myratings будет модифицироваться, но предикат Highratings все равно будет проигнорирован. Это - дефект в стандарте ANSI, который у большинство программ исправлен. Вы можете попробовать использовать представление наподобии последнего примера и посмотреть избавлена ли ваша система от этого дефекта. (Попытка выяснить это самостоятельно может быть иногда быть проще и яснее, чем поиск ответа в документации системы. )
### РЕЗЮМЕ
   Вы теперь овладели знаниями о представлениях полностью. Кроме правил определяющих, является ли данное представление модифицируемыми в SQL, вы познакомились с основными понятиями на которых эти правила базируются - т.е что модификации в представлениях допустимы только когда SQL может недвусмысленно определить, какие значения базовой таблицы можно изменять.

 Это означает что команда модификации, при выполнении, не должна требовать ни изменений для многих строк сразу, ни сравнений между многочисленными строками либо базовой таблицы либо вывода запроса. Так как обьединения включают в себя сравнение строк, они также запрещены. Вы также поняли различие между некоторыми способами которые используют модификацируемые представления и представления только_чтение. Вы научились воспринимать модифицируемые представления как окна, отображающие данные одиночной таблицы, но необязательно исключающие или реорганизующие столбцы, посредством выбора только определенных строк отвечающих условию предиката. Представления только_чтение, с другой стороны, могут содержать более допустимые запросы SQL; они могут следовательно стать способом хранения запросов, которые вам нужно часто выполнять в неизменной форме. Кроме того, наличие запроса чей вывод обрабатывается как объект данных, дает вам возможность иметь ясность и удобство при создании запросов в выводе запросов. Вы теперь можете предохранять команды модификации в представлении от создания строк в базовой таблице, которые не представлены в самом представлении с помощью предложения WITH CHECK OPTION в определении представления. Вы можете также использовать WITH CHECK OPTION как один из способов ограничения в базовой таблице. В автономных запросах, вы обычно используете один или более столбцов в предикате не представленых среди выбранных для вывода, что не вызывает никаких проблем. Но если эти запросы используются в модифицируемых представлениях, появляются проблемы, так как эти запросы производят представления, которые не могут иметь вставляемых в них
   строк. Вы видели некоторые подходы к этим проблемам. В Главах 20 И 21, мы говорили, что представления имеют прикладные программы защиты. Вы можете позволить пользователям обращаться к представлениям не разрешая в тоже время обращаться к таблицам в которых эти представления непосредственно находятся. Глава 22 будет исследовать вопросы доступа к объектам данных в SQL.
РАБОТА С SQL
 
   Какое из этих представлений - модифицируемое?
  .
   
    CREATE VIEW Dailyorders
    AS SELECT DISTINCT cnum, snum, onum, odate
   .
   
    FROM Orders;
    CREATE VIEW Custotals
    AS SELECT cname, SUM (amt)
    FROM Orders, Customers
    WHERE Orders.cnum=customer.cnum
   . 
   
    GROUP BY cname;
    CREATE VIEW Thirdorders
    AS SELECT *
    FROM Dailyorders
   .
   
    WHERE odate=10/03/1990;
    CREATE VIEW Nullcities
    AS SELECT snum, sname, city
    FROM Salespeople
    WHERE city IS NULL
    
  . 
   
    OR sname BETWEEN 'A' AND 'MZ';
 
   * Создайте представление таблицы Продавцов с именем Commissions (Комиссионные). Это представление должно включать только поля comm и snum. С помощью этого представления, можно будет вводить или изменять комиссионные, но только для значений между .10 и .20.
   * Некоторые SQL реализации имеют встроенную константу представляющую текущую дату, иногда называемую " CURDATE ". Слово CURDATE может следовательно использоваться в операторе SQL, и заменяться текущей датой, когда его значение станет доступным с помощью таких команд как SELECT или INSERT. Мы будем использовать представление таблицы Порядков с именем Entryorders для вставки строк в таблицу Порядков. Создайте таблицу порядков, так чтобы CURDATE автоматически вставлялась в поле odate если не указано другого значения. Затем создайте представление Entryorders, так чтобы значения не могли быть указаны.

## Глава 22. КТО ЧТО МОЖЕТ ДЕЛАТЬ В БАЗЕ ДАННЫХ
 
   В ЭТОЙ ГЛАВЕ, ВЫ ОБУЧИТЕСЬ РАБОТЕ С ПРИВИЛЕГИЯМИ. Как сказано в Главе 2, SQL используется обычно в средах, которые требуют распознавания пользователей и различия между различными пользователями систем. Вообще говоря, администраторы баз данных, сами создают пользователей и дают им привилегии. С другой стороны пользователи которые создают таблицы, сами имеют права на управление этими таблицами. Привилегии - это то, что определяет, может ли указаный пользователь выполнить данную команду. Имеется несколько типов привилегий, соответствующих нескольким типам операций. Привилегии даются и отменяются двумя командами SQL: - GRANT (ДОПУСК) и REVOKE (ОТМЕНА). Эта глава покажет вам как эти команды используются.
### ПОЛЬЗОВАТЕЛИ
   Каждый пользователь в среде SQL, имеет специальное идентификационное имя или номер. Терминология везде разная, но мы выбрали (следуя ANSI) ссылку на имя или номер как на Идентификатор (ID) доступа. Команда, посланная в базе данных ассоциируется с определенным пользователем; или иначе, специальным Идентификатором доступа. Посколько это относится к SQL базе данных, ID разрешения - это имя пользователя, и SQL может использовать специальное ключевое слово USER, которое ссылается к Идентификатору доступа связанному с текущей командой. Команда интерпретируется и разрешается (или запрещается ) на основе информации связанной с Идентификатором доступа пользователя подавшего команду.
### РЕГИСТРАЦИЯ
   В системах с многочислеными пользователями, имеется некоторый вид процедуры входа в систему, которую пользователь должен выполнить чтобы получить доступ к компьютерной системе. Эта процедура определяет какой ID доступа будет связан с текущим пользователем. Обычно, каждый человек использующий базу данных должен иметь свой собственный ID доступа и при регистрации превращается в действительного пользователям. Однако, часто пользователи имеющие много задачь могут регистрироваться под различными ID доступа, или наоборот один ID доступа может использоваться несколькими пользователями.
   С точки зрения SQL нет никакой разницы между этими двумя случаями; он воспринимает пользователя просто как его ID доступа.
   SQL база данных может использовать собственную процедуру входа в систему, или она может позволить другой программе, типа операционной системы (основная программа которая работает на вашем компьютере ), обрабатывать файл регистрации и получать ID доступа из этой программы. Тем или другим способом, но SQL будет иметь ID доступа чтобы связать его с вашими действиями, а для вас будет иметь значение ключевое слово USER.
### ПРЕДОСТАВЛЕНИЕ ПРИВИЛЕГИЙ
   Каждый пользователь в SQL базе данных имеет набор привилегий. Это - то что пользователю разрешается делать (возможно это - файл регистрации, который может рассматриваться как минимальная привилегия). Эти привилегии могут изменяться со временем - новые добавляться, старые удаляться. Некоторые из этих привилегий определены в ANSI SQL, но имеются и дополнительные привилегии, которые являются также необходимыми.
   SQL привилегии как определено ANSI, не достаточны в большинстве ситуаций реальной жизни. С другой стороны, типы привилегий, которые необходимы, могут видоизменяться с видом системы которую вы используете - относительно которой ANSI не может дать никаких рекомендаций. Привилегии которые не являются частью стандарта SQL могут использовать похожий синтаксис и не полностью совпадающий со стандартом.
### СТАНДАРТНЫЕ ПРИВИЛЕГИИ
   SQL привилегии определенные ANSI - это привелегии объекта. Это означает что пользователь имеет привилегию чтобы выполнить данную команду только на определенном объекте в базе данных. Очевидно, что привилегии должны различать эти объекты, но система привилегии основанная исключительно на привилегиях объекта не может адресовывать все что нужно SQL, как мы увидем это позже в этой главе. Привилегии объекта связаны одновременно и с пользователями и с таблицами. То есть, привилегия дается определенному пользователю в указаной таблице, или базовой таблице или представлении. Вы должны помнить, что пользователь создавший таблицу (любого вида), является владельцем этой таблицы.
   Это означает, что пользователь имеет все привилегии в этой таблице и может передавать привелегии другим пользователям в этой таблице. Привилегии которые можно назначить пользователю:
 
   **SELECT** Пользователь с этой привилегией может выполнять запросы в таблице.
   **INSERT** Пользователь с этой привилегией может выполнять команду INSERT в таблице.
   UPDATE Пользователь с этой привилегией может выполнять команду UPDATE на таблице. Вы можете ограничить эту привилегию для определенных столбцов таблицы.
   **DELETE** Пользователь с этой привилегией может выполнять команду DELETE в таблице.
   REFERENCES Пользователь с этой привилегией может определить внешний ключ, который использует один или более столбцов этой таблицы, как родительский ключ. Вы можете ограничить эту привилегию для определенных столбцов. (Смотрите Главу 19 для подробностей относительно внешнего ключа и родительского ключа.)
 
   Кроме того, вы столкнетесь с нестандартными привилегиями объекта, такими например как INDEX (ИНДЕКС) дающим право создавать индекс в таблице, SYNONYM (СИНОНИМ) дающим право создавать синоним для объекта, который будет объяснен в Главе 23, и ALTER (ИЗМЕНИТЬ) дающим право выполнять команду ALTER TABLE в таблице. Механизм SQL назначает пользователям эти привилегии с помощью команды GRANT.
   КОМАНДА GRANT
   Позвольте предположить, что пользователь Diane имеет таблицу Заказчиков и хочет позволить пользователю Adrian выполнить запрос к ней.
   Diane должна в этом случае ввести следующую команду:
 
    GRANT INSERT ON Salespeople TO Diane;
 
   Теперь Adrian может выполнить запросы к таблице Заказчиков. Без других привилегий, он может только выбрать значения; но не может выполнить любое действие, которые бы воздействовало на значения в таблице Заказчиков (включая использование таблицы Заказчиков в качестве родительской таблицы внешнего ключа, что ограничивает изменения которые выполнять со значениям в таблице Заказчиков). Когда SQL получает команду GRANT, он проверяет привилегии пользователя подавшего эту команду, чтобы определить допустима ли команда GRANT.
   Adrian самостоятельно не может выдать эту команду. Он также не может предоставить право SELECT другому пользователю: таблица еще принадлежит Diane (позже мы покажем как Diane может дать право Adrian предоставлять SELECT другим пользователям). Синтаксис - тот же самый, что и для предоставления других привилегий. Если Adrian - владелец таблицы Продавцов, то он может позволить Diane вводить в нее строки с помощью следующего предложения
 
    GRANT INSERT ON Salespeople TO Diane;
 
   Теперь Diane имеет право помещать нового продавца в таблицу.
   ГРУППЫ ПРИВЕЛЕГИЙ, ГРУППЫ ПОЛЬЗОВАТЕЛЕЙ
   Вы не должны ограничивать себя предоставлением одиночной привилегии отдельному пользователю командой GRANT. Списки привилегий или пользователей, отделяемых запятыми, являются совершенно приемлемыми. Stephen может предоставить и SELECT и INSERT в таблице Порядков для Adrian
 
    GRANT SELECT, INSERT ON Orders TO Adrian;
 
   или и для Adrian и для Diane
 
    GRANT SELECT, INSERT ON Orders TO Adrian, Diane;
 
   Когда привилегии и пользователи перечислены таким образом, весь список привилегий предоставляются всем указанным пользователям. В строгой ANSI интерпретации, вы не можете предоставить привилегии во многих таблицах сразу одной командой, но в некоторых реализациях это ограничение может быть ослаблено, позволяя вам указывать несколько таблиц, отделяя их запятыми, так что бы весь список привелегий мог быть предоставлен для всех указанных таблиц.
### ОГРАНИЧЕНИЕ ПРИВИЛЕГИЙ НА ОПРЕДЕЛЕННЫЕ СТОЛБЦЫ
   Все привилегии объекта используют один тот же синтаксис, кроме команд UPDATE и REGERNCES в которых необязательно указывать имена столбцов. Привилегию UPDATE можно предоставлять на подобии других привилегий:

    GRANT UPDATE ON Salespeople TO Diane;
 
   Эта команда позволит Diane изменять значения в любом или во всех столбцах таблицы Продавцов. Однако, если Adrian хочет ограничить Diane в изменении например комиссионных, он может ввести
 
    GRANT UPDATE (comm) ON Salespeople TO Diane;
 
   Другими словами, он просто должен указать конкретный столбец к которому привилегия UPDATE должна быть применена, в круглых скобках после имени таблицы. Имена многочисленых столбцов таблицы могут указываться в любом порядке, отделяемые запятыми:
 
   GRANT UPDATE (city, comm) ON Salespeople TO Diane;
 
   REFERENCES следует тому же самому правилу. Когда вы предоставите привилегию REFERENCES другому пользователю, он сможет создавать внешние ключи ссылающиеся на столбцы вашей таблицы как на родительские ключи. Подобно UPDATE, для привилегии REFERENCES может быть указан список из одного или более столбцов для которых ограничена эта привилегия. Например, Diane может предоставить Stephen право использовать таблицу Заказчиков, как таблицу родительского ключа, с помощью такой команды:
 
    GRANT REFERENCES (cname, cnum)
    ON Customers TO Stephen;
 
   Эта команда дает Stephen право использовать столбцы cnum и cname, в качестве родительских ключей по отношению к любым внешним ключам в его таблицах. Stephen может контролировать то как это будет выполнено. Он может определить (cname, cnum) или, как в нашем случае( cnum, cname), как двух-столбцовый родительский ключ, совпадающий с помощью внешнего ключа с двумя столбцами в одной из его собственных таблиц. Или он может создать раздельные внешние ключи чтобы ссылаться на поля индивидуально, обеспечив тем самым чтобы Diane имела принудительное присвоение родительского ключа (см. Главу 19).
   Не имея ограничений на номера внешних ключей он должден базироваться на этих родительских ключах, а родительские ключи различных внешних ключей - разрешены для совмещения(overlap).
   Как и в случае с привилегией UPDATE, вы можете исключить список столбцов и таким образом позволять всем без исключения столбцам быть используемыми в качестве родительских ключей. Adrian может предоставить Diane право сделать это следующей командой:
 
    GRANT REFERENCES ON Salespeople TO Diane;
   Естественно, привилегия будет пригодна для использования только в столбцах, которые имеют ограничения требуемые для родительских ключей.
   ИСПОЛЬЗОВАНИЕ АРГУМЕНТОВ ALL И PUBLIC
   SQL поддерживает два аргумента для команды GRANT, которые имеют специальное значение: ALL PRIVILEGES (ВСЕ ПРИВИЛЕГИИ) или просто ALL и PUBLIC (ОБЩИЕ). ALL используется вместо имен привилегий в команде GRANT чтобы отдать все привилегии в таблице. Например, Diane может дать Stephen весь набор привилегий в таблице Заказчиков с помощью такой команды:
 
    GRANT REFERENCES ON Salespeople TO Diane;
 
   (привилегии UPDATE и REFERENCES естественно применяются ко всем столбцам.) А это другой способ высказать ту же мысль:

    GRANT ALL ON Customers TO Stephen;
 
   PUBLIC - больше похож на тип аргумента - захватить все (catch-all), чем на пользовательскую привилегию. Когда вы предоставляете привилегии для публикации, все пользователи автоматически их получают. Наиболее часто, это применяется для привилегии SELECT в определенных базовых аблицах или представлениях которые вы хотите сделать доступными для любого пользователя. Чтобы позволить любому пользователю видеть таблицу Порядков, вы, например, можете ввести следующее:
 
    GRANT SELECT ON Orders TO PUBLIC;
 
   Конечно, вы можете предоставить любые или все привилегии обществу, но это видимо нежелательно. Все привилегии за исключением SELECT позволяют пользователю изменять (или, в случае REFERENCES, ограничивать) содержание таблицы. Разрешение всем пользователям изменять содержание ваших таблиц вызовет проблему. Даже если вы имеете небольшую компанию, и в ней работают все ваши текущие пользователи способные выполнять команды модификации в данной таблице, было бы лучше предоставить привилегии каждому пользователю индивидуально, чем одни и те же привелегии для всех. PUBLIC не ограничен в его передаче только текущим пользователям. Любой новый пользователь добавляемый к вашей системе, автоматически получит все привилегии назначенные ранее всем, так что если вы захотите ограничить доступ к таблице всем, сейчас или в будущем, лучше всего предоставить привилегии иные чем SELECT для индивидуальных пользователей.
### ПРЕДОСТАВЛЕНИЕ ПРИВЕЛЕГИЙ С ПОМОЩЬЮ WITH GRANT OPTION
   Иногда, создателю таблицы хочется чтобы другие пользователи могли получить привилегии в его таблице. Обычно это делается в системах, где один или более людей создают несколько (или все) базовые таблицы в базе данных а затем передают ответственность за них тем кто будет фактически с ними работать. SQL позволяет делать это с помощью предложения WITH GRANT OPTION. Если Diane хотела бы чтобы Adrian имел право предоставлять привилегию SELECT в таблице Заказчиков другим пользователям, она дала бы ему привилегию SELECT с использованием предложения WITH GRANT OPTION:
 
    GRANT SELECT ON Customers TO Adrian
    WITH GRANT OPTION;
 
   После того Adrian получил право передавать привилегию SELECT третьим лицам; он может выдать команду
 
    GRANT SELECT ON Diane.Customers TO Stephen;
 
   или даже
 
    GRANT SELECT ON Diane.Customers TO Stephen
    WITH GRANT OPTION;
 
   Пользователь с помощью GRANT OPTION в особой привилегии для данной таблицы, может, в свою очередь, предоставить эту привилегию к той же таблице, с или без GRANT OPTION, любому другому пользователю. Это не меняет принадлежности самой таблицы; как и прежде таблица принадлежат ее создателю. (поэтому пользователи получившие права, должны устанавливать префикс ID доступа владельца когда ссылаются к этим таблицам.
   Следующая глава покажет вам этот способ. ) Пользователь же с помощью GRANT OPTION во всех привилегиях для данной таблицы будет иметь всю полноту власти в той таблице.
### ОТМЕНА ПРИВИЛЕГИЙ
   Также как ANSI предоставляет команду CREATE TABLE чтобы создать таблицу, а не DROP TABLE чтобы от нее избавиться, так и команда GRANT позволяет вам давать привилегии пользователям, не предоставляя способа чтобы отобрать их обратно. Потребность удалять привилегии сводится к команде REVOKE, фактически стандартному средству с достаточно понятной формой записи. Синтаксис команды REVOKE - похож на GRANT, но имеет обратный смысл. Чтобы удалить привилегию INSERT для Adrian в таблице Порядков, вы можете ввести
 
    REVOKE INSERT ON Orders FROM Adrian;
 
   Использование списков привилегий и пользователей здесь допустимы как и в случае с GRANT, так что вы можете ввести следующую команду:
 
    REVOKE INSERT, DELETE ON Customers
    FROM Adrian, Stephen;
 
   Однако, здесь имеется некоторая неясность. Кто имеет право отменять привилегии? Когда пользователь с правом передавать привелегии другим, теряет это право? Пользователи которым он предоставил эти привилегии, также их потеряют ? Так как это не стандартная особенность, нет никаких авторитетных ответов на эти вопросы, но наиболее общий подход - это такой: * Привилегии отменяются пользователем который их предоставил, и отмена будетт каскадироваться, то-есть она будет автоматически распространяться на всех пользователям получивших от него эту привилегию.
### ИСПОЛЬЗОВАНИЕ ПРЕДСТАВЛЕНИЙ ДЛЯ ФИЛЬТРАЦИИ ПРИВЕЛЕГИЙ
   Вы можете сделать действия привилегий более точными, используя представления. Всякий раз, когда вы передаете привилегию в базовой таблице пользователю, она автоматически распространяется на все строки, а при использовании возможных исключений UPDATE и REFERENCES, на все столбцы таблицы. Создавая представление которое ссылается на основную таблицу и затем переносит привилегию на представление, а не на таблицу, вы можете ограничивать эти привилегии любыми выражениями в запросе содержащимся в представлении. Это значительно улучшает базисные возможности команды GRANT.
### КТО МОЖЕТ СОЗДАВАТЬ ПРЕДСТАВЛЕНИЯ?
   Чтобы создавать представление, вы должны иметь привилегию SELECT во всех таблицах на которые вы ссылаетесь в представлении. Если представление - модифицируемое, любая привелегия INSERT, UPDATE, и DELETE которые вы имеете в базовой таблице, будут автоматически передаваться представлению. Если вы испытываете недостаток в привилегиях на модификацию в базовых таблицах, вы не сможете иметь их и в представлениях которые создали, даже если сами эти представления - модифицируемые.
   Так как внешние ключи не используются в представлениях, привилегия REFERENCES никогда не используется при создании представлений. Все эти ограничения - определяются ANSI. Нестандартные привилегии системы (обсуждаемые позже в этой главе ) также могут быть включены. В последующих разделах мы предположим, что создатели представлений которые мы обсуждаем, имеют частные или соответствующие привилегии во всех базовых таблицах.
   ОГРАНИЧЕНИЕ ПРИВИЛЕГИИ SELECT ДЛЯ ОПРЕДЕЛЕННЫХ СТОЛБЦОВ
   Предположим вы хотите дать пользователю Claire способность видеть только столбцы snum и sname таблицы Продавцов. Вы можете сделать это, поместив имена этих столбцов в представление
 
    CREATE VIEW Clairesview
    AS SELECT snum, sname
    FROM Salespeople;
 
   и предоставить Claire привилегию SELECT в представлении, а не в самой
   таблице Продавцов:
 
    GRANT SELECT On Clairesview to Claire;
 
   Вы можете создать привилегии специально для столбцов наподобии использования других привилегий, но, для команды INSERT, это будет означать вставку значений по умолчанию, а для команды DELETE, ограничение столбца не будет иметь значения. Привелегии REFERENCES и UPDATE, конечно, могут сделать столбцы специфическими не прибегая к представлению.
### ОГРАНИЧЕНИЕ ПРИВЕЛЕГИЙ ДЛЯ ОПРЕДЕЛЕННЫХ СТРОК
   Обычно, более полезный способ чтобы фильтровать привилегии с представлениями - это использовать представление чтобы привилегия относилась только к определенным строкам. Вы делаете это, естественно, используя предикат в представлении который определит, какие строки являются включенными. Чтобы предоставить пользователю Adrian, привилегию UPDATE в таблице Заказчиков, для всех заказчиков размещенных в Лондоне, вы можете создать такое представление:
 
    CREATE VIEW Londoncust
    AS SELECT *
    FROM Customers
    WHERE city='London'
    WITH CHECK OPTION;
 
   Затем Вы должны передать привилегию UPDATE в этой таблице для Adrian:
 
    GRANT UPDATE ON Londoncust TO Adrian;
 
   В этом отличие привилегии для определенных строк от привилегии UPDATE для определенных столбцов, которая распространена на все столбцы таблицы Заказчиков, но не на строки, среди которых строки со значением поля city иным чем London не будут учитываться. Предложение WITH CHECK OPTION предохраняет Adrian от замены значения поля city на любое значение кроме London.
 
### ПРЕДОСТАВЛЕНИЕ ДОСТУПА ТОЛЬКО К ИЗВЛЕЧЕННЫМ ДАННЫМ
   Другая возможность состоит в том, чтобы предлагать пользователям доступ к уже извлеченным данным, а не к фактическим значениям в таблице. Агрегатные функции, могут быть весьма удобными в применении такого способа. Вы можете создавать представление которое дает счет, среднее, и общее количество для порядков на каждый день порядка:
 
    CREATE VIEW Datetotals
    AS SELECT odate, COUNT (*), SUM (amt), AVG (amt)
    FROM Orders
    GROUP BY odate;
 
   Теперь вы передаете пользователю Diane - привелегию SELECT в представлении Datetotals:
 
    GRANT SELECT ON Datetotals TO Diane;
 
### ИСПОЛЬЗОВАНИЕ ПРЕДСТАВЛЕНИЙ В КАЧЕСТВЕ АЛЬТЕРНАТИВЫ К ОГРАНИЧЕНИЯМ
   Одной из последних прикладных программ из серии, описанной в Главе 18, является использование представлений с WITH CHECK OPTION как альтернативы к ограничениям. Предположим что вы хотели удостовериться, что все значения поля city в таблице Продавцов находятся в одном из городов где ваша компания в настоящее время имеет ведомство. Вы можете установить ограничение CHECK непосредственно на столбец city, но позже может стать трудно его изменить, если ваша компания например откроет там другие ведомства. В качестве альтернативы, можно создать представление, которое исключает неправильные значения city:

CREATE VIEW Curcities
   AS SELECT *
   FROM Salespeople
   WHERE city IN ('London', 'Rome', 'San Jose', 'Berlin')
   WITH CHECK OPTION;
 
   Теперь, вместо того, чтобы предоставить пользователям привилегии модифицирования в таблице Продавцов, вы можете предоставить их в представлении Curcities. Преимущество такого подхода - в том, что если вам нужно сделать изменение, вы можете удалить это представление, создать новое, и предоставить в этом новом представлении привилегии пользователям, что проще чем изменять ограничения. Недостатком является то, что владелец таблицы Продавцов также должен использовать это представление если он не хочет чтобы его собственные команды были отклонены. С другой стороны, этот подход позволяет владельцу таблицы и любым другим получить привилегии модификации в самой таблице, а не в представлении, чтобы делать исключения для ограничений.
   Это часто бывает желательно, но не выполнимо, если вы используете ограничения в базовой таблице. К сожалению, эти исключения нельзя будет увидеть в представлении. Если вы выберите этот подход, вам захочется создать второе представление, содержащее только исключения:
 
    CREATE VIEW Othercities
    AS SELECT *
    FROM Salespeople
    WHERE city NOT IN ('London', 'Rome', 'San Jose',
    'Berlin')
    WITH CHECK OPTION;
 
   Вы должны выбрать для передачи пользователям только привилегию SELECT в этом представлении, чтобы они могли видеть исключенные строки, но не могли помещать недопустимые значения city в базовую таблицу. Фактически, пользователи могли бы сделать запрос обоих представлений в объединении и увидеть все строки сразу.
### ДРУГИЕ ТИПЫ ПРИВИЛЕГИЙ
   Вы разумеется хотите знать, кто же имеет право первым создать таблицу. Эта область привилегии не относится к ANSI, но не может игнорироваться. Все стандартные привилегии ANSI вытекают из этой привилегии; привилегии создателей таблиц которые могут передавать привилегии объекта. Если все ваши пользователи будут создавать в системе базовые таблицы с разными размерами это приведет к избыточности в них и к неэффетивности системы. Притягивают к себе и другие вопросы:
   * Кто имеет право изменять, удалять, или ограничивать таблицы?
   * Должны ли права создания базовых таблиц отличаться от прав создания представлений?
   * Должен ли быть суперпользователь - пользователь который отвечает за поддержание базы данных и следовательно имеющий наибольшие, или все привилегии, которые не предоставляются индивидуально?
 
   Пока ANSI не принимает в этом участие, а SQL используется в различных средах, мы не можем дать окончательный ответ на эти вопросы. Мы предлагаем рассмотреть здесь кусок наиболее общих выводов.
   Привилегии которые не определяются в терминах специальных объектов данных называются - привилегиями системы, или правами базы данных. На базисном уровне, они будут вероятно включать в себя право создавать объекты данных, вероятно отличающиеся от базовых таблиц( обычно создаваемыми несколькими пользователями ) и представления (обычно создаваемые большинством пользователей). Привилегии системы для создания представлений, должны дополнять, а не заменять привилегии объекта которые ANSI требует от создателей представлений (описанных ранее в этой главе). Кроме того, в системе любого размера всегда имеются некоторые типы суперпользователей - пользователей которые автоматически имеют большинство или все привилегии - и которые могут передать свой статус суперпользователя кому-нибудь с помощью привилегии или группы привилегий. Администратор Базы Данных, или DBA, является термином наиболее часто используемым для такого суперпользователя, и для привилегий которыми он обладает.
### ТИПИЧНЫЕ ПРИВИЛЕГИИ СИСТЕМЫ
   При общем подходе имеется три базовых привилегии системы:
   * CONNECT (Подключить)
   * RESOURCE (Ресурс)
   * DBA (Аминистратор Базы Данных).
 
   Проще, можно сказать, что CONNECT состоит из права зарегистрироваться и права создавать представления и синонимы(см. Главу 23), если переданы привилегии объекта. RESOURCE состоит из права создавать базовые таблицы. DBA - это привилегия суперпользователя, дающая пользователю высокие полномочия в базе данных. Один или более пользователей с функциями администратора базы данных может иметь эту привилегию. Некоторые системы кроме того имеют специального пользователя, иногда называемого SYSADM или SYS (Системный Администратор Базы Данных), который имеет наивысшие полномочия; это - специальное имя, а не просто пользователь со специальной DBA привилегией. Фактически только один человек имеет право зарегистрироваться с именем SYSADM, являющимся его идентификатором доступа. Различие весьма тонкое и функционирует по разному в различных системах. Для наших целей, мы будем ссылаться на высокопривилегированного пользователя, который разрабатывает и управляет базой данных имея полномочия DBA, понимая что фактически эти полномочия - та же самая привилегия. Команда GRANT, в измененной форме, является пригодной для использования с привилегиями объекта как и с системными привилегиями. Для начала передача прав может быть сделана с помощью DBA.
   Например, DBA может передать привилегию для создания таблицы пользователю Rodriguez следующим образом:
 
    GRANT RESOURCE TO Rodriguez;
### СОЗДАНИЕ И УДАЛЕНИЕ ПОЛЬЗОВАТЕЛЕЙ
   Естественно появляется вопрос, откуда возьмется пользователь с именем Rodriguez ? Как определить его ID допуска ? В большинстве реализаций, DBA создает пользователя, автоматически предоставляя ему привилегию CONNECT. В этом случае, обычно добавляется предложение IDENTIFIED BY, указывающее пароль. (Если же нет, операционная система должна определить, можете ли вы зарегистрироваться в базе данных с данным ID доступа. ) DBA может, например, ввести
 
    GRANT CONNECT TO Thelonius IDENTIFIED BY Redwagon;
 
   что приведет к созданию пользователя, с именем Thelonius, даст ему право регистрироваться, и назначит ему пароль Redwagon, и все это в одном предложении.
   Раз Thelonious - уже опознаный пользователь, он или DBA могут использовать эту же команду чтобы изменить пароль Redwagon. Хотя это и удобно, но все же имеются ограничения и в этом подходе. Это невозможность иметь пользователя который не мог бы зарегистрироваться, хотя бы временно. Если вы хотите запретить пользователю регистрироваться, вы должны использовать для REVOKE привилегию CONNECT, которая "удаляет" этого пользователя. Некоторые реализации позволяють вам создавать и удалять пользователей, независимо от их привилегий при регистрации.
   Когда вы предоставляете привилегию CONNECT пользователю, вы создаете этого пользователя. При этом чтобы сделать это Вы сами, должны иметь DBA привилегию. Если этот пользователь будет создавать базовые таблицы (а не только представления ), ему нужно также предоставить привилегию RESOURCE. Но это сразу порождает другую проблему.
   Если вы сделаете попытку удалить привилегию CONNECT пользователя, который имеет им созданые таблицы, команда будет отклонена, потому что ее действие оставит таблицу без владельца, а это не позволяется. Вы должны сначала удалить все таблицы созданные этим пользователем, прежде чем удалить его привилегию CONNECT . Если эти таблицы не пустые, то вы вероятно захотите передать их данные в другие таблицы с помощью команды INSERT, которая использует запрос. Вам не нужно удалять отдельно привилегию RESOURSE; достаточно удалить CONNECT чтобы удалить пользователя. Хотя все выше сказаное - это вполне стандартный подход к привилегиям системы, он также имеет значительные ограничения. Появились альтернативные подходы, которые более конкретно определены и точнее управляют привилегиями системы.
   Эти выводы несколько выводят нас за пределы стандарта SQL как это определено в настоящее время, и, в некоторых реализациях, могут полностью выйти за пределы стандарта SQL. Эти вещи вероятно не будут слишком вас касаться, если вы не DBA или не пользователь высокого уровня. Обычные пользователи просто должны быть знакомыми с привилегиями системы в принципе, справляясь со своей документации только в случае специальных сообщений.
### РЕЗЮМЕ
   Привилегии дают вам возможность видеть SQL под новым углом зрения, когда SQL выполняет действия через специальных пользователей в специальной системе базы данных. Сама команда GRANT достаточно проста: с ее помощью, вы предоставляете те или иные привилегии объекта одному или более пользователям. Если вы предоставляете привилегию WITH GRANT OPTION пользователю, этот пользователь может в свою очередь предоставить эту привилегию другим. Теперь вы понимаете намеки на использование привилегий в представлениях - чтобы усовершенствовать привилегии в базовых таблицах, или как альтернативы к ограничениям - и на некоторые преимущества и недостатки такого подхода. Привилегии системы, которые необходимы, но не входят в область стандарта SQL, обсуждались в их наиболее общей форме и поэтому вы будете знакомиться с ними на практике.
   Глава 23 продолжит обсуждение о выводах в SQL, таких как сохранение или восстановление изменений, создание ваших собственных имен для таблиц принадлежащих другим людям, и понимание что происходит когда различные пользователи пытаются обращаться к одному и тому же объекту одновременно.
### РАБОТА С SQL
   * Передайте Janet право на изменение оценки заказчика.
   * Передайте Stephan право передавать другим пользователям право делать запросы в таблице Порядков.
   * Отнимите привилегию INSERT( ВСТАВКА) в таблице Продавцов у Claire и у всех пользователей которым она была предоставлена.
   * Передайте Jerry право вставлять или модифицировать таблицу Заказчиков с сохранением его возможности оценивать значения в диапазоне от 100 до 500.
   * Рарешите Janet делать запросы в таблице Заказчиков, но запретите ему уменьшать оценки в той же таблице Заказчиков.    



