## Глава 23. ГЛОБАЛЬНЫЕ АСПЕКТЫ SQL
 
   ЭТА ГЛАВА БУДЕТ ОБСУЖДАТЬ АСПЕКТЫ ЯЗЫКА SQL которые имеют отношение к базе данных как к единому целому, включая использование многочисленых имен для объектов данных, размещение запоминаемых данных, восстановлние и сохранение изменений в базе данных а также координирование одновременных действий многочисленных пользователей. Этот материал даст вам возможность конфигурации вашей базы данных, отмены действия ошибок, и определения как действия одного пользователя в базе данных будут влиять на действия других пользователей.
### ПЕРЕИМЕНОВАНИЕ ТАБЛИЦ
   Каждый раз, когда вы ссылаетесь в команде к базовой таблице или представлению не являющимися вашей собственностью, вы должны установить в ней префикс имени владельца, так что бы SQL знала где ее искать. Так как это со временем становится неудобным, большинство реализаций SQL позволяют вам создавать синонимы для таблиц (что не является стандартом ANSI ) Синоним - это альтернативное имя, наподобии прозвища, для таблицы. Когда вы создаете синоним, вы становитесь его собственником, так что нет никакой необходимости, чтобы он предшествовал другому пользовательскому идентификатору доступа( имени пользователя ) Если вы имеете по крайней мере одну привилегию в одном или более столбцах таблицы; вы можете создать для них синоним. (Некоторое отношение к этому может иметь специальная привилегия для создания синонимов.)
   
 Adrian может создать синоним с именем Clients, для таблицы с именем Diane.Customers, с помощью команды CREATE SYNONYM следующим образом:
 
    CREATE SYNONYM Clients FOR Diane.Customers;
 
   Теперь, Adrian может использовать таблицу с именем Clients в команде точно так же как ее использует Diane.Customers. Синоним Clients - это собственность, используемая исключительно для Adrian.
### ПЕРЕИМЕНОВАНИЕ С ТЕМ ЖЕ САМЫМ ИМЕНЕМ
   Префикс (прозвище) пользователя - это фактически часть имени любой таблицы. Всякий раз, когда вы не указываете ваше собственное имя пользователя вместе с именем вашей собственной таблицы, SQL сам заполняет для вас это место. Следовательно, два одинаковых имени таблицы но связанные с различными владельцами, становятся не идентичными и следовательно не приводят к какому-нибудь беспорядку (по крайней мере в SQL).
   Это означает что два пользователя могут создать две полностью несвязанные таблицы с одинаковыми именами, но это также будет означать, что один пользователь может создать представление основанное на имени другого пользователя стоящем после имени таблицы. Это иногда делается когда представление, рассматривается как сама таблица - например, если представление просто использует CHECK OPTION как заменитель ограничения CHECK в базовой таблице( смотрите Главу 22 для подробностей). Вы можете также создавать ваши собственные синонимы, имена которых будут такими же что и первоначальные имена таблиц. Например, Adrian может определить Customers, как свой синоним для таблицы Diane.Customers :
 
    CREATE SYNONYM Customers FOR Diane.Customers;
 
   С точки зрения SQL, теперь имеются два разных имени одной таблицы:
   Diane.Customers и Adrian.Customers. Однако, каждый из этих пользователей может ссылаться к этой таблице просто как к Customers, SQL как говорилось выше сам добавит к ней недостающие имена пользователей.
### ОДНО ИМЯ ДЛЯ КАЖДОГО
   Если вы планируете иметь таблицу Заказчиков используемую большим числом пользователей, лучше всего что бы они ссылались к ней с помощью одного и того же имени. Это даст вам возможность, например, использовать это имя в вашем внутреннем общении без ограничений. Чтобы создать единое имя для всех пользователей, вы создаете общий синоним. Например, если все пользователи будут вызывать таблицу Заказчиков с именем Customers, вы можете ввести
 
    CREATE PUBLIC SYNONYM Customers FOR Customers;
 
   Мы пронимаем, что таблица Заказчиков это ваша собственность, поэтому никакого префикса имени пользователя в этой команды не указывается. В основном, общие синонимы создаются владельцами объектов или привилегированными пользователями, типа DBA. Пользователям кроме того, должны еще быть предоставлены привилегии в таблице Заказчиков чтобы они могли иметь к ней доступ. Даже если имя является общим, сама таблица общей не является. Общие синонимы становятся собственными с помощью команды PUBLIC, а не с помощью их создателей.
### УДАЛЕНИЕ СИНОНИМОВ
   Общие и другие синонимы могут удаляться командой DROP SYNONYM. Синонимы удаляются их владельцами, кроме общих синонимов, которые удаляются соответствующими привилегированными личностями, обычно DBA. Чтобы удалить например синоним Clients, когда вместо него уже появился общий синоним Customers, Adrian может ввести
 
    DROP SYNONYM Clients;
 
   Сама таблица Заказчиков, естественно, становится не эффективной.
   КАК БАЗА ДАННЫХ РАСПРЕДЕЛЕНА ДЛЯ ПОЛЬЗОВАТЕЛЕЙ?
   Таблицы и другие объекты данных сохраняются в базе данных и находятся там связанными с определенными пользователями которые ими владеют.
   В некотором смысле, вы могли бы сказать, что они сохраняются в " именной области пользователя ", хотя это никак не отражает их физического расположения, но зато, как и большинство вещей в SQL, находятся в строгой логической конструкции. Однако, на самом деле, объекты данных сохраняться, в физическом смысле, и количество памяти которое может использоваться определенным объектом или пользователем, в данное время, имеют свой предел.
   В конце концов, никакой компьютер не имеет прямого доступа к бесконечному числу аппаратных средств (диску, ленте, или внутренней памяти) для хранения данных. Кроме того, эффективность SQL расширится если логическая структура данных будет отображаться неким физическим способом при котором эти команды получать преимущество.
   В больших SQL системах, база данных будет разделена на области, так называемые Области Базы Данных или Разделы.
   Это области сохраняемой информации, которые размещены так, чтобы информация внутри них находилась близко друг к другу для выполнения команд; то-есть программа не должна искать где-то далеко информацию, сгруппированную в одиночной области базы данных. Хотя ее физические возможности зависят от аппаратного оборудования, целесообразно чтобы команда работала в этих областях внутри самой SQL. Системы которые используют области базы данных (в дальнейшем называемых - DBS (Data Base Spaces)), позволяют вам с помощью команд SQL обрабатывать эти области как объекты.
   DBS создаются командами CREATE DBSPACE (СОЗДАТЬ DBS), ACQUIRE DBSPACE(ПОЛУЧИТЬ DBS) или CREATE TABLESPACE (СОЗДАТЬ ТАБЛИЧНУЮ ОБЛАСТЬ), в зависимости от используемой реализации. Одна DBS может вмещать любое число пользователей, и отдельный пользователь может иметь доступ к многим DBS. Привилегия создавать таблицы, хотя и может быть передана по всей базу данных, часто передается в конкретной DBS. Мы можем создать DBS с именем Sampletables, следующей командой:
 
    CREATE DBSPACE Sampletables
    ( pctindex 10,
    pctfree 25);
 
   Параметр pctindex определяет какой процент DBS должен быть оставлен, чтобы сохранять в нем индексы таблиц. Pctfree - это процент DBS который оставлен чтобы позволить таблицам расширять размеры их строк (AL- TER TABLE может добавлять столбцы или увеличивать размер столбцов, делая каждую строку длиннее. Это - расширение памяти отводимой для этого). Имеются также другие параметры которые вы также можете определять, и которые меняются от программы к программе. Большинство программ автоматически будут обеспечивать значения по умолчанию, поэтому вы можете создавать DBS не определяя эти параметры. DBS может иметь или определенное ограничение размера, или ей может быть позволено расти неограниченно вместе с таблицами. Если DBS создалась, пользователям предоставляются права создавать в ней объекты. Вы можете например предоставить Diane право создать таблицу Sampletables с помощью следующей команды:
 
    GRANT RESOURCE ON Sampletables TO Diane;
 
   Это даст вам возможность более конкретно определять место хранения данных. Первый DBS назначаемый данному пользователю - обычно тот, где все объекты этого пользователя создаются по умолчанию. Пользователи имеющие доступ к многочисленым DBS могут определить, где они хотят разместить определенный объект. При разделении вашей базы данных на DBSы, вы должны иметь в виду типы операций, которые вы будете часто выполнять. Таблицы которые, как вам уже известно, будут часто объединяться, или которые имеют одну таблицу ссылающуюся на другую во внешнем ключе, должны находиться вместе в одной DBS.
   Например, вы могли бы сообщить при назначении типовых таблиц, что таблица Порядков будет часто объединяться с одной или обеими из двух других таблиц,, так как таблица Порядков использует значения из обеих этих таблиц. При прочих равных условиях, эти три таблицы должны входить в ту же самую область DBS, независимо от того, кто их владелец.
   Возможное присутствие ограничения внешнего ключа в таблице Порядков, просто приведет к более строгому совместному использованию области DBS.
### КОГДА СДЕЛАННЫЕ ИЗМЕНЕНИЯ СТАНОВЯТСЯ ПОСТОЯННЫМИ?
   Визуально, среда базы данных, это картина которая постоянно отображает для существующих пользователей, постоянно вводимые и изменяемые данные, допуская, что если система правильно разработана, она будет функционировать без сбоев. Однако реально, благодаря человеческим или компьютерным сбоям, ошибки время от времени случаются, и поэтому хорошие компьютерные программы стали применять способы отмены действий вызвавших такие ошибки. Команда SQL, которая воздействует на содержание или структуру базы данных - например команда модификации DML или команда DROP TABLE, - не обязательно будет необратимой. Вы можете определить после окончания ее действия, останутся ли изменения сделанные данной командой или группой команд постоянными в базы данных, или онибудут полностью проигнорированы. С этой целью, команды обрабатываются группами, называемыми - транзакциями. Транзакция начинается всякий раз, когда вы начинаете сеанс с SQL. Все команды которые вы введете будут частью этой транзакции, пока вы не завершите их вводом команды COMMIT WORK или команды ROLLBACK WORK. COMMIT может сделать все изменения постоянными с помощью транзакции, а ROLLBACK может откатить их братно или отменить. Новая транзакция начинается после каждой команды COMMIT или ROLLBACK. Этот процесс известен как диалоговая обработка запросов или транзакция. Синтаксис, чтобы оставить все ваши изменения постоянными во время регистрации, или во время последнего COMMIT или ROLLBACK
 
    COMMIT WORK;
 
   Синтаксис отмены изменения -
 
    ROLLBACK WORK;
 
   В большинстве реализаций, вы можете установить параметр, называемый AUTOCOMMIT. Он будет автоматически запоминать все действия которые будут выполняться. Действия которые приведут к ошибке, всегда будут автоматически "прокручены" обратно. Если это предусмотрено в вашей системе, для фиксации всех ваших действий, вы можете использовать эту возможность с помощью команды типа:
 
    SET AUTOCOMMIT ON;
 
   Вы можете вернуться к обычной диалоговой обработке запросов с помощью такой команды:
 
    SET AUTOCOMMIT OFF;
 
   Имеется возможность установки AUTOCOMMIT которую система выполнит автоматически при регистрации. Если сеанс пользователя завершается аварийно - например, произошел сбой системы или выполнена перезагрузка пользователя, - то текущая транзакция выполнит автоматический откат изменений. Это - одна из причин, по которой вы можете управлять выпонением вашей диалоговой обработки запросов, разделив ваши команды на большое количество различных транзакций. Одиночная транзакция не должна содержать много несвязанных команд; фактически, она может состоять из единственной команды. Транзакции которые включают всю группу несвязанных изменений не оставляют вам фактически никакого выбора сохранить или отклонить целую группу, если вы хотите отменить только одно определенное изменение. Хорошим правилом которому надо следовать, это делать ваши транзакции состоящими из одной команды или нескольких близко связанных команд. Например, предположим вы хотите удалить продавца Motika из базы данных. Прежде, чем вы удалите его из таблицы Продавцов, вы сначала должны сделать что-нибудь с его порядками и его заказчиками. (Если используются ограничения внешнего ключа, и ваша система, следуя ANSI, ограничивает изменение родительского ключа, у вас не будет выбора делать или не делать этого. Это будет сделано обязательно.)
   Одно из логических решений, будет состоять в том, чтобы установить поле snum в его порядках в NULL, в следствии чего ни один продавец не получит комиссионные в этих порядках, пока комиссионые не будут предоставлены заказчикам для Peel. Затем вы можете удалить их из таблицы Продавцов:
   
    UPDATE Orders
    SET snum=NULL
    WHERE snum=1004;
    
    UPDATE Cudomers
    SET snum=1001
    WHERE snum=1004;
    
    DELETE FROM Salespeople
    WHERE snum=1004;
 
   Если у вас проблема с удалением Motika (возможно имеется другой внешний ключ ссылающийся на него о котором вы не знали и не учитывали ), вы могли бы отменить все изменения которые вы сделали, до тех пор пока проблема не будет определена и решена.
   Более того, это должна быть группа команд, чтобы обрабатывать ее как одиночную транзакцию. Вы можете предусмотреть это с помощью команды COMMIT, и завершить ее с помощью команды COMMIT или ROLLBACK.
 
### КАК SQL ОБЩАЕТСЯ СРАЗУ СО МНОГИМИ ПОЛЬЗОВАТЕЛЯМИ
   SQL часто используется в многопользовательских средах - в средах, где сразу много пользователей могут выполнять действия в базе данных одновременно. Это создает потенциальную возможность конфликта между различными выполняемыми действиями. Например, предположим что вы выполняете команду в таблице Продавцов :
 
    UPDATE Salespeople
    SET comm=comm * 2
    WHERE sname LIKE 'R%';
 
   и в это же время, Diane вводит такой запрос:
 
    SELECT city, AVG (comm)
    FROM Salespeople
    GROUP BY city;
 
   Может ли усредненное значение(AVG) Diane отазить изменения которые вы делаете в таблице? Не важно, будет это сделано или нет, а важно что бы были отражены или все или ни одно из значений комиссионных (comm) для которых выполнялись изменения. Любой промежуточный результат является случайным или непредсказуемым, для порядка в котором значения были изменены физически. Вывод запроса, не должен быть случайным и непредсказуемым. Посмотрим на это с другой стороны. Предположим, что вы находите ошибку и прокручиваете обратно все ваши модификации уже после того, как Diane получила их результаты в виде вывода. В этом случае Diane получит ряд усредненых значений основанных на тех изменениях которые были позже отменены, не зная что ее информации неточна. Обработка одновременных транзакций называется - параллелизмом или совпадением, и имеет номера возможных проблем которые могут при этом возникать.
   Имеются следующие примеры:
   * Модификация может быть сделана без учета другой модификации. Например, продавец должен сделать запрос к таблице инвентаризации, чтобы найти десять фрагментов пунктов торговцев акциями, и упорядочить шесть из их для заказчика. Прежде, чем это изменение было сделано, другой продавец делает запрос к таблице и упорядочивает семь из тех же фразментов для своего заказчика. ПРИМЕЧАНИЕ: Термин "упорядочить", аналогичен общепринятому - "заказать", что в принципе более соответствует логике запроса, потому что с точки зрения пользователя, он именно "заказывает" информацию в базе данных, которая упорядочивает эту информацию в соответствии с "заказом".
   * Изменения в базе данных могут быть прокручены обратно уже после того, как их действия уже были закончены. Например если Вы отменили вашу ошибку уже после того, как Diane получила свой вывод.
   * Одно действие может воздействовать частично на результат другого действия. Например когда Diane получает среднее от значений в то время как вы выполняете модификацию этих значений. Хотя это не всегда проблематично, в большинстве случаев действие такое же как если бы агрегаты должны были отразить состояние базы данных в пункте относительной стабильности. Например в ревизионных книгах, должна быть возможность вернуться назад и найти это существующее усредненное значение для Diane в некоторой временной точке, и оставить его без изменений которые можно было бы сделаны начиная уже с этого места. Это будет невозможно сделать, если модификация была выполнена во время вычисления функции.
   * Тупик. Два пользователя могут попытаться выполнить действия которые конфликтуют друг с другом. Например, если два пользователя попробуют изменить и значение внешнего ключа и значение родительского ключа одновременно.
 
   Имеется много сложнейших сценариев которые нужно было бы последовательно просматривать, если бы одновременные транзакции были неуправляемыми. К счастью, SQL обеспечивает вас средством управления параллелизмом для точного указания места получения результата. Что ANSI указывает для управления параллелизмом -это что все одновременные команды будут выполняться по принципу - ни одна команда не должна быть выдана, пока предыдущая не будет завершена (включая команды COMMIT или ROLLBACK ).
   Более точно, нужно просто не позволить таблице быть доступной более чем для одной транзакции в данный момент времени. Однако в большинствситуаций, необходимость иметь базу данных доступную сразу многим пользователям, приводит к некоторому компромису в управлении параллелизмом. Некоторые реализации SQL предлагают пользователям выбор, позволяя им самим находить золотую середину между согласованностью данных и доступностью к базе данных. Этот выбор доступен пользователю, DBA, или тому и другому.
   На самом деле они осуществляют это управление вне SQL, даже если и воздействуют на процесс работы самой SQL.
   Механизм используемый SQL для управления параллелизмом операций, называется - блокировкой. Блокировки задерживают определенные операции в базе данных, пока другие операции или транзакции не завершены. Задержанные операции выстраиваюится в очередь и выполняются только когда блокировка снята (некоторые инструменты блокировок дают вам возможность указывать NOWAIT, которая будет отклонять команду вместо того чтобы поставить ее в очередь, позволяя вам делать что-нибудь другое).
   Блокировки в многопользовательских системах необходимы. Следовательно, должен быть некий тип схемы блокировки по умолчанию, который мог бы применяться ко всем командам в базе данных. Такая схема по умолчанию, может быть определена для всей базы данных, или в качестве параметра в команде CREATE DBSPACE или команде ALTER DBSPACE, и таким образом использовать их по разному в различных DBS. Кроме того, системы обычно обеспечиваются неким типом обнаружителя зависания, который может обнаруживать ситуации, где две операции имеют блокировки, блокирующие друг друга. В этом случае, одна из команд будет прокручена обратно и получит сброс блокировки. Так как терминология и специфика схем блокировок меняются от программы к программе, мы можем смоделировать
   наши рассуждения на примере программы базы данных DB2 фирмы IBM. IBM - лидер в этой области (как впрочим и во многих других ), и поэтому такой подход наиболее удобен. С другой стороны, некоторые реализации могут иметь значительные различия в синтаксисе и в функциях, но в основном их действия должно быть очень похожими.
### ТИПЫ БЛОКИРОВОК
   Имеется два базовых типа блокировок:
   - распределяемые блокировки и
   - специальльные блокировки.
   Распределяемые (или S-блокировки ) могут быть установлены более чем однимо пользователя в данный момент времени. Это дает возможность любому числу пользователей обращаться к данным, но не изменять их.
   Специальные блокировки (или X-блокировки ) не позволяют никому вообще, кроме владельца этой блокировки обращаться к данным. Специальные блокировки используются для команд которые изменяют содержание или структуру таблицы. Они действуют до конца транзакции.
   Общие блокировки используются для запросов. Насколько они продолжительны зависит фактически от уровня изоляции.
   Что такое уровень изоляции блокировки? Это - то, что определяет, сколько таблиц будет блокировано. В DB2, имеется три уровня изоляции, два из которых можно применить и к распределеным и к специальным блокировкам, а третий, ограниченный, чтобы использовать эти блокировки совместно. Они управляются командами поданными извне SQL, так что мы можем обсуждать не указывая их точного синтаксиса. Точный синтаксис команд связанных с блокировками различен для различных реализаций.
   Следующее обсуждение полезно прежде всего на концептуальном уровне.
   Уровень изоляции - повторное чтение - гарантирует, что внутри данной транзакции, все записи извлеченные с помощью запросов, не могут быть изменены. Поскольку записи модифицируемые в транзакции являются субъектами специальной блокировки, пока транзакция не завершена, они не могут быть изменены в любом случае. С другой стороны для запросов, повторное чтение означает, что вы можете решить заранее, какие строки вы хотите заблокировать и выполнить запрос который их выберет. Выполняя запроса, вы гарантированы, что никакие изменения не будут сделаны в этих строках, до тех пор пока вы не завершите текущую транзакцию.
   В то время как повторное чтение защищает пользователя, который поместил блокировку, она может в то же время значительно снизить производительность.
   Уровень указатель стабильности - предохраняет каждую запись от изменений, на время когда она читается или от чтения на время ее изменения. Последний случай это специальная блокировка, и применяется пока изменение не завершено или пока оно не отменено( т.е. на время отката изменения). Следовательно, когда вы модифицируете группу записей использующих указатель стабильности, эти записи будут заблокированы пока транзакция не закончится, что аналогично действию производимому уровнем повторное чтение. Различиие между этими двумя уровнями в их воздействии на запросы. В случае уровня указатель стабильности, строки таблицы которые в данное время не используются запросом, могут быть изменены. Третий уровень изоляции DB2 - это уровень только чтение.
   Только чтение фиксирует фрагмент данных; хотя на самом деле он блокирует всю таблицу. Следовательно, он не может использоваться с командами модификации. Любое содержание таблицы как единое целое, в момент выполнения команды, будет отражено в выводе запроса.
   Это не обязательно так как в случае с уровнем указатель стабильности. Блокировка только чтение, гарантирует что ваш вывод будет внутренне согласован, если конечно нет необходимости во второй блокировке, не связывающей большую часть таблицы с уровнем повторное чтение. Блокировка только чтение удобна тогда, когда вы делаете отчеты, которые должны быть внутренне согласованны, и позволять доступ к большинству или ко всем строкам таблицы, не связывая базу данных.
### ДРУГИЕ СПОСОБЫ БЛОКИРОВКИ ДАННЫХ
   Некоторые реализации выполняют блокировку страницы вместо блокировки строки. Это может быть либо возможностю для вашего управления либо нечто заложенным уже в конструкцию системы.
   Страница - это блок накопления памяти, обычно равный 1024 байт.
   Страница может состоять из одной или более строк таблицы, возможно сопровождаемых индексами и другой периферийной информацией, а может состоять даже из нескольких строк другой таблицы. Если вы блокируете страницы вместо строк, все данные в этих страницах будут блокированы точно также как и в индивидуальных строках, согласно уровням изоляции описаным выше.
   Основным преимуществом такого подхода является эффективность. Когда SQL не следит за блокированность и разблокированностью строк индивиду-ально, он работает быстрее. С другой стороны, язык SQL был разработан так чтобы максимизировать свои возможности, и произвольно блокирует строки которые необязательно было блокировать.
   
 Похожая возможность, доступная в некоторых системах - это блокировка областей DBS. Области базы данных имеют тенденцию быть больше чем страница, так что этот подход удовлетворяет и достоинству увиличения производительности и недостатку блокирования страниц.
   Вообще то лучше отключать блокировку низкого уровня если вам кажется что появились значительные проблемы с эффективностью.
### РЕЗЮМЕ
   Ключевые определения, с которыми вы познакомились в этой главе:
   * Синонимы, или как создавать новые имена для объектов данных.
   * Области базы даных (DBS), или как распределяется доступная память в базе данных.
   * Транзакция, или как сохранять или восстанавливать изменения в базе данных.
   * Управление Параллелизмом, или как SQL предохраняет от конфликта одной команды с другой.
 
   Синонимы - это объекты, в том смысле, что они имеют имена и (иногда) владельцев, но естественно они не могут существовать без таблицы, чье имя они замещают. Они могут быть общими и следовательно доступными каждому кто имеет доступ к объекту, или они могут принадлежать определенному пользователю.
   Области DBS или просто DBS - это подразделы базы данных, которые распределены для пользователей. Связанные таблицы, (например таблицы, которые будут часто объединяться,) лучше хранить в общей для них DBS.
   СOMMIT и ROLLBACK - это команды, используемые для выполнения изменений в базе данных, в то время когда предыдущая команда COMMIT или команда ROLLBACK, начинают сеанс и оставляют изменения, или игнорируют их как группу.
   Средство Управление Параллелизмом - определяет в какой степени одновременно поданные команды будут мешать друг другу. Оно является адаптируемым средством, находящим компромис между производительностью базы данных и изоляцией действующих команд.
### РАБОТА С SQL
   * Создайте область базы данных с именем Myspace которая выделяет 15 процентов своей области для индексов, и 40 процентов на расширение строк.
   * Вы получили право SELECT в таблице Порядков продавца Diane. Введите команду так чтобы вы могли ссылаться к этой таблице как к "Orders" не используя имя "Diane" в качестве префикса.
   * Если произойдет сбой питания, что случится с всеми изменениями сделанными во время текущей транзакции?
   * Если вы не можете видеть строку из-за ее блокировки, какой это тип блокировки?
   * Если вы хотите получить общее, максимальное, и усредненое значения сумм приобретений для всех порядков, и не хотите при этом запрещать другим пользоваться таблицей, какой уровень изоляции будет этому соответствовать?

### Глава 24. КАК ДАННЫЕ SQL СОДЕРЖАТСЯ В УПОРЯДОЧЕННОМ ВИДЕ
 
   В ЭТОЙ ГЛАВЕ, ВЫ УЗНАЕТЕ КАК ТИПОВАЯ SQL БАЗА данных сохраняет самоорганизованность. Не удивительно, что самоорганизованность обеспечива ется реляционной базой данных, создаваемой и поддерживаемой с помощью программы. Вы можете обращаться к этим таблицам самостоятельно для по лучения информации о привилегиях, таблицах, индексах, и так далее. Эта глава покажет вам некоторые типы содержащиеся в такой базе данных.
   
### КАТАЛОГ СИСТЕМЫ

   Чтобы функционировать как SQL база данных, ваша компьютерная система должна следить за многими различными вещями: таблицами, представлениями, индексами, синонимами, привилегиями, пользователями, и так далее.
   Имеются различные способы делать это, но ясно, что наиболее логичный, эффективный, и согласованный способ делать это в реляционной среде состоит в том, чтобы сохранять эту информацию в таблицах. Это дает возможность компьютеру размещать и управлять информацией в которой он нуждается, используя те же самые процедуры которые он использует чтобы размещать и управлять данными которые он хранит для вас. Хотя это - вопрос конкретной программы, а не часть стандарта ANSI, большинство SQL баз данных, используют набор SQL таблиц хранящих служебную информацию для своих внутренних потребностей. Этот набор называется в различных публикациях как - системный каталог, словарь данных, или просто системные таблицы (Термин "словарь данных" может также относится к общему архиву данных, включая информацию о физических параметрах базы данных которые хранятся вне SQL. Следовательно, имеются программы баз данных, которые имеют и системный каталог и словарь данных. )
   Таблицы системного каталога - напоминают обычные SQL таблицы: те же строки и столбцы данных. Например, одна таблица каталога обычно содержит информацию о таблицах существующих в базе данных, по одной строке на каждую таблицу базы данных; другая содержит информацию о различных столбцах таблиц, по одной строке на столбец, и так далее. Таблицы каталога создаются и присваиваются с помощью самой базы данных, и идентифицируются с помощью специальных имен, таких например как SYSTEM.
   База данных создает эти таблицы и модифицирует их автоматически; таблицы каталога не могут быть непосредственно подвергнуты действию команды модификации.
   Если это случится, это значительно запутает всю систему и сделает ее неработоспособной. Однако, в большинстве систем, каталог может быть запрошен пользователем. Это очень полезно, потому что это дает вам возможность узнать кое-что о базе данных, которую вы используете. Конечно, вся информация не всегда доступна всем пользователям. Подобно другим таблицам, доступ к каталогу ограничен для пользователей без соответствующих привилегий. Так как каталог принадлежит самой системе, имеется некоторая неясность относительно того, кто имеет привилегии и кто может предоставить привилегии в этом каталоге. Обычно, привилегии каталога предоставляет суперпользователь, например, администратор системы, зарегистрированый как SYSTEM или DBA. Кроме того, некоторые привилегии могут предоставляться пользователям автоматически.
### ТИПИЧНЫЙ СИСТЕМНЫЙ КАТАЛОГ
   Давайте рассмотрим некоторые таблицы которые мы могли бы найти в типовом каталоге системы:
   
  | Таблицы        | Содержание                            |
|----------------|---------------------------------------|
| SYSTEMCATALOG  | Таблицы (базовые и представления)     |
| SYSTEMCOLUMNS  | Столбцы таблицы                       |
| SYSTEMTABLES   | Каталог Представления в SYSTEMCATALOG |
| SYSTEMINDEXES  | Индексы в таблице                     |
| SYSTEMUSERAUTH | Пользователи базы данных              |
| SYSTEMTABAUTH  | Объектные привилегии пользователей    |
| SYSTEMCOLAUTH  | Столбцовые привилегии пользователей   |
| SYSTEMSYNONS   | Синонимы для таблиц                   |
 
 
   Теперь, если наш DBA предоставит пользователю Stephen право просматривать SYSTEMCATALOG такой командой,
 
    GRANT SELECT ON SYSTEMCATALOG TO Stephen;
 
   то Stephen сможет увидеть некоторую информацию обо всех таблицах в базе данных (мы имеем здесь пользователя DBA, пользователя Chris, владельца трех наших типовых таблиц, а также Adrian владельца представления Londoncust ).
 
    SELECT tname, owner, numcolumns, type, CO
    FROM SYSTEMCATALOG;
 
SQL Execution Log

    SELECT tname, owner, numcolumns, type, CO
    FROM SYSTEMCATALOG;

|    tname                                 |    owner                                 |    numcolumns                            |    type                                  |     CO                                   |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    SYSTEMCATALOG<br style="margin: 0px; padding: 0px;"> |    SYSTEM<br style="margin: 0px; padding: 0px;"> |    4<br style="margin: 0px; padding: 0px;"> |    B<br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> <br style="margin: 0px; padding: 0px;"> |
|    Salespeople<br style="margin: 0px; padding: 0px;"> |    Chris<br style="margin: 0px; padding: 0px;"> |    4<br style="margin: 0px; padding: 0px;"> |    B<br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> <br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    Chris<br style="margin: 0px; padding: 0px;"> |    5<br style="margin: 0px; padding: 0px;"> |    B<br style="margin: 0px; padding: 0px;"> |    Y<br style="margin: 0px; padding: 0px;"> |
|    Londoncust<br style="margin: 0px; padding: 0px;"> |    Adrian<br style="margin: 0px; padding: 0px;"> |    5<br style="margin: 0px; padding: 0px;"> |    V<br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> <br style="margin: 0px; padding: 0px;"> |
|    Orders<br style="margin: 0px; padding: 0px;"> |    Chris<br style="margin: 0px; padding: 0px;"> |    5<br style="margin: 0px; padding: 0px;"> |    B<br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> <br style="margin: 0px; padding: 0px;"> |

   Таблица 24.1: Содержание таблицы SYSTEMCATALOG
   Как вы можете видеть, каждая строка описывает свою таблицу. Первый столбец - имя; второй - имя пользователя который владеет ею; третий - число столбцов которые содержит таблица; и четвертый - код из одного символа, это или B (для базовой таблицы ) или V (для представления). Последний столбец имеет пустые(NULL) значения, если его тип не равен V; и этот столбец указывает, определена или нет возможность проверки. Обратите внимание что SYSTEMCATALOG(СЧИСТЕМНЫЙ КАТАЛОГ) представлен как одна из таблиц в вышеуказаном списке. Для простоты, мы исключили остальные каталоги системы из вывода. Таблицы системного каталога обычно показываются в SYSTEMCATALOG.
### ИСПОЛЬЗОВАНИЕ ПРЕДСТАВЛЕНИЙ В ТАБЛИЦАХ КАТАЛОГА
   Поскольку SYSTEMCATALOG - это таблица, вы можете использовать ее в представлении. Фактически можно считать, что имеется такое представление с именем SYSTEMTABLES. Это представление SYSTEMCATALOG содержит только те таблицы, которые входят в системный каталог; это обычно таблицы базы данных, типа таблицы Продавцов, которые показаны в SYSTEMCATALOG, но не в SYSTEMTABLES. Давайте предположим, что только таблицы каталога являются собственностью пользователя SYSTEM. Если вы захотите, вы можете определить другое представление, которое бы специально исключало таблицы каталога из вывода:
 
    CREATE VIEW Datatables
    AS SELECT *
    FROM SYSTEMCATALOG
    WHERE owner < > 'SYSTEM';
 
   РАЗРЕШИТЬ ПОЛЬЗОВАТЕЛЯМ ВИДЕТЬ (ТОЛЬКО) ИХ СОБСТВЕННЫЕ ОБЪЕКТЫ
   Кроме того, имеются другое использование представлений каталога.
   Предположим вам нужно чтобы каждый пользователь был способен сделать запрос каталога, для получения информации только из таблиц которыми он владеет. Пока значение USER, в команде SQL постоянно для ID доступа пользователя выдающего команду, оно может всегда быть использоваться, чтобы давать доступ пользователям только к их собственным таблицам. Вы можете, для начала создать следующее представление:
 
    CREATE VIEW Owntables
    AS SELECT *
    FROM SYSTEMCATALOG
    WHERE Owner=USER;
 
   Теперь вы можете предоставить всем пользователям доступ к этому представлению:
 
    GRANT SELECT ON Owntables TO PUBLIC;
 
   Каждый пользователь теперь, способен выбирать (SELECT) только те строки из SYSTEMCATALOG, владельцем которых он сам является.
   ПРЕДСТАВЛЕНИЕ SYSTEMCOLUMNS
   Одно небольшое добавление к этому, позволит каждому пользователю просматривать таблицу SYSTEMCOLUMNS для столбцов из его собственных таблиц. Сначала, давайте рассмотрим ту часть таблицы SYSTEMCOLUMNS, которая описывает наши типовые таблицы( другими словами, исключим сам каталог):
   
|    tname                                 |    cname                                 |    datatype                              |    cnumber                               |    tabowner                              |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    Salespeople<br style="margin: 0px; padding: 0px;"> |    snum<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Salespeople<br style="margin: 0px; padding: 0px;"> |    sname<br style="margin: 0px; padding: 0px;"> |    char<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Salespeople<br style="margin: 0px; padding: 0px;"> |    city<br style="margin: 0px; padding: 0px;"> |    char<br style="margin: 0px; padding: 0px;"> |    3<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Salespeople<br style="margin: 0px; padding: 0px;"> |    comm<br style="margin: 0px; padding: 0px;"> |    decimal<br style="margin: 0px; padding: 0px;"> |    4<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    cnum<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    cname<br style="margin: 0px; padding: 0px;"> |    char<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    city<br style="margin: 0px; padding: 0px;"> |    char<br style="margin: 0px; padding: 0px;"> |    3<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    rating<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    4<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    snum<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    5<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Orders<br style="margin: 0px; padding: 0px;"> |    onum<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Orders<br style="margin: 0px; padding: 0px;"> |    odate<br style="margin: 0px; padding: 0px;"> |    date<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Orders<br style="margin: 0px; padding: 0px;"> |    amt<br style="margin: 0px; padding: 0px;"> |    decimal<br style="margin: 0px; padding: 0px;"> |    3<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Orders<br style="margin: 0px; padding: 0px;"> |    cnum<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    4<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Orders<br style="margin: 0px; padding: 0px;"> |    snum<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    5<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |

   Как вы можете видеть, каждая строка этой таблицы показывает столбец таблицы в базе данных. Все столбцы данной таблицы должны иметь разные имена, также как каждая таблица должна иметь данного пользователя, и наконец все комбинации пользователей, таблиц, и имен столбцов должны различаться между собой.
   
Следовательно табличные столбцы: tname (имя таблицы ), tabowner (владелец таблицы ), и cname (имя столбца ), вместе составляют первичный ключ этой таблицы. Столбец datatype( тип данных ) говорит сам за себя. Столбец cnumber (номер столбца ) указывает на местоположении этого столбца внутри таблицы. Для упрощения, мы опустили параметры длины столбца, точности, и масштаба.
   Для справки, показана строка из SYSTFMCATALOG которая ссылается к этой таблице:
 
|    tname                                 |    owner                                 |    numcolumns                            |    type                                  |    CO                                    |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    SYSTEMCOLUMNS<br style="margin: 0px; padding: 0px;"> |    System<br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> <br style="margin: 0px; padding: 0px;"> |    8<br style="margin: 0px; padding: 0px;"> |    B<br style="margin: 0px; padding: 0px;"> |

Некоторые SQL реализации, будут обеспечивать вас большим количеством данных чем показано в этих столбцах, но показанное являются основой для любый реализаций.
   Для иллюстрации процедуры предложенной в начале этого раздела, имеется способ, позволяющий каждому пользователю видеть информацию SYSTEMCOLUMNS только для принадлежащих ему таблиц:
 
    CREATE VIEW Owncolumns
    AS SELECT *
    FROM SYSTEMCOLUMNS
    WHERE tabowner=USER;
    
    GRANT SELECT ON Owncolumns TO PUBLIC;
 
### КОММЕНТАРИЙ В СОДЕРЖАНИИ КАТАЛОГА
   Большинство версий SQL, позволяют вам помещать комментарии(ремарки) в специальные столбцы пояснений таблиц каталогов SYSTEMCATALOG и SYSTEMCOLUMNS, что удобно, так как эти таблицы не всегда могут объяснить свое содержание. Для простоты, мы пока исключали этот столбец из наших иллюстраций.
   Можно использовать команду COMMENT ON со строкой текста, чтобы пояснить любую строку в одной из этих таблиц. Состояние - TABLE, для комментирования в SYSTEMCATALOG, и текст - COLUMN, для SYSTEMCOLUMNS.
   Например:
 
    COMMENT ON TABLE Chris.Orders
    IS 'Current Customer Orders';
 
   Текст будет помещен в столбец пояснений SYSTEMCATALOG. Обычно, максимальная длина таких пояснений - 254 символов.
   Сам комментарий, указывается для конкретной строки, одна с tname=Orders, а другая owner=Chris. Мы увидим этот комментарий в строке для таблицы Порядков в SYSTEMCATALOG:
 
    SELECT tname, remarks
    FROM SYSTEMCATALOG
    WHERE tname='Orders'
    AND owner='Chris';
 
   Вывод для этого запроса показывается в Таблица 24.2.
   SYSTEMCOLUMNS работает точно так же. Сначала, мы создаем комментарий
 
    COMMENT ON COLUMN Orders.onum
    IS 'Order #';
 
   затем выбираем эту строку из SYSTEMCOLUMNS:
 
    SELECT cnumber, datatype, cname, remarks
    FROM SYSTEMCOLUMNS
    WHERE tname='Orders'
    AND tabowner='Chris'
    AND cname=onum;
 
   Вывод для этого запроса показывается в Таблице 24.3.
   Чтобы изменить комментарий, вы можете просто ввести новую команду COMMENT ON для той же строки. Новый комментарий будет записан поверх старого. Если вы хотите удалить комментарий, напишите поверх него пустой комментарий, подобно следующему:
 
    COMMENT ON COLUMN Orders.onum
    IS ";
 
   и этот пустой комментарий затрет предыдущий.
 
SQL Execution Log
 
    SELECT tname, remarks FROM SYSTEMCATALOG
    WHERE tname='Orders' AND owner='Chris'

|    tname                                 |    remarks                               |
|------------------------------------------|------------------------------------------|
|    Orders<br style="margin: 0px; padding: 0px;"> |    Current Customers Orders<br style="margin: 0px; padding: 0px;"> |


   Таблица 24.2: Коментарий в SYSTEMCATALOG
 
    SQL Execution Log
    SELECT cnumber, datatype, cname, remarks
    FROM SYSTEMCOLUMNS WHERE tname='Orders' AND tabowner='Chris'
    AND cname='onum'
    
|    cnumber                               |    datatype                              |    cname                                 |    remarks                               |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1<br style="margin: 0px; padding: 0px;"> |    integer<br style="margin: 0px; padding: 0px;"> |    onum<br style="margin: 0px; padding: 0px;"> |    Orders #<br style="margin: 0px; padding: 0px;"> |


   Таблица 24.3: Коментарий в SYSTEMCOLUMNS
### ОСТАЛЬНОЕ ИЗ КАТАЛОГА
   Здесь показаны оставшиеся из ващих системных таблиц определения, с типовым запросом для каждого:
 
    SYSTEMINDEXES - ИНДЕКСАЦИЯ В БАЗЕ ДАННЫХ
 
   Имена столбцов в таблице SYSTEMINDEXES и их описания - следующие:

|    СТОЛБЦЫ                               |    ОПИСАНИЕ                              |
|------------------------------------------|------------------------------------------|
|    iname<br style="margin: 0px; padding: 0px;"> |    Имя индекса (используемого для его исключения )<br style="margin: 0px; padding: 0px;"> |
|    iowner<br style="margin: 0px; padding: 0px;"> |    Имя пользователя который создал индекс<br style="margin: 0px; padding: 0px;"> |
|    tname<br style="margin: 0px; padding: 0px;"> |    Имя таблицы которая содержит индекс<br style="margin: 0px; padding: 0px;"> |
|    cnumber<br style="margin: 0px; padding: 0px;"> |    Номер столбца в таблице<br style="margin: 0px; padding: 0px;"> |
|    tabowner<br style="margin: 0px; padding: 0px;"> |    Пользователь который владеет таблицей содержащей индекс<br style="margin: 0px; padding: 0px;"> |
|    numcolumns<br style="margin: 0px; padding: 0px;"> |    Число столбцов в индексе<br style="margin: 0px; padding: 0px;"> |
|    cposition<br style="margin: 0px; padding: 0px;"> |    Позиция текущего столбца среди набора индексов<br style="margin: 0px; padding: 0px;"> |
|    isunique<br style="margin: 0px; padding: 0px;"> |    Уникален ли индекс (Y или N )<br style="margin: 0px; padding: 0px;"> |

 
### ТИПОВОЙ ЗАПРОС
   Индекс считается неуникальным, если он вызывает продавца, в snum столбце таблицы Заказчиков:
 
    SELECT iname, iowner, tname, cnumber, isunique
    FROM SYSTEMINDEXES
    WHERE iname='salesperson';
 
   Вывод для этого запроса показывается в Таблице 24.4.
 
SQL Execution Log
 
    SELECT iname, iowner, tname, cnumber, isunique
    FROM SYSTEMINDEXES WHERE iname='salespeople';

|    iname                                 |    iowner                                |    tname                                 |    cnumber                               |    isunique                              |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    salesperson<br style="margin: 0px; padding: 0px;"> |    Stephan<br style="margin: 0px; padding: 0px;"> |    Customers<br style="margin: 0px; padding: 0px;"> |    5<br style="margin: 0px; padding: 0px;"> |    N<br style="margin: 0px; padding: 0px;"> |

   Таблица 24.4: Строка из таблицы SYSTEMINDEXES
   
### SYSTEMUSERAUTH - ПОЛЬЗОВАТЕЛЬСКИЕ И СИСТЕМНЫЕ ПРИВИЛЕГИИ В БАЗЕ ДАННЫХ
   Имена столбцов для SYSTEMUSERAUTH и их описание, следующее:
   
|    Столбцы                               |    Описание                              |
|------------------------------------------|------------------------------------------|
|    username<br style="margin: 0px; padding: 0px;"> |    Идентификатор (ID ) доступа пользователя<br style="margin: 0px; padding: 0px;"> |
|    password<br style="margin: 0px; padding: 0px;"> |    Пароль пользователя вводимый при регистрации<br style="margin: 0px; padding: 0px;"> |
|    resource<br style="margin: 0px; padding: 0px;"> |    Где пользователь имеет права RESOURCE<br style="margin: 0px; padding: 0px;"> |
|    dba<br style="margin: 0px; padding: 0px;"> |    Где пользователь имеет права DBA<br style="margin: 0px; padding: 0px;"> |


   Мы будем использовать простую схему системных привилегий, которая представлена в Главе 22, где были представлены три системных привилегии - CONNECT( ПОДКЛЮЧИТЬ ), RESOURCE( РЕСУРСЫ ) и DBA. Все пользователи получают CONNECT по умолчанию при регистрации, поэтому он не описан в таблице выше. Возможные состояния столбцов resource и dba могут быть - Y (Да, пользователь имеет привилегии) или - No (Нет, пользователь не имеет привилегий).
   Пароли (password) доступны только высоко привилегированным пользователям, если они существуют. Следовательно запрос этой таблицы можно вообще делать только для информации относительно привилегий системы и пользователей.
   ТИПОВОЙ ЗАПРОС Чтобы найти всех пользователей которые имеют привилегию RESOURCE, и увидеть какие из них - DBA, вы можете ввести следующее условие:
 
    SELECT username, dba
    FROM SYSTEMUSERAUTH
    WHERE resource='Y';
 
   Вывод для этого запроса показывается в Таблице 24.5.
 
### SYSTEMTABAUTH - ПРИВИЛЕГИИ ОБЪЕКТА ОТОРЫЕ НЕ ОПРЕДЕЛЯЮТ СТОЛБЦЫ
   Здесь показаны имена столбцов в таблице SYSTEMTABAUTH и их описание:
   
|    COLUMN                                |    ОПИСАНИЕ                              |
|------------------------------------------|------------------------------------------|
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |

   username Пользователь который имеет привилегии grantor Пользователь который передает привилегии по имени пользователя tname Имя таблицы в которой существуют привилегии owner Владелец tname selauth Имеет ли пользователь привилегию SELECT insauth Имеет ли пользователь привилегию INSERT delauth Имеет ли пользователь привилегию DELETE
   Возможные значения для каждой из перечисленных привилегий объекта (имена столбцов которых окончиваются на auth ) - Y, N, и G. G указывает что пользователь имеет привилегию с возможностью передачи привилегий.
   В каждой строке, по крайней мере один из этих столбцов должен иметь состояние отличное от N (другими словами, иметь хоть какую-то привилегию).
 
SQL Execution Log
    
    SELECT username, dba FROM SYSTEMUSERAUTH
       WHERE resource='Y' ;
    
|    username                              |    dba                                   |
|------------------------------------------|------------------------------------------|
|    Diane<br style="margin: 0px; padding: 0px;"> |    N<br style="margin: 0px; padding: 0px;"> |
|    Adrian<br style="margin: 0px; padding: 0px;"> |    Y<br style="margin: 0px; padding: 0px;"> |


   Таблица 24 .5: Пользователи которые имеют привилегию RESOURCE
   Первые четыре столбца этой таблицы составляют первичный ключ. Это означает что каждая комбинация из tname, владелец-пользователь (не забудьте, что две различные таблицы с различными владельцами могут иметь одно и тоже имя ), пользователь и пользователь передающий права(гарантор ), должна быть уникальной. Каждая строка этой таблицы содержит все привилегии (которые не являются определенным столбцом ), предоставляются одним определенным пользователем другому определенному пользователю в конкретном объекте. UPDATE и REFERENCES, являются привилегиями, которые могут быть определенными столбцами, и находиться в различных таблицах каталога. Если пользователь получает привилегии в таблице от более чем одного пользователя, такие привилегии могут быть отдельными строками созданными в этой таблице. Это необходимо для каскадного отслеживания при вызове привилегий.
   ТИПОВОЙ ЗАПРОС. Чтобы найти все привелегии SELECT, INSERT, и DELETE, которые Adrian предоставляет пользователям в таблице Заказчиков, вы можете ввести следующее (вывод показан в Таблице 24.6 ):
 
    SELECT username, selauth, insauth, delauth
    FROM SYSTEMTABAUTH
    WHERE grantor='Adrian'
    ANDtname='Customers';
 
SQL Execution Log

    SELECT username, selauth, insauth, delauth
    FROM SYSTEMTABAUTH WHERE grantor='Adrian'
    AND tname='Customers';
    
|    username                              |    selauth                               |    insauth                               |    delauth                               |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    Claire<br style="margin: 0px; padding: 0px;"> |    G<br style="margin: 0px; padding: 0px;"> |    Y<br style="margin: 0px; padding: 0px;"> |    N<br style="margin: 0px; padding: 0px;"> |
|    Norman<br style="margin: 0px; padding: 0px;"> |    Y<br style="margin: 0px; padding: 0px;"> |    Y<br style="margin: 0px; padding: 0px;"> |    Y<br style="margin: 0px; padding: 0px;"> |

   Таблица 24. 6: Пользователи получившие привилегии от Adrian
 
   Выше показано, что Adrian предоставил Claire привилегии INSERT и SELECT в таблице Заказчиков, позднее предоставив ей права на передачу привилегий. Пользователю Norman, он предоставил привелегии SELECT, INSERT, и DELETE, но не дал возможность передачи привилегий ни в одной из них. Если Claire имела привилегию DELETE в таблице Заказчиков от какого-то другого источника, в этом запросе это показано не будет.
   
### SYSTEMCOLAUTH

|    СТОЛБЦЫ                               |    ОПИСАНИЕ                              |
|------------------------------------------|------------------------------------------|
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |
|  <br style="margin: 0px; padding: 0px;"> |  <br style="margin: 0px; padding: 0px;"> |

username Пользователь который имеет привилегии grantor Пользователь который предоставляет привилегии другому пользователю tname Имя таблицы в которой существуют привилегии cname Имя столбца в котором существуют привилегии owner Владелец tname updauth Имеет ли пользователь привилегию UPDATE в этом столбце refauth Имеет ли пользователь привилегию REFERENCES в этом столбце
   Столбцы updauth и refauth могут быть в состоянии Y, N, или G; но не могут быть одновременно в состоянии N для одной и той же строки. Это - первые пять столбцов таблицы, которы не составляют первичный ключ. Он отличается от первичного ключа SYSTEMTABAUTH в котором содержится поле cname, указывающее на определенный столбец обсуждаемой таблицы для которой применяются одна или обе привилегии. Отдельная строка в этой таблице может существовать для каждого столбца в любой данной таблицы в которой одному пользователю передаются превилегии определенного столбца с помощью другого пользователя. Как и в случае с SYSTEMTABAUTH та же привилегия может быть описана в более чем одной строке этой таблицы если она была передана более чем одним пользователем.
   ТИПОВОЙ ЗАПРОС. Чтобы выяснить, в каких столбцах какой таблицы вы имеете привилегию REFERENCES, вы можете ввести следующий запрос (вывод показывается в Таблице 24.7 )
 
    SELECT owner, tname, cname
    FROM SYSTEMCOLAUTH
    WHERE refauth IN ('Y', 'G')
     AND username=USER
    ORDER BY 1, 2;
 
   который показывает, что эти две таблицы, которые имеют различных владельцев, но одинаковые имя, в действительности, совершенно разные таблицы (т.е. это не как два синонима для одной таблицы ).
 
SQL Execution Log
 
    SELECT OWNER, TNAME, CNAME FROM SYSTEMCOLAUTH
    WHERE refaulth IN ('Y', 'G' ) AND username=USER
    ORDER BY 1, 2;

|    owner                                 |    tname                                 |    cname                                 |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    Diane<br style="margin: 0px; padding: 0px;"> |    Customers<br style="margin: 0px; padding: 0px;"> |    cnum<br style="margin: 0px; padding: 0px;"> |
|    Diane<br style="margin: 0px; padding: 0px;"> |    Salespeople<br style="margin: 0px; padding: 0px;"> |    sname<br style="margin: 0px; padding: 0px;"> |
|    Diane<br style="margin: 0px; padding: 0px;"> |    Salespeople<br style="margin: 0px; padding: 0px;"> |    sname<br style="margin: 0px; padding: 0px;"> |
|    Gillan<br style="margin: 0px; padding: 0px;"> |    Customers<br style="margin: 0px; padding: 0px;"> |    cnum<br style="margin: 0px; padding: 0px;"> |

  Таблица 24. 7: Столбцы в пользователь имеет привилегию INSERT
### SYSTEMSYNONS - СИНОНИМЫ ДЛЯ ТАБЛИЦ В БАЗЕ ДАННЫХ
   Это - имена столбцов в таблице SYSTEMSYNONS и их описание:
   
|    СТОЛБЕЦ                               |    ОПИСАНИЕ                              |
|------------------------------------------|------------------------------------------|
|    synonym<br style="margin: 0px; padding: 0px;"> |    Имя синонима<br style="margin: 0px; padding: 0px;"> |
|    synowner<br style="margin: 0px; padding: 0px;"> |    Пользователь, который является владельцем синонима (может быть PUBLIC (ОБЩИЙ))<br style="margin: 0px; padding: 0px;"> |
|    tname<br style="margin: 0px; padding: 0px;"> |    Имя таблицы используемой владельцем<br style="margin: 0px; padding: 0px;"> |
|    tabowner<br style="margin: 0px; padding: 0px;"> |    Имя пользователя который является владельцем таблицы<br style="margin: 0px; padding: 0px;"> |

### ТИПОВОЙ ЗАПРОС.
Предположим, что Adrian имеет синоним Clients для таблицы Заказчиков принадлежащей Diane, и что имеется общий синоним Customers для этой же таблицы. Вы делаете запрос таблицы для всех синонимов в таблице Заказчиков (вывод показывается в Таблице 24.8 ):
 
    SELECT *
    FROM SYSTEMSYNONS
    WHERE tname='Customers'
 
SQL Execution Log
 
    SELECT * FROM SYSTEMSYNONS
    WHERE tname='Customers';

|    synonym                               |    synowner                              |    tname                                 |    tabowner                              |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    Clients<br style="margin: 0px; padding: 0px;"> |    Adrian<br style="margin: 0px; padding: 0px;"> |    Customers<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    PUBLIC<br style="margin: 0px; padding: 0px;"> |    Customers<br style="margin: 0px; padding: 0px;"> |    Diane<br style="margin: 0px; padding: 0px;"> |

 
   Таблица 24.8: Синонимы для таблицы Заказчиков
### ДРУГОЕ ИСПОЛЬЗОВАНИЕ КАТАЛОГА
   Конечно, вы можете выполнять более сложные запросы в системном каталоге. Обьединения, например, могут быть очень удобны. Эта команда позволит вам увидеть столбцы таблиц и базовые индексы установленые для каждого, (вывод показывается в Таблице 24.9 ):
 
    SELECT a.tname, a.cname, iname, cposition
    FROM SYSTEMCOLUMNS a, SYSTEMINDEXES b
    WHERE a.tabowner=b. tabowner
    AND a.tname=b.tname
    AND a.cnumber=b.cnumber
    ORDER BY 3 DESC, 2;
 
   Она показывает два индекса, один для таблицы Заказчиков и один для таблицы Продавцов. Последний из них - это одностолбцовый индекс с именем salesno в поле snum; он был помещен первым из-за сортировки по убыванию (в обратном алфавитном порядке ) в столбце iname. Другой индекс, custsale, используется продавцами чтобы отыскивать своих заказчиков. Он основывается на комбинации полей snum и cnum внутри таблицы Заказчиков, с полем snum приходящим в индексе первым, как это и показано с помощью поля cposition.
 
SQL Execution Log
 
    SELECT a.tname, a.cname, iname, cposition
    FROM SYSTEMCOLUMNS a, SYSTEMINDEXES b
    WHERE a.tabowner=b.tabowner
    AND a.tname=b.tname
    AND a.cnumber=b.cnumber
    ORDER BY 3 DESC, 2;

|    tname                                 |    cname                                 |    iname                                 |    cposition                             |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    Salespeople<br style="margin: 0px; padding: 0px;"> |    sname<br style="margin: 0px; padding: 0px;"> |    salesno<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    cnum<br style="margin: 0px; padding: 0px;"> |    custsale<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |
|    Customers<br style="margin: 0px; padding: 0px;"> |    snum<br style="margin: 0px; padding: 0px;"> |    custsale<br style="margin: 0px; padding: 0px;"> |    1<br style="margin: 0px; padding: 0px;"> |

 Таблица 24.9 Столбцы и их индексы
 
   Подзапросы также могут быть использованы. Имеется способ увидеть данные столбца только для столбцов из таблиц каталога:
 
    SELECT *
    FROM SYSTEMCOLUMNS
    WHERE tname IN
    ( SELECT tname
    FROM SYSTEMCATALOG);
 
   Для простоты, мы не будем показывать вывод этой команды, которая состоит из одного входа для каждого столбца каждой таблицы каталога.
   Вы могли бы поместить этот запрос в представление, назвав его, например, SYSTEMTABCOLS, для представления SYSTEMTABLES.
### РЕЗЮМЕ
   Итак, система SQL использует набор таблиц, называемый ситемным каталогом в структуре базы данных. Эти таблицы могут запрашиваться но модифицироваться. Кроме того, вы можете добавлять комментарии столбцов в (и удалять их из) таблицы SYSTEMCATALOG и SYSTEMCOLUMNS.
   Создание представлений в этих таблицах - превосходный способ точно определить, какая пользовательская информация может быть доступной.
   Теперь, когда вы узнали о каталоге, вы завершили ваше обучение SQL в диалоговом режиме. Следующая глава этой книги расскажет вам как SQL используется в программах которые написаны прежде всего на других языках но которые способны извлечь пользу из возможностей SQL, взаимодействуя с его таблицами базы данных.
### РАБОТА С SQL
   * Сделайте запрос каталога чтобы вывести, для каждой таблицы имеющей более чем четыре столбца, имя таблицы, имя владелеца, а также имя столбцов и тип данных этих столбцов.
   * Сделайте запрос каталога чтобы выяснить, сколько синонимов существует для каждой таблицы в базе данных. Не забудьте, что один и тот же синоним принадлежащий двум различным пользователям - это фактически два разных синонима.
   * Выясните сколько таблиц имеют индексы в более чем пятьдесяти процентов их столбцов.

## Глава 25. ИСПОЛЬЗОВАНИЕ SQL С ДРУГИМ ЯЗЫКОМ
( ВЛОЖЕННЫЙ SQL )
 
   В ЭТОЙ ГЛАВЕ ВЫ УЗНАЕТЕ КАК SQL ИСПОЛЬЗУЕТСЯ для расширения программ написанных на других языках. Хотя непроцедурность языка SQL делает его очень мощным, в то же время это накладывает на него большое число ограничений. Чтобы преодолеть эти ограничения, вы можете включать SQL в программы написанные на том или другом процедурном языке( имеющем определенный алгоритм). Для наших примеров, мы выбрали Паскаль, считая что этот язык наиболее прост в понимании для начинающих, и еще потому, что Паскаль - один из языков для которых ANSI имеет полуофициальный стандарт.
### ЧТО ТАКОЕ - ВЛОЖЕНИЕ SQL
   Чтобы вложить SQL в другой язык, вы должны использовать пакет программ который бы обеспечивал поддержку вложения SQL в этот язык и конечно же, поддержку самого языка. Естественно, вы должны быть знакомы с языком который вы используете. Главным образом, вы будете использовать команды SQL для работы в таблицах базы данных, передачи результатов вывода в программу и получение ввода из программы в которую они вкладываются, обобщенно ссылаясь к главной программе (которая может или не может ппринимать их из диалога или посылать обратно в диалог пользователя и программы).
### ЗАЧЕМ ВКЛАДЫВАТЬ SQL?
   Хотя и мы потратили некоторое время на то чтобы показать что умеет делать SQL, но если вы - опытный программист, вы вероятно отметили, что сам по себе, он не очень полезен при написании программ. Самое очевидное ограничение - это то, что в то время как SQL может сразу выполнить пакет команды, интерактивный SQL в основном выполняет по одной команде в каждый момент времени. Типы логических конструкций типа
 
    if ... then ("если ... то" ),
    for ... do ("для ... выполнить") и
    while ... repeat( "пока ... повторять" ) -
 
   используемых для структур большинства компьютерных программ, здесь отсутствуют, так что вы не сможете принять решение - выполнять ли, как выполнять, или как долго выполнять одно действие в результате другого действия. Кроме того, интерактивный SQL не может делать многого со значениями, кроме ввода их в таблицу, размещения или распределения их с помощью запросов, и конечно вывода их на какое-то устройство.
   Более традиционные языки, однако, сильны именно в этих областях. Они разработаны так чтобы программист мог начинать обработку данных, и основываясь на ее результатах, решать, делать ли это действие или другое, или же повторять действие до тех пока не встретится некоторое условие, создавая логические маршруты и циклы. Значения сохраняются в переменных, которые могут использоваться и изменяться с помощью любого числа команд. Это дает вам возможность указывать пользователям на ввод или вывод этих команд из файла, и возможность форматировать вывод сложными способами (например, преобразовывать числовых данных в диаграммы). Цель вложенного SQL состоит в том, чтобы объединить эти возможности, позволяющие вам создавать сложные процедурные программы которые адресуют базу данных посредством SQL - позволяя вам устранить сложные действия в таблицах на процедурном языке который не ориентирован на такую структуру данных, в тоже время поддерживая структурную строгость процедурного языка.
 
### КАК ДЕЛАЮТСЯ ВЛОЖЕНИЯ SQL.
   Команды SQL помещаются в исходный текст главной программы, которой предшествует фраза - EXEC SQL (EXECute SQL). Далее устанавливаются некоторые команды которые являются специальными для вложенной формы SQL, и которые будут представлены в этой главе.
   Строго говоря, стандарт ANSI не поддерживает вложенный SQL как таковой. Он поддерживает понятие, называемое - модуль, который более точно, является вызываемым набором процедур SQL, а не вложением в другой язык. Официальное определение синтаксиса вложения SQL, будет включать расширение официального синтаксиса каждого языка в который может вкладываться SQL, что весьма долгая и неблагодарная задача, которую ANSI избегает. Однако, ANSI обеспечивает четыре приложения (не являющиеся частью стандарта ), которые определяют синтаксис вложения SQL для четырех языков: КОБОЛ, ПАСКАЛЬ, ФОРТРАН, и ПЛ/1. Язык C - также широко поддерживается как и другие языки. Когда вы вставляете команды SQL в текст программы написанной на другом языке, вы должны выполнить предкомпиляцию прежде, чем вы окончательно ее скомпилируете.
   Программа называемая прекомпилятором (или препроцессором ), будет просматривать текст вашей программы и преобразовывать команды SQL, в форму удобную для использования базовым языком.
   Затем вы используете обычный транслятор чтобы преобразовывать программу из исходного текста в выполняемый код.
   Согласно подходу к модульному языку определенному ANSI, основная программа вызывает процедуры SQL. Процедуры выбирают параметры из главной программы, и возвращают уже обработанные значения, обратно в основную программу. Модуль может содержать любое число процедур, каждая из которых состоит из одиночной команды SQL. Идея в том, чтобы процедуры могли работать тем же самым способом чтго и процедуры на языке в который они были вложены( хотя модуль еще должен идентифицировать базовый язык из-за различий в типах данных различных языков ).
   Реализации могут удовлетворить стандарту, выполнив вложение SQL таким способом, как если бы модули уже были точно определены. Для этой цели прекомпилятор будет создавать модуль, называемый модулем доступа.
   Только один модуль, содержащий любое число процедур SQL, может существовать для данной программы. Размещение операторов SQL непосредственно в главном коде, происходит более просто и более практично чем непосредственно создание самих модулей.
   Каждая из программ использующих вложение SQL, связана с ID доступа, во время ее выполнения. ID доступа, связанный с программой, должен иметь все привилегии чтобы выполнять операции SQL, выполняемые в программе. Вообще то, вложенная программа SQL регистрируется в базе данных, также как и пользователь, выполняющий программу. Более подробно, это определяет проектировщик, но вероятно было бы неплохо для включить в вашу программу команду CONNECT или ей подобную.
### ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННЫХ ОСНОВНОГО ЯЗЫКА В SQL
   Основной способ которым SQL и части базового языка ваших программ будут связываться друг с другом - это с помощью значений переменных. Естественно, что разные языки распознают различные типы данных для переменных. ANSI определяет эквиваленты SQL для четыре базовых языков - ПЛ/1, Паскаль, КОБОЛ, и ФОРТРАН; все это подробности описаны в Приложении B. Эквиваленты для других языков - определяет проектировщик.

Имейте в виду, что типы, такие как DATE, не распознаются ANSI; и следовательно никаких эквивалентных типов данных для базовых языков, не существуют в стандарте ANSI. Более сложные типы данных базового языка, такие как матрицы, не имеют эквивалентов в SQL. Вы можете использовать переменные из главной программы во вложенных операторах SQL везде, где вы будете использовать выражения значений. (SQL, используемый в этой главе, будет пониматься как к вложенный SQL, до тех пор пока это не будет оговорено особо. )
   Текущим значением переменной, может быть значение, используемое в команде. Главные переменные должны -
   * быть обьявленными в SQL DECLARE SESSION (РАЗДЕЛ ОБЪЯВЛЕНИЙ ) который будет описан далее.
   * иметь совместимый тип данных с их функциями в команде SQL (например, числовой тип если они вставляется в числовое поле )
   * быть назначеными значению во время их использования в команде SQL, если команда SQL самостоятельно не может сделать назначение.
   * предшествовать двоеточию (:) когда они упоминаются в команде SQL.
 
   Так как главные переменные отличаются от имен столбцов SQL наличием у них двоеточия, вы можете использовать переменные с теми же самыми именами что и ваши столбцы, если это конечно нужно. Предположим что вы имеете четыре переменных в вашей программе, с именами: id_num, salesperson, loc, и comm. Они содержат значения которые вы хотите вставить в таблицу Продавцов. Вы могли бы вложить следующую команду SQL в вашу программу:
 
    EXEC SQL INSERT INTO Salespeople
    VALUES (:id_num, :salesperson, :loc, :comm)
 
   Текущие значения этих переменных будут помещены в таблицу. Как вы можете видеть, переменная comm имеет то же самое имя что и столбец в который это значение вкладывается. Обратите внимание, что точка с запятой в конце команды отсутствует. Это потому, что соответствующее завершение для вложенной команды SQL зависит от языка для которого делается вложение. Для Паскаля и PL/1, это будет точка с запятой; для КОБОЛА, слово END-EXEC ; и для ФОРТРАНА не будет никакого завершения. В других языках это зависит от реализации, и поэтому мы договоримся что будем использовать точку с запятой (в этой книге) всегда, чтобы не
   противоречить интерактивному SQL и Паскалю. Паскаль завершает вложенный SQL и собственные команды одинаково - точкой с запятой. Способ сделать команду полностью такой как описана выше, состоит в том, чтобы включать ее в цикл и повторять ее, с различными значениями переменных, как например показано в следующем примере:
 
    while not end-ot-file (input) do
    begin
    readln (id_num, salesperson, loc, comm);
    EXEC SOL INSERT INTO Salespeople
    VALUES (:id_num, :salesperson, :loc, :comm);
    end;
 
   Фрагмент программы на ПАСКАЛЕ, определяет цикл, который будет считывать значения из файла, сохранять их в четырех проименованных переменных, сохранять значения этих переменных в таблице Продавцов, и затем считывать следующие четыре значения, повторяя этот процесс до тех пор пока весь входной файл не прочитается. Считается, что каждый набор значений завершается возвратом каретки (для незнакомых с Паскалем, функция readln считывает вводимую информацию и переходит на следующую строку источника этой информации). Это дает вам простойспособ передать данные из текстового файла в реляционную структуру.
   Конечно, вы можете сначала обработать данные любыми возможными способами на вашем главном языке, например для исключения всех комиссионных ниже значения .12
 
    while not end-ot-file (input) do
    begin
    readln (id_num, salesperson, loc, comm);
    if comm >=.12 then
    EXEC SQL INSERT INTO Salespeople
    VALUES (:id_num, :salesperson, :loc, :comm);
    end;
 
   Только строки которые встретят условие comm >=.12 будут вставлены в вывод. Это показывает что можно использовать и циклы и условия как нормальные для главного языка.
### ОБЪЯВЛЕНИЕ ПЕРЕМЕННЫХ
   Все переменные на которые имеется ссылка в предложениях SQL, должны сначала быть обьявлены в SQL DECLARE SECTION (РАЗДЕЛе ОБЪЯВЛЕНИЙ ), использующем обычный синтаксис главного языка. Вы можете иметь любое число таких разделов в программе, и они могут размещаться где-нибудь в коде перед используемой переменной, подчиненной ограничениям определенным в соответствии с главным языком. Раздел объявлений должен начинать и кончаться вложенными командами SQL - BEGIN DECLARE SECTION (Начало Раздела Объявлений ) и END DECLARE SECTION (Конец Раздела Объявлений ), которым предшествует, как обычно EXEC SQL (Выполнить).
   Чтобы обьявить переменные используемые в предыдущем примере, вы можете ввести следующее:
 
    EXEC SQL BEGIN DECLARE SECTION;
    Var
    id-num: integer;
    Salesperson: packed array (1 . .10) ot char;
    loc: packed array (1. .10) ot char;
    comm: real;
    EXEC SQL END DECLARE SECTION;
 
   Для незнакомых с ПАСКАЛем, i - это заголовок который предшествует ряду обьявляемых переменных, и упакованным (или распакованным ) массивам являющимися серией фиксированных переменных значений различаемых
   с помощью номеров( например, третий символ loc будет loc (3)). Использование точки с запятой после каждой переменной указывает на то что это - Паскаль, а не SQL.
### ИЗВЛЕЧЕНИЕ ЗНАЧЕНИЙ ПЕРЕМЕННЫХ
   Кроме помещения значений переменных в таблицы используя команды SQL, вы можете использовать SQL чтобы получать значения для этих переменных. Один из способов делать это - с помощью разновидности команды SELECT которая содержит предложение INTO. Давайте вернемся к нашему предыдущему примеру и переместим строку Peel из таблицы Продавцов в наши переменные главного языка.
 
    EXEC SQL SELECT snum, sname, city, comm
    INTO :id_num, :salesperson, :loc, :comm
    FROM Salespeople
    WHERE snum=1001;
 
   Выбранные значения помещаются в переменные с упорядоченными именами указанными в предложении INTO. Разумееется, переменные с именами указанными в предложении INTO должны иметь соответствующий тип чтобы принять эти значения, и должна быть своя переменная для каждого выбранного столбца. Если не учитывать присутствие предложения INTO, то этот запрос - похож на любой другой. Однако, предложение INTO добавляет значительное ограничение к запросу. Запрос должен извлекать не более одной строки. Если он извлекает много строк, все они не могут быть вставлены одновременно в одну и ту же переменную. Команда естественно потерпит неудачу. По этой причине, SELECT INTO должно использоваться только при следующих условиях:
   * когда вы используете предикат проверяющий значения, которое как вы знаете, могут быть уникальным, как в этом примере. Значения которые, как вы знаете, могут быть уникальными - это те значения которые имеют принудительное ограничение уникальности или уникальный индекс, как это говорилось в Главах 17 и 18.
   * когда вы используете одну или более агрегатных функций и не используете GROUP BY.
   * когда вы используете SELECT DISTINCT во внешнем ключе с предикатом ссылающимся на единственное значение родительского ключа (обеспечивая вашей системе предписание справочной целостность), как в следующем примере:
 
    EXEC SQL SELECT DISTINCT snum
    INTO :salesnum
    FROM Customers
    WHERE snum=
    (SELECT snum
    FROM Salespeople
    WHERE sname='Motika');
 
   Предпологалось что Salespeople.sname и Salespeople.snum - это соответственно, уникальный и первичный ключи этой таблицы, а Customers.snum - это внешний ключ ссылающийся на Salespeople.snum, и вы предполагали что этот запрос произведет единственную строку. Имеются другие случаи, когда вы можете знаете, что запрос должен произвести единственную строку вывода, но они мало известны и, в большинстве случаев, вы основываетесь на том что ваши данные имеют целостность, которая не может быть предписана с помощью ограничений. Не полагайтесь на это! Вы создаете программу которая, вероятно, будет использоваться в течение некоторого времени, и лучше всего проиграть ее чтобы быть гарантированным в будущем от возможных отказов. Во всяком случае, нет необходимости группировать запросы которые производут одиночные строки, поскольку SELECT INTO - используется только для удобства.
   Как вы увидите, вы можете использовать запросы выводящие многочисленные строки, используя курсор.
### КУРСОР
   Одна из сильных качеств SQL - это способность функционировать на всех строках таблицы, чтобы встретить определенное условие как блок запись, не зная сколько таких строк там может быть. Если десять строк удовлетворяют предикату, то запрос может вывести все десять строк. Если десять миллионов строк определены, все десять миллионов строк будут выведены. Это несколько затруднительно, когда вы попробуете связать это с другими языками. Как вы сможете назначать вывод запроса для переменных когда вы не знаете как велик будет вывод ? Решение состоит в том, чтобы использовать то, что называется - курсором. Вы вероятно знакомы с курсором, как с мигающей черточкой, которая отмечает вашу позицию на экране компьютера. Вы можете рассматривать SQL курсор как устройство, которое аналогично этому, отмечает ваше место в выводе запроса, хотя аналогия не полная.
   Курсор - это вид переменной, которая связана с запросом. Значением этой переменной может быть каждая строка, которая выводится при запросе. Подобно главным переменным, курсоры должны быть обьявлены прежде, чем они будут использованы. Это делается командой DECLARE CURSOR, следующим образом:
 
    EXEC SQL DECLARE CURSOR Londonsales FOR
    SELECT *
    FROM Salespeople
    WHERE city='London';
 
   Запрос не выполнится немедленно; он - только определяется. Курсор немного напоминает представление, в котором курсор содержит запрос, а содержание курсора - напоминает любой вывод запроса, каждый раз когда курсор становится открытым. Однако, в отличие от базовых таблиц или представлений, строки курсора упорядочены: имеются первая, вторая...
   ... и последняя строка курсора. Этот порядок может быть произвольным с явным управлением с помощью предложения ORDER BY в запросе, или же по умолчанию следовать какому-то упорядочению определяемому инструментально-определяемой схемой. Когда вы находите точку в вашей программе в которой вы хотите выполнить запрос, вы открываете курсор с помощью следующей команды:
 
    EXEC SQL OPEN CURSOR Londonsales;
 
   Значения в курсоре могут быть получены, когда вы выполняете именно эту команду, но не предыдущую команду DECLARE и не последующую команду FETСH. Затем, вы используете команду FETCH чтобы извлечь вывод из этого запроса, по одной строке в каждый момент времени.
 
    EXEC SQL FETCH Londonsales INTO :id_num,
    :salesperson, :loc, :comm;
 
   Это выражение переместит значения из первой выбраной строки, в переменные. Другая команда FETCH выводет следующий набор значений. Идея состоит в том, чтобы поместить команду FETCH внутрь цикла, так чтобы выбрав строку, вы могли переместив набор значений из этой строки в переменные, возвращались обратно в цикл чтобы переместить следующий набор значений в те же самые переменные. Например, возможно вам нужно чтобы вывод выдавался по одной строке, спрашивая каждый раз у пользователя, хочет ли он продолжить чтобы увидеть следующую строку
 
    Look_at_more:=True;
    EXEC SQL OPEN CURSOR Londonsales;
    while Look_at_more do
    begin
    EXEC SQL FETCH Londonsales
    INTO :id_num, :Salesperson, :loc, :comm;
    writeln (id_num, Salesperson, loc, comm);
    writeln ('Do you want to see more data? (Y/N)');
    readln (response);
    it response='N' then Look_at_more:=False
    end;
    EXEC SQL CLOSE CURSOR Londonsales;
 
   В Паскале, знак :=означает - "является назначенным значением из", в то время как=еще имеет обычное значение " равно ". Функция writeln записывает ее вывод, и затем переходит к новой строке. Одиночные кавычки вокруг символьных значений во втором writeln и в предложении if ... then - обычны для Паскаля, что случается при дубликатах в SQL.

В результате этого фрагмента, Булева переменная с именем Look_at_more должна быть установлена в состояние верно, открыт курсор, и введен цикл. Внутри цикла, строка выбирается из курсора и выводится на экран.
   У пользователя спрашивают, хочет ли он видеть следующую строку. Пока он не ответил N (Нет ), цикл повторяется, и следующая строка значений будет выбрана.
   Хотя переменные Look_at_more и ответ должны быть обьявлены как Булева переменная и символьная(char) переменная, соответственно, в разделе обьявлений переменных в Паскаля, они не должны быть включены в раздел обьявлений SQL, потому что они не используются в командах SQL.
   Как вы можете видеть, двоеточия перед именами переменных не используются для не-SQL операторов. Далее обратите внимание, что имеется оператор CLOSE CURSOR соответствующий оператору OPEN CURSOR. Он, как вы поняли, освобождает курсор значений, поэтому запрос будет нужно выполнить повторно с оператором OPEN CURSOR, прежде чем перейти в выбору следующих значений. Это необязательно для тех строк которые были выбраны запросом после закрытия курсора, хотя это и обычная процедура.
   Пока курсор закрыт, SQL не следит за тем, какие строки были выбраны.
   Если вы открываете курсор снова, запрос повторно выполняется с этой точки, и вы начинаете все сначала. Этот пример не обеспечивает автоматический выхода из цикла, когда все строки уже будут выбраны. Когда у FETCH нет больше строк которые надо извлекать, он просто не меняет значений в переменных предложения INTO. Следовательно, если данные исчерпались, эти переменные будут неоднократно выводиться с идентичными значениями, до тех пор пока пользователь не завершит цикл, введя ответ - N.
### SQL КОДЫ
   Хорошо было бы знать, когда данные будут исчерпаны, так чтобы можно было сообщить об этом пользователю и цикл завершился бы автоматически.
   Это - даже более важно чем например знать что команда SQL выполнена с ошибкой. Переменная SQLCODE (называемая еще SQLCOD в ФОРТРАНе ) предназначена чтобы обеспечить эту функцию. Она должна быть определена как переменная главного языка и должна иметь тип данных который в главном языке соответствует одному из точных числовых типов SQL, как это показано в Приложении B. Значение SQLCODE устанавливается каждый раз, когда выполняется команда SQL. В основном существуют три возможности:
   Команда выполнилась без ошибки, но не произвела никакого действия.
   * Для различных команд это выглядит по разному: Для SELECT, ни одна строка не выбрана запросом.
   * Для FETCH, последняя строка уже была выбрана, или ни одной строки не выбрано запросом в курсоре.
   * Для INSERT, ни одной строки не было вставлено (подразумевается что запрос использовался чтобы сгенерировать значения для вставки, и был отвергнут при попытке извлечения любой строки.
   * Для UPDATE и DELETE, ни одна строка не ответила условию предиката, и следовательно никаких изменений сделано в таблице не будет.
   * В любом случае, будет установлен код SQLCODE=100.
   * Команда выполнилась нормально, не удовлетворив ни одному из выше указанных условий. В этом случае, будет установлен код SQLCOD=0.
   * Команда сгенерировала ошибку. Если это случилось, изменения сделанные к базе данных текущей транзакцией, будут восстановлены( см. Главу 23). В этом случае будет установлен код SQLCODE= некоторому отрицательному числу, определяемому проектировщиком. Задача этого числа, идентифицировать проблему, так точно насколько это возможно. В принципе, ваша система должна быть снабжена подпрограммой, которая в этом случае, должна выполниться чтобы выдать для вас информацию расшифровывающее значение негативного числа определенного вашим проектировщиком. В этом случае некоторое сообщение об ошибке будет выведено на экран или записано в файл протокола, а программа в это время выполнит восстановление изменений для текущей транзакции, отключится от базы данных и выйдет из нее. Теперь мы можем усовершенствовать
 
### ИСПОЛЬЗОВАНИЕ SQLCODE ДЛЯ УПРАВЛЕНИЯ ЦИКЛАМИ
   Наш предыдущий пример для выхода из цикла автоматически, при условии что курсор пуст, все строки выбраны, или произошла ошибка:
 
    Look_at_more:=lhe;
    EXEC SQL OPEN CURSOR Londonsales;
    while Look_at_more
    and SQLCODE=O do
    begin
    EXEC SQL FETCH London$ales
    INTO :id_num, :Salesperson, :loc, :comm;
    writeln (id_num, Salesperson, loc, comm);
    writeln ('Do you want to see more data? (Y/N)');
    readln (response);
    If response='N' then Look_at_more:=Fabe;
    end;
    EXEC SQL CLOSE CURSOR Londonsales;
 
### ПРЕДЛОЖЕНИЕ WHENEVER
   Это удобно для выхода при выполненом условии - все строки выбраны.
   Но если вы получили ошибку, вы должны предпринять нечто такое, что описано для третьего случая, выше. Для этой цели, SQL предоставляет предложение GOTO. Фактически, SQL позволяет вам применять его достаточно широко, так что программа может выполнить команду GOTO автоматически, если будет произведено определенное значение SQLCODE. Вы можете сделать это соввместно с предложением WHENEVER. Имеется кусгок из примера для этого случая:
 
    EXEC SQL WHENEVER SQLERROR GOTO Error_handler;
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
 
   SQLERROR- это другой способ сообщить что SQLCODE < 0; а NOT FOUND - это другой способ сообщить что SQLCODE=100. (Некоторые реализации называют последний случай еще как - SQLWARNING.) Error_handler - это имя того места в программе в которое будет перенесено выполнение программы если произошла ошибка (GOTO может состоять из одного или двух слов). Такое место определяется любым способом соответствующим для главного языка, например, с помощью метки в Паскале, или имени раздела или имени параграфа в КОБОЛЕ (в дальнейшем мы будем использовать термин - метка). Метка более удачно идентифицирует стандартную процедуру распространяемую проектировщиком для включения во все программы.
   CONTINUE не делает чего-то специального для значения SQLCODE. Оно также является значением по умолчанию. если вы не используете команду WHENEVER, определяющую значение SQLCODE. Однако, эти неактивные определения дают вам возможность переключаться вперед и назад, выполняя и не выполняя действия, в различных точках(метках) вашей программы. Например, если ваша программа включает в себя несколько команд INSERT, использующих запросы, которые реально должны производить значения, вы могли бы напечатать специальное сообщение или сделать что-то такое, что поясняло бы, что запросы возвращаются пустыми и никакие значения не были вставлены. В этом случае, вы можете ввести следующее:
 
    EXEC SQL WHENEVER NOT FOUND GOTO No_rows;
 
   No_rows - это метка в некотором коде, содержащем определенное действие. С другой стороны, если вам нужно сделать выборку в программе позже, вы можете ввести следующее в этой точке,
 
    EXEC SQL WHENEVER NOT FOUND CONTINUE;
 
   что бы выполнение выборки повторялось до тех пор пока все строки не будут извлечены, что является нормальной процедурой не требующей специальной обработки.
### МОДИФИЦИРОВАНИЕ КУРСОРОВ
   Курсоры могут также быть использованы, чтобы выбирать группу строк из таблицы, которые могут быть затем модифицированы или удалены одна за другой. Это дает вам возможность, обходить некоторые ограничения предикатов используемых в командах UPDATE и DELETE. Вы можете ссылаться на таблицу задействованную в предикате запроса курсора или любом из его подзапросов, которые вы не можете выполнить в предикатах самих этих команд. Как подчеркнуто в Главе 16, стандарт SQL отклоняет попытку удалить всех пользователей с рейтингом ниже среднего, в следующей форме:
 
       EXEC SQL DELETE FROM Customers
   WHERE rating <
   ( SELECT AVG (rating)
   FROM Customers);
 
   Однако, вы можете получить тот же эффект, используя запрос для выбора соответствующих строк, запомнив их в курсоре, и выполнив DELETE с использованием курсора. Сначала вы должны обьявить курсор:
 
    EXEC SQL DECLARE Belowavg CURSOR FOR
    SELECT *
    FROM Customers
    WHERE rating <
    (SELECT AVG (rating)
    FROM Customers);
 
   Затем вы должны создать цикл, чтобы удалить всех заказчиков выбранных курсором:
 
    EXEC SQL WHENEVER SQLERROR GOTO Error_handler;
    EXEC SQL OPEN CURSOR Belowavg;
    while not SOLCODE=100 do
    begin
    EXEC SOL FETCH Belowavg INTO :a, :b, :c, :d, :e;
    EXEC SOL DELETE FROM Customers
    WHERE CURRENT OF Belowavg;
    end;
    EXEC SOL CLOSE CURSOR Belowavg;
 
   Предложение WHERE CURRENT OF означает что DELETE применяется к строке которая в настоящее время выбрана курсором. Здесь подразумевается, что и курсор и команда DELETE, ссылаются на одну и ту же таблицу, и следовательно, что запрос в курсоре - это не обьединение.
   Курсор должен также быть модифицируемым. Являясь модифицируемым, курсор должен удовлетворять тем же условиям что и представления (см. Главу 21). Кроме того, ORDER BY и UNION, которые не разрешены в представлениях, в курсорах - разрешаются, но предохраняют курсор от модифицируемости. Обратите внимание в вышеупомянутом примере, что мы должны выбирать строки из курсора в набор переменных, даже если мы не собирались использовать эти переменные. Этого требует синтаксис команды FETCH. UPDATE работает так же. Вы можете увеличить значение комиссионных всем продавцам, которые имеют заказчиков с оценкой=300, следующим способом. Сначала вы обьявляете курсор:
 
    EXEC SOL DECLARE CURSOR High_Cust AS
    SELECT *
    FROM Salespeople
    WHERE snum IN
    (SELECT snum
    FROM Customers
    WHERE rating=300);
 
   Затем вы выполняете модификации в цикле:
 
    EXEC SQL OPEN CURSOR High_cust;
    while SQLCODE=0 do
    begin
    EXEC SOL FETCH High_cust
    INTO :id_num, :salesperson, :loc, :comm;
    EXEC SQL UPDATE Salespeople
    SET comm=comm + .01
    WHERE CURRENT OF High_cust;
    end;
    EXEC SQL CLOSE CURSOR High_cust;
 
   Обратите внимание: что некоторые реализации требуют, чтобы вы указывали в определении курсора, что курсор будет использоваться для выполнения команды UPDATE на определенных столбцах. Это делается с помощью заключительной фразы определения курсора - FOR UPDATE <column list>.
   Чтобы обьявить курсор High_cust таким способом, так чтобы вы могли модифицировать командой UPDATE столбец comm, вы должны ввести следующее предложение:
 
    EXEC SQL DECLARE CURSOR High_Cust AS
    SELECT *
    FROM Salespeople
    WHERE snum IN
    (SELECT snum
    FROM Customers
    WHERE rating=300)
    FOR UPDATE OF comm;
 
   Это обеспечит вас определенной защитой от случайных модификаций, которые могут разрушить весь порядок в базе данных.
### ПЕРЕМЕННАЯ INDICATOR
   Пустые (NULLS) значения - это специальные маркеры определяемые самой SQL. Они не могут помещаться в главные переменные. Попытка вставить NULL значения в главнуюпеременную будет некорректна, так как главные языки не поддерживают NULL значений в SQL, по определению. Хотя результат при попытке вставить NULL значение в главную переменную определяет проектировщик, этот результат не должен ротиворечить теории базы данных, и поэтому обязан произвести ошибку: код SQLCODE ввиде отрицательного числа, и вызвать подпрограмму управления ошибкой. Естеcтвенно вам нужно этого избежать. Поэтому, вы можете выбрать NULL значения с допустимыми значениями, не приводящими к разрушению вашей программы. Даже если программа и не разрушится, значения в главных переменных станут неправильными, потому что они не могут иметь NULL значений. Альтернативным методом предоставляемым для этой ситуацией является - функция переменной indicator(указатель). Переменная indicator - обьявленная в разделе объявлений SQL напоминает другие переменные. Она может иметь тип главного языка который соответствует числовому типу в SQL. Всякий раз, когда вы выполняете операцию, которая должна поместить NULL значение в переменную главного языка, вы должны использовать переменную indicator, для надежности. Вы помещаете переменную indicator в команду SQL непосредственно после переменной главного языка которую вы хотите защитить, без каких-либо пробелов или запятых, хотя вы и можете, при желании, вставить слово - INDICATOR. Переменной indicator в команде, изначально присваивается значение 0. Однако, если производится значение NULL, переменная indicator становится равной отрицательному числу. Вы можете проверить значение переменной indicator, чтобы узнать, было ли найдено значение NULL. Давайте предположим, что поля city и comm, таблицы Продавцов, не имеют ограничения NOT NULL, и что мы объявили вразделе обьявлений SQL, две ПАСКАЛЬевские переменные

целого типа, i_a и i_b. (Нет ничего такого в разделеобьявлений, что могло бы представить их как переменные indicator. Они станут переменными indicator, когда будут использоваться как переменные indicator. )
   Имеется одна возможность:
 
    EXEC SQL OPEN CURSOR High_cust;
    while SQLCODE=O do
    begin
    EXEC SQL FETCH High_cust
    INTO :id_num, :salesperson,
    :loc:i_a, :commINDlCATOR:i_b;
    If i_a >=O and i_b >=O then
    {no NULLs produced}
    EXEC SQL UPDATE Salespeople
    SET comm=comm + .01
    WHERE CURRENT OF Hlgh_cust;
    else
    {one or both NULL}
    begin
    If i_a < O then
    writeln ('salesperson ', id_num, ' has no city');
    If i_b < O then
    writeln ('salesperson ', id_num, ' has no
    commission');
    end;
    {else}
    end; {while}
    EXEC SQL CLOSE CURSOR High_cust;
 
   Как вы видите, мы включили, ключевое слово INDICATOR в одном случае, и исключили его в другом случае, чтобы показать, что эффект будет одинаковым в любом случае. Каждая строка будет выбрана, но команда UPDATE выполнится только если NULL значения не будут обнаружены. Если будут обнаружены NULL значения, выполнится еще одна часть программы, которая распечатает предупреждающее сообщение, где было найдено каждое NULL значение.
   Обратите внимание: переменные indicator должны проверяться в главном языке, как указывалось выше, а не в предложении WHERE команды SQL. Последнее в принципе не запрещено, но результат часто бывает непредвиденным.
### ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННОЙ INDICATOR ДЛЯ ЭМУЛЯЦИИ NULL ЗНАЧЕНИЙ SQL
   Другая возможность состоит в том, чтобы обрабатывать переменную indicator, связывая ее с каждой переменной главного языка, специальным способом, эмулирующим поведение NULL значений SQL.
   сякий раз, когда вы используете одно из этих значений в вашей программе, например в предложении if ... then, вы можете сначала проверить связанную переменную indicator, является ли ее значение=NULL. Если это так, то вы обрабатываете переменную по-другому. Например, если NULL значение было извлечено из поля city для главной переменной city, которая связана с переменной indicator - i_city, вы должны установить значение city равное последовательности пробелов. Это будет необходимо, только если вы будете распечатывать его на принтере; его значение не должно отличаться от логики вашей программы. Естественно, i_city автоматически установливается в отрицательное значение. Предположим, что вы имели следующую конструкцию в вашей программе:
 
    If sity='London' then
    comm:=comm + .01
    else comm:=comm - .01
 
   Любое значение, вводимое в переменную city, или будет равно "London" или не будет равно. Следовательно, в каждом случае значение комиссионных будет либо увеличино либо уменьшено. Однако, эквивалентные команды в SQL выполняются по разному:
 
    EXEC SQL UPDATE Salespeople
    SET comm=comm + .01
    WHERE sity='London';
    и
    EXEC SQL UPDATE Salespeople
    SET comm=comm .01;
    WHERE sity < > 'London';
 
   ( Вариант на ПАСКАЛе работает только с единственным значением, в то время как вариант на SQL работает со всеми таблицами. ) Если значение city в варианте на SQL будет равно значению NULL, оба предиката будут неизвестны, и значение comm, следовательно, не будет изменено в любом случае.
   Вы можете использовать переменную indicator чтобы сделать поведение вашего главного языка непротиворечащим этому, с помощью создания условия, которое исключает NULL значения:
 
    If i_city >=O then
    begin
    If city='London' then
    comm:=comm + .01
    else comm:=comm - .01;
    end;
    {begin and end нужны здесь только для понимания}
    --------------------------------------------------------------
    ПРИМЕЧАНИЕ: Последняя строка этого примера содержит ремарку -
    { begin и end необходимы только для понимания }
    --------------------------------------------------------------
 
   В более сложной программ, вы можете захотеть установить Булеву переменную в "верно", чтобы указать что значение city=NULL. Затем вы можете просто проверять эту переменную всякий раз, когда вам это необходимо.
### ДРУГОЕ ИСПОЛЬЗОВАНИЕ ПЕРЕМЕННОЙ INDICATOR
   Переменная indicator также может использоваться для назначения значения NULL. Просто добавьте ее к имени главной переменной в команде UPDATE или INSERT тем же способом что и в команде SELECT. Если переменная indicator имеет отрицательное значение, значение NULL будет помещено в поле. Например, следующая команда помещает значения NULL в поля city и comm, таблицы Продавцов, всякий раз, когда переменные indicator - i_a или i_b будут отрицательными; в противном случае она помещает туда значения главных переменных:
 
    EXEC SQL INSERT INTO Salespeople
    VALUES (:Id_num, :salesperson, :loc:i_a, :comm:i_b);
 
   Переменная indicator используется также, чтобы показывать отбрасываемую строку. Это произойдет если вы вставляете значения символов SQL в главную переменную которая не достаточно длинна чтобы вместить все символы. Это особая проблема с нестандартным типами данных - VARCHAR и LONG (смотри Приложению C). В этом случае, переменная будет заполнена первыми символами строки, а последние символы будут потеряны. Если используется переменная indicator, она будет установлена в положительное значение, указывающее на длину отбрасываемой части строки, позволяя таким образом вам узнать, сколько символов было потеряно.
   В этом случае, Вы можете проверить с помощью просмотра -значение переменной indicator > 0, или < 0.
### РЕЗЮМЕ
   Команды SQL вкладываются в процедурные языках, чтобы объединить силы двух подходов. Некоторые дополнительные средства SQL необходимы, чтобы выполнить эту работу. Вложенные команды SQL транслируемые программой, называемой прекомпилятором, в форму пригодную для использования транслятором главного языка, и используемые в этом главном языке, как вызовы процедуры к подпрограммам которые создает прекомпилятор, называются - модулями доступа. ANSI поддерживает вложение SQL в языки: ПАСКАЛЬ, ФОРТРАН, КОБОЛ, и PL/I. Другие языки также используются, особенно Си. В попытке кратко описать вложенный SQL, имеются наиболее важные места в этой главе:
   * Все вложенные команды SQL начинаются словами EXEC SQL и заканчиваются способом который зависит от используемого главного языка.
   * Все главные переменные доступные в командах SQL, должны быть обьявлены в разделе объявлений SQL прежде, чем они будут использованы.
   * Всем главным переменным должно предшествовать двоеточие когда они используются в команде SQL.
   * Запросы могут сохранять свой вывод непосредственно в главных переменных, используя предложение INTO, если и только если, они выбирают единственную строку.
   * Курсоры могут использоваться для сохранения вывода запроса, и доступа к одной строке в каждый момент времени. Курсоры бывают обьявлеными (если определяют запрос в котором будут содержаться), открытыми(если выполняют запрос ), и закрытыми (если удаляют вывод запроса из курсора). Если курсор открыт, команда FETCH, используется чтобы перемещать его по очереди к каждой строке вывода запроса.
   * Курсоры являются модифицируемыми или только-чтение. Чтобы стать модифицируемым, курсор должен удовлетворять всем критериям которым удовлетворяет просмотр; кроме того, он не должен использовать предложений ORDER BY или UNION, которые в любом случае не могут использоваться просмотрами. Не модифицируемый курсор является курсором только-чтение.
   * Если курсор модифицируемый, он может использоваться для определения, какие строки задействованы вложенными командами UPDATE и DELETE через предложение WHERE CURRENT OF. DELETE или UPDATE должны быть вне той таблицы к которой курсор обращается в запросе.
   * SQLCODE должен быть обьявлен как переменная числового типа для каждой программы которая будет использовать вложенный SQL. Его значение установливается автоматически после выполнения каждой команды SQL.
   * Если команда SQL выполнена как обычно, но не произвела вывода или ожидаемого изменения в базе данных, SQLCODE=100. Если команда произвела ошибку, SQLCODE будет равняться некоторому аппаратноопределенному отрицательному числу которое описывает ошибку. В противном случае, SQLCODE=0.
   * Предложение WHENEVER может использоваться для определения действия которое нужно предпринять когда SQLCODE=100 (не найдено) или когда SQLCODE равен отрицательному числу (SQLERROR). Действием может быть или переход к некоторой определенной метке в программе (GOTO <label> ) или отсутствие какого-либо действия вообще( продолжить). Последнее, установлено по умолчанию.
   * Числовые переменные могут также использоваться как переменные indicator. Переменные indicator следуют за другим именами переменных в команде SQL, без каких бы то ни было посторонних символов кроме (необязательного) слова INDICATOR.
   * Обычно, значение переменной indicator=0. Если команда SQL пытается поместить NULL значение в главную переменную которая использует indicator, indicator будет установлен в отрицательное значение. Этот факт можно использоваться чтобы предотвращать ошибки, и для помечания NULL значений SQL для специальной обработки их в главной программе.
   * Переменная indicator может использоваться для вставки NULL значений в команды SQL - INSERT или UPDATE. Она также может принимать положительное значение указывающее на длинну отбрасываемой части строки не поместившейся в предельные границы какойнибудь переменной, куда эта строка помещалась.
 
### РАБОТА С SQL
   Обратите внимание: Ответы для этих упражнений написаны в псевдокодах, являющихся английским языком описания логики, которой должна следовать программа. Это сделано для того чтобы помомочь читателям которые могут быть незнакомы с Паскалем(или любым другим языком). Кроме того это лучше сфокусирует ваше внимание на включемых понятиях, опуская частности того или другого языка. Чтобы непротиворечить нашим примерам, стиль псевдокода будет напоминать Паскаль.
   Мы опустим из программ все что не относится напрямую к рассматриваемым вопросам, например, определение устройств ввода-вывода, подключение к базе данных, и так далее. Конечно, имеется много способов чтобы выполнять такие упражнения; и совсем не обязательно что представленые варианты решений являются самыми удачными.
   * Разработайте простую программу которая выберет все комбинации полей snum и cnum из таблиц Порядков и Заказчиков и выясните, всегда ли предыдущая комбинация такая же как последующая. Если комбинация из таблицы Порядков не найдена в таблице Заказчиков, значение поля snum для этой строки будет изменено на удовлетворяющее условию совпадения. Вы должны помнить, что курсор с подзапросом - модифицируем (ANSI ограничение, также применимо к просмотрам, и что базисная целостность базы данных это не тоже самое что проверка на ошибку(т.е. первичные ключи уникальны, все поля cnums в таблице Порядков правильны, и так далее). Проверьте раздел обьявлений, и убедитесь что там обьявлены все используемые курсоры.
   * Предположим, что ваша программа предписывает ANSI запрещение курсоры или просмотры использующие модифицируемые подзапросы. Как вы должны изменить вышеупомянутую программу?

   * Разработайте программу которая подсказывает пользователям изменить значения поля city продавца, автоматически увеличивает комиссионные на .01 для продавца переводимого в Барселону и уменьшает их на .01 для продавца переводимого в Сан Хосе. Кроме того, продавец находящийся в Лондоне должен потерять .02 из своих комиссионных, независимо от того меняет он город или нет, в то время как продавец не находящийся в Лондоне должен иметь увеличение комиссионных на .02. Изменение в комиссионных основывающееся на нахождении продавца в Лондоне, может применяться независимо от того куда тот переводится. Выясните могут ли поле city или поле comm содержать NULL значения, и обработайте их, как это делается в SQL. Предупреждение! : эта программа имеет некоторые сокращения.
