## Глава 9. ОБЪЕДИНЕНИЕ ТАБЛИЦЫ С СОБОЙ
 
   В ГЛАВЕ 8, МЫ ПОКАЗАЛИ ВАМ КАК ОБЪЕДИНЯТЬ ДВЕ или более таблиц вместе.
   Достаточно интересно то, что та же самая методика может использоваться чтобы объединять вместе две копии одиночной таблицы. В этой главе, мы будем исследовать этот процесс. Как вы видете, объединение таблицы с самой собой, далеко не простая вещь, и может быть очень полезным способом определять определенные виды связей между пунктами данных в конкретной таблице.
 
### КАК ДЕЛАТЬ ОБЪЕДИНЕНИЕ ТАБЛИЦЫ С СОБОЙ?
   Для объединения таблицы с собой, вы можете сделать каждую строку таблицы, одновременно, и комбинацией ее с собой и комбинацией с каждой другой строкой таблицы. Вы затем оцениваете каждую комбинацию в терминах предиката, также как в обьединениях мультитаблиц. Это позволит вам легко создавать определенные виды связей между различными позициями внутри одиночной таблицы - с помощью обнаружения пар строк со значением поля, например.
   Вы можете изобразить обьединение таблицы с собой, как обьединение двух копий одной и той же таблицы. Таблица на самом деле не копируется, но SQL выполняет команду так, как если бы это было сделано. Другими словами, это обьединение - такое же, как и любое другое обьединение между двумя таблицами, за исключением того, что в данном случае обе таблицы идентичны.
### ПСЕВДОНИМЫ
   Синтаксис команды для объединения таблицы с собой, тот же что и для объединения многочисленых таблиц, в одном экземпляре. Когда вы объединяете таблицу с собой, все повторяемые имена столбца, заполняются префиксами имени таблицы. Чтобы ссылаться к этим столбцам внутри запроса, вы должны иметь два различных имени для этой таблицы.
   Вы можете сделать это с помощью определения временных имен называемых переменными диапазона, переменными корреляции или просто - псевдонимами. Вы определяете их в предложении FROM запроса. Это очень просто: вы набираете имя таблицы, оставляете пробел, и затем набираете псевдоним для нее. Имеется пример который находит все пары заказчиков имеющих один и тот же самый рейтинг (вывод показывается в Таблице 9.1):
 
SQL Execution Log

    SELECT first.cname, second.cname, first.rating
    FROM Customers first, Customers second
    WHERE first.rating=second.rating;
 
|    Giovanni                              |    Giovanni                              |    200                                   |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    Giovanni<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |
|    Liu<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |
|    Liu<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |
|    Grass<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |
|    Grass<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |
|    Clemens<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |
|    Clemens<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |
|    Clemens<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |
|    Cisneros<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |
|    Cisneros<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |
|    Pereira<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |
|    Pereira<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |
|    Pereira<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |


   Таблица 9.1: Объединение таблицы с собой
 
   (обратите внимание что в Таблице 9.1, как и в некоторых дальнейших примерах, полный запрос не может уместиться в окне вывода, и следовательно будет усекаться.)
   В вышеупомянутой команде, SQL ведет себя так, как если бы он соединял две таблицы называемые 'первая' и 'вторая'. Обе они - фактически, таблицы Заказчика, но псевдонимы разрешают им быть обработаными независимо. Псевдонимы первый и второй были установлены в предложении FROM запроса, сразу после имени копии таблицы. Обратите внимание что псевдонимы могут использоваться в предложении SELECT, даже если они не определены в предложении FROM.
   Это - очень хорошо. SQL будет сначала допускать любые такие псевдонимы на веру, но будет отклонять команду если они не определены далее в предложении FROM запроса.
   Псевдоним существует - только пока команда выполняется ! Когда запрос заканчивается, псевдонимы используемые в нем больше не имеют никакого значения.
   Теперь, когда имеются две копии таблицы Заказчиков, чтобы работать с ними, SQL может обрабатывать эту операцию точно также как и любое другое обьединение - берет каждую строку из одного псевдонима и сравнивает ее с каждой строкой из другого псевдонима.
### УСТРАНЕНИЕ ИЗБЫТОЧНОСТИ
   Обратите внимание что наш вывод имеет два значение для каждой комбинации, причем второй раз в обратном порядке. Это потому, что каждое значение показано первый раз в каждом псевдониме, и второй раз( симметрично) в предикате. Следовательно, значение A в псевдониме сначала выбирается в комбинации со значением B во втором псевдониме, а затем значение A во втором псевдониме выбирается в комбинации со значением B в первом псевдониме. В нашем примере, Hoffman выбрался вместе с Clemens, а затем Clemens выбрался вместе с Hoffman. Тот же самый случай с Cisneros и Grass, Liu и Giovanni, и так далее. Кроме того каждая строка была сравнена сама с собой, чтобы вывести строки такие как - Liu и Liu. Простой способ избежать этого состoит в том, чтобы налагать порядок на два значения, так чтобы один мог быть меньше чем другой или предшествовал ему в алфавитном порядке. Это делает предикат ассиметричным, поэтому те же самые значения в обратном порядке не будут выбраны снова, например:
 
    SELECT tirst.cname, second.cname, first.rating
    FROM Customers first, Customers second
    WHERE first.rating=second.rating
    AND first.cname < second.cname;
 
   Вывод этого запроса показывается в Таблице 9.2.
 
   Hoffman предшествует Periera в алфавитном порядке, поэтому комбинация удовлетворяет обеим условиям предиката и появляется в выводе. Когда та же самая комбинация появляется в обратном порядке - когда Periera в псевдониме первой таблицы сравнтвается с Hoffman во второй таблице псевдонима - второе условие не встречается. Аналогично Hoffman не выбирается при наличии того же рейтинга что и он сам потому что его имя не предшествует ему самому в алфавитном порядке. Если бы вы захотели
 
SQL Execution Log

    SELECT first.cname, second.cname, first.rating FROM Customers first, Customers second
    WHERE first.rating=second.rating
    AND first.cname < second.cname
    
|    cname                                 |    cname                                 |    rating                                |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    Hoffman<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |
|    Giovanni<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |
|    Clemens<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |

  Таблица 9.2: Устранение избыточности вывода в обьединении с собой.
 
   включить сравнение строк с ними же в запросах подобно этому, вы
   могли бы просто использовать <=вместо <.
### ПРОВЕРКА ОШИБОК
   Таким образом мы можем использовать эту особенность SQL для проверки определенных видов ошибок. При просмотре таблицы Порядков, вы можете видеть что поля cnum и snum должны иметь постоянную связь. Так как каждый заказчик должен быть назначен к одному и только одному продавцу, каждый раз когда определенный номер заказчика появляется в таблице Порядков, он должен совпадать с таким же номером продавца. Следующая команда будет определять любые несогласованности в этой области:
 
    SELECT first.onum, tirst.cnum, first.snum,
    second.onum, second.cnum,second.snum
    FROM Orders first, Orders second
    WHERE first.cnum=second.cnum
    AND first.snum < > second.snum;
 
   Хотя это выглядит сложно, логика этой команды достаточно проста. Она будет брать первую строку таблицы Порядков, запоминать ее под первым псевдонимом, и проверять ее в комбинации с каждой строкой таблицы Порядков под вторым псевдонимом, одну за другой. Если комбинация строк удовлетворяет предикату, она выбирается для вывода. В этом случае предикат будет рассматривать эту строку, найдет строку где поле cnum=2008 а поле snum=1007, и затем рассмотрит каждую следующую строку с тем же самым значением поля cnum. Если он находит что какая -то из их имеет значение отличное от значения поля snum, предикат будет верен, и выведет выбранные поля из текущей комбинации строк. Если же значение snum с данным значением cnum в наш таблице совпадает, эта команда не произведет никакого вывода.
### БОЛЬШЕ ПСЕВДОНИМОВ
   Хотя обьединение таблицы с собой - это первая ситуация когда понятно что псевдонимы необходимы, вы не ограничены в их использовании что бы только отличать копию одлной таблицы от ее оригинала. Вы можете использовать псевдонимы в любое время когда вы хотите создать альтернативные имена для ваших таблиц в команде. Например, если ваши таблицы имеют очень длинные и сложные имена, вы могли бы определить простые односимвольные псевдонимы, типа a и b, и использовать их вместо имен таблицы в предложении SELECT и предикате. Они будут также использоваться с соотнесенными подзапросами(обсуждаемыми в Главе 11).
### ЕЩЕ БОЛЬШЕ КОМПЛЕКСНЫХ ОБЪЕДИНЕНИЙ
   Вы можете использовать любое число псевдонимов для одной таблицы в запросе, хотя использование более двух в данном предложении SELECT * будет излишеством. Предположим что вы еще не назначили ваших заказчиков к вашему продавцу. Компании должна назначить каждому продавцу первоначально трех заказчиков, по одному для каждого рейтингового значения. Вы лично можете решить какого заказчика какому продавцу назначить, но следующий запрос вы используете чтобы увидеть все возможные комбинации заказчиков которых вы можете назначать. (Вывод показывается в Таблице 9.3 ):
 
SQL Execution Log

    SELECT a.cnum, b.cnum, c.cnum
    FROM Customers a, Customers b, Customers c
    WHERE a.rating=100
    AND b.rating=200
    AND c.rating=300;
    AND c.rating=300;
    
|    cnum                                  |    cnum                                  |    cnum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |
|    2001<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |
|    2001<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |
|    2001<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |

 Таблица 9.3 Комбинация пользователей с различными значениями рейтинга
   Как вы можете видеть, этот запрос находит все комбинации заказчиков с тремя значениями оценки, поэтому первый столбец состоит из заказчиков с оценкой 100, второй с 200, и последний с оценкой 300. Они повторяются во всех возможных комбинациях. Это - сортировка группировки которая не может быть выполнена с GROUP BY или ORDER BY, поскольку они сравнивают значения только в одном столбце вывода.
   Вы должны также понимать, что не всегда обязательно использовать каждый псевдоним или таблицу которые упомянуты в предложении FROM запроса, в предложении SELECT. Иногда, предложение или таблица становятся запрашиваемыми исключительно потому что они могут вызываться в предикате запроса. Например, следующий запрос находит всех заказчиков размещенных в городах где продавец Serres (snum 1002 ) имеет заказиков (вывод показывается в Таблице 9.4 ):
 
    SELECT b.cnum, b.cname
    FROM Customers a, Customers b
    WHERE a.snum=1002
    AND b.city=a.city;
 
SQL Execution Log
 
    SELECT b.cnum, b.cname
    FROM Customers a, Customers b
    WHERE a.snum=1002 AND b.city=a.city;
    
|    cnum                                  |    cname                                 |
|------------------------------------------|------------------------------------------|
|    2003<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |

Таблица 9.4 Нахождение заказчиков в городах относящихся к Serres.
   Псевдоним a будет делать предикат неверным за исключением случая когда его значение столбца snum= 1002. Таким образом псевдоним опускает все, кроме заказчиков продавца Serres. Псевдоним b будет верным для всех строк с тем же самым значением города что и текущее значение города для a; в ходе запроса, строка псевдонима b будет верна один раз когда значение города представлено в a. Нахождение этих строк псевдонима b - единственая цель псевдонима a, поэтоиму мы не выбираем все столбцы подряд. Как вы можете видеть, собственные заказчики Serres вы бираются при нахождении их в том же самом городе что и он сам, поэтому выбор их из псевдонима a необязателен. Короче говоря, псевдоним назходит строки заказчиков Serres, Liu и Grass. Псевдоним b находит всех заказчиков размещенных в любом из их городов (San Jose и Berlin соответственно ) включая, конечно, самих - Liu и Grass.
   Вы можете также создать обьединение которое включает и различные таблицы и псевдонимы одиночной таблицы. Следующий запрос объединяет таблицу Пользователей с собой: чтобы найти все пары заказчиков обслуживаемых одним продавцом. В то же самое время, этот запрос объединяетзаказчика с таблицей Продавцов с именем этого продавца (вывод показан в Таблице 9.5 ):
 
    SELECT sname, Salespeople.snum, first.cname
    second.cname
    FROM Customers first, Customers second, Salespeople
    WHERE first.snum=second.snum
    AND Salespeople.snum=first.snum
    AND first.cnum < second.cnum;
 
SQL Execution Log

    SELECT cname, Salespeople.snum, first.cname second.cname
    FROM Customers first, Customers second, Salespeople
    WHERE first.snum=second.snum AND Salespeople.snum=first.snum
    AND first.cnum < second.cnum;

|    cname                                 |    snum                                  |    cname                                 |    cname                                 |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    Serres<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |
|    Peel<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |

   Таблица 9.5: Объединение таблицы с собой и с другой таблицей
### РЕЗЮМЕ
   Теперь Вы понимаете возможности объединения и можете использовать их для ограничения связей с таблицей, между различными таблицами, или в обоих случаях. Вы могли видеть некоторые возможности объединения при использовании его способностей. Вы теперь познакомились с терминами порядковые переменные, корреляционные переменные и предложения (эта терминология будет меняться от изделия к изделию, так что мы предлагаем Вам познакомится со всеми тремя терминами). Кроме того Вы поняли, немного, как в действительности работают запросы.
   Следующим шагом после комбинации многочисленых таблиц или многочисленых копий одной таблицы в запросе, будет комбинация многочисленных запросов, где один запрос будет производить вывод который будет затем управлять работой другого запроса. Это другое мощное средство SQL, о котором мы расскажем в Главе 10 и более тщательно в последующих главах.
 
### РАБОТА С SQL
   * Напишите запрос который бы вывел все пары продавцов живущих в одном и том же городе. Исключите комбинации продавцов с ними же, а также дубликаты строк выводимых в обратным порядке.
   * Напишите запрос который вывел бы все пары порядков по данным заказчикам, именам этих заказчиков, и исключал дубликаты из вывода, как в предыдущем вопросе.
   * Напишите запрос который вывел бы имена(cname) и города(city) всех заказчиков с такой же оценкой(rating) как у Hoffmanа. Напишите запрос использующий поле cnum Hoffmanа а не его оценку, так чтобы оно могло быть использовано если его оценка вдруг изменится.
   
## Глава 10. ВСТАВКА ОДНОГО ЗАПРОСА ВНУТРЬ ДРУГОГО
 
   В КОНЕЦ ГЛАВЫ 9, МЫ ГОВОРИЛИ ЧТО ЗАПРОСЫ могут управлять другими запросами. В этой главе, вы узнаете как это делается (большей частью), помещая запрос внутрь предиката другого запроса, и используя вывод внутреннего запроса в верном или неверном условии предиката. Вы сможете выяснить какие виды операторов могут использовать подзапросы и посмотреть как подзапросы работают со средствами SQL, такими как DISTINCT, с составными функциями и выводимыми выражения. Вы узнаете как использовать подзапросы с предложением HAVING и получите некоторые наставления как правильно использовать подзапросы.
 
### КАК РАБОТАЕТ ПОДЗАПРОС?
   С помощью SQL вы можете вкладывать запросы внутрь друга друга. Обычно, внутренний запрос генерирует значение которое проверяется в предикате внешнего запроса, определяющего верно оно или нет. Например, предположим что мы знаем имя продавца: Motika, но не знаем значение его поля snum, и хотим извлечь все порядки из таблицы Порядков. Имеется один способ чтобы сделать это( вывод показывается в Таблице 10.1 ):
 
    SELECT *
    FROM Orders
    WHERE snum=
    ( SELECT snum
    FROM Salespeople
    WHERE sname='Motika');
 
   Чтобы оценить внешний( основной ) запрос, SQL сначала должен оценить внутренний запрос (или подзапрос ) внутри предложения WHERE. Он делает это так как и должен делать запрос имеющий единственную цель отыскать через таблицу Продавцов все строки, где поле sname равно значению Motika, и затем извлечь значения поля snum этих строк.
   Единственной найденной строкой естественно будет snum=1004. Однако SQL, не просто выдает это значение, а помещает его в предикат основного запроса вместо самого подзапроса, так чтобы предиката прочитал что
 
    WHERE snum=1004
 
SQL Execution Log

    SELECT * FROM Orders WHERE snum=
    (SELECT snum FROM Salespeople WHERE sname='Motika');
    
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |

Таблица 10.1: Использование подзапроса
   Основной запрос затем выполняется как обычно с вышеупомянутыми результатами. Конечно же, подзапрос должен выбрать один и только один столбец, а тип данных этого столбца должен совпадать с тем значением с которым он будет сравниваться в предикате. Часто, как показано выше, выбранное поле и его значение будут иметь одинаковые имена(в этом случае, snum), но это необязательно.
   Конечно, если бы мы уже знали номер продавца Motika, мы могли бы просто напечатать
   
    WHERE snum=1004
   и выполнять далее с подзапросом в целом, но это было бы не так универсально. Это будет продолжать работать даже если номер Motika изменился, а, с помощью простого изменения имени в подзапросе, вы можете использовать его для чего угодно.
 
### ЗНАЧЕНИЯ, КОТОРЫЕ МОГУТ ВЫДАВАТЬ ПОДЗАПРОСЫ
   Скорее всего было бы удобнее, чтобы наш подзапрос в предыдущем примере возвращал одно и только одно значение.
   
 Имея выбранным поле snum " WHERE city="London" вместо "WHERE sname='Motika", можно получить несколько различных значений. Это может сделать уравнение в предикате основного запроса невозможным для оценки верности или неверности, и команда выдаст ошибку.
   При использовании подзапросов в предикатах основанных на реляционных операторах (уравнениях или неравенствах, как объяснено в Главе 4 ), вы должны убедиться что использовали подзапрос который будет выдавать одну и только одну строку вывода. Если вы используете подзапрос который не выводит никаких значений вообще, команда не потерпит неудачи; но основной запрос не выведет никаких значений. Подзапросы которые не производят никакого вывода (или нулевой вывод) вынуждают рассматривать предикат ни как верный ни как неверный, а как неизвестный. Однако, неизвестный предикат имеет тот же самый эффект что и неверный: никакие строки не выбираются основным запросом (смотри Главу 5 для подробной информации о неизвестном предикате ).
   Это плохая стратегия, чтобы делать что-нибудь подобное следующему:
   
    SELECT *
    FROM Orders
    WHERE snum=
    ( SELECT snum
    FROM Salespeople
    WHERE city=Barcelona );
   Поскольку мы имеем только одного продавца в Barcelona - Rifkin, то подзапрос будет выбирать одиночное значение snum и следовательно будет принят. Но это - только в данном случае. Большинство SQL баз данных имеют многочисленых пользователей, и если другой пользователь добавит нового продавца из Barcelona в таблицу, подзапрос выберет два значения, и ваша команда потерпит неудачу.
 
### DISTINCT С ПОДЗАПРОСАМИ
   Вы можете, в некоторых случаях, использовать DISTINCT чтобы вынудить подзапрос генерировать одиночное значение. Предположим что мы хотим найти все порядки кредитований для тех продавцов которые обслуживают Hoffmanа (cnum=2001). Имеется один способ чтобы сделать это (вывод показывается в Таблице 10.2 ):
 
    SELECT *
    FROM Orders
    WHERE snum=
    ( SELECT DISTINCT snum
    FROM Orders
    WHERE cnum=2001 );
 
SQL Execution Log

    SELECT * FROM Orders WHERE snum=
    (SELECT DISTINCT snum FROM Orders Where cnum=2001);

|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |


   Таблица 10.2: Использование DISTINCT чтобы вынудить получение одного значения из подзапроса
   Подзапрос установил что значение поля snum совпало с Hoffman - 1001, и затем основной запрос выделил все порядки с этим значением snum из таблицы Порядков( не разбирая, относятся они к Hoffman или нет). Так как каждый заказчик назначен к одному и только этому продавцу, мы знаем что каждая строка в таблице Порядков с данным значением cnum должна иметь такое же значение snum. Однако так как там может быть любое число таких строк, подзапрос мог бы вывести много (хотя и идентичных ) значений snum для данного поля cnum. Аргумент DISTINCT предотвращает это. Если наш подзапрос возвратит более одного значения, это будет указывать на ошибку в наших данных - хорошая вещь для знающих об этом.
   Альтернативный подход должен быть чтобы ссылаться к таблице Заказчиков а не к таблице Порядков в подзапросе. Так как поле cnum - это первичный ключ таблицы Заказчика, запрос выбирающий его должен произвести только одно значение. Это рационально только если вы как пользователь имеете доступ к таблице Порядков но не к таблице Заказчиков. В этом случае, вы можете использовать решение которое мы показали выше. (SQL имеет механизмы которые определяют - кто имеет привилегии чтобы делать что-то в определенной таблице. Это будет объясняться в Главе 22.) Пожалуйста учтите, что методика используемая в предшествующем примере применима только когда вы знаете, что два различных поля в таблице должны всегда совпадать, как в нашем случае. Эта ситуация не является типичной в реляционных базах данных, она являеться исключением из правил.
### ПРЕДИКАТЫ С ПОДЗАПРОСАМИ ЯВЛЯЮТСЯ НЕОБРАТИМЫМИ
   Вы должны обратить внимание что предикаты включающие подзапросы, используют выражение
 
    < скалярная форма > < оператор > < подзапрос >, а не
    < подзапрос > < оператор > < скалярное выражение > или,
    < подзапрос > < оператор > < подзапрос >.

   Другими словами, вы не должны записывать предыдущий пример так:
   
    SELECT *
    FROM Orders
    WHERE (SELECT DISTINCT snum
    FROM Orders
    WHERE cnum=2001 )
    =snum;
   В строгой ANSI реализации, это приведет к неудаче, хотя некоторые программы и позволяют делать такие вещи. ANSI также предохраняет вас от появления обеих значений при сравнении, которые нужно вывести с помощью подзапроса.
### ИСПОЛЬЗОВАНИЕ АГРЕГАТНЫХ ФУНКЦИЙ В ПОДЗАПРОСАХ
   Один тип функций, который автоматически может производить одиночное значение для любого числа строк, конечно же, - агрегатная функция.
   Любой запрос использующий одиночную функцию агрегата без предложения GROUP BY будет выбирать одиночное значение для использования в основном предикате. Например, вы хотите увидеть все порядки имеющие сумму приобретений выше средней на 4-е Октября (вывод показан в Таблице 10.3 ):
 
    SELECT *
    FROM Orders
    WHERE amt >
    ( SELECT AVG (amt)
    FROM Orders
    WHERE odate=10/04/1990 );
 
SQL Execution Log

    SELECT * FROM Orders WHERE amt >
    (SELECT AVG (amt) FROM Orders
    WHERE odate=01/04/1990 );
    
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3005<br style="margin: 0px; padding: 0px;"> |    2345.45<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |

Таблица 10.3: Выбор всех сумм со значением выше средней на 10/04/1990
   Средняя сумма приобретений на 4 Октября - 1788.98 (1713.23 + 75.75) делится пополам, что в целом равняется =894.49. Все строки со значением в поле amt выше этого - являются выбраными.
   Имейте ввиду что сгруппированные агрегатные функции, которые являются агрегатными функциями определенными в терминах предложения GROUP BY, могут производить многочисленые значения. Они, следовательно, не позволительны в подзапросах такого характера. Даже если GROUP BY и HAVING используются таким способом, что только одна группа выводится с помощью подзапроса, команда будет отклонена в принципе. Вы должны использовать одиночную агрегатную функцию с предложением WHERE что устранит нежелательные группы. Например, следующий запрос который должен найти среднее значение комиссионных продавца в Лондоне -
 
    SELECT AVG (comm)
    FROM Salespeople
    GROUP BY city
    HAVlNG city="London";
 
   не может использоваться в подзапросе! Во всяком случае это не лучший способ формировать запрос. Другим способом может быть -
 
    SELECT AVG (comm)
    FROM Salespeople
    WHERE city="London";
### ИСПОЛЬЗОВАНИЕ ПОДЗАПРОСОВ КОТОРЫЕ ВЫДАЮТ МНОГО СТРОК С ПОМОЩЬЮ ОПЕРАТОРА IN
   Вы можете использовать подзапросы которые производят любое число строк если вы используете специальный оператор IN (операторы BETWEEN, LIKE, и IS NULL не могут использоваться с подзапросами). Как вы помните, IN определяет набор значений, одно из которых должно совпадать с другим термином уравнения предиката в порядке, чтобы предикат был верным. Когда вы используете IN с подзапросом, SQL просто формирует этот набор из вывода подзапроса. Мы можем, следовательно, использовать IN чтобы выполнить такой же подзапрос который не будет работать с реляционным оператором, и найти все атрибуты таблицы Порядков для продавца в Лондоне (вывод показывается в Таблице 10.4 ):
 
    SELECT *
    FROM Orders
    WHERE snum IN
    ( SELECT snum
    FROM Salespeople
    WHERE city="LONDON" );
 
SQL Execution Log

    SELECT * FROM Orders WHERE snum IN
    (SELECT snum FROM Salespeople WHERE city='London');
    
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |

Таблица 10. 4: Использование подзапроса с IN
   В ситуации подобно этой, подзапрос - более прост для пользователя чтобы понимать его и более прост для компьютера чтобы его выполнить, чем если бы Вы использовали обьединение:
 
    SELECT onum, amt, odate, cnum, Orders.snum
    FROM Orders, Salespeople
    WHERE Orders.snum=Salespeople.snum
    AND Salespeople.city="London";
 
   Хотя это и произведет тот же самый вывод что и в примере с подзапросом, SQL должен будет просмотреть каждую возможную комбинацию строк из двух таблиц и проверить их снова по составному предикату. Проще и эффективнее извлекать из таблицы Продавцов значения поля snum где city="London", и затем искать эти значения в таблице Порядков, как это делается в варианте с подзапросом. Внутренний запрос дает нам snums=1001 и snum=1004. Внешний запрос, затем, дает нам строки из таблицы Поряд ков где эти поля snum найдены.
   Строго говоря, быстрее или нет работает вариант подзапроса, практически зависит от реализации - в какой программе вы это используете.
   Эта часть вашей программы называемой - оптимизатор, пытается найти наиболее эффективный способ выполнения ваших запросов.
   Хороший оптимизатор во всяком случае преобразует вариант обьединения в подзапрос, но нет достаточно простого способа для вас чтобы выяснить выполнено это или нет. Лучше сохранить ваши запросы в памяти чем полагаться полностью на оптимизатор.
   Конечно вы можете также использовать оператор IN, даже когда вы уверены что подзапрос произведет одиночное значение. В любой ситуации где вы можете использовать реляционный оператор сравнения (=), вы можете использовать IN. В отличие от реляционных операторов, IN не может заставить команду потерпеть неудачу если больше чем одно значение выбрано подзапросом. Это может быть или преимуществом или недостатком. Вы не увидите непосредственно вывода из подзапросов; если вы полагаете что подзапрос собирается произвести только одно значение, а он производит различные. Вы не сможете объяснить различия в выводе основного запроса. Например, рассмотрим команду, которая похожа на предыдущую:
 
    SELECT onum, amt, odate
    FROM Orders
    WHERE snum=
    ( SELECT snum
    FROM Orders
    WHERE cnum=2001 );
 
   Вы можете устранить потребность в DISTINCT используя IN вместо (=),
   подобно этому:
 
    SELECT onum, amt, odate
    FROM Orders
    WHERE snum IN
    ( SELECT snum
    FROM Orders
    WHERE cnum=2001 );
 
   Что случится если есть ошибка и один из порядков был акредитован к различным продавцам? Версия использующая IN будет давать вам все порядки для обоих продавцов. Нет никакого очевидного способа наблюдения за ошибкой, и поэтому сгенерированные отчеты или решения сделанные на основе этого запроса не будут содержать ошибки. Вариант использующий (=), просто потерпит неудачу.
   
 Это, по крайней мере, позволило вам узнать что имеется такая проблема. Вы должны затем выполнять поиск неисправности, выполнив этот подзапрос отдельно и наблюдая значения которые он производит.
   В принципе, если вы знаете что подзапрос должен( по логике) вывести только одно значение, вы должны использовать =. IN является подходящим, если запрос может ограниченно производить одно или более значений, независимо от того ожидаете вы их или нет. Предположим, мы хотим знать комиссионные всех продавцов обслуживающих заказчиков в Лондоне:
 
    SELECT comm
    FROM Salespeople
    WHERE snum IN
    ( SELECT snum
    FROM Customers
    WHERE city="London" );
 
   Выводимыми для этого запроса, показанного в Таблице 10.5, являются значения комиссионных продавца Peel (snum =1001 ), который имеет обоих заказчиков в Лондоне. Это - только для данного случая. Нет никакой причины чтобы некоторые заказчики в Лондоне не могли быть назначеными к кому-то еще. Следовательно, IN - это наиболее логичная форма чтобы использовать ее в запросе.
 
SQL Execution Log

    SELECT comm FROM Salespeople WHERE snum IN
    (SELECT snum FROM Customers WHERE city='London');


|    comm                                  |
|------------------------------------------|
|    0.12<br style="margin: 0px; padding: 0px;"> |

 Таблица 10.5 Использование IN с подзапросом для вывода одного значения
   Между прочим, префикс таблицы для поля city необязателен в предыдущем примере, несмотря на возможную неоднозначность между полями city таблицы Заказчика и таблицы Продавцов.
   SQL всегда ищет первое поле в таблице обозначенной в предложении FROM текущего подзапроса. Если поле с данным именем там не найдено, проверяются внешние запросы. В вышеупомянутом примере, "city" в предложении WHERE означает что имеется ссылка к Customer.city( поле city таблицы Заказчиков). Так как таблица Заказчиков указана в предложении FROM текущего запроса, SQL предполагает что это - правильно. Это предположение может быть отменено полным именем таблицы или префиксом псевдонима, о которых мы поговорим позже когда будем говорить об соотнесенных подзапросах. Если возможен беспорядок, конечно же, лучше всего использовать префиксы.
### ПОДЗАПРОСЫ ВЫБИРАЮТ ОДИНОЧНЫЕ СТОЛБЦЫ
   Смысл всех подзапросов обсужденных в этой главе тот, что все они выбирают одиночный столбец. Это обязательно, поскольку выбранный вывод сравнивается с одиночным значением. Подтверждением этому то, что SELECT * не может использоваться в подзапросе. Имеется исключение из этого, когда подзапросы используются с оператором EXISTS, который мы будем представлять в Главе 12.
### ИСПОЛЬЗОВАНИЕ ВЫРАЖЕНИЙ В ПОДЗАПРОСАХ
   Вы можете использовать выражение основанное на столбце, а не просто сам столбец, в предложении SELECT подзапроса. Это может быть выполнено или с помощью реляционных операторов или с IN. Например, следующий запрос использует реляционный оператор =( вывод показывается в Таблице 10.6 ):
 
    SELECT *
    FROM Customers
    WHERE cnum=
    ( SELECT snum + 1000
    FROM Salespeople
    WHERE sname=Serres );
 
   Он находит всех заказчиков чье значение поля cnum равное 1000, выше поля snum Serres. Мы предполагаем что столбец sname не имеет никаких двойных значений (это может быть предписано или UNIQUE INDEX, обсуждаемым в Главе 17, или ограничением UNIQUE, обсуждаемым в Главе 18 );иначе
 
SQL Execution Log

    SELECT * FROM Customers WHERE cnum=
    (SELECT snum + 1000 WHERE Salespeople
    WHERE sname='Serres'
    
|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2002<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |

 Таблица 10.6: Использование подзапроса с выражением
 
   подзапрос может произвести многочисленые значения. Когда поля snum и сnum не имеют такого простого функционального значения как например первичный ключ, что не всегда хорошо, запрос типа вышеупомянутого невероятно полезен.
### ПОДЗАПРОСЫ В ПРЕДЛОЖЕНИИ HAVING
   Вы можете также использовать подзапросы внутри предложения HAVING.
   Эти подзапросы могут использовать свои собственные агрегатные функции если они не производят многочисленых значений или использовать GROUP BY или HAVING. Следующий запрос является этому примером (вывод пока зывается в Таблице 10.7 ):
 
    SELECT rating, COUNT (DISTINCT cnum )
    FROM Customers
    GROUP BY rating
    HAVING rating >
    ( SELECT AVG (rating)
    FROM Customers
    WHERE city=" San Jose';
 
SQL Execution Log

    SELECT rating,count (DISTINCT cnum) FROM Customers
    GROUP BY rating HAVING rating >
    (SELECT AVG (rating)snum + 1000 FROM Custimers
    WHERE city='San Jose'
    
|    rating                                |                                          |
|------------------------------------------|------------------------------------------|
|    200<br style="margin: 0px; padding: 0px;"> |    2<br style="margin: 0px; padding: 0px;"> |


   Таблица 10.7: Нахождение заказчиков с оценкой выше среднего в San Jose
   Эта команда подсчитывает заказчиков с оценками выше среднего в San Jose. Так как имеются другие оценки отличные от 300, они должны быть выведены с числом номеров заказчиков которые имели эту оценку.
### РЕЗЮМЕ
   Теперь вы используете запросы в иерархической манере. Вы видели, что использование результата одного запроса для управления другим, расширяет возможности позволяющие выполнить большее количество функций. Вы теперь понимаете как использовать подзапросы с реляционными операторами также как и со специальным оператором IN, или в предложении WHERE или в предложении HAVING внешнего запроса.
   В следующих главах, мы будем разрабатывать подзапросы. Сначала в Главе 11, мы обсудим другой вид подзапроса, который выполняется отдельно для каждой строки таблицы вызываемой во внешнем запросе. Затем, в Главе 12 и 13, мы представим вас нескольким специальным операторам которые функционируют на всех подзапросах, как это делает IN, за исключением когда эти операторы могут использоваться только в подзапросах.
### РАБОТА С SQL
   * Напишите запрос, который бы использовал подзапрос для получениявсех порядков для заказчика с именем Cisneros. Предположим, что вы не знаете номера этого заказчика, указываемого в поле cnum.
   * Напишите запрос который вывел бы имена и оценки всех заказчиков которые имеют усредненые порядки.
   * Напишите запрос который бы выбрал общую сумму всех приобретений в порядках для каждого продавца, у которого эта общая сумма больше чем сумма наибольшего порядка в таблице.
   
## Глава 11. СООТНЕСЕННЫЕ ПОДЗАПРОСЫ
 
   В ЭТОЙ ГЛАВЕ, МЫ ПРЕДСТАВИМ ВАС ТИПУ подзапроса о котором мы не говорили в Главе 10 - посвященной соотнесенному подзапросу. Вы узнаете как использовать соотнесенные подзапросы в предложениях запросов WHERE и HAVING. Сходства и различия между соотнесенными подзапросами и обьединениями будут обсуждаться далее, и вы сможете повысить ваше знание псевдонимов и префиксов имени таблицы - когда они необходимы и как их использовать.
 
### КАК СФОРМИРОВАТЬ СООТНЕСЕННЫЙ ПОДЗАПРОС
   Когда вы используете подзапросы в SQL, вы можете обратиться к внутреннему запросу таблицы в предложении внешнего запроса FROM, сформировав - соотнесенный подзапрос. Когда вы делаете это, подзапрос выполняется неоднократно, по одному разу для каждой строки таблицы основного запроса. Соотнесенный подзапрос - один из большого количества тонких понятий в SQL из-за сложности в его оценке. Если вы сумеете овладеть им, вы найдете что он очень мощный, потому что может выполнять сложные функции с помощью очень лаконичных указаний.
   Например, имеется один способ найти всех заказчиков в порядках на 3-е Октября (вывод показывается в Таблице 11.1):
 
    SELECT *
    FROM Customers outer
    WHERE 10/03/1990 IN
    ( SELECT odate
    FROM Orders inner
    WHERE outer.cnum=inner.cnum );
### КАК РАБОТАЕТ СООТНЕСЕННЫЙ ПОДЗАПРОС
   В вышеупомянутом примере, "внутренний"(inner) и "внешний"(outer), это псевдонимы, подобно обсужденным в Главе 9. Мы выбрали эти имена для большей ясности; они отсылают к значениям внутренних и внешних запросов, соответственно. Так как значение в поле cnum внешнего запроса меняется, внутренний запрос должен выполняться отдельно для каждой строки внешнего запроса. Строка внешнего запроса для которого внутренний
 
SQL Execution Log
 
    SELECT * FROM Customers outer WHERE 10/03/1990 IN
    (SELECT odate FROM Orders inner WHERE outer.cnum=inner.cnum);
 

  |    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2003<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |


 
   Таблица 11.1: Использование соотнесенного подзапроса
   запрос каждый раз будет выполнен, называется - текущей строкой-кандидатом. Следовательно, процедура оценки выполняемой соотнесенным подзапросом - это:
   * Выбрать строку из таблицы именованной в внешнем запросе. Это будет текущая строка-кандидат.
   * Сохранить значения из этой строки-кандидата в псевдониме с именем в предложении FROM внешнего запроса.
   * Выполнить подзапрос. Везде, где псевдоним данный для внешнего запроса найден (в этом случае "внешний" ), использовать значение для текущей строки-кандидата. Использование значения из строки-кандидата внешнего запроса в подзапросе называется - внешней ссылкой.
   * Оценить предикат внешнего запроса на основе результатов подзапроса выполняемого в шаге 3. Он определяеть - выбирается ли строка-кандидат для вывода.
   * Повторить процедуру для следующей строки-кандидата таблицы, и так далее пока все строки таблицы не будут проверены.
 
   В вышеупомянутом примере, SQL осуществляет следующую процедуру:
   * Он выбирает строку Hoffman из таблицы Заказчиков.
   * Сохраняет эту строку как текущую строку-кандидат под псевдонимом - "внешним".
   * Затем он выполняет подзапрос. Подзапрос просматривает всю таблицу Порядков чтобы найти строки где значение cnum поле - такое же как значение outer.cnum, которое в настоящее время равно 2001, - поле cnum строки Hoffmanа. Затем он извлекает поле odate из каждой строки таблицы Порядков для которой это верно, и формирует набор значений поля odate.
   * Получив набор всех значений поля odate, для поля cnum=2001, он проверяет предикат основного запроса чтобы видеть имеется ли значение на 3 Октября в этом наборе. Если это так(а это так), то он выбирает строку Hoffmanа для вывода ее из основного запроса.
   * Он повторяет всю процедуру, используя строку Giovanni как строку-кандидата, и затем сохраняет повторно пока каждая строка таблицы Заказчиков не будет проверена.
 
   Как вы можете видеть, вычисления которые SQL выполняет с помощью этих простых инструкций - это полный комплекс. Конечно, вы могли бы решить ту же самую проблему используя обьединение, следующего вида (вывод для этого запроса показывается в Таблице 11.2):
 
    SELECT *
    FROM Customers first, Orders second
    WHERE first.cnum=second.cnum
    AND second.odate=10/03/1990;
 
   Обратите внимание что Cisneros был выбран дважды, по одному разу для каждого порядка который он имел для данной даты. Мы могли бы устранить это используя SELECT DISTINCT вместо просто SELECT. Но это необязательно в варианте подзапроса. Оператор IN, используемый в варианте подзапроса, не делает никакого различия между значениями которые выбираются подзапросом один раз и значениями которые выбираются неоднократно. Следовательно DISTINCT необязателен.
 
SQL Execution Log
    
    SELECT * FROM Customers first, Orders second
    WHERE first.cnum=second.cnum (SELECT COUNT (*)
       FROM Customers WHERE snum=main.snum;

|    cnum                                  |    cname                                 |
|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |


   Таблица 11. 2 Использование обьединения вместо соотнесенного подзапроса
   Предположим что мы хотим видеть имена и номера всех продавцов которые имеют более одного заказчика. Следующий запрос выполнит это для вас (вывод показывается в Таблица 11.3 ):
 
    SELECT snum, sname
    FROM Salespeople main
    WHERE 1 <
    ( SELECT COUNT (*)
    FROM Customers
    WHERE snum=main.snum );
 
   Обратите внимание что предложение FROM подзапроса в этом примере не использует псевдоним. При отсутствии имени таблицы или префикса псевдонима, SQL может для начала принять, что любое поле выводится из таблицы с именем указанным в предложении FROM текущего запроса. Если поле с этим именем отсутствует( в нашем случае - snum ) в той таблице, SQL будет проверять внешние запросы. Именно поэтому, префикс имени таблицы обычно необходим в соотнесенных подзапросах - для отмены этого предположения. Псевдонимы также часто запрашиваются чтобы давать вам возможность ссылаться к той же самой таблице во внутреннем и внешнем запросе без какой-либо неоднозначности.
 
SQL Execution Log
 
    SELECT snum sname FROM Salespeople main
    WHERE 1 < AND second.odate=10/03/1990;
    
|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2003<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |


   Таблица 11.3: Нахождение продавцов с многочислеными заказчиками
### ИСПОЛЬЗОВАНИЕ СООТНЕСЕННЫХ ПОДЗАПРОСОВ ДЛЯ НАХОЖДЕНИЯ ОШИБОК
   Иногда полезно выполнять запросы которые разработаны специально так чтобы находить ошибки. Это всегда возможно при дефектной информации которую можно ввести в вашу базу данных, и, если она введена, бывает трудно ее определить. Следующий запрос не должен производить никакого вывода. Он просматривает таблицу Порядков чтобы видеть совпадают ли поля snum и cnum в каждой строке таблицы Заказчиков и выводит каждую строку где этого совпадения нет. Другими словами, запрос выясняет, тот ли продавец кредитовал каждую продажу (он воспринимает поле cnum, как первичный ключ таблицы Заказчиков, который не будет иметь никаких двойных значений в этой таблице ).
 
    SELECT *
    FROM Orders main
    WHERE NOT snum=
    ( SELECT snum
    FROM Customers
    WHERE cnum=main.cnum );
 
   При использовании механизма справочной целостности (обсужденного в Главе 19 ), вы можете быть гарантированы от некоторых ошибок такого вида. Этот механизм не всегда доступен, хотя его использование желательно во всех случаях, причем поиск ошибки запроса описанный выше, может быть еще полезнее.
### РАВНЕНИЕ ТАБЛИЦЫ С СОБОЙ
   Вы можете также использовать соотнесенный подзапрос основанный на той же самой таблице что и основной запрос. Это даст вам возможность извлечть определенные сложные формы произведенной информации. Например, мы можем найти все порядки со значениями сумм приобретений выше среднего для их заказчиков (вывод показан в Таблице 11.4 ):
 
    SELECT *
    FROM Orders outer
    WHERE amt >
    ( SELECT AVG amt
    FROM Orders inter
    WHERE inner.cnum=outer.cnum );
 
 
SQL Execution Log

    SELECT * FROM Orders outer WHERE amt >
    (SELECT AVG (amt) FROM Orders inner
    WHERE inner.cnum=outer.cnum
    
|     onum                                 |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.00<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |


   Таблица 11.4: Соотнесение таблицы с собой
   Конечно, в нашей маленькой типовой таблице, где большиство заказчиков имеют только один порядок, большинство значений являются одновременно средними и следовательно не выбираются. Давайте введем команду другим способом (вывод показывается в Таблице 11.5):
 
    SELECT *
    FROM Orders outer
    WHERE amt >=
    ( SELECT AVG (amt)
    FROM Orders inner
    WHERE inner.cnum=outer.cnum );
 
SQL Execution Log
 
    SELECT * FROM Orders outer WHERE amt > =
    (SELECT AVG (amt) FROM Orders inner
    WHERE inner.cnum=outer.cnum);
    
|     onum                                 |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3003<br style="margin: 0px; padding: 0px;"> |    767.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3005<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.19<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.95<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |

   Таблица 11.5: Выбераются порядки которые >=средней сумме приобретений для их заказчиков.
   Различие, конечно, в том, что реляционный оператор основного предиката включает значения которые равняются среднему (что обычно означает что они - единственые порядки для данных заказчиков ).
### СООТНЕСЕННЫЕ ПОДЗАПРОСЫ В ПРЕДЛОЖЕНИИ HAVING
   Также как предложение HAVING может брать подзапросы, он может брать и соотнесенные подзапросы. Когда вы используете соотнесенный подзапрос в предложении HAVING, вы должны ограничивать внешние ссылки к позициям которые могли бы непосредственно использоваться в самом предложении HAVING. Вы можете вспомнить из Главы 6 что предложение HAVING может использовать только агрегатные функции которые указаны в их предложении SELECT или поля используемые в их предложении GROUP BY. Они являются только внешними ссылками, которые вы можете делать. Все это потому, что предикат предложения HAVING оценивается для каждой группы из внешнего запроса, а не для каждой строки. Следовательно, подзапрос будет выполняться один раз для каждой группы выведеной из внешнего запроса, а не для каждой строки.
   Предположим что вы хотите суммировать значения сумм приобретений покупок из таблицы Порядков, сгруппировав их по датам, удалив все даты где бы SUM не был по крайней мере на 2000.00 выше максимальной (MAX ) суммы:
   
    SELECT odate, SUM (amt)
    FROM Orders a
    GROUP BY odate
    HAVING SUM (amt) >
    ( SELECT 2000.00 + MAX (amt)
    FROM Orders b
    WHERE a.odate=b.odate );
   Подзапрос вычисляет значение MAX для всех строк с той же самой датой что и у текущей агрегатной группы основного запроса. Это должно быть выполнено, как и ранее, с испошльзованием предложения WHERE. Сам подзапрос не должен использовать предложения GROUP BY или HAVING.
### СООТНЕСЕННЫЕ ПОДЗАПРОСЫ И ОБЬЕДИНЕНИЯ
   Как вы и могли предположить, соотнесенные подзапросы по природе близки к обьединениям - они оба включают проверку каждой строки одной таблицы с каждой строкой другой (или псевдонимом из той же ) таблицы.
   Вы найдете что большинство операций которые могут выполняться с одним из них будут также работать и с другим.
   Однако имеется различие в прикладной программе между ними, такое как вышеупомянутая потребность в использовании DISTINCT с обьединением и его необязательность с подзапросом. Имеются также некоторые вещи которые каждый может делать так, как этого не может другой. Подзапросы, например, могут использовать агрегатную функцию в предикате, делая возможным выполнение операций типа нашего предыдущего примера в котором мы извлекли порядки усредненные для их заказчиков. Обьединения, с другой стороны, могут выводить строки из обеих сравниваемых таблиц, в то время как вывод подзапросов используется только в предикатах внешних запросов. Как правило, форма запроса которая кажется наиболее интуитивной будет вероятно лучшей в использовании, но при этом хорошо бы знать обе техники для тех ситуаций когда та или иная могут не работать.
### РЕЗЮМЕ
   Вы можете поздравлять себя с овладением большого куска из рассмотреных понятий в SQL - соотнесенного подзапроса. Вы видели как соотнесенный подзапрос связан с обьединение, а также, как как его можно использовать с агрегатными функциями и в предложении HAVING. В общем, вы теперь узнали все типы подзапросов полностью.
   Следующий шаг - описание некоторых SQL специальных операторов. Они берут подзапросы как аргументы, как это делает IN, но в отличие от IN, они могут использоваться только в подзапросах. Первый из их, представленный в Главе 12, - называется EXISTS.
### РАБОТА С SQL
   * Напишите команду SELECT использующую соотнесенный подзапрос, которая выберет имена и номера всех заказчиков с максимальными для их городов оценками.
   * Напишите два запроса которые выберут всех продавцов (по их имени и номеру ) которые в своих городах имеют заказчиков которых они не обслуживают. Один запрос - с использованием обьединения и один - с соотнесенным подзапросом. Которое из решений будет более изящным? (Подсказка: один из способом это сделать, состоит в том, чтобы находить всех заказчиков не обслуживаемых данным продавцом и определить, находится ли каждый из них в городе продавца.)

## Глава 12. ИСПОЛЬЗОВАНИЕ ОПЕРАТОРА EXISTS
 
   ТЕПЕРЬ, КОГДА ВЫ ХОРОШО ОЗНАКОМЛЕНЫ С ПОДЗАПРОСАМИ, мы можем говорить о некоторых специальных операторах которые всегда берут подзапросы как аргументы. Вы узнаете о первом из их в этой главе. Остальные будут описан в следующей главе.
   Оператор EXISTS используется чтобы указать предикату, - производить ли подзапросу вывод или нет. В этой главе, вы узнаете как использовать этот оператор со стандартными и (обычно ) соотнесенными подзапросами.
   Мы будем также обсуждать специальные расмышления которые перейдут в игру когда вы будете использовать этот оператор как относительный агрегат, как пустой указатель NULL, и как оператор Буля. Кроме того, вы можете повысить ваш профессиональный уровень относительно подзапросов исследуя их в более сложных прикладных программах чем те которые мы видели до сих пор.
### КАК РАБОТАЕТ EXISTS?
   **EXISTS** - это оператор, который производит верное или неверное значение, другими словами, выражение Буля (см. Главу 4 для обзора этого термина). Это означает что он может работать автономно в предикате или в комбинации с другими выражениями Буля использующими Булевы операторы AND, OR, и NOT. Он берет подзапрос как аргумент и оценивает его как верный если тот производит любой вывод или как неверный если тот не делает этого. Этим он отличается от других операторов предиката, в которых1 он не может быть неизвестным. Например, мы можем решить, извлекать ли нам некоторые данные из таблицы Заказчиков если, и только если, один или более заказчиков в этой таблице находятсяся в San Jose (вывод для этого запроса показывается в Таблице 12.1):
 
    SELECT cnum, cname, city
    FROM Customers
    WHERE EXISTS
    ( SELECT *
    FROM Customers
    WHERE city=" San Jose' );
 
   Внутренний запрос выбирает все данные для всех заказчиков в San Jose. Оператор EXISTS во внешнем предикате отмечает, что некоторый вывод был произведен подзапросом, и поскольку выражение EXISTS было полным предикатом, делает предикат верным. Подзапрос( не соотнесенный ) был выполнен только один раз для всего внешнего запроса, и следовательно,
   
SQL Execution Log

    SELECT snum, sname, city FROM Customers WHERE EXISTS
    (SELECT * FROM Customers WHERE city='San Jose');

   |    cnum                                  |    cname                                 |    city                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    2002<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |
|    2003<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |

 
   Таблица 12.1 Использование оператора EXISTS
 
   имеет одно значение во всех случаях. Поэтому EXISTS, когда используется этим способом, делает предикат верным или неверным для всех строк сразу, что это не так уж полезно для извлечения определенной информации.
### ВЫБОР СТОЛБЦОВ С ПОМОЩЬЮ EXISTS
   В вышеупомянутом примере, EXISTS должен быть установлен так чтобы легко выбрать один столбец, вместо того, чтобы выбирать все столбцы используя в выборе звезду( SELECT *) В этом состоит его отличие от подзапроса который (как вы видели ранее в Главе 10 мог выбрать только один столбец ) . Однако, в принципе он мало отличается при выборе EXISTS столбцов, или когда выбираются все столбцы, потому что он просто замечает - выполняется или нет вывод из подзапроса - а не использует выведенные значения.
### ИСПОЛЬЗОВАНИЕ EXISTS С СООТНЕСЕННЫМИ ПОДЗАПРОСАМИ
   В соотнесенном подзапросе, предложение EXISTS оценивается отдельно для каждой строки таблицы имя которой указано во внешнем запросе, точно также как и другие операторы предиката, когда вы используете соотнесенный подзапрос. Это дает возможность использовать EXISTS как верный предикат, который генерирует различные ответы для каждой строки таблицы указанной в основном запросе. Следовательно информация из внутреннего запроса, будет сохранена, если выведена непосредственно, когда вы используете EXISTS таким способом. Например, мы можем вывести продавцов которые имеют многочисленых заказчиков (вывод для этого запроса показывается в Таблице 12.2 ):
 
    SELECT DISTINCT snum
    FROM Customers outer
    WHERE EXISTS
    ( SELECT *
    FROM Customers inner
    WHERE inner.snum=outer.snum
    AND inner.cnum < > outer.cnum );
 
SQL Execution Log

    SELECT DISTINCT cnum FROM Customers outer WHERE EXISTS
    (SELECT * FROM Customers inner WHERE inner.snum=outer.snum
    AND inner.cnum < > outer.cnum);
    
|     cnum                                 |
|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |


   Таблица 12. 2: Использование EXISTS с соотнесенным подзапросом
   Для каждой строки-кандидата внешнего запроса (представляющей заказчика проверяемого в настоящее время ), внутренний запрос находит строки которые совпадают со значением поля snum (которое имел продавец ), но не со значением поля cnum (сответствующего другим заказчикам ).
   Если любые такие строки найдены внутренним запросом, это означает, что имеются два разных заказчика обслуживаемых текущим продавцом (то-есть продавцом заказчика в текущей строке-кандидата из внешнего запроса ).
   Предикат EXISTS поэтому верен для текущей строки, и номер продавца поля (snum) таблицы указанной во внешнем запросе будет выведено. Если был DISTINCT не указан, каждый из этих продавцов будет выбран один раз для каждого заказчика к которому он назначен.
### КОМБИНАЦИЯ ИЗ EXISTS И ОБЬЕДИНЕНИЯ
   Однако для нас может быть полезнее вывести больше информации об этих продавцах а не только их номера. Мы можем сделать это объединив таблицу Заказчиков с таблицей Продавцов (вывод для запроса показывается в Таблице 12.3 ):
 
    SELECT DISTINCT first.snum, sname, first.city
    FROM Salespeople first, Customers second
    WHERE EXISTS
    ( SELECT *
    FROM Customers third
    WHERE second.snum=third.snum
    AND second.cnum < > third.cnum )
    AND first.snum=second.snum;
 
SQL Execution Log

    SELECT DISTINCT first.snum, sname, first.city
    FROM Salespeople first, Customers second
    WHERE EXISTS (SELECT * FROM Customers third
    WHERE second.snum=third.snum
    AND second.cnum < > third.cnum)
    AND first.snum=second.snum;

|    cnum                                  |    cname                                 |    city                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |

Таблица 12.3: Комбинация EXISTS с обьединением
   Внутренний запрос здесь - как и в предыдущем варианте, фактически сообщает, что псевдоним был изменен. Внешний запрос - это обьединение таблицы Продавцов с таблицей Заказчиков, наподобии того что мы видели прежде. Новое предложение основного предиката (AND first.snum=second.snum ) естественно оценивается на том же самом уровне что и предложение EXISTS. Это - функциональный предикат самого обьединения, сравнивающий две таблицы из внешнего запроса в терминах поля snum, которое являются для них общим. Из-за Булева оператора AND, оба условия основного предиката должны быть верны в порядке для верного предиката.
   Следовательно, результаты подзапроса имеют смысл только в тех случаях когда вторая часть запроса верна, а обьединение - выполняемо. Таким образом комбинация объединения и подзапроса может стать очень мощным способом обработки данных.
### ИСПОЛЬЗОВАНИЕ NOT EXISTS
   Предыдущий пример дал понять что EXISTS может работать в комбинации с операторами Буля. Конечно, то что является самым простым способом для использования и вероятно наиболее часто используется с EXISTS - это оператор NOT. Один из способов которым мы могли бы найти всех продавцов только с одним заказчиком будет состоять в том, чтобы инвертировать наш предыдущий пример. (Вывод для этого запроса показывается в Таблице 12.4:)
 
    SELECT DISTINCT snum
    FROM Customers outer
    WHERE NOT EXISTS
    ( SELECT *
    FROM Customers inner
    WHERE inner.snum=outer.snum
    AND inner.cnum < > outer.cnum );
### EXISTS И АГРЕГАТЫ
   Одна вещь которую EXISTS не может сделать - взять функцию агрегата в подзапросе. Это имеет значение. Если функция агрегата находит любые строки для операций с ними, EXISTS верен, не взирая на то, что это - значение функции ; если же агрегатная функция не находит никаких строк, EXISTS неправилен.
 
SQL Execution Log

    SELECT DISTINCT snum FROM Salespeople outer
    WHERE NOT EXISTS (SELECT * FROM Customers inner
    WHERE inner.snum=outer.snum
    AND inner.cnum < > outer.cnum);
    
|     cnum                                 |
|------------------------------------------|
|    1003<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |


   Таблица 12.4: Использование EXISTS с NOT
   Попытка использовать агрегаты с EXISTS таким способом, вероятно покажет что проблема неверно решалась от начала до конца.
   Конечно, подзапрос в предикате EXISTS может также использовать один или более из его собственных подзапросов. Они могут иметь любой из различных типов которые мы видели (или который мы будем видеть). Такие подзапросы, и любые другие в них, позволяют использовать агрегаты, если нет другой причины по которой они не могут быть использованы.
   Следующий раздел приводит этому пример.
   В любом случае, вы можете получить тот же самый результат более легко, выбрав поле которое вы использовали в агрегатной функции, вместо использования самой этой функции. Другими словами, предикат - EXISTS (SELECT COUNT (DISTINCT sname) FROM Salespeople) - будет эквивалентен - EXISTS (SELECT sname FROM Salespeople) который был позволен выше.
### БОЛЕЕ УДАЧНЫЙ ПРИМЕР ПОДЗАПРОСА
   Возможные прикладные программы подзапросов могут становиться многократно вкладываемыми. Вы можете вкладывать их два или более в одиночный запрос, и даже один внутрь другого. Так как можно рассмотреть небольшой кусок чтобы получить всю картину работаты этой команды, вы можете воспользоваться способом в SQL, который может принимать различные команды из большинства других языков.
   Имеется запрос который извлекает строки всех продавцов которые имеют заказчиков с больше чем одним текущим порядком. Это не обязательно самое простое решение этой проблемы, но оно предназначено скорее показать улучшеную логику SQL. Вывод этой информации связывает все три наши типовых таблицы:
 
    SELECT *
    FROM Salespeople first
    WHERE EXISTS
    ( SELECT *
    FROM Customers second
    WHERE first.snum=second.snum
    AND 1 <
    ( SELECT COUNT (*)
    FROM Orders
    WHERE Orders.cnum=
    second.cnum ));
 
   Вывод для этого запроса показывается в Таблице 12.5.
 
SQL Execution Log
 
    FROM Salespeople first WHERE EXISTS
    (SELECT * FROM Customers second
    WHERE first.snum=second.snum
    AND 1 < (SELECT CONT (*) FROM Orders
    WHERE Orders.cnum=second.cnum));
 
|    cnum                                  |    cname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.17<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    0.13<br style="margin: 0px; padding: 0px;"> |
|    1007<br style="margin: 0px; padding: 0px;"> |    Rifkin<br style="margin: 0px; padding: 0px;"> |    Barselona<br style="margin: 0px; padding: 0px;"> |    0.15<br style="margin: 0px; padding: 0px;"> |

Таблица 12.5: Использование EXISTS с комплексным подзапросом
   Мы могли бы разобрать вышеупомянутый запрос примерно так:
   Берем каждую строку таблицы Продавцов как строку-кандидат( внешний запрос ) и выполняем подзапросы. Для каждой строки-кандидата из внешнего запроса, берем в соответствие каждую строку из таблицы Заказчиков( средний запрос). Если текущая строка заказчиков не совпадает с текущей строкой продавца( т.е. если first.snum < > second.snum ), предикат среднего запроса неправилен. Всякий раз, когда мы находим заказчика в среднем запросе который совдает с продавцом во внешнем запросе, мы должны рассматривать сам внутренний запрос чтобы определить, будет ли наш средний предикат запроса верен. Внутренний запрос считает число порядков текущего заказчика (из среднего запроса). Если это число больший чем 1, предикат среднего запроса верен, и строки выбираются.
   Это делает EXISTS предикат внешнего запроса верным для текущей строки продавца, и означает, что по крайней мере один из текущих заказчиков продавца имеет более чем один порядок.
   Если это не кажется достаточно понятным для вас в этой точке разбора примера, не волнуйтесь. Сложность этого примера - хороша независимо от того, как часто будете Вы использовать ее в деловой ситуации. Основная цель примеров такого типа состоит в том, чтобы показать вам некоторые возможности которые могут оказаться в дальнейшем полезными. После работы со сложными ситуациями подобно этой, простые запросы которые являются наиболее часто используемыми в SQL, покажутся Вам элементарными.
   Кроме того, этот запрос, даже если он кажется удобным, довольно из-вилистый способ извлечения информации и делает много работы. Он связывает три разных таблицы чтобы дать вам эту информацию, а если таблиц больше чем здесь указано, будет трудно получить ее напрямую (хотя это не единственный способ, и не обязательно лучший способ в SQL). Возможно вам нужно увидеть эту информацию относительно регулярной основы - если, например, вы имеете премию в конце недели для продавца который получил многочисленые порядки от одного заказчика. В этом случае, он должен был бы вывести команду, и сохранять ее чтобы использовать снова и снова по мере того как данные будут меняться (лучше всего сделать это с помощью представления, которое мы будем проходить в Главе 20 ).
### РЕЗЮМЕ
   EXISTS, хотя он и кажется простым, может быть одним из самых непонятных операторов SQL. Однако, он облажает гибкостью и мощностью. В этой главе, вы видели и овладели большинством возможностей которые EXISTS дает вам. В дальнейшем, ваше понимание улучшеной логики подзапроса расширится значительно.
   Следующим шагом будет овладение тремя другими специальными операторами которые берут подзапросы как аргументы, это - ANY, ALL, и SOME. Как вы увидете в Главе 13, это - альтернативные формулировки некоторых вещей которые вы уже использовали, но которые в некоторых случаях, могут оказаться более предпочтительными.

### РАБОТА С SQL
   Напишите запрос который бы использовал оператор EXISTS для извлечения всех продавцов которые имеют заказчиков с оценкой 300.
   * Как бы вы решили предыдущую проблему используя обьединение?
   * Напишите запрос использующий оператор EXISTS который выберет всех продавцов с заказчиками размещенными в их городах которые ими не обслуживаются.
   * Напишите запрос который извлекал бы из таблицы Заказчиков каждого заказчика назначенного к продавцу который в данный момент имеет по крайней мере еще одного заказчика (кроме заказчика которого вы выберете ) с порядками в таблице Порядков (подсказка: это может быть похоже на структуру в примере с нашим трех-уровневым подзапросом ).

## Глава 13. ИСПОЛЬЗОВАНИЕ ОПЕРАТОРОВ ANY, ALL, И SOME
 
   ТЕПЕРЬ, КОГДА ВЫ ОВЛАДЕЛИ ОПЕРАТОРОМ EXISTS, Вы узнаете приблизительно три специальных оператора ориентируемых на подзапросы. (Фактически, имеются только два, так как ANY и SOME - одно и то же.) Если вы поймете работу этих операторов, вы будете понимать все типы подзапросов предиката используемых в SQL . Кроме того, вы будете представлены различным способам где данный запрос может быть сформирован используя различные типы подзапросов предиката, и вы поймете преимущества и недостатки каждого из этих подходов.
   ANY, ALL, и SOME напоминают EXISTS который воспринимает подзапросы как аргументы; однако они отличаются от EXISTS тем, что используются совместно с реляционными операторами. В этом отношении, они напоминают оператор IN когда тот используется с подзапросами; они берут все значения выведенные подзапросом и обрабатывают их как модуль. Однако, в отличие от IN, они могут использоваться только с подзапросами.
### СПЕЦИАЛЬНЫЕ ОПЕРАТОРЫ ANY или SOME
   Операторы SOME и ANY - взаимозаменяемы везде и там где мы используем ANY, SOME будет работать точно так же. Различие в терминологии состоит в том чтобы позволить людям использовать тот термин который наиболее однозначен. Это может создать проблему; потому что, как мы это увидим, наша интуиция может иногда вводить в заблуждение.
   Имеется новый способ нахождения продавца с заказчиками размещенными в их городах (вывод для этого запроса показывается в Таблице 13.1 ):
 
    SELECT *
    FROM Salespeople
    WHERE city=ANY
    (SELECT city
    FROM Customers );
 
   Оператор ANY берет все значения выведенные подзапросом, (для этого случая - это все значения city в таблице Заказчиков ), и оценивает их как верные если любой(ANY) из их равняется значению города текущей строки внешнего запроса.
 
SQL Execution Log

    SELECT * FROM Salespeople WHERE city=ANY
    (SELECT city FROM Customers);

|    cnum                                  |    cname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    1002<br style="margin: 0px; padding: 0px;"> |    Serres<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    0.13<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |

 Таблица 13. 1: Использование оператора ANY
   Это означает, что подзапрос должен выбирать значения такого же типа как и те, которые сравниваются в основном предикате. В этом его отличие от EXISTS, который просто определяет, производит ли подзапрос результаты или нет, и фактически не использует эти результаты.
   ИСПОЛЬЗОВАНИЕ ОПЕРАТОРОВ IN ИЛИ EXISTS ВМЕСТО ОПЕРАТОРА ANY
   Мы можем также использовать оператор IN чтобы создать запрос аналогичный предыдущему :
 
    SELECT *
    FROM Salespeople
    WHERE city IN
    ( SELECT city
    FROM Customers );
   Этот запрос будет производить вывод показанный в Таблице 13.2.
   Однако, оператор ANY может использовать другие реляционные операторы кроме равняется (=), и таким образом делать сравнения которые являются выше возможностей IN. Например, мы могли бы найти всех продавцов с их заказчиками которые следуют им в алфавитном порядке (вывод показан в Таблице 13.3)
 
    SELECT *
    FROM Salespeople
    WHERE sname < ANY
    ( SELECT cname
    FROM Customers);
 
SQL Execution Log
 
    SELECT * FROM Salespeople
    WHERE city IN (SELECT city FROM Customers);
    
|    cnum                                  |    cname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    0.10<br style="margin: 0px; padding: 0px;"> |


   Таблица 13. 3: Использование оператора ANY с оператором "неравно" (<)
 
   продавцов для их заказчиков которые упорядоченны в алфавитном порядке
   ( вывод показан в Таблице 13.3)
 
    SELECT *
    FROM Salespeople
    WHERE sname < ANY
    ( SELECT cname
    FROM Customers);
 
   Все строки были выбраны для Serres и Rifkin, потому что нет других заказчиков чьи имена следовали бы за ими в алфавитном порядке.
   Обратите внимание что это является d основнjм эквивалентом следующему запросу с EXISTS, чей вывод показывается в Таблице 13.4:
 
    SELECT *
    FROM Salespeople outer
    WHERE EXISTS
    ( SELECT *
    FROM Customers inner
    WHERE outer.sname < inner.cname );
 
SQL Execution Log
 
    SELECT * FROM Salespeople outer
    WHERE EXISTS (SELECT *
    FROM Customers inner WHERE outer.sname < inner.cname);

|    cnum                                  |    cname                                 |    city                                  |    comm                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    1001<br style="margin: 0px; padding: 0px;"> |    Peel<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.12<br style="margin: 0px; padding: 0px;"> |
|    1004<br style="margin: 0px; padding: 0px;"> |    Motika<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    0.11<br style="margin: 0px; padding: 0px;"> |
|    1003<br style="margin: 0px; padding: 0px;"> |    Axelrod<br style="margin: 0px; padding: 0px;"> |    New York<br style="margin: 0px; padding: 0px;"> |    0.10<br style="margin: 0px; padding: 0px;"> |


   Таблица 13.4 Использование EXISTS как альтернатива оператору ANY
   Любой запрос который может быть сформулирован с ANY (или, как мы увидим, с ALL ), мог быть также сформулирован с EXISTS, хотя наоборот будет неверно. Строго говоря, вариант с EXISTS не абсолютно идентичен вариантам с ANY или с ALL из-за различия в том как обрабатываются пустые( NULL ) значения (что будет обсуждаться позже в этой главе). Тем ни менее, с технической точки зрения, вы могли бы делать это без ANY и ALL если бы вы стали очень находчивы в использовании EXISTS (и IS NULL ).
   Большинство пользователей, однако, находят ANY и ALL более удобными в использовании чем EXISTS, который требует соотнесенных подзапросов.
   Кроме того, в зависимости от реализации, ANY и ALL могут, по крайней мере в теории, быть более эффективными чем EXISTS. Подзапросы ANY или ALL могут выполняться один раз и иметь вывод используемый чтобы определять предикат для каждой строки основного запроса. EXISTS, с другой стороны, берет соотнесенный подзапрос, который требует чтобы весь подзапрос повторно выполнялся для каждой строки основного запроса. SQL пытается найти наиболее эффективный способ выполнения любой команды, и может попробовать преобразовать менее эффективную формулу запроса в более эффективную (но вы не можете всегда рассчитывать на получение самой эффективной формулировки ).
   Основная причина для формулировки EXISTS как альтернативы ANY и ALL в том что ANY и ALL могут быть несколько неоднозначен, из-за способа использования этого термина в Английском языке, как вы это скоро увидите. С приходом понимания различия способов формулирования данного запроса, вы сможете поработать над процедурами которые сейчас кажутся Вам трудными или неудобными.
   КАК ANY МОЖЕТ СТАТЬ НЕОДНОЗНАЧНЫМ
   Как подразумевалось выше, ANY не полностью однозначен. Если мы создаем запрос чтобы выбрать заказчиков которые имеют больший рейтинг чем любой заказчик в Риме, мы можем получить вывод который несколько отличался бы от того что мы ожидали (как показано в Таблице 13.5 ):
   
    SELECT *
    FROM Customers
    WHERE rating > ANY
    ( SELECT rating
    FROM Customers
    WHERE city=Rome );
   В английском языке, способ которым мы обычно склонны интерпретировать оценку " больше чем любой (где city=Rome ) ", должен вам сообщить что это значение оценки должно быть выше чем значение оценки в каждом случае где значение city=Rome. Однако это не так, в случае ANY - используемом в SQL . ANY оценивает как верно, если подзапрос находит любое значение которое делает условие верным.
 
SQL Execution Log
 
    SELECT * FROM Customers WHERE rating > ANY
    (SELECT rating FROM Customers WHERE city='Rome');
    
|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2002<br style="margin: 0px; padding: 0px;"> |    Giovanni<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    2003<br style="margin: 0px; padding: 0px;"> |    Liu<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    200<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |

Таблица 13.5 Как оператор "больше чем" (>) интерпретируется ANY
   Если мы оценим ANY способом использующим грамматику Английского Языка, то только заказчики с оценкой 300 будут превышать Giovanni, который находится в Риме и имеет оценку 200. Однако, подзапрос ANY также находит Periera в Риме с оценкой 100. Так как все заказчики с оценкой 200 были выше этой, они будут выбраны, даже если имелся другой заказчик из Рима(Giovanni) чья оценка не была выше (фактически, то что один из выбранных заказчиков также находится в Риме несущественно).
   Так как подзапрос произвел по крайней мере одно значение которое сделает предикат верным в отношении этих строк, строки были выбраны. Чтобы дать другой пример, предположим что мы должны были выбирать все порядки сумм приоретений которые были больше чем по крайней мере один из порядков на 6-е Октября:
   
    SELECT *
    FROM Orders
    WHERE amt > ANY
    ( SELECT amt
    FROM Orders
    WHERE odate=10/06/1990 );
 
   Вывод для этого запроса показывается в Таблице 13.6.
   Даже если самая высокая сумма приобретений в таблице (9891.88) - имелась на 6-е Октября, предыдущая строка имеет более высокое значение суммы чем другая строка на 6-е Октября, которая имела значение суммы=1309.95. Имея реляционный оператор ">=" вместо просто " > ", эта строка будет также выбирана, потому что она равна самой себе.
   Конечно, вы можете использовать ANY с другой SQL техникой, например с техникой обьединения. Этот запрос будет находить все порядки со значением суммы меньшей чем значение любой суммы для заказчика в San Jose (вывод показывается в Таблице 13.7):
   
    SELECT *
    FROM Orders
    WHERE amt < ANY
    ( SELECT amt
    FROM Orders A, Customers b
    WHERE a.cnum=b.cnum
    AND b.city=" San Jose' );
 
   Даже если нименьший порядок в таблице был для заказчика из San Jose, то был второй наибольший; следовательно почти все строки будут выбраны. Простой способ запомнить, что < ANY значение меньшее чем наибольшее выбранное значение, а > ANY значение большее чем наименьшее выбранное значение.
 
SQL Execution Log

    SELECT * FROM Orders WHERE amt > ANY
    (SELECT amt FROM Orders WHERE odate=10/06/1990);
 
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3005<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |


   Таблица 13. 6: Выбранное значение больше чем любое(ANY) на 6-е Октября
 
SQL Execution Log
 
    WHERE amt > ANY (SELECT amt FROM Orders a, Customers b
    WHERE a.cnum=b.cnum AND b.city='San Jose');
 
|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3001<br style="margin: 0px; padding: 0px;"> |    18.69<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3003<br style="margin: 0px; padding: 0px;"> |    767.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2001<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3006<br style="margin: 0px; padding: 0px;"> |    1098.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2008<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3007<br style="margin: 0px; padding: 0px;"> |    75.10<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3010<br style="margin: 0px; padding: 0px;"> |    1309.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2004<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |

Таблица 13. 7: Использование ANY с объединением
   Фактически, вышеуказанные команды весьма похожи на следующее - (вывод показан в Таблице 13.8) :
 
    SELECT *
    FROM Orders
    WHERE amt <
    ( SELECT MAX amt
    FROM Orders A, Customers b
    WHERE a.cnum=b.cnum
    AND b.city=" San Jose' );
 
SQL Execution Log
 
    WHERE amt < (SELECT MAX (amt) FROM Orders a, Customers b
    WHERE a.cnum=b.cnum AND b.city='San Jose');

|    onum                                  |    amt                                   |    odate                                 |    cnum                                  |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    3002<br style="margin: 0px; padding: 0px;"> |    1900.10<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2007<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |
|    3005<br style="margin: 0px; padding: 0px;"> |    5160.45<br style="margin: 0px; padding: 0px;"> |    10/03/1990<br style="margin: 0px; padding: 0px;"> |    2003<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    3009<br style="margin: 0px; padding: 0px;"> |    1713.23<br style="margin: 0px; padding: 0px;"> |    10/04/1990<br style="margin: 0px; padding: 0px;"> |    2002<br style="margin: 0px; padding: 0px;"> |    1003<br style="margin: 0px; padding: 0px;"> |
|    3008<br style="margin: 0px; padding: 0px;"> |    4723.00<br style="margin: 0px; padding: 0px;"> |    10/05/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    3011<br style="margin: 0px; padding: 0px;"> |    9891.88<br style="margin: 0px; padding: 0px;"> |    10/06/1990<br style="margin: 0px; padding: 0px;"> |    2006<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |

 Таблица 13.8: Использование агрегатной функции вместо ANY
### СПЕЦИАЛЬНЫЙ ОПЕРАТОР ALL
   С помощью ALL, предикат является верным, если каждое значение выбранное подзапросом удовлетворяет условию в предикате внешнего запроса.
   Если мы хотим пересмотреть наш предыдущий пример чтобы вывести только тех заказчиков чьи оценки, фактически, выше чем у каждого заказчика в Париже, мы можем ввести следующее чтобы произвести вывод показанный в Таблтце 13.9:
 
    SELECT *
    FROM Customers
    WHERE rating > ALL
    (SELECT rating
    FROM Customers
    WHERE city=Rome ):
 
SQL Execution Log
 
    SELECT * FROM Customers WHERE rating > ALL
    (SELECT rating FROM Customers WHERE city='Rome');

|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |

Таблица 13.9: Использование оператора ALL
   Этот оператор проверяет значения оценки всех заказчиков в Риме. Затем он находит заказчиков с оценкой большей чем у любого из заказчиков в Риме. Самая высокая оценка в Риме - у Giovanni( 200). Следовательно, выбираются только значения выше этих 200.
   Как и в случае с ANY, мы можем использовать EXISTS для производства альтернативной формулировки такого же запроса - (вывод показан в Таблице 13.10 ):
 
    SELECT *
    FROM Customers outer
    WHERE NOT EXISTS
    ( SELECT *
    FROM Customers inner
    WHERE outer.rating <=inner.rating
    AND inner.city=|Rome| );
 
SQL Execution Log

    SELECT * FROM Customers outer WHERE NOT EXISTS
    (SELECT * FROM Customers inner WHERE outer
    rating=inner.rating AND inner.city='Rome');
    
|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |


   Таблица 13.10: Использование EXISTS в качестве альтернативы к ALL
 
### РАВЕНСТВА И НЕРАВЕНСТВА
   ALL используется в основном с неравенствами чем с равенствами, так как значение может быть "равным для всех" результатом подзапроса только если все результаты, фактически, идентичны. Посмотрите следующий запрос:
 
    SELECT *
    FROM Customers
    WHERE rating=ALL
    ( SELECT rating
    FROM Customers
    WHERE city=" San Jose' );
 
   Эта команда допустима, но, c этими данными, мы не получим никакого вывода. Только в единственом случае вывод будет выдан этим запросом - если все значения оценки в San Jose окажутся идентичными. В этом случае, можно сказать следующее :
 
    SELECT *
    FROM Customers
    WHERE rating=
    ( SELECT DISTINCT rating
    FROM Customers
    WHERE city=" San Jose' );
 
   Основное различие в том, что эта последняя команда должна потерпеть неудачу если подзапрос выведет много значений, в то время как вариант с ALL просто не даст никакого вывода. В общем, не самая удачная идея использовать запросы которые работают только в определенных ситуациях подобно этой. Так как ваша база данных будет постоянно меняться, это еудачный способ, чтобы узнать о ее содержании. Однако, ALL может более эффективно использоваться с неравенствами, то есть с оператором "< >". Но учтите что сказанное в SQL что - значение которое не равняется всем результатам подзапроса, - будет отличаться от того же но сказанного с учетом граматики Английского языка. Очевидно, если подзапрос возвращает много различных значений, как это обычно бывает, ни одно
   отдельное значение не может быть равно им всем в обычном смысле. В SQL, выражение - < > ALL - в действительности соответствует " не равен любому " результату подзапроса. Другими словами, предикат верен, если данное значение не найдено среди результатов подзапроса. Следовательно, наш предыдущий пример противоположен по смыслу этому примеру (с выводом показанным в Таблице 13.11):
 
    SELECT *
    FROM Customers
    WHERE rating < > ALL
    ( SELECT rating
    FROM Customers
    WHERE city=" San Jose' );
 
SQL Execution Log
 
    SELECT * FROM Customers WHERE rating < > ALL
    (SELECT rating FROM Customers WHERE city='San Jose');

 |    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2001<br style="margin: 0px; padding: 0px;"> |    Hoffman<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2006<br style="margin: 0px; padding: 0px;"> |    Clemens<br style="margin: 0px; padding: 0px;"> |    London<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1001<br style="margin: 0px; padding: 0px;"> |
|    2007<br style="margin: 0px; padding: 0px;"> |    Pereira<br style="margin: 0px; padding: 0px;"> |    Rome<br style="margin: 0px; padding: 0px;"> |    100<br style="margin: 0px; padding: 0px;"> |    1004<br style="margin: 0px; padding: 0px;"> |


   Таблица 13.11: Использование ALL с < >
   Вышеупомянутый подзапрос выберает все оценки для города San Jose. Он выводит набор из двух значений: 200 (для Liu ) и 300 (для Cisneros).
   атем, основной запрос, выбирает все строки, с оценкой не совпадающей ни с одной из них - другими словами все строки с оценкой 100. Вы можете сформулировать тот же самый запрос используя оператор NOT IN:
 
    SELECT*
    FROM Customers
    WHERE rating NOT IN
    ( SELECT rating
    FROM Customers
    WHERE city=" San Jose' );
 
   Вы могли бы также использовать оператор ANY:
 
    SELECT *
    FROM Customers
    WHERE NOT rating=ANY
    ( SELECT rating
    FROM Customers
    WHERE city=" San Jose' );
 
   Вывод будет одинаков для всех трех условий.
 
### ПРАВИЛЬНОЕ ПОНИМАНИЕ ANY И ALL
   В SQL, сказать что - значение больше( или меньше ) чем любое(ANY) из набора значений - тоже самое что сказать, что оно больше( или меньше ) чем любое одно отдельное из этих значений. И наоборот, сказать что значение не равно всему(ALL) набору значений, тоже что сказать, что нет такого значения в наборе которому оно равно.
### КАК ANY, ALL, И EXIST ПОСТУПАЮТM С ОТСУТСТВУЮЩИМИ И НЕИЗВЕСТНЫМИ ДАННЫМИ
   Как было сказано, имеются некоторые различия между EXISTS и операторами представленными в этой главе относительно того как они обрабатывают оператор NULL. ANY и ALL также отличаются друг от друга тем как они реагируют если подзапрос не произвел никаких значений чтобы использовать их в сравнении. Эти различия могут привести к непредвиденным результатам на Ваши запросы если вы не будете их учитывать.
### КОГДА ПОДЗАПРОС ВОЗВРАЩАЕТСЯ ПУСТЫМ
   Одно значительное различие между ALL и ANY - способ действия в cитуации когда подзапрос не возвращает никаких значений. В принципе, всякий раз, когда допустимый подзапрос не в состоянии сделать вывод, ALL - автоматически верен, а ANY автоматически неправилен. Это означает, что следующий запрос
 
    SELECT *
    FROM Customers
    WHERE rating > ANY
    ( SELECT rating
    FROM Customers
    WHERE city=Boston );
 
   не произведет никакого вывода, в то время как запрос -
 
    SELECT
    FROM Customers
    WHERE rating > ALL
    ( SELECT rating
    FROM Customers
    WHERE city='Boston' );
 
   выведет всю таблицу Заказчиков. Когда нет никаких заказчиков в Boston,
   естественно, ни одно из этих сравнений не имеет значення.
### ANY И ALL ВМЕСТО EXISTS С ПУСТЫМ УКАЗАТЕЛЕМ( NULL )
   Значения NULL также имеют некоторые проблемы с операторами наподобие этих. Когда SQL сравнивает два значения в предикате, одно из которых пустое (NULL), то результат неизвестен (смотрите Главу 5). Неизвестный предикат, подобен неверному и является причиной того что строка не выбирается, но работать он будет иначе в некоторых похожих запросах, в зависимости от того, используют они ALL или ANY вместо EXISTS. Рассмотрим наш предыдущий пример:
 
    SELECT *
    FROM Customers
    WHERE rating > ANY
    ( SELECT rating
    FROM Customers
    WHERE city='Rome' );
 
   и еще один пример:
 
    SELECT *
    FROM Customers outer
    WHERE EXISTS
    ( SELECT *
    FROM Customers inner
    WHERE outer.rating > inner.rating
    AND inner.city='Rome' );
 
   В общем, эти два запроса будут вести себя одинаково. Но предположим, что появилось пустое(NULL) значение в столбце rating таблицы Заказчиков:
 

   
   | CNUM | CNAME | CITY    | RATING | SNUM |
|------|-------|---------|--------|------|
| 2003 | Liu   | SanJose | NULL   | 1002 |

   В варианте с ANY, где оценка Liu выбрана основным запросом, значение NULL делает предикат неизвестным а строка Liu не выбирается для вывода. Однако, в варианте с NOT EXISTS когда эта строка выбрана основным запросом, значение NULL используется в предикате подзапроса, делая его неизвестным в каждом случае. Это означает что подзапрос не будет производить никаких значений, и EXISTS будет неправилен. Это, естественно, делает оператор NOT EXISTS верным. Следовательно, строка Liu будет выбрана для вывода. Это основное расхождение, в отличие от других типов предикатов, где значение EXISTS независимо от того верно оно или нет - всегда неизвестно. Все это является аргументом в пользу использования варианта формулировки с ANY. Мы не считаем что значение NULL является выше чем допустимое значение. Более того, результат будет тот же, если мы будем проверять для более низкого значения.
   ИСПОЛЬЗОВАНИЕ COUNT ВМЕСТО EXISTS
   Подчеркнем, что все формулировки с ANY и ALL могут быть в точности выполнены с EXISTS, в то время как наоборот будет неверно. Хотя в этом случае, также верно и то что EXISTS и NOT EXISTS подзапросы могут обманывать при выполнении тех же самых подзапросов с COUNT(*) в предложения SELECT подзапроса. Если больше чем ноль строк выводе будет подсчитано, это эквивалентно EXISTS; в противном случае это работает также как NOT EXISTS. Следующее является этому примером (вывод показывается в Таблице 13.12 ):
 
    SELECT *
    FROM Customers outer
    WHERE NOT EXISTS
    ( SELECT *
    FROM Customers inner
    WHERE outer.rating <=inner.rating
    AND inner.city='Rome' );
 
SQL Execution Log
 
    SELECT * FROM Customers outer
    WHERE NOT EXISTS (SELECT * FROM Customers inner
    WHERE outer.rating <=inner.rating AND inner.city='Rome');


|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |


   Таблица 13.12: Использование EXISTS с соотнесенным подзапросом
   
    Это должно также быть выполнено как
 
    SELECT *
    FROM Customers outer
    WHERE 1 >
    ( SELECT COUNT (*)
    FROM Customers inner
    WHERE outer.rating <=inner.rating
    AND inner.city='Rome' );
 
   Вывод к этому запросу показывается в Таблице 13.13.
   Теперь Вы начинаете понимать сколько способов имеется в SQL. Если это все кажется несколько путанным на этой стадии, нет причины волноваться. Вы обучаетесь чтобы использовать ту технику которая лучше всего отвечает вашим требованиям и наиболее понятна для вас. Начиная с этого места, мы хотим показать Вам большое количество возможностей, что бы вы могли найти ваш собственный стиль.
 
SQL Execution Log
 
    SELECT * FROM Customers outer
    WHERE 1 > (SELECT COUNT (*) FROM Customers inner
    WHERE outer.rating <=inner.rating
    AND inner.city='Rome');

|    cnum                                  |    cname                                 |    city                                  |    rating                                |    snum                                  |
|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|------------------------------------------|
|    2004<br style="margin: 0px; padding: 0px;"> |    Grass<br style="margin: 0px; padding: 0px;"> |    Berlin<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1002<br style="margin: 0px; padding: 0px;"> |
|    2008<br style="margin: 0px; padding: 0px;"> |    Cisneros<br style="margin: 0px; padding: 0px;"> |    San Jose<br style="margin: 0px; padding: 0px;"> |    300<br style="margin: 0px; padding: 0px;"> |    1007<br style="margin: 0px; padding: 0px;"> |


   Таблица 13.13: Использование COUNT вместо EXISTS
=РЕЗЮМЕ
   Итак, вы прошли много чего в этой главе. Подзапросы не простая тема, и мы потратили много время чтобы показать их разновидности и неоднозначности. То чему Вы теперь научились, вещи достаточно глубокие. Вы знаете несколько технических решений одной проблемы, и поэтому вы можете выбрать то которое более подходит вашим целям. Кроме того, вы поняли, как различные формулировки будет обрабатывать пустые значения (NULL) и ошибки.
   Теперь, когда вы полностью изучили запросы, наиболее важный, и вероятно наиболее сложный, аспект SQL, объем другого материала будет относительно прост для понимания.
   Мы имеем еще одну главу о запросах, которая покажет вам как объединить выводы любого числа запросов в единое тело, с помощью формирования объединения многочисленых запросов используя оператор UNION.
### РАБОТА С SQL
   * Напишите запрос который бы выбирал всех заказчиков чьи оценки равны или больше чем любая( ANY ) оценка заказчика Serres.
   * Что будет выведено вышеупомянутой командой?
   * Напишите запрос использующий ANY или ALL, который бы находил всех продавцов которые не имеют никаких заказчиков размещенных в их городе.
   * Напишите запрос который бы выбирал все порядки с суммой больше чем любая (в обычном смысле ) для заказчиков в Лондоне.
   * Напишите предыдущий запрос с использованием - MAX.


