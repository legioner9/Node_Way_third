<!-- Start Document Outline -->

* [Установка программных пакетов в Linux для начинающих (linux install rpm)](#установка-программных-пакетов-в-linux-для-начинающих-linux-install-rpm)
	* [Два способа установки ПО.](#два-способа-установки-по)
	* [Программа rpm.](#программа-rpm)
	* [Установка ПО из исходных текстов](#установка-по-из-исходных-текстов)
	* [Необходимые сведения о программировании на языке Си](#необходимые-сведения-о-программировании-на-языке-си)
	* [Инсталляция пакетов ПО из исходных текстов](#инсталляция-пакетов-по-из-исходных-текстов)
	* [Сколько осталось места на диске](#сколько-осталось-места-на-диске)
	* [Освобождение дискового пространства](#освобождение-дискового-пространства)

<!-- End Document Outline -->

# [Установка программных пакетов в Linux для начинающих (linux install rpm)](https://www.opennet.ru/base/sys/soft_inst.txt.html)

Два способа установки ПО.
-------------------------

   Необходимость в установке новых программных пакетов под LINUX
   возникает в двух основных случаях :
   - когда появляется новая версия одного из уже установленных у Вас пакетов;
   - когда возникает необходимость использования какой-то пакета, еще не установленного в системе.

   Во втором случае это может быть один из пакетов, имеющихся на Вашем
   установочном диске, но не установленный в процессе инсталляции. Однако
   чаще всего новое ПО Вы будете находить в Интернет, тем более, что
   значительная часть этого ПО бесплатное или условно бесплатное. Как бы
   то ни было, но рано или поздно Вы все равно окажетесь перед
   необходимостью установить новый пакет.

   Существует две основных формы распространения ПО для LINUX: в исходных
   текстах и в виде исполняемых модулей. И в том и в другом случае пакет
   ПО может поставляться либо в виде tar-gz архива, либо в виде
   rpm-пакета.

   Проще всего установить ПО, представленное в виде rpm-пакета,
   содержащего исполняемые файлы, этот способ и рассмотрим первым.
   Отметим только, что для инсталляции новых пакетов Вы должны войти в
   систему как пользователь root.


## Программа rpm.

   Название этой программы (или команды) является аббревиатурой от Redhat
   Package Manager. Такая расшифровка дается в большинстве книг и
   руководств по Линукс и кажется мне более правильной и логичной, хотя в
   главе 6 "The Official Red Hat Linux Reference Guide" говорится: "The
   RPM Package Manager (RPM), is an open packaging system available for
   any-one to use, and works on Red Hat Linux as well as other Linux and
   UNIX systems".

   Программа rpm в некотором смысле аналогична программам типа setup
   wizard для MS Windows.  Преимуществом использования этой программы по
   сравнению с установкой tar-gz архивов является то, что она
   автоматически проделает все необходимые действия по установке ПО:
   создаст необходимые каталоги, распределит по ним файлы, создаст
   ссылки. Кроме того, она может быть использована не только для
   установки нового пакета, но и для обновления версий ПО, получения
   перечней установленного ПО и проверки установки, а также для
   деинсталляции отдельных пакетов (например, если после периода пробной
   работы с программой Вы решили отказаться от ее дальнейшего
   использования). С помощью той же программы rpm можно самому создать
   пакет формата rpm, однако для начинающих лучше, наверное, этим не
   заниматься, а воспользоваться готовыми rpm-пакетами.

   rpm-пакеты - это специальным образом подготовленные архивы,
   предназначенные для обработки программой rpm. Название rpm-пакетов
   оканчивается на суффикс .rpm, например, xzip-180-1.i386.rpm или
   xzip-180-1.src.rpm. Как видите, перед суффиксом .rpm стоит еще один
   суффикс. Если это .i386 или .i586, то в пакете находятся исполняемые
   файлы, а если этот суффикс .src, - то в пакете исходные тексты,
   которые после установки еще надо скомпилировать. Обычно и на
   установочных компакт-дисках и в Интернет-каталогах rpm-пакеты с
   исполняемыми файлами располагаются в каталогах с названием RPMS, а
   rpm-пакеты с исходными текстами - в подкаталогах SRPMS.

   В Интернет rpm-пакеты можно найти на различных серверах. По моему
   опыту наиболее удобным сервером в Интернет  для поиска rpm-архивов
   является сервер http://rufus.w3.org. На нем установлена поисковая
   система, которая позволяет упорядочивать список пакетов наиболее
   удобным для Вас способом:
- по именам пакетов;
- по дистрибутивам;
- по группам приложений;
- по датам;
- по поставщикам (производителям) ПО.

   Общий объем архива rpm-пакетов на этом сервере составляет более 66
   Гигабайт. Очень богатые архивы хранят также два ftp-сервера в России:
   ftp://ftp.chg.ru/pub/Linux и ftp://ftp.nc.orc.ru/ 

   Необходимо только заметить, что если для перекачки пакетов из Интернет
   Вы используете компьютер, работающий под Windows, то все имена пакетов
   у Вас будут, скорее всего, искажены. Дело в том, что Windows "не
   любит" имена, в которых несколько точек (например,
   glib-1.0.6-3.i386.rpm и заменит "лишние", по его мнению, точки на
   подчеркивания - glib-1_0_6-3_i386.rpm). Так что после получения пакета
   (при переносе его на ПК с ОС Linux) надо эти "исправления" устранить,
   вернувшись к UNIX-вым именам.

   Итак, Вы нашли и скачали rpm-архив с исполняемой версией нужного Вам
   пакета. Если Вы ставите совершенно новый пакет (у Вас не было на
   компьютере предыдущих версий этого ПО), то для установки пакета из
   этого архива достаточно перейти в тот каталог, где находится архив, и
   дать команду (для самых нетерпеливых: не спешите выполнять эту
   рекомендацию, прочитайте еще хотя бы пару абзацев)

           rpm -i имя_rpm-архива


   Если у Вас была установлена предыдущая версия пакета, то в простейшем
   случае надо дать команду следующего формата:

           rpm -U --force имя_rpm-архива


   Здесь параметр -U говорит программе, что надо произвести обновление
   (upgrade) пакета, а опция --force требует безусловно (и без лишних
   вопросов) обновить все входящие в пакет файлы. Заметьте, что это очень
   сильное требование, и в некоторых случаях может быть лучше сохранить
   какие-то (например, конфигурационные) файлы от предыдущей версии.
   Если установка проходит нормально, и никаких дополнительных сообщений
   не появляется, то после завершения работы программы (после появления
   приглашения shell) Вы можете пользоваться вновь установленным пакетом.

   К сожалению не всегда все так просто. Приведу конкретный пример. У
   меня был установлен RedHat Linux версии 5.2, причем программа Midnight
   Commander (mc) была версии 4.1.36. На ftp-сервере я увидел версию
   4.5.30 этой программы (пакет mc-4.5.30-12.i386.rpm) и, естественно,
   решил ее поставить. Однако оказалось, что для этого необходимо, чтобы
   были установлены еще 4 других пакета, о чем rpm мне и сообщила:

       ошибка: неудовлетворенные зависимости:
           redhat-logos нужен для mc-4.5.30-12
           libglib-1.2.so.0 нужен для mc-4.5.30-12
           libc.so.6(GLIBC_2.1) нужен для mc-4.5.30-12
           libc.so.6(GLIBC_2.0) нужен для mc-4.5.30-12
            

   Это и не удивительно, если Вы вспомните, что и при первоначальной
   установке Linux программа инсталляции тоже проверяла взаимозависимости
   пакетов и предлагала установить недостающие. Однако в случае
   инсталляции все необходимые пакеты находятся на том же диске, а здесь
   мне пришлось вначале поискать нужные пакеты. Два пакета
   (redhat-logos-1.0.5-1.noarch.rpm и glibc-2.1.1-6.i386.rpm) я нашел без
   труда, после чего rpm перестала просить и GLIBC_2.0. А вот с
   libglib.so.1 вышло сложнее. Во-первых я никак не мог найти пакета с
   таким названием. Как оказалось, такого пакета и не существует, файл
   libglib.so.1 входит в состав пакета glib-1.0.6-3.i386.rpm. Пока я это
   выяснил, я узнал также, что чтобы выяснить, какие файлы установит тот
   или иной пакет, надо дать команду

           rpm -qpl имя_rpm-архива
            


   а для получения информации о пакете - команду

           rpm -qpi имя_rpm-архива
            


   Дело в том, что файлы RPM кроме собственно архива файлов содержат
   информацию о пакете, включая имя, версию и краткое описание. С помощью
   той же программы rpm Вы можете просмотреть эту дополнительную
   информацию. Например, для пакета glib-1.0.6-3.i386.rpm получим
   следующие результаты:

           rpm -qpi glib-1.0.6-3.i386.rpm
            


   Вывод будет примерно таким:

        Name        : glib                 Relocations: (not relocateable)
        Version     : 1.0.6                     Vendor: Red Hat Software
        Release     : 3                     Build Date: Суб 10 Окт 1998 04:49:03
        Install date: (not installed)       Build Host: porky.redhat.com
        Group       : Libraries             Source RPM: glib-1.0.6-3.i386.rpm
        Size        : 55305
        Packager    : Red Hat Software <bug@redhat.com.>
        Summary     : Handy library of utility functions
        Description :
        Handy library of utility functions. Development libs and headers are
        in gtk+-devel.
         


   Если дать команду:

        rpm -qpl glib-1.0.6-3.i386.rpm
         


   будет выдан список входящих в пакет файлов с указанием того, куда они
   будут установлены:

     /usr/lib/libglib.so.1
     /usr/lib/libglib.so.1.0.6


   RPM также предоставляет мощную систему запросов по установленным в
   системе пакетам. По команде

       rpm -qа


   Вы получите перечень всех установленных в системе пакетов (перечень
   будет очень большим, так что лучше сразу направить вывод в фильтр
   more). Вы можете искать информацию об отдельном пакете или об
   отдельных файлах. Например, Вы можете легко найти, какому пакету
   принадлежит файл и откуда появился:

       rpm -qf /etc/bashrc
       bash-1.14.7-16.


   Если Вы беспокоитесь о том, что случайно удалили важный файл из
   установленного пакета, просто проверьте это:

       rpm -Va


   Вы будете оповещены об любых аномалиях. Потом можно переустановить
   пакет, если это необходимо. Любые конфигурационные файлы будут
   сохранены.

   RPM это очень полезная утилита, и, как Вы видите, имеет различные
   опции. Я привел только несколько примеров. Всего rpm имеет 16 основных
   режимов работы, которые имеет смысл объединить в 6 групп (после
   двоеточия приводится формат команды для соответствующего режима):

   Запросы:
   
          Запрос : rpm [--query] [queryoptions]
          Показать метки запросов (Querytags) : rpm [--querytags]
           

   Установка и поддержка установленных пакетов:
   
          Установка : rpm [--install] [installoptions] [package_file]+
          Обновление : rpm [--freshen|-F] [installoptions]
          [package_file]+
          Деинсталляция : rpm [--uninstall|-e] [uninstalloptions]
          [package]+
          Проверка : rpm [--verify|-V] [verifyoptions] [package]+
           

   Подписи (пакеты подписываются электронной цифровой подписью в формате
  PGP, с целью обеспечения неизменяемости и сохранения авторства
  пакетов):
  
          Проверка подписи : rpm [--verify|-V] [verifyoptions] [package]+
          Переподписывание : rpm [--resign] [package_file]+
          Добавление подписи : rpm [--addsign] [package_file]+
           

   Работа с базой:
   
          Инициализация базы : rpm -i [--initdb]
          Rebuild Database: rpm -i [--rebuilddb]
           

   Создание rpm-пакетов:
   
          Создать пакет : rpm [-b|t] [package_spec]+
          Перекомпилировать пакет : rpm [--rebuild] [sourcerpm]+
          Build Package from Tarball: rpm [--tarbuild] [tarredsource]+
           

   Разное:
   
          Показать конфигурацию программы rpm : rpm [--showrc]
          Задать пользователей : rpm [--setperms] [package]+
          Задать группы : rpm [--setgids] [package]+
           

   Более подробное описание команды rpm Вы можете найти в RPM-HOWTO,
   страницах man и info. Здесь оно не приводится, в основном потому, что
   в графических режимах существуют несколько более удобные и
   "человечные" программы для управления установленным в системе ПО и
   процессами его обновления, которые и будут рассмотрены в следующих
   подразделах.

   Примечание:

   Я пользовался третьей версией RPM. В настоящее время существует уже
   версия 4, однако в списке рассылки blackcat-list промелькнуло такое
   сообщение:

   > Кто-либо имеет опыт установки rpm 4.x?
   > Хотелось бы установить пакеты из состава дистрибутива Red Hat 7.0.

   Сам пан Каневский ;-) не советовал ставить 4.х
   rpm-3.0.5-9.6x понимает структуру 4.х и ставит 4.х пакеты


## Установка ПО из исходных текстов

   В некоторых случаях исполняемые модули приложений могут поставляться и
   в виде tar-gz-архивов. В таком случае установка приложения только
   немного сложнее, чем в случае установки из rpm-пакета: необходимо
   просто развернуть архив и чаще всего можно уже запускать полученное
   приложение. Немного сложнее установить приложение, если оно
   поставляется в исходных текстах. Этот случай и рассмотрим в настоящем
   разделе.


## Необходимые сведения о программировании на языке Си

   Начать стоит с того, что операционная система UNIX родилась на свет
   одновременно с языком программирования C (Си). Более того, язык C был
   создан специально для разработки этой ОС, значительная часть UNIX была
   написана на языке С. ОС Linux тоже написана на Си. Поэтому, а также в
   соответствии с принципом свободного распространения исходных кодов,
   многие приложения для Линукс распространяются в виде текстов на С.
   Естественно, что для того, чтобы такое приложение установить в систему
   и запустить на исполнение, его необходимо скомпилировать. Для
   выполнения процедур компиляции обычно используется программа gcc (хотя
   существуют и некоторые альтернативные разработки).

   GNU-компилятор с языка С gcc, содержит в себе 4 основных компонента,
   соответствующие четырем этапам преобразования исходного кода в
   исполняемую программу.
   Первый компонент - это препроцессор, который модифицирует исходный код
   программы перед компиляцией в соответствии с командами препроцессора,
   содержащимися в С-программе. В соответствии с этими командами
   выполняются простые подстановки текста.
   Второй - собственно компилятор, который обрабатывает исходный код и
   преобразует его в код на языке ассемблера.
   Третий компонент - ассемблер, который генерирует объектный код.
   И, наконец, четвертый компонент - компоновщик, который собирает
   исполняемый файл из файлов объектного кода. Дело в том, что большие
   программы обычно пишутся по-частям, в виде множества отдельных файлов,
   содержащих исходный код соответствующей части. Компилятор обрабатывает
   каждый такой файл отдельно и создает отдельные объектные модули (файлы
   таких модулей обычно имеют расширение .o). Создание единой исполняемой
   программы из таких модулей и является задачей компоновщика. При таком
   подходе, если в какой-то модуль программист вносит исправление, нет
   необходимости заново компилировать всю программу: достаточно
   откомпилировать исправленный модуль и заново запустить компоновщик.

   Для выполнения стандартных операций программист может использовать
   функции из стандартных библиотек. Самый характерный пример - это
   библиотека libc, которая содержит функции, выполняющие такие задачи,
   как управление памятью и операции ввода-вывода. Программисты могут
   создать свои собственные библиотеки и использовать их при написании
   новых программ.

   Библиотеки бывают статическими, разделяемыми и динамическими.
   Статическая библиотека - это библиотека, код которой встраивается в
   программу при компиляции. Код разделяемой библиотеки не встраивается в
   программу, а загружается в память одновременно с программой и
   программа получает доступ к функциям этой библиотеки. Динамические
   библиотеки - разновидность разделяемых, только библиотечные функции
   загружаются в память только тогда, когда из программы поступит вызов
   соответствующей функции. В процессе выполнения программы они могут
   выгружаться и заменяться другими функциями из той же или другой
   библиотеки. Имена статических библиотек обычно имеют суффикс .a, а
   имена разделяемых библиотек - суффикс .so, за которым следует старший
   и младший номера версии. Имя может быть любой строкой, которая
   однозначно характеризует библиотеку. Обычно имена библиотек начинаются
   с lib. Примеры: libm.so.5 - общая математическая библиотека,
   libX11.so.6 - библиотека для работы с системой X Window. Библиотека
   libc.so.5 компонуется автоматически, в то время как большинство других
   библиотек необходимо явно указывать в командной строке при вызове
   программы gcc. Это делается через опцию -l за которой следует
   уникальная часть имени библиотеки, например, для вызова математической
   библиотеки достаточно указать -lm.

   Многие системные библиотеки располагаются в системных каталогах,
   например, в /usr/lib/ и /lib/, но некоторые могут располагаться и в
   других каталогах. Список этих каталогов помещается в файл
   /etc/ld.so.conf. Каждый раз, когда разделяемая библиотека изменяется
   или инсталлируется вновь, нужно выполнять команду ldconfig, чтобы
   обновить файл /etc/ld.so.conf, а также ссылки на него. Если библиотека
   инсталлируется из RPM-пакета, это обычно делается автоматически, хотя
   и не всегда.

   При компиляции больших программ, использующих фрагменты исходного
   кода, расположенные в разных файлах, бывает очень трудно отследить,
   какие файлы нужно перекомпилировать, а какие только компоновать. В
   таких случаях очень помогает утилита make, которая автоматически
   определяет, следует ли компилировать файл исходного кода, по дате его
   последней модификации. Утилита make оперирует файлами, исходя из их
   зависимости друг от друга. Эти зависимости определяются файлом с
   именем makefile. Строка файла makefile состоит из трех частей: имени
   целевого файла, списка файлов, от которых он зависит, и команды. Если
   какой-либо файл из списка изменился после целевого файла, то
   выполняется указанная в строке команда. В строке может быть указано
   несколько команд. Обычно команда - это вызов компилятора для
   компиляции файла исходного кода или компоновки файлов объектного кода.
   Строки, определяющие зависимости, отделяются друг от друга пустой
   строкой.


## Инсталляция пакетов ПО из исходных текстов

   Теперь, когда мы получили первое впечатление о том, как осуществляется
   компиляция программ на языке С, можно перейти к рассмотрению того, как
   обращаться с пакетами программ, распространяемыми в виде исходных
   кодов. Первое, что надо сказать в этой связи, это то, что для
   установки таких пакетов Вы, естественно, должны иметь в своей системе
   утилиты gcc и make.

   Непосредственно процесс инсталляции пакета состоит из следующих шагов:

   1. Перейти (с помощью команды `cd') в каталог, содержащий исходные
   коды устанавливаемого пакета.


   2. Выполнить команду `./configure', которая осуществляет
   конфигурирование пакета в соответствии с Вашей системой. Процесс
   выполнения этой команды занимает довольно длительное время, причем
   команда выдает на экран сообщения, сообщающие, какие именно
   особенности системы испытываются.


   3. Выполнить команду `make', для того, чтобы скомпилировать пакет.


   4. После этого можно выполнить (это шаг не является обязательным)
   команду `make check', которая вызывает запуск процедур
   самотестирования, которые поставляются с пакетом.


   5. Выполнить команду `make install' для установки программ, а также
   файлов данных и документации.


   6. Заключительный этап состоит в выполнении команды \`make clean\',
   которая удаляет промежуточные объектные и двоичные файлы из каталога с
   исходными кодами. Для удаления временных файлов, которые создала
   команда \`configure' (после чего пакет можно компилировать для другого
   типа компьютеров), надо выполнить команду `make distclean'.


   В большинстве случаев выполнение этой последовательности команд
   достаточно для установки нового пакета.


## Сколько осталось места на диске

   При установке новых пакетов очень часто возникает одна проблема,
   хорошо знакомая всем пользователям компьютеров: недостаток дискового
   пространства. Поэтому перед установкой нового пакета надо вначале
   ответить на вопрос о том, достаточно ли места на диске для размещения
   данного ПО?

   Программа rpm позволяет определить, сколько места потребуется для
   установки пакета: для этого надо дать запрос вида rpm -qpi имя_пакета
   и в строке Size будет выдано, сколько байт займет пакет. Осталось
   узнать, есть ли столько свободного места на диске.

   Для определения обьема свободного пространства на диске Вы можете
   воспользоваться командой df. Если дать эту команду без аргументов, то
   она сообщит каков объем дискового пространства во всех смонтированных
   файловых системах, сколько используется и сколько еще свободно.
   Единицей измерения при этом служит 1 килобайтный блок. Если Вы хотите
   получить сведения об объеме свободного пространства в более привычных
   мегабайтах, дайте команду с параметром -h:

           df -h


   Сведения о количестве свободного пространства на конкретном диске
   можно получить, если задать в качестве параметра имя файла устройства:

           df -h /dev/hda2


   Если вместо имени файла устройства указать полное (с указанием пути)
   имя произвольного файла или каталога, то Вы получите данные о
   количестве используемого и свободного места в файловой системе,
   содержащей указанный файл (каталог).

   Если место еще есть, то можно перейти к установке пакета. Хуже
   владельцам компьютеров с дисками маленького объема: тут каждый раз
   надо думать, как бы освободить место для новой программы, другими
   словами, что уже можно с диска удалить. Удалять можно отдельные файлы,
   но, конечно, с точки зрения освобождения пространства, эффективнее
   удалять целыми каталогами или пакетами.

   Файлы (каталоги) удаляются в том случае, если они (размещенные в них
   файлы) Вам более не нужны. Естественно, что для удаления выбираются
   каталоги (или файлы) самого большого обьема и тут оказывается полезной
   команда du (disc usage).

   Команда du позволяет узнать, сколько места занимает конкретный файл
   или подкаталог. Для этого надо дать команду следующего формата (в
   примере мы узнаем объем каталога /usr/lib )

           du -ks /usr/lib


   Результатом выполнения данной команды будет примерно такая строка

           91418 /usr/lib


   которая означает, что каталог /usr/lib занимает 91418 килобайт (опция
   k указывает, что объем должен выдаваться в килобайтах). Опция s задана
   для того, чтобы выводился только суммарный объем каталога. Если Вы ее
   опустите, то получите данные об объеме каждого подкаталога и файла в
   указанном каталоге, а это очень много информации. Впрочем, последней
   строкой все равно будет выведен суммарный объем каталога, так что если
   Вас завораживает мелькание строк на экране, можете доставить себе это
   маленькое удовольствие.

   Если маленькую s заменить на большую S, то выводиться будет только
   информация об объеме подкаталогов (но не файлов), что иногда тоже
   полезно. О других опциях указанных команд Вы можете узнать на
   соответствующих man-страницах или по команде info.

   Теперь Вы знаете, как определить сколько места займет на диске
   устанавливаемый пакет и каков объем свободного пространства на диске.
   Рассмотрим, что можно сделать, если свободного места не достаточно.
   Надо заметить, что при стандартной инсталляции ОС Linux на диске
   образуется большое количество файлов, которые Вам вообще никогда не
   понадобятся. В то же время довольно трудно в огромной массе файлов
   найти те, которые Вам не нужны (тем более, что они спрятаны глубоко в
   дебрях структуры каталогов). Поэтому я расскажу вкратце о своем опыте
   поиска ненужных файлов, надеясь, что этот опыт окажется полезен
   читателю.


## Освобождение дискового пространства

   Однажды мне пришлось устанавливать Линукс (Black Cat 6.0) на 486-ой
   компьютер с жестким диском объемом 350 Мбайт. Хотя при установке я
   старался выбрать минимально возможную конфигурацию ПО, все равно после
   завершения установки диск оказался заполнен более чем на 90 %.
   Перечислю вкратце те действия, которые позволили мне освободить
   достаточно места на диске для установки новых пакетов.

   1. Первым делом стоит подумать об удалении части пакетов ПО,
   установленных при инсталляции системы. Для того, чтобы решить, какой
   пакет или пакеты можно удалить, дайте команду:


           %rpm -qa --queryformat "%15{SIZE} %{NAME}\n" | sort -nr
           %rpm -q -a > packages
            
             
    


   Полученный файл packages будет содержать список всех установленных в
   системе пакетов ПО. Этот список можно проанализировать с целью
   выявления ненужных Вам пакетов и удалить таковые с помощью команды rpm
   с параметром -e. При этом будут удалены все созданные при инсталляции
   пакета файлы и каталоги. Этот способ самый безопасный, поскольку
   программа rpm предварительно проверит, не используется ли данный пакет
   какой-либо другой программой, и при наличии такой зависимости выдаст
   соответствующее предупреждение, а удалять что-либо откажется.

   У меня, например, в полученном таким образом файле packages
   встретилось упоминание пакета AfterStep-APPS-990329-2. Выполнив
   команду:

        % rpm -qi AfterStep-APPS


   выяснил, что этот пакет содержит некие апплеты к оконному менеджеру
   AfterStep. Поскольку такой менеджер не использовал, удалил этот пакет,
   а также и сам пакет AfterStep, с помощью команд:

        % rpm -e AfterStep
        % rpm -e AfterStep-APPS


   Это освободило около 5800 Кбайт (отмечу только, что удаление пакетов
   надо выполнять с правами root-а). Воспользовавшись таким приемом Вы
   можете удалить все пакеты, которые не используете. Я, например, удалил
   такие пакеты, как gnome-core, gnome-libs, gnome-audio, поскольку в
   качестве графической среды использую не Gnome, а KDE. Отмечу, что
   когда я попытался удалить gnome-core, rpm отказалась это сделать,
   сообщив, что часть этого пакета используется пакетом xmms-gnome. Еще
   больше неудовлетворенных зависимостей образуется при попытке удалить
   gnome-libs. Однако поскольку все упоминавшиеся в этих сообщениях
   пакеты так или иначе были связаны с Gnome, я рискнул удалить их все, а
   также другие пакеты, которые были с ними связаны. В результате
   освободилось около 7800 Кбайт дискового пространства.

   2. Заглянув в каталог /usr/man, я обнаружил два подкаталога со
   страницами руководства man на французском и испанском языках. После их
   удаления освободилось около 100 Кбайт.


   3. В каталоге /usr/lib/kbd/keymaps можно, по-видимому, удалить
   подкаталоги, в которых хранятся таблицы раскладок клавиатуры,
   предназначенные для других типов микропроцессоров, а в
   /usr/lib/kbd/keymaps/i386 -подкаталоги для раскладок, отличных от
   qwerty.
   
   
   Аналогичным образом удаляются раскладки клавиатуры для различных
   языков, которыми Вы не пользуетесь (зачем мне китайский или тайский, я
   не знаю на них ни одного слова!). Эти шрифты расположены в каталоге
   /usr/lib/kbd/keymaps/i386/qwerty.
   
   Можно попробовать удалить ненужные фонты из /usr/lib/kbd/consolefonts,
   однако если в начале таблицы раскладки клавиатуры указывается, для
   какого языка она служит, то о назначении файла фонта приходиться
   судить по его названию.

   Поскольку по умолчанию в системе устанавливаются средства локализации
   для различных стран (которые Вам, по-видимому, не потребуются), то
   можно удалить из каталога /usr/share/locale все подкаталоги,
   соответствующие не нужным Вам языкам. Всего там около 16 мегабайт, так
   что удаление ненужного может дать около 15 мегабайт освобожденного
   пространства. Еще более 2 мегабайт может дать очистка каталогов
   /usr/share/i18n/locales и /usr/share/i18n/charmaps



   4. В каталоге /usr/share/doc/HTML/ имеются подкаталоги с документацией
   на разных языках, значительная часть которой Вам, по-видимому, не
   нужна. Я оставил в этом каталоге только три подкаталога en, ru
   default, причем последний является просто ссылкой на подкаталог en,
   так что фактически там только 2 подкаталога осталось. Удаление этой
   документации освободило около 500 Кбайт.