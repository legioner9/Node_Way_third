## Архитектура и проектирование программного обеспечения

Билет содержит два теоретических вопроса и одно практическое задание.

### Теоретические вопросы на экзамен

Экзамен письменный, писать нужно разборчиво, иначе нужно будет зачитать свое творение или давать пояснения устно.

1. Что такое архитектура ПО, основные ее задачи и методы
2. Обзор топологий компоновки программных компонентов
3. Клиент-серверная архитектура и трехуровневая (трехзвенная) архитектура
4. Слои абстракции в программных системах и примеры слоев абстракции
5. Модульность и подходы к ее реализации
6. Принцип инверсии управления IoC (Inversion of Control)
7. Принцип инверсии зависимостей DIP (Dependency Inversion Principle)
8. Принцип внедрения зависимостей (Dependency Injection)
9. Связь принципа инверсии управления (IoC) и внедрения зависимостей (DI)
10. Разница между внедрением зависимостей (DI) и Dependency Lookup (DL)
11. Понятие программного интерфейса (API)
12. Обертки (wrappers) и примеры их применения
13. Основные парадигмы программирования и сферы их применения
14. Разница между прототипным наследованием и классовым
15. Парадигма функционального программирования и его задачи
16. Разница между императивным и декларативным программированием
17. Событийно-ориентированное программирование и принцип работы EventEmitter
18. Асинхронное программирование и особенности асинхронного кода
19. Блокирующий и неблокирующий ввод/вывод (non-blocking I/O)
20. Понятие метаданных, метапрограммирование и его различные реализации
21. Программирование, управляемое данными (Data-driven Programming)
22. Межпроцессное взаимодействие (Interprocess Communication), классификация
23. Балансировка нагрузки в многопоточных приложениях, серверная и клиентская
24. Понятия сетевого протокола, сокета и порта
25. Непрерывная интеграция CI (Continuous integration)
26. Системы контроля версий, их задачи и применение
27. Семейство паттернов MV* и их место в программных системах
28. Реактивное программирование с примерами использования
29. Стиль кода и необходимость использования соглашений о стиле
30. Рефакторинг и декомпозиция кода, повышение уровня абстракции кода
31. Языки с ручным и автоматическим управлением памятью
32. Сборщики мусора и подсчет ссылок, утечки памяти и их предотвращение
33. Классификация языков программирования по уровню абстракции
34. Классификация языков программирования по управлению памятью
35. Языки со статической и динамической типизацией
36. Сильная и слабая типизация, явная и неявная типизация
37. Принцип утиной типизации и проблемы, которые она решает (duck typing)
38. Раннее и позднее связывание, сильная и слабая связность кода
39. Статическое и динамическое связывание
40. Классификация способов непрямого наследования
41. Примеси и их применение для непрямого наследования (mixin)
42. Принцип композиции как замена наследованию
43. Понятие функции высшего порядка и суперпозиции функций
44. Анонимные функции и передача функций как аргументов
45. Каррирование и частичное применение функций (currying)
46. Замыкания (closure) и их применение, для чего используется, как работает
47. Контексты и управление видимостью в контекстах
48. Оптимизирующие компиляторы и их особенности
49. Специализированные языки DSL (Domain Specific Language)
50. Классификация DSL (Domain Specific Language)
51. BNF, ABNF, регулярные выражения и синтаксисы
52. Причины создания языков высокого уровня абстракции
53. Глобальное состояние и комбинаторный взрыв
54. Способы минимизации глобального состояния
55. Использование итераторов и масштабирование вычислений
56. Использование хешей (ассоциативных массивов) как замена if/switch
57. Организация слоя доступа к данным DAC (Data Access Layer)
58. Место кода бизнес-логики, интерфейсов и фреймворка в архитектуре ПО
59. Экранирование модулей приложения друг от друга (sandboxing)
60. Парсинг, сериализация и десериализация (serialization)

### Практические задания на экзамен

Задачи не публикуются, но будут связаны с лабораторными и лекциями курса.
Для реализация практического задания можно использовать любой язык программирования, который позволяет решить задачу.
