<!-- Start Document Outline -->

* [выполняемая программа - это динамический объект,](#выполняемая-программа---это-динамический-объект)
* [Под архитектурой операционной системы понимают](#под-архитектурой-операционной-системы-понимают)
* [Интерфейс в широком смысле](#интерфейс-в-широком-смысле)
* [Мультипрограммирование (многозадачность, multitasking)](#мультипрограммирование-многозадачность-multitasking)
* [планированием.](#планированием)
* [Диспетчеризация](#диспетчеризация)
* [В 1981 году Петерсон (Peterson)](#в-1981-году-петерсон-peterson)
* [подход Хансена.](#подход-хансена)

<!-- End Document Outline --> 

В отличие от программы, которая является статическим
объектом, 
# выполняемая программа - это динамический объект,
он называется процессом и является базовым понятием современных ОС.

# Под архитектурой операционной системы понимают
структурную и
функциональную организацию ОС на основе некоторой совокупности
программных модулей. В состав ОС входят исполняемые и объектные
модули стандартных для данной ОС форматов , программные модули
специального формата (например, загрузчик ОС, драйверы вводавывода),
конф,tгурационные файлы, файлы документации, модули
справочной системы и т.д.

#  Интерфейс в широком смысле
- определенная стандартами граница
между взаимодействующими независимыми объектами. Интерфейс
задает параметры, процедуры и характеристики взаимодействия
объектов.

# Мультипрограммирование (многозадачность, multitasking)
– это такой способ организации вычислительного процесса, при котором на одном процессоре попеременно выполняются несколько программ. Чтобы поддерживать мультипрограммирование, ОС должна определить для себя внутренние единицы работы, между которыми будут разделяться процессор и другие ресурсы компьютера. В ОС пакетной обработки, распространенных в компьютерах второго и сначала и третьего поколения, такой единицей работы было задание. В настоящее время в большинстве операционных систем определены два типа единиц работы: более крупная единица – процесс, или задача, и менее крупная – поток, или нить. Причем процесс выполняется в форме одного или нескольких потоков.

Работа по определению момента, в который необходимо прервать выполнение текущего потока, и потока, которому следует предоставить возможность выполняться, называется
# планированием. 

# Диспетчеризация 
заключается в реализации найденного в результате планирования решения, т.е. в переключении процессора с одного потока на другой. Диспетчеризация проходит в три этапа:

* сохранение контекста текущего потока;
* загрузка контекста потока, выбранного в результате планирования;
* запуск нового потока на выполнение.

# В 1981 году Петерсон (Peterson) 
предложил более изящное решение. Пусть оба процесса имеют доступ к массиву флагов готовности и к переменной очередности.

    shared int ready[2] = {0, 0};
    shared int turn;
    while (some condition)
      {
        ready[i] = 1;
        turn =1- i; 
        while(ready[1-i] && turn == 1-i);
        critical section
        ready[i] = 0;
        remainder section
      }
      

Несколько позже Хансен (Hansen) предложил другой механизм: разбудивший процесс покидает монитор немедленно после исполнения операции signal. Рассмотрим 
# подход Хансена. 
Применим концепцию мониторов к решению задачи "производитель-потребитель".

    monitor ProducerConsumer 
      {
        condition full, empty;
        int count;
        void put()
     {
        if(count == N) full.wait;
        put_item;
        count += 1;
       if(count == 1) empty.signal;
      }
        void get()
      {
       if (count == 0) empty.wait;
      get_item();
      count -= 1;
      if(count == N-1) full.signal;
      }
      {
        count = 0;
      }
        }
          Producer:
          while(1)
        {
        produce_item;ProducerConsumer.put();
        }
       Consumer:
       while(1)
         {
           ProducerConsumer.get();
           consume_item;
    }




